20190526_235222,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_b19200
package cgeo.geocaching;

import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.LiveMapStrategy.Strategy;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.maps.MapProviderFactory;
import cgeo.geocaching.maps.interfaces.MapProvider;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider;
import cgeo.geocaching.utils.CryptUtils;
import cgeo.geocaching.utils.Log;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.preference.PreferenceManager;

import java.util.Locale;

/**
 * General c:geo preferences/settings set by the user
 */
public final class Settings {

    private static final String KEY_TEMP_TOKEN_SECRET = "temp-token-secret";
    private static final String KEY_TEMP_TOKEN_PUBLIC = "temp-token-public";
    private static final String KEY_HELP_SHOWN = "helper";
    private static final String KEY_ANYLONGITUDE = "anylongitude";
    private static final String KEY_ANYLATITUDE = "anylatitude";
    private static final String KEY_PUBLICLOC = "publicloc";
    private static final String KEY_USE_OFFLINEMAPS = "offlinemaps";
    private static final String KEY_USE_OFFLINEWPMAPS = "offlinewpmaps";
    private static final String KEY_WEB_DEVICE_CODE = "webDeviceCode";
    private static final String KEY_WEBDEVICE_NAME = "webDeviceName";
    private static final String KEY_MAP_LIVE = "maplive";
    private static final String KEY_MAP_SOURCE = "mapsource";
    private static final String KEY_USE_TWITTER = "twitter";
    private static final String KEY_SHOW_ADDRESS = "showaddress";
    private static final String KEY_SHOW_CAPTCHA = "showcaptcha";
    private static final String KEY_MAP_TRAIL = "maptrail";
    private static final String KEY_LAST_MAP_ZOOM = "mapzoom";
    private static final String KEY_LIVE_LIST = "livelist";
    private static final String KEY_METRIC_UNITS = "units";
    private static final String KEY_SKIN = "skin";
    private static final String KEY_LAST_USED_LIST = "lastlist";
    private static final String KEY_CACHE_TYPE = "cachetype";
    private static final String KEY_TWITTER_TOKEN_SECRET = "tokensecret";
    private static final String KEY_TWITTER_TOKEN_PUBLIC = "tokenpublic";
    private static final String KEY_VERSION = "version";
    private static final String KEY_LOAD_DESCRIPTION = "autoloaddesc";
    private static final String KEY_RATING_WANTED = "ratingwanted";
    private static final String KEY_ELEVATION_WANTED = "elevationwanted";
    private static final String KEY_FRIENDLOGS_WANTED = "friendlogswanted";
    private static final String KEY_USE_ENGLISH = "useenglish";
    private static final String KEY_USE_COMPASS = "usecompass";
    private static final String KEY_AUTO_VISIT_TRACKABLES = "trackautovisit";
    private static final String KEY_AUTO_INSERT_SIGNATURE = "sigautoinsert";
    private static final String KEY_ALTITUDE_CORRECTION = "altcorrection";
    private static final String KEY_USE_GOOGLE_NAVIGATION = "usegnav";
    private static final String KEY_STORE_LOG_IMAGES = "logimages";
    private static final String KEY_EXCLUDE_DISABLED = "excludedisabled";
    private static final String KEY_EXCLUDE_OWN = "excludemine";
    private static final String KEY_MAPFILE = "mfmapfile";
    private static final String KEY_SIGNATURE = "signature";
    private static final String KEY_GCVOTE_PASSWORD = "pass-vote";
    private static final String KEY_PASSWORD = "password";
    private static final String KEY_USERNAME = "username";
    private static final String KEY_MEMBER_STATUS = "memberstatus";
    private static final String KEY_COORD_INPUT_FORMAT = "coordinputformat";
    private static final String KEY_LOG_OFFLINE = "log_offline";
    private static final String KEY_LOAD_DIRECTION_IMG = "loaddirectionimg";
    private static final String KEY_GC_CUSTOM_DATE = "gccustomdate";
    private static final String KEY_SHOW_WAYPOINTS_THRESHOLD = "gcshowwaypointsthreshold";
    private static final String KEY_COOKIE_STORE = "cookiestore";
    private static final String KEY_OPEN_LAST_DETAILS_PAGE = "opendetailslastpage";
    private static final String KEY_LAST_DETAILS_PAGE = "lastdetailspage";
    private static final String KEY_DEFAULT_NAVIGATION_TOOL = "defaultNavigationTool";
    private static final String KEY_DEFAULT_NAVIGATION_TOOL_2 = "defaultNavigationTool2";
    private static final String KEY_LIVE_MAP_STRATEGY = "livemapstrategy";
    private static final String KEY_DEBUG = "debug";
    private static final String KEY_HIDE_LIVE_MAP_HINT = "hidelivemaphint";
    private static final String KEY_LIVE_MAP_HINT_SHOW_COUNT = "livemaphintshowcount";
    private static final String KEY_SETTINGS_VERSION = "settingsversion";

    private final static int unitsMetric = 1;

    // twitter api keys
    private final static String keyConsumerPublic = CryptUtils.rot13("ESnsCvAv3kEupF1GCR3jGj");
    private final static String keyConsumerSecret = CryptUtils.rot13("7vQWceACV9umEjJucmlpFe9FCMZSeqIqfkQ2BnhV9x");

    private interface PrefRunnable {
        void edit(final Editor edit);
    }

    public enum coordInputFormatEnum {
        Plain,
        Deg,
        Min,
        Sec;

        static coordInputFormatEnum fromInt(int id) {
            final coordInputFormatEnum[] values = coordInputFormatEnum.values();
            if (id >= 0 && id < values.length) {
                return values[id];
            } else {
                return Min;
            }
        }
    }

    private static String username = null;
    private static String password = null;

    private static final SharedPreferences sharedPrefs = PreferenceManager.getDefaultSharedPreferences(cgeoapplication.getInstance().getBaseContext());
    static {
        migrateSettings();
        Log.setDebugUnsaved(sharedPrefs.getBoolean(KEY_DEBUG, false));
    }

    // maps
    private static MapProvider mapProvider = null;

    private Settings() {
        // this class is not to be instantiated;
    }

    private static void migrateSettings() {
        // migrate from non standard file location and integer based boolean types
        if (sharedPrefs.getInt(KEY_SETTINGS_VERSION, 0) < 1) {
            final String oldPreferencesName = "cgeo.pref";
            final SharedPreferences old = cgeoapplication.getInstance().getSharedPreferences(oldPreferencesName, Context.MODE_PRIVATE);
            final Editor e = sharedPrefs.edit();

            e.putString(KEY_TEMP_TOKEN_SECRET, old.getString(KEY_TEMP_TOKEN_SECRET, null));
            e.putString(KEY_TEMP_TOKEN_PUBLIC, old.getString(KEY_TEMP_TOKEN_PUBLIC, null));
            e.putBoolean(KEY_HELP_SHOWN, old.getInt(KEY_HELP_SHOWN, 0) != 0);
            e.putFloat(KEY_ANYLONGITUDE, old.getFloat(KEY_ANYLONGITUDE, 0));
            e.putFloat(KEY_ANYLATITUDE, old.getFloat(KEY_ANYLATITUDE, 0));
            e.putBoolean(KEY_PUBLICLOC, 0 != old.getInt(KEY_PUBLICLOC, 0));
            e.putBoolean(KEY_USE_OFFLINEMAPS, 0 != old.getInt(KEY_USE_OFFLINEMAPS, 1));
            e.putBoolean(KEY_USE_OFFLINEWPMAPS, 0 != old.getInt(KEY_USE_OFFLINEWPMAPS, 0));
            e.putString(KEY_WEB_DEVICE_CODE, old.getString(KEY_WEB_DEVICE_CODE, null));
            e.putString(KEY_WEBDEVICE_NAME, old.getString(KEY_WEBDEVICE_NAME, null));
            e.putBoolean(KEY_MAP_LIVE, old.getInt(KEY_MAP_LIVE, 1) != 0);
            e.putInt(KEY_MAP_SOURCE, old.getInt(KEY_MAP_SOURCE, 0));
            e.putBoolean(KEY_USE_TWITTER, 0 != old.getInt(KEY_USE_TWITTER, 0));
            e.putBoolean(KEY_SHOW_ADDRESS, 0 != old.getInt(KEY_SHOW_ADDRESS, 1));
            e.putBoolean(KEY_SHOW_CAPTCHA, old.getBoolean(KEY_SHOW_CAPTCHA, false));
            e.putBoolean(KEY_MAP_TRAIL, old.getInt(KEY_MAP_TRAIL, 1) != 0);
            e.putInt(KEY_LAST_MAP_ZOOM, old.getInt(KEY_LAST_MAP_ZOOM, 14));
            e.putBoolean(KEY_LIVE_LIST, 0 != old.getInt(KEY_LIVE_LIST, 1));
            e.putBoolean(KEY_METRIC_UNITS, old.getInt(KEY_METRIC_UNITS, unitsMetric) == unitsMetric);
            e.putBoolean(KEY_SKIN, old.getInt(KEY_SKIN, 0) != 0);
            e.putInt(KEY_LAST_USED_LIST, old.getInt(KEY_LAST_USED_LIST, StoredList.STANDARD_LIST_ID));
            e.putString(KEY_CACHE_TYPE, old.getString(KEY_CACHE_TYPE, CacheType.ALL.id));
            e.putString(KEY_TWITTER_TOKEN_SECRET, old.getString(KEY_TWITTER_TOKEN_SECRET, null));
            e.putString(KEY_TWITTER_TOKEN_PUBLIC, old.getString(KEY_TWITTER_TOKEN_PUBLIC, null));
            e.putInt(KEY_VERSION, old.getInt(KEY_VERSION, 0));
            e.putBoolean(KEY_LOAD_DESCRIPTION, 0 != old.getInt(KEY_LOAD_DESCRIPTION, 0));
            e.putBoolean(KEY_RATING_WANTED, old.getBoolean(KEY_RATING_WANTED, true));
            e.putBoolean(KEY_ELEVATION_WANTED, old.getBoolean(KEY_ELEVATION_WANTED, true));
            e.putBoolean(KEY_FRIENDLOGS_WANTED, old.getBoolean(KEY_FRIENDLOGS_WANTED, true));
            e.putBoolean(KEY_USE_ENGLISH, old.getBoolean(KEY_USE_ENGLISH, false));
            e.putBoolean(KEY_USE_COMPASS, 0 != old.getInt(KEY_USE_COMPASS, 1));
            e.putBoolean(KEY_AUTO_VISIT_TRACKABLES, old.getBoolean(KEY_AUTO_VISIT_TRACKABLES, false));
            e.putBoolean(KEY_AUTO_INSERT_SIGNATURE, old.getBoolean(KEY_AUTO_INSERT_SIGNATURE, false));
            e.putInt(KEY_ALTITUDE_CORRECTION, old.getInt(KEY_ALTITUDE_CORRECTION, 0));
            e.putBoolean(KEY_USE_GOOGLE_NAVIGATION, 0 != old.getInt(KEY_USE_GOOGLE_NAVIGATION, 1));
            e.putBoolean(KEY_STORE_LOG_IMAGES, old.getBoolean(KEY_STORE_LOG_IMAGES, false));
            e.putBoolean(KEY_EXCLUDE_DISABLED, 0 != old.getInt(KEY_EXCLUDE_DISABLED, 0));
            e.putBoolean(KEY_EXCLUDE_OWN, 0 != old.getInt(KEY_EXCLUDE_OWN, 0));
            e.putString(KEY_MAPFILE, old.getString(KEY_MAPFILE, null));
            e.putString(KEY_SIGNATURE, old.getString(KEY_SIGNATURE, null));
            e.putString(KEY_GCVOTE_PASSWORD, old.getString(KEY_GCVOTE_PASSWORD, null));
            e.putString(KEY_PASSWORD, old.getString(KEY_PASSWORD, null));
            e.putString(KEY_USERNAME, old.getString(KEY_USERNAME, null));
            e.putString(KEY_MEMBER_STATUS, old.getString(KEY_MEMBER_STATUS, ""));
            e.putInt(KEY_COORD_INPUT_FORMAT, old.getInt(KEY_COORD_INPUT_FORMAT, 0));
            e.putBoolean(KEY_LOG_OFFLINE, old.getBoolean(KEY_LOG_OFFLINE, false));
            e.putBoolean(KEY_LOAD_DIRECTION_IMG, old.getBoolean(KEY_LOAD_DIRECTION_IMG, true));
            e.putString(KEY_GC_CUSTOM_DATE, old.getString(KEY_GC_CUSTOM_DATE, null));
            e.putInt(KEY_SHOW_WAYPOINTS_THRESHOLD, old.getInt(KEY_SHOW_WAYPOINTS_THRESHOLD, 0));
            e.putString(KEY_COOKIE_STORE, old.getString(KEY_COOKIE_STORE, null));
            e.putBoolean(KEY_OPEN_LAST_DETAILS_PAGE, old.getBoolean(KEY_OPEN_LAST_DETAILS_PAGE, false));
            e.putInt(KEY_LAST_DETAILS_PAGE, old.getInt(KEY_LAST_DETAILS_PAGE, 1));
            e.putInt(KEY_DEFAULT_NAVIGATION_TOOL, old.getInt(KEY_DEFAULT_NAVIGATION_TOOL, 0));
            e.putInt(KEY_DEFAULT_NAVIGATION_TOOL_2, old.getInt(KEY_DEFAULT_NAVIGATION_TOOL_2, 0));
            e.putInt(KEY_LIVE_MAP_STRATEGY, old.getInt(KEY_LIVE_MAP_STRATEGY, Strategy.AUTO.id));
            e.putBoolean(KEY_DEBUG, old.getBoolean(KEY_DEBUG, false));
            e.putBoolean(KEY_HIDE_LIVE_MAP_HINT, old.getInt(KEY_HIDE_LIVE_MAP_HINT, 0) != 0);
            e.putInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, old.getInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, 0));

            e.putInt(KEY_SETTINGS_VERSION, 1) ; // mark migrated
            e.commit();
        }
    }

    public static void setLanguage(boolean useEnglish) {
        final Configuration config = new Configuration();
        config.locale = useEnglish ? new Locale("en") : Locale.getDefault();
        final Resources resources = cgeoapplication.getInstance().getResources();
        resources.updateConfiguration(config, resources.getDisplayMetrics());
    }

    public static boolean isLogin() {
        final String preUsername = sharedPrefs.getString(KEY_USERNAME, null);
        final String prePassword = sharedPrefs.getString(KEY_PASSWORD, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    /**
     * Get login and password information.
     *
     * @return a pair (login, password) or null if no valid information is stored
     */
    public static ImmutablePair<String, String> getLogin() {
        if (username == null || password == null) {
            final String preUsername = sharedPrefs.getString(KEY_USERNAME, null);
            final String prePassword = sharedPrefs.getString(KEY_PASSWORD, null);

            if (preUsername == null || prePassword == null) {
                return null;
            }

            username = preUsername;
            password = prePassword;
        }
        return new ImmutablePair<String, String>(username, password);
    }

    public static String getUsername() {
        if (null == username) {
            return sharedPrefs.getString(KEY_USERNAME, null);
        } else {
            return username;
        }
    }

    public static boolean setLogin(final String username, final String password) {
        Settings.username = username;
        Settings.password = password;
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
                    // erase username and password
                    edit.remove(KEY_USERNAME);
                    edit.remove(KEY_PASSWORD);
                } else {
                    // save username and password
                    edit.putString(KEY_USERNAME, username);
                    edit.putString(KEY_PASSWORD, password);
                }
            }
        });
    }

    public static boolean isPremiumMember() {
        // Basic Member, Premium Member, ???
        String memberStatus = Settings.getMemberStatus();
        if (memberStatus == null) {
            return false;
        }
        return "Premium Member".equalsIgnoreCase(memberStatus);
    }

    public static String getMemberStatus() {
        return sharedPrefs.getString(KEY_MEMBER_STATUS, "");
    }

    public static boolean setMemberStatus(final String memberStatus) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(memberStatus)) {
                    edit.remove(KEY_MEMBER_STATUS);
                } else {
                    edit.putString(KEY_MEMBER_STATUS, memberStatus);
                }
            }
        });
    }

    public static boolean isGCvoteLogin() {
        final String preUsername = sharedPrefs.getString(KEY_USERNAME, null);
        final String prePassword = sharedPrefs.getString(KEY_GCVOTE_PASSWORD, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    public static boolean setGCvoteLogin(final String password) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(password)) {
                    // erase password
                    edit.remove(KEY_GCVOTE_PASSWORD);
                } else {
                    // save password
                    edit.putString(KEY_GCVOTE_PASSWORD, password);
                }
            }
        });
    }

    public static ImmutablePair<String, String> getGCvoteLogin() {
        final String username = sharedPrefs.getString(KEY_USERNAME, null);
        final String password = sharedPrefs.getString(KEY_GCVOTE_PASSWORD, null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return null;
        }

        return new ImmutablePair<String, String>(username, password);
    }

    public static boolean setSignature(final String signature) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(signature)) {
                    // erase signature
                    edit.remove(KEY_SIGNATURE);
                } else {
                    // save signature
                    edit.putString(KEY_SIGNATURE, signature);
                }
            }
        });
    }

    public static String getSignature() {
        return sharedPrefs.getString(KEY_SIGNATURE, null);
    }

    public static boolean setCookieStore(final String cookies) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(final Editor edit) {
                if (StringUtils.isBlank(cookies)) {
                    // erase cookies
                    edit.remove(KEY_COOKIE_STORE);
                } else {
                    // save cookies
                    edit.putString(KEY_COOKIE_STORE, cookies);
                }
            }
        });
    }

    public static String getCookieStore() {
        return sharedPrefs.getString(KEY_COOKIE_STORE, null);
    }

    /**
     * @param cacheType
     *            The cache type used for future filtering
     */
    public static void setCacheType(final CacheType cacheType) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                if (cacheType == null) {
                    edit.remove(KEY_CACHE_TYPE);
                } else {
                    edit.putString(KEY_CACHE_TYPE, cacheType.id);
                }
            }
        });
    }

    public static void setLiveMap(final boolean live) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_MAP_LIVE, live);
            }
        });
    }

    public static int getLastList() {
        final int listId = sharedPrefs.getInt(KEY_LAST_USED_LIST, StoredList.STANDARD_LIST_ID);

        return listId;
    }

    public static void saveLastList(final int listId) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_USED_LIST, listId);
            }
        });
    }

    public static void setWebNameCode(final String name, final String code) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {

                edit.putString(KEY_WEBDEVICE_NAME, name);
                edit.putString(KEY_WEB_DEVICE_CODE, code);
            }
        });
    }

    public static MapProvider getMapProvider() {
        if (mapProvider == null) {
            mapProvider = MapProviderFactory.getMapProvider(getMapSource());
        }
        return mapProvider;
    }

    public static String getMapFile() {
        return sharedPrefs.getString(KEY_MAPFILE, null);
    }

    public static boolean setMapFile(final String mapFile) {
        final boolean commitResult = editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_MAPFILE, mapFile);
            }
        });

        return commitResult;
    }

    public static boolean isValidMapFile(final String mapFileIn) {
        return MapsforgeMapProvider.isValidMapFile(mapFileIn);
    }

    public static coordInputFormatEnum getCoordInputFormat() {
        return coordInputFormatEnum.fromInt(sharedPrefs.getInt(KEY_COORD_INPUT_FORMAT, 0));
    }

    public static void setCoordInputFormat(final coordInputFormatEnum format) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_COORD_INPUT_FORMAT, format.ordinal());
            }
        });
    }

    static void setLogOffline(final boolean offline) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LOG_OFFLINE, offline);
            }
        });
    }

    public static boolean getLogOffline() {
        return sharedPrefs.getBoolean(KEY_LOG_OFFLINE, false);
    }

    static void setLoadDirImg(final boolean value) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LOAD_DIRECTION_IMG, value);
            }
        });
    }

    public static boolean getLoadDirImg() {
        return isPremiumMember() ? false : sharedPrefs.getBoolean(KEY_LOAD_DIRECTION_IMG, true);
    }

    public static void setGcCustomDate(final String format) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_GC_CUSTOM_DATE, format);
            }
        });
    }

    /**
     * @return User selected date format on GC.com
     * @see cgBase.gcCustomDateFormats
     */
    public static String getGcCustomDate() {
        return sharedPrefs.getString(KEY_GC_CUSTOM_DATE, null);
    }

    public static boolean isExcludeMyCaches() {
        return sharedPrefs.getBoolean(KEY_EXCLUDE_OWN, false);
    }

    /**
     * edit some settings without knowing how to get the settings editor or how to commit
     *
     * @param runnable
     * @return
     */
    private static boolean editSharedSettings(final PrefRunnable runnable) {
        final SharedPreferences.Editor prefsEdit = sharedPrefs.edit();
        runnable.edit(prefsEdit);
        return prefsEdit.commit();
    }

    public static void setExcludeMine(final boolean exclude) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_EXCLUDE_OWN, exclude);
            }
        });
    }

    public static void setUseEnglish(final boolean english) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_ENGLISH, english);
                setLanguage(english);
            }
        });
    }

    public static boolean isUseEnglish() {
        return sharedPrefs.getBoolean(KEY_USE_ENGLISH, false);
    }

    public static boolean isShowAddress() {
        return sharedPrefs.getBoolean(KEY_SHOW_ADDRESS, true);
    }

    public static void setShowAddress(final boolean showAddress) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SHOW_ADDRESS, showAddress);
            }
        });
    }

    public static boolean isShowCaptcha() {
        return isPremiumMember() ? false : sharedPrefs.getBoolean(KEY_SHOW_CAPTCHA, false);
    }

    public static void setShowCaptcha(final boolean showCaptcha) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SHOW_CAPTCHA, showCaptcha);
            }
        });
    }

    public static boolean isExcludeDisabledCaches() {
        return sharedPrefs.getBoolean(KEY_EXCLUDE_DISABLED, false);
    }

    public static void setExcludeDisabledCaches(final boolean exclude) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_EXCLUDE_DISABLED, exclude);
            }
        });
    }

    public static boolean isStoreOfflineMaps() {
        return sharedPrefs.getBoolean(KEY_USE_OFFLINEMAPS, true);
    }

    public static void setStoreOfflineMaps(final boolean offlineMaps) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_OFFLINEMAPS, offlineMaps);
            }
        });
    }

    public static boolean isStoreOfflineWpMaps() {
        return sharedPrefs.getBoolean(KEY_USE_OFFLINEWPMAPS, false);
    }

    public static void setStoreOfflineWpMaps(final boolean offlineMaps) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_OFFLINEWPMAPS, offlineMaps);
            }
        });
    }

    public static boolean isStoreLogImages() {
        return sharedPrefs.getBoolean(KEY_STORE_LOG_IMAGES, false);
    }

    public static void setStoreLogImages(final boolean storeLogImages) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_STORE_LOG_IMAGES, storeLogImages);
            }
        });
    }

    public static boolean isUseGoogleNavigation() {
        return sharedPrefs.getBoolean(KEY_USE_GOOGLE_NAVIGATION, true);
    }

    public static void setUseGoogleNavigation(final boolean useGoogleNavigation) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_GOOGLE_NAVIGATION, useGoogleNavigation);
            }
        });
    }

    public static boolean isAutoLoadDescription() {
        return sharedPrefs.getBoolean(KEY_LOAD_DESCRIPTION, false);
    }

    public static void setAutoLoadDesc(final boolean autoLoad) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LOAD_DESCRIPTION, autoLoad);
            }
        });
    }

    public static boolean isRatingWanted() {
        return sharedPrefs.getBoolean(KEY_RATING_WANTED, true);
    }

    public static void setRatingWanted(final boolean ratingWanted) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_RATING_WANTED, ratingWanted);
            }
        });
    }

    public static boolean isElevationWanted() {
        return sharedPrefs.getBoolean(KEY_ELEVATION_WANTED, true);
    }

    public static void setElevationWanted(final boolean elevationWanted) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_ELEVATION_WANTED, elevationWanted);
            }
        });
    }

    public static boolean isFriendLogsWanted() {
        if (!isLogin()) {
            // don't show a friends log if the user is anonymous
            return false;
        }
        return sharedPrefs.getBoolean(KEY_FRIENDLOGS_WANTED, true);
    }

    public static void setFriendLogsWanted(final boolean friendLogsWanted) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_FRIENDLOGS_WANTED, friendLogsWanted);
            }
        });
    }

    public static boolean isLiveList() {
        return sharedPrefs.getBoolean(KEY_LIVE_LIST, true);
    }

    public static void setLiveList(final boolean liveList) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LIVE_LIST, liveList);
            }
        });
    }

    public static boolean isPublicLoc() {
        return sharedPrefs.getBoolean(KEY_PUBLICLOC, false);
    }

    public static void setPublicLoc(final boolean publicLocation) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_PUBLICLOC, publicLocation);
            }
        });
    }

    public static boolean isTrackableAutoVisit() {
        return sharedPrefs.getBoolean(KEY_AUTO_VISIT_TRACKABLES, false);
    }

    public static void setTrackableAutoVisit(final boolean autoVisit) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_AUTO_VISIT_TRACKABLES, autoVisit);
            }
        });
    }

    public static boolean isAutoInsertSignature() {
        return sharedPrefs.getBoolean(KEY_AUTO_INSERT_SIGNATURE, false);
    }

    public static void setAutoInsertSignature(final boolean autoInsert) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_AUTO_INSERT_SIGNATURE, autoInsert);
            }
        });
    }

    public static boolean isUseMetricUnits() {
        return sharedPrefs.getBoolean(KEY_METRIC_UNITS, true);
    }

    public static void setUseMetricUnits(final boolean metric) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_METRIC_UNITS, metric);
            }
        });
    }

    public static boolean isLiveMap() {
        return sharedPrefs.getBoolean(KEY_MAP_LIVE, true);
    }

    public static boolean isMapTrail() {
        return sharedPrefs.getBoolean(KEY_MAP_TRAIL, true);
    }

    public static void setMapTrail(final boolean showTrail) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_MAP_TRAIL, showTrail);
            }
        });
    }

    public static int getMapZoom() {
        return sharedPrefs.getInt(KEY_LAST_MAP_ZOOM, 14);
    }

    public static void setMapZoom(final int mapZoomLevel) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_MAP_ZOOM, mapZoomLevel);
            }
        });
    }

    public static int getMapSource() {
        return sharedPrefs.getInt(KEY_MAP_SOURCE, 0);
    }

    public static void setMapSource(final int newMapSource) {
        if (!MapProviderFactory.isSameProvider(getMapSource(), newMapSource)) {
            mapProvider = null;
        }
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_MAP_SOURCE, newMapSource);
            }
        });
    }

    public static void setAnyCoordinates(final Geopoint coords) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (null != coords) {
                    edit.putFloat(KEY_ANYLATITUDE, (float) coords.getLatitude());
                    edit.putFloat(KEY_ANYLONGITUDE, (float) coords.getLongitude());
                } else {
                    edit.remove(KEY_ANYLATITUDE);
                    edit.remove(KEY_ANYLONGITUDE);
                }
            }
        });

    }

    public static Geopoint getAnyCoordinates() {
        if (sharedPrefs.contains(KEY_ANYLATITUDE) && sharedPrefs.contains(KEY_ANYLONGITUDE)) {
            float lat = sharedPrefs.getFloat(KEY_ANYLATITUDE, 0);
            float lon = sharedPrefs.getFloat(KEY_ANYLONGITUDE, 0);
            return new Geopoint(lat, lon);
        }
        return null;
    }

    public static boolean isUseCompass() {
        return sharedPrefs.getBoolean(KEY_USE_COMPASS, true);
    }

    public static void setUseCompass(final boolean useCompass) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_COMPASS, useCompass);
            }
        });
    }

    public static boolean isHelpShown() {
        return sharedPrefs.getBoolean(KEY_HELP_SHOWN, false);
    }

    public static void setHelpShown() {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_HELP_SHOWN, true);
            }
        });
    }

    public static boolean isLightSkin() {
        return sharedPrefs.getBoolean(KEY_SKIN, false);
    }

    public static void setLightSkin(final boolean lightSkin) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SKIN, lightSkin);
            }
        });
    }

    public static String getKeyConsumerPublic() {
        return keyConsumerPublic;
    }

    public static String getKeyConsumerSecret() {
        return keyConsumerSecret;
    }

    public static int getAltCorrection() {
        return sharedPrefs.getInt(KEY_ALTITUDE_CORRECTION, 0);
    }

    public static boolean setAltCorrection(final int altitude) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_ALTITUDE_CORRECTION, altitude);
            }
        });
    }

    public static String getWebDeviceCode() {
        return sharedPrefs.getString(KEY_WEB_DEVICE_CODE, null);
    }

    public static String getWebDeviceName() {
        return sharedPrefs.getString(KEY_WEBDEVICE_NAME, null);
    }

    /**
     * @return The cache type used for filtering or ALL if no filter is active. Returns never null
     */
    public static CacheType getCacheType() {
        return CacheType.getById(sharedPrefs.getString(KEY_CACHE_TYPE, CacheType.ALL.id));
    }

    public static int getWayPointsThreshold() {
        return sharedPrefs.getInt(KEY_SHOW_WAYPOINTS_THRESHOLD, 0);
    }

    public static void setShowWaypointsThreshold(final int threshold) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_SHOW_WAYPOINTS_THRESHOLD, threshold);
            }
        });
    }

    public static boolean isUseTwitter() {
        return sharedPrefs.getBoolean(KEY_USE_TWITTER, false);
    }

    public static void setUseTwitter(final boolean useTwitter) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_TWITTER, useTwitter);
            }
        });
    }

    public static boolean isTwitterLoginValid() {
        return !StringUtils.isBlank(getTokenPublic()) && !StringUtils.isBlank(getTokenSecret());
    }

    public static String getTokenPublic() {
        return sharedPrefs.getString(KEY_TWITTER_TOKEN_PUBLIC, null);
    }

    public static String getTokenSecret() {
        return sharedPrefs.getString(KEY_TWITTER_TOKEN_SECRET, null);

    }

    public static int getVersion() {
        return sharedPrefs.getInt(KEY_VERSION, 0);
    }

    public static void setTwitterTokens(final String tokenPublic, final String tokenSecret, boolean enableTwitter) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_TWITTER_TOKEN_PUBLIC, tokenPublic);
                edit.putString(KEY_TWITTER_TOKEN_SECRET, tokenSecret);
                if (tokenPublic != null) {
                    edit.remove(KEY_TEMP_TOKEN_PUBLIC);
                    edit.remove(KEY_TEMP_TOKEN_SECRET);
                }
            }
        });
        setUseTwitter(enableTwitter);
    }

    public static void setTwitterTempTokens(final String tokenPublic, final String tokenSecret) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_TEMP_TOKEN_PUBLIC, tokenPublic);
                edit.putString(KEY_TEMP_TOKEN_SECRET, tokenSecret);
            }
        });
    }

    public static ImmutablePair<String, String> getTempToken() {
        String tokenPublic = sharedPrefs.getString(KEY_TEMP_TOKEN_PUBLIC, null);
        String tokenSecret = sharedPrefs.getString(KEY_TEMP_TOKEN_SECRET, null);
        return new ImmutablePair<String, String>(tokenPublic, tokenSecret);
    }

    public static void setVersion(final int version) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_VERSION, version);
            }
        });
    }

    public static boolean isOpenLastDetailsPage() {
        return sharedPrefs.getBoolean(KEY_OPEN_LAST_DETAILS_PAGE, false);
    }

    public static void setOpenLastDetailsPage(final boolean openLastPage) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_OPEN_LAST_DETAILS_PAGE, openLastPage);
            }
        });
    }

    public static int getLastDetailsPage() {
        return sharedPrefs.getInt(KEY_LAST_DETAILS_PAGE, 1);
    }

    public static void setLastDetailsPage(final int index) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_DETAILS_PAGE, index);
            }
        });
    }

    public static int getDefaultNavigationTool() {
        return sharedPrefs.getInt(KEY_DEFAULT_NAVIGATION_TOOL, 0);
    }

    public static void setDefaultNavigationTool(final int defaultNavigationTool) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_DEFAULT_NAVIGATION_TOOL, defaultNavigationTool);
            }
        });
    }

    public static int getDefaultNavigationTool2() {
        return sharedPrefs.getInt(KEY_DEFAULT_NAVIGATION_TOOL_2, 0);
    }

    public static void setDefaultNavigationTool2(final int defaultNavigationTool) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_DEFAULT_NAVIGATION_TOOL_2, defaultNavigationTool);
            }
        });
    }

    public static Strategy getLiveMapStrategy() {
        return Strategy.getById(sharedPrefs.getInt(KEY_LIVE_MAP_STRATEGY, Strategy.AUTO.id));
    }

    public static void setLiveMapStrategy(final Strategy strategy) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LIVE_MAP_STRATEGY, strategy.id);
            }
        });
    }


    public static boolean isDebug() {
        return Log.isDebug();
    }

    public static void setDebug(final boolean debug) {
        editSharedSettings(new PrefRunnable() {

            @Override public void edit(Editor edit) {
                edit.putBoolean(KEY_DEBUG, debug);
            }
        });
        Log.setDebugUnsaved(debug);
    }

    public static boolean getHideLiveMapHint() {
        return sharedPrefs.getBoolean(KEY_HIDE_LIVE_MAP_HINT, false);
    }

    public static void setHideLiveHint(final boolean hide) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_HIDE_LIVE_MAP_HINT, hide);
            }
        });
    }

    public static int getLiveMapHintShowCount() {
        return sharedPrefs.getInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, 0);
    }

    public static void setLiveMapHintShowCount(final int showCount) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, showCount);
            }
        });
    }

    public static String getPreferencesName() {
        // there is currently no Android API to get the file name of the shared preferences
        return cgeoapplication.getInstance().getPackageName() + "_preferences";
    }
}
!@#$%
20190526_235222,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_a19200
package cgeo.geocaching;

import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.LiveMapStrategy.Strategy;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.maps.MapProviderFactory;
import cgeo.geocaching.maps.interfaces.MapProvider;
import cgeo.geocaching.utils.CryptUtils;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.preference.PreferenceManager;

import java.util.Locale;

/**
 * General c:geo preferences/settings set by the user
 */
public final class Settings {

    private static final String KEY_TEMP_TOKEN_SECRET = "temp-token-secret";
    private static final String KEY_TEMP_TOKEN_PUBLIC = "temp-token-public";
    private static final String KEY_HELP_SHOWN = "helper";
    private static final String KEY_ANYLONGITUDE = "anylongitude";
    private static final String KEY_ANYLATITUDE = "anylatitude";
    private static final String KEY_PUBLICLOC = "publicloc";
    private static final String KEY_USE_OFFLINEMAPS = "offlinemaps";
    private static final String KEY_USE_OFFLINEWPMAPS = "offlinewpmaps";
    private static final String KEY_WEB_DEVICE_CODE = "webDeviceCode";
    private static final String KEY_WEBDEVICE_NAME = "webDeviceName";
    private static final String KEY_MAP_LIVE = "maplive";
    private static final String KEY_MAP_SOURCE = "mapsource";
    private static final String KEY_USE_TWITTER = "twitter";
    private static final String KEY_SHOW_ADDRESS = "showaddress";
    private static final String KEY_SHOW_CAPTCHA = "showcaptcha";
    private static final String KEY_MAP_TRAIL = "maptrail";
    private static final String KEY_LAST_MAP_ZOOM = "mapzoom";
    private static final String KEY_LIVE_LIST = "livelist";
    private static final String KEY_METRIC_UNITS = "units";
    private static final String KEY_SKIN = "skin";
    private static final String KEY_LAST_USED_LIST = "lastlist";
    private static final String KEY_CACHE_TYPE = "cachetype";
    private static final String KEY_TWITTER_TOKEN_SECRET = "tokensecret";
    private static final String KEY_TWITTER_TOKEN_PUBLIC = "tokenpublic";
    private static final String KEY_VERSION = "version";
    private static final String KEY_LOAD_DESCRIPTION = "autoloaddesc";
    private static final String KEY_RATING_WANTED = "ratingwanted";
    private static final String KEY_ELEVATION_WANTED = "elevationwanted";
    private static final String KEY_FRIENDLOGS_WANTED = "friendlogswanted";
    private static final String KEY_USE_ENGLISH = "useenglish";
    private static final String KEY_USE_COMPASS = "usecompass";
    private static final String KEY_AUTO_VISIT_TRACKABLES = "trackautovisit";
    private static final String KEY_AUTO_INSERT_SIGNATURE = "sigautoinsert";
    private static final String KEY_ALTITUDE_CORRECTION = "altcorrection";
    private static final String KEY_USE_GOOGLE_NAVIGATION = "usegnav";
    private static final String KEY_STORE_LOG_IMAGES = "logimages";
    private static final String KEY_EXCLUDE_DISABLED = "excludedisabled";
    private static final String KEY_EXCLUDE_OWN = "excludemine";
    private static final String KEY_MAPFILE = "mfmapfile";
    private static final String KEY_SIGNATURE = "signature";
    private static final String KEY_GCVOTE_PASSWORD = "pass-vote";
    private static final String KEY_PASSWORD = "password";
    private static final String KEY_USERNAME = "username";
    private static final String KEY_MEMBER_STATUS = "memberstatus";
    private static final String KEY_COORD_INPUT_FORMAT = "coordinputformat";
    private static final String KEY_LOG_OFFLINE = "log_offline";
    private static final String KEY_LOAD_DIRECTION_IMG = "loaddirectionimg";
    private static final String KEY_GC_CUSTOM_DATE = "gccustomdate";
    private static final String KEY_SHOW_WAYPOINTS_THRESHOLD = "gcshowwaypointsthreshold";
    private static final String KEY_COOKIE_STORE = "cookiestore";
    private static final String KEY_OPEN_LAST_DETAILS_PAGE = "opendetailslastpage";
    private static final String KEY_LAST_DETAILS_PAGE = "lastdetailspage";
    private static final String KEY_DEFAULT_NAVIGATION_TOOL = "defaultNavigationTool";
    private static final String KEY_DEFAULT_NAVIGATION_TOOL_2 = "defaultNavigationTool2";
    private static final String KEY_LIVE_MAP_STRATEGY = "livemapstrategy";
    private static final String KEY_DEBUG = "debug";
    private static final String KEY_HIDE_LIVE_MAP_HINT = "hidelivemaphint";
    private static final String KEY_LIVE_MAP_HINT_SHOW_COUNT = "livemaphintshowcount";
    private static final String KEY_SETTINGS_VERSION = "settingsversion";

    private final static int unitsMetric = 1;

    // twitter api keys
    private final static String keyConsumerPublic = CryptUtils.rot13("ESnsCvAv3kEupF1GCR3jGj");
    private final static String keyConsumerSecret = CryptUtils.rot13("7vQWceACV9umEjJucmlpFe9FCMZSeqIqfkQ2BnhV9x");

    private interface PrefRunnable {
        void edit(final Editor edit);
    }

    public enum coordInputFormatEnum {
        Plain,
        Deg,
        Min,
        Sec;

        static coordInputFormatEnum fromInt(int id) {
            final coordInputFormatEnum[] values = coordInputFormatEnum.values();
            if (id >= 0 && id < values.length) {
                return values[id];
            } else {
                return Min;
            }
        }
    }

    private static String username = null;
    private static String password = null;

    private static final SharedPreferences sharedPrefs = PreferenceManager.getDefaultSharedPreferences(cgeoapplication.getInstance().getBaseContext());
    static {
        migrateSettings();
    }

    // Debug settings are accessed often enough to be cached
    private static Boolean cachedDebug = sharedPrefs.getBoolean(KEY_DEBUG, false);

    // maps
    private static MapProvider mapProvider = null;

    private Settings() {
        // this class is not to be instantiated;
    }

    private static void migrateSettings() {
        // migrate from non standard file location and integer based boolean types
        if (sharedPrefs.getInt(KEY_SETTINGS_VERSION, 0) < 1) {
            final String oldPreferencesName = "cgeo.pref";
            final SharedPreferences old = cgeoapplication.getInstance().getSharedPreferences(oldPreferencesName, Context.MODE_PRIVATE);
            final Editor e = sharedPrefs.edit();

            e.putString(KEY_TEMP_TOKEN_SECRET, old.getString(KEY_TEMP_TOKEN_SECRET, null));
            e.putString(KEY_TEMP_TOKEN_PUBLIC, old.getString(KEY_TEMP_TOKEN_PUBLIC, null));
            e.putBoolean(KEY_HELP_SHOWN, old.getInt(KEY_HELP_SHOWN, 0) != 0);
            e.putFloat(KEY_ANYLONGITUDE, old.getFloat(KEY_ANYLONGITUDE, 0));
            e.putFloat(KEY_ANYLATITUDE, old.getFloat(KEY_ANYLATITUDE, 0));
            e.putBoolean(KEY_PUBLICLOC, 0 != old.getInt(KEY_PUBLICLOC, 0));
            e.putBoolean(KEY_USE_OFFLINEMAPS, 0 != old.getInt(KEY_USE_OFFLINEMAPS, 1));
            e.putBoolean(KEY_USE_OFFLINEWPMAPS, 0 != old.getInt(KEY_USE_OFFLINEWPMAPS, 0));
            e.putString(KEY_WEB_DEVICE_CODE, old.getString(KEY_WEB_DEVICE_CODE, null));
            e.putString(KEY_WEBDEVICE_NAME, old.getString(KEY_WEBDEVICE_NAME, null));
            e.putBoolean(KEY_MAP_LIVE, old.getInt(KEY_MAP_LIVE, 1) != 0);
            e.putInt(KEY_MAP_SOURCE, old.getInt(KEY_MAP_SOURCE, 0));
            e.putBoolean(KEY_USE_TWITTER, 0 != old.getInt(KEY_USE_TWITTER, 0));
            e.putBoolean(KEY_SHOW_ADDRESS, 0 != old.getInt(KEY_SHOW_ADDRESS, 1));
            e.putBoolean(KEY_SHOW_CAPTCHA, old.getBoolean(KEY_SHOW_CAPTCHA, false));
            e.putBoolean(KEY_MAP_TRAIL, old.getInt(KEY_MAP_TRAIL, 1) != 0);
            e.putInt(KEY_LAST_MAP_ZOOM, old.getInt(KEY_LAST_MAP_ZOOM, 14));
            e.putBoolean(KEY_LIVE_LIST, 0 != old.getInt(KEY_LIVE_LIST, 1));
            e.putBoolean(KEY_METRIC_UNITS, old.getInt(KEY_METRIC_UNITS, unitsMetric) == unitsMetric);
            e.putBoolean(KEY_SKIN, old.getInt(KEY_SKIN, 0) != 0);
            e.putInt(KEY_LAST_USED_LIST, old.getInt(KEY_LAST_USED_LIST, StoredList.STANDARD_LIST_ID));
            e.putString(KEY_CACHE_TYPE, old.getString(KEY_CACHE_TYPE, CacheType.ALL.id));
            e.putString(KEY_TWITTER_TOKEN_SECRET, old.getString(KEY_TWITTER_TOKEN_SECRET, null));
            e.putString(KEY_TWITTER_TOKEN_PUBLIC, old.getString(KEY_TWITTER_TOKEN_PUBLIC, null));
            e.putInt(KEY_VERSION, old.getInt(KEY_VERSION, 0));
            e.putBoolean(KEY_LOAD_DESCRIPTION, 0 != old.getInt(KEY_LOAD_DESCRIPTION, 0));
            e.putBoolean(KEY_RATING_WANTED, old.getBoolean(KEY_RATING_WANTED, true));
            e.putBoolean(KEY_ELEVATION_WANTED, old.getBoolean(KEY_ELEVATION_WANTED, true));
            e.putBoolean(KEY_FRIENDLOGS_WANTED, old.getBoolean(KEY_FRIENDLOGS_WANTED, true));
            e.putBoolean(KEY_USE_ENGLISH, old.getBoolean(KEY_USE_ENGLISH, false));
            e.putBoolean(KEY_USE_COMPASS, 0 != old.getInt(KEY_USE_COMPASS, 1));
            e.putBoolean(KEY_AUTO_VISIT_TRACKABLES, old.getBoolean(KEY_AUTO_VISIT_TRACKABLES, false));
            e.putBoolean(KEY_AUTO_INSERT_SIGNATURE, old.getBoolean(KEY_AUTO_INSERT_SIGNATURE, false));
            e.putInt(KEY_ALTITUDE_CORRECTION, old.getInt(KEY_ALTITUDE_CORRECTION, 0));
            e.putBoolean(KEY_USE_GOOGLE_NAVIGATION, 0 != old.getInt(KEY_USE_GOOGLE_NAVIGATION, 1));
            e.putBoolean(KEY_STORE_LOG_IMAGES, old.getBoolean(KEY_STORE_LOG_IMAGES, false));
            e.putBoolean(KEY_EXCLUDE_DISABLED, 0 != old.getInt(KEY_EXCLUDE_DISABLED, 0));
            e.putBoolean(KEY_EXCLUDE_OWN, 0 != old.getInt(KEY_EXCLUDE_OWN, 0));
            e.putString(KEY_MAPFILE, old.getString(KEY_MAPFILE, null));
            e.putString(KEY_SIGNATURE, old.getString(KEY_SIGNATURE, null));
            e.putString(KEY_GCVOTE_PASSWORD, old.getString(KEY_GCVOTE_PASSWORD, null));
            e.putString(KEY_PASSWORD, old.getString(KEY_PASSWORD, null));
            e.putString(KEY_USERNAME, old.getString(KEY_USERNAME, null));
            e.putString(KEY_MEMBER_STATUS, old.getString(KEY_MEMBER_STATUS, ""));
            e.putInt(KEY_COORD_INPUT_FORMAT, old.getInt(KEY_COORD_INPUT_FORMAT, 0));
            e.putBoolean(KEY_LOG_OFFLINE, old.getBoolean(KEY_LOG_OFFLINE, false));
            e.putBoolean(KEY_LOAD_DIRECTION_IMG, old.getBoolean(KEY_LOAD_DIRECTION_IMG, true));
            e.putString(KEY_GC_CUSTOM_DATE, old.getString(KEY_GC_CUSTOM_DATE, null));
            e.putInt(KEY_SHOW_WAYPOINTS_THRESHOLD, old.getInt(KEY_SHOW_WAYPOINTS_THRESHOLD, 0));
            e.putString(KEY_COOKIE_STORE, old.getString(KEY_COOKIE_STORE, null));
            e.putBoolean(KEY_OPEN_LAST_DETAILS_PAGE, old.getBoolean(KEY_OPEN_LAST_DETAILS_PAGE, false));
            e.putInt(KEY_LAST_DETAILS_PAGE, old.getInt(KEY_LAST_DETAILS_PAGE, 1));
            e.putInt(KEY_DEFAULT_NAVIGATION_TOOL, old.getInt(KEY_DEFAULT_NAVIGATION_TOOL, 0));
            e.putInt(KEY_DEFAULT_NAVIGATION_TOOL_2, old.getInt(KEY_DEFAULT_NAVIGATION_TOOL_2, 0));
            e.putInt(KEY_LIVE_MAP_STRATEGY, old.getInt(KEY_LIVE_MAP_STRATEGY, Strategy.AUTO.id));
            e.putBoolean(KEY_DEBUG, old.getBoolean(KEY_DEBUG, false));
            e.putBoolean(KEY_HIDE_LIVE_MAP_HINT, old.getInt(KEY_HIDE_LIVE_MAP_HINT, 0) != 0);
            e.putInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, old.getInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, 0));

            e.putInt(KEY_SETTINGS_VERSION, 1) ; // mark migrated
            e.commit();
            cachedDebug = sharedPrefs.getBoolean(KEY_DEBUG, false);
        }
    }

    public static void setLanguage(boolean useEnglish) {
        final Configuration config = new Configuration();
        config.locale = useEnglish ? new Locale("en") : Locale.getDefault();
        final Resources resources = cgeoapplication.getInstance().getResources();
        resources.updateConfiguration(config, resources.getDisplayMetrics());
    }

    public static boolean isLogin() {
        final String preUsername = sharedPrefs.getString(KEY_USERNAME, null);
        final String prePassword = sharedPrefs.getString(KEY_PASSWORD, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    /**
     * Get login and password information.
     *
     * @return a pair (login, password) or null if no valid information is stored
     */
    public static ImmutablePair<String, String> getLogin() {
        if (username == null || password == null) {
            final String preUsername = sharedPrefs.getString(KEY_USERNAME, null);
            final String prePassword = sharedPrefs.getString(KEY_PASSWORD, null);

            if (preUsername == null || prePassword == null) {
                return null;
            }

            username = preUsername;
            password = prePassword;
        }
        return new ImmutablePair<String, String>(username, password);
    }

    public static String getUsername() {
        if (null == username) {
            return sharedPrefs.getString(KEY_USERNAME, null);
        } else {
            return username;
        }
    }

    public static boolean setLogin(final String username, final String password) {
        Settings.username = username;
        Settings.password = password;
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
                    // erase username and password
                    edit.remove(KEY_USERNAME);
                    edit.remove(KEY_PASSWORD);
                } else {
                    // save username and password
                    edit.putString(KEY_USERNAME, username);
                    edit.putString(KEY_PASSWORD, password);
                }
            }
        });
    }

    public static boolean isPremiumMember() {
        // Basic Member, Premium Member, ???
        String memberStatus = Settings.getMemberStatus();
        if (memberStatus == null) {
            return false;
        }
        return "Premium Member".equalsIgnoreCase(memberStatus);
    }

    public static String getMemberStatus() {
        return sharedPrefs.getString(KEY_MEMBER_STATUS, "");
    }

    public static boolean setMemberStatus(final String memberStatus) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(memberStatus)) {
                    edit.remove(KEY_MEMBER_STATUS);
                } else {
                    edit.putString(KEY_MEMBER_STATUS, memberStatus);
                }
            }
        });
    }

    public static boolean isGCvoteLogin() {
        final String preUsername = sharedPrefs.getString(KEY_USERNAME, null);
        final String prePassword = sharedPrefs.getString(KEY_GCVOTE_PASSWORD, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    public static boolean setGCvoteLogin(final String password) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(password)) {
                    // erase password
                    edit.remove(KEY_GCVOTE_PASSWORD);
                } else {
                    // save password
                    edit.putString(KEY_GCVOTE_PASSWORD, password);
                }
            }
        });
    }

    public static ImmutablePair<String, String> getGCvoteLogin() {
        final String username = sharedPrefs.getString(KEY_USERNAME, null);
        final String password = sharedPrefs.getString(KEY_GCVOTE_PASSWORD, null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return null;
        }

        return new ImmutablePair<String, String>(username, password);
    }

    public static boolean setSignature(final String signature) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(signature)) {
                    // erase signature
                    edit.remove(KEY_SIGNATURE);
                } else {
                    // save signature
                    edit.putString(KEY_SIGNATURE, signature);
                }
            }
        });
    }

    public static String getSignature() {
        return sharedPrefs.getString(KEY_SIGNATURE, null);
    }

    public static boolean setCookieStore(final String cookies) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(final Editor edit) {
                if (StringUtils.isBlank(cookies)) {
                    // erase cookies
                    edit.remove(KEY_COOKIE_STORE);
                } else {
                    // save cookies
                    edit.putString(KEY_COOKIE_STORE, cookies);
                }
            }
        });
    }

    public static String getCookieStore() {
        return sharedPrefs.getString(KEY_COOKIE_STORE, null);
    }

    /**
     * @param cacheType
     *            The cache type used for future filtering
     */
    public static void setCacheType(final CacheType cacheType) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                if (cacheType == null) {
                    edit.remove(KEY_CACHE_TYPE);
                } else {
                    edit.putString(KEY_CACHE_TYPE, cacheType.id);
                }
            }
        });
    }

    public static void setLiveMap(final boolean live) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_MAP_LIVE, live);
            }
        });
    }

    public static int getLastList() {
        final int listId = sharedPrefs.getInt(KEY_LAST_USED_LIST, StoredList.STANDARD_LIST_ID);

        return listId;
    }

    public static void saveLastList(final int listId) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_USED_LIST, listId);
            }
        });
    }

    public static void setWebNameCode(final String name, final String code) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {

                edit.putString(KEY_WEBDEVICE_NAME, name);
                edit.putString(KEY_WEB_DEVICE_CODE, code);
            }
        });
    }

    public static MapProvider getMapProvider() {
        if (mapProvider == null) {
            mapProvider = MapProviderFactory.getMapProvider(getMapSource());
        }
        return mapProvider;
    }

    public static String getMapFile() {
        return sharedPrefs.getString(KEY_MAPFILE, null);
    }

    public static boolean setMapFile(final String mapFile) {
        final boolean commitResult = editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_MAPFILE, mapFile);
            }
        });

        return commitResult;
    }

    public static coordInputFormatEnum getCoordInputFormat() {
        return coordInputFormatEnum.fromInt(sharedPrefs.getInt(KEY_COORD_INPUT_FORMAT, 0));
    }

    public static void setCoordInputFormat(final coordInputFormatEnum format) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_COORD_INPUT_FORMAT, format.ordinal());
            }
        });
    }

    static void setLogOffline(final boolean offline) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LOG_OFFLINE, offline);
            }
        });
    }

    public static boolean getLogOffline() {
        return sharedPrefs.getBoolean(KEY_LOG_OFFLINE, false);
    }

    static void setLoadDirImg(final boolean value) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LOAD_DIRECTION_IMG, value);
            }
        });
    }

    public static boolean getLoadDirImg() {
        return isPremiumMember() ? false : sharedPrefs.getBoolean(KEY_LOAD_DIRECTION_IMG, true);
    }

    public static void setGcCustomDate(final String format) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_GC_CUSTOM_DATE, format);
            }
        });
    }

    /**
     * @return User selected date format on GC.com
     * @see cgBase.gcCustomDateFormats
     */
    public static String getGcCustomDate() {
        return sharedPrefs.getString(KEY_GC_CUSTOM_DATE, null);
    }

    public static boolean isExcludeMyCaches() {
        return sharedPrefs.getBoolean(KEY_EXCLUDE_OWN, false);
    }

    /**
     * edit some settings without knowing how to get the settings editor or how to commit
     *
     * @param runnable
     * @return
     */
    private static boolean editSharedSettings(final PrefRunnable runnable) {
        final SharedPreferences.Editor prefsEdit = sharedPrefs.edit();
        runnable.edit(prefsEdit);
        return prefsEdit.commit();
    }

    public static void setExcludeMine(final boolean exclude) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_EXCLUDE_OWN, exclude);
            }
        });
    }

    public static void setUseEnglish(final boolean english) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_ENGLISH, english);
                setLanguage(english);
            }
        });
    }

    public static boolean isUseEnglish() {
        return sharedPrefs.getBoolean(KEY_USE_ENGLISH, false);
    }

    public static boolean isShowAddress() {
        return sharedPrefs.getBoolean(KEY_SHOW_ADDRESS, true);
    }

    public static void setShowAddress(final boolean showAddress) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SHOW_ADDRESS, showAddress);
            }
        });
    }

    public static boolean isShowCaptcha() {
        return isPremiumMember() ? false : sharedPrefs.getBoolean(KEY_SHOW_CAPTCHA, false);
    }

    public static void setShowCaptcha(final boolean showCaptcha) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SHOW_CAPTCHA, showCaptcha);
            }
        });
    }

    public static boolean isExcludeDisabledCaches() {
        return sharedPrefs.getBoolean(KEY_EXCLUDE_DISABLED, false);
    }

    public static void setExcludeDisabledCaches(final boolean exclude) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_EXCLUDE_DISABLED, exclude);
            }
        });
    }

    public static boolean isStoreOfflineMaps() {
        return sharedPrefs.getBoolean(KEY_USE_OFFLINEMAPS, true);
    }

    public static void setStoreOfflineMaps(final boolean offlineMaps) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_OFFLINEMAPS, offlineMaps);
            }
        });
    }

    public static boolean isStoreOfflineWpMaps() {
        return sharedPrefs.getBoolean(KEY_USE_OFFLINEWPMAPS, false);
    }

    public static void setStoreOfflineWpMaps(final boolean offlineMaps) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_OFFLINEWPMAPS, offlineMaps);
            }
        });
    }

    public static boolean isStoreLogImages() {
        return sharedPrefs.getBoolean(KEY_STORE_LOG_IMAGES, false);
    }

    public static void setStoreLogImages(final boolean storeLogImages) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_STORE_LOG_IMAGES, storeLogImages);
            }
        });
    }

    public static boolean isUseGoogleNavigation() {
        return sharedPrefs.getBoolean(KEY_USE_GOOGLE_NAVIGATION, true);
    }

    public static void setUseGoogleNavigation(final boolean useGoogleNavigation) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_GOOGLE_NAVIGATION, useGoogleNavigation);
            }
        });
    }

    public static boolean isAutoLoadDescription() {
        return sharedPrefs.getBoolean(KEY_LOAD_DESCRIPTION, false);
    }

    public static void setAutoLoadDesc(final boolean autoLoad) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LOAD_DESCRIPTION, autoLoad);
            }
        });
    }

    public static boolean isRatingWanted() {
        return sharedPrefs.getBoolean(KEY_RATING_WANTED, true);
    }

    public static void setRatingWanted(final boolean ratingWanted) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_RATING_WANTED, ratingWanted);
            }
        });
    }

    public static boolean isElevationWanted() {
        return sharedPrefs.getBoolean(KEY_ELEVATION_WANTED, true);
    }

    public static void setElevationWanted(final boolean elevationWanted) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_ELEVATION_WANTED, elevationWanted);
            }
        });
    }

    public static boolean isFriendLogsWanted() {
        if (!isLogin()) {
            // don't show a friends log if the user is anonymous
            return false;
        }
        return sharedPrefs.getBoolean(KEY_FRIENDLOGS_WANTED, true);
    }

    public static void setFriendLogsWanted(final boolean friendLogsWanted) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_FRIENDLOGS_WANTED, friendLogsWanted);
            }
        });
    }

    public static boolean isLiveList() {
        return sharedPrefs.getBoolean(KEY_LIVE_LIST, true);
    }

    public static void setLiveList(final boolean liveList) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LIVE_LIST, liveList);
            }
        });
    }

    public static boolean isPublicLoc() {
        return sharedPrefs.getBoolean(KEY_PUBLICLOC, false);
    }

    public static void setPublicLoc(final boolean publicLocation) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_PUBLICLOC, publicLocation);
            }
        });
    }

    public static boolean isTrackableAutoVisit() {
        return sharedPrefs.getBoolean(KEY_AUTO_VISIT_TRACKABLES, false);
    }

    public static void setTrackableAutoVisit(final boolean autoVisit) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_AUTO_VISIT_TRACKABLES, autoVisit);
            }
        });
    }

    public static boolean isAutoInsertSignature() {
        return sharedPrefs.getBoolean(KEY_AUTO_INSERT_SIGNATURE, false);
    }

    public static void setAutoInsertSignature(final boolean autoInsert) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_AUTO_INSERT_SIGNATURE, autoInsert);
            }
        });
    }

    public static boolean isUseMetricUnits() {
        return sharedPrefs.getBoolean(KEY_METRIC_UNITS, true);
    }

    public static void setUseMetricUnits(final boolean metric) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_METRIC_UNITS, metric);
            }
        });
    }

    public static boolean isLiveMap() {
        return sharedPrefs.getBoolean(KEY_MAP_LIVE, true);
    }

    public static boolean isMapTrail() {
        return sharedPrefs.getBoolean(KEY_MAP_TRAIL, true);
    }

    public static void setMapTrail(final boolean showTrail) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_MAP_TRAIL, showTrail);
            }
        });
    }

    public static int getMapZoom() {
        return sharedPrefs.getInt(KEY_LAST_MAP_ZOOM, 14);
    }

    public static void setMapZoom(final int mapZoomLevel) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_MAP_ZOOM, mapZoomLevel);
            }
        });
    }

    public static int getMapSource() {
        return sharedPrefs.getInt(KEY_MAP_SOURCE, 0);
    }

    public static void setMapSource(final int newMapSource) {
        if (!MapProviderFactory.isSameProvider(getMapSource(), newMapSource)) {
            mapProvider = null;
        }
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_MAP_SOURCE, newMapSource);
            }
        });
    }

    public static void setAnyCoordinates(final Geopoint coords) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (null != coords) {
                    edit.putFloat(KEY_ANYLATITUDE, (float) coords.getLatitude());
                    edit.putFloat(KEY_ANYLONGITUDE, (float) coords.getLongitude());
                } else {
                    edit.remove(KEY_ANYLATITUDE);
                    edit.remove(KEY_ANYLONGITUDE);
                }
            }
        });

    }

    public static Geopoint getAnyCoordinates() {
        if (sharedPrefs.contains(KEY_ANYLATITUDE) && sharedPrefs.contains(KEY_ANYLONGITUDE)) {
            float lat = sharedPrefs.getFloat(KEY_ANYLATITUDE, 0);
            float lon = sharedPrefs.getFloat(KEY_ANYLONGITUDE, 0);
            return new Geopoint(lat, lon);
        }
        return null;
    }

    public static boolean isUseCompass() {
        return sharedPrefs.getBoolean(KEY_USE_COMPASS, true);
    }

    public static void setUseCompass(final boolean useCompass) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_COMPASS, useCompass);
            }
        });
    }

    public static boolean isHelpShown() {
        return sharedPrefs.getBoolean(KEY_HELP_SHOWN, false);
    }

    public static void setHelpShown() {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_HELP_SHOWN, true);
            }
        });
    }

    public static boolean isLightSkin() {
        return sharedPrefs.getBoolean(KEY_SKIN, false);
    }

    public static void setLightSkin(final boolean lightSkin) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SKIN, lightSkin);
            }
        });
    }

    public static String getKeyConsumerPublic() {
        return keyConsumerPublic;
    }

    public static String getKeyConsumerSecret() {
        return keyConsumerSecret;
    }

    public static int getAltCorrection() {
        return sharedPrefs.getInt(KEY_ALTITUDE_CORRECTION, 0);
    }

    public static boolean setAltCorrection(final int altitude) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_ALTITUDE_CORRECTION, altitude);
            }
        });
    }

    public static String getWebDeviceCode() {
        return sharedPrefs.getString(KEY_WEB_DEVICE_CODE, null);
    }

    public static String getWebDeviceName() {
        return sharedPrefs.getString(KEY_WEBDEVICE_NAME, null);
    }

    /**
     * @return The cache type used for filtering or ALL if no filter is active. Returns never null
     */
    public static CacheType getCacheType() {
        return CacheType.getById(sharedPrefs.getString(KEY_CACHE_TYPE, CacheType.ALL.id));
    }

    public static int getWayPointsThreshold() {
        return sharedPrefs.getInt(KEY_SHOW_WAYPOINTS_THRESHOLD, 0);
    }

    public static void setShowWaypointsThreshold(final int threshold) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_SHOW_WAYPOINTS_THRESHOLD, threshold);
            }
        });
    }

    public static boolean isUseTwitter() {
        return sharedPrefs.getBoolean(KEY_USE_TWITTER, false);
    }

    public static void setUseTwitter(final boolean useTwitter) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_TWITTER, useTwitter);
            }
        });
    }

    public static boolean isTwitterLoginValid() {
        return !StringUtils.isBlank(getTokenPublic()) && !StringUtils.isBlank(getTokenSecret());
    }

    public static String getTokenPublic() {
        return sharedPrefs.getString(KEY_TWITTER_TOKEN_PUBLIC, null);
    }

    public static String getTokenSecret() {
        return sharedPrefs.getString(KEY_TWITTER_TOKEN_SECRET, null);

    }

    public static int getVersion() {
        return sharedPrefs.getInt(KEY_VERSION, 0);
    }

    public static void setTwitterTokens(final String tokenPublic, final String tokenSecret, boolean enableTwitter) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_TWITTER_TOKEN_PUBLIC, tokenPublic);
                edit.putString(KEY_TWITTER_TOKEN_SECRET, tokenSecret);
                if (tokenPublic != null) {
                    edit.remove(KEY_TEMP_TOKEN_PUBLIC);
                    edit.remove(KEY_TEMP_TOKEN_SECRET);
                }
            }
        });
        setUseTwitter(enableTwitter);
    }

    public static void setTwitterTempTokens(final String tokenPublic, final String tokenSecret) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_TEMP_TOKEN_PUBLIC, tokenPublic);
                edit.putString(KEY_TEMP_TOKEN_SECRET, tokenSecret);
            }
        });
    }

    public static ImmutablePair<String, String> getTempToken() {
        String tokenPublic = sharedPrefs.getString(KEY_TEMP_TOKEN_PUBLIC, null);
        String tokenSecret = sharedPrefs.getString(KEY_TEMP_TOKEN_SECRET, null);
        return new ImmutablePair<String, String>(tokenPublic, tokenSecret);
    }

    public static void setVersion(final int version) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_VERSION, version);
            }
        });
    }

    public static boolean isOpenLastDetailsPage() {
        return sharedPrefs.getBoolean(KEY_OPEN_LAST_DETAILS_PAGE, false);
    }

    public static void setOpenLastDetailsPage(final boolean openLastPage) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_OPEN_LAST_DETAILS_PAGE, openLastPage);
            }
        });
    }

    public static int getLastDetailsPage() {
        return sharedPrefs.getInt(KEY_LAST_DETAILS_PAGE, 1);
    }

    public static void setLastDetailsPage(final int index) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_DETAILS_PAGE, index);
            }
        });
    }

    public static int getDefaultNavigationTool() {
        return sharedPrefs.getInt(KEY_DEFAULT_NAVIGATION_TOOL, 0);
    }

    public static void setDefaultNavigationTool(final int defaultNavigationTool) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_DEFAULT_NAVIGATION_TOOL, defaultNavigationTool);
            }
        });
    }

    public static int getDefaultNavigationTool2() {
        return sharedPrefs.getInt(KEY_DEFAULT_NAVIGATION_TOOL_2, 0);
    }

    public static void setDefaultNavigationTool2(final int defaultNavigationTool) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_DEFAULT_NAVIGATION_TOOL_2, defaultNavigationTool);
            }
        });
    }

    public static Strategy getLiveMapStrategy() {
        return Strategy.getById(sharedPrefs.getInt(KEY_LIVE_MAP_STRATEGY, Strategy.AUTO.id));
    }

    public static void setLiveMapStrategy(final Strategy strategy) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LIVE_MAP_STRATEGY, strategy.id);
            }
        });
    }


    public static boolean isDebug() {
        return cachedDebug;
    }

    public static void setDebug(final boolean debug) {
        editSharedSettings(new PrefRunnable() {

            @Override public void edit(Editor edit) {
                edit.putBoolean(KEY_DEBUG, debug);
            }
        });
        cachedDebug = debug;
    }

    public static boolean getHideLiveMapHint() {
        return sharedPrefs.getBoolean(KEY_HIDE_LIVE_MAP_HINT, false);
    }

    public static void setHideLiveHint(final boolean hide) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_HIDE_LIVE_MAP_HINT, hide);
            }
        });
    }

    public static int getLiveMapHintShowCount() {
        return sharedPrefs.getInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, 0);
    }

    public static void setLiveMapHintShowCount(final int showCount) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, showCount);
            }
        });
    }

    public static String getPreferencesName() {
        // there is currently no Android API to get the file name of the shared preferences
        return cgeoapplication.getInstance().getPackageName() + "_preferences";
    }
}
!@#$%
20190526_235222,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_c19200
package cgeo.geocaching;

import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.LiveMapStrategy.Strategy;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.maps.MapProviderFactory;
import cgeo.geocaching.maps.interfaces.MapProvider;
import cgeo.geocaching.utils.CryptUtils;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.preference.PreferenceManager;

import java.util.Locale;

/**
 * General c:geo preferences/settings set by the user
 */
public final class Settings {

    private static final String KEY_TEMP_TOKEN_SECRET = "temp-token-secret";
    private static final String KEY_TEMP_TOKEN_PUBLIC = "temp-token-public";
    private static final String KEY_HELP_SHOWN = "helper";
    private static final String KEY_ANYLONGITUDE = "anylongitude";
    private static final String KEY_ANYLATITUDE = "anylatitude";
    private static final String KEY_PUBLICLOC = "publicloc";
    private static final String KEY_USE_OFFLINEMAPS = "offlinemaps";
    private static final String KEY_USE_OFFLINEWPMAPS = "offlinewpmaps";
    private static final String KEY_WEB_DEVICE_CODE = "webDeviceCode";
    private static final String KEY_WEBDEVICE_NAME = "webDeviceName";
    private static final String KEY_MAP_LIVE = "maplive";
    private static final String KEY_MAP_SOURCE = "mapsource";
    private static final String KEY_USE_TWITTER = "twitter";
    private static final String KEY_SHOW_ADDRESS = "showaddress";
    private static final String KEY_SHOW_CAPTCHA = "showcaptcha";
    private static final String KEY_MAP_TRAIL = "maptrail";
    private static final String KEY_LAST_MAP_ZOOM = "mapzoom";
    private static final String KEY_LIVE_LIST = "livelist";
    private static final String KEY_METRIC_UNITS = "units";
    private static final String KEY_SKIN = "skin";
    private static final String KEY_LAST_USED_LIST = "lastlist";
    private static final String KEY_CACHE_TYPE = "cachetype";
    private static final String KEY_TWITTER_TOKEN_SECRET = "tokensecret";
    private static final String KEY_TWITTER_TOKEN_PUBLIC = "tokenpublic";
    private static final String KEY_VERSION = "version";
    private static final String KEY_LOAD_DESCRIPTION = "autoloaddesc";
    private static final String KEY_RATING_WANTED = "ratingwanted";
    private static final String KEY_ELEVATION_WANTED = "elevationwanted";
    private static final String KEY_FRIENDLOGS_WANTED = "friendlogswanted";
    private static final String KEY_USE_ENGLISH = "useenglish";
    private static final String KEY_USE_COMPASS = "usecompass";
    private static final String KEY_AUTO_VISIT_TRACKABLES = "trackautovisit";
    private static final String KEY_AUTO_INSERT_SIGNATURE = "sigautoinsert";
    private static final String KEY_ALTITUDE_CORRECTION = "altcorrection";
    private static final String KEY_USE_GOOGLE_NAVIGATION = "usegnav";
    private static final String KEY_STORE_LOG_IMAGES = "logimages";
    private static final String KEY_EXCLUDE_DISABLED = "excludedisabled";
    private static final String KEY_EXCLUDE_OWN = "excludemine";
    private static final String KEY_MAPFILE = "mfmapfile";
    private static final String KEY_SIGNATURE = "signature";
    private static final String KEY_GCVOTE_PASSWORD = "pass-vote";
    private static final String KEY_PASSWORD = "password";
    private static final String KEY_USERNAME = "username";
    private static final String KEY_MEMBER_STATUS = "memberstatus";
    private static final String KEY_COORD_INPUT_FORMAT = "coordinputformat";
    private static final String KEY_LOG_OFFLINE = "log_offline";
    private static final String KEY_LOAD_DIRECTION_IMG = "loaddirectionimg";
    private static final String KEY_GC_CUSTOM_DATE = "gccustomdate";
    private static final String KEY_SHOW_WAYPOINTS_THRESHOLD = "gcshowwaypointsthreshold";
    private static final String KEY_COOKIE_STORE = "cookiestore";
    private static final String KEY_OPEN_LAST_DETAILS_PAGE = "opendetailslastpage";
    private static final String KEY_LAST_DETAILS_PAGE = "lastdetailspage";
    private static final String KEY_DEFAULT_NAVIGATION_TOOL = "defaultNavigationTool";
    private static final String KEY_DEFAULT_NAVIGATION_TOOL_2 = "defaultNavigationTool2";
    private static final String KEY_LIVE_MAP_STRATEGY = "livemapstrategy";
    private static final String KEY_DEBUG = "debug";
    private static final String KEY_HIDE_LIVE_MAP_HINT = "hidelivemaphint";
    private static final String KEY_LIVE_MAP_HINT_SHOW_COUNT = "livemaphintshowcount";
    private static final String KEY_SETTINGS_VERSION = "settingsversion";

    private final static int unitsMetric = 1;

    // twitter api keys
    private final static String keyConsumerPublic = CryptUtils.rot13("ESnsCvAv3kEupF1GCR3jGj");
    private final static String keyConsumerSecret = CryptUtils.rot13("7vQWceACV9umEjJucmlpFe9FCMZSeqIqfkQ2BnhV9x");

    private interface PrefRunnable {
        void edit(final Editor edit);
    }

    public enum coordInputFormatEnum {
        Plain,
        Deg,
        Min,
        Sec;

        static coordInputFormatEnum fromInt(int id) {
            final coordInputFormatEnum[] values = coordInputFormatEnum.values();
            if (id >= 0 && id < values.length) {
                return values[id];
            } else {
                return Min;
            }
        }
    }

    private static String username = null;
    private static String password = null;

    private static final SharedPreferences sharedPrefs = PreferenceManager.getDefaultSharedPreferences(cgeoapplication.getInstance().getBaseContext());
    static {
        migrateSettings();
    }

    // Debug settings are accessed often enough to be cached
    private static Boolean cachedDebug = sharedPrefs.getBoolean(KEY_DEBUG, false);

    // maps
    private static MapProvider mapProvider = null;

    private Settings() {
        // this class is not to be instantiated;
    }

    private static void migrateSettings() {
        // migrate from non standard file location and integer based boolean types
        if (sharedPrefs.getInt(KEY_SETTINGS_VERSION, 0) < 1) {
            final String oldPreferencesName = "cgeo.pref";
            final SharedPreferences old = cgeoapplication.getInstance().getSharedPreferences(oldPreferencesName, Context.MODE_PRIVATE);
            final Editor e = sharedPrefs.edit();

            e.putString(KEY_TEMP_TOKEN_SECRET, old.getString(KEY_TEMP_TOKEN_SECRET, null));
            e.putString(KEY_TEMP_TOKEN_PUBLIC, old.getString(KEY_TEMP_TOKEN_PUBLIC, null));
            e.putBoolean(KEY_HELP_SHOWN, old.getInt(KEY_HELP_SHOWN, 0) != 0);
            e.putFloat(KEY_ANYLONGITUDE, old.getFloat(KEY_ANYLONGITUDE, 0));
            e.putFloat(KEY_ANYLATITUDE, old.getFloat(KEY_ANYLATITUDE, 0));
            e.putBoolean(KEY_PUBLICLOC, 0 != old.getInt(KEY_PUBLICLOC, 0));
            e.putBoolean(KEY_USE_OFFLINEMAPS, 0 != old.getInt(KEY_USE_OFFLINEMAPS, 1));
            e.putBoolean(KEY_USE_OFFLINEWPMAPS, 0 != old.getInt(KEY_USE_OFFLINEWPMAPS, 0));
            e.putString(KEY_WEB_DEVICE_CODE, old.getString(KEY_WEB_DEVICE_CODE, null));
            e.putString(KEY_WEBDEVICE_NAME, old.getString(KEY_WEBDEVICE_NAME, null));
            e.putBoolean(KEY_MAP_LIVE, old.getInt(KEY_MAP_LIVE, 1) != 0);
            e.putInt(KEY_MAP_SOURCE, old.getInt(KEY_MAP_SOURCE, 0));
            e.putBoolean(KEY_USE_TWITTER, 0 != old.getInt(KEY_USE_TWITTER, 0));
            e.putBoolean(KEY_SHOW_ADDRESS, 0 != old.getInt(KEY_SHOW_ADDRESS, 1));
            e.putBoolean(KEY_SHOW_CAPTCHA, old.getBoolean(KEY_SHOW_CAPTCHA, false));
            e.putBoolean(KEY_MAP_TRAIL, old.getInt(KEY_MAP_TRAIL, 1) != 0);
            e.putInt(KEY_LAST_MAP_ZOOM, old.getInt(KEY_LAST_MAP_ZOOM, 14));
            e.putBoolean(KEY_LIVE_LIST, 0 != old.getInt(KEY_LIVE_LIST, 1));
            e.putBoolean(KEY_METRIC_UNITS, old.getInt(KEY_METRIC_UNITS, unitsMetric) == unitsMetric);
            e.putBoolean(KEY_SKIN, old.getInt(KEY_SKIN, 0) != 0);
            e.putInt(KEY_LAST_USED_LIST, old.getInt(KEY_LAST_USED_LIST, StoredList.STANDARD_LIST_ID));
            e.putString(KEY_CACHE_TYPE, old.getString(KEY_CACHE_TYPE, CacheType.ALL.id));
            e.putString(KEY_TWITTER_TOKEN_SECRET, old.getString(KEY_TWITTER_TOKEN_SECRET, null));
            e.putString(KEY_TWITTER_TOKEN_PUBLIC, old.getString(KEY_TWITTER_TOKEN_PUBLIC, null));
            e.putInt(KEY_VERSION, old.getInt(KEY_VERSION, 0));
            e.putBoolean(KEY_LOAD_DESCRIPTION, 0 != old.getInt(KEY_LOAD_DESCRIPTION, 0));
            e.putBoolean(KEY_RATING_WANTED, old.getBoolean(KEY_RATING_WANTED, true));
            e.putBoolean(KEY_ELEVATION_WANTED, old.getBoolean(KEY_ELEVATION_WANTED, true));
            e.putBoolean(KEY_FRIENDLOGS_WANTED, old.getBoolean(KEY_FRIENDLOGS_WANTED, true));
            e.putBoolean(KEY_USE_ENGLISH, old.getBoolean(KEY_USE_ENGLISH, false));
            e.putBoolean(KEY_USE_COMPASS, 0 != old.getInt(KEY_USE_COMPASS, 1));
            e.putBoolean(KEY_AUTO_VISIT_TRACKABLES, old.getBoolean(KEY_AUTO_VISIT_TRACKABLES, false));
            e.putBoolean(KEY_AUTO_INSERT_SIGNATURE, old.getBoolean(KEY_AUTO_INSERT_SIGNATURE, false));
            e.putInt(KEY_ALTITUDE_CORRECTION, old.getInt(KEY_ALTITUDE_CORRECTION, 0));
            e.putBoolean(KEY_USE_GOOGLE_NAVIGATION, 0 != old.getInt(KEY_USE_GOOGLE_NAVIGATION, 1));
            e.putBoolean(KEY_STORE_LOG_IMAGES, old.getBoolean(KEY_STORE_LOG_IMAGES, false));
            e.putBoolean(KEY_EXCLUDE_DISABLED, 0 != old.getInt(KEY_EXCLUDE_DISABLED, 0));
            e.putBoolean(KEY_EXCLUDE_OWN, 0 != old.getInt(KEY_EXCLUDE_OWN, 0));
            e.putString(KEY_MAPFILE, old.getString(KEY_MAPFILE, null));
            e.putString(KEY_SIGNATURE, old.getString(KEY_SIGNATURE, null));
            e.putString(KEY_GCVOTE_PASSWORD, old.getString(KEY_GCVOTE_PASSWORD, null));
            e.putString(KEY_PASSWORD, old.getString(KEY_PASSWORD, null));
            e.putString(KEY_USERNAME, old.getString(KEY_USERNAME, null));
            e.putString(KEY_MEMBER_STATUS, old.getString(KEY_MEMBER_STATUS, ""));
            e.putInt(KEY_COORD_INPUT_FORMAT, old.getInt(KEY_COORD_INPUT_FORMAT, 0));
            e.putBoolean(KEY_LOG_OFFLINE, old.getBoolean(KEY_LOG_OFFLINE, false));
            e.putBoolean(KEY_LOAD_DIRECTION_IMG, old.getBoolean(KEY_LOAD_DIRECTION_IMG, true));
            e.putString(KEY_GC_CUSTOM_DATE, old.getString(KEY_GC_CUSTOM_DATE, null));
            e.putInt(KEY_SHOW_WAYPOINTS_THRESHOLD, old.getInt(KEY_SHOW_WAYPOINTS_THRESHOLD, 0));
            e.putString(KEY_COOKIE_STORE, old.getString(KEY_COOKIE_STORE, null));
            e.putBoolean(KEY_OPEN_LAST_DETAILS_PAGE, old.getBoolean(KEY_OPEN_LAST_DETAILS_PAGE, false));
            e.putInt(KEY_LAST_DETAILS_PAGE, old.getInt(KEY_LAST_DETAILS_PAGE, 1));
            e.putInt(KEY_DEFAULT_NAVIGATION_TOOL, old.getInt(KEY_DEFAULT_NAVIGATION_TOOL, 0));
            e.putInt(KEY_DEFAULT_NAVIGATION_TOOL_2, old.getInt(KEY_DEFAULT_NAVIGATION_TOOL_2, 0));
            e.putInt(KEY_LIVE_MAP_STRATEGY, old.getInt(KEY_LIVE_MAP_STRATEGY, Strategy.AUTO.id));
            e.putBoolean(KEY_DEBUG, old.getBoolean(KEY_DEBUG, false));
            e.putBoolean(KEY_HIDE_LIVE_MAP_HINT, old.getInt(KEY_HIDE_LIVE_MAP_HINT, 0) != 0);
            e.putInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, old.getInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, 0));

            e.putInt(KEY_SETTINGS_VERSION, 1) ; // mark migrated
            e.commit();
            cachedDebug = sharedPrefs.getBoolean(KEY_DEBUG, false);
        }
    }

    public static void setLanguage(boolean useEnglish) {
        final Configuration config = new Configuration();
        config.locale = useEnglish ? new Locale("en") : Locale.getDefault();
        final Resources resources = cgeoapplication.getInstance().getResources();
        resources.updateConfiguration(config, resources.getDisplayMetrics());
    }

    public static boolean isLogin() {
        final String preUsername = sharedPrefs.getString(KEY_USERNAME, null);
        final String prePassword = sharedPrefs.getString(KEY_PASSWORD, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    /**
     * Get login and password information.
     *
     * @return a pair (login, password) or null if no valid information is stored
     */
    public static ImmutablePair<String, String> getLogin() {
        if (username == null || password == null) {
            final String preUsername = sharedPrefs.getString(KEY_USERNAME, null);
            final String prePassword = sharedPrefs.getString(KEY_PASSWORD, null);

            if (preUsername == null || prePassword == null) {
                return null;
            }

            username = preUsername;
            password = prePassword;
        }
        return new ImmutablePair<String, String>(username, password);
    }

    public static String getUsername() {
        if (null == username) {
            return sharedPrefs.getString(KEY_USERNAME, null);
        } else {
            return username;
        }
    }

    public static boolean setLogin(final String username, final String password) {
        Settings.username = username;
        Settings.password = password;
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
                    // erase username and password
                    edit.remove(KEY_USERNAME);
                    edit.remove(KEY_PASSWORD);
                } else {
                    // save username and password
                    edit.putString(KEY_USERNAME, username);
                    edit.putString(KEY_PASSWORD, password);
                }
            }
        });
    }

    public static boolean isPremiumMember() {
        // Basic Member, Premium Member, ???
        String memberStatus = Settings.getMemberStatus();
        if (memberStatus == null) {
            return false;
        }
        return "Premium Member".equalsIgnoreCase(memberStatus);
    }

    public static String getMemberStatus() {
        return sharedPrefs.getString(KEY_MEMBER_STATUS, "");
    }

    public static boolean setMemberStatus(final String memberStatus) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(memberStatus)) {
                    edit.remove(KEY_MEMBER_STATUS);
                } else {
                    edit.putString(KEY_MEMBER_STATUS, memberStatus);
                }
            }
        });
    }

    public static boolean isGCvoteLogin() {
        final String preUsername = sharedPrefs.getString(KEY_USERNAME, null);
        final String prePassword = sharedPrefs.getString(KEY_GCVOTE_PASSWORD, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    public static boolean setGCvoteLogin(final String password) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(password)) {
                    // erase password
                    edit.remove(KEY_GCVOTE_PASSWORD);
                } else {
                    // save password
                    edit.putString(KEY_GCVOTE_PASSWORD, password);
                }
            }
        });
    }

    public static ImmutablePair<String, String> getGCvoteLogin() {
        final String username = sharedPrefs.getString(KEY_USERNAME, null);
        final String password = sharedPrefs.getString(KEY_GCVOTE_PASSWORD, null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return null;
        }

        return new ImmutablePair<String, String>(username, password);
    }

    public static boolean setSignature(final String signature) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(signature)) {
                    // erase signature
                    edit.remove(KEY_SIGNATURE);
                } else {
                    // save signature
                    edit.putString(KEY_SIGNATURE, signature);
                }
            }
        });
    }

    public static String getSignature() {
        return sharedPrefs.getString(KEY_SIGNATURE, null);
    }

    public static boolean setCookieStore(final String cookies) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(final Editor edit) {
                if (StringUtils.isBlank(cookies)) {
                    // erase cookies
                    edit.remove(KEY_COOKIE_STORE);
                } else {
                    // save cookies
                    edit.putString(KEY_COOKIE_STORE, cookies);
                }
            }
        });
    }

    public static String getCookieStore() {
        return sharedPrefs.getString(KEY_COOKIE_STORE, null);
    }

    /**
     * @param cacheType
     *            The cache type used for future filtering
     */
    public static void setCacheType(final CacheType cacheType) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                if (cacheType == null) {
                    edit.remove(KEY_CACHE_TYPE);
                } else {
                    edit.putString(KEY_CACHE_TYPE, cacheType.id);
                }
            }
        });
    }

    public static void setLiveMap(final boolean live) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_MAP_LIVE, live);
            }
        });
    }

    public static int getLastList() {
        final int listId = sharedPrefs.getInt(KEY_LAST_USED_LIST, StoredList.STANDARD_LIST_ID);

        return listId;
    }

    public static void saveLastList(final int listId) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_USED_LIST, listId);
            }
        });
    }

    public static void setWebNameCode(final String name, final String code) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {

                edit.putString(KEY_WEBDEVICE_NAME, name);
                edit.putString(KEY_WEB_DEVICE_CODE, code);
            }
        });
    }

    public static MapProvider getMapProvider() {
        if (mapProvider == null) {
            mapProvider = MapProviderFactory.getMapProvider(getMapSource());
        }
        return mapProvider;
    }

    public static String getMapFile() {
        return sharedPrefs.getString(KEY_MAPFILE, null);
    }

    public static boolean setMapFile(final String mapFile) {
        final boolean commitResult = editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_MAPFILE, mapFile);
            }
        });

        return commitResult;
    }

    public static coordInputFormatEnum getCoordInputFormat() {
        return coordInputFormatEnum.fromInt(sharedPrefs.getInt(KEY_COORD_INPUT_FORMAT, 0));
    }

    public static void setCoordInputFormat(final coordInputFormatEnum format) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_COORD_INPUT_FORMAT, format.ordinal());
            }
        });
    }

    static void setLogOffline(final boolean offline) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LOG_OFFLINE, offline);
            }
        });
    }

    public static boolean getLogOffline() {
        return sharedPrefs.getBoolean(KEY_LOG_OFFLINE, false);
    }

    static void setLoadDirImg(final boolean value) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LOAD_DIRECTION_IMG, value);
            }
        });
    }

    public static boolean getLoadDirImg() {
        return isPremiumMember() ? false : sharedPrefs.getBoolean(KEY_LOAD_DIRECTION_IMG, true);
    }

    public static void setGcCustomDate(final String format) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_GC_CUSTOM_DATE, format);
            }
        });
    }

    /**
     * @return User selected date format on GC.com
     * @see cgBase.gcCustomDateFormats
     */
    public static String getGcCustomDate() {
        return sharedPrefs.getString(KEY_GC_CUSTOM_DATE, null);
    }

    public static boolean isExcludeMyCaches() {
        return sharedPrefs.getBoolean(KEY_EXCLUDE_OWN, false);
    }

    /**
     * edit some settings without knowing how to get the settings editor or how to commit
     *
     * @param runnable
     * @return
     */
    private static boolean editSharedSettings(final PrefRunnable runnable) {
        final SharedPreferences.Editor prefsEdit = sharedPrefs.edit();
        runnable.edit(prefsEdit);
        return prefsEdit.commit();
    }

    public static void setExcludeMine(final boolean exclude) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_EXCLUDE_OWN, exclude);
            }
        });
    }

    public static void setUseEnglish(final boolean english) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_ENGLISH, english);
                setLanguage(english);
            }
        });
    }

    public static boolean isUseEnglish() {
        return sharedPrefs.getBoolean(KEY_USE_ENGLISH, false);
    }

    public static boolean isShowAddress() {
        return sharedPrefs.getBoolean(KEY_SHOW_ADDRESS, true);
    }

    public static void setShowAddress(final boolean showAddress) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SHOW_ADDRESS, showAddress);
            }
        });
    }

    public static boolean isShowCaptcha() {
        return isPremiumMember() ? false : sharedPrefs.getBoolean(KEY_SHOW_CAPTCHA, false);
    }

    public static void setShowCaptcha(final boolean showCaptcha) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SHOW_CAPTCHA, showCaptcha);
            }
        });
    }

    public static boolean isExcludeDisabledCaches() {
        return sharedPrefs.getBoolean(KEY_EXCLUDE_DISABLED, false);
    }

    public static void setExcludeDisabledCaches(final boolean exclude) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_EXCLUDE_DISABLED, exclude);
            }
        });
    }

    public static boolean isStoreOfflineMaps() {
        return sharedPrefs.getBoolean(KEY_USE_OFFLINEMAPS, true);
    }

    public static void setStoreOfflineMaps(final boolean offlineMaps) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_OFFLINEMAPS, offlineMaps);
            }
        });
    }

    public static boolean isStoreOfflineWpMaps() {
        return sharedPrefs.getBoolean(KEY_USE_OFFLINEWPMAPS, false);
    }

    public static void setStoreOfflineWpMaps(final boolean offlineMaps) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_OFFLINEWPMAPS, offlineMaps);
            }
        });
    }

    public static boolean isStoreLogImages() {
        return sharedPrefs.getBoolean(KEY_STORE_LOG_IMAGES, false);
    }

    public static void setStoreLogImages(final boolean storeLogImages) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_STORE_LOG_IMAGES, storeLogImages);
            }
        });
    }

    public static boolean isUseGoogleNavigation() {
        return sharedPrefs.getBoolean(KEY_USE_GOOGLE_NAVIGATION, true);
    }

    public static void setUseGoogleNavigation(final boolean useGoogleNavigation) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_GOOGLE_NAVIGATION, useGoogleNavigation);
            }
        });
    }

    public static boolean isAutoLoadDescription() {
        return sharedPrefs.getBoolean(KEY_LOAD_DESCRIPTION, false);
    }

    public static void setAutoLoadDesc(final boolean autoLoad) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LOAD_DESCRIPTION, autoLoad);
            }
        });
    }

    public static boolean isRatingWanted() {
        return sharedPrefs.getBoolean(KEY_RATING_WANTED, true);
    }

    public static void setRatingWanted(final boolean ratingWanted) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_RATING_WANTED, ratingWanted);
            }
        });
    }

    public static boolean isElevationWanted() {
        return sharedPrefs.getBoolean(KEY_ELEVATION_WANTED, true);
    }

    public static void setElevationWanted(final boolean elevationWanted) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_ELEVATION_WANTED, elevationWanted);
            }
        });
    }

    public static boolean isFriendLogsWanted() {
        if (!isLogin()) {
            // don't show a friends log if the user is anonymous
            return false;
        }
        return sharedPrefs.getBoolean(KEY_FRIENDLOGS_WANTED, true);
    }

    public static void setFriendLogsWanted(final boolean friendLogsWanted) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_FRIENDLOGS_WANTED, friendLogsWanted);
            }
        });
    }

    public static boolean isLiveList() {
        return sharedPrefs.getBoolean(KEY_LIVE_LIST, true);
    }

    public static void setLiveList(final boolean liveList) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LIVE_LIST, liveList);
            }
        });
    }

    public static boolean isPublicLoc() {
        return sharedPrefs.getBoolean(KEY_PUBLICLOC, false);
    }

    public static void setPublicLoc(final boolean publicLocation) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_PUBLICLOC, publicLocation);
            }
        });
    }

    public static boolean isTrackableAutoVisit() {
        return sharedPrefs.getBoolean(KEY_AUTO_VISIT_TRACKABLES, false);
    }

    public static void setTrackableAutoVisit(final boolean autoVisit) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_AUTO_VISIT_TRACKABLES, autoVisit);
            }
        });
    }

    public static boolean isAutoInsertSignature() {
        return sharedPrefs.getBoolean(KEY_AUTO_INSERT_SIGNATURE, false);
    }

    public static void setAutoInsertSignature(final boolean autoInsert) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_AUTO_INSERT_SIGNATURE, autoInsert);
            }
        });
    }

    public static boolean isUseMetricUnits() {
        return sharedPrefs.getBoolean(KEY_METRIC_UNITS, true);
    }

    public static void setUseMetricUnits(final boolean metric) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_METRIC_UNITS, metric);
            }
        });
    }

    public static boolean isLiveMap() {
        return sharedPrefs.getBoolean(KEY_MAP_LIVE, true);
    }

    public static boolean isMapTrail() {
        return sharedPrefs.getBoolean(KEY_MAP_TRAIL, true);
    }

    public static void setMapTrail(final boolean showTrail) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_MAP_TRAIL, showTrail);
            }
        });
    }

    public static int getMapZoom() {
        return sharedPrefs.getInt(KEY_LAST_MAP_ZOOM, 14);
    }

    public static void setMapZoom(final int mapZoomLevel) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_MAP_ZOOM, mapZoomLevel);
            }
        });
    }

    public static int getMapSource() {
        return sharedPrefs.getInt(KEY_MAP_SOURCE, 0);
    }

    public static void setMapSource(final int newMapSource) {
        if (!MapProviderFactory.isSameProvider(getMapSource(), newMapSource)) {
            mapProvider = null;
        }
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_MAP_SOURCE, newMapSource);
            }
        });
    }

    public static void setAnyCoordinates(final Geopoint coords) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (null != coords) {
                    edit.putFloat(KEY_ANYLATITUDE, (float) coords.getLatitude());
                    edit.putFloat(KEY_ANYLONGITUDE, (float) coords.getLongitude());
                } else {
                    edit.remove(KEY_ANYLATITUDE);
                    edit.remove(KEY_ANYLONGITUDE);
                }
            }
        });

    }

    public static Geopoint getAnyCoordinates() {
        if (sharedPrefs.contains(KEY_ANYLATITUDE) && sharedPrefs.contains(KEY_ANYLONGITUDE)) {
            float lat = sharedPrefs.getFloat(KEY_ANYLATITUDE, 0);
            float lon = sharedPrefs.getFloat(KEY_ANYLONGITUDE, 0);
            return new Geopoint(lat, lon);
        }
        return null;
    }

    public static boolean isUseCompass() {
        return sharedPrefs.getBoolean(KEY_USE_COMPASS, true);
    }

    public static void setUseCompass(final boolean useCompass) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_COMPASS, useCompass);
            }
        });
    }

    public static boolean isHelpShown() {
        return sharedPrefs.getBoolean(KEY_HELP_SHOWN, false);
    }

    public static void setHelpShown() {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_HELP_SHOWN, true);
            }
        });
    }

    public static boolean isLightSkin() {
        return sharedPrefs.getBoolean(KEY_SKIN, false);
    }

    public static void setLightSkin(final boolean lightSkin) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SKIN, lightSkin);
            }
        });
    }

    public static String getKeyConsumerPublic() {
        return keyConsumerPublic;
    }

    public static String getKeyConsumerSecret() {
        return keyConsumerSecret;
    }

    public static int getAltCorrection() {
        return sharedPrefs.getInt(KEY_ALTITUDE_CORRECTION, 0);
    }

    public static boolean setAltCorrection(final int altitude) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_ALTITUDE_CORRECTION, altitude);
            }
        });
    }

    public static String getWebDeviceCode() {
        return sharedPrefs.getString(KEY_WEB_DEVICE_CODE, null);
    }

    public static String getWebDeviceName() {
        return sharedPrefs.getString(KEY_WEBDEVICE_NAME, null);
    }

    /**
     * @return The cache type used for filtering or ALL if no filter is active. Returns never null
     */
    public static CacheType getCacheType() {
        return CacheType.getById(sharedPrefs.getString(KEY_CACHE_TYPE, CacheType.ALL.id));
    }

    /**
     * The Threshold for the showing of child waypoints
     * 
     * @return
     */

    public static int getWayPointsThreshold() {
        return sharedPrefs.getInt(KEY_SHOW_WAYPOINTS_THRESHOLD, 0);
    }

    public static void setShowWaypointsThreshold(final int threshold) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_SHOW_WAYPOINTS_THRESHOLD, threshold);
            }
        });
    }

    public static boolean isUseTwitter() {
        return sharedPrefs.getBoolean(KEY_USE_TWITTER, false);
    }

    public static void setUseTwitter(final boolean useTwitter) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_TWITTER, useTwitter);
            }
        });
    }

    public static boolean isTwitterLoginValid() {
        return !StringUtils.isBlank(getTokenPublic()) && !StringUtils.isBlank(getTokenSecret());
    }

    public static String getTokenPublic() {
        return sharedPrefs.getString(KEY_TWITTER_TOKEN_PUBLIC, null);
    }

    public static String getTokenSecret() {
        return sharedPrefs.getString(KEY_TWITTER_TOKEN_SECRET, null);

    }

    public static int getVersion() {
        return sharedPrefs.getInt(KEY_VERSION, 0);
    }

    public static void setTwitterTokens(final String tokenPublic, final String tokenSecret, boolean enableTwitter) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_TWITTER_TOKEN_PUBLIC, tokenPublic);
                edit.putString(KEY_TWITTER_TOKEN_SECRET, tokenSecret);
                if (tokenPublic != null) {
                    edit.remove(KEY_TEMP_TOKEN_PUBLIC);
                    edit.remove(KEY_TEMP_TOKEN_SECRET);
                }
            }
        });
        setUseTwitter(enableTwitter);
    }

    public static void setTwitterTempTokens(final String tokenPublic, final String tokenSecret) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_TEMP_TOKEN_PUBLIC, tokenPublic);
                edit.putString(KEY_TEMP_TOKEN_SECRET, tokenSecret);
            }
        });
    }

    public static ImmutablePair<String, String> getTempToken() {
        String tokenPublic = sharedPrefs.getString(KEY_TEMP_TOKEN_PUBLIC, null);
        String tokenSecret = sharedPrefs.getString(KEY_TEMP_TOKEN_SECRET, null);
        return new ImmutablePair<String, String>(tokenPublic, tokenSecret);
    }

    public static void setVersion(final int version) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_VERSION, version);
            }
        });
    }

    public static boolean isOpenLastDetailsPage() {
        return sharedPrefs.getBoolean(KEY_OPEN_LAST_DETAILS_PAGE, false);
    }

    public static void setOpenLastDetailsPage(final boolean openLastPage) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_OPEN_LAST_DETAILS_PAGE, openLastPage);
            }
        });
    }

    public static int getLastDetailsPage() {
        return sharedPrefs.getInt(KEY_LAST_DETAILS_PAGE, 1);
    }

    public static void setLastDetailsPage(final int index) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_DETAILS_PAGE, index);
            }
        });
    }

    public static int getDefaultNavigationTool() {
        return sharedPrefs.getInt(KEY_DEFAULT_NAVIGATION_TOOL, 0);
    }

    public static void setDefaultNavigationTool(final int defaultNavigationTool) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_DEFAULT_NAVIGATION_TOOL, defaultNavigationTool);
            }
        });
    }

    public static int getDefaultNavigationTool2() {
        return sharedPrefs.getInt(KEY_DEFAULT_NAVIGATION_TOOL_2, 0);
    }

    public static void setDefaultNavigationTool2(final int defaultNavigationTool) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_DEFAULT_NAVIGATION_TOOL_2, defaultNavigationTool);
            }
        });
    }

    public static Strategy getLiveMapStrategy() {
        return Strategy.getById(sharedPrefs.getInt(KEY_LIVE_MAP_STRATEGY, Strategy.AUTO.id));
    }

    public static void setLiveMapStrategy(final Strategy strategy) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LIVE_MAP_STRATEGY, strategy.id);
            }
        });
    }


    public static boolean isDebug() {
        return cachedDebug;
    }

    public static void setDebug(final boolean debug) {
        editSharedSettings(new PrefRunnable() {

            @Override public void edit(Editor edit) {
                edit.putBoolean(KEY_DEBUG, debug);
            }
        });
        cachedDebug = debug;
    }

    public static boolean getHideLiveMapHint() {
        return sharedPrefs.getBoolean(KEY_HIDE_LIVE_MAP_HINT, false);
    }

    public static void setHideLiveHint(final boolean hide) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_HIDE_LIVE_MAP_HINT, hide);
            }
        });
    }

    public static int getLiveMapHintShowCount() {
        return sharedPrefs.getInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, 0);
    }

    public static void setLiveMapHintShowCount(final int showCount) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, showCount);
            }
        });
    }

    public static String getPreferencesName() {
        // there is currently no Android API to get the file name of the shared preferences
        return cgeoapplication.getInstance().getPackageName() + "_preferences";
    }
}
!@#$%
20190526_235301,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_b05936
package cgeo.geocaching.connector.gc;

import cgeo.geocaching.R;
import cgeo.geocaching.Settings;
import cgeo.geocaching.cgeoapplication;
import cgeo.geocaching.enumerations.StatusCode;
import cgeo.geocaching.network.Cookies;
import cgeo.geocaching.network.HtmlImage;
import cgeo.geocaching.network.Network;
import cgeo.geocaching.network.Parameters;
import cgeo.geocaching.utils.BaseUtils;
import cgeo.geocaching.utils.Log;

import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.apache.http.HttpResponse;

import android.content.Context;
import android.graphics.drawable.BitmapDrawable;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;
import java.util.regex.Matcher;

public abstract class Login {

    private final static String ENGLISH = "English&#9660;";

    // false = not logged in
    private static boolean actualLoginStatus = false;
    private static String actualUserName = "";
    private static int actualCachesFound = -1;
    private static String actualStatus = "";

    private final static Map<String, SimpleDateFormat> gcCustomDateFormats;
    static {
        final String[] formats = new String[] {
                "MM/dd/yyyy",
                "yyyy-MM-dd",
                "yyyy/MM/dd",
                "dd/MMM/yyyy",
                "MMM/dd/yyyy",
                "dd MMM yy",
                "dd/MM/yyyy"
        };

        Map<String, SimpleDateFormat> map = new HashMap<String, SimpleDateFormat>();

        for (String format : formats) {
            map.put(format, new SimpleDateFormat(format, Locale.ENGLISH));
        }

        gcCustomDateFormats = Collections.unmodifiableMap(map);
    }

    public static StatusCode login() {
        final ImmutablePair<String, String> login = Settings.getLogin();

        if (login == null || StringUtils.isEmpty(login.left) || StringUtils.isEmpty(login.right)) {
            Login.setActualStatus(cgeoapplication.getInstance().getString(R.string.err_login));
            Log.e("cgeoBase.login: No login information stored");
            return StatusCode.NO_LOGIN_INFO_STORED;
        }

        Login.setActualStatus(cgeoapplication.getInstance().getString(R.string.init_login_popup_working));
        HttpResponse loginResponse = Network.getRequest("https://www.geocaching.com/login/default.aspx");
        String loginData = Network.getResponseData(loginResponse);
        if (loginResponse != null && loginResponse.getStatusLine().getStatusCode() == 503 && BaseUtils.matches(loginData, GCConstants.PATTERN_MAINTENANCE)) {
            return StatusCode.MAINTENANCE;
        }

        if (StringUtils.isBlank(loginData)) {
            Log.e("cgeoBase.login: Failed to retrieve login page (1st)");
            return StatusCode.CONNECTION_FAILED; // no loginpage
        }

        if (Login.getLoginStatus(loginData)) {
            Log.i("Already logged in Geocaching.com as " + login.left);
            Login.switchToEnglish(loginData);
            return StatusCode.NO_ERROR; // logged in
        }

        Cookies.clearCookies();
        Settings.setCookieStore(null);

        final Parameters params = new Parameters(
                "__EVENTTARGET", "",
                "__EVENTARGUMENT", "",
                "ctl00$ContentBody$tbUsername", login.left,
                "ctl00$ContentBody$tbPassword", login.right,
                "ctl00$ContentBody$cbRememberMe", "on",
                "ctl00$ContentBody$btnSignIn", "Login");
        final String[] viewstates = Login.getViewstates(loginData);
        if (isEmpty(viewstates)) {
            Log.e("cgeoBase.login: Failed to find viewstates");
            return StatusCode.LOGIN_PARSE_ERROR; // no viewstates
        }
        Login.putViewstates(params, viewstates);

        loginResponse = Network.postRequest("https://www.geocaching.com/login/default.aspx", params);
        loginData = Network.getResponseData(loginResponse);

        if (StringUtils.isBlank(loginData)) {
            Log.e("cgeoBase.login: Failed to retrieve login page (2nd)");
            // FIXME: should it be CONNECTION_FAILED to match the first attempt?
            return StatusCode.COMMUNICATION_ERROR; // no login page
        }

        if (Login.getLoginStatus(loginData)) {
            Log.i("Successfully logged in Geocaching.com as " + login.left);

            Login.switchToEnglish(loginData);
            Settings.setCookieStore(Cookies.dumpCookieStore());

            return StatusCode.NO_ERROR; // logged in
        }

        if (loginData.contains("Your username/password combination does not match.")) {
            Log.i("Failed to log in Geocaching.com as " + login.left + " because of wrong username/password");
            return StatusCode.WRONG_LOGIN_DATA; // wrong login
        }

        Log.i("Failed to log in Geocaching.com as " + login.left + " for some unknown reason");
            return StatusCode.UNKNOWN_ERROR; // can't login
    }

    public static StatusCode logout() {
        HttpResponse logoutResponse = Network.getRequest("https://www.geocaching.com/login/default.aspx?RESET=Y&redir=http%3a%2f%2fwww.geocaching.com%2fdefault.aspx%3f");
        String logoutData = Network.getResponseData(logoutResponse);
        if (logoutResponse != null && logoutResponse.getStatusLine().getStatusCode() == 503 && BaseUtils.matches(logoutData, GCConstants.PATTERN_MAINTENANCE)) {
            return StatusCode.MAINTENANCE;
        }

        Cookies.clearCookies();
        Settings.setCookieStore(null);
        return StatusCode.NO_ERROR;
    }

    public static void setActualCachesFound(final int found) {
        actualCachesFound = found;
    }

    public static String getActualStatus() {
        return actualStatus;
    }

    public static void setActualStatus(final String status) {
        actualStatus = status;
    }

    public static boolean isActualLoginStatus() {
        return actualLoginStatus;
    }

    public static void setActualLoginStatus(boolean loginStatus) {
        actualLoginStatus = loginStatus;
    }

    public static String getActualUserName() {
        return actualUserName;
    }

    public static void setActualUserName(String userName) {
        actualUserName = userName;
    }

    public static int getActualCachesFound() {
        return actualCachesFound;
    }

    /**
     * Check if the user has been logged in when he retrieved the data.
     *
     * @param page
     * @return <code>true</code> if user is logged in, <code>false</code> otherwise
     */
    public static boolean getLoginStatus(final String page) {
        if (StringUtils.isBlank(page)) {
            Log.e("cgeoBase.checkLogin: No page given");
            return false;
        }

        setActualStatus(cgeoapplication.getInstance().getString(R.string.init_login_popup_ok));

        // on every page except login page
        setActualLoginStatus(BaseUtils.matches(page, GCConstants.PATTERN_LOGIN_NAME));
        if (isActualLoginStatus()) {
            setActualUserName(BaseUtils.getMatch(page, GCConstants.PATTERN_LOGIN_NAME, true, "???"));
            setActualCachesFound(Integer.parseInt(BaseUtils.getMatch(page, GCConstants.PATTERN_CACHES_FOUND, true, "0").replaceAll("[,.]", "")));
            Settings.setMemberStatus(BaseUtils.getMatch(page, GCConstants.PATTERN_MEMBER_STATUS, true, null));
            return true;
        }

        // login page
        setActualLoginStatus(BaseUtils.matches(page, GCConstants.PATTERN_LOGIN_NAME_LOGIN_PAGE));
        if (isActualLoginStatus()) {
            setActualUserName(Settings.getUsername());
            // number of caches found is not part of this page
            return true;
        }

        setActualStatus(cgeoapplication.getInstance().getString(R.string.init_login_popup_failed));
        return false;
    }

    private static void switchToEnglish(String previousPage) {
        if (previousPage != null && previousPage.contains(ENGLISH)) {
            Log.i("Geocaching.com language already set to English");
            // get find count
            getLoginStatus(Network.getResponseData(Network.getRequest("http://www.geocaching.com/email/")));
        } else {
            final String page = Network.getResponseData(Network.getRequest("http://www.geocaching.com/default.aspx"));
            getLoginStatus(page);
            if (page == null) {
                Log.e("Failed to read viewstates to set geocaching.com language");
            }
            final Parameters params = new Parameters(
                    "__EVENTTARGET", "ctl00$uxLocaleList$uxLocaleList$ctl00$uxLocaleItem", // switch to english
                    "__EVENTARGUMENT", "");
            Login.transferViewstates(page, params);
            final HttpResponse response = Network.postRequest("http://www.geocaching.com/default.aspx", params);
            if (!Network.isSuccess(response)) {
                Log.e("Failed to set geocaching.com language to English");
            }
        }
    }

    public static BitmapDrawable downloadAvatarAndGetMemberStatus(final Context context) {
        try {
            final String profile = BaseUtils.replaceWhitespace(Network.getResponseData(Network.getRequest("http://www.geocaching.com/my/")));

            Settings.setMemberStatus(BaseUtils.getMatch(profile, GCConstants.PATTERN_MEMBER_STATUS, true, null));

            setActualCachesFound(Integer.parseInt(BaseUtils.getMatch(profile, GCConstants.PATTERN_CACHES_FOUND, true, "-1").replaceAll("[,.]", "")));

            final String avatarURL = BaseUtils.getMatch(profile, GCConstants.PATTERN_AVATAR_IMAGE_PROFILE_PAGE, false, null);
            if (null != avatarURL) {
                final HtmlImage imgGetter = new HtmlImage(context, "", false, 0, false);
                return imgGetter.getDrawable(avatarURL);
            }
            // No match? There may be no avatar set by user.
            Log.d("No avatar set for user");
        } catch (Exception e) {
            Log.w("Error when retrieving user avatar", e);
        }
        return null;
    }

    /**
     * Detect user date settings on geocaching.com
     */
    public static void detectGcCustomDate() {

        final String result = Network.getResponseData(Network.getRequest("http://www.geocaching.com/account/ManagePreferences.aspx"));

        if (null == result) {
            Log.w("cgeoBase.detectGcCustomDate: result is null");
            return;
        }

        String customDate = BaseUtils.getMatch(result, GCConstants.PATTERN_CUSTOMDATE, true, null);
        if (null != customDate) {
            Settings.setGcCustomDate(customDate);
        }
    }

    public static Date parseGcCustomDate(final String input, final String format) throws ParseException {
        if (StringUtils.isBlank(input)) {
            throw new ParseException("Input is null", 0);
        }

        final String trimmed = input.trim();

        if (gcCustomDateFormats.containsKey(format)) {
            try {
                return gcCustomDateFormats.get(format).parse(trimmed);
            } catch (ParseException e) {
            }
        }

        for (SimpleDateFormat sdf : gcCustomDateFormats.values()) {
            try {
                return sdf.parse(trimmed);
            } catch (ParseException e) {
            }
        }

        throw new ParseException("No matching pattern", 0);
    }

    public static Date parseGcCustomDate(final String input) throws ParseException {
        return parseGcCustomDate(input, Settings.getGcCustomDate());
    }

    /**
     * checks if an Array of Strings is empty or not. Empty means:
     * - Array is null
     * - or all elements are null or empty strings
     */
    public static boolean isEmpty(String[] a) {
        if (a == null) {
            return true;
        }

        for (String s : a) {
            if (StringUtils.isNotEmpty(s)) {
                return false;
            }
        }
        return true;
    }

    /**
     * read all viewstates from page
     *
     * @return String[] with all view states
     */
    public static String[] getViewstates(String page) {
        // Get the number of viewstates.
        // If there is only one viewstate, __VIEWSTATEFIELDCOUNT is not present

        if (page == null) { // no network access
            return null;
        }

        int count = 1;
        final Matcher matcherViewstateCount = GCConstants.PATTERN_VIEWSTATEFIELDCOUNT.matcher(page);
        if (matcherViewstateCount.find()) {
            try {
                count = Integer.parseInt(matcherViewstateCount.group(1));
            } catch (NumberFormatException e) {
                Log.e("getViewStates", e);
            }
        }

        String[] viewstates = new String[count];

        // Get the viewstates
        int no;
        final Matcher matcherViewstates = GCConstants.PATTERN_VIEWSTATES.matcher(page);
        while (matcherViewstates.find()) {
            String sno = matcherViewstates.group(1); // number of viewstate
            if (sno.length() == 0) {
                no = 0;
            }
            else {
                try {
                    no = Integer.parseInt(sno);
                } catch (NumberFormatException e) {
                    Log.e("getViewStates", e);
                    no = 0;
                }
            }
            viewstates[no] = matcherViewstates.group(2);
        }

        if (viewstates.length != 1 || viewstates[0] != null) {
            return viewstates;
        }
        // no viewstates were present
        return null;
    }

    /**
     * put viewstates into request parameters
     */
    public static void putViewstates(final Parameters params, final String[] viewstates) {
        if (ArrayUtils.isEmpty(viewstates)) {
            return;
        }
        params.put("__VIEWSTATE", viewstates[0]);
        if (viewstates.length > 1) {
            for (int i = 1; i < viewstates.length; i++) {
                params.put("__VIEWSTATE" + i, viewstates[i]);
            }
            params.put("__VIEWSTATEFIELDCOUNT", String.valueOf(viewstates.length));
        }
    }

    /**
     * transfers the viewstates variables from a page (response) to parameters
     * (next request)
     */
    public static void transferViewstates(final String page, final Parameters params) {
        putViewstates(params, getViewstates(page));
    }

    /**
     * POST HTTP request. Do the request a second time if the user is not logged in
     *
     * @param uri
     * @return
     */
    public static String postRequestLogged(final String uri, final Parameters params) {
        HttpResponse response = Network.postRequest(uri, params);
        String data = Network.getResponseData(response);

        if (!getLoginStatus(data)) {
            if (login() == StatusCode.NO_ERROR) {
                response = Network.postRequest(uri, params);
                data = Network.getResponseData(response);
            } else {
                Log.i("Working as guest.");
            }
        }
        return data;
    }

    /**
     * GET HTTP request. Do the request a second time if the user is not logged in
     *
     * @param uri
     * @param params
     * @return
     */
    public static String getRequestLogged(final String uri, final Parameters params) {
        final String data = Network.getResponseData(Network.getRequest(uri, params));

        if (getLoginStatus(data)) {
            return data;
        }

        if (login() == StatusCode.NO_ERROR) {
            return Network.getResponseData(Network.getRequest(uri, params));
        }

        Log.w("Working as guest.");
        return data;
    }

}
!@#$%
20190526_235301,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_a05936
package cgeo.geocaching.network;

import cgeo.geocaching.R;
import cgeo.geocaching.Settings;
import cgeo.geocaching.cgBase;
import cgeo.geocaching.connector.gc.GCConstants;
import cgeo.geocaching.enumerations.StatusCode;
import cgeo.geocaching.utils.BaseUtils;

import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.apache.http.HttpResponse;

import android.content.Context;
import android.graphics.drawable.BitmapDrawable;
import android.util.Log;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;
import java.util.regex.Matcher;

public abstract class Login {

    private final static String ENGLISH = "English&#9660;";

    // false = not logged in
    private static boolean actualLoginStatus = false;
    private static String actualUserName = "";
    private static String actualMemberStatus = "";
    private static int actualCachesFound = -1;
    private static String actualStatus = "";

    private final static Map<String, SimpleDateFormat> gcCustomDateFormats;
    static {
        final String[] formats = new String[] {
                "MM/dd/yyyy",
                "yyyy-MM-dd",
                "yyyy/MM/dd",
                "dd/MMM/yyyy",
                "MMM/dd/yyyy",
                "dd MMM yy",
                "dd/MM/yyyy"
        };

        Map<String, SimpleDateFormat> map = new HashMap<String, SimpleDateFormat>();

        for (String format : formats) {
            map.put(format, new SimpleDateFormat(format, Locale.ENGLISH));
        }

        gcCustomDateFormats = Collections.unmodifiableMap(map);
    }

    public static StatusCode login() {
        final ImmutablePair<String, String> login = Settings.getLogin();

        if (login == null || StringUtils.isEmpty(login.left) || StringUtils.isEmpty(login.right)) {
            Login.setActualStatus(cgBase.res.getString(R.string.err_login));
            Log.e(Settings.tag, "cgeoBase.login: No login information stored");
            return StatusCode.NO_LOGIN_INFO_STORED;
        }

        // res is null during the unit tests
        if (cgBase.res != null) {
            Login.setActualStatus(cgBase.res.getString(R.string.init_login_popup_working));
        }
        HttpResponse loginResponse = Network.request("https://www.geocaching.com/login/default.aspx", null, false, false, false);
        String loginData = Network.getResponseData(loginResponse);
        if (loginResponse != null && loginResponse.getStatusLine().getStatusCode() == 503 && BaseUtils.matches(loginData, GCConstants.PATTERN_MAINTENANCE)) {
            return StatusCode.MAINTENANCE;
        }

        if (StringUtils.isBlank(loginData)) {
            Log.e(Settings.tag, "cgeoBase.login: Failed to retrieve login page (1st)");
            return StatusCode.CONNECTION_FAILED; // no loginpage
        }

        if (Login.getLoginStatus(loginData)) {
            Log.i(Settings.tag, "Already logged in Geocaching.com as " + login.left);
            Login.switchToEnglish(loginData);
            return StatusCode.NO_ERROR; // logged in
        }

        Network.clearCookies();
        Settings.setCookieStore(null);

        final Parameters params = new Parameters(
                "__EVENTTARGET", "",
                "__EVENTARGUMENT", "",
                "ctl00$ContentBody$tbUsername", login.left,
                "ctl00$ContentBody$tbPassword", login.right,
                "ctl00$ContentBody$cbRememberMe", "on",
                "ctl00$ContentBody$btnSignIn", "Login");
        final String[] viewstates = Login.getViewstates(loginData);
        if (cgBase.isEmpty(viewstates)) {
            Log.e(Settings.tag, "cgeoBase.login: Failed to find viewstates");
            return StatusCode.LOGIN_PARSE_ERROR; // no viewstates
        }
        Login.putViewstates(params, viewstates);

        loginResponse = Network.postRequest("https://www.geocaching.com/login/default.aspx", params);
        loginData = Network.getResponseData(loginResponse);

        if (StringUtils.isNotBlank(loginData)) {
            if (Login.getLoginStatus(loginData)) {
                Log.i(Settings.tag, "Successfully logged in Geocaching.com as " + login.left);

                Login.switchToEnglish(loginData);
                Settings.setCookieStore(Network.dumpCookieStore());

                return StatusCode.NO_ERROR; // logged in
            } else {
                if (loginData.contains("Your username/password combination does not match.")) {
                    Log.i(Settings.tag, "Failed to log in Geocaching.com as " + login.left + " because of wrong username/password");
                    return StatusCode.WRONG_LOGIN_DATA; // wrong login
                } else {
                    Log.i(Settings.tag, "Failed to log in Geocaching.com as " + login.left + " for some unknown reason");
                    return StatusCode.UNKNOWN_ERROR; // can't login
                }
            }
        } else {
            Log.e(Settings.tag, "cgeoBase.login: Failed to retrieve login page (2nd)");
            // FIXME: should it be CONNECTION_FAILED to match the first attempt?
            return StatusCode.COMMUNICATION_ERROR; // no login page
        }
    }

    public static StatusCode logout() {
        HttpResponse logoutResponse = Network.request("https://www.geocaching.com/login/default.aspx?RESET=Y&redir=http%3a%2f%2fwww.geocaching.com%2fdefault.aspx%3f", null, false, false, false);
        String logoutData = Network.getResponseData(logoutResponse);
        if (logoutResponse != null && logoutResponse.getStatusLine().getStatusCode() == 503 && BaseUtils.matches(logoutData, GCConstants.PATTERN_MAINTENANCE)) {
            return StatusCode.MAINTENANCE;
        }

        Network.clearCookies();
        Settings.setCookieStore(null);
        return StatusCode.NO_ERROR;
    }

    public static void setActualCachesFound(final int found) {
        actualCachesFound = found;
    }

    public static String getActualStatus() {
        return actualStatus;
    }

    public static void setActualStatus(final String status) {
        actualStatus = status;
    }

    public static boolean isActualLoginStatus() {
        return actualLoginStatus;
    }

    public static void setActualLoginStatus(boolean loginStatus) {
        actualLoginStatus = loginStatus;
    }

    public static String getActualUserName() {
        return actualUserName;
    }

    public static void setActualUserName(String userName) {
        actualUserName = userName;
    }

    public static String getActualMemberStatus() {
        return actualMemberStatus;
    }

    public static void setActualMemberStatus(final String memberStatus) {
        actualMemberStatus = memberStatus;
    }

    public static int getActualCachesFound() {
        return actualCachesFound;
    }

    /**
     * Check if the user has been logged in when he retrieved the data.
     *
     * @param page
     * @return <code>true</code> if user is logged in, <code>false</code> otherwise
     */
    public static boolean getLoginStatus(final String page) {
        if (StringUtils.isBlank(page)) {
            Log.e(Settings.tag, "cgeoBase.checkLogin: No page given");
            return false;
        }

        // res is null during the unit tests
        if (cgBase.res != null) {
            setActualStatus(cgBase.res.getString(R.string.init_login_popup_ok));
        }

        // on every page except login page
        setActualLoginStatus(BaseUtils.matches(page, GCConstants.PATTERN_LOGIN_NAME));
        if (isActualLoginStatus()) {
            setActualUserName(BaseUtils.getMatch(page, GCConstants.PATTERN_LOGIN_NAME, true, "???"));
            setActualMemberStatus(BaseUtils.getMatch(page, GCConstants.PATTERN_MEMBER_STATUS, true, "???"));
            setActualCachesFound(Integer.parseInt(BaseUtils.getMatch(page, GCConstants.PATTERN_CACHES_FOUND, true, "0").replaceAll("[,.]", "")));
            return true;
        }

        // login page
        setActualLoginStatus(BaseUtils.matches(page, GCConstants.PATTERN_LOGIN_NAME_LOGIN_PAGE));
        if (isActualLoginStatus()) {
            setActualUserName(Settings.getUsername());
            setActualMemberStatus(Settings.getMemberStatus());
            // number of caches found is not part of this page
            return true;
        }

        // res is null during the unit tests
        if (cgBase.res != null) {
            setActualStatus(cgBase.res.getString(R.string.init_login_popup_failed));
        }
        return false;
    }

    private static void switchToEnglish(String previousPage) {
        if (previousPage != null && previousPage.indexOf(ENGLISH) >= 0) {
            Log.i(Settings.tag, "Geocaching.com language already set to English");
            // get find count
            getLoginStatus(Network.getResponseData(Network.request("http://www.geocaching.com/email/", null, false)));
        } else {
            final String page = Network.getResponseData(Network.request("http://www.geocaching.com/default.aspx", null, false));
            getLoginStatus(page);
            if (page == null) {
                Log.e(Settings.tag, "Failed to read viewstates to set geocaching.com language");
            }
            final Parameters params = new Parameters(
                    "__EVENTTARGET", "ctl00$uxLocaleList$uxLocaleList$ctl00$uxLocaleItem", // switch to english
                    "__EVENTARGUMENT", "");
            Login.transferViewstates(page, params);
            final HttpResponse response = Network.postRequest("http://www.geocaching.com/default.aspx", params);
            if (!Network.isSuccess(response)) {
                Log.e(Settings.tag, "Failed to set geocaching.com language to English");
            }
        }
    }

    public static BitmapDrawable downloadAvatarAndGetMemberStatus(final Context context) {
        try {
            final String profile = BaseUtils.replaceWhitespace(Network.getResponseData(Network.request("http://www.geocaching.com/my/", null, false)));

            Settings.setMemberStatus(BaseUtils.getMatch(profile, GCConstants.PATTERN_MEMBER_STATUS, true, null));

            setActualCachesFound(Integer.parseInt(BaseUtils.getMatch(profile, GCConstants.PATTERN_CACHES_FOUND, true, "-1").replaceAll("[,.]", "")));

            final String avatarURL = BaseUtils.getMatch(profile, GCConstants.PATTERN_AVATAR_IMAGE_PROFILE_PAGE, false, null);
            if (null != avatarURL) {
                final HtmlImage imgGetter = new HtmlImage(context, "", false, 0, false);
                return imgGetter.getDrawable(avatarURL);
            }
            // No match? There may be no avatar set by user.
            Log.d(Settings.tag, "No avatar set for user");
        } catch (Exception e) {
            Log.w(Settings.tag, "Error when retrieving user avatar", e);
        }
        return null;
    }

    /**
     * Detect user date settings on geocaching.com
     */
    public static void detectGcCustomDate() {

        final String result = Network.getResponseData(Network.request("http://www.geocaching.com/account/ManagePreferences.aspx", null, false, false, false));

        if (null == result) {
            Log.w(Settings.tag, "cgeoBase.detectGcCustomDate: result is null");
            return;
        }

        String customDate = BaseUtils.getMatch(result, GCConstants.PATTERN_CUSTOMDATE, true, null);
        if (null != customDate) {
            Settings.setGcCustomDate(customDate);
        }
    }

    public static Date parseGcCustomDate(final String input, final String format) throws ParseException {
        if (StringUtils.isBlank(input)) {
            throw new ParseException("Input is null", 0);
        }

        final String trimmed = input.trim();

        if (gcCustomDateFormats.containsKey(format)) {
            try {
                return gcCustomDateFormats.get(format).parse(trimmed);
            } catch (ParseException e) {
            }
        }

        for (SimpleDateFormat sdf : gcCustomDateFormats.values()) {
            try {
                return sdf.parse(trimmed);
            } catch (ParseException e) {
            }
        }

        throw new ParseException("No matching pattern", 0);
    }

    public static Date parseGcCustomDate(final String input) throws ParseException {
        return parseGcCustomDate(input, Settings.getGcCustomDate());
    }

    /**
     * read all viewstates from page
     *
     * @return String[] with all view states
     */
    public static String[] getViewstates(String page) {
        // Get the number of viewstates.
        // If there is only one viewstate, __VIEWSTATEFIELDCOUNT is not present

        if (page == null) { // no network access
            return null;
        }

        int count = 1;
        final Matcher matcherViewstateCount = GCConstants.PATTERN_VIEWSTATEFIELDCOUNT.matcher(page);
        if (matcherViewstateCount.find()) {
            try {
                count = Integer.parseInt(matcherViewstateCount.group(1));
            } catch (NumberFormatException e) {
                Log.e(Settings.tag, "getViewStates", e);
            }
        }

        String[] viewstates = new String[count];

        // Get the viewstates
        int no;
        final Matcher matcherViewstates = GCConstants.PATTERN_VIEWSTATES.matcher(page);
        while (matcherViewstates.find()) {
            String sno = matcherViewstates.group(1); // number of viewstate
            if (sno.length() == 0) {
                no = 0;
            }
            else {
                try {
                    no = Integer.parseInt(sno);
                } catch (NumberFormatException e) {
                    Log.e(Settings.tag, "getViewStates", e);
                    no = 0;
                }
            }
            viewstates[no] = matcherViewstates.group(2);
        }

        if (viewstates.length != 1 || viewstates[0] != null) {
            return viewstates;
        }
        // no viewstates were present
        return null;
    }

    /**
     * put viewstates into request parameters
     */
    public static void putViewstates(final Parameters params, final String[] viewstates) {
        if (ArrayUtils.isEmpty(viewstates)) {
            return;
        }
        params.put("__VIEWSTATE", viewstates[0]);
        if (viewstates.length > 1) {
            for (int i = 1; i < viewstates.length; i++) {
                params.put("__VIEWSTATE" + i, viewstates[i]);
            }
            params.put("__VIEWSTATEFIELDCOUNT", String.valueOf(viewstates.length));
        }
    }

    /**
     * transfers the viewstates variables from a page (response) to parameters
     * (next request)
     */
    public static void transferViewstates(final String page, final Parameters params) {
        putViewstates(params, getViewstates(page));
    }

    static public String[] requestViewstates(final String uri, final Parameters params, boolean xContentType, boolean my) {
        final HttpResponse response = Network.request(uri, params, xContentType, my, false);

        return getViewstates(Network.getResponseData(response));
    }

}
!@#$%
20190526_235301,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_c05936
package cgeo.geocaching.network;

import cgeo.geocaching.R;
import cgeo.geocaching.Settings;
import cgeo.geocaching.cgBase;
import cgeo.geocaching.connector.gc.GCConstants;
import cgeo.geocaching.enumerations.StatusCode;
import cgeo.geocaching.utils.BaseUtils;

import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.apache.http.HttpResponse;

import android.content.Context;
import android.graphics.drawable.BitmapDrawable;
import android.util.Log;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;
import java.util.regex.Matcher;

public abstract class Login {

    private final static String ENGLISH = "English&#9660;";

    // false = not logged in
    private static boolean actualLoginStatus = false;
    private static String actualUserName = "";
    private static String actualMemberStatus = "";
    private static int actualCachesFound = -1;
    private static String actualStatus = "";

    private final static Map<String, SimpleDateFormat> gcCustomDateFormats;
    static {
        final String[] formats = new String[] {
                "MM/dd/yyyy",
                "yyyy-MM-dd",
                "yyyy/MM/dd",
                "dd/MMM/yyyy",
                "MMM/dd/yyyy",
                "dd MMM yy",
                "dd/MM/yyyy"
        };

        Map<String, SimpleDateFormat> map = new HashMap<String, SimpleDateFormat>();

        for (String format : formats) {
            map.put(format, new SimpleDateFormat(format, Locale.ENGLISH));
        }

        gcCustomDateFormats = Collections.unmodifiableMap(map);
    }

    public static StatusCode login() {
        final ImmutablePair<String, String> login = Settings.getLogin();

        if (login == null || StringUtils.isEmpty(login.left) || StringUtils.isEmpty(login.right)) {
            Login.setActualStatus(cgBase.res.getString(R.string.err_login));
            Log.e(Settings.tag, "cgeoBase.login: No login information stored");
            return StatusCode.NO_LOGIN_INFO_STORED;
        }

        // res is null during the unit tests
        if (cgBase.res != null) {
            Login.setActualStatus(cgBase.res.getString(R.string.init_login_popup_working));
        }
        HttpResponse loginResponse = Network.request("https://www.geocaching.com/login/default.aspx", null, false, false, false);
        String loginData = Network.getResponseData(loginResponse);
        if (loginResponse != null && loginResponse.getStatusLine().getStatusCode() == 503 && BaseUtils.matches(loginData, GCConstants.PATTERN_MAINTENANCE)) {
            return StatusCode.MAINTENANCE;
        }

        if (StringUtils.isBlank(loginData)) {
            Log.e(Settings.tag, "cgeoBase.login: Failed to retrieve login page (1st)");
            return StatusCode.CONNECTION_FAILED; // no loginpage
        }

        if (Login.getLoginStatus(loginData)) {
            Log.i(Settings.tag, "Already logged in Geocaching.com as " + login.left + " (" + getActualMemberStatus() + ')');
            Login.switchToEnglish(loginData);
            return StatusCode.NO_ERROR; // logged in
        }

        Network.clearCookies();
        Settings.setCookieStore(null);

        final Parameters params = new Parameters(
                "__EVENTTARGET", "",
                "__EVENTARGUMENT", "",
                "ctl00$ContentBody$tbUsername", login.left,
                "ctl00$ContentBody$tbPassword", login.right,
                "ctl00$ContentBody$cbRememberMe", "on",
                "ctl00$ContentBody$btnSignIn", "Login");
        final String[] viewstates = Login.getViewstates(loginData);
        if (cgBase.isEmpty(viewstates)) {
            Log.e(Settings.tag, "cgeoBase.login: Failed to find viewstates");
            return StatusCode.LOGIN_PARSE_ERROR; // no viewstates
        }
        Login.putViewstates(params, viewstates);

        loginResponse = Network.postRequest("https://www.geocaching.com/login/default.aspx", params);
        loginData = Network.getResponseData(loginResponse);

        if (StringUtils.isNotBlank(loginData)) {
            if (Login.getLoginStatus(loginData)) {
                Log.i(Settings.tag, "Successfully logged in Geocaching.com as " + login.left + " (" + getActualMemberStatus() + ')');

                Login.switchToEnglish(loginData);
                Settings.setCookieStore(Network.dumpCookieStore());

                return StatusCode.NO_ERROR; // logged in
            } else {
                if (loginData.contains("Your username/password combination does not match.")) {
                    Log.i(Settings.tag, "Failed to log in Geocaching.com as " + login.left + " because of wrong username/password");
                    return StatusCode.WRONG_LOGIN_DATA; // wrong login
                } else {
                    Log.i(Settings.tag, "Failed to log in Geocaching.com as " + login.left + " for some unknown reason");
                    return StatusCode.UNKNOWN_ERROR; // can't login
                }
            }
        } else {
            Log.e(Settings.tag, "cgeoBase.login: Failed to retrieve login page (2nd)");
            // FIXME: should it be CONNECTION_FAILED to match the first attempt?
            return StatusCode.COMMUNICATION_ERROR; // no login page
        }
    }

    public static StatusCode logout() {
        HttpResponse logoutResponse = Network.request("https://www.geocaching.com/login/default.aspx?RESET=Y&redir=http%3a%2f%2fwww.geocaching.com%2fdefault.aspx%3f", null, false, false, false);
        String logoutData = Network.getResponseData(logoutResponse);
        if (logoutResponse != null && logoutResponse.getStatusLine().getStatusCode() == 503 && BaseUtils.matches(logoutData, GCConstants.PATTERN_MAINTENANCE)) {
            return StatusCode.MAINTENANCE;
        }

        Network.clearCookies();
        Settings.setCookieStore(null);
        return StatusCode.NO_ERROR;
    }

    public static void setActualCachesFound(final int found) {
        actualCachesFound = found;
    }

    public static String getActualStatus() {
        return actualStatus;
    }

    public static void setActualStatus(final String status) {
        actualStatus = status;
    }

    public static boolean isActualLoginStatus() {
        return actualLoginStatus;
    }

    public static void setActualLoginStatus(boolean loginStatus) {
        actualLoginStatus = loginStatus;
    }

    public static String getActualUserName() {
        return actualUserName;
    }

    public static void setActualUserName(String userName) {
        actualUserName = userName;
    }

    public static String getActualMemberStatus() {
        return actualMemberStatus;
    }

    public static void setActualMemberStatus(final String memberStatus) {
        actualMemberStatus = memberStatus;
    }

    public static int getActualCachesFound() {
        return actualCachesFound;
    }

    /**
     * Check if the user has been logged in when he retrieved the data.
     *
     * @param page
     * @return <code>true</code> if user is logged in, <code>false</code> otherwise
     */
    public static boolean getLoginStatus(final String page) {
        if (StringUtils.isBlank(page)) {
            Log.e(Settings.tag, "cgeoBase.checkLogin: No page given");
            return false;
        }

        // res is null during the unit tests
        if (cgBase.res != null) {
            setActualStatus(cgBase.res.getString(R.string.init_login_popup_ok));
        }

        // on every page except login page
        setActualLoginStatus(BaseUtils.matches(page, GCConstants.PATTERN_LOGIN_NAME));
        if (isActualLoginStatus()) {
            setActualUserName(BaseUtils.getMatch(page, GCConstants.PATTERN_LOGIN_NAME, true, "???"));
            setActualMemberStatus(BaseUtils.getMatch(page, GCConstants.PATTERN_MEMBER_STATUS, true, "???"));
            setActualCachesFound(Integer.parseInt(BaseUtils.getMatch(page, GCConstants.PATTERN_CACHES_FOUND, true, "0").replaceAll("[,.]", "")));
            return true;
        }

        // login page
        setActualLoginStatus(BaseUtils.matches(page, GCConstants.PATTERN_LOGIN_NAME_LOGIN_PAGE));
        if (isActualLoginStatus()) {
            setActualUserName(Settings.getUsername());
            setActualMemberStatus(Settings.getMemberStatus());
            // number of caches found is not part of this page
            return true;
        }

        // res is null during the unit tests
        if (cgBase.res != null) {
            setActualStatus(cgBase.res.getString(R.string.init_login_popup_failed));
        }
        return false;
    }

    private static void switchToEnglish(String previousPage) {
        if (previousPage != null && previousPage.indexOf(ENGLISH) >= 0) {
            Log.i(Settings.tag, "Geocaching.com language already set to English");
            // get find count
            getLoginStatus(Network.getResponseData(Network.request("http://www.geocaching.com/email/", null, false)));
        } else {
            final String page = Network.getResponseData(Network.request("http://www.geocaching.com/default.aspx", null, false));
            getLoginStatus(page);
            if (page == null) {
                Log.e(Settings.tag, "Failed to read viewstates to set geocaching.com language");
            }
            final Parameters params = new Parameters(
                    "__EVENTTARGET", "ctl00$uxLocaleList$uxLocaleList$ctl00$uxLocaleItem", // switch to english
                    "__EVENTARGUMENT", "");
            Login.transferViewstates(page, params);
            final HttpResponse response = Network.postRequest("http://www.geocaching.com/default.aspx", params);
            if (!Network.isSuccess(response)) {
                Log.e(Settings.tag, "Failed to set geocaching.com language to English");
            }
        }
    }

    public static BitmapDrawable downloadAvatarAndGetMemberStatus(final Context context) {
        try {
            final String profile = BaseUtils.replaceWhitespace(Network.getResponseData(Network.request("http://www.geocaching.com/my/", null, false)));

            Settings.setMemberStatus(BaseUtils.getMatch(profile, GCConstants.PATTERN_MEMBER_STATUS, true, null));

            setActualCachesFound(Integer.parseInt(BaseUtils.getMatch(profile, GCConstants.PATTERN_CACHES_FOUND, true, "-1").replaceAll("[,.]", "")));

            final String avatarURL = BaseUtils.getMatch(profile, GCConstants.PATTERN_AVATAR_IMAGE_PROFILE_PAGE, false, null);
            if (null != avatarURL) {
                final HtmlImage imgGetter = new HtmlImage(context, "", false, 0, false);
                return imgGetter.getDrawable(avatarURL);
            }
            // No match? There may be no avatar set by user.
            Log.d(Settings.tag, "No avatar set for user");
        } catch (Exception e) {
            Log.w(Settings.tag, "Error when retrieving user avatar", e);
        }
        return null;
    }

    /**
     * Detect user date settings on geocaching.com
     */
    public static void detectGcCustomDate() {

        final String result = Network.getResponseData(Network.request("http://www.geocaching.com/account/ManagePreferences.aspx", null, false, false, false));

        if (null == result) {
            Log.w(Settings.tag, "cgeoBase.detectGcCustomDate: result is null");
            return;
        }

        String customDate = BaseUtils.getMatch(result, GCConstants.PATTERN_CUSTOMDATE, true, null);
        if (null != customDate) {
            Settings.setGcCustomDate(customDate);
        }
    }

    public static Date parseGcCustomDate(final String input, final String format) throws ParseException {
        if (StringUtils.isBlank(input)) {
            throw new ParseException("Input is null", 0);
        }

        final String trimmed = input.trim();

        if (gcCustomDateFormats.containsKey(format)) {
            try {
                return gcCustomDateFormats.get(format).parse(trimmed);
            } catch (ParseException e) {
            }
        }

        for (SimpleDateFormat sdf : gcCustomDateFormats.values()) {
            try {
                return sdf.parse(trimmed);
            } catch (ParseException e) {
            }
        }

        throw new ParseException("No matching pattern", 0);
    }

    public static Date parseGcCustomDate(final String input) throws ParseException {
        return parseGcCustomDate(input, Settings.getGcCustomDate());
    }

    /**
     * read all viewstates from page
     *
     * @return String[] with all view states
     */
    public static String[] getViewstates(String page) {
        // Get the number of viewstates.
        // If there is only one viewstate, __VIEWSTATEFIELDCOUNT is not present

        if (page == null) { // no network access
            return null;
        }

        int count = 1;
        final Matcher matcherViewstateCount = GCConstants.PATTERN_VIEWSTATEFIELDCOUNT.matcher(page);
        if (matcherViewstateCount.find()) {
            try {
                count = Integer.parseInt(matcherViewstateCount.group(1));
            } catch (NumberFormatException e) {
                Log.e(Settings.tag, "getViewStates", e);
            }
        }

        String[] viewstates = new String[count];

        // Get the viewstates
        int no;
        final Matcher matcherViewstates = GCConstants.PATTERN_VIEWSTATES.matcher(page);
        while (matcherViewstates.find()) {
            String sno = matcherViewstates.group(1); // number of viewstate
            if (sno.length() == 0) {
                no = 0;
            }
            else {
                try {
                    no = Integer.parseInt(sno);
                } catch (NumberFormatException e) {
                    Log.e(Settings.tag, "getViewStates", e);
                    no = 0;
                }
            }
            viewstates[no] = matcherViewstates.group(2);
        }

        if (viewstates.length != 1 || viewstates[0] != null) {
            return viewstates;
        }
        // no viewstates were present
        return null;
    }

    /**
     * put viewstates into request parameters
     */
    public static void putViewstates(final Parameters params, final String[] viewstates) {
        if (ArrayUtils.isEmpty(viewstates)) {
            return;
        }
        params.put("__VIEWSTATE", viewstates[0]);
        if (viewstates.length > 1) {
            for (int i = 1; i < viewstates.length; i++) {
                params.put("__VIEWSTATE" + i, viewstates[i]);
            }
            params.put("__VIEWSTATEFIELDCOUNT", String.valueOf(viewstates.length));
        }
    }

    /**
     * transfers the viewstates variables from a page (response) to parameters
     * (next request)
     */
    public static void transferViewstates(final String page, final Parameters params) {
        putViewstates(params, getViewstates(page));
    }

    static public String[] requestViewstates(final String uri, final Parameters params, boolean xContentType, boolean my) {
        final HttpResponse response = Network.request(uri, params, xContentType, my, false);

        return getViewstates(Network.getResponseData(response));
    }

}
!@#$%
20190526_235837,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_b17168
package cgeo.geocaching.ui;

import cgeo.geocaching.CacheDetailActivity;
import cgeo.geocaching.IGeoData;
import cgeo.geocaching.R;
import cgeo.geocaching.Settings;
import cgeo.geocaching.cgCache;
import cgeo.geocaching.cgeoapplication;
import cgeo.geocaching.enumerations.CacheListType;
import cgeo.geocaching.enumerations.CacheSize;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.filter.IFilter;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.sorting.CacheComparator;
import cgeo.geocaching.sorting.DistanceComparator;
import cgeo.geocaching.sorting.VisitComparator;
import cgeo.geocaching.utils.AngleUtils;
import cgeo.geocaching.utils.Log;

import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.builder.HashCodeBuilder;

import android.app.Activity;
import android.content.res.Resources;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.drawable.Drawable;
import android.graphics.drawable.LayerDrawable;
import android.text.Spannable;
import android.text.Spanned;
import android.text.style.ForegroundColorSpan;
import android.text.style.StrikethroughSpan;
import android.util.SparseArray;
import android.view.GestureDetector;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ArrayAdapter;
import android.widget.CheckBox;
import android.widget.ImageView;
import android.widget.RelativeLayout;
import android.widget.TextView;

import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;

public class CacheListAdapter extends ArrayAdapter<cgCache> {

    private LayoutInflater inflater = null;
    private CacheComparator cacheComparator = null;
    private Geopoint coords;
    private float azimuth = 0;
    private long lastSort = 0L;
    private boolean selectMode = false;
    private IFilter currentFilter = null;
    private List<cgCache> originalList = null;

    final private Set<CompassMiniView> compasses = new LinkedHashSet<CompassMiniView>();
    final private Set<DistanceView> distances = new LinkedHashSet<DistanceView>();
    final private CacheListType cacheListType;
    final private Resources res;
    /** Resulting list of caches */
    final private List<cgCache> list;

    private static final int SWIPE_MIN_DISTANCE = 60;
    private static final int SWIPE_MAX_OFF_PATH = 100;
    private static final SparseArray<Drawable> gcIconDrawables = new SparseArray<Drawable>();
    /**
     * time in milliseconds after which the list may be resorted due to position updates
     */
    private static final int PAUSE_BETWEEN_LIST_SORT = 1000;

    private static final int[] RATING_BACKGROUND = new int[3];
    static {
        if (Settings.isLightSkin()) {
            RATING_BACKGROUND[0] = R.drawable.favourite_background_red_light;
            RATING_BACKGROUND[1] = R.drawable.favourite_background_orange_light;
            RATING_BACKGROUND[2] = R.drawable.favourite_background_green_light;
        } else {
            RATING_BACKGROUND[0] = R.drawable.favourite_background_red_dark;
            RATING_BACKGROUND[1] = R.drawable.favourite_background_orange_dark;
            RATING_BACKGROUND[2] = R.drawable.favourite_background_green_dark;
        }
    }

    /**
     * view holder for the cache list adapter
     *
     */
    private static class ViewHolder {
        CheckBox checkbox;
        ImageView logStatusMark;
        TextView text;
        TextView favourite;
        TextView info;
        ImageView inventory;
        RelativeLayout directionLayout;
        DistanceView distance;
        CompassMiniView direction;
        RelativeLayout dirImgLayout;
        ImageView dirImg;
    }

    public CacheListAdapter(final Activity activity, final List<cgCache> list, CacheListType cacheListType) {
        super(activity, 0, list);
        final IGeoData currentGeo = cgeoapplication.getInstance().currentGeo();
        if (currentGeo != null) {
            coords = currentGeo.getCoords();
        }
        this.res = activity.getResources();
        this.list = list;
        this.cacheListType = cacheListType;
        if (cacheListType == CacheListType.HISTORY) {
            cacheComparator = new VisitComparator();
        }

        final Drawable modifiedCoordinatesMarker = activity.getResources().getDrawable(R.drawable.marker_usermodifiedcoords);
        for (final CacheType cacheType : CacheType.values()) {
            // unmodified icon
            int hashCode = getIconHashCode(cacheType, false);
            gcIconDrawables.put(hashCode, activity.getResources().getDrawable(cacheType.markerId));
            // icon with flag for user modified coordinates
            hashCode = getIconHashCode(cacheType, true);
            Drawable[] layers = new Drawable[2];
            layers[0] = activity.getResources().getDrawable(cacheType.markerId);
            layers[1] = modifiedCoordinatesMarker;
            LayerDrawable ld = new LayerDrawable(layers);
            ld.setLayerInset(1,
                    layers[0].getIntrinsicWidth() - layers[1].getIntrinsicWidth(),
                    layers[0].getIntrinsicHeight() - layers[1].getIntrinsicHeight(),
                    0, 0);
            gcIconDrawables.put(hashCode, ld);
        }
    }

    private static int getIconHashCode(final CacheType cacheType, final boolean userModifiedOrFinal) {
        return new HashCodeBuilder()
                .append(cacheType)
                .append(userModifiedOrFinal)
                .toHashCode();
    }

    /**
     * change the sort order
     *
     * @param comparator
     */
    public void setComparator(final CacheComparator comparator) {
        cacheComparator = comparator;
        forceSort();
    }

    public CacheComparator getCacheComparator() {
        return cacheComparator;
    }

    public cgCache findCacheByGeocode(String geocode) {
        for (int i = 0; i < getCount(); i++) {
            if (getItem(i).getGeocode().equalsIgnoreCase(geocode)) {
                return getItem(i);
            }
        }

        return null;
    }
    /**
     * Called when a new page of caches was loaded.
     */
    public void reFilter() {
        if (currentFilter != null) {
            // Back up the list again
            originalList = new ArrayList<cgCache>(list);

            currentFilter.filter(list);
        }
    }

    /**
     * Called after a user action on the filter menu.
     */
    public void setFilter(final IFilter filter) {
        // Backup current caches list if it isn't backed up yet
        if (originalList == null) {
            originalList = new ArrayList<cgCache>(list);
        }

        // If there is already a filter in place, this is a request to change or clear the filter, so we have to
        // replace the original cache list
        if (currentFilter != null) {
            list.clear();
            list.addAll(originalList);
        }

        // Do the filtering or clear it
        if (filter != null) {
            filter.filter(list);
        }
        currentFilter = filter;

        notifyDataSetChanged();
    }

    public boolean isFiltered() {
        return currentFilter != null;
    }

    public String getFilterName() {
        return currentFilter.getName();
    }

    public int getCheckedCount() {
        int checked = 0;
        for (cgCache cache : list) {
            if (cache.isStatusChecked()) {
                checked++;
            }
        }
        return checked;
    }

    public void setSelectMode(final boolean selectMode) {
        this.selectMode = selectMode;

        if (!selectMode) {
            for (final cgCache cache : list) {
                cache.setStatusChecked(false);
            }
        }
        notifyDataSetChanged();
    }

    public boolean isSelectMode() {
        return selectMode;
    }

    public void switchSelectMode() {
        setSelectMode(!isSelectMode());
    }

    public void invertSelection() {
        for (cgCache cache : list) {
            cache.setStatusChecked(!cache.isStatusChecked());
        }
        notifyDataSetChanged();
    }

    public void forceSort() {
        if (CollectionUtils.isEmpty(list) || selectMode) {
            return;
        }

        if (isSortedByDistance()) {
            lastSort = 0;
            updateSortByDistance();
        }
        else {
            Collections.sort(list, cacheComparator);
        }

        notifyDataSetChanged();
    }

    public void setActualCoordinates(final Geopoint coords) {
        this.coords = coords;
        updateSortByDistance();

        for (final DistanceView distance : distances) {
            distance.update(coords);
        }
        for (final CompassMiniView compass : compasses) {
            compass.updateCurrentCoords(coords);
        }
    }

    private void updateSortByDistance() {
        if (CollectionUtils.isEmpty(list)) {
            return;
        }
        if (selectMode) {
            return;
        }
        if ((System.currentTimeMillis() - lastSort) <= PAUSE_BETWEEN_LIST_SORT) {
            return;
        }
        if (!isSortedByDistance()) {
            return;
        }
        if (coords == null) {
            return;
        }
        final ArrayList<cgCache> oldList = new ArrayList<cgCache>(list);
        Collections.sort(list, new DistanceComparator(coords, list));

        // avoid an update if the list has not changed due to location update
        if (list.equals(oldList)) {
            return;
        }
        notifyDataSetChanged();
        lastSort = System.currentTimeMillis();
    }

    private boolean isSortedByDistance() {
        return cacheComparator == null || cacheComparator instanceof DistanceComparator;
    }

    public void setActualHeading(final float direction) {
        if (Math.abs(AngleUtils.difference(azimuth, direction)) < 10) {
            return;
        }

        azimuth = direction;
        for (final CompassMiniView compass : compasses) {
            compass.updateAzimuth(azimuth);
        }
    }

    @Override
    public View getView(final int position, final View rowView, final ViewGroup parent) {
        if (inflater == null) {
            inflater = ((Activity) getContext()).getLayoutInflater();
        }

        if (position > getCount()) {
            Log.w("CacheListAdapter.getView: Attempt to access missing item #" + position);
            return null;
        }

        final cgCache cache = getItem(position);

        View v = rowView;

        final ViewHolder holder;
        if (v == null) {
            v = inflater.inflate(R.layout.caches_item, null);

            holder = new ViewHolder();
            holder.checkbox = (CheckBox) v.findViewById(R.id.checkbox);
            holder.logStatusMark = (ImageView) v.findViewById(R.id.log_status_mark);
            holder.text = (TextView) v.findViewById(R.id.text);
            holder.directionLayout = (RelativeLayout) v.findViewById(R.id.direction_layout);
            holder.distance = (DistanceView) v.findViewById(R.id.distance);
            holder.direction = (CompassMiniView) v.findViewById(R.id.direction);
            holder.dirImgLayout = (RelativeLayout) v.findViewById(R.id.dirimg_layout);
            holder.dirImg = (ImageView) v.findViewById(R.id.dirimg);
            holder.inventory = (ImageView) v.findViewById(R.id.inventory);
            holder.favourite = (TextView) v.findViewById(R.id.favourite);
            holder.info = (TextView) v.findViewById(R.id.info);

            v.setTag(holder);
        } else {
            holder = (ViewHolder) v.getTag();
        }

        final boolean lightSkin = Settings.isLightSkin();

        final TouchListener touchLst = new TouchListener(cache);
        v.setOnClickListener(touchLst);
        v.setOnLongClickListener(touchLst);
        v.setOnTouchListener(touchLst);
        v.setLongClickable(true);

        if (selectMode) {
            holder.checkbox.setVisibility(View.VISIBLE);
        }
        else {
            holder.checkbox.setVisibility(View.GONE);
        }

        holder.checkbox.setChecked(cache.isStatusChecked());
        holder.checkbox.setOnClickListener(new SelectionCheckBoxListener(cache));

        distances.add(holder.distance);
        holder.distance.setContent(cache.getCoords());
        compasses.add(holder.direction);
        holder.direction.setTargetCoords(cache.getCoords());

        if (cache.isFound() && cache.isLogOffline()) {
            holder.logStatusMark.setImageResource(R.drawable.mark_green_orange);
            holder.logStatusMark.setVisibility(View.VISIBLE);
        } else if (cache.isFound()) {
            holder.logStatusMark.setImageResource(R.drawable.mark_green_more);
            holder.logStatusMark.setVisibility(View.VISIBLE);
        } else if (cache.isLogOffline()) {
            holder.logStatusMark.setImageResource(R.drawable.mark_orange);
            holder.logStatusMark.setVisibility(View.VISIBLE);
        } else {
            holder.logStatusMark.setVisibility(View.GONE);
        }

        if (cache.getNameSp() == null) {
            cache.setNameSp((new Spannable.Factory()).newSpannable(cache.getName()));
            if (cache.isDisabled() || cache.isArchived()) { // strike
                cache.getNameSp().setSpan(new StrikethroughSpan(), 0, cache.getNameSp().toString().length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
            }
            if (cache.isArchived()) {
                cache.getNameSp().setSpan(new ForegroundColorSpan(res.getColor(R.color.archived_cache_color)), 0, cache.getNameSp().toString().length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
            }
        }

        holder.text.setText(cache.getNameSp(), TextView.BufferType.SPANNABLE);
        holder.text.setCompoundDrawablesWithIntrinsicBounds(getCacheIcon(cache), null, null, null);

        if (cache.getInventoryItems() > 0) {
            holder.inventory.setVisibility(View.VISIBLE);
        } else {
            holder.inventory.setVisibility(View.GONE);
        }

        boolean setDiDi = false;
        if (cache.getCoords() != null) {
            holder.direction.setVisibility(View.VISIBLE);
            holder.direction.updateAzimuth(azimuth);
            if (coords != null) {
                holder.distance.update(coords);
                holder.direction.updateCurrentCoords(coords);
            }
            setDiDi = true;
        } else {
            if (cache.getDistance() != null) {
                holder.distance.setDistance(cache.getDistance());
                setDiDi = true;
            }
            if (cache.getDirection() != null) {
                holder.direction.setVisibility(View.VISIBLE);
                holder.direction.updateAzimuth(azimuth);
                holder.direction.updateHeading(cache.getDirection());
                setDiDi = true;
            }
        }

        if (setDiDi) {
            holder.directionLayout.setVisibility(View.VISIBLE);
            holder.dirImgLayout.setVisibility(View.GONE);
        } else {
            holder.directionLayout.setVisibility(View.GONE);
            holder.distance.clear();

            final Bitmap dirImgPre = BitmapFactory.decodeFile(DirectionImage.getDirectionFile(cache.getGeocode(), false).getPath());
            final Bitmap dirImg;
            if (dirImgPre != null) { // null happens for invalid caches (not yet released)
                dirImg = dirImgPre.copy(Bitmap.Config.ARGB_8888, true);
                dirImgPre.recycle();
            }
            else {
                dirImg = null;
            }

            if (dirImg != null) {
                if (!lightSkin) {
                    final int length = dirImg.getWidth() * dirImg.getHeight();
                    final int[] pixels = new int[length];
                    dirImg.getPixels(pixels, 0, dirImg.getWidth(), 0, 0, dirImg.getWidth(), dirImg.getHeight());
                    for (int i = 0; i < length; i++) {
                        if (pixels[i] == 0xff000000) { // replace black with white
                            pixels[i] = 0xffffffff;
                        }
                    }
                    dirImg.setPixels(pixels, 0, dirImg.getWidth(), 0, 0, dirImg.getWidth(), dirImg.getHeight());
                }

                holder.dirImg.setImageBitmap(dirImg);
                holder.dirImgLayout.setVisibility(View.VISIBLE);
            } else {
                holder.dirImg.setImageBitmap(null);
                holder.dirImgLayout.setVisibility(View.GONE);
            }
        }

        holder.favourite.setText(Integer.toString(cache.getFavoritePoints()));

        int favoriteBack;
        // set default background, neither vote nor rating may be available
        if (lightSkin) {
            favoriteBack = R.drawable.favourite_background_light;
        } else {
            favoriteBack = R.drawable.favourite_background_dark;
        }
        final float myVote = cache.getMyVote();
        if (myVote > 0) { // use my own rating for display, if I have voted
            if (myVote >= 4) {
                favoriteBack = RATING_BACKGROUND[2];
            } else if (myVote >= 3) {
                favoriteBack = RATING_BACKGROUND[1];
            } else if (myVote > 0) {
                favoriteBack = RATING_BACKGROUND[0];
            }
        } else {
            final float rating = cache.getRating();
            if (rating >= 3.5) {
                favoriteBack = RATING_BACKGROUND[2];
            } else if (rating >= 2.1) {
                favoriteBack = RATING_BACKGROUND[1];
            } else if (rating > 0.0) {
                favoriteBack = RATING_BACKGROUND[0];
            }
        }
        holder.favourite.setBackgroundResource(favoriteBack);

        if (cacheListType == CacheListType.HISTORY && cache.getVisitedDate() > 0) {
            final ArrayList<String> infos = new ArrayList<String>();
            infos.add(StringUtils.upperCase(cache.getGeocode()));
            infos.add(Formatter.formatDate(cache.getVisitedDate()));
            infos.add(Formatter.formatTime(cache.getVisitedDate()));
            holder.info.setText(StringUtils.join(infos, Formatter.SEPARATOR));
        } else {
            final ArrayList<String> infos = new ArrayList<String>();
            if (StringUtils.isNotBlank(cache.getGeocode())) {
                infos.add(cache.getGeocode());
            }
            if (cache.hasDifficulty()) {
                infos.add("D " + String.format("%.1f", cache.getDifficulty()));
            }
            if (cache.hasTerrain()) {
                infos.add("T " + String.format("%.1f", cache.getTerrain()));
            }

            // don't show "not chosen" for events and virtuals, that should be the normal case
            if (cache.getSize() != CacheSize.UNKNOWN && cache.showSize()) {
                infos.add(cache.getSize().getL10n());
            } else if (cache.isEventCache() && cache.getHiddenDate() != null) {
                infos.add(Formatter.formatShortDate(cache.getHiddenDate().getTime()));
            }

            if (cache.isPremiumMembersOnly()) {
                infos.add(res.getString(R.string.cache_premium));
            }
            if (cacheListType != CacheListType.OFFLINE && cacheListType != CacheListType.HISTORY && cache.getListId() > 0) {
                infos.add(res.getString(R.string.cache_offline));
            }
            holder.info.setText(StringUtils.join(infos, Formatter.SEPARATOR));
        }

        return v;
    }

    private static Drawable getCacheIcon(cgCache cache) {
        int hashCode = getIconHashCode(cache.getType(), cache.hasUserModifiedCoords() || cache.hasFinalDefined());
        final Drawable drawable = gcIconDrawables.get(hashCode);
        if (drawable != null) {
            return drawable;
        }

        // fallback to mystery icon
        hashCode = getIconHashCode(CacheType.MYSTERY, cache.hasUserModifiedCoords() || cache.hasFinalDefined());
        return gcIconDrawables.get(hashCode);
    }

    @Override
    public void notifyDataSetChanged() {
        super.notifyDataSetChanged();
        distances.clear();
        compasses.clear();
    }

    private static class SelectionCheckBoxListener implements View.OnClickListener {

        private final cgCache cache;

        public SelectionCheckBoxListener(cgCache cache) {
            this.cache = cache;
        }

        @Override
        public void onClick(View view) {
            final boolean checkNow = ((CheckBox) view).isChecked();
            cache.setStatusChecked(checkNow);
        }
    }

    private class TouchListener implements View.OnLongClickListener, View.OnClickListener, View.OnTouchListener {

        private boolean touch = true;
        private final GestureDetector gestureDetector;
        private final cgCache cache;

        public TouchListener(final cgCache cache) {
            this.cache = cache;
            final FlingGesture dGesture = new FlingGesture(cache);
            gestureDetector = new GestureDetector(getContext(), dGesture);
        }

        // tap on item
        @Override
        public void onClick(View view) {
            if (!touch) {
                touch = true;
                return;
            }

            if (isSelectMode()) {
                cache.setStatusChecked(!cache.isStatusChecked());
                notifyDataSetChanged();
                return;
            }

            // load cache details
            CacheDetailActivity.startActivity(getContext(), cache.getGeocode(), cache.getName());
        }

        // long tap on item
        @Override
        public boolean onLongClick(View view) {
            if (!touch) {
                touch = true;
                return true;
            }

            return view.showContextMenu();
        }

        // swipe on item
        @Override
        public boolean onTouch(View view, MotionEvent event) {
            if (gestureDetector.onTouchEvent(event)) {
                touch = false;
                return true;
            }

            return false;
        }
    }

    private class FlingGesture extends GestureDetector.SimpleOnGestureListener {

        private final cgCache cache;

        public FlingGesture(cgCache cache) {
            this.cache = cache;
        }

        @Override
        public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
            try {
                if (Math.abs(e1.getY() - e2.getY()) > SWIPE_MAX_OFF_PATH) {
                    return false;
                }

                // left to right swipe
                if ((e2.getX() - e1.getX()) > SWIPE_MIN_DISTANCE && Math.abs(velocityX) > Math.abs(velocityY)) {
                    if (!selectMode) {
                        switchSelectMode();
                        cache.setStatusChecked(true);
                    }
                    return true;
                }

                // right to left swipe
                if ((e1.getX() - e2.getX()) > SWIPE_MIN_DISTANCE && Math.abs(velocityX) > Math.abs(velocityY)) {
                    if (selectMode) {
                        switchSelectMode();
                    }
                    return true;
                }
            } catch (Exception e) {
                Log.w("CacheListAdapter.FlingGesture.onFling: " + e.toString());
            }

            return false;
        }
    }

    public List<cgCache> getFilteredList() {
        return list;
    }

    public List<cgCache> getCheckedCaches() {
        final ArrayList<cgCache> result = new ArrayList<cgCache>();
        for (cgCache cache : list) {
            if (cache.isStatusChecked()) {
                result.add(cache);
            }
        }
        return result;
    }

    public List<cgCache> getCheckedOrAllCaches() {
        final List<cgCache> result = getCheckedCaches();
        if (!result.isEmpty()) {
            return result;
        }
        return new ArrayList<cgCache>(list);
    }

    public int getCheckedOrAllCount() {
        final int checked = getCheckedCount();
        if (checked > 0) {
            return checked;
        }
        return list.size();
    }
}
!@#$%
20190526_235837,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_a17168
package cgeo.geocaching.ui;

import cgeo.geocaching.CacheDetailActivity;
import cgeo.geocaching.IGeoData;
import cgeo.geocaching.R;
import cgeo.geocaching.Settings;
import cgeo.geocaching.cgCache;
import cgeo.geocaching.cgeoapplication;
import cgeo.geocaching.enumerations.CacheListType;
import cgeo.geocaching.enumerations.CacheSize;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.filter.IFilter;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.sorting.CacheComparator;
import cgeo.geocaching.sorting.DistanceComparator;
import cgeo.geocaching.sorting.VisitComparator;
import cgeo.geocaching.utils.AngleUtils;
import cgeo.geocaching.utils.Log;

import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.builder.HashCodeBuilder;

import android.app.Activity;
import android.content.res.Resources;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.drawable.Drawable;
import android.graphics.drawable.LayerDrawable;
import android.text.Spannable;
import android.text.Spanned;
import android.text.style.StrikethroughSpan;
import android.util.SparseArray;
import android.view.GestureDetector;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ArrayAdapter;
import android.widget.CheckBox;
import android.widget.ImageView;
import android.widget.RelativeLayout;
import android.widget.TextView;

import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;

public class CacheListAdapter extends ArrayAdapter<cgCache> {

    private LayoutInflater inflater = null;
    private CacheComparator cacheComparator = null;
    private Geopoint coords;
    private float azimuth = 0;
    private long lastSort = 0L;
    private boolean selectMode = false;
    private IFilter currentFilter = null;
    private List<cgCache> originalList = null;

    final private Set<CompassMiniView> compasses = new LinkedHashSet<CompassMiniView>();
    final private Set<DistanceView> distances = new LinkedHashSet<DistanceView>();
    final private CacheListType cacheListType;
    final private Resources res;
    /** Resulting list of caches */
    final private List<cgCache> list;

    private static final int SWIPE_MIN_DISTANCE = 60;
    private static final int SWIPE_MAX_OFF_PATH = 100;
    private static final SparseArray<Drawable> gcIconDrawables = new SparseArray<Drawable>();
    /**
     * time in milliseconds after which the list may be resorted due to position updates
     */
    private static final int PAUSE_BETWEEN_LIST_SORT = 1000;

    private static final int[] RATING_BACKGROUND = new int[3];
    static {
        if (Settings.isLightSkin()) {
            RATING_BACKGROUND[0] = R.drawable.favourite_background_red_light;
            RATING_BACKGROUND[1] = R.drawable.favourite_background_orange_light;
            RATING_BACKGROUND[2] = R.drawable.favourite_background_green_light;
        } else {
            RATING_BACKGROUND[0] = R.drawable.favourite_background_red_dark;
            RATING_BACKGROUND[1] = R.drawable.favourite_background_orange_dark;
            RATING_BACKGROUND[2] = R.drawable.favourite_background_green_dark;
        }
    }

    /**
     * view holder for the cache list adapter
     *
     */
    private static class ViewHolder {
        CheckBox checkbox;
        ImageView logStatusMark;
        TextView text;
        TextView favourite;
        TextView info;
        ImageView inventory;
        RelativeLayout directionLayout;
        DistanceView distance;
        CompassMiniView direction;
        RelativeLayout dirImgLayout;
        ImageView dirImg;
    }

    public CacheListAdapter(final Activity activity, final List<cgCache> list, CacheListType cacheListType) {
        super(activity, 0, list);
        final IGeoData currentGeo = cgeoapplication.getInstance().currentGeo();
        if (currentGeo != null) {
            coords = currentGeo.getCoords();
        }
        this.res = activity.getResources();
        this.list = list;
        this.cacheListType = cacheListType;
        if (cacheListType == CacheListType.HISTORY) {
            cacheComparator = new VisitComparator();
        }

        final Drawable modifiedCoordinatesMarker = activity.getResources().getDrawable(R.drawable.marker_usermodifiedcoords);
        for (final CacheType cacheType : CacheType.values()) {
            // unmodified icon
            int hashCode = getIconHashCode(cacheType, false);
            gcIconDrawables.put(hashCode, activity.getResources().getDrawable(cacheType.markerId));
            // icon with flag for user modified coordinates
            hashCode = getIconHashCode(cacheType, true);
            Drawable[] layers = new Drawable[2];
            layers[0] = activity.getResources().getDrawable(cacheType.markerId);
            layers[1] = modifiedCoordinatesMarker;
            LayerDrawable ld = new LayerDrawable(layers);
            ld.setLayerInset(1,
                    layers[0].getIntrinsicWidth() - layers[1].getIntrinsicWidth(),
                    layers[0].getIntrinsicHeight() - layers[1].getIntrinsicHeight(),
                    0, 0);
            gcIconDrawables.put(hashCode, ld);
        }
    }

    private static int getIconHashCode(final CacheType cacheType, final boolean userModifiedOrFinal) {
        return new HashCodeBuilder()
                .append(cacheType)
                .append(userModifiedOrFinal)
                .toHashCode();
    }

    /**
     * change the sort order
     *
     * @param comparator
     */
    public void setComparator(final CacheComparator comparator) {
        cacheComparator = comparator;
        forceSort();
    }

    public CacheComparator getCacheComparator() {
        return cacheComparator;
    }

    public cgCache findCacheByGeocode(String geocode) {
        for (int i = 0; i < getCount(); i++) {
            if (getItem(i).getGeocode().equalsIgnoreCase(geocode)) {
                return getItem(i);
            }
        }

        return null;
    }
    /**
     * Called when a new page of caches was loaded.
     */
    public void reFilter() {
        if (currentFilter != null) {
            // Back up the list again
            originalList = new ArrayList<cgCache>(list);

            currentFilter.filter(list);
        }
    }

    /**
     * Called after a user action on the filter menu.
     */
    public void setFilter(final IFilter filter) {
        // Backup current caches list if it isn't backed up yet
        if (originalList == null) {
            originalList = new ArrayList<cgCache>(list);
        }

        // If there is already a filter in place, this is a request to change or clear the filter, so we have to
        // replace the original cache list
        if (currentFilter != null) {
            list.clear();
            list.addAll(originalList);
        }

        // Do the filtering or clear it
        if (filter != null) {
            filter.filter(list);
        }
        currentFilter = filter;

        notifyDataSetChanged();
    }

    public boolean isFiltered() {
        return currentFilter != null;
    }

    public String getFilterName() {
        return currentFilter.getName();
    }

    public int getCheckedCount() {
        int checked = 0;
        for (cgCache cache : list) {
            if (cache.isStatusChecked()) {
                checked++;
            }
        }
        return checked;
    }

    public void setSelectMode(final boolean selectMode) {
        this.selectMode = selectMode;

        if (!selectMode) {
            for (final cgCache cache : list) {
                cache.setStatusChecked(false);
            }
        }
        notifyDataSetChanged();
    }

    public boolean isSelectMode() {
        return selectMode;
    }

    public void switchSelectMode() {
        setSelectMode(!isSelectMode());
    }

    public void invertSelection() {
        for (cgCache cache : list) {
            cache.setStatusChecked(!cache.isStatusChecked());
        }
        notifyDataSetChanged();
    }

    public void forceSort() {
        if (CollectionUtils.isEmpty(list) || selectMode) {
            return;
        }

        if (isSortedByDistance()) {
            lastSort = 0;
            updateSortByDistance();
        }
        else {
            Collections.sort(list, cacheComparator);
        }

        notifyDataSetChanged();
    }

    public void setActualCoordinates(final Geopoint coords) {
        this.coords = coords;
        updateSortByDistance();

        for (final DistanceView distance : distances) {
            distance.update(coords);
        }
        for (final CompassMiniView compass : compasses) {
            compass.updateCurrentCoords(coords);
        }
    }

    private void updateSortByDistance() {
        if (CollectionUtils.isEmpty(list)) {
            return;
        }
        if (selectMode) {
            return;
        }
        if ((System.currentTimeMillis() - lastSort) <= PAUSE_BETWEEN_LIST_SORT) {
            return;
        }
        if (!isSortedByDistance()) {
            return;
        }
        if (coords == null) {
            return;
        }
        Collections.sort(list, new DistanceComparator(coords, list));
        notifyDataSetChanged();
        lastSort = System.currentTimeMillis();
    }

    private boolean isSortedByDistance() {
        return cacheComparator == null || cacheComparator instanceof DistanceComparator;
    }

    public void setActualHeading(final float direction) {
        if (Math.abs(AngleUtils.difference(azimuth, direction)) < 10) {
            return;
        }

        azimuth = direction;
        for (final CompassMiniView compass : compasses) {
            compass.updateAzimuth(azimuth);
        }
    }

    @Override
    public View getView(final int position, final View rowView, final ViewGroup parent) {
        if (inflater == null) {
            inflater = ((Activity) getContext()).getLayoutInflater();
        }

        if (position > getCount()) {
            Log.w("CacheListAdapter.getView: Attempt to access missing item #" + position);
            return null;
        }

        final cgCache cache = getItem(position);

        View v = rowView;

        final ViewHolder holder;
        if (v == null) {
            v = inflater.inflate(R.layout.caches_item, null);

            holder = new ViewHolder();
            holder.checkbox = (CheckBox) v.findViewById(R.id.checkbox);
            holder.logStatusMark = (ImageView) v.findViewById(R.id.log_status_mark);
            holder.text = (TextView) v.findViewById(R.id.text);
            holder.directionLayout = (RelativeLayout) v.findViewById(R.id.direction_layout);
            holder.distance = (DistanceView) v.findViewById(R.id.distance);
            holder.direction = (CompassMiniView) v.findViewById(R.id.direction);
            holder.dirImgLayout = (RelativeLayout) v.findViewById(R.id.dirimg_layout);
            holder.dirImg = (ImageView) v.findViewById(R.id.dirimg);
            holder.inventory = (ImageView) v.findViewById(R.id.inventory);
            holder.favourite = (TextView) v.findViewById(R.id.favourite);
            holder.info = (TextView) v.findViewById(R.id.info);

            v.setTag(holder);
        } else {
            holder = (ViewHolder) v.getTag();
        }

        final boolean lightSkin = Settings.isLightSkin();

        final TouchListener touchLst = new TouchListener(cache);
        v.setOnClickListener(touchLst);
        v.setOnLongClickListener(touchLst);
        v.setOnTouchListener(touchLst);
        v.setLongClickable(true);

        if (selectMode) {
            holder.checkbox.setVisibility(View.VISIBLE);
        }
        else {
            holder.checkbox.setVisibility(View.GONE);
        }

        holder.checkbox.setChecked(cache.isStatusChecked());
        holder.checkbox.setOnClickListener(new SelectionCheckBoxListener(cache));

        distances.add(holder.distance);
        holder.distance.setContent(cache.getCoords());
        compasses.add(holder.direction);
        holder.direction.setTargetCoords(cache.getCoords());

        if (cache.isFound() && cache.isLogOffline()) {
            holder.logStatusMark.setImageResource(R.drawable.mark_green_orange);
            holder.logStatusMark.setVisibility(View.VISIBLE);
        } else if (cache.isFound()) {
            holder.logStatusMark.setImageResource(R.drawable.mark_green_more);
            holder.logStatusMark.setVisibility(View.VISIBLE);
        } else if (cache.isLogOffline()) {
            holder.logStatusMark.setImageResource(R.drawable.mark_orange);
            holder.logStatusMark.setVisibility(View.VISIBLE);
        } else {
            holder.logStatusMark.setVisibility(View.GONE);
        }

        if (cache.getNameSp() == null) {
            cache.setNameSp((new Spannable.Factory()).newSpannable(cache.getName()));
            if (cache.isDisabled() || cache.isArchived()) { // strike
                cache.getNameSp().setSpan(new StrikethroughSpan(), 0, cache.getNameSp().toString().length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
            }
        }

        holder.text.setText(cache.getNameSp(), TextView.BufferType.SPANNABLE);
        holder.text.setCompoundDrawablesWithIntrinsicBounds(getCacheIcon(cache), null, null, null);

        if (cache.getInventoryItems() > 0) {
            holder.inventory.setVisibility(View.VISIBLE);
        } else {
            holder.inventory.setVisibility(View.GONE);
        }

        boolean setDiDi = false;
        if (cache.getCoords() != null) {
            holder.direction.setVisibility(View.VISIBLE);
            holder.direction.updateAzimuth(azimuth);
            if (coords != null) {
                holder.distance.update(coords);
                holder.direction.updateCurrentCoords(coords);
            }
            setDiDi = true;
        } else {
            if (cache.getDistance() != null) {
                holder.distance.setDistance(cache.getDistance());
                setDiDi = true;
            }
            if (cache.getDirection() != null) {
                holder.direction.setVisibility(View.VISIBLE);
                holder.direction.updateAzimuth(azimuth);
                holder.direction.updateHeading(cache.getDirection());
                setDiDi = true;
            }
        }

        if (setDiDi) {
            holder.directionLayout.setVisibility(View.VISIBLE);
            holder.dirImgLayout.setVisibility(View.GONE);
        } else {
            holder.directionLayout.setVisibility(View.GONE);
            holder.distance.clear();

            final Bitmap dirImgPre = BitmapFactory.decodeFile(DirectionImage.getDirectionFile(cache.getGeocode(), false).getPath());
            final Bitmap dirImg;
            if (dirImgPre != null) { // null happens for invalid caches (not yet released)
                dirImg = dirImgPre.copy(Bitmap.Config.ARGB_8888, true);
                dirImgPre.recycle();
            }
            else {
                dirImg = null;
            }

            if (dirImg != null) {
                if (!lightSkin) {
                    final int length = dirImg.getWidth() * dirImg.getHeight();
                    final int[] pixels = new int[length];
                    dirImg.getPixels(pixels, 0, dirImg.getWidth(), 0, 0, dirImg.getWidth(), dirImg.getHeight());
                    for (int i = 0; i < length; i++) {
                        if (pixels[i] == 0xff000000) { // replace black with white
                            pixels[i] = 0xffffffff;
                        }
                    }
                    dirImg.setPixels(pixels, 0, dirImg.getWidth(), 0, 0, dirImg.getWidth(), dirImg.getHeight());
                }

                holder.dirImg.setImageBitmap(dirImg);
                holder.dirImgLayout.setVisibility(View.VISIBLE);
            } else {
                holder.dirImg.setImageBitmap(null);
                holder.dirImgLayout.setVisibility(View.GONE);
            }
        }

        holder.favourite.setText(Integer.toString(cache.getFavoritePoints()));

        int favoriteBack;
        // set default background, neither vote nor rating may be available
        if (lightSkin) {
            favoriteBack = R.drawable.favourite_background_light;
        } else {
            favoriteBack = R.drawable.favourite_background_dark;
        }
        final float myVote = cache.getMyVote();
        if (myVote > 0) { // use my own rating for display, if I have voted
            if (myVote >= 4) {
                favoriteBack = RATING_BACKGROUND[2];
            } else if (myVote >= 3) {
                favoriteBack = RATING_BACKGROUND[1];
            } else if (myVote > 0) {
                favoriteBack = RATING_BACKGROUND[0];
            }
        } else {
            final float rating = cache.getRating();
            if (rating >= 3.5) {
                favoriteBack = RATING_BACKGROUND[2];
            } else if (rating >= 2.1) {
                favoriteBack = RATING_BACKGROUND[1];
            } else if (rating > 0.0) {
                favoriteBack = RATING_BACKGROUND[0];
            }
        }
        holder.favourite.setBackgroundResource(favoriteBack);

        if (cacheListType == CacheListType.HISTORY && cache.getVisitedDate() > 0) {
            final ArrayList<String> infos = new ArrayList<String>();
            infos.add(StringUtils.upperCase(cache.getGeocode()));
            infos.add(Formatter.formatDate(cache.getVisitedDate()));
            infos.add(Formatter.formatTime(cache.getVisitedDate()));
            holder.info.setText(StringUtils.join(infos, Formatter.SEPARATOR));
        } else {
            final ArrayList<String> infos = new ArrayList<String>();
            if (StringUtils.isNotBlank(cache.getGeocode())) {
                infos.add(cache.getGeocode());
            }
            if (cache.hasDifficulty()) {
                infos.add("D " + String.format("%.1f", cache.getDifficulty()));
            }
            if (cache.hasTerrain()) {
                infos.add("T " + String.format("%.1f", cache.getTerrain()));
            }

            // don't show "not chosen" for events and virtuals, that should be the normal case
            if (cache.getSize() != CacheSize.UNKNOWN && cache.showSize()) {
                infos.add(cache.getSize().getL10n());
            } else if (cache.isEventCache() && cache.getHiddenDate() != null) {
                infos.add(Formatter.formatShortDate(cache.getHiddenDate().getTime()));
            }

            if (cache.isPremiumMembersOnly()) {
                infos.add(res.getString(R.string.cache_premium));
            }
            if (cacheListType != CacheListType.OFFLINE && cacheListType != CacheListType.HISTORY && cache.getListId() > 0) {
                infos.add(res.getString(R.string.cache_offline));
            }
            holder.info.setText(StringUtils.join(infos, Formatter.SEPARATOR));
        }

        return v;
    }

    private static Drawable getCacheIcon(cgCache cache) {
        int hashCode = getIconHashCode(cache.getType(), cache.hasUserModifiedCoords() || cache.hasFinalDefined());
        final Drawable drawable = gcIconDrawables.get(hashCode);
        if (drawable != null) {
            return drawable;
        }

        // fallback to mystery icon
        hashCode = getIconHashCode(CacheType.MYSTERY, cache.hasUserModifiedCoords() || cache.hasFinalDefined());
        return gcIconDrawables.get(hashCode);
    }

    @Override
    public void notifyDataSetChanged() {
        super.notifyDataSetChanged();
        distances.clear();
        compasses.clear();
    }

    private static class SelectionCheckBoxListener implements View.OnClickListener {

        private final cgCache cache;

        public SelectionCheckBoxListener(cgCache cache) {
            this.cache = cache;
        }

        @Override
        public void onClick(View view) {
            final boolean checkNow = ((CheckBox) view).isChecked();
            cache.setStatusChecked(checkNow);
        }
    }

    private class TouchListener implements View.OnLongClickListener, View.OnClickListener, View.OnTouchListener {

        private boolean touch = true;
        private final GestureDetector gestureDetector;
        private final cgCache cache;

        public TouchListener(final cgCache cache) {
            this.cache = cache;
            final FlingGesture dGesture = new FlingGesture(cache);
            gestureDetector = new GestureDetector(getContext(), dGesture);
        }

        // tap on item
        @Override
        public void onClick(View view) {
            if (!touch) {
                touch = true;
                return;
            }

            if (isSelectMode()) {
                cache.setStatusChecked(!cache.isStatusChecked());
                notifyDataSetChanged();
                return;
            }

            // load cache details
            CacheDetailActivity.startActivity(getContext(), cache.getGeocode(), cache.getName());
        }

        // long tap on item
        @Override
        public boolean onLongClick(View view) {
            if (!touch) {
                touch = true;
                return true;
            }

            return view.showContextMenu();
        }

        // swipe on item
        @Override
        public boolean onTouch(View view, MotionEvent event) {
            if (gestureDetector.onTouchEvent(event)) {
                touch = false;
                return true;
            }

            return false;
        }
    }

    private class FlingGesture extends GestureDetector.SimpleOnGestureListener {

        private final cgCache cache;

        public FlingGesture(cgCache cache) {
            this.cache = cache;
        }

        @Override
        public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
            try {
                if (Math.abs(e1.getY() - e2.getY()) > SWIPE_MAX_OFF_PATH) {
                    return false;
                }

                // left to right swipe
                if ((e2.getX() - e1.getX()) > SWIPE_MIN_DISTANCE && Math.abs(velocityX) > Math.abs(velocityY)) {
                    if (!selectMode) {
                        switchSelectMode();
                        cache.setStatusChecked(true);
                    }
                    return true;
                }

                // right to left swipe
                if ((e1.getX() - e2.getX()) > SWIPE_MIN_DISTANCE && Math.abs(velocityX) > Math.abs(velocityY)) {
                    if (selectMode) {
                        switchSelectMode();
                    }
                    return true;
                }
            } catch (Exception e) {
                Log.w("CacheListAdapter.FlingGesture.onFling: " + e.toString());
            }

            return false;
        }
    }

    public List<cgCache> getFilteredList() {
        return list;
    }

    public List<cgCache> getCheckedCaches() {
        final ArrayList<cgCache> result = new ArrayList<cgCache>();
        for (cgCache cache : list) {
            if (cache.isStatusChecked()) {
                result.add(cache);
            }
        }
        return result;
    }

    public List<cgCache> getCheckedOrAllCaches() {
        final List<cgCache> result = getCheckedCaches();
        if (!result.isEmpty()) {
            return result;
        }
        return new ArrayList<cgCache>(list);
    }

    public int getCheckedOrAllCount() {
        final int checked = getCheckedCount();
        if (checked > 0) {
            return checked;
        }
        return list.size();
    }
}
!@#$%
20190526_235837,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_c17168
package cgeo.geocaching.ui;

import cgeo.geocaching.CacheDetailActivity;
import cgeo.geocaching.IGeoData;
import cgeo.geocaching.R;
import cgeo.geocaching.Settings;
import cgeo.geocaching.cgCache;
import cgeo.geocaching.cgeoapplication;
import cgeo.geocaching.enumerations.CacheListType;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.filter.IFilter;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.sorting.CacheComparator;
import cgeo.geocaching.sorting.DistanceComparator;
import cgeo.geocaching.sorting.VisitComparator;
import cgeo.geocaching.utils.AngleUtils;
import cgeo.geocaching.utils.Log;

import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang3.builder.HashCodeBuilder;

import android.app.Activity;
import android.content.res.Resources;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.drawable.Drawable;
import android.graphics.drawable.LayerDrawable;
import android.text.Spannable;
import android.text.Spanned;
import android.text.style.StrikethroughSpan;
import android.util.SparseArray;
import android.view.GestureDetector;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ArrayAdapter;
import android.widget.CheckBox;
import android.widget.ImageView;
import android.widget.RelativeLayout;
import android.widget.TextView;

import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;

public class CacheListAdapter extends ArrayAdapter<cgCache> {

    private LayoutInflater inflater = null;
    private CacheComparator cacheComparator = null;
    private Geopoint coords;
    private float azimuth = 0;
    private long lastSort = 0L;
    private boolean selectMode = false;
    private IFilter currentFilter = null;
    private List<cgCache> originalList = null;

    final private Set<CompassMiniView> compasses = new LinkedHashSet<CompassMiniView>();
    final private Set<DistanceView> distances = new LinkedHashSet<DistanceView>();
    final private CacheListType cacheListType;
    final private Resources res;
    /** Resulting list of caches */
    final private List<cgCache> list;

    private static final int SWIPE_MIN_DISTANCE = 60;
    private static final int SWIPE_MAX_OFF_PATH = 100;
    private static final SparseArray<Drawable> gcIconDrawables = new SparseArray<Drawable>();
    /**
     * time in milliseconds after which the list may be resorted due to position updates
     */
    private static final int PAUSE_BETWEEN_LIST_SORT = 1000;

    private static final int[] RATING_BACKGROUND = new int[3];
    static {
        if (Settings.isLightSkin()) {
            RATING_BACKGROUND[0] = R.drawable.favourite_background_red_light;
            RATING_BACKGROUND[1] = R.drawable.favourite_background_orange_light;
            RATING_BACKGROUND[2] = R.drawable.favourite_background_green_light;
        } else {
            RATING_BACKGROUND[0] = R.drawable.favourite_background_red_dark;
            RATING_BACKGROUND[1] = R.drawable.favourite_background_orange_dark;
            RATING_BACKGROUND[2] = R.drawable.favourite_background_green_dark;
        }
    }

    /**
     * view holder for the cache list adapter
     *
     */
    private static class ViewHolder {
        CheckBox checkbox;
        ImageView logStatusMark;
        TextView text;
        TextView favourite;
        TextView info;
        ImageView inventory;
        RelativeLayout directionLayout;
        DistanceView distance;
        CompassMiniView direction;
        RelativeLayout dirImgLayout;
        ImageView dirImg;
    }

    public CacheListAdapter(final Activity activity, final List<cgCache> list, CacheListType cacheListType) {
        super(activity, 0, list);
        final IGeoData currentGeo = cgeoapplication.getInstance().currentGeo();
        if (currentGeo != null) {
            coords = currentGeo.getCoords();
        }
        this.res = activity.getResources();
        this.list = list;
        this.cacheListType = cacheListType;
        if (cacheListType == CacheListType.HISTORY) {
            cacheComparator = new VisitComparator();
        }

        final Drawable modifiedCoordinatesMarker = activity.getResources().getDrawable(R.drawable.marker_usermodifiedcoords);
        for (final CacheType cacheType : CacheType.values()) {
            // unmodified icon
            int hashCode = getIconHashCode(cacheType, false);
            gcIconDrawables.put(hashCode, activity.getResources().getDrawable(cacheType.markerId));
            // icon with flag for user modified coordinates
            hashCode = getIconHashCode(cacheType, true);
            Drawable[] layers = new Drawable[2];
            layers[0] = activity.getResources().getDrawable(cacheType.markerId);
            layers[1] = modifiedCoordinatesMarker;
            LayerDrawable ld = new LayerDrawable(layers);
            ld.setLayerInset(1,
                    layers[0].getIntrinsicWidth() - layers[1].getIntrinsicWidth(),
                    layers[0].getIntrinsicHeight() - layers[1].getIntrinsicHeight(),
                    0, 0);
            gcIconDrawables.put(hashCode, ld);
        }
    }

    private static int getIconHashCode(final CacheType cacheType, final boolean userModifiedOrFinal) {
        return new HashCodeBuilder()
                .append(cacheType)
                .append(userModifiedOrFinal)
                .toHashCode();
    }

    /**
     * change the sort order
     *
     * @param comparator
     */
    public void setComparator(final CacheComparator comparator) {
        cacheComparator = comparator;
        forceSort();
    }

    public CacheComparator getCacheComparator() {
        return cacheComparator;
    }

    public cgCache findCacheByGeocode(String geocode) {
        for (int i = 0; i < getCount(); i++) {
            if (getItem(i).getGeocode().equalsIgnoreCase(geocode)) {
                return getItem(i);
            }
        }

        return null;
    }
    /**
     * Called when a new page of caches was loaded.
     */
    public void reFilter() {
        if (currentFilter != null) {
            // Back up the list again
            originalList = new ArrayList<cgCache>(list);

            currentFilter.filter(list);
        }
    }

    /**
     * Called after a user action on the filter menu.
     */
    public void setFilter(final IFilter filter) {
        // Backup current caches list if it isn't backed up yet
        if (originalList == null) {
            originalList = new ArrayList<cgCache>(list);
        }

        // If there is already a filter in place, this is a request to change or clear the filter, so we have to
        // replace the original cache list
        if (currentFilter != null) {
            list.clear();
            list.addAll(originalList);
        }

        // Do the filtering or clear it
        if (filter != null) {
            filter.filter(list);
        }
        currentFilter = filter;

        notifyDataSetChanged();
    }

    public boolean isFiltered() {
        return currentFilter != null;
    }

    public String getFilterName() {
        return currentFilter.getName();
    }

    public int getCheckedCount() {
        int checked = 0;
        for (cgCache cache : list) {
            if (cache.isStatusChecked()) {
                checked++;
            }
        }
        return checked;
    }

    public void setSelectMode(final boolean selectMode) {
        this.selectMode = selectMode;

        if (!selectMode) {
            for (final cgCache cache : list) {
                cache.setStatusChecked(false);
            }
        }
        notifyDataSetChanged();
    }

    public boolean isSelectMode() {
        return selectMode;
    }

    public void switchSelectMode() {
        setSelectMode(!isSelectMode());
    }

    public void invertSelection() {
        for (cgCache cache : list) {
            cache.setStatusChecked(!cache.isStatusChecked());
        }
        notifyDataSetChanged();
    }

    public void forceSort() {
        if (CollectionUtils.isEmpty(list) || selectMode) {
            return;
        }

        if (isSortedByDistance()) {
            lastSort = 0;
            updateSortByDistance();
        }
        else {
            Collections.sort(list, cacheComparator);
        }

        notifyDataSetChanged();
    }

    public void setActualCoordinates(final Geopoint coords) {
        this.coords = coords;
        updateSortByDistance();

        for (final DistanceView distance : distances) {
            distance.update(coords);
        }
        for (final CompassMiniView compass : compasses) {
            compass.updateCurrentCoords(coords);
        }
    }

    private void updateSortByDistance() {
        if (CollectionUtils.isEmpty(list)) {
            return;
        }
        if (selectMode) {
            return;
        }
        if ((System.currentTimeMillis() - lastSort) <= PAUSE_BETWEEN_LIST_SORT) {
            return;
        }
        if (!isSortedByDistance()) {
            return;
        }
        if (coords == null) {
            return;
        }
        Collections.sort(list, new DistanceComparator(coords, list));
        notifyDataSetChanged();
        lastSort = System.currentTimeMillis();
    }

    private boolean isSortedByDistance() {
        return cacheComparator == null || cacheComparator instanceof DistanceComparator;
    }

    public void setActualHeading(final float direction) {
        if (Math.abs(AngleUtils.difference(azimuth, direction)) < 10) {
            return;
        }

        azimuth = direction;
        for (final CompassMiniView compass : compasses) {
            compass.updateAzimuth(azimuth);
        }
    }

    @Override
    public View getView(final int position, final View rowView, final ViewGroup parent) {
        if (inflater == null) {
            inflater = ((Activity) getContext()).getLayoutInflater();
        }

        if (position > getCount()) {
            Log.w("CacheListAdapter.getView: Attempt to access missing item #" + position);
            return null;
        }

        final cgCache cache = getItem(position);

        View v = rowView;

        final ViewHolder holder;
        if (v == null) {
            v = inflater.inflate(R.layout.caches_item, null);

            holder = new ViewHolder();
            holder.checkbox = (CheckBox) v.findViewById(R.id.checkbox);
            holder.logStatusMark = (ImageView) v.findViewById(R.id.log_status_mark);
            holder.text = (TextView) v.findViewById(R.id.text);
            holder.directionLayout = (RelativeLayout) v.findViewById(R.id.direction_layout);
            holder.distance = (DistanceView) v.findViewById(R.id.distance);
            holder.direction = (CompassMiniView) v.findViewById(R.id.direction);
            holder.dirImgLayout = (RelativeLayout) v.findViewById(R.id.dirimg_layout);
            holder.dirImg = (ImageView) v.findViewById(R.id.dirimg);
            holder.inventory = (ImageView) v.findViewById(R.id.inventory);
            holder.favourite = (TextView) v.findViewById(R.id.favourite);
            holder.info = (TextView) v.findViewById(R.id.info);

            v.setTag(holder);
        } else {
            holder = (ViewHolder) v.getTag();
        }

        final boolean lightSkin = Settings.isLightSkin();

        final TouchListener touchLst = new TouchListener(cache);
        v.setOnClickListener(touchLst);
        v.setOnLongClickListener(touchLst);
        v.setOnTouchListener(touchLst);
        v.setLongClickable(true);

        if (selectMode) {
            holder.checkbox.setVisibility(View.VISIBLE);
        }
        else {
            holder.checkbox.setVisibility(View.GONE);
        }

        holder.checkbox.setChecked(cache.isStatusChecked());
        holder.checkbox.setOnClickListener(new SelectionCheckBoxListener(cache));

        distances.add(holder.distance);
        holder.distance.setContent(cache.getCoords());
        compasses.add(holder.direction);
        holder.direction.setTargetCoords(cache.getCoords());

        if (cache.isFound() && cache.isLogOffline()) {
            holder.logStatusMark.setImageResource(R.drawable.mark_green_orange);
            holder.logStatusMark.setVisibility(View.VISIBLE);
        } else if (cache.isFound()) {
            holder.logStatusMark.setImageResource(R.drawable.mark_green_more);
            holder.logStatusMark.setVisibility(View.VISIBLE);
        } else if (cache.isLogOffline()) {
            holder.logStatusMark.setImageResource(R.drawable.mark_orange);
            holder.logStatusMark.setVisibility(View.VISIBLE);
        } else {
            holder.logStatusMark.setVisibility(View.GONE);
        }

        if (cache.getNameSp() == null) {
            cache.setNameSp((new Spannable.Factory()).newSpannable(cache.getName()));
            if (cache.isDisabled() || cache.isArchived()) { // strike
                cache.getNameSp().setSpan(new StrikethroughSpan(), 0, cache.getNameSp().toString().length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
            }
        }

        holder.text.setText(cache.getNameSp(), TextView.BufferType.SPANNABLE);
        holder.text.setCompoundDrawablesWithIntrinsicBounds(getCacheIcon(cache), null, null, null);

        if (cache.getInventoryItems() > 0) {
            holder.inventory.setVisibility(View.VISIBLE);
        } else {
            holder.inventory.setVisibility(View.GONE);
        }

        boolean setDiDi = false;
        if (cache.getCoords() != null) {
            holder.direction.setVisibility(View.VISIBLE);
            holder.direction.updateAzimuth(azimuth);
            if (coords != null) {
                holder.distance.update(coords);
                holder.direction.updateCurrentCoords(coords);
            }
            setDiDi = true;
        } else {
            if (cache.getDistance() != null) {
                holder.distance.setDistance(cache.getDistance());
                setDiDi = true;
            }
            if (cache.getDirection() != null) {
                holder.direction.setVisibility(View.VISIBLE);
                holder.direction.updateAzimuth(azimuth);
                holder.direction.updateHeading(cache.getDirection());
                setDiDi = true;
            }
        }

        if (setDiDi) {
            holder.directionLayout.setVisibility(View.VISIBLE);
            holder.dirImgLayout.setVisibility(View.GONE);
        } else {
            holder.directionLayout.setVisibility(View.GONE);
            holder.distance.clear();

            final Bitmap dirImgPre = BitmapFactory.decodeFile(DirectionImage.getDirectionFile(cache.getGeocode(), false).getPath());
            final Bitmap dirImg;
            if (dirImgPre != null) { // null happens for invalid caches (not yet released)
                dirImg = dirImgPre.copy(Bitmap.Config.ARGB_8888, true);
                dirImgPre.recycle();
            }
            else {
                dirImg = null;
            }

            if (dirImg != null) {
                if (!lightSkin) {
                    final int length = dirImg.getWidth() * dirImg.getHeight();
                    final int[] pixels = new int[length];
                    dirImg.getPixels(pixels, 0, dirImg.getWidth(), 0, 0, dirImg.getWidth(), dirImg.getHeight());
                    for (int i = 0; i < length; i++) {
                        if (pixels[i] == 0xff000000) { // replace black with white
                            pixels[i] = 0xffffffff;
                        }
                    }
                    dirImg.setPixels(pixels, 0, dirImg.getWidth(), 0, 0, dirImg.getWidth(), dirImg.getHeight());
                }

                holder.dirImg.setImageBitmap(dirImg);
                holder.dirImgLayout.setVisibility(View.VISIBLE);
            } else {
                holder.dirImg.setImageBitmap(null);
                holder.dirImgLayout.setVisibility(View.GONE);
            }
        }

        holder.favourite.setText(Integer.toString(cache.getFavoritePoints()));

        int favoriteBack;
        // set default background, neither vote nor rating may be available
        if (lightSkin) {
            favoriteBack = R.drawable.favourite_background_light;
        } else {
            favoriteBack = R.drawable.favourite_background_dark;
        }
        final float myVote = cache.getMyVote();
        if (myVote > 0) { // use my own rating for display, if I have voted
            if (myVote >= 4) {
                favoriteBack = RATING_BACKGROUND[2];
            } else if (myVote >= 3) {
                favoriteBack = RATING_BACKGROUND[1];
            } else if (myVote > 0) {
                favoriteBack = RATING_BACKGROUND[0];
            }
        } else {
            final float rating = cache.getRating();
            if (rating >= 3.5) {
                favoriteBack = RATING_BACKGROUND[2];
            } else if (rating >= 2.1) {
                favoriteBack = RATING_BACKGROUND[1];
            } else if (rating > 0.0) {
                favoriteBack = RATING_BACKGROUND[0];
            }
        }
        holder.favourite.setBackgroundResource(favoriteBack);

        if (cacheListType == CacheListType.HISTORY && cache.getVisitedDate() > 0) {
            holder.info.setText(Formatter.formatCacheInfoHistory(cache));
        } else {
            holder.info.setText(Formatter.formatCacheInfoLong(cache, cacheListType));
        }

        return v;
    }

    private static Drawable getCacheIcon(cgCache cache) {
        int hashCode = getIconHashCode(cache.getType(), cache.hasUserModifiedCoords() || cache.hasFinalDefined());
        final Drawable drawable = gcIconDrawables.get(hashCode);
        if (drawable != null) {
            return drawable;
        }

        // fallback to mystery icon
        hashCode = getIconHashCode(CacheType.MYSTERY, cache.hasUserModifiedCoords() || cache.hasFinalDefined());
        return gcIconDrawables.get(hashCode);
    }

    @Override
    public void notifyDataSetChanged() {
        super.notifyDataSetChanged();
        distances.clear();
        compasses.clear();
    }

    private static class SelectionCheckBoxListener implements View.OnClickListener {

        private final cgCache cache;

        public SelectionCheckBoxListener(cgCache cache) {
            this.cache = cache;
        }

        @Override
        public void onClick(View view) {
            final boolean checkNow = ((CheckBox) view).isChecked();
            cache.setStatusChecked(checkNow);
        }
    }

    private class TouchListener implements View.OnLongClickListener, View.OnClickListener, View.OnTouchListener {

        private boolean touch = true;
        private final GestureDetector gestureDetector;
        private final cgCache cache;

        public TouchListener(final cgCache cache) {
            this.cache = cache;
            final FlingGesture dGesture = new FlingGesture(cache);
            gestureDetector = new GestureDetector(getContext(), dGesture);
        }

        // tap on item
        @Override
        public void onClick(View view) {
            if (!touch) {
                touch = true;
                return;
            }

            if (isSelectMode()) {
                cache.setStatusChecked(!cache.isStatusChecked());
                notifyDataSetChanged();
                return;
            }

            // load cache details
            CacheDetailActivity.startActivity(getContext(), cache.getGeocode(), cache.getName());
        }

        // long tap on item
        @Override
        public boolean onLongClick(View view) {
            if (!touch) {
                touch = true;
                return true;
            }

            return view.showContextMenu();
        }

        // swipe on item
        @Override
        public boolean onTouch(View view, MotionEvent event) {
            if (gestureDetector.onTouchEvent(event)) {
                touch = false;
                return true;
            }

            return false;
        }
    }

    private class FlingGesture extends GestureDetector.SimpleOnGestureListener {

        private final cgCache cache;

        public FlingGesture(cgCache cache) {
            this.cache = cache;
        }

        @Override
        public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
            try {
                if (Math.abs(e1.getY() - e2.getY()) > SWIPE_MAX_OFF_PATH) {
                    return false;
                }

                // left to right swipe
                if ((e2.getX() - e1.getX()) > SWIPE_MIN_DISTANCE && Math.abs(velocityX) > Math.abs(velocityY)) {
                    if (!selectMode) {
                        switchSelectMode();
                        cache.setStatusChecked(true);
                    }
                    return true;
                }

                // right to left swipe
                if ((e1.getX() - e2.getX()) > SWIPE_MIN_DISTANCE && Math.abs(velocityX) > Math.abs(velocityY)) {
                    if (selectMode) {
                        switchSelectMode();
                    }
                    return true;
                }
            } catch (Exception e) {
                Log.w("CacheListAdapter.FlingGesture.onFling: " + e.toString());
            }

            return false;
        }
    }

    public List<cgCache> getFilteredList() {
        return list;
    }

    public List<cgCache> getCheckedCaches() {
        final ArrayList<cgCache> result = new ArrayList<cgCache>();
        for (cgCache cache : list) {
            if (cache.isStatusChecked()) {
                result.add(cache);
            }
        }
        return result;
    }

    public List<cgCache> getCheckedOrAllCaches() {
        final List<cgCache> result = getCheckedCaches();
        if (!result.isEmpty()) {
            return result;
        }
        return new ArrayList<cgCache>(list);
    }

    public int getCheckedOrAllCount() {
        final int checked = getCheckedCount();
        if (checked > 0) {
            return checked;
        }
        return list.size();
    }
}
!@#$%
20190526_235855,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_b09016
package cgeo.geocaching;

import cgeo.geocaching.activity.AbstractActivity;
import cgeo.geocaching.apps.cache.navi.NavigationAppFactory;
import cgeo.geocaching.apps.cache.navi.NavigationAppFactory.NavigationAppsEnum;
import cgeo.geocaching.compatibility.Compatibility;
import cgeo.geocaching.connector.gc.Login;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.StatusCode;
import cgeo.geocaching.maps.MapProviderFactory;
import cgeo.geocaching.maps.interfaces.MapSource;
import cgeo.geocaching.network.Cookies;
import cgeo.geocaching.network.Network;
import cgeo.geocaching.network.Parameters;
import cgeo.geocaching.twitter.TwitterAuthorizationActivity;
import cgeo.geocaching.ui.Formatter;
import cgeo.geocaching.utils.Log;
import cgeo.geocaching.utils.LogTemplateProvider;
import cgeo.geocaching.utils.LogTemplateProvider.LogTemplate;

import ch.boye.httpclientandroidlib.HttpResponse;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;

import android.app.ProgressDialog;
import android.content.Context;
import android.content.Intent;
import android.content.res.Configuration;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.view.ContextMenu;
import android.view.ContextMenu.ContextMenuInfo;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemSelectedListener;
import android.widget.ArrayAdapter;
import android.widget.Button;
import android.widget.CheckBox;
import android.widget.EditText;
import android.widget.Spinner;
import android.widget.TextView;

import java.io.File;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

public class SettingsActivity extends AbstractActivity {

    private final static int SELECT_MAPFILE_REQUEST = 1;

    private ProgressDialog loginDialog = null;
    private ProgressDialog webDialog = null;
    private boolean enableTemplatesMenu = false;
    private Handler logInHandler = new Handler() {

        @Override
        public void handleMessage(Message msg) {
            try {
                if (loginDialog != null && loginDialog.isShowing()) {
                    loginDialog.dismiss();
                }

                if (msg.obj == null || (msg.obj instanceof Drawable)) {
                    helpDialog(res.getString(R.string.init_login_popup), res.getString(R.string.init_login_popup_ok),
                            (Drawable) msg.obj);
                } else {
                    helpDialog(res.getString(R.string.init_login_popup),
                            res.getString(R.string.init_login_popup_failed_reason) + " " +
                                    ((StatusCode) msg.obj).getErrorString(res) + ".");
                }
            } catch (Exception e) {
                showToast(res.getString(R.string.err_login_failed));

                Log.e("SettingsActivity.logInHandler: " + e.toString());
            }

            if (loginDialog != null && loginDialog.isShowing()) {
                loginDialog.dismiss();
            }

            init();
        }
    };

    private Handler webAuthHandler = new Handler() {

        @Override
        public void handleMessage(Message msg) {
            try {
                if (webDialog != null && webDialog.isShowing()) {
                    webDialog.dismiss();
                }

                if (msg.what > 0) {
                    helpDialog(res.getString(R.string.init_sendToCgeo), res.getString(R.string.init_sendToCgeo_register_ok).replace("####", String.valueOf(msg.what)));
                } else {
                    helpDialog(res.getString(R.string.init_sendToCgeo), res.getString(R.string.init_sendToCgeo_register_fail));
                }
            } catch (Exception e) {
                showToast(res.getString(R.string.init_sendToCgeo_register_fail));

                Log.e("SettingsActivity.webHandler: " + e.toString());
            }

            if (webDialog != null && webDialog.isShowing()) {
                webDialog.dismiss();
            }

            init();
        }
    };

    public SettingsActivity() {
        super("c:geo-configuration");
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        // init

        setTheme();
        setContentView(R.layout.init);
        setTitle(res.getString(R.string.settings));

        init();
    }

    @Override
    public void onConfigurationChanged(Configuration newConfig) {
        super.onConfigurationChanged(newConfig);

        init();
    }

    @Override
    public void onPause() {
        saveValues();
        super.onPause();
    }

    @Override
    public void onStop() {
        saveValues();
        Compatibility.dataChanged(getPackageName());
        super.onStop();
    }

    @Override
    public void onDestroy() {
        saveValues();

        super.onDestroy();
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        menu.add(0, 0, 0, res.getString(R.string.init_clear)).setIcon(R.drawable.ic_menu_delete);

        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        if (item.getItemId() == 0) {
            boolean status;

            ((EditText) findViewById(R.id.username)).setText("");
            ((EditText) findViewById(R.id.password)).setText("");
            ((EditText) findViewById(R.id.passvote)).setText("");

            status = saveValues();
            if (status) {
                showToast(res.getString(R.string.init_cleared));
            } else {
                showToast(res.getString(R.string.err_init_cleared));
            }

            finish();
        }

        return false;
    }

    @Override
    public void onCreateContextMenu(ContextMenu menu, View v,
            ContextMenuInfo menuInfo) {
        if (enableTemplatesMenu) {
            menu.setHeaderTitle(R.string.init_signature_template_button);
            for (LogTemplate template : LogTemplateProvider.getTemplates()) {
                menu.add(0, template.getItemId(), 0, template.getResourceId());
            }
        }
    }

    @Override
    public boolean onContextItemSelected(MenuItem item) {
        LogTemplate template = LogTemplateProvider.getTemplate(item.getItemId());
        if (template != null) {
            return insertSignatureTemplate(template);
        }
        return super.onContextItemSelected(item);
    }

    private boolean insertSignatureTemplate(final LogTemplate template) {
        EditText sig = (EditText) findViewById(R.id.signature);
        String insertText = "[" + template.getTemplateString() + "]";
        insertAtPosition(sig, insertText, true);
        return true;
    }

    public void init() {

        // geocaching.com settings
        final ImmutablePair<String, String> login = Settings.getLogin();
        if (login != null) {
            ((EditText) findViewById(R.id.username)).setText(login.left);
            ((EditText) findViewById(R.id.password)).setText(login.right);
        }

        Button logMeIn = (Button) findViewById(R.id.log_me_in);
        logMeIn.setOnClickListener(new logIn());

        TextView legalNote = (TextView) findViewById(R.id.legal_note);
        legalNote.setClickable(true);
        legalNote.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View arg0) {
                startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse("http://www.geocaching.com/about/termsofuse.aspx")));
            }
        });

        // gcvote settings
        final ImmutablePair<String, String> gcvoteLogin = Settings.getGCvoteLogin();
        if (null != gcvoteLogin && null != gcvoteLogin.right) {
            ((EditText) findViewById(R.id.passvote)).setText(gcvoteLogin.right);
        }

        // go4cache settings
        TextView go4cache = (TextView) findViewById(R.id.about_go4cache);
        go4cache.setClickable(true);
        go4cache.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View arg0) {
                startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse("http://go4cache.com/")));
            }
        });

        final CheckBox publicButton = (CheckBox) findViewById(R.id.publicloc);
        publicButton.setChecked(Settings.isPublicLoc());
        publicButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setPublicLoc(publicButton.isChecked());
            }
        });

        // Twitter settings
        Button authorizeTwitter = (Button) findViewById(R.id.authorize_twitter);
        authorizeTwitter.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View arg0) {
                Intent authIntent = new Intent(SettingsActivity.this, TwitterAuthorizationActivity.class);
                startActivity(authIntent);
            }
        });

        final CheckBox twitterButton = (CheckBox) findViewById(R.id.twitter_option);
        twitterButton.setChecked(Settings.isUseTwitter() && Settings.isTwitterLoginValid());
        twitterButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setUseTwitter(twitterButton.isChecked());
                if (Settings.isUseTwitter() && !Settings.isTwitterLoginValid()) {
                    Intent authIntent = new Intent(SettingsActivity.this, TwitterAuthorizationActivity.class);
                    startActivity(authIntent);
                }

                twitterButton.setChecked(Settings.isUseTwitter());
            }
        });

        // Signature settings
        EditText sigEdit = (EditText) findViewById(R.id.signature);
        if (sigEdit.getText().length() == 0) {
            sigEdit.setText(Settings.getSignature());
        }
        Button sigBtn = (Button) findViewById(R.id.signature_help);
        sigBtn.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                helpDialog(res.getString(R.string.init_signature_help_title), res.getString(R.string.init_signature_help_text));
            }
        });
        Button templates = (Button) findViewById(R.id.signature_template);
        registerForContextMenu(templates);
        templates.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                enableTemplatesMenu = true;
                openContextMenu(v);
                enableTemplatesMenu = false;
            }
        });
        final CheckBox autoinsertButton = (CheckBox) findViewById(R.id.sigautoinsert);
        autoinsertButton.setChecked(Settings.isAutoInsertSignature());
        autoinsertButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setAutoInsertSignature(autoinsertButton.isChecked());
            }
        });

        // Cache details
        final CheckBox autoloadButton = (CheckBox) findViewById(R.id.autoload);
        autoloadButton.setChecked(Settings.isAutoLoadDescription());
        autoloadButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setAutoLoadDesc(autoloadButton.isChecked());
            }
        });

        final CheckBox ratingWantedButton = (CheckBox) findViewById(R.id.ratingwanted);
        ratingWantedButton.setChecked(Settings.isRatingWanted());
        ratingWantedButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setRatingWanted(ratingWantedButton.isChecked());
            }
        });

        final CheckBox elevationWantedButton = (CheckBox) findViewById(R.id.elevationwanted);
        elevationWantedButton.setChecked(Settings.isElevationWanted());
        elevationWantedButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setElevationWanted(elevationWantedButton.isChecked());
            }
        });

        final CheckBox friendLogsWantedButton = (CheckBox) findViewById(R.id.friendlogswanted);
        friendLogsWantedButton.setChecked(Settings.isFriendLogsWanted());
        friendLogsWantedButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setFriendLogsWanted(friendLogsWantedButton.isChecked());
            }
        });

        final CheckBox openLastDetailsPageButton = (CheckBox) findViewById(R.id.openlastdetailspage);
        openLastDetailsPageButton.setChecked(Settings.isOpenLastDetailsPage());
        openLastDetailsPageButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setOpenLastDetailsPage(openLastDetailsPageButton.isChecked());
            }
        });

        // Other settings
        final CheckBox skinButton = (CheckBox) findViewById(R.id.skin);
        skinButton.setChecked(Settings.isLightSkin());
        skinButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setLightSkin(skinButton.isChecked());
            }
        });

        final CheckBox addressButton = (CheckBox) findViewById(R.id.address);
        addressButton.setChecked(Settings.isShowAddress());
        addressButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setShowAddress(addressButton.isChecked());
            }
        });

        final CheckBox captchaButton = (CheckBox) findViewById(R.id.captcha);
        captchaButton.setEnabled(!Settings.isPremiumMember());
        captchaButton.setChecked(Settings.isShowCaptcha());
        captchaButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setShowCaptcha(captchaButton.isChecked());
            }
        });

        final CheckBox dirImgButton = (CheckBox) findViewById(R.id.loaddirectionimg);
        dirImgButton.setEnabled(!Settings.isPremiumMember());
        dirImgButton.setChecked(Settings.getLoadDirImg());
        dirImgButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setLoadDirImg(!Settings.getLoadDirImg());
                dirImgButton.setChecked(Settings.getLoadDirImg());
            }
        });

        final CheckBox useEnglishButton = (CheckBox) findViewById(R.id.useenglish);
        useEnglishButton.setChecked(Settings.isUseEnglish());
        useEnglishButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setUseEnglish(useEnglishButton.isChecked());
            }
        });

        final CheckBox excludeButton = (CheckBox) findViewById(R.id.exclude);
        excludeButton.setChecked(Settings.isExcludeMyCaches());
        excludeButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setExcludeMine(excludeButton.isChecked());
            }
        });

        final CheckBox disabledButton = (CheckBox) findViewById(R.id.disabled);
        disabledButton.setChecked(Settings.isExcludeDisabledCaches());
        disabledButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setExcludeDisabledCaches(disabledButton.isChecked());
            }
        });

        TextView showWaypointsThreshold = (TextView) findViewById(R.id.showwaypointsthreshold);
        showWaypointsThreshold.setText(String.valueOf(Settings.getWayPointsThreshold()));

        final CheckBox autovisitButton = (CheckBox) findViewById(R.id.trackautovisit);
        autovisitButton.setChecked(Settings.isTrackableAutoVisit());
        autovisitButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setTrackableAutoVisit(autovisitButton.isChecked());
            }
        });

        final CheckBox offlineButton = (CheckBox) findViewById(R.id.offline);
        offlineButton.setChecked(Settings.isStoreOfflineMaps());
        offlineButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setStoreOfflineMaps(offlineButton.isChecked());
            }
        });

        final CheckBox offlineWpButton = (CheckBox) findViewById(R.id.offline_wp);
        offlineWpButton.setChecked(Settings.isStoreOfflineWpMaps());
        offlineWpButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setStoreOfflineWpMaps(offlineWpButton.isChecked());
            }
        });

        final CheckBox saveLogImgButton = (CheckBox) findViewById(R.id.save_log_img);
        saveLogImgButton.setChecked(Settings.isStoreLogImages());
        saveLogImgButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setStoreLogImages(saveLogImgButton.isChecked());
            }
        });

        final CheckBox livelistButton = (CheckBox) findViewById(R.id.livelist);
        livelistButton.setChecked(Settings.isLiveList());
        livelistButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setLiveList(livelistButton.isChecked());
            }
        });

        final CheckBox unitsButton = (CheckBox) findViewById(R.id.units);
        unitsButton.setChecked(!Settings.isUseMetricUnits());
        unitsButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setUseMetricUnits(!unitsButton.isChecked());
            }
        });

        final CheckBox gnavButton = (CheckBox) findViewById(R.id.gnav);
        gnavButton.setChecked(Settings.isUseGoogleNavigation());
        gnavButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setUseGoogleNavigation(gnavButton.isChecked());
            }
        });

        final CheckBox logOffline = (CheckBox) findViewById(R.id.log_offline);
        logOffline.setChecked(Settings.getLogOffline());
        logOffline.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setLogOffline(!Settings.getLogOffline());
                logOffline.setChecked(Settings.getLogOffline());
            }
        });

        // Altitude settings
        EditText altitudeEdit = (EditText) findViewById(R.id.altitude);
        altitudeEdit.setText(String.valueOf(Settings.getAltCorrection()));

        //Send2cgeo settings
        String webDeviceName = Settings.getWebDeviceName();

        if (StringUtils.isNotBlank(webDeviceName)) {
            ((EditText) findViewById(R.id.webDeviceName)).setText(webDeviceName);
        } else {
            String s = android.os.Build.MODEL;
            ((EditText) findViewById(R.id.webDeviceName)).setText(s);
        }

        Button webAuth = (Button) findViewById(R.id.sendToCgeo_register);
        webAuth.setOnClickListener(new webAuth());

        // Map source settings
        Collection<String> mapSourceNames = new ArrayList<String>();
        for (MapSource mapSource : MapProviderFactory.getMapSources().values()) {
            mapSourceNames.add(mapSource.getName());
        }
        Spinner mapSourceSelector = (Spinner) findViewById(R.id.mapsource);
        ArrayAdapter<CharSequence> adapter = new ArrayAdapter<CharSequence>(this, android.R.layout.simple_spinner_item, mapSourceNames.toArray(new String[mapSourceNames.size()]));
        adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        mapSourceSelector.setAdapter(adapter);
        int mapsource = Settings.getMapSource();
        mapSourceSelector.setSelection(MapProviderFactory.getSourceOrdinalFromId(mapsource));
        mapSourceSelector.setOnItemSelectedListener(new cgeoChangeMapSource());

        initMapfileEdittext(false);

        Button selectMapfile = (Button) findViewById(R.id.select_mapfile);
        selectMapfile.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Intent selectIntent = new Intent(SettingsActivity.this, cgSelectMapfile.class);
                startActivityForResult(selectIntent, SELECT_MAPFILE_REQUEST);
            }
        });

        final CheckBox trailButton = (CheckBox) findViewById(R.id.trail);
        trailButton.setChecked(Settings.isMapTrail());
        trailButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setMapTrail(trailButton.isChecked());
            }
        });

        // Default navigation tool settings
        Spinner defaultNavigationToolSelector = (Spinner) findViewById(R.id.default_navigation_tool);
        final List<NavigationAppsEnum> apps = NavigationAppFactory.getInstalledDefaultNavigationApps();
        ArrayAdapter<NavigationAppsEnum> naviAdapter = new ArrayAdapter<NavigationAppsEnum>(this, android.R.layout.simple_spinner_item, apps) {
            @Override
            public View getView(int position, View convertView, ViewGroup parent) {
                TextView textView = (TextView) super.getView(position, convertView, parent);
                textView.setText(getItem(position).app.getName());
                return textView;
            }
            @Override
            public View getDropDownView(int position, View convertView, ViewGroup parent) {
                TextView textView = (TextView) super.getDropDownView(position, convertView, parent);
                textView.setText(getItem(position).app.getName());
                return textView;
            }
        };
        naviAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        defaultNavigationToolSelector.setAdapter(naviAdapter);
        int defaultNavigationTool = Settings.getDefaultNavigationTool();
        int ordinal = 0;
        for (int i = 0; i < apps.size(); i++) {
            if (apps.get(i).id == defaultNavigationTool) {
                ordinal = i;
                break;
            }
        }
        defaultNavigationToolSelector.setSelection(ordinal);
        defaultNavigationToolSelector.setOnItemSelectedListener(new OnItemSelectedListener() {
            @Override
            public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
                NavigationAppsEnum item = (NavigationAppsEnum) parent.getItemAtPosition(position);
                if (item != null) {
                    Settings.setDefaultNavigationTool(item.id);
                }
            }

            @Override
            public void onNothingSelected(AdapterView<?> arg0) {
                // noop
            }
        });

        // 2nd Default navigation tool settings
        Spinner defaultNavigationTool2Selector = (Spinner) findViewById(R.id.default_navigation_tool_2);
        //        final List<NavigationAppsEnum> apps = NavigationAppFactory.getInstalledNavigationApps(this);
        ArrayAdapter<NavigationAppsEnum> navi2Adapter = new ArrayAdapter<NavigationAppsEnum>(this, android.R.layout.simple_spinner_item, apps) {
            @Override
            public View getView(int position, View convertView, ViewGroup parent) {
                TextView textView = (TextView) super.getView(position, convertView, parent);
                textView.setText(getItem(position).app.getName());
                return textView;
            }

            @Override
            public View getDropDownView(int position, View convertView, ViewGroup parent) {
                TextView textView = (TextView) super.getDropDownView(position, convertView, parent);
                textView.setText(getItem(position).app.getName());
                return textView;
            }
        };
        navi2Adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        defaultNavigationTool2Selector.setAdapter(navi2Adapter);
        int defaultNavigationTool2 = Settings.getDefaultNavigationTool2();
        int ordinal2 = 0;
        for (int i = 0; i < apps.size(); i++) {
            if (apps.get(i).id == defaultNavigationTool2) {
                ordinal2 = i;
                break;
            }
        }
        defaultNavigationTool2Selector.setSelection(ordinal2);
        defaultNavigationTool2Selector.setOnItemSelectedListener(new OnItemSelectedListener() {
            @Override
            public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
                NavigationAppsEnum item = (NavigationAppsEnum) parent.getItemAtPosition(position);
                if (item != null) {
                    Settings.setDefaultNavigationTool2(item.id);
                }
            }

            @Override
            public void onNothingSelected(AdapterView<?> arg0) {
                // noop
            }
        });

        refreshBackupLabel();

        // Database location
        refreshDbOnSDCardSetting();

        final CheckBox dbOnSDCardButton = (CheckBox) findViewById(R.id.dbonsdcard);
        dbOnSDCardButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                app.moveDatabase(SettingsActivity.this);
            }
        });

        // Debug settings
        final CheckBox debugButton = (CheckBox) findViewById(R.id.debug);
        debugButton.setChecked(Settings.isDebug());
        debugButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setDebug(!Settings.isDebug());
                debugButton.setChecked(Settings.isDebug());
            }
        });
    }

    private void initMapfileEdittext(boolean setFocus) {
        EditText mfmapFileEdit = (EditText) findViewById(R.id.mapfile);
        mfmapFileEdit.setText(Settings.getMapFile());
        if (setFocus) {
            mfmapFileEdit.requestFocus();
        }
    }

    /**
     * @param view
     *            unused here but needed since this method is referenced from XML layout
     */
    public void backup(View view) {
        // avoid overwriting an existing backup with an empty database (can happen directly after reinstalling the app)
        if (app.getAllStoredCachesCount(true, CacheType.ALL) == 0) {
            helpDialog(res.getString(R.string.init_backup), res.getString(R.string.init_backup_unnecessary));
            return;
        }

        final ProgressDialog dialog = ProgressDialog.show(this, res.getString(R.string.init_backup), res.getString(R.string.init_backup_running), true, false);
        new Thread() {
            @Override
            public void run() {
                final String backupFileName = app.backupDatabase();
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        dialog.dismiss();
                        helpDialog(res.getString(R.string.init_backup_backup),
                                backupFileName != null ? res.getString(R.string.init_backup_success) + "\n" + backupFileName : res.getString(R.string.init_backup_failed));
                        refreshBackupLabel();
                    }
                });
            }
        }.start();
    }

    private void refreshBackupLabel() {
        TextView lastBackup = (TextView) findViewById(R.id.backup_last);
        File lastBackupFile = cgeoapplication.isRestoreFile();
        if (lastBackupFile != null) {
            lastBackup.setText(res.getString(R.string.init_backup_last) + " " + Formatter.formatTime(lastBackupFile.lastModified()) + ", " + Formatter.formatDate(lastBackupFile.lastModified()));
        } else {
            lastBackup.setText(res.getString(R.string.init_backup_last_no));
        }
    }

    private void refreshDbOnSDCardSetting() {
        final CheckBox dbOnSDCardButton = (CheckBox) findViewById(R.id.dbonsdcard);
        dbOnSDCardButton.setChecked(Settings.isDbOnSDCard());
    }

    /**
     * @param view
     *            unused here but needed since this method is referenced from XML layout
     */
    public void restore(View view) {
        app.restoreDatabase(this);
    }

    public boolean saveValues() {
        String usernameNew = StringUtils.trimToEmpty(((EditText) findViewById(R.id.username)).getText().toString());
        String passwordNew = StringUtils.trimToEmpty(((EditText) findViewById(R.id.password)).getText().toString());
        String passvoteNew = StringUtils.trimToEmpty(((EditText) findViewById(R.id.passvote)).getText().toString());
        // don't trim signature, user may want to have whitespace at the beginning
        String signatureNew = ((EditText) findViewById(R.id.signature)).getText().toString();
        String altitudeNew = StringUtils.trimToNull(((EditText) findViewById(R.id.altitude)).getText().toString());
        String mfmapFileNew = StringUtils.trimToEmpty(((EditText) findViewById(R.id.mapfile)).getText().toString());

        int altitudeNewInt = 0;
        if (altitudeNew != null) {
            try {
                altitudeNewInt = Integer.parseInt(altitudeNew);
            } catch (NumberFormatException e) {
                altitudeNewInt = 0;
            }
        }

        final boolean status1 = Settings.setLogin(usernameNew, passwordNew);
        final boolean status2 = Settings.setGCvoteLogin(passvoteNew);
        final boolean status3 = Settings.setSignature(signatureNew);
        final boolean status4 = Settings.setAltCorrection(altitudeNewInt);
        final boolean status5 = Settings.setMapFile(mfmapFileNew);
        TextView field = (TextView) findViewById(R.id.showwaypointsthreshold);
        Settings.setShowWaypointsThreshold(safeParse(field, 5));

        return status1 && status2 && status3 && status4 && status5;
    }

    /**
     * Returns the Int Value in the Field
     *
     * @param field
     *            the field to retrieve the integer value from
     * @param defaultValue
     *            the default value
     * @return either the field content or the default value
     */

    static private int safeParse(final TextView field, int defaultValue) {
        try {
            return Integer.parseInt(field.getText().toString());
        } catch (NumberFormatException e) {
            return defaultValue;
        }
    }

    private static class cgeoChangeMapSource implements OnItemSelectedListener {

        @Override
        public void onItemSelected(AdapterView<?> arg0, View arg1, int arg2,
                long arg3) {
            Settings.setMapSource(MapProviderFactory.getSourceIdFromOrdinal(arg2));
        }

        @Override
        public void onNothingSelected(AdapterView<?> arg0) {
            arg0.setSelection(MapProviderFactory.getSourceIdFromOrdinal(Settings.getMapSource()));
        }
    }

    private class logIn implements View.OnClickListener {

        @Override
        public void onClick(View arg0) {
            final String username = ((EditText) findViewById(R.id.username)).getText().toString();
            final String password = ((EditText) findViewById(R.id.password)).getText().toString();

            if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
                showToast(res.getString(R.string.err_missing_auth));
                return;
            }

            loginDialog = ProgressDialog.show(SettingsActivity.this, res.getString(R.string.init_login_popup), res.getString(R.string.init_login_popup_working), true);
            loginDialog.setCancelable(false);

            Settings.setLogin(username, password);
            Cookies.clearCookies();

            (new Thread() {

                @Override
                public void run() {
                    final StatusCode loginResult = Login.login();
                    Object payload = loginResult;
                    if (loginResult == StatusCode.NO_ERROR) {
                        Login.detectGcCustomDate();
                        payload = Login.downloadAvatarAndGetMemberStatus();
                    }
                    logInHandler.obtainMessage(0, payload).sendToTarget();
                }
            }).start();
        }
    }

    private class webAuth implements View.OnClickListener {

        @Override
        public void onClick(View arg0) {
            final String deviceName = ((EditText) findViewById(R.id.webDeviceName)).getText().toString();
            final String deviceCode = Settings.getWebDeviceCode();

            if (StringUtils.isBlank(deviceName)) {
                showToast(res.getString(R.string.err_missing_device_name));
                return;
            }

            webDialog = ProgressDialog.show(SettingsActivity.this, res.getString(R.string.init_sendToCgeo), res.getString(R.string.init_sendToCgeo_registering), true);
            webDialog.setCancelable(false);

            (new Thread() {

                @Override
                public void run() {
                    int pin = 0;

                    final String nam = StringUtils.defaultString(deviceName);
                    final String cod = StringUtils.defaultString(deviceCode);

                    final Parameters params = new Parameters("name", nam, "code", cod);
                    HttpResponse response = Network.getRequest("http://send2.cgeo.org/auth.html", params);

                    if (response != null && response.getStatusLine().getStatusCode() == 200)
                    {
                        //response was OK
                        String[] strings = Network.getResponseData(response).split(",");
                        try {
                            pin = Integer.parseInt(strings[1].trim());
                        } catch (Exception e) {
                            Log.e("webDialog: " + e.toString());
                        }
                        String code = strings[0];
                        Settings.setWebNameCode(nam, code);
                    }

                    webAuthHandler.sendEmptyMessage(pin);
                }
            }).start();
        }
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);

        if (requestCode == SELECT_MAPFILE_REQUEST) {
            if (resultCode == RESULT_OK) {
                if (data.hasExtra("mapfile")) {
                    Settings.setMapFile(data.getStringExtra("mapfile"));
                    if (!Settings.isValidMapFile(Settings.getMapFile())) {
                        showToast(res.getString(R.string.warn_invalid_mapfile));
                    }
                }
            }
            initMapfileEdittext(true);
        }
    }

    public static void startActivity(Context fromActivity) {
        final Intent initIntent = new Intent(fromActivity, SettingsActivity.class);
        fromActivity.startActivity(initIntent);
    }

}
!@#$%
20190526_235855,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_a09016
package cgeo.geocaching;

import cgeo.geocaching.activity.AbstractActivity;
import cgeo.geocaching.apps.cache.navi.NavigationAppFactory;
import cgeo.geocaching.apps.cache.navi.NavigationAppFactory.NavigationAppsEnum;
import cgeo.geocaching.compatibility.Compatibility;
import cgeo.geocaching.connector.gc.Login;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.StatusCode;
import cgeo.geocaching.maps.MapProviderFactory;
import cgeo.geocaching.maps.interfaces.MapSource;
import cgeo.geocaching.network.Cookies;
import cgeo.geocaching.network.Network;
import cgeo.geocaching.network.Parameters;
import cgeo.geocaching.twitter.TwitterAuthorizationActivity;
import cgeo.geocaching.ui.Formatter;
import cgeo.geocaching.utils.Log;
import cgeo.geocaching.utils.LogTemplateProvider;
import cgeo.geocaching.utils.LogTemplateProvider.LogTemplate;

import ch.boye.httpclientandroidlib.HttpResponse;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;

import android.app.ProgressDialog;
import android.content.Context;
import android.content.Intent;
import android.content.res.Configuration;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.view.ContextMenu;
import android.view.ContextMenu.ContextMenuInfo;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemSelectedListener;
import android.widget.ArrayAdapter;
import android.widget.Button;
import android.widget.CheckBox;
import android.widget.EditText;
import android.widget.Spinner;
import android.widget.TextView;

import java.io.File;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

public class SettingsActivity extends AbstractActivity {

    private final static int SELECT_MAPFILE_REQUEST = 1;

    private ProgressDialog loginDialog = null;
    private ProgressDialog webDialog = null;
    private Handler logInHandler = new Handler() {

        @Override
        public void handleMessage(Message msg) {
            try {
                if (loginDialog != null && loginDialog.isShowing()) {
                    loginDialog.dismiss();
                }

                if (msg.obj == null || (msg.obj instanceof Drawable)) {
                    helpDialog(res.getString(R.string.init_login_popup), res.getString(R.string.init_login_popup_ok),
                            (Drawable) msg.obj);
                } else {
                    helpDialog(res.getString(R.string.init_login_popup),
                            res.getString(R.string.init_login_popup_failed_reason) + " " +
                                    ((StatusCode) msg.obj).getErrorString(res) + ".");
                }
            } catch (Exception e) {
                showToast(res.getString(R.string.err_login_failed));

                Log.e("SettingsActivity.logInHandler: " + e.toString());
            }

            if (loginDialog != null && loginDialog.isShowing()) {
                loginDialog.dismiss();
            }

            init();
        }
    };

    private Handler webAuthHandler = new Handler() {

        @Override
        public void handleMessage(Message msg) {
            try {
                if (webDialog != null && webDialog.isShowing()) {
                    webDialog.dismiss();
                }

                if (msg.what > 0) {
                    helpDialog(res.getString(R.string.init_sendToCgeo), res.getString(R.string.init_sendToCgeo_register_ok).replace("####", String.valueOf(msg.what)));
                } else {
                    helpDialog(res.getString(R.string.init_sendToCgeo), res.getString(R.string.init_sendToCgeo_register_fail));
                }
            } catch (Exception e) {
                showToast(res.getString(R.string.init_sendToCgeo_register_fail));

                Log.e("SettingsActivity.webHandler: " + e.toString());
            }

            if (webDialog != null && webDialog.isShowing()) {
                webDialog.dismiss();
            }

            init();
        }
    };
    protected boolean enableTemplatesMenu = false;

    public SettingsActivity() {
        super("c:geo-configuration");
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        // init

        setTheme();
        setContentView(R.layout.init);
        setTitle(res.getString(R.string.settings));

        init();
    }

    @Override
    public void onResume() {
        super.onResume();

    }

    @Override
    public void onConfigurationChanged(Configuration newConfig) {
        super.onConfigurationChanged(newConfig);

        init();
    }

    @Override
    public void onPause() {
        saveValues();
        super.onPause();
    }

    @Override
    public void onStop() {
        saveValues();
        Compatibility.dataChanged(getPackageName());
        super.onStop();
    }

    @Override
    public void onDestroy() {
        saveValues();

        super.onDestroy();
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        menu.add(0, 0, 0, res.getString(R.string.init_clear)).setIcon(R.drawable.ic_menu_delete);

        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        if (item.getItemId() == 0) {
            boolean status;

            ((EditText) findViewById(R.id.username)).setText("");
            ((EditText) findViewById(R.id.password)).setText("");
            ((EditText) findViewById(R.id.passvote)).setText("");

            status = saveValues();
            if (status) {
                showToast(res.getString(R.string.init_cleared));
            } else {
                showToast(res.getString(R.string.err_init_cleared));
            }

            finish();
        }

        return false;
    }

    @Override
    public void onCreateContextMenu(ContextMenu menu, View v,
            ContextMenuInfo menuInfo) {
        if (enableTemplatesMenu) {
            menu.setHeaderTitle(R.string.init_signature_template_button);
            for (LogTemplate template : LogTemplateProvider.getTemplates()) {
                menu.add(0, template.getItemId(), 0, template.getResourceId());
            }
        }
    }

    @Override
    public boolean onContextItemSelected(MenuItem item) {
        LogTemplate template = LogTemplateProvider.getTemplate(item.getItemId());
        if (template != null) {
            return insertSignatureTemplate(template);
        }
        return super.onContextItemSelected(item);
    }

    private boolean insertSignatureTemplate(final LogTemplate template) {
        EditText sig = (EditText) findViewById(R.id.signature);
        String insertText = "[" + template.getTemplateString() + "]";
        insertAtPosition(sig, insertText, true);
        return true;
    }

    public void init() {

        // geocaching.com settings
        final ImmutablePair<String, String> login = Settings.getLogin();
        if (login != null) {
            ((EditText) findViewById(R.id.username)).setText(login.left);
            ((EditText) findViewById(R.id.password)).setText(login.right);
        }

        Button logMeIn = (Button) findViewById(R.id.log_me_in);
        logMeIn.setOnClickListener(new logIn());

        TextView legalNote = (TextView) findViewById(R.id.legal_note);
        legalNote.setClickable(true);
        legalNote.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View arg0) {
                startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse("http://www.geocaching.com/about/termsofuse.aspx")));
            }
        });

        // gcvote settings
        final ImmutablePair<String, String> gcvoteLogin = Settings.getGCvoteLogin();
        if (null != gcvoteLogin && null != gcvoteLogin.right) {
            ((EditText) findViewById(R.id.passvote)).setText(gcvoteLogin.right);
        }

        // go4cache settings
        TextView go4cache = (TextView) findViewById(R.id.about_go4cache);
        go4cache.setClickable(true);
        go4cache.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View arg0) {
                startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse("http://go4cache.com/")));
            }
        });

        final CheckBox publicButton = (CheckBox) findViewById(R.id.publicloc);
        publicButton.setChecked(Settings.isPublicLoc());
        publicButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setPublicLoc(publicButton.isChecked());
            }
        });

        // Twitter settings
        Button authorizeTwitter = (Button) findViewById(R.id.authorize_twitter);
        authorizeTwitter.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View arg0) {
                Intent authIntent = new Intent(SettingsActivity.this, TwitterAuthorizationActivity.class);
                startActivity(authIntent);
            }
        });

        final CheckBox twitterButton = (CheckBox) findViewById(R.id.twitter_option);
        twitterButton.setChecked(Settings.isUseTwitter() && Settings.isTwitterLoginValid());
        twitterButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setUseTwitter(twitterButton.isChecked());
                if (Settings.isUseTwitter() && !Settings.isTwitterLoginValid()) {
                    Intent authIntent = new Intent(SettingsActivity.this, TwitterAuthorizationActivity.class);
                    startActivity(authIntent);
                }

                twitterButton.setChecked(Settings.isUseTwitter());
            }
        });

        // Signature settings
        EditText sigEdit = (EditText) findViewById(R.id.signature);
        if (sigEdit.getText().length() == 0) {
            sigEdit.setText(Settings.getSignature());
        }
        Button sigBtn = (Button) findViewById(R.id.signature_help);
        sigBtn.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                helpDialog(res.getString(R.string.init_signature_help_title), res.getString(R.string.init_signature_help_text));
            }
        });
        Button templates = (Button) findViewById(R.id.signature_template);
        registerForContextMenu(templates);
        templates.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                enableTemplatesMenu = true;
                openContextMenu(v);
                enableTemplatesMenu = false;
            }
        });
        final CheckBox autoinsertButton = (CheckBox) findViewById(R.id.sigautoinsert);
        autoinsertButton.setChecked(Settings.isAutoInsertSignature());
        autoinsertButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setAutoInsertSignature(autoinsertButton.isChecked());
            }
        });

        // Cache details
        final CheckBox autoloadButton = (CheckBox) findViewById(R.id.autoload);
        autoloadButton.setChecked(Settings.isAutoLoadDescription());
        autoloadButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setAutoLoadDesc(autoloadButton.isChecked());
            }
        });

        final CheckBox ratingWantedButton = (CheckBox) findViewById(R.id.ratingwanted);
        ratingWantedButton.setChecked(Settings.isRatingWanted());
        ratingWantedButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setRatingWanted(ratingWantedButton.isChecked());
            }
        });

        final CheckBox elevationWantedButton = (CheckBox) findViewById(R.id.elevationwanted);
        elevationWantedButton.setChecked(Settings.isElevationWanted());
        elevationWantedButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setElevationWanted(elevationWantedButton.isChecked());
            }
        });

        final CheckBox friendLogsWantedButton = (CheckBox) findViewById(R.id.friendlogswanted);
        friendLogsWantedButton.setChecked(Settings.isFriendLogsWanted());
        friendLogsWantedButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setFriendLogsWanted(friendLogsWantedButton.isChecked());
            }
        });

        final CheckBox openLastDetailsPageButton = (CheckBox) findViewById(R.id.openlastdetailspage);
        openLastDetailsPageButton.setChecked(Settings.isOpenLastDetailsPage());
        openLastDetailsPageButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setOpenLastDetailsPage(openLastDetailsPageButton.isChecked());
            }
        });

        // Other settings
        final CheckBox skinButton = (CheckBox) findViewById(R.id.skin);
        skinButton.setChecked(Settings.isLightSkin());
        skinButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setLightSkin(skinButton.isChecked());
            }
        });

        final CheckBox addressButton = (CheckBox) findViewById(R.id.address);
        addressButton.setChecked(Settings.isShowAddress());
        addressButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setShowAddress(addressButton.isChecked());
            }
        });

        final CheckBox captchaButton = (CheckBox) findViewById(R.id.captcha);
        captchaButton.setEnabled(!Settings.isPremiumMember());
        captchaButton.setChecked(Settings.isShowCaptcha());
        captchaButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setShowCaptcha(captchaButton.isChecked());
            }
        });

        final CheckBox dirImgButton = (CheckBox) findViewById(R.id.loaddirectionimg);
        dirImgButton.setEnabled(!Settings.isPremiumMember());
        dirImgButton.setChecked(Settings.getLoadDirImg());
        dirImgButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setLoadDirImg(!Settings.getLoadDirImg());
                dirImgButton.setChecked(Settings.getLoadDirImg());
            }
        });

        final CheckBox useEnglishButton = (CheckBox) findViewById(R.id.useenglish);
        useEnglishButton.setChecked(Settings.isUseEnglish());
        useEnglishButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setUseEnglish(useEnglishButton.isChecked());
            }
        });

        final CheckBox excludeButton = (CheckBox) findViewById(R.id.exclude);
        excludeButton.setChecked(Settings.isExcludeMyCaches());
        excludeButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setExcludeMine(excludeButton.isChecked());
            }
        });

        final CheckBox disabledButton = (CheckBox) findViewById(R.id.disabled);
        disabledButton.setChecked(Settings.isExcludeDisabledCaches());
        disabledButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setExcludeDisabledCaches(disabledButton.isChecked());
            }
        });

        TextView showWaypointsThreshold = (TextView) findViewById(R.id.showwaypointsthreshold);
        showWaypointsThreshold.setText(String.valueOf(Settings.getWayPointsThreshold()));

        final CheckBox autovisitButton = (CheckBox) findViewById(R.id.trackautovisit);
        autovisitButton.setChecked(Settings.isTrackableAutoVisit());
        autovisitButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setTrackableAutoVisit(autovisitButton.isChecked());
            }
        });

        final CheckBox offlineButton = (CheckBox) findViewById(R.id.offline);
        offlineButton.setChecked(Settings.isStoreOfflineMaps());
        offlineButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setStoreOfflineMaps(offlineButton.isChecked());
            }
        });

        final CheckBox offlineWpButton = (CheckBox) findViewById(R.id.offline_wp);
        offlineWpButton.setChecked(Settings.isStoreOfflineWpMaps());
        offlineWpButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setStoreOfflineWpMaps(offlineWpButton.isChecked());
            }
        });

        final CheckBox saveLogImgButton = (CheckBox) findViewById(R.id.save_log_img);
        saveLogImgButton.setChecked(Settings.isStoreLogImages());
        saveLogImgButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setStoreLogImages(saveLogImgButton.isChecked());
            }
        });

        final CheckBox livelistButton = (CheckBox) findViewById(R.id.livelist);
        livelistButton.setChecked(Settings.isLiveList());
        livelistButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setLiveList(livelistButton.isChecked());
            }
        });

        final CheckBox unitsButton = (CheckBox) findViewById(R.id.units);
        unitsButton.setChecked(!Settings.isUseMetricUnits());
        unitsButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setUseMetricUnits(!unitsButton.isChecked());
            }
        });

        final CheckBox gnavButton = (CheckBox) findViewById(R.id.gnav);
        gnavButton.setChecked(Settings.isUseGoogleNavigation());
        gnavButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setUseGoogleNavigation(gnavButton.isChecked());
            }
        });

        final CheckBox logOffline = (CheckBox) findViewById(R.id.log_offline);
        logOffline.setChecked(Settings.getLogOffline());
        logOffline.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setLogOffline(!Settings.getLogOffline());
                logOffline.setChecked(Settings.getLogOffline());
            }
        });

        // Altitude settings
        EditText altitudeEdit = (EditText) findViewById(R.id.altitude);
        altitudeEdit.setText(String.valueOf(Settings.getAltCorrection()));

        //Send2cgeo settings
        String webDeviceName = Settings.getWebDeviceName();

        if (StringUtils.isNotBlank(webDeviceName)) {
            ((EditText) findViewById(R.id.webDeviceName)).setText(webDeviceName);
        } else {
            String s = android.os.Build.MODEL;
            ((EditText) findViewById(R.id.webDeviceName)).setText(s);
        }

        Button webAuth = (Button) findViewById(R.id.sendToCgeo_register);
        webAuth.setOnClickListener(new webAuth());

        // Map source settings
        Collection<String> mapSourceNames = new ArrayList<String>();
        for (MapSource mapSource : MapProviderFactory.getMapSources().values()) {
            mapSourceNames.add(mapSource.getName());
        }
        Spinner mapSourceSelector = (Spinner) findViewById(R.id.mapsource);
        ArrayAdapter<CharSequence> adapter = new ArrayAdapter<CharSequence>(this, android.R.layout.simple_spinner_item, mapSourceNames.toArray(new String[mapSourceNames.size()]));
        adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        mapSourceSelector.setAdapter(adapter);
        int mapsource = Settings.getMapSource();
        mapSourceSelector.setSelection(MapProviderFactory.getSourceOrdinalFromId(mapsource));
        mapSourceSelector.setOnItemSelectedListener(new cgeoChangeMapSource());

        initMapfileEdittext(false);

        Button selectMapfile = (Button) findViewById(R.id.select_mapfile);
        selectMapfile.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Intent selectIntent = new Intent(SettingsActivity.this, cgSelectMapfile.class);
                startActivityForResult(selectIntent, SELECT_MAPFILE_REQUEST);
            }
        });

        final CheckBox trailButton = (CheckBox) findViewById(R.id.trail);
        trailButton.setChecked(Settings.isMapTrail());
        trailButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setMapTrail(trailButton.isChecked());
            }
        });

        // Default navigation tool settings
        Spinner defaultNavigationToolSelector = (Spinner) findViewById(R.id.default_navigation_tool);
        final List<NavigationAppsEnum> apps = NavigationAppFactory.getInstalledDefaultNavigationApps();
        ArrayAdapter<NavigationAppsEnum> naviAdapter = new ArrayAdapter<NavigationAppsEnum>(this, android.R.layout.simple_spinner_item, apps) {
            @Override
            public View getView(int position, View convertView, ViewGroup parent) {
                TextView textView = (TextView) super.getView(position, convertView, parent);
                textView.setText(getItem(position).app.getName());
                return textView;
            }
            @Override
            public View getDropDownView(int position, View convertView, ViewGroup parent) {
                TextView textView = (TextView) super.getDropDownView(position, convertView, parent);
                textView.setText(getItem(position).app.getName());
                return textView;
            }
        };
        naviAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        defaultNavigationToolSelector.setAdapter(naviAdapter);
        int defaultNavigationTool = Settings.getDefaultNavigationTool();
        int ordinal = 0;
        for (int i = 0; i < apps.size(); i++) {
            if (apps.get(i).id == defaultNavigationTool) {
                ordinal = i;
                break;
            }
        }
        defaultNavigationToolSelector.setSelection(ordinal);
        defaultNavigationToolSelector.setOnItemSelectedListener(new OnItemSelectedListener() {
            @Override
            public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
                NavigationAppsEnum item = (NavigationAppsEnum) parent.getItemAtPosition(position);
                if (item != null) {
                    Settings.setDefaultNavigationTool(item.id);
                }
            }

            @Override
            public void onNothingSelected(AdapterView<?> arg0) {
                // noop
            }
        });

        // 2nd Default navigation tool settings
        Spinner defaultNavigationTool2Selector = (Spinner) findViewById(R.id.default_navigation_tool_2);
        //        final List<NavigationAppsEnum> apps = NavigationAppFactory.getInstalledNavigationApps(this);
        ArrayAdapter<NavigationAppsEnum> navi2Adapter = new ArrayAdapter<NavigationAppsEnum>(this, android.R.layout.simple_spinner_item, apps) {
            @Override
            public View getView(int position, View convertView, ViewGroup parent) {
                TextView textView = (TextView) super.getView(position, convertView, parent);
                textView.setText(getItem(position).app.getName());
                return textView;
            }

            @Override
            public View getDropDownView(int position, View convertView, ViewGroup parent) {
                TextView textView = (TextView) super.getDropDownView(position, convertView, parent);
                textView.setText(getItem(position).app.getName());
                return textView;
            }
        };
        navi2Adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        defaultNavigationTool2Selector.setAdapter(navi2Adapter);
        int defaultNavigationTool2 = Settings.getDefaultNavigationTool2();
        int ordinal2 = 0;
        for (int i = 0; i < apps.size(); i++) {
            if (apps.get(i).id == defaultNavigationTool2) {
                ordinal2 = i;
                break;
            }
        }
        defaultNavigationTool2Selector.setSelection(ordinal2);
        defaultNavigationTool2Selector.setOnItemSelectedListener(new OnItemSelectedListener() {
            @Override
            public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
                NavigationAppsEnum item = (NavigationAppsEnum) parent.getItemAtPosition(position);
                if (item != null) {
                    Settings.setDefaultNavigationTool2(item.id);
                }
            }

            @Override
            public void onNothingSelected(AdapterView<?> arg0) {
                // noop
            }
        });

        refreshBackupLabel();

        // Database location
        refreshDbOnSDCardSetting();

        final CheckBox dbOnSDCardButton = (CheckBox) findViewById(R.id.dbonsdcard);
        dbOnSDCardButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                app.moveDatabase(SettingsActivity.this);
            }
        });

        // Debug settings
        final CheckBox debugButton = (CheckBox) findViewById(R.id.debug);
        debugButton.setChecked(Settings.isDebug());
        debugButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setDebug(!Settings.isDebug());
                debugButton.setChecked(Settings.isDebug());
            }
        });
    }

    private void initMapfileEdittext(boolean setFocus) {
        EditText mfmapFileEdit = (EditText) findViewById(R.id.mapfile);
        mfmapFileEdit.setText(Settings.getMapFile());
        if (setFocus) {
            mfmapFileEdit.requestFocus();
        }
    }

    /**
     * @param view
     *            unused here but needed since this method is referenced from XML layout
     */
    public void backup(View view) {
        // avoid overwriting an existing backup with an empty database (can happen directly after reinstalling the app)
        if (app.getAllStoredCachesCount(true, CacheType.ALL) == 0) {
            helpDialog(res.getString(R.string.init_backup), res.getString(R.string.init_backup_unnecessary));
            return;
        }

        final ProgressDialog dialog = ProgressDialog.show(this, res.getString(R.string.init_backup), res.getString(R.string.init_backup_running), true, false);
        new Thread() {
            @Override
            public void run() {
                final String backupFileName = app.backupDatabase();
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        dialog.dismiss();
                        helpDialog(res.getString(R.string.init_backup_backup),
                                backupFileName != null ? res.getString(R.string.init_backup_success) + "\n" + backupFileName : res.getString(R.string.init_backup_failed));
                        refreshBackupLabel();
                    }
                });
            }
        }.start();
    }

    private void refreshBackupLabel() {
        TextView lastBackup = (TextView) findViewById(R.id.backup_last);
        File lastBackupFile = cgeoapplication.isRestoreFile();
        if (lastBackupFile != null) {
            lastBackup.setText(res.getString(R.string.init_backup_last) + " " + Formatter.formatTime(lastBackupFile.lastModified()) + ", " + Formatter.formatDate(lastBackupFile.lastModified()));
        } else {
            lastBackup.setText(res.getString(R.string.init_backup_last_no));
        }
    }

    private void refreshDbOnSDCardSetting() {
        final CheckBox dbOnSDCardButton = (CheckBox) findViewById(R.id.dbonsdcard);
        dbOnSDCardButton.setChecked(Settings.isDbOnSDCard());
    }

    /**
     * @param view
     *            unused here but needed since this method is referenced from XML layout
     */
    public void restore(View view) {
        app.restoreDatabase(this);
    }

    public boolean saveValues() {
        String usernameNew = StringUtils.trimToEmpty(((EditText) findViewById(R.id.username)).getText().toString());
        String passwordNew = StringUtils.trimToEmpty(((EditText) findViewById(R.id.password)).getText().toString());
        String passvoteNew = StringUtils.trimToEmpty(((EditText) findViewById(R.id.passvote)).getText().toString());
        // don't trim signature, user may want to have whitespace at the beginning
        String signatureNew = ((EditText) findViewById(R.id.signature)).getText().toString();
        String altitudeNew = StringUtils.trimToNull(((EditText) findViewById(R.id.altitude)).getText().toString());
        String mfmapFileNew = StringUtils.trimToEmpty(((EditText) findViewById(R.id.mapfile)).getText().toString());

        int altitudeNewInt = 0;
        if (altitudeNew != null) {
            try {
                altitudeNewInt = Integer.parseInt(altitudeNew);
            } catch (NumberFormatException e) {
                altitudeNewInt = 0;
            }
        }

        final boolean status1 = Settings.setLogin(usernameNew, passwordNew);
        final boolean status2 = Settings.setGCvoteLogin(passvoteNew);
        final boolean status3 = Settings.setSignature(signatureNew);
        final boolean status4 = Settings.setAltCorrection(altitudeNewInt);
        final boolean status5 = Settings.setMapFile(mfmapFileNew);
        TextView field = (TextView) findViewById(R.id.showwaypointsthreshold);
        Settings.setShowWaypointsThreshold(safeParse(field, 5));

        return status1 && status2 && status3 && status4 && status5;
    }

    /**
     * Returns the Int Value in the Field
     *
     * @param field
     *            the field to retrieve the integer value from
     * @param defaultValue
     *            the default value
     * @return either the field content or the default value
     */

    static private int safeParse(final TextView field, int defaultValue) {
        try {
            return Integer.parseInt(field.getText().toString());
        } catch (NumberFormatException e) {
            return defaultValue;
        }
    }

    private static class cgeoChangeMapSource implements OnItemSelectedListener {

        @Override
        public void onItemSelected(AdapterView<?> arg0, View arg1, int arg2,
                long arg3) {
            Settings.setMapSource(MapProviderFactory.getSourceIdFromOrdinal(arg2));
        }

        @Override
        public void onNothingSelected(AdapterView<?> arg0) {
            arg0.setSelection(MapProviderFactory.getSourceIdFromOrdinal(Settings.getMapSource()));
        }
    }

    private class logIn implements View.OnClickListener {

        @Override
        public void onClick(View arg0) {
            final String username = ((EditText) findViewById(R.id.username)).getText().toString();
            final String password = ((EditText) findViewById(R.id.password)).getText().toString();

            if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
                showToast(res.getString(R.string.err_missing_auth));
                return;
            }

            loginDialog = ProgressDialog.show(SettingsActivity.this, res.getString(R.string.init_login_popup), res.getString(R.string.init_login_popup_working), true);
            loginDialog.setCancelable(false);

            Settings.setLogin(username, password);
            Cookies.clearCookies();

            (new Thread() {

                @Override
                public void run() {
                    final StatusCode loginResult = Login.login();
                    Object payload = loginResult;
                    if (loginResult == StatusCode.NO_ERROR) {
                        Login.detectGcCustomDate();
                        payload = Login.downloadAvatarAndGetMemberStatus();
                    }
                    logInHandler.obtainMessage(0, payload).sendToTarget();
                }
            }).start();
        }
    }

    private class webAuth implements View.OnClickListener {

        @Override
        public void onClick(View arg0) {
            final String deviceName = ((EditText) findViewById(R.id.webDeviceName)).getText().toString();
            final String deviceCode = Settings.getWebDeviceCode();

            if (StringUtils.isBlank(deviceName)) {
                showToast(res.getString(R.string.err_missing_device_name));
                return;
            }

            webDialog = ProgressDialog.show(SettingsActivity.this, res.getString(R.string.init_sendToCgeo), res.getString(R.string.init_sendToCgeo_registering), true);
            webDialog.setCancelable(false);

            (new Thread() {

                @Override
                public void run() {
                    int pin = 0;

                    final String nam = StringUtils.defaultString(deviceName);
                    final String cod = StringUtils.defaultString(deviceCode);

                    final Parameters params = new Parameters("name", nam, "code", cod);
                    HttpResponse response = Network.getRequest("http://send2.cgeo.org/auth.html", params);

                    if (response != null && response.getStatusLine().getStatusCode() == 200)
                    {
                        //response was OK
                        String[] strings = Network.getResponseData(response).split(",");
                        try {
                            pin = Integer.parseInt(strings[1].trim());
                        } catch (Exception e) {
                            Log.e("webDialog: " + e.toString());
                        }
                        String code = strings[0];
                        Settings.setWebNameCode(nam, code);
                    }

                    webAuthHandler.sendEmptyMessage(pin);
                }
            }).start();
        }
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);

        if (requestCode == SELECT_MAPFILE_REQUEST) {
            if (resultCode == RESULT_OK) {
                if (data.hasExtra("mapfile")) {
                    Settings.setMapFile(data.getStringExtra("mapfile"));
                    if (!Settings.isValidMapFile(Settings.getMapFile())) {
                        showToast(res.getString(R.string.warn_invalid_mapfile));
                    }
                }
            }
            initMapfileEdittext(true);
        }
    }

    public static void startActivity(Context fromActivity) {
        final Intent initIntent = new Intent(fromActivity, SettingsActivity.class);
        fromActivity.startActivity(initIntent);
    }

}
!@#$%
20190526_235855,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_c09016
package cgeo.geocaching;

import cgeo.geocaching.activity.AbstractActivity;
import cgeo.geocaching.apps.cache.navi.NavigationAppFactory;
import cgeo.geocaching.apps.cache.navi.NavigationAppFactory.NavigationAppsEnum;
import cgeo.geocaching.compatibility.Compatibility;
import cgeo.geocaching.connector.gc.Login;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.StatusCode;
import cgeo.geocaching.maps.MapProviderFactory;
import cgeo.geocaching.maps.interfaces.MapSource;
import cgeo.geocaching.network.Cookies;
import cgeo.geocaching.network.Network;
import cgeo.geocaching.network.Parameters;
import cgeo.geocaching.twitter.TwitterAuthorizationActivity;
import cgeo.geocaching.ui.Formatter;
import cgeo.geocaching.utils.Log;
import cgeo.geocaching.utils.LogTemplateProvider;
import cgeo.geocaching.utils.LogTemplateProvider.LogTemplate;

import ch.boye.httpclientandroidlib.HttpResponse;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;

import android.app.ProgressDialog;
import android.content.Context;
import android.content.Intent;
import android.content.res.Configuration;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.view.ContextMenu;
import android.view.ContextMenu.ContextMenuInfo;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemSelectedListener;
import android.widget.ArrayAdapter;
import android.widget.Button;
import android.widget.CheckBox;
import android.widget.EditText;
import android.widget.Spinner;
import android.widget.TextView;

import java.io.File;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

public class SettingsActivity extends AbstractActivity {

    private final static int SELECT_MAPFILE_REQUEST = 1;

    private ProgressDialog loginDialog = null;
    private ProgressDialog webDialog = null;
    private Handler logInHandler = new Handler() {

        @Override
        public void handleMessage(Message msg) {
            try {
                if (loginDialog != null && loginDialog.isShowing()) {
                    loginDialog.dismiss();
                }

                if (msg.obj == null || (msg.obj instanceof Drawable)) {
                    helpDialog(res.getString(R.string.init_login_popup), res.getString(R.string.init_login_popup_ok),
                            (Drawable) msg.obj);
                } else {
                    helpDialog(res.getString(R.string.init_login_popup),
                            res.getString(R.string.init_login_popup_failed_reason) + " " +
                                    ((StatusCode) msg.obj).getErrorString(res) + ".");
                }
            } catch (Exception e) {
                showToast(res.getString(R.string.err_login_failed));

                Log.e("SettingsActivity.logInHandler: " + e.toString());
            }

            if (loginDialog != null && loginDialog.isShowing()) {
                loginDialog.dismiss();
            }

            init();
        }
    };

    private Handler webAuthHandler = new Handler() {

        @Override
        public void handleMessage(Message msg) {
            try {
                if (webDialog != null && webDialog.isShowing()) {
                    webDialog.dismiss();
                }

                if (msg.what > 0) {
                    helpDialog(res.getString(R.string.init_sendToCgeo), res.getString(R.string.init_sendToCgeo_register_ok).replace("####", String.valueOf(msg.what)));
                } else {
                    helpDialog(res.getString(R.string.init_sendToCgeo), res.getString(R.string.init_sendToCgeo_register_fail));
                }
            } catch (Exception e) {
                showToast(res.getString(R.string.init_sendToCgeo_register_fail));

                Log.e("SettingsActivity.webHandler: " + e.toString());
            }

            if (webDialog != null && webDialog.isShowing()) {
                webDialog.dismiss();
            }

            init();
        }
    };
    protected boolean enableTemplatesMenu = false;

    public SettingsActivity() {
        super("c:geo-configuration");
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        // init

        setTheme();
        setContentView(R.layout.init);
        setTitle(res.getString(R.string.settings));

        init();
    }

    @Override
    public void onResume() {
        super.onResume();

    }

    @Override
    public void onConfigurationChanged(Configuration newConfig) {
        super.onConfigurationChanged(newConfig);

        init();
    }

    @Override
    public void onPause() {
        saveValues();
        super.onPause();
    }

    @Override
    public void onStop() {
        saveValues();
        Compatibility.dataChanged(getPackageName());
        super.onStop();
    }

    @Override
    public void onDestroy() {
        saveValues();

        super.onDestroy();
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        menu.add(0, 0, 0, res.getString(R.string.init_clear)).setIcon(R.drawable.ic_menu_delete);

        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        if (item.getItemId() == 0) {
            boolean status;

            ((EditText) findViewById(R.id.username)).setText("");
            ((EditText) findViewById(R.id.password)).setText("");
            ((EditText) findViewById(R.id.passvote)).setText("");

            status = saveValues();
            if (status) {
                showToast(res.getString(R.string.init_cleared));
            } else {
                showToast(res.getString(R.string.err_init_cleared));
            }

            finish();
        }

        return false;
    }

    @Override
    public void onCreateContextMenu(ContextMenu menu, View v,
            ContextMenuInfo menuInfo) {
        if (enableTemplatesMenu) {
            menu.setHeaderTitle(R.string.init_signature_template_button);
            for (LogTemplate template : LogTemplateProvider.getTemplates()) {
                menu.add(0, template.getItemId(), 0, template.getResourceId());
            }
        }
    }

    @Override
    public boolean onContextItemSelected(MenuItem item) {
        LogTemplate template = LogTemplateProvider.getTemplate(item.getItemId());
        if (template != null) {
            return insertSignatureTemplate(template);
        }
        return super.onContextItemSelected(item);
    }

    private boolean insertSignatureTemplate(final LogTemplate template) {
        EditText sig = (EditText) findViewById(R.id.signature);
        String insertText = "[" + template.getTemplateString() + "]";
        insertAtPosition(sig, insertText, true);
        return true;
    }

    public void init() {

        // geocaching.com settings
        final ImmutablePair<String, String> login = Settings.getLogin();
        if (login != null) {
            ((EditText) findViewById(R.id.username)).setText(login.left);
            ((EditText) findViewById(R.id.password)).setText(login.right);
        }

        Button logMeIn = (Button) findViewById(R.id.log_me_in);
        logMeIn.setOnClickListener(new logIn());

        TextView legalNote = (TextView) findViewById(R.id.legal_note);
        legalNote.setClickable(true);
        legalNote.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View arg0) {
                startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse("http://www.geocaching.com/about/termsofuse.aspx")));
            }
        });

        // gcvote settings
        final ImmutablePair<String, String> gcvoteLogin = Settings.getGCvoteLogin();
        if (null != gcvoteLogin && null != gcvoteLogin.right) {
            ((EditText) findViewById(R.id.passvote)).setText(gcvoteLogin.right);
        }

        // go4cache settings
        TextView go4cache = (TextView) findViewById(R.id.about_go4cache);
        go4cache.setClickable(true);
        go4cache.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View arg0) {
                startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse("http://go4cache.com/")));
            }
        });

        final CheckBox publicButton = (CheckBox) findViewById(R.id.publicloc);
        publicButton.setChecked(Settings.isPublicLoc());
        publicButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setPublicLoc(publicButton.isChecked());
            }
        });

        // Twitter settings
        Button authorizeTwitter = (Button) findViewById(R.id.authorize_twitter);
        authorizeTwitter.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View arg0) {
                Intent authIntent = new Intent(SettingsActivity.this, TwitterAuthorizationActivity.class);
                startActivity(authIntent);
            }
        });

        final CheckBox twitterButton = (CheckBox) findViewById(R.id.twitter_option);
        twitterButton.setChecked(Settings.isUseTwitter() && Settings.isTwitterLoginValid());
        twitterButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setUseTwitter(twitterButton.isChecked());
                if (Settings.isUseTwitter() && !Settings.isTwitterLoginValid()) {
                    Intent authIntent = new Intent(SettingsActivity.this, TwitterAuthorizationActivity.class);
                    startActivity(authIntent);
                }

                twitterButton.setChecked(Settings.isUseTwitter());
            }
        });

        // Signature settings
        EditText sigEdit = (EditText) findViewById(R.id.signature);
        if (sigEdit.getText().length() == 0) {
            sigEdit.setText(Settings.getSignature());
        }
        Button sigBtn = (Button) findViewById(R.id.signature_help);
        sigBtn.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                helpDialog(res.getString(R.string.init_signature_help_title), res.getString(R.string.init_signature_help_text));
            }
        });
        Button templates = (Button) findViewById(R.id.signature_template);
        registerForContextMenu(templates);
        templates.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                enableTemplatesMenu = true;
                openContextMenu(v);
                enableTemplatesMenu = false;
            }
        });
        final CheckBox autoinsertButton = (CheckBox) findViewById(R.id.sigautoinsert);
        autoinsertButton.setChecked(Settings.isAutoInsertSignature());
        autoinsertButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setAutoInsertSignature(autoinsertButton.isChecked());
            }
        });

        // Cache details
        final CheckBox autoloadButton = (CheckBox) findViewById(R.id.autoload);
        autoloadButton.setChecked(Settings.isAutoLoadDescription());
        autoloadButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setAutoLoadDesc(autoloadButton.isChecked());
            }
        });

        final CheckBox ratingWantedButton = (CheckBox) findViewById(R.id.ratingwanted);
        ratingWantedButton.setChecked(Settings.isRatingWanted());
        ratingWantedButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setRatingWanted(ratingWantedButton.isChecked());
            }
        });

        final CheckBox elevationWantedButton = (CheckBox) findViewById(R.id.elevationwanted);
        elevationWantedButton.setChecked(Settings.isElevationWanted());
        elevationWantedButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setElevationWanted(elevationWantedButton.isChecked());
            }
        });

        final CheckBox friendLogsWantedButton = (CheckBox) findViewById(R.id.friendlogswanted);
        friendLogsWantedButton.setChecked(Settings.isFriendLogsWanted());
        friendLogsWantedButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setFriendLogsWanted(friendLogsWantedButton.isChecked());
            }
        });

        final CheckBox openLastDetailsPageButton = (CheckBox) findViewById(R.id.openlastdetailspage);
        openLastDetailsPageButton.setChecked(Settings.isOpenLastDetailsPage());
        openLastDetailsPageButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setOpenLastDetailsPage(openLastDetailsPageButton.isChecked());
            }
        });

        // Other settings
        final CheckBox skinButton = (CheckBox) findViewById(R.id.skin);
        skinButton.setChecked(Settings.isLightSkin());
        skinButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setLightSkin(skinButton.isChecked());
            }
        });

        final CheckBox addressButton = (CheckBox) findViewById(R.id.address);
        addressButton.setChecked(Settings.isShowAddress());
        addressButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setShowAddress(addressButton.isChecked());
            }
        });

        final CheckBox captchaButton = (CheckBox) findViewById(R.id.captcha);
        captchaButton.setEnabled(!Settings.isPremiumMember());
        captchaButton.setChecked(Settings.isShowCaptcha());
        captchaButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setShowCaptcha(captchaButton.isChecked());
            }
        });

        final CheckBox dirImgButton = (CheckBox) findViewById(R.id.loaddirectionimg);
        dirImgButton.setEnabled(!Settings.isPremiumMember());
        dirImgButton.setChecked(Settings.getLoadDirImg());
        dirImgButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setLoadDirImg(!Settings.getLoadDirImg());
                dirImgButton.setChecked(Settings.getLoadDirImg());
            }
        });

        final CheckBox useEnglishButton = (CheckBox) findViewById(R.id.useenglish);
        useEnglishButton.setChecked(Settings.isUseEnglish());
        useEnglishButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setUseEnglish(useEnglishButton.isChecked());
            }
        });

        final CheckBox excludeButton = (CheckBox) findViewById(R.id.exclude);
        excludeButton.setChecked(Settings.isExcludeMyCaches());
        excludeButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setExcludeMine(excludeButton.isChecked());
            }
        });

        final CheckBox disabledButton = (CheckBox) findViewById(R.id.disabled);
        disabledButton.setChecked(Settings.isExcludeDisabledCaches());
        disabledButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setExcludeDisabledCaches(disabledButton.isChecked());
            }
        });

        TextView showWaypointsThreshold = (TextView) findViewById(R.id.showwaypointsthreshold);
        showWaypointsThreshold.setText(String.valueOf(Settings.getWayPointsThreshold()));

        final CheckBox autovisitButton = (CheckBox) findViewById(R.id.trackautovisit);
        autovisitButton.setChecked(Settings.isTrackableAutoVisit());
        autovisitButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setTrackableAutoVisit(autovisitButton.isChecked());
            }
        });

        final CheckBox offlineButton = (CheckBox) findViewById(R.id.offline);
        offlineButton.setChecked(Settings.isStoreOfflineMaps());
        offlineButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setStoreOfflineMaps(offlineButton.isChecked());
            }
        });

        final CheckBox offlineWpButton = (CheckBox) findViewById(R.id.offline_wp);
        offlineWpButton.setChecked(Settings.isStoreOfflineWpMaps());
        offlineWpButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setStoreOfflineWpMaps(offlineWpButton.isChecked());
            }
        });

        final CheckBox saveLogImgButton = (CheckBox) findViewById(R.id.save_log_img);
        saveLogImgButton.setChecked(Settings.isStoreLogImages());
        saveLogImgButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setStoreLogImages(saveLogImgButton.isChecked());
            }
        });

        final CheckBox livelistButton = (CheckBox) findViewById(R.id.livelist);
        livelistButton.setChecked(Settings.isLiveList());
        livelistButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setLiveList(livelistButton.isChecked());
            }
        });

        final CheckBox unitsButton = (CheckBox) findViewById(R.id.units);
        unitsButton.setChecked(!Settings.isUseMetricUnits());
        unitsButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setUseMetricUnits(!unitsButton.isChecked());
            }
        });

        final CheckBox gnavButton = (CheckBox) findViewById(R.id.gnav);
        gnavButton.setChecked(Settings.isUseGoogleNavigation());
        gnavButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setUseGoogleNavigation(gnavButton.isChecked());
            }
        });

        final CheckBox logOffline = (CheckBox) findViewById(R.id.log_offline);
        logOffline.setChecked(Settings.getLogOffline());
        logOffline.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setLogOffline(!Settings.getLogOffline());
                logOffline.setChecked(Settings.getLogOffline());
            }
        });

        // Altitude settings
        EditText altitudeEdit = (EditText) findViewById(R.id.altitude);
        altitudeEdit.setText(String.valueOf(Settings.getAltCorrection()));

        //Send2cgeo settings
        String webDeviceName = Settings.getWebDeviceName();

        if (StringUtils.isNotBlank(webDeviceName)) {
            ((EditText) findViewById(R.id.webDeviceName)).setText(webDeviceName);
        } else {
            String s = android.os.Build.MODEL;
            ((EditText) findViewById(R.id.webDeviceName)).setText(s);
        }

        Button webAuth = (Button) findViewById(R.id.sendToCgeo_register);
        webAuth.setOnClickListener(new webAuth());

        // Map source settings
        Collection<String> mapSourceNames = new ArrayList<String>();
        for (MapSource mapSource : MapProviderFactory.getMapSources().values()) {
            mapSourceNames.add(mapSource.getName());
        }
        Spinner mapSourceSelector = (Spinner) findViewById(R.id.mapsource);
        ArrayAdapter<CharSequence> adapter = new ArrayAdapter<CharSequence>(this, android.R.layout.simple_spinner_item, mapSourceNames.toArray(new String[mapSourceNames.size()]));
        adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        mapSourceSelector.setAdapter(adapter);
        int mapsource = Settings.getMapSource();
        mapSourceSelector.setSelection(MapProviderFactory.getSourceOrdinalFromId(mapsource));
        mapSourceSelector.setOnItemSelectedListener(new cgeoChangeMapSource());

        initMapfileEdittext(false);

        Button selectMapfile = (Button) findViewById(R.id.select_mapfile);
        selectMapfile.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Intent selectIntent = new Intent(SettingsActivity.this, cgSelectMapfile.class);
                startActivityForResult(selectIntent, SELECT_MAPFILE_REQUEST);
            }
        });

        final CheckBox trailButton = (CheckBox) findViewById(R.id.trail);
        trailButton.setChecked(Settings.isMapTrail());
        trailButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setMapTrail(trailButton.isChecked());
            }
        });

        // Default navigation tool settings
        Spinner defaultNavigationToolSelector = (Spinner) findViewById(R.id.default_navigation_tool);
        final List<NavigationAppsEnum> apps = NavigationAppFactory.getInstalledDefaultNavigationApps();
        ArrayAdapter<NavigationAppsEnum> naviAdapter = new ArrayAdapter<NavigationAppsEnum>(this, android.R.layout.simple_spinner_item, apps) {
            @Override
            public View getView(int position, View convertView, ViewGroup parent) {
                TextView textView = (TextView) super.getView(position, convertView, parent);
                textView.setText(getItem(position).app.getName());
                return textView;
            }

            @Override
            public View getDropDownView(int position, View convertView, ViewGroup parent) {
                TextView textView = (TextView) super.getDropDownView(position, convertView, parent);
                textView.setText(getItem(position).app.getName());
                return textView;
            }
        };
        naviAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        defaultNavigationToolSelector.setAdapter(naviAdapter);
        int defaultNavigationTool = Settings.getDefaultNavigationTool();
        int ordinal = 0;
        for (int i = 0; i < apps.size(); i++) {
            if (apps.get(i).id == defaultNavigationTool) {
                ordinal = i;
                break;
            }
        }
        defaultNavigationToolSelector.setSelection(ordinal);
        defaultNavigationToolSelector.setOnItemSelectedListener(new OnItemSelectedListener() {
            @Override
            public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
                NavigationAppsEnum item = (NavigationAppsEnum) parent.getItemAtPosition(position);
                if (item != null) {
                    Settings.setDefaultNavigationTool(item.id);
                }
            }

            @Override
            public void onNothingSelected(AdapterView<?> arg0) {
                // noop
            }
        });

        // 2nd Default navigation tool settings
        Spinner defaultNavigationTool2Selector = (Spinner) findViewById(R.id.default_navigation_tool_2);
        //        final List<NavigationAppsEnum> apps = NavigationAppFactory.getInstalledNavigationApps(this);
        ArrayAdapter<NavigationAppsEnum> navi2Adapter = new ArrayAdapter<NavigationAppsEnum>(this, android.R.layout.simple_spinner_item, apps) {
            @Override
            public View getView(int position, View convertView, ViewGroup parent) {
                TextView textView = (TextView) super.getView(position, convertView, parent);
                textView.setText(getItem(position).app.getName());
                return textView;
            }

            @Override
            public View getDropDownView(int position, View convertView, ViewGroup parent) {
                TextView textView = (TextView) super.getDropDownView(position, convertView, parent);
                textView.setText(getItem(position).app.getName());
                return textView;
            }
        };
        navi2Adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        defaultNavigationTool2Selector.setAdapter(navi2Adapter);
        int defaultNavigationTool2 = Settings.getDefaultNavigationTool2();
        int ordinal2 = 0;
        for (int i = 0; i < apps.size(); i++) {
            if (apps.get(i).id == defaultNavigationTool2) {
                ordinal2 = i;
                break;
            }
        }
        defaultNavigationTool2Selector.setSelection(ordinal2);
        defaultNavigationTool2Selector.setOnItemSelectedListener(new OnItemSelectedListener() {
            @Override
            public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
                NavigationAppsEnum item = (NavigationAppsEnum) parent.getItemAtPosition(position);
                if (item != null) {
                    Settings.setDefaultNavigationTool2(item.id);
                }
            }

            @Override
            public void onNothingSelected(AdapterView<?> arg0) {
                // noop
            }
        });

        refreshBackupLabel();

        // Database location
        refreshDbOnSDCardSetting();

        final CheckBox dbOnSDCardButton = (CheckBox) findViewById(R.id.dbonsdcard);
        dbOnSDCardButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                app.moveDatabase(SettingsActivity.this);
            }
        });

        // Debug settings
        final CheckBox debugButton = (CheckBox) findViewById(R.id.debug);
        debugButton.setChecked(Settings.isDebug());
        debugButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Settings.setDebug(!Settings.isDebug());
                debugButton.setChecked(Settings.isDebug());
            }
        });
    }

    private void initMapfileEdittext(boolean setFocus) {
        EditText mfmapFileEdit = (EditText) findViewById(R.id.mapfile);
        mfmapFileEdit.setText(Settings.getMapFile());
        if (setFocus) {
            mfmapFileEdit.requestFocus();
        }
    }

    /**
     * @param view
     *            unused here but needed since this method is referenced from XML layout
     */
    public void backup(View view) {
        // avoid overwriting an existing backup with an empty database (can happen directly after reinstalling the app)
        if (app.getAllStoredCachesCount(true, CacheType.ALL) == 0) {
            helpDialog(res.getString(R.string.init_backup), res.getString(R.string.init_backup_unnecessary));
            return;
        }

        final ProgressDialog dialog = ProgressDialog.show(this, res.getString(R.string.init_backup), res.getString(R.string.init_backup_running), true, false);
        new Thread() {
            @Override
            public void run() {
                final String backupFileName = app.backupDatabase();
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        dialog.dismiss();
                        helpDialog(res.getString(R.string.init_backup_backup),
                                backupFileName != null ? res.getString(R.string.init_backup_success) + "\n" + backupFileName : res.getString(R.string.init_backup_failed));
                        refreshBackupLabel();
                    }
                });
            }
        }.start();
    }

    private void refreshBackupLabel() {
        TextView lastBackup = (TextView) findViewById(R.id.backup_last);
        File lastBackupFile = cgeoapplication.isRestoreFile();
        if (lastBackupFile != null) {
            lastBackup.setText(res.getString(R.string.init_backup_last) + " " + Formatter.formatTime(lastBackupFile.lastModified()) + ", " + Formatter.formatDate(lastBackupFile.lastModified()));
        } else {
            lastBackup.setText(res.getString(R.string.init_backup_last_no));
        }
    }

    private void refreshDbOnSDCardSetting() {
        final CheckBox dbOnSDCardButton = (CheckBox) findViewById(R.id.dbonsdcard);
        dbOnSDCardButton.setChecked(Settings.isDbOnSDCard());
    }

    /**
     * @param view
     *            unused here but needed since this method is referenced from XML layout
     */
    public void restore(View view) {
        app.restoreDatabase(this);
    }

    public boolean saveValues() {
        String usernameNew = StringUtils.trimToEmpty(((EditText) findViewById(R.id.username)).getText().toString());
        String passwordNew = StringUtils.trimToEmpty(((EditText) findViewById(R.id.password)).getText().toString());
        String passvoteNew = StringUtils.trimToEmpty(((EditText) findViewById(R.id.passvote)).getText().toString());
        // don't trim signature, user may want to have whitespace at the beginning
        String signatureNew = ((EditText) findViewById(R.id.signature)).getText().toString();
        String altitudeNew = StringUtils.trimToNull(((EditText) findViewById(R.id.altitude)).getText().toString());
        String mfmapFileNew = StringUtils.trimToEmpty(((EditText) findViewById(R.id.mapfile)).getText().toString());

        int altitudeNewInt = 0;
        if (altitudeNew != null) {
            try {
                altitudeNewInt = Integer.parseInt(altitudeNew);
            } catch (NumberFormatException e) {
                altitudeNewInt = 0;
            }
        }

        final boolean status1 = Settings.setLogin(usernameNew, passwordNew);
        final boolean status2 = Settings.setGCvoteLogin(passvoteNew);
        final boolean status3 = Settings.setSignature(signatureNew);
        final boolean status4 = Settings.setAltCorrection(altitudeNewInt);
        final boolean status5 = Settings.setMapFile(mfmapFileNew);
        TextView field = (TextView) findViewById(R.id.showwaypointsthreshold);
        Settings.setShowWaypointsThreshold(safeParse(field, 5));

        return status1 && status2 && status3 && status4 && status5;
    }

    /**
     * Returns the Int Value in the Field
     *
     * @param field
     *            the field to retrieve the integer value from
     * @param defaultValue
     *            the default value
     * @return either the field content or the default value
     */

    static private int safeParse(final TextView field, int defaultValue) {
        try {
            return Integer.parseInt(field.getText().toString());
        } catch (NumberFormatException e) {
            return defaultValue;
        }
    }

    private static class cgeoChangeMapSource implements OnItemSelectedListener {

        @Override
        public void onItemSelected(AdapterView<?> arg0, View arg1, int arg2,
                long arg3) {
            Settings.setMapSource(MapProviderFactory.getSourceIdFromOrdinal(arg2));
        }

        @Override
        public void onNothingSelected(AdapterView<?> arg0) {
            arg0.setSelection(MapProviderFactory.getSourceIdFromOrdinal(Settings.getMapSource()));
        }
    }

    private class logIn implements View.OnClickListener {

        @Override
        public void onClick(View arg0) {
            final String username = ((EditText) findViewById(R.id.username)).getText().toString();
            final String password = ((EditText) findViewById(R.id.password)).getText().toString();

            if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
                showToast(res.getString(R.string.err_missing_auth));
                return;
            }

            loginDialog = ProgressDialog.show(SettingsActivity.this, res.getString(R.string.init_login_popup), res.getString(R.string.init_login_popup_working), true);
            loginDialog.setCancelable(false);

            Settings.setLogin(username, password);
            Cookies.clearCookies();

            (new Thread() {

                @Override
                public void run() {
                    final StatusCode loginResult = Login.login();
                    Object payload = loginResult;
                    if (loginResult == StatusCode.NO_ERROR) {
                        Login.detectGcCustomDate();
                        payload = Login.downloadAvatarAndGetMemberStatus();
                    }
                    logInHandler.obtainMessage(0, payload).sendToTarget();
                }
            }).start();
        }
    }

    private class webAuth implements View.OnClickListener {

        @Override
        public void onClick(View arg0) {
            final String deviceName = ((EditText) findViewById(R.id.webDeviceName)).getText().toString();
            final String deviceCode = Settings.getWebDeviceCode();

            if (StringUtils.isBlank(deviceName)) {
                showToast(res.getString(R.string.err_missing_device_name));
                return;
            }

            webDialog = ProgressDialog.show(SettingsActivity.this, res.getString(R.string.init_sendToCgeo), res.getString(R.string.init_sendToCgeo_registering), true);
            webDialog.setCancelable(false);

            (new Thread() {

                @Override
                public void run() {
                    int pin = 0;

                    final String nam = StringUtils.defaultString(deviceName);
                    final String cod = StringUtils.defaultString(deviceCode);

                    final Parameters params = new Parameters("name", nam, "code", cod);
                    HttpResponse response = Network.getRequest("http://send2.cgeo.org/auth.html", params);

                    if (response != null && response.getStatusLine().getStatusCode() == 200)
                    {
                        //response was OK
                        String[] strings = Network.getResponseData(response).split(",");
                        try {
                            pin = Integer.parseInt(strings[1].trim());
                        } catch (Exception e) {
                            Log.e("webDialog: " + e.toString());
                        }
                        String code = strings[0];
                        Settings.setWebNameCode(nam, code);
                    }

                    webAuthHandler.sendEmptyMessage(pin);
                }
            }).start();
        }
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);

        if (requestCode == SELECT_MAPFILE_REQUEST) {
            if (resultCode == RESULT_OK) {
                if (data.hasExtra("mapfile")) {
                    Settings.setMapFile(data.getStringExtra("mapfile"));
                    if (!Settings.isValidMapFile(Settings.getMapFile())) {
                        showToast(res.getString(R.string.warn_invalid_mapfile));
                    }
                }
            }
            initMapfileEdittext(true);
        }
    }

    public static void startActivity(Context fromActivity) {
        final Intent initIntent = new Intent(fromActivity, SettingsActivity.class);
        fromActivity.startActivity(initIntent);
    }

}
!@#$%
20190527_000018,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_b16056
package cgeo.geocaching;

import cgeo.geocaching.apps.cache.navi.NavigationAppFactory.NavigationAppsEnum;
import cgeo.geocaching.connector.gc.GCConstants;
import cgeo.geocaching.connector.gc.Login;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.LiveMapStrategy.Strategy;
import cgeo.geocaching.enumerations.LogType;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.maps.MapProviderFactory;
import cgeo.geocaching.maps.interfaces.GeoPointImpl;
import cgeo.geocaching.maps.interfaces.MapProvider;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider;
import cgeo.geocaching.utils.CryptUtils;
import cgeo.geocaching.utils.Log;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.preference.PreferenceManager;

import java.util.Locale;

/**
 * General c:geo preferences/settings set by the user
 */
public final class Settings {

    private static final String KEY_TEMP_TOKEN_SECRET = "temp-token-secret";
    private static final String KEY_TEMP_TOKEN_PUBLIC = "temp-token-public";
    private static final String KEY_HELP_SHOWN = "helper";
    private static final String KEY_ANYLONGITUDE = "anylongitude";
    private static final String KEY_ANYLATITUDE = "anylatitude";
    private static final String KEY_PUBLICLOC = "publicloc";
    private static final String KEY_USE_OFFLINEMAPS = "offlinemaps";
    private static final String KEY_USE_OFFLINEWPMAPS = "offlinewpmaps";
    private static final String KEY_WEB_DEVICE_CODE = "webDeviceCode";
    private static final String KEY_WEBDEVICE_NAME = "webDeviceName";
    private static final String KEY_MAP_LIVE = "maplive";
    private static final String KEY_MAP_SOURCE = "mapsource";
    private static final String KEY_USE_TWITTER = "twitter";
    private static final String KEY_SHOW_ADDRESS = "showaddress";
    private static final String KEY_SHOW_CAPTCHA = "showcaptcha";
    private static final String KEY_MAP_TRAIL = "maptrail";
    private static final String KEY_LAST_MAP_ZOOM = "mapzoom";
    private static final String KEY_LAST_MAP_LAT = "maplat";
    private static final String KEY_LAST_MAP_LON = "maplon";
    private static final String KEY_LIVE_LIST = "livelist";
    private static final String KEY_METRIC_UNITS = "units";
    private static final String KEY_SKIN = "skin";
    private static final String KEY_LAST_USED_LIST = "lastlist";
    private static final String KEY_CACHE_TYPE = "cachetype";
    private static final String KEY_TWITTER_TOKEN_SECRET = "tokensecret";
    private static final String KEY_TWITTER_TOKEN_PUBLIC = "tokenpublic";
    private static final String KEY_VERSION = "version";
    private static final String KEY_LOAD_DESCRIPTION = "autoloaddesc";
    private static final String KEY_RATING_WANTED = "ratingwanted";
    private static final String KEY_ELEVATION_WANTED = "elevationwanted";
    private static final String KEY_FRIENDLOGS_WANTED = "friendlogswanted";
    private static final String KEY_USE_ENGLISH = "useenglish";
    private static final String KEY_USE_COMPASS = "usecompass";
    private static final String KEY_AUTO_VISIT_TRACKABLES = "trackautovisit";
    private static final String KEY_AUTO_INSERT_SIGNATURE = "sigautoinsert";
    private static final String KEY_ALTITUDE_CORRECTION = "altcorrection";
    private static final String KEY_USE_GOOGLE_NAVIGATION = "usegnav";
    private static final String KEY_STORE_LOG_IMAGES = "logimages";
    private static final String KEY_EXCLUDE_DISABLED = "excludedisabled";
    private static final String KEY_EXCLUDE_OWN = "excludemine";
    private static final String KEY_MAPFILE = "mfmapfile";
    private static final String KEY_SIGNATURE = "signature";
    private static final String KEY_GCVOTE_PASSWORD = "pass-vote";
    private static final String KEY_PASSWORD = "password";
    private static final String KEY_USERNAME = "username";
    private static final String KEY_MEMBER_STATUS = "memberstatus";
    private static final String KEY_COORD_INPUT_FORMAT = "coordinputformat";
    private static final String KEY_LOG_OFFLINE = "log_offline";
    private static final String KEY_LOAD_DIRECTION_IMG = "loaddirectionimg";
    private static final String KEY_GC_CUSTOM_DATE = "gccustomdate";
    private static final String KEY_SHOW_WAYPOINTS_THRESHOLD = "gcshowwaypointsthreshold";
    private static final String KEY_COOKIE_STORE = "cookiestore";
    private static final String KEY_OPEN_LAST_DETAILS_PAGE = "opendetailslastpage";
    private static final String KEY_LAST_DETAILS_PAGE = "lastdetailspage";
    private static final String KEY_DEFAULT_NAVIGATION_TOOL = "defaultNavigationTool";
    private static final String KEY_DEFAULT_NAVIGATION_TOOL_2 = "defaultNavigationTool2";
    private static final String KEY_LIVE_MAP_STRATEGY = "livemapstrategy";
    private static final String KEY_DEBUG = "debug";
    private static final String KEY_HIDE_LIVE_MAP_HINT = "hidelivemaphint";
    private static final String KEY_LIVE_MAP_HINT_SHOW_COUNT = "livemaphintshowcount";
    private static final String KEY_SETTINGS_VERSION = "settingsversion";
    private static final String KEY_DB_ON_SDCARD = "dbonsdcard";
    private static final String KEY_LAST_TRACKABLE_ACTION = "trackableaction";
    private static final String KEY_SHARE_AFTER_EXPORT = "shareafterexport";

    private final static int unitsMetric = 1;

    // twitter api keys
    private final static String keyConsumerPublic = CryptUtils.rot13("ESnsCvAv3kEupF1GCR3jGj");
    private final static String keyConsumerSecret = CryptUtils.rot13("7vQWceACV9umEjJucmlpFe9FCMZSeqIqfkQ2BnhV9x");

    private interface PrefRunnable {
        void edit(final Editor edit);
    }

    public enum coordInputFormatEnum {
        Plain,
        Deg,
        Min,
        Sec;

        static coordInputFormatEnum fromInt(int id) {
            final coordInputFormatEnum[] values = coordInputFormatEnum.values();
            if (id < 0 || id >= values.length) {
                return Min;
            }
            return values[id];
        }
    }

    private static String username = null;
    private static String password = null;

    private static final SharedPreferences sharedPrefs = PreferenceManager.getDefaultSharedPreferences(cgeoapplication.getInstance().getBaseContext());
    static {
        migrateSettings();
        Log.setDebugUnsaved(sharedPrefs.getBoolean(KEY_DEBUG, false));
    }

    // maps
    private static MapProvider mapProvider = null;

    private Settings() {
        // this class is not to be instantiated;
    }

    private static void migrateSettings() {
        // migrate from non standard file location and integer based boolean types
        if (sharedPrefs.getInt(KEY_SETTINGS_VERSION, 0) < 1) {
            final String oldPreferencesName = "cgeo.pref";
            final SharedPreferences old = cgeoapplication.getInstance().getSharedPreferences(oldPreferencesName, Context.MODE_PRIVATE);
            final Editor e = sharedPrefs.edit();

            e.putString(KEY_TEMP_TOKEN_SECRET, old.getString(KEY_TEMP_TOKEN_SECRET, null));
            e.putString(KEY_TEMP_TOKEN_PUBLIC, old.getString(KEY_TEMP_TOKEN_PUBLIC, null));
            e.putBoolean(KEY_HELP_SHOWN, old.getInt(KEY_HELP_SHOWN, 0) != 0);
            e.putFloat(KEY_ANYLONGITUDE, old.getFloat(KEY_ANYLONGITUDE, 0));
            e.putFloat(KEY_ANYLATITUDE, old.getFloat(KEY_ANYLATITUDE, 0));
            e.putBoolean(KEY_PUBLICLOC, 0 != old.getInt(KEY_PUBLICLOC, 0));
            e.putBoolean(KEY_USE_OFFLINEMAPS, 0 != old.getInt(KEY_USE_OFFLINEMAPS, 1));
            e.putBoolean(KEY_USE_OFFLINEWPMAPS, 0 != old.getInt(KEY_USE_OFFLINEWPMAPS, 0));
            e.putString(KEY_WEB_DEVICE_CODE, old.getString(KEY_WEB_DEVICE_CODE, null));
            e.putString(KEY_WEBDEVICE_NAME, old.getString(KEY_WEBDEVICE_NAME, null));
            e.putBoolean(KEY_MAP_LIVE, old.getInt(KEY_MAP_LIVE, 1) != 0);
            e.putInt(KEY_MAP_SOURCE, old.getInt(KEY_MAP_SOURCE, 0));
            e.putBoolean(KEY_USE_TWITTER, 0 != old.getInt(KEY_USE_TWITTER, 0));
            e.putBoolean(KEY_SHOW_ADDRESS, 0 != old.getInt(KEY_SHOW_ADDRESS, 1));
            e.putBoolean(KEY_SHOW_CAPTCHA, old.getBoolean(KEY_SHOW_CAPTCHA, false));
            e.putBoolean(KEY_MAP_TRAIL, old.getInt(KEY_MAP_TRAIL, 1) != 0);
            e.putInt(KEY_LAST_MAP_ZOOM, old.getInt(KEY_LAST_MAP_ZOOM, 14));
            e.putBoolean(KEY_LIVE_LIST, 0 != old.getInt(KEY_LIVE_LIST, 1));
            e.putBoolean(KEY_METRIC_UNITS, old.getInt(KEY_METRIC_UNITS, unitsMetric) == unitsMetric);
            e.putBoolean(KEY_SKIN, old.getInt(KEY_SKIN, 0) != 0);
            e.putInt(KEY_LAST_USED_LIST, old.getInt(KEY_LAST_USED_LIST, StoredList.STANDARD_LIST_ID));
            e.putString(KEY_CACHE_TYPE, old.getString(KEY_CACHE_TYPE, CacheType.ALL.id));
            e.putString(KEY_TWITTER_TOKEN_SECRET, old.getString(KEY_TWITTER_TOKEN_SECRET, null));
            e.putString(KEY_TWITTER_TOKEN_PUBLIC, old.getString(KEY_TWITTER_TOKEN_PUBLIC, null));
            e.putInt(KEY_VERSION, old.getInt(KEY_VERSION, 0));
            e.putBoolean(KEY_LOAD_DESCRIPTION, 0 != old.getInt(KEY_LOAD_DESCRIPTION, 0));
            e.putBoolean(KEY_RATING_WANTED, old.getBoolean(KEY_RATING_WANTED, true));
            e.putBoolean(KEY_ELEVATION_WANTED, old.getBoolean(KEY_ELEVATION_WANTED, true));
            e.putBoolean(KEY_FRIENDLOGS_WANTED, old.getBoolean(KEY_FRIENDLOGS_WANTED, true));
            e.putBoolean(KEY_USE_ENGLISH, old.getBoolean(KEY_USE_ENGLISH, false));
            e.putBoolean(KEY_USE_COMPASS, 0 != old.getInt(KEY_USE_COMPASS, 1));
            e.putBoolean(KEY_AUTO_VISIT_TRACKABLES, old.getBoolean(KEY_AUTO_VISIT_TRACKABLES, false));
            e.putBoolean(KEY_AUTO_INSERT_SIGNATURE, old.getBoolean(KEY_AUTO_INSERT_SIGNATURE, false));
            e.putInt(KEY_ALTITUDE_CORRECTION, old.getInt(KEY_ALTITUDE_CORRECTION, 0));
            e.putBoolean(KEY_USE_GOOGLE_NAVIGATION, 0 != old.getInt(KEY_USE_GOOGLE_NAVIGATION, 1));
            e.putBoolean(KEY_STORE_LOG_IMAGES, old.getBoolean(KEY_STORE_LOG_IMAGES, false));
            e.putBoolean(KEY_EXCLUDE_DISABLED, 0 != old.getInt(KEY_EXCLUDE_DISABLED, 0));
            e.putBoolean(KEY_EXCLUDE_OWN, 0 != old.getInt(KEY_EXCLUDE_OWN, 0));
            e.putString(KEY_MAPFILE, old.getString(KEY_MAPFILE, null));
            e.putString(KEY_SIGNATURE, old.getString(KEY_SIGNATURE, null));
            e.putString(KEY_GCVOTE_PASSWORD, old.getString(KEY_GCVOTE_PASSWORD, null));
            e.putString(KEY_PASSWORD, old.getString(KEY_PASSWORD, null));
            e.putString(KEY_USERNAME, old.getString(KEY_USERNAME, null));
            e.putString(KEY_MEMBER_STATUS, old.getString(KEY_MEMBER_STATUS, ""));
            e.putInt(KEY_COORD_INPUT_FORMAT, old.getInt(KEY_COORD_INPUT_FORMAT, 0));
            e.putBoolean(KEY_LOG_OFFLINE, old.getBoolean(KEY_LOG_OFFLINE, false));
            e.putBoolean(KEY_LOAD_DIRECTION_IMG, old.getBoolean(KEY_LOAD_DIRECTION_IMG, true));
            e.putString(KEY_GC_CUSTOM_DATE, old.getString(KEY_GC_CUSTOM_DATE, null));
            e.putInt(KEY_SHOW_WAYPOINTS_THRESHOLD, old.getInt(KEY_SHOW_WAYPOINTS_THRESHOLD, 0));
            e.putString(KEY_COOKIE_STORE, old.getString(KEY_COOKIE_STORE, null));
            e.putBoolean(KEY_OPEN_LAST_DETAILS_PAGE, old.getBoolean(KEY_OPEN_LAST_DETAILS_PAGE, false));
            e.putInt(KEY_LAST_DETAILS_PAGE, old.getInt(KEY_LAST_DETAILS_PAGE, 1));
            e.putInt(KEY_DEFAULT_NAVIGATION_TOOL, old.getInt(KEY_DEFAULT_NAVIGATION_TOOL, 0));
            e.putInt(KEY_DEFAULT_NAVIGATION_TOOL_2, old.getInt(KEY_DEFAULT_NAVIGATION_TOOL_2, 0));
            e.putInt(KEY_LIVE_MAP_STRATEGY, old.getInt(KEY_LIVE_MAP_STRATEGY, Strategy.AUTO.id));
            e.putBoolean(KEY_DEBUG, old.getBoolean(KEY_DEBUG, false));
            e.putBoolean(KEY_HIDE_LIVE_MAP_HINT, old.getInt(KEY_HIDE_LIVE_MAP_HINT, 0) != 0);
            e.putInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, old.getInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, 0));

            e.putInt(KEY_SETTINGS_VERSION, 1); // mark migrated
            e.commit();
        }
    }

    public static void setLanguage(boolean useEnglish) {
        final Configuration config = new Configuration();
        config.locale = useEnglish ? new Locale("en") : Locale.getDefault();
        final Resources resources = cgeoapplication.getInstance().getResources();
        resources.updateConfiguration(config, resources.getDisplayMetrics());
    }

    public static boolean isLogin() {
        final String preUsername = sharedPrefs.getString(KEY_USERNAME, null);
        final String prePassword = sharedPrefs.getString(KEY_PASSWORD, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    /**
     * Get login and password information.
     *
     * @return a pair (login, password) or null if no valid information is stored
     */
    public static ImmutablePair<String, String> getLogin() {
        if (username == null || password == null) {
            final String preUsername = sharedPrefs.getString(KEY_USERNAME, null);
            final String prePassword = sharedPrefs.getString(KEY_PASSWORD, null);

            if (preUsername == null || prePassword == null) {
                return null;
            }

            username = preUsername;
            password = prePassword;
        }
        return new ImmutablePair<String, String>(username, password);
    }

    public static String getUsername() {
        return username != null ? username : sharedPrefs.getString(KEY_USERNAME, null);
    }

    public static boolean setLogin(final String username, final String password) {
        Settings.username = username;
        Settings.password = password;
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
                    // erase username and password
                    edit.remove(KEY_USERNAME);
                    edit.remove(KEY_PASSWORD);
                } else {
                    // save username and password
                    edit.putString(KEY_USERNAME, username);
                    edit.putString(KEY_PASSWORD, password);
                }
            }
        });
    }

    public static boolean isPremiumMember() {
        // Basic Member, Premium Member, ???
        String memberStatus = Settings.getMemberStatus();
        if (memberStatus == null) {
            return false;
        }
        return GCConstants.MEMBER_STATUS_PM.equalsIgnoreCase(memberStatus);
    }

    public static String getMemberStatus() {
        return sharedPrefs.getString(KEY_MEMBER_STATUS, "");
    }

    public static boolean setMemberStatus(final String memberStatus) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(memberStatus)) {
                    edit.remove(KEY_MEMBER_STATUS);
                } else {
                    edit.putString(KEY_MEMBER_STATUS, memberStatus);
                }
            }
        });
    }

    public static boolean isGCvoteLogin() {
        final String preUsername = sharedPrefs.getString(KEY_USERNAME, null);
        final String prePassword = sharedPrefs.getString(KEY_GCVOTE_PASSWORD, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    public static boolean setGCvoteLogin(final String password) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(password)) {
                    // erase password
                    edit.remove(KEY_GCVOTE_PASSWORD);
                } else {
                    // save password
                    edit.putString(KEY_GCVOTE_PASSWORD, password);
                }
            }
        });
    }

    public static ImmutablePair<String, String> getGCvoteLogin() {
        final String username = sharedPrefs.getString(KEY_USERNAME, null);
        final String password = sharedPrefs.getString(KEY_GCVOTE_PASSWORD, null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return null;
        }

        return new ImmutablePair<String, String>(username, password);
    }

    public static boolean setSignature(final String signature) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(signature)) {
                    // erase signature
                    edit.remove(KEY_SIGNATURE);
                } else {
                    // save signature
                    edit.putString(KEY_SIGNATURE, signature);
                }
            }
        });
    }

    public static String getSignature() {
        return sharedPrefs.getString(KEY_SIGNATURE, null);
    }

    public static boolean setCookieStore(final String cookies) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(final Editor edit) {
                if (StringUtils.isBlank(cookies)) {
                    // erase cookies
                    edit.remove(KEY_COOKIE_STORE);
                } else {
                    // save cookies
                    edit.putString(KEY_COOKIE_STORE, cookies);
                }
            }
        });
    }

    public static String getCookieStore() {
        return sharedPrefs.getString(KEY_COOKIE_STORE, null);
    }

    /**
     * @param cacheType
     *            The cache type used for future filtering
     */
    public static void setCacheType(final CacheType cacheType) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                if (cacheType == null) {
                    edit.remove(KEY_CACHE_TYPE);
                } else {
                    edit.putString(KEY_CACHE_TYPE, cacheType.id);
                }
            }
        });
    }

    public static void setLiveMap(final boolean live) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_MAP_LIVE, live);
            }
        });
    }

    public static int getLastList() {
        return sharedPrefs.getInt(KEY_LAST_USED_LIST, StoredList.STANDARD_LIST_ID);
    }

    public static void saveLastList(final int listId) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_USED_LIST, listId);
            }
        });
    }

    public static void setWebNameCode(final String name, final String code) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {

                edit.putString(KEY_WEBDEVICE_NAME, name);
                edit.putString(KEY_WEB_DEVICE_CODE, code);
            }
        });
    }

    public static MapProvider getMapProvider() {
        if (mapProvider == null) {
            mapProvider = MapProviderFactory.getMapProvider(getMapSource());
        }
        return mapProvider;
    }

    public static String getMapFile() {
        return sharedPrefs.getString(KEY_MAPFILE, null);
    }

    public static boolean setMapFile(final String mapFile) {
        return editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_MAPFILE, mapFile);
            }
        });
    }

    public static boolean isValidMapFile() {
        return isValidMapFile(getMapFile());
    }

    public static boolean isValidMapFile(final String mapFileIn) {
        return MapsforgeMapProvider.isValidMapFile(mapFileIn);
    }

    public static coordInputFormatEnum getCoordInputFormat() {
        return coordInputFormatEnum.fromInt(sharedPrefs.getInt(KEY_COORD_INPUT_FORMAT, 0));
    }

    public static void setCoordInputFormat(final coordInputFormatEnum format) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_COORD_INPUT_FORMAT, format.ordinal());
            }
        });
    }

    static void setLogOffline(final boolean offline) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LOG_OFFLINE, offline);
            }
        });
    }

    public static boolean getLogOffline() {
        return sharedPrefs.getBoolean(KEY_LOG_OFFLINE, false);
    }

    static void setLoadDirImg(final boolean value) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LOAD_DIRECTION_IMG, value);
            }
        });
    }

    public static boolean getLoadDirImg() {
        return !isPremiumMember() && sharedPrefs.getBoolean(KEY_LOAD_DIRECTION_IMG, true);
    }

    public static void setGcCustomDate(final String format) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_GC_CUSTOM_DATE, format);
            }
        });
    }

    /**
     * @return User selected date format on GC.com
     * @see Login#gcCustomDateFormats
     */
    public static String getGcCustomDate() {
        return sharedPrefs.getString(KEY_GC_CUSTOM_DATE, null);
    }

    public static boolean isExcludeMyCaches() {
        return sharedPrefs.getBoolean(KEY_EXCLUDE_OWN, false);
    }

    /**
     * edit some settings without knowing how to get the settings editor or how to commit
     *
     * @param runnable
     * @return
     */
    private static boolean editSharedSettings(final PrefRunnable runnable) {
        final SharedPreferences.Editor prefsEdit = sharedPrefs.edit();
        runnable.edit(prefsEdit);
        return prefsEdit.commit();
    }

    public static void setExcludeMine(final boolean exclude) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_EXCLUDE_OWN, exclude);
            }
        });
    }

    public static void setUseEnglish(final boolean english) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_ENGLISH, english);
                setLanguage(english);
            }
        });
    }

    public static boolean isUseEnglish() {
        return sharedPrefs.getBoolean(KEY_USE_ENGLISH, false);
    }

    public static boolean isShowAddress() {
        return sharedPrefs.getBoolean(KEY_SHOW_ADDRESS, true);
    }

    public static void setShowAddress(final boolean showAddress) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SHOW_ADDRESS, showAddress);
            }
        });
    }

    public static boolean isShowCaptcha() {
        return !isPremiumMember() && sharedPrefs.getBoolean(KEY_SHOW_CAPTCHA, false);
    }

    public static void setShowCaptcha(final boolean showCaptcha) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SHOW_CAPTCHA, showCaptcha);
            }
        });
    }

    public static boolean isExcludeDisabledCaches() {
        return sharedPrefs.getBoolean(KEY_EXCLUDE_DISABLED, false);
    }

    public static void setExcludeDisabledCaches(final boolean exclude) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_EXCLUDE_DISABLED, exclude);
            }
        });
    }

    public static boolean isStoreOfflineMaps() {
        return sharedPrefs.getBoolean(KEY_USE_OFFLINEMAPS, true);
    }

    public static void setStoreOfflineMaps(final boolean offlineMaps) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_OFFLINEMAPS, offlineMaps);
            }
        });
    }

    public static boolean isStoreOfflineWpMaps() {
        return sharedPrefs.getBoolean(KEY_USE_OFFLINEWPMAPS, false);
    }

    public static void setStoreOfflineWpMaps(final boolean offlineMaps) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_OFFLINEWPMAPS, offlineMaps);
            }
        });
    }

    public static boolean isStoreLogImages() {
        return sharedPrefs.getBoolean(KEY_STORE_LOG_IMAGES, false);
    }

    public static void setStoreLogImages(final boolean storeLogImages) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_STORE_LOG_IMAGES, storeLogImages);
            }
        });
    }

    public static boolean isUseGoogleNavigation() {
        return sharedPrefs.getBoolean(KEY_USE_GOOGLE_NAVIGATION, true);
    }

    public static void setUseGoogleNavigation(final boolean useGoogleNavigation) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_GOOGLE_NAVIGATION, useGoogleNavigation);
            }
        });
    }

    public static boolean isAutoLoadDescription() {
        return sharedPrefs.getBoolean(KEY_LOAD_DESCRIPTION, false);
    }

    public static void setAutoLoadDesc(final boolean autoLoad) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LOAD_DESCRIPTION, autoLoad);
            }
        });
    }

    public static boolean isRatingWanted() {
        return sharedPrefs.getBoolean(KEY_RATING_WANTED, true);
    }

    public static void setRatingWanted(final boolean ratingWanted) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_RATING_WANTED, ratingWanted);
            }
        });
    }

    public static boolean isElevationWanted() {
        return sharedPrefs.getBoolean(KEY_ELEVATION_WANTED, true);
    }

    public static void setElevationWanted(final boolean elevationWanted) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_ELEVATION_WANTED, elevationWanted);
            }
        });
    }

    public static boolean isFriendLogsWanted() {
        if (!isLogin()) {
            // don't show a friends log if the user is anonymous
            return false;
        }
        return sharedPrefs.getBoolean(KEY_FRIENDLOGS_WANTED, true);
    }

    public static void setFriendLogsWanted(final boolean friendLogsWanted) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_FRIENDLOGS_WANTED, friendLogsWanted);
            }
        });
    }

    public static boolean isLiveList() {
        return sharedPrefs.getBoolean(KEY_LIVE_LIST, true);
    }

    public static void setLiveList(final boolean liveList) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LIVE_LIST, liveList);
            }
        });
    }

    public static boolean isPublicLoc() {
        return sharedPrefs.getBoolean(KEY_PUBLICLOC, false);
    }

    public static void setPublicLoc(final boolean publicLocation) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_PUBLICLOC, publicLocation);
            }
        });
    }

    public static boolean isTrackableAutoVisit() {
        return sharedPrefs.getBoolean(KEY_AUTO_VISIT_TRACKABLES, false);
    }

    public static void setTrackableAutoVisit(final boolean autoVisit) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_AUTO_VISIT_TRACKABLES, autoVisit);
            }
        });
    }

    public static boolean isAutoInsertSignature() {
        return sharedPrefs.getBoolean(KEY_AUTO_INSERT_SIGNATURE, false);
    }

    public static void setAutoInsertSignature(final boolean autoInsert) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_AUTO_INSERT_SIGNATURE, autoInsert);
            }
        });
    }

    public static boolean isUseMetricUnits() {
        return sharedPrefs.getBoolean(KEY_METRIC_UNITS, true);
    }

    public static void setUseMetricUnits(final boolean metric) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_METRIC_UNITS, metric);
            }
        });
    }

    public static boolean isLiveMap() {
        return sharedPrefs.getBoolean(KEY_MAP_LIVE, true);
    }

    public static boolean isMapTrail() {
        return sharedPrefs.getBoolean(KEY_MAP_TRAIL, true);
    }

    public static void setMapTrail(final boolean showTrail) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_MAP_TRAIL, showTrail);
            }
        });
    }

    public static int getMapZoom() {
        return sharedPrefs.getInt(KEY_LAST_MAP_ZOOM, 14);
    }

    public static void setMapZoom(final int mapZoomLevel) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_MAP_ZOOM, mapZoomLevel);
            }
        });
    }

    public static GeoPointImpl getMapCenter() {
        return getMapProvider().getMapItemFactory()
                .getGeoPointBase(new Geopoint(sharedPrefs.getInt(KEY_LAST_MAP_LAT, 0) / 1e6,
                        sharedPrefs.getInt(KEY_LAST_MAP_LON, 0) / 1e6));
    }

    public static void setMapCenter(final GeoPointImpl mapViewCenter) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_MAP_LAT, mapViewCenter.getLatitudeE6());
                edit.putInt(KEY_LAST_MAP_LON, mapViewCenter.getLongitudeE6());
            }
        });
    }

    public static int getMapSource() {
        return sharedPrefs.getInt(KEY_MAP_SOURCE, 0);
    }

    public static void setMapSource(final int newMapSource) {
        if (!MapProviderFactory.isSameActivity(getMapSource(), newMapSource)) {
            mapProvider = null;
        }
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_MAP_SOURCE, newMapSource);
            }
        });
    }

    public static void setAnyCoordinates(final Geopoint coords) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (null != coords) {
                    edit.putFloat(KEY_ANYLATITUDE, (float) coords.getLatitude());
                    edit.putFloat(KEY_ANYLONGITUDE, (float) coords.getLongitude());
                } else {
                    edit.remove(KEY_ANYLATITUDE);
                    edit.remove(KEY_ANYLONGITUDE);
                }
            }
        });

    }

    public static Geopoint getAnyCoordinates() {
        if (sharedPrefs.contains(KEY_ANYLATITUDE) && sharedPrefs.contains(KEY_ANYLONGITUDE)) {
            float lat = sharedPrefs.getFloat(KEY_ANYLATITUDE, 0);
            float lon = sharedPrefs.getFloat(KEY_ANYLONGITUDE, 0);
            return new Geopoint(lat, lon);
        }
        return null;
    }

    public static boolean isUseCompass() {
        return sharedPrefs.getBoolean(KEY_USE_COMPASS, true);
    }

    public static void setUseCompass(final boolean useCompass) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_COMPASS, useCompass);
            }
        });
    }

    public static boolean isHelpShown() {
        return sharedPrefs.getBoolean(KEY_HELP_SHOWN, false);
    }

    public static void setHelpShown() {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_HELP_SHOWN, true);
            }
        });
    }

    public static boolean isLightSkin() {
        return sharedPrefs.getBoolean(KEY_SKIN, false);
    }

    public static void setLightSkin(final boolean lightSkin) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SKIN, lightSkin);
            }
        });
    }

    public static String getKeyConsumerPublic() {
        return keyConsumerPublic;
    }

    public static String getKeyConsumerSecret() {
        return keyConsumerSecret;
    }

    public static int getAltCorrection() {
        return sharedPrefs.getInt(KEY_ALTITUDE_CORRECTION, 0);
    }

    public static boolean setAltCorrection(final int altitude) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_ALTITUDE_CORRECTION, altitude);
            }
        });
    }

    public static String getWebDeviceCode() {
        return sharedPrefs.getString(KEY_WEB_DEVICE_CODE, null);
    }

    public static String getWebDeviceName() {
        return sharedPrefs.getString(KEY_WEBDEVICE_NAME, null);
    }

    /**
     * @return The cache type used for filtering or ALL if no filter is active. Returns never null
     */
    public static CacheType getCacheType() {
        return CacheType.getById(sharedPrefs.getString(KEY_CACHE_TYPE, CacheType.ALL.id));
    }

    /**
     * The Threshold for the showing of child waypoints
     *
     * @return
     */

    public static int getWayPointsThreshold() {
        return sharedPrefs.getInt(KEY_SHOW_WAYPOINTS_THRESHOLD, 0);
    }

    public static void setShowWaypointsThreshold(final int threshold) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_SHOW_WAYPOINTS_THRESHOLD, threshold);
            }
        });
    }

    public static boolean isUseTwitter() {
        return sharedPrefs.getBoolean(KEY_USE_TWITTER, false);
    }

    public static void setUseTwitter(final boolean useTwitter) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_TWITTER, useTwitter);
            }
        });
    }

    public static boolean isTwitterLoginValid() {
        return !StringUtils.isBlank(getTokenPublic()) && !StringUtils.isBlank(getTokenSecret());
    }

    public static String getTokenPublic() {
        return sharedPrefs.getString(KEY_TWITTER_TOKEN_PUBLIC, null);
    }

    public static String getTokenSecret() {
        return sharedPrefs.getString(KEY_TWITTER_TOKEN_SECRET, null);

    }

    public static int getVersion() {
        return sharedPrefs.getInt(KEY_VERSION, 0);
    }

    public static void setTwitterTokens(final String tokenPublic, final String tokenSecret, boolean enableTwitter) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_TWITTER_TOKEN_PUBLIC, tokenPublic);
                edit.putString(KEY_TWITTER_TOKEN_SECRET, tokenSecret);
                if (tokenPublic != null) {
                    edit.remove(KEY_TEMP_TOKEN_PUBLIC);
                    edit.remove(KEY_TEMP_TOKEN_SECRET);
                }
            }
        });
        setUseTwitter(enableTwitter);
    }

    public static void setTwitterTempTokens(final String tokenPublic, final String tokenSecret) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_TEMP_TOKEN_PUBLIC, tokenPublic);
                edit.putString(KEY_TEMP_TOKEN_SECRET, tokenSecret);
            }
        });
    }

    public static ImmutablePair<String, String> getTempToken() {
        String tokenPublic = sharedPrefs.getString(KEY_TEMP_TOKEN_PUBLIC, null);
        String tokenSecret = sharedPrefs.getString(KEY_TEMP_TOKEN_SECRET, null);
        return new ImmutablePair<String, String>(tokenPublic, tokenSecret);
    }

    public static void setVersion(final int version) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_VERSION, version);
            }
        });
    }

    public static boolean isOpenLastDetailsPage() {
        return sharedPrefs.getBoolean(KEY_OPEN_LAST_DETAILS_PAGE, false);
    }

    public static void setOpenLastDetailsPage(final boolean openLastPage) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_OPEN_LAST_DETAILS_PAGE, openLastPage);
            }
        });
    }

    public static int getLastDetailsPage() {
        return sharedPrefs.getInt(KEY_LAST_DETAILS_PAGE, 1);
    }

    public static void setLastDetailsPage(final int index) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_DETAILS_PAGE, index);
            }
        });
    }

    public static int getDefaultNavigationTool() {
        return sharedPrefs.getInt(KEY_DEFAULT_NAVIGATION_TOOL, NavigationAppsEnum.COMPASS.id);
    }

    public static void setDefaultNavigationTool(final int defaultNavigationTool) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_DEFAULT_NAVIGATION_TOOL, defaultNavigationTool);
            }
        });
    }

    public static int getDefaultNavigationTool2() {
        return sharedPrefs.getInt(KEY_DEFAULT_NAVIGATION_TOOL_2, NavigationAppsEnum.INTERNAL_MAP.id);
    }

    public static void setDefaultNavigationTool2(final int defaultNavigationTool) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_DEFAULT_NAVIGATION_TOOL_2, defaultNavigationTool);
            }
        });
    }

    public static Strategy getLiveMapStrategy() {
        return Strategy.getById(sharedPrefs.getInt(KEY_LIVE_MAP_STRATEGY, Strategy.AUTO.id));
    }

    public static void setLiveMapStrategy(final Strategy strategy) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LIVE_MAP_STRATEGY, strategy.id);
            }
        });
    }

    public static boolean isDebug() {
        return Log.isDebug();
    }

    public static void setDebug(final boolean debug) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_DEBUG, debug);
            }
        });
        Log.setDebugUnsaved(debug);
    }

    public static boolean getHideLiveMapHint() {
        return sharedPrefs.getBoolean(KEY_HIDE_LIVE_MAP_HINT, false);
    }

    public static void setHideLiveHint(final boolean hide) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_HIDE_LIVE_MAP_HINT, hide);
            }
        });
    }

    public static int getLiveMapHintShowCount() {
        return sharedPrefs.getInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, 0);
    }

    public static void setLiveMapHintShowCount(final int showCount) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, showCount);
            }
        });
    }

    public static boolean isDbOnSDCard() {
        return sharedPrefs.getBoolean(KEY_DB_ON_SDCARD, false);
    }

    public static void setDbOnSDCard(final boolean dbOnSDCard) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_DB_ON_SDCARD, dbOnSDCard);
            }
        });
    }

    public static void setShareAfterExport(final boolean shareAfterExport) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SHARE_AFTER_EXPORT, shareAfterExport);
            }
        });
    }

    public static int getTrackableAction() {
        return sharedPrefs.getInt(KEY_LAST_TRACKABLE_ACTION, LogType.RETRIEVED_IT.id);
    }

    public static void setTrackableAction(final int trackableAction) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_TRACKABLE_ACTION, trackableAction);
            }
        });
	}

    public static boolean getShareAfterExport() {
        return sharedPrefs.getBoolean(KEY_SHARE_AFTER_EXPORT, true);
    }

    public static String getPreferencesName() {
        // there is currently no Android API to get the file name of the shared preferences
        return cgeoapplication.getInstance().getPackageName() + "_preferences";
    }

}
!@#$%
20190527_000018,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_a16056
package cgeo.geocaching;

import cgeo.geocaching.apps.cache.navi.NavigationAppFactory.NavigationAppsEnum;
import cgeo.geocaching.connector.gc.GCConstants;
import cgeo.geocaching.connector.gc.Login;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.LiveMapStrategy.Strategy;
import cgeo.geocaching.enumerations.LogType;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.maps.MapProviderFactory;
import cgeo.geocaching.maps.interfaces.MapProvider;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider;
import cgeo.geocaching.utils.CryptUtils;
import cgeo.geocaching.utils.Log;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.preference.PreferenceManager;

import java.util.Locale;

/**
 * General c:geo preferences/settings set by the user
 */
public final class Settings {

    private static final String KEY_TEMP_TOKEN_SECRET = "temp-token-secret";
    private static final String KEY_TEMP_TOKEN_PUBLIC = "temp-token-public";
    private static final String KEY_HELP_SHOWN = "helper";
    private static final String KEY_ANYLONGITUDE = "anylongitude";
    private static final String KEY_ANYLATITUDE = "anylatitude";
    private static final String KEY_PUBLICLOC = "publicloc";
    private static final String KEY_USE_OFFLINEMAPS = "offlinemaps";
    private static final String KEY_USE_OFFLINEWPMAPS = "offlinewpmaps";
    private static final String KEY_WEB_DEVICE_CODE = "webDeviceCode";
    private static final String KEY_WEBDEVICE_NAME = "webDeviceName";
    private static final String KEY_MAP_LIVE = "maplive";
    private static final String KEY_MAP_SOURCE = "mapsource";
    private static final String KEY_USE_TWITTER = "twitter";
    private static final String KEY_SHOW_ADDRESS = "showaddress";
    private static final String KEY_SHOW_CAPTCHA = "showcaptcha";
    private static final String KEY_MAP_TRAIL = "maptrail";
    private static final String KEY_LAST_MAP_ZOOM = "mapzoom";
    private static final String KEY_LIVE_LIST = "livelist";
    private static final String KEY_METRIC_UNITS = "units";
    private static final String KEY_SKIN = "skin";
    private static final String KEY_LAST_USED_LIST = "lastlist";
    private static final String KEY_CACHE_TYPE = "cachetype";
    private static final String KEY_TWITTER_TOKEN_SECRET = "tokensecret";
    private static final String KEY_TWITTER_TOKEN_PUBLIC = "tokenpublic";
    private static final String KEY_VERSION = "version";
    private static final String KEY_LOAD_DESCRIPTION = "autoloaddesc";
    private static final String KEY_RATING_WANTED = "ratingwanted";
    private static final String KEY_ELEVATION_WANTED = "elevationwanted";
    private static final String KEY_FRIENDLOGS_WANTED = "friendlogswanted";
    private static final String KEY_USE_ENGLISH = "useenglish";
    private static final String KEY_USE_COMPASS = "usecompass";
    private static final String KEY_AUTO_VISIT_TRACKABLES = "trackautovisit";
    private static final String KEY_AUTO_INSERT_SIGNATURE = "sigautoinsert";
    private static final String KEY_ALTITUDE_CORRECTION = "altcorrection";
    private static final String KEY_USE_GOOGLE_NAVIGATION = "usegnav";
    private static final String KEY_STORE_LOG_IMAGES = "logimages";
    private static final String KEY_EXCLUDE_DISABLED = "excludedisabled";
    private static final String KEY_EXCLUDE_OWN = "excludemine";
    private static final String KEY_MAPFILE = "mfmapfile";
    private static final String KEY_SIGNATURE = "signature";
    private static final String KEY_GCVOTE_PASSWORD = "pass-vote";
    private static final String KEY_PASSWORD = "password";
    private static final String KEY_USERNAME = "username";
    private static final String KEY_MEMBER_STATUS = "memberstatus";
    private static final String KEY_COORD_INPUT_FORMAT = "coordinputformat";
    private static final String KEY_LOG_OFFLINE = "log_offline";
    private static final String KEY_LOAD_DIRECTION_IMG = "loaddirectionimg";
    private static final String KEY_GC_CUSTOM_DATE = "gccustomdate";
    private static final String KEY_SHOW_WAYPOINTS_THRESHOLD = "gcshowwaypointsthreshold";
    private static final String KEY_COOKIE_STORE = "cookiestore";
    private static final String KEY_OPEN_LAST_DETAILS_PAGE = "opendetailslastpage";
    private static final String KEY_LAST_DETAILS_PAGE = "lastdetailspage";
    private static final String KEY_DEFAULT_NAVIGATION_TOOL = "defaultNavigationTool";
    private static final String KEY_DEFAULT_NAVIGATION_TOOL_2 = "defaultNavigationTool2";
    private static final String KEY_LIVE_MAP_STRATEGY = "livemapstrategy";
    private static final String KEY_DEBUG = "debug";
    private static final String KEY_HIDE_LIVE_MAP_HINT = "hidelivemaphint";
    private static final String KEY_LIVE_MAP_HINT_SHOW_COUNT = "livemaphintshowcount";
    private static final String KEY_SETTINGS_VERSION = "settingsversion";
    private static final String KEY_DB_ON_SDCARD = "dbonsdcard";
    private static final String KEY_LAST_TRACKABLE_ACTION = "trackableaction";

    private final static int unitsMetric = 1;

    // twitter api keys
    private final static String keyConsumerPublic = CryptUtils.rot13("ESnsCvAv3kEupF1GCR3jGj");
    private final static String keyConsumerSecret = CryptUtils.rot13("7vQWceACV9umEjJucmlpFe9FCMZSeqIqfkQ2BnhV9x");

    private interface PrefRunnable {
        void edit(final Editor edit);
    }

    public enum coordInputFormatEnum {
        Plain,
        Deg,
        Min,
        Sec;

        static coordInputFormatEnum fromInt(int id) {
            final coordInputFormatEnum[] values = coordInputFormatEnum.values();
            if (id < 0 || id >= values.length) {
                return Min;
            }
            return values[id];
        }
    }

    private static String username = null;
    private static String password = null;

    private static final SharedPreferences sharedPrefs = PreferenceManager.getDefaultSharedPreferences(cgeoapplication.getInstance().getBaseContext());
    static {
        migrateSettings();
        Log.setDebugUnsaved(sharedPrefs.getBoolean(KEY_DEBUG, false));
    }

    // maps
    private static MapProvider mapProvider = null;

    private Settings() {
        // this class is not to be instantiated;
    }

    private static void migrateSettings() {
        // migrate from non standard file location and integer based boolean types
        if (sharedPrefs.getInt(KEY_SETTINGS_VERSION, 0) < 1) {
            final String oldPreferencesName = "cgeo.pref";
            final SharedPreferences old = cgeoapplication.getInstance().getSharedPreferences(oldPreferencesName, Context.MODE_PRIVATE);
            final Editor e = sharedPrefs.edit();

            e.putString(KEY_TEMP_TOKEN_SECRET, old.getString(KEY_TEMP_TOKEN_SECRET, null));
            e.putString(KEY_TEMP_TOKEN_PUBLIC, old.getString(KEY_TEMP_TOKEN_PUBLIC, null));
            e.putBoolean(KEY_HELP_SHOWN, old.getInt(KEY_HELP_SHOWN, 0) != 0);
            e.putFloat(KEY_ANYLONGITUDE, old.getFloat(KEY_ANYLONGITUDE, 0));
            e.putFloat(KEY_ANYLATITUDE, old.getFloat(KEY_ANYLATITUDE, 0));
            e.putBoolean(KEY_PUBLICLOC, 0 != old.getInt(KEY_PUBLICLOC, 0));
            e.putBoolean(KEY_USE_OFFLINEMAPS, 0 != old.getInt(KEY_USE_OFFLINEMAPS, 1));
            e.putBoolean(KEY_USE_OFFLINEWPMAPS, 0 != old.getInt(KEY_USE_OFFLINEWPMAPS, 0));
            e.putString(KEY_WEB_DEVICE_CODE, old.getString(KEY_WEB_DEVICE_CODE, null));
            e.putString(KEY_WEBDEVICE_NAME, old.getString(KEY_WEBDEVICE_NAME, null));
            e.putBoolean(KEY_MAP_LIVE, old.getInt(KEY_MAP_LIVE, 1) != 0);
            e.putInt(KEY_MAP_SOURCE, old.getInt(KEY_MAP_SOURCE, 0));
            e.putBoolean(KEY_USE_TWITTER, 0 != old.getInt(KEY_USE_TWITTER, 0));
            e.putBoolean(KEY_SHOW_ADDRESS, 0 != old.getInt(KEY_SHOW_ADDRESS, 1));
            e.putBoolean(KEY_SHOW_CAPTCHA, old.getBoolean(KEY_SHOW_CAPTCHA, false));
            e.putBoolean(KEY_MAP_TRAIL, old.getInt(KEY_MAP_TRAIL, 1) != 0);
            e.putInt(KEY_LAST_MAP_ZOOM, old.getInt(KEY_LAST_MAP_ZOOM, 14));
            e.putBoolean(KEY_LIVE_LIST, 0 != old.getInt(KEY_LIVE_LIST, 1));
            e.putBoolean(KEY_METRIC_UNITS, old.getInt(KEY_METRIC_UNITS, unitsMetric) == unitsMetric);
            e.putBoolean(KEY_SKIN, old.getInt(KEY_SKIN, 0) != 0);
            e.putInt(KEY_LAST_USED_LIST, old.getInt(KEY_LAST_USED_LIST, StoredList.STANDARD_LIST_ID));
            e.putString(KEY_CACHE_TYPE, old.getString(KEY_CACHE_TYPE, CacheType.ALL.id));
            e.putString(KEY_TWITTER_TOKEN_SECRET, old.getString(KEY_TWITTER_TOKEN_SECRET, null));
            e.putString(KEY_TWITTER_TOKEN_PUBLIC, old.getString(KEY_TWITTER_TOKEN_PUBLIC, null));
            e.putInt(KEY_VERSION, old.getInt(KEY_VERSION, 0));
            e.putBoolean(KEY_LOAD_DESCRIPTION, 0 != old.getInt(KEY_LOAD_DESCRIPTION, 0));
            e.putBoolean(KEY_RATING_WANTED, old.getBoolean(KEY_RATING_WANTED, true));
            e.putBoolean(KEY_ELEVATION_WANTED, old.getBoolean(KEY_ELEVATION_WANTED, true));
            e.putBoolean(KEY_FRIENDLOGS_WANTED, old.getBoolean(KEY_FRIENDLOGS_WANTED, true));
            e.putBoolean(KEY_USE_ENGLISH, old.getBoolean(KEY_USE_ENGLISH, false));
            e.putBoolean(KEY_USE_COMPASS, 0 != old.getInt(KEY_USE_COMPASS, 1));
            e.putBoolean(KEY_AUTO_VISIT_TRACKABLES, old.getBoolean(KEY_AUTO_VISIT_TRACKABLES, false));
            e.putBoolean(KEY_AUTO_INSERT_SIGNATURE, old.getBoolean(KEY_AUTO_INSERT_SIGNATURE, false));
            e.putInt(KEY_ALTITUDE_CORRECTION, old.getInt(KEY_ALTITUDE_CORRECTION, 0));
            e.putBoolean(KEY_USE_GOOGLE_NAVIGATION, 0 != old.getInt(KEY_USE_GOOGLE_NAVIGATION, 1));
            e.putBoolean(KEY_STORE_LOG_IMAGES, old.getBoolean(KEY_STORE_LOG_IMAGES, false));
            e.putBoolean(KEY_EXCLUDE_DISABLED, 0 != old.getInt(KEY_EXCLUDE_DISABLED, 0));
            e.putBoolean(KEY_EXCLUDE_OWN, 0 != old.getInt(KEY_EXCLUDE_OWN, 0));
            e.putString(KEY_MAPFILE, old.getString(KEY_MAPFILE, null));
            e.putString(KEY_SIGNATURE, old.getString(KEY_SIGNATURE, null));
            e.putString(KEY_GCVOTE_PASSWORD, old.getString(KEY_GCVOTE_PASSWORD, null));
            e.putString(KEY_PASSWORD, old.getString(KEY_PASSWORD, null));
            e.putString(KEY_USERNAME, old.getString(KEY_USERNAME, null));
            e.putString(KEY_MEMBER_STATUS, old.getString(KEY_MEMBER_STATUS, ""));
            e.putInt(KEY_COORD_INPUT_FORMAT, old.getInt(KEY_COORD_INPUT_FORMAT, 0));
            e.putBoolean(KEY_LOG_OFFLINE, old.getBoolean(KEY_LOG_OFFLINE, false));
            e.putBoolean(KEY_LOAD_DIRECTION_IMG, old.getBoolean(KEY_LOAD_DIRECTION_IMG, true));
            e.putString(KEY_GC_CUSTOM_DATE, old.getString(KEY_GC_CUSTOM_DATE, null));
            e.putInt(KEY_SHOW_WAYPOINTS_THRESHOLD, old.getInt(KEY_SHOW_WAYPOINTS_THRESHOLD, 0));
            e.putString(KEY_COOKIE_STORE, old.getString(KEY_COOKIE_STORE, null));
            e.putBoolean(KEY_OPEN_LAST_DETAILS_PAGE, old.getBoolean(KEY_OPEN_LAST_DETAILS_PAGE, false));
            e.putInt(KEY_LAST_DETAILS_PAGE, old.getInt(KEY_LAST_DETAILS_PAGE, 1));
            e.putInt(KEY_DEFAULT_NAVIGATION_TOOL, old.getInt(KEY_DEFAULT_NAVIGATION_TOOL, 0));
            e.putInt(KEY_DEFAULT_NAVIGATION_TOOL_2, old.getInt(KEY_DEFAULT_NAVIGATION_TOOL_2, 0));
            e.putInt(KEY_LIVE_MAP_STRATEGY, old.getInt(KEY_LIVE_MAP_STRATEGY, Strategy.AUTO.id));
            e.putBoolean(KEY_DEBUG, old.getBoolean(KEY_DEBUG, false));
            e.putBoolean(KEY_HIDE_LIVE_MAP_HINT, old.getInt(KEY_HIDE_LIVE_MAP_HINT, 0) != 0);
            e.putInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, old.getInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, 0));

            e.putInt(KEY_SETTINGS_VERSION, 1) ; // mark migrated
            e.commit();
        }
    }

    public static void setLanguage(boolean useEnglish) {
        final Configuration config = new Configuration();
        config.locale = useEnglish ? new Locale("en") : Locale.getDefault();
        final Resources resources = cgeoapplication.getInstance().getResources();
        resources.updateConfiguration(config, resources.getDisplayMetrics());
    }

    public static boolean isLogin() {
        final String preUsername = sharedPrefs.getString(KEY_USERNAME, null);
        final String prePassword = sharedPrefs.getString(KEY_PASSWORD, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    /**
     * Get login and password information.
     *
     * @return a pair (login, password) or null if no valid information is stored
     */
    public static ImmutablePair<String, String> getLogin() {
        if (username == null || password == null) {
            final String preUsername = sharedPrefs.getString(KEY_USERNAME, null);
            final String prePassword = sharedPrefs.getString(KEY_PASSWORD, null);

            if (preUsername == null || prePassword == null) {
                return null;
            }

            username = preUsername;
            password = prePassword;
        }
        return new ImmutablePair<String, String>(username, password);
    }

    public static String getUsername() {
        return username != null ? username : sharedPrefs.getString(KEY_USERNAME, null);
    }

    public static boolean setLogin(final String username, final String password) {
        Settings.username = username;
        Settings.password = password;
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
                    // erase username and password
                    edit.remove(KEY_USERNAME);
                    edit.remove(KEY_PASSWORD);
                } else {
                    // save username and password
                    edit.putString(KEY_USERNAME, username);
                    edit.putString(KEY_PASSWORD, password);
                }
            }
        });
    }

    public static boolean isPremiumMember() {
        // Basic Member, Premium Member, ???
        String memberStatus = Settings.getMemberStatus();
        if (memberStatus == null) {
            return false;
        }
        return GCConstants.MEMBER_STATUS_PM.equalsIgnoreCase(memberStatus);
    }

    public static String getMemberStatus() {
        return sharedPrefs.getString(KEY_MEMBER_STATUS, "");
    }

    public static boolean setMemberStatus(final String memberStatus) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(memberStatus)) {
                    edit.remove(KEY_MEMBER_STATUS);
                } else {
                    edit.putString(KEY_MEMBER_STATUS, memberStatus);
                }
            }
        });
    }

    public static boolean isGCvoteLogin() {
        final String preUsername = sharedPrefs.getString(KEY_USERNAME, null);
        final String prePassword = sharedPrefs.getString(KEY_GCVOTE_PASSWORD, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    public static boolean setGCvoteLogin(final String password) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(password)) {
                    // erase password
                    edit.remove(KEY_GCVOTE_PASSWORD);
                } else {
                    // save password
                    edit.putString(KEY_GCVOTE_PASSWORD, password);
                }
            }
        });
    }

    public static ImmutablePair<String, String> getGCvoteLogin() {
        final String username = sharedPrefs.getString(KEY_USERNAME, null);
        final String password = sharedPrefs.getString(KEY_GCVOTE_PASSWORD, null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return null;
        }

        return new ImmutablePair<String, String>(username, password);
    }

    public static boolean setSignature(final String signature) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(signature)) {
                    // erase signature
                    edit.remove(KEY_SIGNATURE);
                } else {
                    // save signature
                    edit.putString(KEY_SIGNATURE, signature);
                }
            }
        });
    }

    public static String getSignature() {
        return sharedPrefs.getString(KEY_SIGNATURE, null);
    }

    public static boolean setCookieStore(final String cookies) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(final Editor edit) {
                if (StringUtils.isBlank(cookies)) {
                    // erase cookies
                    edit.remove(KEY_COOKIE_STORE);
                } else {
                    // save cookies
                    edit.putString(KEY_COOKIE_STORE, cookies);
                }
            }
        });
    }

    public static String getCookieStore() {
        return sharedPrefs.getString(KEY_COOKIE_STORE, null);
    }

    /**
     * @param cacheType
     *            The cache type used for future filtering
     */
    public static void setCacheType(final CacheType cacheType) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                if (cacheType == null) {
                    edit.remove(KEY_CACHE_TYPE);
                } else {
                    edit.putString(KEY_CACHE_TYPE, cacheType.id);
                }
            }
        });
    }

    public static void setLiveMap(final boolean live) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_MAP_LIVE, live);
            }
        });
    }

    public static int getLastList() {
        return sharedPrefs.getInt(KEY_LAST_USED_LIST, StoredList.STANDARD_LIST_ID);
    }

    public static void saveLastList(final int listId) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_USED_LIST, listId);
            }
        });
    }

    public static void setWebNameCode(final String name, final String code) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {

                edit.putString(KEY_WEBDEVICE_NAME, name);
                edit.putString(KEY_WEB_DEVICE_CODE, code);
            }
        });
    }

    public static MapProvider getMapProvider() {
        if (mapProvider == null) {
            mapProvider = MapProviderFactory.getMapProvider(getMapSource());
        }
        return mapProvider;
    }

    public static String getMapFile() {
        return sharedPrefs.getString(KEY_MAPFILE, null);
    }

    public static boolean setMapFile(final String mapFile) {
        return editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_MAPFILE, mapFile);
            }
        });
    }

    public static boolean isValidMapFile() {
        return isValidMapFile(getMapFile());
    }

    public static boolean isValidMapFile(final String mapFileIn) {
        return MapsforgeMapProvider.isValidMapFile(mapFileIn);
    }

    public static coordInputFormatEnum getCoordInputFormat() {
        return coordInputFormatEnum.fromInt(sharedPrefs.getInt(KEY_COORD_INPUT_FORMAT, 0));
    }

    public static void setCoordInputFormat(final coordInputFormatEnum format) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_COORD_INPUT_FORMAT, format.ordinal());
            }
        });
    }

    static void setLogOffline(final boolean offline) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LOG_OFFLINE, offline);
            }
        });
    }

    public static boolean getLogOffline() {
        return sharedPrefs.getBoolean(KEY_LOG_OFFLINE, false);
    }

    static void setLoadDirImg(final boolean value) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LOAD_DIRECTION_IMG, value);
            }
        });
    }

    public static boolean getLoadDirImg() {
        return !isPremiumMember() && sharedPrefs.getBoolean(KEY_LOAD_DIRECTION_IMG, true);
    }

    public static void setGcCustomDate(final String format) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_GC_CUSTOM_DATE, format);
            }
        });
    }

    /**
     * @return User selected date format on GC.com
     * @see Login#gcCustomDateFormats
     */
    public static String getGcCustomDate() {
        return sharedPrefs.getString(KEY_GC_CUSTOM_DATE, null);
    }

    public static boolean isExcludeMyCaches() {
        return sharedPrefs.getBoolean(KEY_EXCLUDE_OWN, false);
    }

    /**
     * edit some settings without knowing how to get the settings editor or how to commit
     *
     * @param runnable
     * @return
     */
    private static boolean editSharedSettings(final PrefRunnable runnable) {
        final SharedPreferences.Editor prefsEdit = sharedPrefs.edit();
        runnable.edit(prefsEdit);
        return prefsEdit.commit();
    }

    public static void setExcludeMine(final boolean exclude) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_EXCLUDE_OWN, exclude);
            }
        });
    }

    public static void setUseEnglish(final boolean english) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_ENGLISH, english);
                setLanguage(english);
            }
        });
    }

    public static boolean isUseEnglish() {
        return sharedPrefs.getBoolean(KEY_USE_ENGLISH, false);
    }

    public static boolean isShowAddress() {
        return sharedPrefs.getBoolean(KEY_SHOW_ADDRESS, true);
    }

    public static void setShowAddress(final boolean showAddress) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SHOW_ADDRESS, showAddress);
            }
        });
    }

    public static boolean isShowCaptcha() {
        return !isPremiumMember() && sharedPrefs.getBoolean(KEY_SHOW_CAPTCHA, false);
    }

    public static void setShowCaptcha(final boolean showCaptcha) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SHOW_CAPTCHA, showCaptcha);
            }
        });
    }

    public static boolean isExcludeDisabledCaches() {
        return sharedPrefs.getBoolean(KEY_EXCLUDE_DISABLED, false);
    }

    public static void setExcludeDisabledCaches(final boolean exclude) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_EXCLUDE_DISABLED, exclude);
            }
        });
    }

    public static boolean isStoreOfflineMaps() {
        return sharedPrefs.getBoolean(KEY_USE_OFFLINEMAPS, true);
    }

    public static void setStoreOfflineMaps(final boolean offlineMaps) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_OFFLINEMAPS, offlineMaps);
            }
        });
    }

    public static boolean isStoreOfflineWpMaps() {
        return sharedPrefs.getBoolean(KEY_USE_OFFLINEWPMAPS, false);
    }

    public static void setStoreOfflineWpMaps(final boolean offlineMaps) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_OFFLINEWPMAPS, offlineMaps);
            }
        });
    }

    public static boolean isStoreLogImages() {
        return sharedPrefs.getBoolean(KEY_STORE_LOG_IMAGES, false);
    }

    public static void setStoreLogImages(final boolean storeLogImages) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_STORE_LOG_IMAGES, storeLogImages);
            }
        });
    }

    public static boolean isUseGoogleNavigation() {
        return sharedPrefs.getBoolean(KEY_USE_GOOGLE_NAVIGATION, true);
    }

    public static void setUseGoogleNavigation(final boolean useGoogleNavigation) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_GOOGLE_NAVIGATION, useGoogleNavigation);
            }
        });
    }

    public static boolean isAutoLoadDescription() {
        return sharedPrefs.getBoolean(KEY_LOAD_DESCRIPTION, false);
    }

    public static void setAutoLoadDesc(final boolean autoLoad) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LOAD_DESCRIPTION, autoLoad);
            }
        });
    }

    public static boolean isRatingWanted() {
        return sharedPrefs.getBoolean(KEY_RATING_WANTED, true);
    }

    public static void setRatingWanted(final boolean ratingWanted) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_RATING_WANTED, ratingWanted);
            }
        });
    }

    public static boolean isElevationWanted() {
        return sharedPrefs.getBoolean(KEY_ELEVATION_WANTED, true);
    }

    public static void setElevationWanted(final boolean elevationWanted) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_ELEVATION_WANTED, elevationWanted);
            }
        });
    }

    public static boolean isFriendLogsWanted() {
        if (!isLogin()) {
            // don't show a friends log if the user is anonymous
            return false;
        }
        return sharedPrefs.getBoolean(KEY_FRIENDLOGS_WANTED, true);
    }

    public static void setFriendLogsWanted(final boolean friendLogsWanted) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_FRIENDLOGS_WANTED, friendLogsWanted);
            }
        });
    }

    public static boolean isLiveList() {
        return sharedPrefs.getBoolean(KEY_LIVE_LIST, true);
    }

    public static void setLiveList(final boolean liveList) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LIVE_LIST, liveList);
            }
        });
    }

    public static boolean isPublicLoc() {
        return sharedPrefs.getBoolean(KEY_PUBLICLOC, false);
    }

    public static void setPublicLoc(final boolean publicLocation) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_PUBLICLOC, publicLocation);
            }
        });
    }

    public static boolean isTrackableAutoVisit() {
        return sharedPrefs.getBoolean(KEY_AUTO_VISIT_TRACKABLES, false);
    }

    public static void setTrackableAutoVisit(final boolean autoVisit) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_AUTO_VISIT_TRACKABLES, autoVisit);
            }
        });
    }

    public static boolean isAutoInsertSignature() {
        return sharedPrefs.getBoolean(KEY_AUTO_INSERT_SIGNATURE, false);
    }

    public static void setAutoInsertSignature(final boolean autoInsert) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_AUTO_INSERT_SIGNATURE, autoInsert);
            }
        });
    }

    public static boolean isUseMetricUnits() {
        return sharedPrefs.getBoolean(KEY_METRIC_UNITS, true);
    }

    public static void setUseMetricUnits(final boolean metric) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_METRIC_UNITS, metric);
            }
        });
    }

    public static boolean isLiveMap() {
        return sharedPrefs.getBoolean(KEY_MAP_LIVE, true);
    }

    public static boolean isMapTrail() {
        return sharedPrefs.getBoolean(KEY_MAP_TRAIL, true);
    }

    public static void setMapTrail(final boolean showTrail) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_MAP_TRAIL, showTrail);
            }
        });
    }

    public static int getMapZoom() {
        return sharedPrefs.getInt(KEY_LAST_MAP_ZOOM, 14);
    }

    public static void setMapZoom(final int mapZoomLevel) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_MAP_ZOOM, mapZoomLevel);
            }
        });
    }

    public static int getMapSource() {
        return sharedPrefs.getInt(KEY_MAP_SOURCE, 0);
    }

    public static void setMapSource(final int newMapSource) {
        if (!MapProviderFactory.isSameActivity(getMapSource(), newMapSource)) {
            mapProvider = null;
        }
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_MAP_SOURCE, newMapSource);
            }
        });
    }

    public static void setAnyCoordinates(final Geopoint coords) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (null != coords) {
                    edit.putFloat(KEY_ANYLATITUDE, (float) coords.getLatitude());
                    edit.putFloat(KEY_ANYLONGITUDE, (float) coords.getLongitude());
                } else {
                    edit.remove(KEY_ANYLATITUDE);
                    edit.remove(KEY_ANYLONGITUDE);
                }
            }
        });

    }

    public static Geopoint getAnyCoordinates() {
        if (sharedPrefs.contains(KEY_ANYLATITUDE) && sharedPrefs.contains(KEY_ANYLONGITUDE)) {
            float lat = sharedPrefs.getFloat(KEY_ANYLATITUDE, 0);
            float lon = sharedPrefs.getFloat(KEY_ANYLONGITUDE, 0);
            return new Geopoint(lat, lon);
        }
        return null;
    }

    public static boolean isUseCompass() {
        return sharedPrefs.getBoolean(KEY_USE_COMPASS, true);
    }

    public static void setUseCompass(final boolean useCompass) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_COMPASS, useCompass);
            }
        });
    }

    public static boolean isHelpShown() {
        return sharedPrefs.getBoolean(KEY_HELP_SHOWN, false);
    }

    public static void setHelpShown() {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_HELP_SHOWN, true);
            }
        });
    }

    public static boolean isLightSkin() {
        return sharedPrefs.getBoolean(KEY_SKIN, false);
    }

    public static void setLightSkin(final boolean lightSkin) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SKIN, lightSkin);
            }
        });
    }

    public static String getKeyConsumerPublic() {
        return keyConsumerPublic;
    }

    public static String getKeyConsumerSecret() {
        return keyConsumerSecret;
    }

    public static int getAltCorrection() {
        return sharedPrefs.getInt(KEY_ALTITUDE_CORRECTION, 0);
    }

    public static boolean setAltCorrection(final int altitude) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_ALTITUDE_CORRECTION, altitude);
            }
        });
    }

    public static String getWebDeviceCode() {
        return sharedPrefs.getString(KEY_WEB_DEVICE_CODE, null);
    }

    public static String getWebDeviceName() {
        return sharedPrefs.getString(KEY_WEBDEVICE_NAME, null);
    }

    /**
     * @return The cache type used for filtering or ALL if no filter is active. Returns never null
     */
    public static CacheType getCacheType() {
        return CacheType.getById(sharedPrefs.getString(KEY_CACHE_TYPE, CacheType.ALL.id));
    }

    /**
     * The Threshold for the showing of child waypoints
     *
     * @return
     */

    public static int getWayPointsThreshold() {
        return sharedPrefs.getInt(KEY_SHOW_WAYPOINTS_THRESHOLD, 0);
    }

    public static void setShowWaypointsThreshold(final int threshold) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_SHOW_WAYPOINTS_THRESHOLD, threshold);
            }
        });
    }

    public static boolean isUseTwitter() {
        return sharedPrefs.getBoolean(KEY_USE_TWITTER, false);
    }

    public static void setUseTwitter(final boolean useTwitter) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_TWITTER, useTwitter);
            }
        });
    }

    public static boolean isTwitterLoginValid() {
        return !StringUtils.isBlank(getTokenPublic()) && !StringUtils.isBlank(getTokenSecret());
    }

    public static String getTokenPublic() {
        return sharedPrefs.getString(KEY_TWITTER_TOKEN_PUBLIC, null);
    }

    public static String getTokenSecret() {
        return sharedPrefs.getString(KEY_TWITTER_TOKEN_SECRET, null);

    }

    public static int getVersion() {
        return sharedPrefs.getInt(KEY_VERSION, 0);
    }

    public static void setTwitterTokens(final String tokenPublic, final String tokenSecret, boolean enableTwitter) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_TWITTER_TOKEN_PUBLIC, tokenPublic);
                edit.putString(KEY_TWITTER_TOKEN_SECRET, tokenSecret);
                if (tokenPublic != null) {
                    edit.remove(KEY_TEMP_TOKEN_PUBLIC);
                    edit.remove(KEY_TEMP_TOKEN_SECRET);
                }
            }
        });
        setUseTwitter(enableTwitter);
    }

    public static void setTwitterTempTokens(final String tokenPublic, final String tokenSecret) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_TEMP_TOKEN_PUBLIC, tokenPublic);
                edit.putString(KEY_TEMP_TOKEN_SECRET, tokenSecret);
            }
        });
    }

    public static ImmutablePair<String, String> getTempToken() {
        String tokenPublic = sharedPrefs.getString(KEY_TEMP_TOKEN_PUBLIC, null);
        String tokenSecret = sharedPrefs.getString(KEY_TEMP_TOKEN_SECRET, null);
        return new ImmutablePair<String, String>(tokenPublic, tokenSecret);
    }

    public static void setVersion(final int version) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_VERSION, version);
            }
        });
    }

    public static boolean isOpenLastDetailsPage() {
        return sharedPrefs.getBoolean(KEY_OPEN_LAST_DETAILS_PAGE, false);
    }

    public static void setOpenLastDetailsPage(final boolean openLastPage) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_OPEN_LAST_DETAILS_PAGE, openLastPage);
            }
        });
    }

    public static int getLastDetailsPage() {
        return sharedPrefs.getInt(KEY_LAST_DETAILS_PAGE, 1);
    }

    public static void setLastDetailsPage(final int index) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_DETAILS_PAGE, index);
            }
        });
    }

    public static int getDefaultNavigationTool() {
        return sharedPrefs.getInt(KEY_DEFAULT_NAVIGATION_TOOL, NavigationAppsEnum.COMPASS.id);
    }

    public static void setDefaultNavigationTool(final int defaultNavigationTool) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_DEFAULT_NAVIGATION_TOOL, defaultNavigationTool);
            }
        });
    }

    public static int getDefaultNavigationTool2() {
        return sharedPrefs.getInt(KEY_DEFAULT_NAVIGATION_TOOL_2, NavigationAppsEnum.INTERNAL_MAP.id);
    }

    public static void setDefaultNavigationTool2(final int defaultNavigationTool) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_DEFAULT_NAVIGATION_TOOL_2, defaultNavigationTool);
            }
        });
    }

    public static Strategy getLiveMapStrategy() {
        return Strategy.getById(sharedPrefs.getInt(KEY_LIVE_MAP_STRATEGY, Strategy.AUTO.id));
    }

    public static void setLiveMapStrategy(final Strategy strategy) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LIVE_MAP_STRATEGY, strategy.id);
            }
        });
    }


    public static boolean isDebug() {
        return Log.isDebug();
    }

    public static void setDebug(final boolean debug) {
        editSharedSettings(new PrefRunnable() {

            @Override public void edit(Editor edit) {
                edit.putBoolean(KEY_DEBUG, debug);
            }
        });
        Log.setDebugUnsaved(debug);
    }

    public static boolean getHideLiveMapHint() {
        return sharedPrefs.getBoolean(KEY_HIDE_LIVE_MAP_HINT, false);
    }

    public static void setHideLiveHint(final boolean hide) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_HIDE_LIVE_MAP_HINT, hide);
            }
        });
    }

    public static int getLiveMapHintShowCount() {
        return sharedPrefs.getInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, 0);
    }

    public static void setLiveMapHintShowCount(final int showCount) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, showCount);
            }
        });
    }

    public static boolean isDbOnSDCard() {
        return sharedPrefs.getBoolean(KEY_DB_ON_SDCARD, false);
    }

    public static void setDbOnSDCard(final boolean dbOnSDCard) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_DB_ON_SDCARD, dbOnSDCard);
            }
        });
    }

    public static int getTrackableAction() {
        return sharedPrefs.getInt(KEY_LAST_TRACKABLE_ACTION, LogType.RETRIEVED_IT.id);
    }

    public static void setTrackableAction(final int trackableAction) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_TRACKABLE_ACTION, trackableAction);
            }
        });
    }

    public static String getPreferencesName() {
        // there is currently no Android API to get the file name of the shared preferences
        return cgeoapplication.getInstance().getPackageName() + "_preferences";
    }
}
!@#$%
20190527_000018,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_c16056
package cgeo.geocaching;

import cgeo.geocaching.apps.cache.navi.NavigationAppFactory.NavigationAppsEnum;
import cgeo.geocaching.connector.gc.GCConstants;
import cgeo.geocaching.connector.gc.Login;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.LiveMapStrategy.Strategy;
import cgeo.geocaching.enumerations.LogType;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.maps.MapProviderFactory;
import cgeo.geocaching.maps.interfaces.GeoPointImpl;
import cgeo.geocaching.maps.interfaces.MapProvider;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider;
import cgeo.geocaching.utils.CryptUtils;
import cgeo.geocaching.utils.Log;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.preference.PreferenceManager;

import java.util.Locale;

/**
 * General c:geo preferences/settings set by the user
 */
public final class Settings {

    private static final String KEY_TEMP_TOKEN_SECRET = "temp-token-secret";
    private static final String KEY_TEMP_TOKEN_PUBLIC = "temp-token-public";
    private static final String KEY_HELP_SHOWN = "helper";
    private static final String KEY_ANYLONGITUDE = "anylongitude";
    private static final String KEY_ANYLATITUDE = "anylatitude";
    private static final String KEY_PUBLICLOC = "publicloc";
    private static final String KEY_USE_OFFLINEMAPS = "offlinemaps";
    private static final String KEY_USE_OFFLINEWPMAPS = "offlinewpmaps";
    private static final String KEY_WEB_DEVICE_CODE = "webDeviceCode";
    private static final String KEY_WEBDEVICE_NAME = "webDeviceName";
    private static final String KEY_MAP_LIVE = "maplive";
    private static final String KEY_MAP_SOURCE = "mapsource";
    private static final String KEY_USE_TWITTER = "twitter";
    private static final String KEY_SHOW_ADDRESS = "showaddress";
    private static final String KEY_SHOW_CAPTCHA = "showcaptcha";
    private static final String KEY_MAP_TRAIL = "maptrail";
    private static final String KEY_LAST_MAP_ZOOM = "mapzoom";
    private static final String KEY_LAST_MAP_LAT = "maplat";
    private static final String KEY_LAST_MAP_LON = "maplon";
    private static final String KEY_LIVE_LIST = "livelist";
    private static final String KEY_METRIC_UNITS = "units";
    private static final String KEY_SKIN = "skin";
    private static final String KEY_LAST_USED_LIST = "lastlist";
    private static final String KEY_CACHE_TYPE = "cachetype";
    private static final String KEY_TWITTER_TOKEN_SECRET = "tokensecret";
    private static final String KEY_TWITTER_TOKEN_PUBLIC = "tokenpublic";
    private static final String KEY_VERSION = "version";
    private static final String KEY_LOAD_DESCRIPTION = "autoloaddesc";
    private static final String KEY_RATING_WANTED = "ratingwanted";
    private static final String KEY_ELEVATION_WANTED = "elevationwanted";
    private static final String KEY_FRIENDLOGS_WANTED = "friendlogswanted";
    private static final String KEY_USE_ENGLISH = "useenglish";
    private static final String KEY_USE_COMPASS = "usecompass";
    private static final String KEY_AUTO_VISIT_TRACKABLES = "trackautovisit";
    private static final String KEY_AUTO_INSERT_SIGNATURE = "sigautoinsert";
    private static final String KEY_ALTITUDE_CORRECTION = "altcorrection";
    private static final String KEY_USE_GOOGLE_NAVIGATION = "usegnav";
    private static final String KEY_STORE_LOG_IMAGES = "logimages";
    private static final String KEY_EXCLUDE_DISABLED = "excludedisabled";
    private static final String KEY_EXCLUDE_OWN = "excludemine";
    private static final String KEY_MAPFILE = "mfmapfile";
    private static final String KEY_SIGNATURE = "signature";
    private static final String KEY_GCVOTE_PASSWORD = "pass-vote";
    private static final String KEY_PASSWORD = "password";
    private static final String KEY_USERNAME = "username";
    private static final String KEY_MEMBER_STATUS = "memberstatus";
    private static final String KEY_COORD_INPUT_FORMAT = "coordinputformat";
    private static final String KEY_LOG_OFFLINE = "log_offline";
    private static final String KEY_LOAD_DIRECTION_IMG = "loaddirectionimg";
    private static final String KEY_GC_CUSTOM_DATE = "gccustomdate";
    private static final String KEY_SHOW_WAYPOINTS_THRESHOLD = "gcshowwaypointsthreshold";
    private static final String KEY_COOKIE_STORE = "cookiestore";
    private static final String KEY_OPEN_LAST_DETAILS_PAGE = "opendetailslastpage";
    private static final String KEY_LAST_DETAILS_PAGE = "lastdetailspage";
    private static final String KEY_DEFAULT_NAVIGATION_TOOL = "defaultNavigationTool";
    private static final String KEY_DEFAULT_NAVIGATION_TOOL_2 = "defaultNavigationTool2";
    private static final String KEY_LIVE_MAP_STRATEGY = "livemapstrategy";
    private static final String KEY_DEBUG = "debug";
    private static final String KEY_HIDE_LIVE_MAP_HINT = "hidelivemaphint";
    private static final String KEY_LIVE_MAP_HINT_SHOW_COUNT = "livemaphintshowcount";
    private static final String KEY_SETTINGS_VERSION = "settingsversion";
    private static final String KEY_DB_ON_SDCARD = "dbonsdcard";
    private static final String KEY_LAST_TRACKABLE_ACTION = "trackableaction";

    private final static int unitsMetric = 1;

    // twitter api keys
    private final static String keyConsumerPublic = CryptUtils.rot13("ESnsCvAv3kEupF1GCR3jGj");
    private final static String keyConsumerSecret = CryptUtils.rot13("7vQWceACV9umEjJucmlpFe9FCMZSeqIqfkQ2BnhV9x");

    private interface PrefRunnable {
        void edit(final Editor edit);
    }

    public enum coordInputFormatEnum {
        Plain,
        Deg,
        Min,
        Sec;

        static coordInputFormatEnum fromInt(int id) {
            final coordInputFormatEnum[] values = coordInputFormatEnum.values();
            if (id < 0 || id >= values.length) {
                return Min;
            }
            return values[id];
        }
    }

    private static String username = null;
    private static String password = null;

    private static final SharedPreferences sharedPrefs = PreferenceManager.getDefaultSharedPreferences(cgeoapplication.getInstance().getBaseContext());
    static {
        migrateSettings();
        Log.setDebugUnsaved(sharedPrefs.getBoolean(KEY_DEBUG, false));
    }

    // maps
    private static MapProvider mapProvider = null;

    private Settings() {
        // this class is not to be instantiated;
    }

    private static void migrateSettings() {
        // migrate from non standard file location and integer based boolean types
        if (sharedPrefs.getInt(KEY_SETTINGS_VERSION, 0) < 1) {
            final String oldPreferencesName = "cgeo.pref";
            final SharedPreferences old = cgeoapplication.getInstance().getSharedPreferences(oldPreferencesName, Context.MODE_PRIVATE);
            final Editor e = sharedPrefs.edit();

            e.putString(KEY_TEMP_TOKEN_SECRET, old.getString(KEY_TEMP_TOKEN_SECRET, null));
            e.putString(KEY_TEMP_TOKEN_PUBLIC, old.getString(KEY_TEMP_TOKEN_PUBLIC, null));
            e.putBoolean(KEY_HELP_SHOWN, old.getInt(KEY_HELP_SHOWN, 0) != 0);
            e.putFloat(KEY_ANYLONGITUDE, old.getFloat(KEY_ANYLONGITUDE, 0));
            e.putFloat(KEY_ANYLATITUDE, old.getFloat(KEY_ANYLATITUDE, 0));
            e.putBoolean(KEY_PUBLICLOC, 0 != old.getInt(KEY_PUBLICLOC, 0));
            e.putBoolean(KEY_USE_OFFLINEMAPS, 0 != old.getInt(KEY_USE_OFFLINEMAPS, 1));
            e.putBoolean(KEY_USE_OFFLINEWPMAPS, 0 != old.getInt(KEY_USE_OFFLINEWPMAPS, 0));
            e.putString(KEY_WEB_DEVICE_CODE, old.getString(KEY_WEB_DEVICE_CODE, null));
            e.putString(KEY_WEBDEVICE_NAME, old.getString(KEY_WEBDEVICE_NAME, null));
            e.putBoolean(KEY_MAP_LIVE, old.getInt(KEY_MAP_LIVE, 1) != 0);
            e.putInt(KEY_MAP_SOURCE, old.getInt(KEY_MAP_SOURCE, 0));
            e.putBoolean(KEY_USE_TWITTER, 0 != old.getInt(KEY_USE_TWITTER, 0));
            e.putBoolean(KEY_SHOW_ADDRESS, 0 != old.getInt(KEY_SHOW_ADDRESS, 1));
            e.putBoolean(KEY_SHOW_CAPTCHA, old.getBoolean(KEY_SHOW_CAPTCHA, false));
            e.putBoolean(KEY_MAP_TRAIL, old.getInt(KEY_MAP_TRAIL, 1) != 0);
            e.putInt(KEY_LAST_MAP_ZOOM, old.getInt(KEY_LAST_MAP_ZOOM, 14));
            e.putBoolean(KEY_LIVE_LIST, 0 != old.getInt(KEY_LIVE_LIST, 1));
            e.putBoolean(KEY_METRIC_UNITS, old.getInt(KEY_METRIC_UNITS, unitsMetric) == unitsMetric);
            e.putBoolean(KEY_SKIN, old.getInt(KEY_SKIN, 0) != 0);
            e.putInt(KEY_LAST_USED_LIST, old.getInt(KEY_LAST_USED_LIST, StoredList.STANDARD_LIST_ID));
            e.putString(KEY_CACHE_TYPE, old.getString(KEY_CACHE_TYPE, CacheType.ALL.id));
            e.putString(KEY_TWITTER_TOKEN_SECRET, old.getString(KEY_TWITTER_TOKEN_SECRET, null));
            e.putString(KEY_TWITTER_TOKEN_PUBLIC, old.getString(KEY_TWITTER_TOKEN_PUBLIC, null));
            e.putInt(KEY_VERSION, old.getInt(KEY_VERSION, 0));
            e.putBoolean(KEY_LOAD_DESCRIPTION, 0 != old.getInt(KEY_LOAD_DESCRIPTION, 0));
            e.putBoolean(KEY_RATING_WANTED, old.getBoolean(KEY_RATING_WANTED, true));
            e.putBoolean(KEY_ELEVATION_WANTED, old.getBoolean(KEY_ELEVATION_WANTED, true));
            e.putBoolean(KEY_FRIENDLOGS_WANTED, old.getBoolean(KEY_FRIENDLOGS_WANTED, true));
            e.putBoolean(KEY_USE_ENGLISH, old.getBoolean(KEY_USE_ENGLISH, false));
            e.putBoolean(KEY_USE_COMPASS, 0 != old.getInt(KEY_USE_COMPASS, 1));
            e.putBoolean(KEY_AUTO_VISIT_TRACKABLES, old.getBoolean(KEY_AUTO_VISIT_TRACKABLES, false));
            e.putBoolean(KEY_AUTO_INSERT_SIGNATURE, old.getBoolean(KEY_AUTO_INSERT_SIGNATURE, false));
            e.putInt(KEY_ALTITUDE_CORRECTION, old.getInt(KEY_ALTITUDE_CORRECTION, 0));
            e.putBoolean(KEY_USE_GOOGLE_NAVIGATION, 0 != old.getInt(KEY_USE_GOOGLE_NAVIGATION, 1));
            e.putBoolean(KEY_STORE_LOG_IMAGES, old.getBoolean(KEY_STORE_LOG_IMAGES, false));
            e.putBoolean(KEY_EXCLUDE_DISABLED, 0 != old.getInt(KEY_EXCLUDE_DISABLED, 0));
            e.putBoolean(KEY_EXCLUDE_OWN, 0 != old.getInt(KEY_EXCLUDE_OWN, 0));
            e.putString(KEY_MAPFILE, old.getString(KEY_MAPFILE, null));
            e.putString(KEY_SIGNATURE, old.getString(KEY_SIGNATURE, null));
            e.putString(KEY_GCVOTE_PASSWORD, old.getString(KEY_GCVOTE_PASSWORD, null));
            e.putString(KEY_PASSWORD, old.getString(KEY_PASSWORD, null));
            e.putString(KEY_USERNAME, old.getString(KEY_USERNAME, null));
            e.putString(KEY_MEMBER_STATUS, old.getString(KEY_MEMBER_STATUS, ""));
            e.putInt(KEY_COORD_INPUT_FORMAT, old.getInt(KEY_COORD_INPUT_FORMAT, 0));
            e.putBoolean(KEY_LOG_OFFLINE, old.getBoolean(KEY_LOG_OFFLINE, false));
            e.putBoolean(KEY_LOAD_DIRECTION_IMG, old.getBoolean(KEY_LOAD_DIRECTION_IMG, true));
            e.putString(KEY_GC_CUSTOM_DATE, old.getString(KEY_GC_CUSTOM_DATE, null));
            e.putInt(KEY_SHOW_WAYPOINTS_THRESHOLD, old.getInt(KEY_SHOW_WAYPOINTS_THRESHOLD, 0));
            e.putString(KEY_COOKIE_STORE, old.getString(KEY_COOKIE_STORE, null));
            e.putBoolean(KEY_OPEN_LAST_DETAILS_PAGE, old.getBoolean(KEY_OPEN_LAST_DETAILS_PAGE, false));
            e.putInt(KEY_LAST_DETAILS_PAGE, old.getInt(KEY_LAST_DETAILS_PAGE, 1));
            e.putInt(KEY_DEFAULT_NAVIGATION_TOOL, old.getInt(KEY_DEFAULT_NAVIGATION_TOOL, 0));
            e.putInt(KEY_DEFAULT_NAVIGATION_TOOL_2, old.getInt(KEY_DEFAULT_NAVIGATION_TOOL_2, 0));
            e.putInt(KEY_LIVE_MAP_STRATEGY, old.getInt(KEY_LIVE_MAP_STRATEGY, Strategy.AUTO.id));
            e.putBoolean(KEY_DEBUG, old.getBoolean(KEY_DEBUG, false));
            e.putBoolean(KEY_HIDE_LIVE_MAP_HINT, old.getInt(KEY_HIDE_LIVE_MAP_HINT, 0) != 0);
            e.putInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, old.getInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, 0));

            e.putInt(KEY_SETTINGS_VERSION, 1) ; // mark migrated
            e.commit();
        }
    }

    public static void setLanguage(boolean useEnglish) {
        final Configuration config = new Configuration();
        config.locale = useEnglish ? new Locale("en") : Locale.getDefault();
        final Resources resources = cgeoapplication.getInstance().getResources();
        resources.updateConfiguration(config, resources.getDisplayMetrics());
    }

    public static boolean isLogin() {
        final String preUsername = sharedPrefs.getString(KEY_USERNAME, null);
        final String prePassword = sharedPrefs.getString(KEY_PASSWORD, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    /**
     * Get login and password information.
     *
     * @return a pair (login, password) or null if no valid information is stored
     */
    public static ImmutablePair<String, String> getLogin() {
        if (username == null || password == null) {
            final String preUsername = sharedPrefs.getString(KEY_USERNAME, null);
            final String prePassword = sharedPrefs.getString(KEY_PASSWORD, null);

            if (preUsername == null || prePassword == null) {
                return null;
            }

            username = preUsername;
            password = prePassword;
        }
        return new ImmutablePair<String, String>(username, password);
    }

    public static String getUsername() {
        return username != null ? username : sharedPrefs.getString(KEY_USERNAME, null);
    }

    public static boolean setLogin(final String username, final String password) {
        Settings.username = username;
        Settings.password = password;
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
                    // erase username and password
                    edit.remove(KEY_USERNAME);
                    edit.remove(KEY_PASSWORD);
                } else {
                    // save username and password
                    edit.putString(KEY_USERNAME, username);
                    edit.putString(KEY_PASSWORD, password);
                }
            }
        });
    }

    public static boolean isPremiumMember() {
        // Basic Member, Premium Member, ???
        String memberStatus = Settings.getMemberStatus();
        if (memberStatus == null) {
            return false;
        }
        return GCConstants.MEMBER_STATUS_PM.equalsIgnoreCase(memberStatus);
    }

    public static String getMemberStatus() {
        return sharedPrefs.getString(KEY_MEMBER_STATUS, "");
    }

    public static boolean setMemberStatus(final String memberStatus) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(memberStatus)) {
                    edit.remove(KEY_MEMBER_STATUS);
                } else {
                    edit.putString(KEY_MEMBER_STATUS, memberStatus);
                }
            }
        });
    }

    public static boolean isGCvoteLogin() {
        final String preUsername = sharedPrefs.getString(KEY_USERNAME, null);
        final String prePassword = sharedPrefs.getString(KEY_GCVOTE_PASSWORD, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    public static boolean setGCvoteLogin(final String password) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(password)) {
                    // erase password
                    edit.remove(KEY_GCVOTE_PASSWORD);
                } else {
                    // save password
                    edit.putString(KEY_GCVOTE_PASSWORD, password);
                }
            }
        });
    }

    public static ImmutablePair<String, String> getGCvoteLogin() {
        final String username = sharedPrefs.getString(KEY_USERNAME, null);
        final String password = sharedPrefs.getString(KEY_GCVOTE_PASSWORD, null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return null;
        }

        return new ImmutablePair<String, String>(username, password);
    }

    public static boolean setSignature(final String signature) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(signature)) {
                    // erase signature
                    edit.remove(KEY_SIGNATURE);
                } else {
                    // save signature
                    edit.putString(KEY_SIGNATURE, signature);
                }
            }
        });
    }

    public static String getSignature() {
        return sharedPrefs.getString(KEY_SIGNATURE, null);
    }

    public static boolean setCookieStore(final String cookies) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(final Editor edit) {
                if (StringUtils.isBlank(cookies)) {
                    // erase cookies
                    edit.remove(KEY_COOKIE_STORE);
                } else {
                    // save cookies
                    edit.putString(KEY_COOKIE_STORE, cookies);
                }
            }
        });
    }

    public static String getCookieStore() {
        return sharedPrefs.getString(KEY_COOKIE_STORE, null);
    }

    /**
     * @param cacheType
     *            The cache type used for future filtering
     */
    public static void setCacheType(final CacheType cacheType) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                if (cacheType == null) {
                    edit.remove(KEY_CACHE_TYPE);
                } else {
                    edit.putString(KEY_CACHE_TYPE, cacheType.id);
                }
            }
        });
    }

    public static void setLiveMap(final boolean live) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_MAP_LIVE, live);
            }
        });
    }

    public static int getLastList() {
        return sharedPrefs.getInt(KEY_LAST_USED_LIST, StoredList.STANDARD_LIST_ID);
    }

    public static void saveLastList(final int listId) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_USED_LIST, listId);
            }
        });
    }

    public static void setWebNameCode(final String name, final String code) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {

                edit.putString(KEY_WEBDEVICE_NAME, name);
                edit.putString(KEY_WEB_DEVICE_CODE, code);
            }
        });
    }

    public static MapProvider getMapProvider() {
        if (mapProvider == null) {
            mapProvider = MapProviderFactory.getMapProvider(getMapSource());
        }
        return mapProvider;
    }

    public static String getMapFile() {
        return sharedPrefs.getString(KEY_MAPFILE, null);
    }

    public static boolean setMapFile(final String mapFile) {
        return editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_MAPFILE, mapFile);
            }
        });
    }

    public static boolean isValidMapFile() {
        return isValidMapFile(getMapFile());
    }

    public static boolean isValidMapFile(final String mapFileIn) {
        return MapsforgeMapProvider.isValidMapFile(mapFileIn);
    }

    public static coordInputFormatEnum getCoordInputFormat() {
        return coordInputFormatEnum.fromInt(sharedPrefs.getInt(KEY_COORD_INPUT_FORMAT, 0));
    }

    public static void setCoordInputFormat(final coordInputFormatEnum format) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_COORD_INPUT_FORMAT, format.ordinal());
            }
        });
    }

    static void setLogOffline(final boolean offline) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LOG_OFFLINE, offline);
            }
        });
    }

    public static boolean getLogOffline() {
        return sharedPrefs.getBoolean(KEY_LOG_OFFLINE, false);
    }

    static void setLoadDirImg(final boolean value) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LOAD_DIRECTION_IMG, value);
            }
        });
    }

    public static boolean getLoadDirImg() {
        return !isPremiumMember() && sharedPrefs.getBoolean(KEY_LOAD_DIRECTION_IMG, true);
    }

    public static void setGcCustomDate(final String format) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_GC_CUSTOM_DATE, format);
            }
        });
    }

    /**
     * @return User selected date format on GC.com
     * @see Login#gcCustomDateFormats
     */
    public static String getGcCustomDate() {
        return sharedPrefs.getString(KEY_GC_CUSTOM_DATE, null);
    }

    public static boolean isExcludeMyCaches() {
        return sharedPrefs.getBoolean(KEY_EXCLUDE_OWN, false);
    }

    /**
     * edit some settings without knowing how to get the settings editor or how to commit
     *
     * @param runnable
     * @return
     */
    private static boolean editSharedSettings(final PrefRunnable runnable) {
        final SharedPreferences.Editor prefsEdit = sharedPrefs.edit();
        runnable.edit(prefsEdit);
        return prefsEdit.commit();
    }

    public static void setExcludeMine(final boolean exclude) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_EXCLUDE_OWN, exclude);
            }
        });
    }

    public static void setUseEnglish(final boolean english) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_ENGLISH, english);
                setLanguage(english);
            }
        });
    }

    public static boolean isUseEnglish() {
        return sharedPrefs.getBoolean(KEY_USE_ENGLISH, false);
    }

    public static boolean isShowAddress() {
        return sharedPrefs.getBoolean(KEY_SHOW_ADDRESS, true);
    }

    public static void setShowAddress(final boolean showAddress) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SHOW_ADDRESS, showAddress);
            }
        });
    }

    public static boolean isShowCaptcha() {
        return !isPremiumMember() && sharedPrefs.getBoolean(KEY_SHOW_CAPTCHA, false);
    }

    public static void setShowCaptcha(final boolean showCaptcha) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SHOW_CAPTCHA, showCaptcha);
            }
        });
    }

    public static boolean isExcludeDisabledCaches() {
        return sharedPrefs.getBoolean(KEY_EXCLUDE_DISABLED, false);
    }

    public static void setExcludeDisabledCaches(final boolean exclude) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_EXCLUDE_DISABLED, exclude);
            }
        });
    }

    public static boolean isStoreOfflineMaps() {
        return sharedPrefs.getBoolean(KEY_USE_OFFLINEMAPS, true);
    }

    public static void setStoreOfflineMaps(final boolean offlineMaps) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_OFFLINEMAPS, offlineMaps);
            }
        });
    }

    public static boolean isStoreOfflineWpMaps() {
        return sharedPrefs.getBoolean(KEY_USE_OFFLINEWPMAPS, false);
    }

    public static void setStoreOfflineWpMaps(final boolean offlineMaps) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_OFFLINEWPMAPS, offlineMaps);
            }
        });
    }

    public static boolean isStoreLogImages() {
        return sharedPrefs.getBoolean(KEY_STORE_LOG_IMAGES, false);
    }

    public static void setStoreLogImages(final boolean storeLogImages) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_STORE_LOG_IMAGES, storeLogImages);
            }
        });
    }

    public static boolean isUseGoogleNavigation() {
        return sharedPrefs.getBoolean(KEY_USE_GOOGLE_NAVIGATION, true);
    }

    public static void setUseGoogleNavigation(final boolean useGoogleNavigation) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_GOOGLE_NAVIGATION, useGoogleNavigation);
            }
        });
    }

    public static boolean isAutoLoadDescription() {
        return sharedPrefs.getBoolean(KEY_LOAD_DESCRIPTION, false);
    }

    public static void setAutoLoadDesc(final boolean autoLoad) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LOAD_DESCRIPTION, autoLoad);
            }
        });
    }

    public static boolean isRatingWanted() {
        return sharedPrefs.getBoolean(KEY_RATING_WANTED, true);
    }

    public static void setRatingWanted(final boolean ratingWanted) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_RATING_WANTED, ratingWanted);
            }
        });
    }

    public static boolean isElevationWanted() {
        return sharedPrefs.getBoolean(KEY_ELEVATION_WANTED, true);
    }

    public static void setElevationWanted(final boolean elevationWanted) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_ELEVATION_WANTED, elevationWanted);
            }
        });
    }

    public static boolean isFriendLogsWanted() {
        if (!isLogin()) {
            // don't show a friends log if the user is anonymous
            return false;
        }
        return sharedPrefs.getBoolean(KEY_FRIENDLOGS_WANTED, true);
    }

    public static void setFriendLogsWanted(final boolean friendLogsWanted) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_FRIENDLOGS_WANTED, friendLogsWanted);
            }
        });
    }

    public static boolean isLiveList() {
        return sharedPrefs.getBoolean(KEY_LIVE_LIST, true);
    }

    public static void setLiveList(final boolean liveList) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LIVE_LIST, liveList);
            }
        });
    }

    public static boolean isPublicLoc() {
        return sharedPrefs.getBoolean(KEY_PUBLICLOC, false);
    }

    public static void setPublicLoc(final boolean publicLocation) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_PUBLICLOC, publicLocation);
            }
        });
    }

    public static boolean isTrackableAutoVisit() {
        return sharedPrefs.getBoolean(KEY_AUTO_VISIT_TRACKABLES, false);
    }

    public static void setTrackableAutoVisit(final boolean autoVisit) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_AUTO_VISIT_TRACKABLES, autoVisit);
            }
        });
    }

    public static boolean isAutoInsertSignature() {
        return sharedPrefs.getBoolean(KEY_AUTO_INSERT_SIGNATURE, false);
    }

    public static void setAutoInsertSignature(final boolean autoInsert) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_AUTO_INSERT_SIGNATURE, autoInsert);
            }
        });
    }

    public static boolean isUseMetricUnits() {
        return sharedPrefs.getBoolean(KEY_METRIC_UNITS, true);
    }

    public static void setUseMetricUnits(final boolean metric) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_METRIC_UNITS, metric);
            }
        });
    }

    public static boolean isLiveMap() {
        return sharedPrefs.getBoolean(KEY_MAP_LIVE, true);
    }

    public static boolean isMapTrail() {
        return sharedPrefs.getBoolean(KEY_MAP_TRAIL, true);
    }

    public static void setMapTrail(final boolean showTrail) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_MAP_TRAIL, showTrail);
            }
        });
    }

    public static int getMapZoom() {
        return sharedPrefs.getInt(KEY_LAST_MAP_ZOOM, 14);
    }

    public static void setMapZoom(final int mapZoomLevel) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_MAP_ZOOM, mapZoomLevel);
            }
        });
    }

    public static GeoPointImpl getMapCenter() {
        return getMapProvider().getMapItemFactory()
                .getGeoPointBase(new Geopoint(sharedPrefs.getInt(KEY_LAST_MAP_LAT, 0) / 1e6,
                        sharedPrefs.getInt(KEY_LAST_MAP_LON, 0) / 1e6));
    }

    public static void setMapCenter(final GeoPointImpl mapViewCenter) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_MAP_LAT, mapViewCenter.getLatitudeE6());
                edit.putInt(KEY_LAST_MAP_LON, mapViewCenter.getLongitudeE6());
            }
        });
    }

    public static int getMapSource() {
        return sharedPrefs.getInt(KEY_MAP_SOURCE, 0);
    }

    public static void setMapSource(final int newMapSource) {
        if (!MapProviderFactory.isSameActivity(getMapSource(), newMapSource)) {
            mapProvider = null;
        }
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_MAP_SOURCE, newMapSource);
            }
        });
    }

    public static void setAnyCoordinates(final Geopoint coords) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (null != coords) {
                    edit.putFloat(KEY_ANYLATITUDE, (float) coords.getLatitude());
                    edit.putFloat(KEY_ANYLONGITUDE, (float) coords.getLongitude());
                } else {
                    edit.remove(KEY_ANYLATITUDE);
                    edit.remove(KEY_ANYLONGITUDE);
                }
            }
        });

    }

    public static Geopoint getAnyCoordinates() {
        if (sharedPrefs.contains(KEY_ANYLATITUDE) && sharedPrefs.contains(KEY_ANYLONGITUDE)) {
            float lat = sharedPrefs.getFloat(KEY_ANYLATITUDE, 0);
            float lon = sharedPrefs.getFloat(KEY_ANYLONGITUDE, 0);
            return new Geopoint(lat, lon);
        }
        return null;
    }

    public static boolean isUseCompass() {
        return sharedPrefs.getBoolean(KEY_USE_COMPASS, true);
    }

    public static void setUseCompass(final boolean useCompass) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_COMPASS, useCompass);
            }
        });
    }

    public static boolean isHelpShown() {
        return sharedPrefs.getBoolean(KEY_HELP_SHOWN, false);
    }

    public static void setHelpShown() {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_HELP_SHOWN, true);
            }
        });
    }

    public static boolean isLightSkin() {
        return sharedPrefs.getBoolean(KEY_SKIN, false);
    }

    public static void setLightSkin(final boolean lightSkin) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SKIN, lightSkin);
            }
        });
    }

    public static String getKeyConsumerPublic() {
        return keyConsumerPublic;
    }

    public static String getKeyConsumerSecret() {
        return keyConsumerSecret;
    }

    public static int getAltCorrection() {
        return sharedPrefs.getInt(KEY_ALTITUDE_CORRECTION, 0);
    }

    public static boolean setAltCorrection(final int altitude) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_ALTITUDE_CORRECTION, altitude);
            }
        });
    }

    public static String getWebDeviceCode() {
        return sharedPrefs.getString(KEY_WEB_DEVICE_CODE, null);
    }

    public static String getWebDeviceName() {
        return sharedPrefs.getString(KEY_WEBDEVICE_NAME, null);
    }

    /**
     * @return The cache type used for filtering or ALL if no filter is active. Returns never null
     */
    public static CacheType getCacheType() {
        return CacheType.getById(sharedPrefs.getString(KEY_CACHE_TYPE, CacheType.ALL.id));
    }

    /**
     * The Threshold for the showing of child waypoints
     *
     * @return
     */

    public static int getWayPointsThreshold() {
        return sharedPrefs.getInt(KEY_SHOW_WAYPOINTS_THRESHOLD, 0);
    }

    public static void setShowWaypointsThreshold(final int threshold) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_SHOW_WAYPOINTS_THRESHOLD, threshold);
            }
        });
    }

    public static boolean isUseTwitter() {
        return sharedPrefs.getBoolean(KEY_USE_TWITTER, false);
    }

    public static void setUseTwitter(final boolean useTwitter) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_TWITTER, useTwitter);
            }
        });
    }

    public static boolean isTwitterLoginValid() {
        return !StringUtils.isBlank(getTokenPublic()) && !StringUtils.isBlank(getTokenSecret());
    }

    public static String getTokenPublic() {
        return sharedPrefs.getString(KEY_TWITTER_TOKEN_PUBLIC, null);
    }

    public static String getTokenSecret() {
        return sharedPrefs.getString(KEY_TWITTER_TOKEN_SECRET, null);

    }

    public static int getVersion() {
        return sharedPrefs.getInt(KEY_VERSION, 0);
    }

    public static void setTwitterTokens(final String tokenPublic, final String tokenSecret, boolean enableTwitter) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_TWITTER_TOKEN_PUBLIC, tokenPublic);
                edit.putString(KEY_TWITTER_TOKEN_SECRET, tokenSecret);
                if (tokenPublic != null) {
                    edit.remove(KEY_TEMP_TOKEN_PUBLIC);
                    edit.remove(KEY_TEMP_TOKEN_SECRET);
                }
            }
        });
        setUseTwitter(enableTwitter);
    }

    public static void setTwitterTempTokens(final String tokenPublic, final String tokenSecret) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_TEMP_TOKEN_PUBLIC, tokenPublic);
                edit.putString(KEY_TEMP_TOKEN_SECRET, tokenSecret);
            }
        });
    }

    public static ImmutablePair<String, String> getTempToken() {
        String tokenPublic = sharedPrefs.getString(KEY_TEMP_TOKEN_PUBLIC, null);
        String tokenSecret = sharedPrefs.getString(KEY_TEMP_TOKEN_SECRET, null);
        return new ImmutablePair<String, String>(tokenPublic, tokenSecret);
    }

    public static void setVersion(final int version) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_VERSION, version);
            }
        });
    }

    public static boolean isOpenLastDetailsPage() {
        return sharedPrefs.getBoolean(KEY_OPEN_LAST_DETAILS_PAGE, false);
    }

    public static void setOpenLastDetailsPage(final boolean openLastPage) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_OPEN_LAST_DETAILS_PAGE, openLastPage);
            }
        });
    }

    public static int getLastDetailsPage() {
        return sharedPrefs.getInt(KEY_LAST_DETAILS_PAGE, 1);
    }

    public static void setLastDetailsPage(final int index) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_DETAILS_PAGE, index);
            }
        });
    }

    public static int getDefaultNavigationTool() {
        return sharedPrefs.getInt(KEY_DEFAULT_NAVIGATION_TOOL, NavigationAppsEnum.COMPASS.id);
    }

    public static void setDefaultNavigationTool(final int defaultNavigationTool) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_DEFAULT_NAVIGATION_TOOL, defaultNavigationTool);
            }
        });
    }

    public static int getDefaultNavigationTool2() {
        return sharedPrefs.getInt(KEY_DEFAULT_NAVIGATION_TOOL_2, NavigationAppsEnum.INTERNAL_MAP.id);
    }

    public static void setDefaultNavigationTool2(final int defaultNavigationTool) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_DEFAULT_NAVIGATION_TOOL_2, defaultNavigationTool);
            }
        });
    }

    public static Strategy getLiveMapStrategy() {
        return Strategy.getById(sharedPrefs.getInt(KEY_LIVE_MAP_STRATEGY, Strategy.AUTO.id));
    }

    public static void setLiveMapStrategy(final Strategy strategy) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LIVE_MAP_STRATEGY, strategy.id);
            }
        });
    }


    public static boolean isDebug() {
        return Log.isDebug();
    }

    public static void setDebug(final boolean debug) {
        editSharedSettings(new PrefRunnable() {

            @Override public void edit(Editor edit) {
                edit.putBoolean(KEY_DEBUG, debug);
            }
        });
        Log.setDebugUnsaved(debug);
    }

    public static boolean getHideLiveMapHint() {
        return sharedPrefs.getBoolean(KEY_HIDE_LIVE_MAP_HINT, false);
    }

    public static void setHideLiveHint(final boolean hide) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_HIDE_LIVE_MAP_HINT, hide);
            }
        });
    }

    public static int getLiveMapHintShowCount() {
        return sharedPrefs.getInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, 0);
    }

    public static void setLiveMapHintShowCount(final int showCount) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, showCount);
            }
        });
    }

    public static boolean isDbOnSDCard() {
        return sharedPrefs.getBoolean(KEY_DB_ON_SDCARD, false);
    }

    public static void setDbOnSDCard(final boolean dbOnSDCard) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_DB_ON_SDCARD, dbOnSDCard);
            }
        });
    }

    public static int getTrackableAction() {
        return sharedPrefs.getInt(KEY_LAST_TRACKABLE_ACTION, LogType.RETRIEVED_IT.id);
    }

    public static void setTrackableAction(final int trackableAction) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_TRACKABLE_ACTION, trackableAction);
            }
        });
    }

    public static String getPreferencesName() {
        // there is currently no Android API to get the file name of the shared preferences
        return cgeoapplication.getInstance().getPackageName() + "_preferences";
    }

}
!@#$%
20190527_000359,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_b02220
package cgeo.geocaching.network;

import cgeo.geocaching.Settings;
import cgeo.geocaching.files.LocalStorage;
import cgeo.geocaching.utils.BaseUtils;
import cgeo.geocaching.utils.Log;

import ch.boye.httpclientandroidlib.Header;
import ch.boye.httpclientandroidlib.HeaderElement;
import ch.boye.httpclientandroidlib.HttpEntity;
import ch.boye.httpclientandroidlib.HttpException;
import ch.boye.httpclientandroidlib.HttpRequest;
import ch.boye.httpclientandroidlib.HttpRequestInterceptor;
import ch.boye.httpclientandroidlib.HttpResponse;
import ch.boye.httpclientandroidlib.HttpResponseInterceptor;
import ch.boye.httpclientandroidlib.NameValuePair;
import ch.boye.httpclientandroidlib.ProtocolException;
import ch.boye.httpclientandroidlib.client.HttpClient;
import ch.boye.httpclientandroidlib.client.entity.GzipDecompressingEntity;
import ch.boye.httpclientandroidlib.client.entity.UrlEncodedFormEntity;
import ch.boye.httpclientandroidlib.client.methods.HttpGet;
import ch.boye.httpclientandroidlib.client.methods.HttpPost;
import ch.boye.httpclientandroidlib.client.methods.HttpRequestBase;
import ch.boye.httpclientandroidlib.client.params.ClientPNames;
import ch.boye.httpclientandroidlib.entity.mime.MultipartEntity;
import ch.boye.httpclientandroidlib.entity.mime.content.FileBody;
import ch.boye.httpclientandroidlib.entity.mime.content.StringBody;
import ch.boye.httpclientandroidlib.impl.client.DefaultHttpClient;
import ch.boye.httpclientandroidlib.impl.client.DefaultRedirectStrategy;
import ch.boye.httpclientandroidlib.params.BasicHttpParams;
import ch.boye.httpclientandroidlib.params.CoreConnectionPNames;
import ch.boye.httpclientandroidlib.params.CoreProtocolPNames;
import ch.boye.httpclientandroidlib.params.HttpParams;
import ch.boye.httpclientandroidlib.protocol.HttpContext;
import ch.boye.httpclientandroidlib.util.EntityUtils;

import org.apache.commons.lang3.CharEncoding;
import org.apache.commons.lang3.StringUtils;
import org.json.JSONException;
import org.json.JSONObject;

import android.net.Uri;

import java.io.File;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.net.URLEncoder;

public abstract class Network {

    private static final int NB_DOWNLOAD_RETRIES = 4;

    /** User agent id */
    private final static String PC_USER_AGENT = "Mozilla/5.0 (X11; Linux x86_64; rv:9.0.1) Gecko/20100101 Firefox/9.0.1";
    /** Native user agent, taken from a Android 2.2 Nexus **/
    private final static String NATIVE_USER_AGENT = "Mozilla/5.0 (Linux; U; Android 2.2; en-us; Nexus One Build/FRF91) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1";

    private static final String PATTERN_PASSWORD = "(?<=[\\?&])[Pp]ass(w(or)?d)?=[^&#$]+";

    private final static HttpParams clientParams = new BasicHttpParams();

    static {
        Network.clientParams.setParameter(CoreProtocolPNames.HTTP_CONTENT_CHARSET, "UTF-8");
        Network.clientParams.setParameter(CoreConnectionPNames.CONNECTION_TIMEOUT, 30000);
        Network.clientParams.setParameter(CoreConnectionPNames.SO_TIMEOUT, 30000);
        Network.clientParams.setParameter(ClientPNames.HANDLE_REDIRECTS,  true);
    }

    private static String hidePassword(final String message) {
        return message.replaceAll(Network.PATTERN_PASSWORD, "password=***");
    }

    private static HttpClient getHttpClient() {
        final DefaultHttpClient client = new DefaultHttpClient();
        client.setCookieStore(Cookies.cookieStore);
        client.setParams(clientParams);

        client.setRedirectStrategy(new DefaultRedirectStrategy() {
            @Override
            public boolean isRedirected(HttpRequest request, HttpResponse response, HttpContext context) {
                boolean isRedirect = false;
                try {
                    isRedirect = super.isRedirected(request, response, context);
                } catch (final ProtocolException e) {
                    Log.e("httpclient.isRedirected: unable to check for redirection", e);
                }
                if (!isRedirect) {
                    final int responseCode = response.getStatusLine().getStatusCode();
                    if (responseCode == 301 || responseCode == 302) {
                        return true;
                    }
                }
                return isRedirect;
            }
        });

        client.addRequestInterceptor(new HttpRequestInterceptor() {

            @Override
            public void process(
                    final HttpRequest request,
                    final HttpContext context) throws HttpException, IOException {
                if (!request.containsHeader("Accept-Encoding")) {
                    request.addHeader("Accept-Encoding", "gzip");
                }
            }
        });
        client.addResponseInterceptor(new HttpResponseInterceptor() {

            @Override
            public void process(
                    final HttpResponse response,
                    final HttpContext context) throws HttpException, IOException {
                final HttpEntity entity = response.getEntity();
                if (entity != null) {
                    final Header contentEncoding = entity.getContentEncoding();
                    if (contentEncoding != null) {
                        for (final HeaderElement codec : contentEncoding.getElements()) {
                            if (codec.getName().equalsIgnoreCase("gzip")) {
                                Log.d("Decompressing response");
                                response.setEntity(new GzipDecompressingEntity(response.getEntity()));
                                return;
                            }
                        }
                    }
                }
            }

        });

        return client;
    }

    /**
     * POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @return the HTTP response, or null in case of an encoding error params
     */
    public static HttpResponse postRequest(final String uri, final Parameters params) {
        return request("POST", uri, params, null, null);
    }

    /**
     * POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @params headers the headers to add to the request
     * @return the HTTP response, or null in case of an encoding error params
     */
    public static HttpResponse postRequest(final String uri, final Parameters params, final Parameters headers) {
        return request("POST", uri, params, headers, null);
    }

    /**
     * Multipart POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @param fileFieldName the name of the file field name
     * @param fileContentType the content-type of the file
     * @param file the file to include in the request
     * @return the HTTP response, or null in case of an encoding error param
     */
    public static HttpResponse postRequest(final String uri, final Parameters params,
                                           final String fileFieldName, final String fileContentType, final File file) {
        final MultipartEntity entity = new MultipartEntity();
        for (final NameValuePair param : params) {
            try {
                entity.addPart(param.getName(), new StringBody(param.getValue()));
            } catch (final UnsupportedEncodingException e) {
                Log.e("Network.postRequest: unsupported encoding for parameter " + param.getName(), e);
                return null;
            }
        }
        entity.addPart(fileFieldName, new FileBody(file, fileContentType));

        final HttpPost request = new HttpPost(uri);
        request.setEntity(entity);

        addHeaders(request, null, null);
        return doRepeatedRequests(request);
    }

    /**
     * Make an HTTP request
     *
     * @param method
     *            the HTTP method to use ("GET" or "POST")
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add to the URI
     * @param headers
     *            the headers to add to the request
     * @param cacheFile
     *            the cache file used to cache this query
     * @return the HTTP response, or null in case of an encoding error in a POST request arguments
     */
    private static HttpResponse request(final String method, final String uri, final Parameters params, final Parameters headers, final File cacheFile) {
        HttpRequestBase request;
        if (method.equals("GET")) {
            final String fullUri = params == null ? uri : Uri.parse(uri).buildUpon().encodedQuery(params.toString()).build().toString();
            request = new HttpGet(fullUri);
        } else {
            request = new HttpPost(uri);
            if (params != null) {
                try {
                    ((HttpPost) request).setEntity(new UrlEncodedFormEntity(params, "UTF-8"));
                } catch (final UnsupportedEncodingException e) {
                    Log.e("request", e);
                    return null;
                }
            }
        }

        addHeaders(request, headers, cacheFile);

        return doRepeatedRequests(request);
    }

    /**
     * Add headers to HTTP request.
     * @param request
     *            the request to add headers to
     * @param headers
     *            the headers to add (in addition to the standard headers), can be null
     * @param cacheFile
     *            if non-null, the file to take ETag and If-Modified-Since information from
     */
    private static void addHeaders(final HttpRequestBase request, final Parameters headers, final File cacheFile) {
        for (final NameValuePair header : Parameters.extend(Parameters.merge(headers, cacheHeaders(cacheFile)),
                "Accept-Charset", "utf-8,iso-8859-1;q=0.8,utf-16;q=0.8,*;q=0.7",
                "Accept-Language", "en-US,*;q=0.9",
                "X-Requested-With", "XMLHttpRequest")) {
            request.setHeader(header.getName(), header.getValue());
        }
        if (Settings.getUseNativeUa()) {
            request.getParams().setParameter(CoreProtocolPNames.USER_AGENT, Network.NATIVE_USER_AGENT);
        } else {
            request.getParams().setParameter(CoreProtocolPNames.USER_AGENT, Network.PC_USER_AGENT);
        }
    }

    /**
     * Retry a request for a few times.
     *
     * @param request
     *            the request to try
     * @return
     *            the response, or null if there has been a failure
     */
    private static HttpResponse doRepeatedRequests(final HttpRequestBase request) {
        final String reqLogStr = request.getMethod() + " " + Network.hidePassword(request.getURI().toString());
        Log.d(reqLogStr);

        final HttpClient client = Network.getHttpClient();
        for (int i = 0; i <= Network.NB_DOWNLOAD_RETRIES; i++) {
            final long before = System.currentTimeMillis();
            try {
                final HttpResponse response = client.execute(request);
                int status = response.getStatusLine().getStatusCode();
                if (status == 200) {
                    Log.d(status + Network.formatTimeSpan(before) + reqLogStr);
                } else {
                    Log.w(status + " [" + response.getStatusLine().getReasonPhrase() + "]" + Network.formatTimeSpan(before) + reqLogStr);
                }
                return response;
            } catch (IOException e) {
                final String timeSpan = Network.formatTimeSpan(before);
                final String tries = (i + 1) + "/" + (Network.NB_DOWNLOAD_RETRIES + 1);
                if (i == Network.NB_DOWNLOAD_RETRIES) {
                    Log.e("Failure " + tries + timeSpan + reqLogStr, e);
                } else {
                    Log.e("Failure " + tries + " (" + e.toString() + ")" + timeSpan + "- retrying " + reqLogStr);
                }
            }
        }

        return null;
    }

    private static Parameters cacheHeaders(final File cacheFile) {
        if (cacheFile == null || !cacheFile.exists()) {
            return null;
        }

        final String etag = LocalStorage.getSavedHeader(cacheFile, "etag");
        if (etag != null) {
            return new Parameters("If-None-Match", etag);
        }

        final String lastModified = LocalStorage.getSavedHeader(cacheFile, "last-modified");
        if (lastModified != null) {
            return new Parameters("If-Modified-Since", lastModified);
        }

        return null;
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @param cacheFile
     *            the name of the file storing the cached resource, or null not to use one
     * @return the HTTP response
     */
    public static HttpResponse getRequest(final String uri, final Parameters params, final File cacheFile) {
        return request("GET", uri, params, null, cacheFile);
    }


    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @return the HTTP response
     */
    public static HttpResponse getRequest(final String uri, final Parameters params) {
        return request("GET", uri, params, null, null);
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @param headers
     *            the headers to add to the GET request
     * @return the HTTP response
     */
    public static HttpResponse getRequest(final String uri, final Parameters params, final Parameters headers) {
        return request("GET", uri, params, headers, null);
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @return the HTTP response
     */
    public static HttpResponse getRequest(final String uri) {
        return request("GET", uri, null, null, null);
    }

    private static String formatTimeSpan(final long before) {
        // don't use String.format in a pure logging routine, it has very bad performance
        return " (" + (System.currentTimeMillis() - before) + " ms) ";
    }

    static public boolean isSuccess(final HttpResponse response) {
        return response != null && response.getStatusLine().getStatusCode() == 200;
    }

    public static JSONObject requestJSON(final String uri, final Parameters params) {
        final HttpResponse response = request("GET", uri, params, new Parameters("Accept", "application/json, text/javascript, */*; q=0.01"), null);
        if (isSuccess(response)) {
            try {
                return new JSONObject(Network.getResponseData(response));
            } catch (final JSONException e) {
                Log.e("Network.requestJSON", e);
            }
        }

        return null;
    }

    private static String getResponseDataNoError(final HttpResponse response, boolean replaceWhitespace) {
        try {
            String data = EntityUtils.toString(response.getEntity(), "UTF-8");
            return replaceWhitespace ? BaseUtils.replaceWhitespace(data) : data;
        } catch (Exception e) {
            Log.e("getResponseData", e);
            return null;
        }
    }

    public static String getResponseData(final HttpResponse response) {
        return Network.getResponseData(response, true);
    }

    public static String getResponseData(final HttpResponse response, boolean replaceWhitespace) {
        if (!isSuccess(response)) {
            return null;
        }
        return getResponseDataNoError(response, replaceWhitespace);
    }

    public static String rfc3986URLEncode(String text) {
        return StringUtils.replace(Network.encode(text).replace("+", "%20"), "%7E", "~");
    }

    public static String decode(final String text) {
        try {
            return URLDecoder.decode(text, CharEncoding.UTF_8);
        } catch (UnsupportedEncodingException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        return null;
    }

    public static String encode(final String text) {
        try {
            return URLEncoder.encode(text, CharEncoding.UTF_8);
        } catch (UnsupportedEncodingException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        return null;
    }

}
!@#$%
20190527_000359,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_a02220
package cgeo.geocaching.network;

import cgeo.geocaching.Settings;
import cgeo.geocaching.cgeoapplication;
import cgeo.geocaching.files.LocalStorage;
import cgeo.geocaching.utils.BaseUtils;
import cgeo.geocaching.utils.Log;

import ch.boye.httpclientandroidlib.Header;
import ch.boye.httpclientandroidlib.HeaderElement;
import ch.boye.httpclientandroidlib.HttpEntity;
import ch.boye.httpclientandroidlib.HttpException;
import ch.boye.httpclientandroidlib.HttpRequest;
import ch.boye.httpclientandroidlib.HttpRequestInterceptor;
import ch.boye.httpclientandroidlib.HttpResponse;
import ch.boye.httpclientandroidlib.HttpResponseInterceptor;
import ch.boye.httpclientandroidlib.NameValuePair;
import ch.boye.httpclientandroidlib.ProtocolException;
import ch.boye.httpclientandroidlib.client.HttpClient;
import ch.boye.httpclientandroidlib.client.entity.GzipDecompressingEntity;
import ch.boye.httpclientandroidlib.client.entity.UrlEncodedFormEntity;
import ch.boye.httpclientandroidlib.client.methods.HttpGet;
import ch.boye.httpclientandroidlib.client.methods.HttpPost;
import ch.boye.httpclientandroidlib.client.methods.HttpRequestBase;
import ch.boye.httpclientandroidlib.client.params.ClientPNames;
import ch.boye.httpclientandroidlib.entity.mime.MultipartEntity;
import ch.boye.httpclientandroidlib.entity.mime.content.FileBody;
import ch.boye.httpclientandroidlib.entity.mime.content.StringBody;
import ch.boye.httpclientandroidlib.impl.client.DefaultHttpClient;
import ch.boye.httpclientandroidlib.impl.client.DefaultRedirectStrategy;
import ch.boye.httpclientandroidlib.params.BasicHttpParams;
import ch.boye.httpclientandroidlib.params.CoreConnectionPNames;
import ch.boye.httpclientandroidlib.params.CoreProtocolPNames;
import ch.boye.httpclientandroidlib.params.HttpParams;
import ch.boye.httpclientandroidlib.protocol.HttpContext;
import ch.boye.httpclientandroidlib.util.EntityUtils;

import org.apache.commons.lang3.StringUtils;
import org.json.JSONException;
import org.json.JSONObject;

import android.net.Uri;
import android.webkit.WebView;

import java.io.File;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;

public abstract class Network {

    private static final int NB_DOWNLOAD_RETRIES = 4;
    /** User agent id */
    private final static String PC_USER_AGENT = "Mozilla/5.0 (X11; Linux x86_64; rv:9.0.1) Gecko/20100101 Firefox/9.0.1";
    /** Native user agent **/
    private final static String NATIVE_USER_AGENT = new WebView(cgeoapplication.getInstance()).getSettings().getUserAgentString();

    private static final String PATTERN_PASSWORD = "(?<=[\\?&])[Pp]ass(w(or)?d)?=[^&#$]+";

    private final static HttpParams clientParams = new BasicHttpParams();

    static {
        Network.clientParams.setParameter(CoreProtocolPNames.HTTP_CONTENT_CHARSET, "UTF-8");
        Network.clientParams.setParameter(CoreConnectionPNames.CONNECTION_TIMEOUT, 30000);
        Network.clientParams.setParameter(CoreConnectionPNames.SO_TIMEOUT, 30000);
        Network.clientParams.setParameter(ClientPNames.HANDLE_REDIRECTS,  true);
    }

    private static String hidePassword(final String message) {
        return message.replaceAll(Network.PATTERN_PASSWORD, "password=***");
    }

    private static HttpClient getHttpClient() {
        final DefaultHttpClient client = new DefaultHttpClient();
        client.setCookieStore(Cookies.cookieStore);
        client.setParams(clientParams);

        client.setRedirectStrategy(new DefaultRedirectStrategy() {
            @Override
            public boolean isRedirected(HttpRequest request, HttpResponse response, HttpContext context) {
                boolean isRedirect = false;
                try {
                    isRedirect = super.isRedirected(request, response, context);
                } catch (final ProtocolException e) {
                    Log.e("httpclient.isRedirected: unable to check for redirection", e);
                }
                if (!isRedirect) {
                    final int responseCode = response.getStatusLine().getStatusCode();
                    if (responseCode == 301 || responseCode == 302) {
                        return true;
                    }
                }
                return isRedirect;
            }
        });

        client.addRequestInterceptor(new HttpRequestInterceptor() {

            @Override
            public void process(
                    final HttpRequest request,
                    final HttpContext context) throws HttpException, IOException {
                if (!request.containsHeader("Accept-Encoding")) {
                    request.addHeader("Accept-Encoding", "gzip");
                }
            }
        });
        client.addResponseInterceptor(new HttpResponseInterceptor() {

            @Override
            public void process(
                    final HttpResponse response,
                    final HttpContext context) throws HttpException, IOException {
                final HttpEntity entity = response.getEntity();
                if (entity != null) {
                    final Header contentEncoding = entity.getContentEncoding();
                    if (contentEncoding != null) {
                        for (final HeaderElement codec : contentEncoding.getElements()) {
                            if (codec.getName().equalsIgnoreCase("gzip")) {
                                Log.d("Decompressing response");
                                response.setEntity(new GzipDecompressingEntity(response.getEntity()));
                                return;
                            }
                        }
                    }
                }
            }

        });

        return client;
    }

    /**
     * POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @return the HTTP response, or null in case of an encoding error params
     */
    public static HttpResponse postRequest(final String uri, final Parameters params) {
        return request("POST", uri, params, null, null);
    }

    /**
     * POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @params headers the headers to add to the request
     * @return the HTTP response, or null in case of an encoding error params
     */
    public static HttpResponse postRequest(final String uri, final Parameters params, final Parameters headers) {
        return request("POST", uri, params, headers, null);
    }

    /**
     * Multipart POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @param fileFieldName the name of the file field name
     * @param fileContentType the content-type of the file
     * @param file the file to include in the request
     * @return the HTTP response, or null in case of an encoding error param
     */
    public static HttpResponse postRequest(final String uri, final Parameters params,
                                           final String fileFieldName, final String fileContentType, final File file) {
        final MultipartEntity entity = new MultipartEntity();
        for (final NameValuePair param : params) {
            try {
                entity.addPart(param.getName(), new StringBody(param.getValue()));
            } catch (final UnsupportedEncodingException e) {
                Log.e("Network.postRequest: unsupported encoding for parameter " + param.getName(), e);
                return null;
            }
        }
        entity.addPart(fileFieldName, new FileBody(file, fileContentType));

        final HttpPost request = new HttpPost(uri);
        request.setEntity(entity);

        addHeaders(request, null, null);
        return doRepeatedRequests(request);
    }

    /**
     * Make an HTTP request
     *
     * @param method
     *            the HTTP method to use ("GET" or "POST")
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add to the URI
     * @param headers
     *            the headers to add to the request
     * @param cacheFile
     *            the cache file used to cache this query
     * @return the HTTP response, or null in case of an encoding error in a POST request arguments
     */
    private static HttpResponse request(final String method, final String uri, final Parameters params, final Parameters headers, final File cacheFile) {
        HttpRequestBase request;
        if (method.equals("GET")) {
            final String fullUri = params == null ? uri : Uri.parse(uri).buildUpon().encodedQuery(params.toString()).build().toString();
            request = new HttpGet(fullUri);
        } else {
            request = new HttpPost(uri);
            if (params != null) {
                try {
                    ((HttpPost) request).setEntity(new UrlEncodedFormEntity(params, "UTF-8"));
                } catch (final UnsupportedEncodingException e) {
                    Log.e("request", e);
                    return null;
                }
            }
        }

        addHeaders(request, headers, cacheFile);

        return doRepeatedRequests(request);
    }

    /**
     * Add headers to HTTP request.
     * @param request
     *            the request to add headers to
     * @param headers
     *            the headers to add (in addition to the standard headers), can be null
     * @param cacheFile
     *            if non-null, the file to take ETag and If-Modified-Since information from
     */
    private static void addHeaders(final HttpRequestBase request, final Parameters headers, final File cacheFile) {
        for (final NameValuePair header : Parameters.extend(Parameters.merge(headers, cacheHeaders(cacheFile)),
                "Accept-Charset", "utf-8,iso-8859-1;q=0.8,utf-16;q=0.8,*;q=0.7",
                "Accept-Language", "en-US,*;q=0.9",
                "X-Requested-With", "XMLHttpRequest")) {
            request.setHeader(header.getName(), header.getValue());
        }
        if (Settings.getUseNativeUa()) {
            request.getParams().setParameter(CoreProtocolPNames.USER_AGENT, Network.NATIVE_USER_AGENT);
        } else {
            request.getParams().setParameter(CoreProtocolPNames.USER_AGENT, Network.PC_USER_AGENT);
        }
    }

    /**
     * Retry a request for a few times.
     *
     * @param request
     *            the request to try
     * @return
     *            the response, or null if there has been a failure
     */
    private static HttpResponse doRepeatedRequests(final HttpRequestBase request) {
        final String reqLogStr = request.getMethod() + " " + Network.hidePassword(request.getURI().toString());
        Log.d(reqLogStr);

        final HttpClient client = Network.getHttpClient();
        for (int i = 0; i <= Network.NB_DOWNLOAD_RETRIES; i++) {
            final long before = System.currentTimeMillis();
            try {
                final HttpResponse response = client.execute(request);
                int status = response.getStatusLine().getStatusCode();
                if (status == 200) {
                    Log.d(status + Network.formatTimeSpan(before) + reqLogStr);
                } else {
                    Log.w(status + " [" + response.getStatusLine().getReasonPhrase() + "]" + Network.formatTimeSpan(before) + reqLogStr);
                }
                return response;
            } catch (IOException e) {
                final String timeSpan = Network.formatTimeSpan(before);
                final String tries = (i + 1) + "/" + (Network.NB_DOWNLOAD_RETRIES + 1);
                if (i == Network.NB_DOWNLOAD_RETRIES) {
                    Log.e("Failure " + tries + timeSpan + reqLogStr, e);
                } else {
                    Log.e("Failure " + tries + " (" + e.toString() + ")" + timeSpan + "- retrying " + reqLogStr);
                }
            }
        }

        return null;
    }

    private static Parameters cacheHeaders(final File cacheFile) {
        if (cacheFile == null || !cacheFile.exists()) {
            return null;
        }

        final String etag = LocalStorage.getSavedHeader(cacheFile, "etag");
        if (etag != null) {
            return new Parameters("If-None-Match", etag);
        }

        final String lastModified = LocalStorage.getSavedHeader(cacheFile, "last-modified");
        if (lastModified != null) {
            return new Parameters("If-Modified-Since", lastModified);
        }

        return null;
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @param cacheFile
     *            the name of the file storing the cached resource, or null not to use one
     * @return the HTTP response
     */
    public static HttpResponse getRequest(final String uri, final Parameters params, final File cacheFile) {
        return request("GET", uri, params, null, cacheFile);
    }


    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @return the HTTP response
     */
    public static HttpResponse getRequest(final String uri, final Parameters params) {
        return request("GET", uri, params, null, null);
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @param headers
     *            the headers to add to the GET request
     * @return the HTTP response
     */
    public static HttpResponse getRequest(final String uri, final Parameters params, final Parameters headers) {
        return request("GET", uri, params, headers, null);
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @return the HTTP response
     */
    public static HttpResponse getRequest(final String uri) {
        return request("GET", uri, null, null, null);
    }

    private static String formatTimeSpan(final long before) {
        // don't use String.format in a pure logging routine, it has very bad performance
        return " (" + (System.currentTimeMillis() - before) + " ms) ";
    }

    static public boolean isSuccess(final HttpResponse response) {
        return response != null && response.getStatusLine().getStatusCode() == 200;
    }

    public static JSONObject requestJSON(final String uri, final Parameters params) {
        final HttpResponse response = request("GET", uri, params, new Parameters("Accept", "application/json, text/javascript, */*; q=0.01"), null);
        if (isSuccess(response)) {
            try {
                return new JSONObject(Network.getResponseData(response));
            } catch (final JSONException e) {
                Log.e("Network.requestJSON", e);
            }
        }

        return null;
    }

    private static String getResponseDataNoError(final HttpResponse response, boolean replaceWhitespace) {
        try {
            String data = EntityUtils.toString(response.getEntity(), "UTF-8");
            return replaceWhitespace ? BaseUtils.replaceWhitespace(data) : data;
        } catch (Exception e) {
            Log.e("getResponseData", e);
            return null;
        }
    }

    public static String getResponseData(final HttpResponse response) {
        return Network.getResponseData(response, true);
    }

    public static String getResponseData(final HttpResponse response, boolean replaceWhitespace) {
        if (!isSuccess(response)) {
            return null;
        }
        return getResponseDataNoError(response, replaceWhitespace);
    }

    public static String rfc3986URLEncode(String text) {
        return StringUtils.replace(URLEncoder.encode(text).replace("+", "%20"), "%7E", "~");
    }

}
!@#$%
20190527_000359,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_c02220
package cgeo.geocaching.network;

import cgeo.geocaching.Settings;
import cgeo.geocaching.files.LocalStorage;
import cgeo.geocaching.utils.BaseUtils;
import cgeo.geocaching.utils.Log;

import ch.boye.httpclientandroidlib.Header;
import ch.boye.httpclientandroidlib.HeaderElement;
import ch.boye.httpclientandroidlib.HttpEntity;
import ch.boye.httpclientandroidlib.HttpException;
import ch.boye.httpclientandroidlib.HttpRequest;
import ch.boye.httpclientandroidlib.HttpRequestInterceptor;
import ch.boye.httpclientandroidlib.HttpResponse;
import ch.boye.httpclientandroidlib.HttpResponseInterceptor;
import ch.boye.httpclientandroidlib.NameValuePair;
import ch.boye.httpclientandroidlib.ProtocolException;
import ch.boye.httpclientandroidlib.client.HttpClient;
import ch.boye.httpclientandroidlib.client.entity.GzipDecompressingEntity;
import ch.boye.httpclientandroidlib.client.entity.UrlEncodedFormEntity;
import ch.boye.httpclientandroidlib.client.methods.HttpGet;
import ch.boye.httpclientandroidlib.client.methods.HttpPost;
import ch.boye.httpclientandroidlib.client.methods.HttpRequestBase;
import ch.boye.httpclientandroidlib.client.params.ClientPNames;
import ch.boye.httpclientandroidlib.entity.mime.MultipartEntity;
import ch.boye.httpclientandroidlib.entity.mime.content.FileBody;
import ch.boye.httpclientandroidlib.entity.mime.content.StringBody;
import ch.boye.httpclientandroidlib.impl.client.DefaultHttpClient;
import ch.boye.httpclientandroidlib.impl.client.DefaultRedirectStrategy;
import ch.boye.httpclientandroidlib.params.BasicHttpParams;
import ch.boye.httpclientandroidlib.params.CoreConnectionPNames;
import ch.boye.httpclientandroidlib.params.CoreProtocolPNames;
import ch.boye.httpclientandroidlib.params.HttpParams;
import ch.boye.httpclientandroidlib.protocol.HttpContext;
import ch.boye.httpclientandroidlib.util.EntityUtils;

import org.apache.commons.lang3.StringUtils;
import org.json.JSONException;
import org.json.JSONObject;

import android.net.Uri;

import java.io.File;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;

public abstract class Network {

    private static final int NB_DOWNLOAD_RETRIES = 4;
    /** User agent id */
    private final static String PC_USER_AGENT = "Mozilla/5.0 (X11; Linux x86_64; rv:9.0.1) Gecko/20100101 Firefox/9.0.1";
    /** Native user agent, taken from a Android 2.2 Nexus **/
    private final static String NATIVE_USER_AGENT = "Mozilla/5.0 (Linux; U; Android 2.2; en-us; Nexus One Build/FRF91) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1";

    private static final String PATTERN_PASSWORD = "(?<=[\\?&])[Pp]ass(w(or)?d)?=[^&#$]+";

    private final static HttpParams clientParams = new BasicHttpParams();

    static {
        Network.clientParams.setParameter(CoreProtocolPNames.HTTP_CONTENT_CHARSET, "UTF-8");
        Network.clientParams.setParameter(CoreConnectionPNames.CONNECTION_TIMEOUT, 30000);
        Network.clientParams.setParameter(CoreConnectionPNames.SO_TIMEOUT, 30000);
        Network.clientParams.setParameter(ClientPNames.HANDLE_REDIRECTS,  true);
    }

    private static String hidePassword(final String message) {
        return message.replaceAll(Network.PATTERN_PASSWORD, "password=***");
    }

    private static HttpClient getHttpClient() {
        final DefaultHttpClient client = new DefaultHttpClient();
        client.setCookieStore(Cookies.cookieStore);
        client.setParams(clientParams);

        client.setRedirectStrategy(new DefaultRedirectStrategy() {
            @Override
            public boolean isRedirected(HttpRequest request, HttpResponse response, HttpContext context) {
                boolean isRedirect = false;
                try {
                    isRedirect = super.isRedirected(request, response, context);
                } catch (final ProtocolException e) {
                    Log.e("httpclient.isRedirected: unable to check for redirection", e);
                }
                if (!isRedirect) {
                    final int responseCode = response.getStatusLine().getStatusCode();
                    if (responseCode == 301 || responseCode == 302) {
                        return true;
                    }
                }
                return isRedirect;
            }
        });

        client.addRequestInterceptor(new HttpRequestInterceptor() {

            @Override
            public void process(
                    final HttpRequest request,
                    final HttpContext context) throws HttpException, IOException {
                if (!request.containsHeader("Accept-Encoding")) {
                    request.addHeader("Accept-Encoding", "gzip");
                }
            }
        });
        client.addResponseInterceptor(new HttpResponseInterceptor() {

            @Override
            public void process(
                    final HttpResponse response,
                    final HttpContext context) throws HttpException, IOException {
                final HttpEntity entity = response.getEntity();
                if (entity != null) {
                    final Header contentEncoding = entity.getContentEncoding();
                    if (contentEncoding != null) {
                        for (final HeaderElement codec : contentEncoding.getElements()) {
                            if (codec.getName().equalsIgnoreCase("gzip")) {
                                Log.d("Decompressing response");
                                response.setEntity(new GzipDecompressingEntity(response.getEntity()));
                                return;
                            }
                        }
                    }
                }
            }

        });

        return client;
    }

    /**
     * POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @return the HTTP response, or null in case of an encoding error params
     */
    public static HttpResponse postRequest(final String uri, final Parameters params) {
        return request("POST", uri, params, null, null);
    }

    /**
     * POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @params headers the headers to add to the request
     * @return the HTTP response, or null in case of an encoding error params
     */
    public static HttpResponse postRequest(final String uri, final Parameters params, final Parameters headers) {
        return request("POST", uri, params, headers, null);
    }

    /**
     * Multipart POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @param fileFieldName the name of the file field name
     * @param fileContentType the content-type of the file
     * @param file the file to include in the request
     * @return the HTTP response, or null in case of an encoding error param
     */
    public static HttpResponse postRequest(final String uri, final Parameters params,
                                           final String fileFieldName, final String fileContentType, final File file) {
        final MultipartEntity entity = new MultipartEntity();
        for (final NameValuePair param : params) {
            try {
                entity.addPart(param.getName(), new StringBody(param.getValue()));
            } catch (final UnsupportedEncodingException e) {
                Log.e("Network.postRequest: unsupported encoding for parameter " + param.getName(), e);
                return null;
            }
        }
        entity.addPart(fileFieldName, new FileBody(file, fileContentType));

        final HttpPost request = new HttpPost(uri);
        request.setEntity(entity);

        addHeaders(request, null, null);
        return doRepeatedRequests(request);
    }

    /**
     * Make an HTTP request
     *
     * @param method
     *            the HTTP method to use ("GET" or "POST")
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add to the URI
     * @param headers
     *            the headers to add to the request
     * @param cacheFile
     *            the cache file used to cache this query
     * @return the HTTP response, or null in case of an encoding error in a POST request arguments
     */
    private static HttpResponse request(final String method, final String uri, final Parameters params, final Parameters headers, final File cacheFile) {
        HttpRequestBase request;
        if (method.equals("GET")) {
            final String fullUri = params == null ? uri : Uri.parse(uri).buildUpon().encodedQuery(params.toString()).build().toString();
            request = new HttpGet(fullUri);
        } else {
            request = new HttpPost(uri);
            if (params != null) {
                try {
                    ((HttpPost) request).setEntity(new UrlEncodedFormEntity(params, "UTF-8"));
                } catch (final UnsupportedEncodingException e) {
                    Log.e("request", e);
                    return null;
                }
            }
        }

        addHeaders(request, headers, cacheFile);

        return doRepeatedRequests(request);
    }

    /**
     * Add headers to HTTP request.
     * @param request
     *            the request to add headers to
     * @param headers
     *            the headers to add (in addition to the standard headers), can be null
     * @param cacheFile
     *            if non-null, the file to take ETag and If-Modified-Since information from
     */
    private static void addHeaders(final HttpRequestBase request, final Parameters headers, final File cacheFile) {
        for (final NameValuePair header : Parameters.extend(Parameters.merge(headers, cacheHeaders(cacheFile)),
                "Accept-Charset", "utf-8,iso-8859-1;q=0.8,utf-16;q=0.8,*;q=0.7",
                "Accept-Language", "en-US,*;q=0.9",
                "X-Requested-With", "XMLHttpRequest")) {
            request.setHeader(header.getName(), header.getValue());
        }
        if (Settings.getUseNativeUa()) {
            request.getParams().setParameter(CoreProtocolPNames.USER_AGENT, Network.NATIVE_USER_AGENT);
        } else {
            request.getParams().setParameter(CoreProtocolPNames.USER_AGENT, Network.PC_USER_AGENT);
        }
    }

    /**
     * Retry a request for a few times.
     *
     * @param request
     *            the request to try
     * @return
     *            the response, or null if there has been a failure
     */
    private static HttpResponse doRepeatedRequests(final HttpRequestBase request) {
        final String reqLogStr = request.getMethod() + " " + Network.hidePassword(request.getURI().toString());
        Log.d(reqLogStr);

        final HttpClient client = Network.getHttpClient();
        for (int i = 0; i <= Network.NB_DOWNLOAD_RETRIES; i++) {
            final long before = System.currentTimeMillis();
            try {
                final HttpResponse response = client.execute(request);
                int status = response.getStatusLine().getStatusCode();
                if (status == 200) {
                    Log.d(status + Network.formatTimeSpan(before) + reqLogStr);
                } else {
                    Log.w(status + " [" + response.getStatusLine().getReasonPhrase() + "]" + Network.formatTimeSpan(before) + reqLogStr);
                }
                return response;
            } catch (IOException e) {
                final String timeSpan = Network.formatTimeSpan(before);
                final String tries = (i + 1) + "/" + (Network.NB_DOWNLOAD_RETRIES + 1);
                if (i == Network.NB_DOWNLOAD_RETRIES) {
                    Log.e("Failure " + tries + timeSpan + reqLogStr, e);
                } else {
                    Log.e("Failure " + tries + " (" + e.toString() + ")" + timeSpan + "- retrying " + reqLogStr);
                }
            }
        }

        return null;
    }

    private static Parameters cacheHeaders(final File cacheFile) {
        if (cacheFile == null || !cacheFile.exists()) {
            return null;
        }

        final String etag = LocalStorage.getSavedHeader(cacheFile, "etag");
        if (etag != null) {
            return new Parameters("If-None-Match", etag);
        }

        final String lastModified = LocalStorage.getSavedHeader(cacheFile, "last-modified");
        if (lastModified != null) {
            return new Parameters("If-Modified-Since", lastModified);
        }

        return null;
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @param cacheFile
     *            the name of the file storing the cached resource, or null not to use one
     * @return the HTTP response
     */
    public static HttpResponse getRequest(final String uri, final Parameters params, final File cacheFile) {
        return request("GET", uri, params, null, cacheFile);
    }


    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @return the HTTP response
     */
    public static HttpResponse getRequest(final String uri, final Parameters params) {
        return request("GET", uri, params, null, null);
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @param headers
     *            the headers to add to the GET request
     * @return the HTTP response
     */
    public static HttpResponse getRequest(final String uri, final Parameters params, final Parameters headers) {
        return request("GET", uri, params, headers, null);
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @return the HTTP response
     */
    public static HttpResponse getRequest(final String uri) {
        return request("GET", uri, null, null, null);
    }

    private static String formatTimeSpan(final long before) {
        // don't use String.format in a pure logging routine, it has very bad performance
        return " (" + (System.currentTimeMillis() - before) + " ms) ";
    }

    static public boolean isSuccess(final HttpResponse response) {
        return response != null && response.getStatusLine().getStatusCode() == 200;
    }

    public static JSONObject requestJSON(final String uri, final Parameters params) {
        final HttpResponse response = request("GET", uri, params, new Parameters("Accept", "application/json, text/javascript, */*; q=0.01"), null);
        if (isSuccess(response)) {
            try {
                return new JSONObject(Network.getResponseData(response));
            } catch (final JSONException e) {
                Log.e("Network.requestJSON", e);
            }
        }

        return null;
    }

    private static String getResponseDataNoError(final HttpResponse response, boolean replaceWhitespace) {
        try {
            String data = EntityUtils.toString(response.getEntity(), "UTF-8");
            return replaceWhitespace ? BaseUtils.replaceWhitespace(data) : data;
        } catch (Exception e) {
            Log.e("getResponseData", e);
            return null;
        }
    }

    public static String getResponseData(final HttpResponse response) {
        return Network.getResponseData(response, true);
    }

    public static String getResponseData(final HttpResponse response, boolean replaceWhitespace) {
        if (!isSuccess(response)) {
            return null;
        }
        return getResponseDataNoError(response, replaceWhitespace);
    }

    public static String rfc3986URLEncode(String text) {
        return StringUtils.replace(URLEncoder.encode(text).replace("+", "%20"), "%7E", "~");
    }

}
!@#$%
20190527_000523,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_b04056
package cgeo.geocaching.enumerations;

import cgeo.geocaching.R;
import cgeo.geocaching.cgeoapplication;

import java.util.Collections;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;



/**
 * Different log types
 */
public enum LogType {

    FOUND_IT(2, "2", "found it", R.string.log_found, R.drawable.mark_green),
    DIDNT_FIND_IT(3, "3", "didn't find it", R.string.log_dnf, R.drawable.mark_red),
    NOTE(4, "4", "write note", R.string.log_note),
    PUBLISH_LISTING(1003, "24", "publish listing", R.string.log_published, R.drawable.mark_green_more),
    ENABLE_LISTING(23, "23", "enable listing", R.string.log_enabled, R.drawable.mark_green_more),
    ARCHIVE(5, "5", "archive", R.string.log_archived, R.drawable.mark_red_more),
    TEMP_DISABLE_LISTING(22, "22", "temporarily disable listing", R.string.log_disabled, R.drawable.mark_red_more),
    NEEDS_ARCHIVE(7, "7", "needs archived", R.string.log_needs_archived, R.drawable.mark_red),
    WILL_ATTEND(9, "9", "will attend", R.string.log_attend),
    ATTENDED(10, "10", "attended", R.string.log_attended, R.drawable.mark_green),
    RETRIEVED_IT(13, "13", "retrieved it", R.string.log_retrieved, R.drawable.mark_green),
    PLACED_IT(14, "14", "placed it", R.string.log_placed),
    GRABBED_IT(19, "19", "grabbed it", R.string.log_grabbed, R.drawable.mark_green),
    NEEDS_MAINTENANCE(45, "45", "needs maintenance", R.string.log_maintenance_needed, R.drawable.mark_red),
    OWNER_MAINTENANCE(46, "46", "owner maintenance", R.string.log_maintained, R.drawable.mark_green_more),
    UPDATE_COORDINATES(47, "47", "update coordinates", R.string.log_update),
    DISCOVERED_IT(48, "48", "discovered it", R.string.log_discovered, R.drawable.mark_green),
    POST_REVIEWER_NOTE(18, "18", "post reviewer note", R.string.log_reviewer),
    VISIT(1001, "1001", "visit", R.string.log_tb_visit, R.drawable.mark_green),
    WEBCAM_PHOTO_TAKEN(11, "11", "webcam photo taken", R.string.log_webcam, R.drawable.mark_green),
    ANNOUNCEMENT(74, "74", "announcement", R.string.log_announcement),
    MOVE_COLLECTION(69, "69", "unused_collection", R.string.log_movecollection),
    MOVE_INVENTORY(70, "70", "unused_inventory", R.string.log_moveinventory),
    UNKNOWN(0, "unknown", "", R.string.err_unknown, R.drawable.mark_red); // LogType not init. yet

    public final int id;
    public final String iconName;
    public final String type;
    private final int stringId;
    public final int markerId;

    private LogType(int id, String iconName, String type, int stringId, int markerId) {
        this.id = id;
        this.iconName = iconName;
        this.type = type;
        this.stringId = stringId;
        this.markerId = markerId;
    }

    private LogType(int id, String iconName, String type, int stringId) {
        this(id, iconName, type, stringId, R.drawable.mark_gray);
    }

    private final static Map<String, LogType> FIND_BY_ICONNAME;
    private final static Map<String, LogType> FIND_BY_TYPE;
    static {
        final HashMap<String, LogType> mappingPattern = new HashMap<String, LogType>();
        final HashMap<String, LogType> mappingType = new HashMap<String, LogType>();
        for (LogType lt : values()) {
            mappingPattern.put(lt.iconName, lt);
            mappingType.put(lt.type, lt);
        }
        FIND_BY_ICONNAME = Collections.unmodifiableMap(mappingPattern);
        FIND_BY_TYPE = Collections.unmodifiableMap(mappingType);
    }

    public static LogType getById(final int id) {
        for (LogType logType : values()) {
            if (logType.id == id) {
                return logType;
            }
        }
        return UNKNOWN;
    }

    public static LogType getByIconName(final String imageType) {
        final LogType result = imageType != null ? LogType.FIND_BY_ICONNAME.get(imageType.toLowerCase(Locale.US).trim()) : null;
        if (result == null) {
            return UNKNOWN;
        }
        return result;
    }

    public static LogType getByType(final String type) {
        final LogType result = type != null ? LogType.FIND_BY_TYPE.get(type.toLowerCase(Locale.US).trim()) : null;
        if (result == null) {
            return UNKNOWN;
        }
        return result;
    }

    public final String getL10n() {
        return cgeoapplication.getInstance().getBaseContext().getResources().getString(stringId);
    }
}
!@#$%
20190527_000523,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_a04056
package cgeo.geocaching.enumerations;

import cgeo.geocaching.R;
import cgeo.geocaching.cgeoapplication;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;



/**
 * Different log types
 */
public enum LogType {

    FOUND_IT(2,"icon_smile","found it",R.string.log_found),
    DIDNT_FIND_IT(3, "icon_sad", "didn't find it", R.string.log_dnf),
    NOTE(4,"icon_note","write note",R.string.log_note),
    PUBLISH_LISTING(1003, "icon_greenlight", "publish listing", R.string.log_published),
    ENABLE_LISTING(23,"icon_enabled","enable listing",R.string.log_enabled),
    ARCHIVE(5,"traffic_cone","archive",R.string.log_archived),
    TEMP_DISABLE_LISTING(22,"icon_disabled","temporarily disable listing",R.string.log_disabled),
    NEEDS_ARCHIVE(7,"icon_remove","needs archived",R.string.log_needs_archived),
    WILL_ATTEND(9,"icon_rsvp","will attend",R.string.log_attend),
    ATTENDED(10,"icon_attended","attended",R.string.log_attended),
    RETRIEVED_IT(13,"picked_up","retrieved it",R.string.log_retrieved),
    PLACED_IT(14,"dropped_off","placed it",R.string.log_placed),
    GRABBED_IT(19,"transfer","grabbed it",R.string.log_grabbed),
    NEEDS_MAINTENANCE(45,"icon_needsmaint","needs maintenance",R.string.log_maintenance_needed),
    OWNER_MAINTENANCE(46,"icon_maint","owner maintenance",R.string.log_maintained),
    UPDATE_COORDINATES(47,"coord_update","update coordinates",R.string.log_update),
    DISCOVERED_IT(48,"icon_discovered","discovered it",R.string.log_discovered),
    POST_REVIEWER_NOTE(18,"big_smile","post reviewer note",R.string.log_reviewer),
    VISIT(1001, "icon_visited", "visit", R.string.log_tb_visit),
    WEBCAM_PHOTO_TAKEN(11, "icon_camera", "webcam photo taken", R.string.log_webcam),
    ANNOUNCEMENT(74, "icon_announcement", "announcement", R.string.log_announcement),
    MOVE_COLLECTION(69, "conflict_collection_icon_note", "unused_collection", R.string.log_movecollection),
    MOVE_INVENTORY(70, "conflict_inventory_icon_note", "unused_inventory", R.string.log_moveinventory),
    UNKNOWN(0, "unknown", "", R.string.err_unknown); // LogType not init. yet

    public final int id;
    public final String iconName;
    public final String type;
    private final int stringId;

    private LogType(int id, String iconName, String type, int stringId) {
        this.id = id;
        this.iconName = iconName;
        this.type = type;
        this.stringId = stringId;
    }

    private final static Map<String, LogType> FIND_BY_ICONNAME;
    private final static Map<String, LogType> FIND_BY_TYPE;
    static {
        final HashMap<String, LogType> mappingPattern = new HashMap<String, LogType>();
        final HashMap<String, LogType> mappingType = new HashMap<String, LogType>();
        for (LogType lt : values()) {
            mappingPattern.put(lt.iconName, lt);
            mappingType.put(lt.type, lt);
        }
        FIND_BY_ICONNAME = Collections.unmodifiableMap(mappingPattern);
        FIND_BY_TYPE = Collections.unmodifiableMap(mappingType);
    }

    public static LogType getById(final int id) {
        for (LogType logType : values()) {
            if (logType.id == id) {
                return logType;
            }
        }
        return UNKNOWN;
    }

    public static LogType getByIconName(final String imageType) {
        final LogType result = imageType != null ? LogType.FIND_BY_ICONNAME.get(imageType.toLowerCase().trim()) : null;
        if (result == null) {
            return UNKNOWN;
        }
        return result;
    }

    public static LogType getByType(final String type) {
        final LogType result = type != null ? LogType.FIND_BY_TYPE.get(type.toLowerCase().trim()) : null;
        if (result == null) {
            return UNKNOWN;
        }
        return result;
    }

    public final String getL10n() {
        return cgeoapplication.getInstance().getBaseContext().getResources().getString(stringId);
    }
}
!@#$%
20190527_000523,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_c04056
package cgeo.geocaching.enumerations;

import cgeo.geocaching.R;
import cgeo.geocaching.cgeoapplication;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;



/**
 * Different log types
 */
public enum LogType {

    FOUND_IT(2, "2", "found it", R.string.log_found),
    DIDNT_FIND_IT(3, "3", "didn't find it", R.string.log_dnf),
    NOTE(4, "4", "write note", R.string.log_note),
    PUBLISH_LISTING(1003, "24", "publish listing", R.string.log_published),
    ENABLE_LISTING(23, "23", "enable listing", R.string.log_enabled),
    ARCHIVE(5, "5", "archive", R.string.log_archived),
    TEMP_DISABLE_LISTING(22, "22", "temporarily disable listing", R.string.log_disabled),
    NEEDS_ARCHIVE(7, "7", "needs archived", R.string.log_needs_archived),
    WILL_ATTEND(9, "9", "will attend", R.string.log_attend),
    ATTENDED(10, "10", "attended", R.string.log_attended),
    RETRIEVED_IT(13, "13", "retrieved it", R.string.log_retrieved),
    PLACED_IT(14, "14", "placed it", R.string.log_placed),
    GRABBED_IT(19, "19", "grabbed it", R.string.log_grabbed),
    NEEDS_MAINTENANCE(45, "45", "needs maintenance", R.string.log_maintenance_needed),
    OWNER_MAINTENANCE(46, "46", "owner maintenance", R.string.log_maintained),
    UPDATE_COORDINATES(47, "47", "update coordinates", R.string.log_update),
    DISCOVERED_IT(48, "48", "discovered it", R.string.log_discovered),
    POST_REVIEWER_NOTE(18, "68", "post reviewer note", R.string.log_reviewer),
    VISIT(1001, "1001", "visit", R.string.log_tb_visit),
    WEBCAM_PHOTO_TAKEN(11, "11", "webcam photo taken", R.string.log_webcam),
    ANNOUNCEMENT(74, "74", "announcement", R.string.log_announcement),
    MOVE_COLLECTION(69, "69", "unused_collection", R.string.log_movecollection),
    MOVE_INVENTORY(70, "70", "unused_inventory", R.string.log_moveinventory),
    UNKNOWN(0, "unknown", "", R.string.err_unknown); // LogType not init. yet

    public final int id;
    public final String iconName;
    public final String type;
    private final int stringId;

    private LogType(int id, String iconName, String type, int stringId) {
        this.id = id;
        this.iconName = iconName;
        this.type = type;
        this.stringId = stringId;
    }

    private final static Map<String, LogType> FIND_BY_ICONNAME;
    private final static Map<String, LogType> FIND_BY_TYPE;
    static {
        final HashMap<String, LogType> mappingPattern = new HashMap<String, LogType>();
        final HashMap<String, LogType> mappingType = new HashMap<String, LogType>();
        for (LogType lt : values()) {
            mappingPattern.put(lt.iconName, lt);
            mappingType.put(lt.type, lt);
        }
        FIND_BY_ICONNAME = Collections.unmodifiableMap(mappingPattern);
        FIND_BY_TYPE = Collections.unmodifiableMap(mappingType);
    }

    public static LogType getById(final int id) {
        for (LogType logType : values()) {
            if (logType.id == id) {
                return logType;
            }
        }
        return UNKNOWN;
    }

    public static LogType getByIconName(final String imageType) {
        final LogType result = imageType != null ? LogType.FIND_BY_ICONNAME.get(imageType.toLowerCase().trim()) : null;
        if (result == null) {
            return UNKNOWN;
        }
        return result;
    }

    public static LogType getByType(final String type) {
        final LogType result = type != null ? LogType.FIND_BY_TYPE.get(type.toLowerCase().trim()) : null;
        if (result == null) {
            return UNKNOWN;
        }
        return result;
    }

    public final String getL10n() {
        return cgeoapplication.getInstance().getBaseContext().getResources().getString(stringId);
    }
}
!@#$%
20190527_000538,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_b03576
package cgeo.geocaching.enumerations;

import cgeo.geocaching.R;
import cgeo.geocaching.cgeoapplication;

import java.util.Collections;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;



/**
 * Different log types
 */
public enum LogType {

    FOUND_IT(2, "2", "found it", R.string.log_found, R.drawable.mark_green),
    DIDNT_FIND_IT(3, "3", "didn't find it", R.string.log_dnf, R.drawable.mark_red),
    NOTE(4, "4", "write note", R.string.log_note),
    PUBLISH_LISTING(1003, "24", "publish listing", R.string.log_published, R.drawable.mark_green_more),
    ENABLE_LISTING(23, "23", "enable listing", R.string.log_enabled, R.drawable.mark_green_more),
    ARCHIVE(5, "5", "archive", R.string.log_archived, R.drawable.mark_red_more),
    TEMP_DISABLE_LISTING(22, "22", "temporarily disable listing", R.string.log_disabled, R.drawable.mark_red_more),
    NEEDS_ARCHIVE(7, "7", "needs archived", R.string.log_needs_archived, R.drawable.mark_red),
    WILL_ATTEND(9, "9", "will attend", R.string.log_attend),
    ATTENDED(10, "10", "attended", R.string.log_attended, R.drawable.mark_green),
    RETRIEVED_IT(13, "13", "retrieved it", R.string.log_retrieved, R.drawable.mark_green),
    PLACED_IT(14, "14", "placed it", R.string.log_placed),
    GRABBED_IT(19, "19", "grabbed it", R.string.log_grabbed, R.drawable.mark_green),
    NEEDS_MAINTENANCE(45, "45", "needs maintenance", R.string.log_maintenance_needed, R.drawable.mark_red),
    OWNER_MAINTENANCE(46, "46", "owner maintenance", R.string.log_maintained, R.drawable.mark_green_more),
    UPDATE_COORDINATES(47, "47", "update coordinates", R.string.log_update),
    DISCOVERED_IT(48, "48", "discovered it", R.string.log_discovered, R.drawable.mark_green),
    POST_REVIEWER_NOTE(18, "68", "post reviewer note", R.string.log_reviewer),
    VISIT(1001, "1001", "visit", R.string.log_tb_visit, R.drawable.mark_green),
    WEBCAM_PHOTO_TAKEN(11, "11", "webcam photo taken", R.string.log_webcam, R.drawable.mark_green),
    ANNOUNCEMENT(74, "74", "announcement", R.string.log_announcement),
    MOVE_COLLECTION(69, "69", "unused_collection", R.string.log_movecollection),
    MOVE_INVENTORY(70, "70", "unused_inventory", R.string.log_moveinventory),
    UNKNOWN(0, "unknown", "", R.string.err_unknown, R.drawable.mark_red); // LogType not init. yet

    public final int id;
    public final String iconName;
    public final String type;
    private final int stringId;
    public final int markerId;

    private LogType(int id, String iconName, String type, int stringId, int markerId) {
        this.id = id;
        this.iconName = iconName;
        this.type = type;
        this.stringId = stringId;
        this.markerId = markerId;
    }

    private LogType(int id, String iconName, String type, int stringId) {
        this(id, iconName, type, stringId, R.drawable.mark_gray);
    }

    private final static Map<String, LogType> FIND_BY_ICONNAME;
    private final static Map<String, LogType> FIND_BY_TYPE;
    static {
        final HashMap<String, LogType> mappingPattern = new HashMap<String, LogType>();
        final HashMap<String, LogType> mappingType = new HashMap<String, LogType>();
        for (LogType lt : values()) {
            mappingPattern.put(lt.iconName, lt);
            mappingType.put(lt.type, lt);
        }
        FIND_BY_ICONNAME = Collections.unmodifiableMap(mappingPattern);
        FIND_BY_TYPE = Collections.unmodifiableMap(mappingType);
    }

    public static LogType getById(final int id) {
        for (LogType logType : values()) {
            if (logType.id == id) {
                return logType;
            }
        }
        return UNKNOWN;
    }

    public static LogType getByIconName(final String imageType) {
        final LogType result = imageType != null ? LogType.FIND_BY_ICONNAME.get(imageType.toLowerCase(Locale.US).trim()) : null;
        if (result == null) {
            return UNKNOWN;
        }
        return result;
    }

    public static LogType getByType(final String type) {
        final LogType result = type != null ? LogType.FIND_BY_TYPE.get(type.toLowerCase(Locale.US).trim()) : null;
        if (result == null) {
            return UNKNOWN;
        }
        return result;
    }

    public final String getL10n() {
        return cgeoapplication.getInstance().getBaseContext().getResources().getString(stringId);
    }
}
!@#$%
20190527_000538,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_a03576
package cgeo.geocaching.enumerations;

import cgeo.geocaching.R;
import cgeo.geocaching.cgeoapplication;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;



/**
 * Different log types
 */
public enum LogType {

    FOUND_IT(2, "2", "found it", R.string.log_found),
    DIDNT_FIND_IT(3, "3", "didn't find it", R.string.log_dnf),
    NOTE(4, "4", "write note", R.string.log_note),
    PUBLISH_LISTING(1003, "24", "publish listing", R.string.log_published),
    ENABLE_LISTING(23, "23", "enable listing", R.string.log_enabled),
    ARCHIVE(5, "5", "archive", R.string.log_archived),
    TEMP_DISABLE_LISTING(22, "22", "temporarily disable listing", R.string.log_disabled),
    NEEDS_ARCHIVE(7, "7", "needs archived", R.string.log_needs_archived),
    WILL_ATTEND(9, "9", "will attend", R.string.log_attend),
    ATTENDED(10, "10", "attended", R.string.log_attended),
    RETRIEVED_IT(13, "13", "retrieved it", R.string.log_retrieved),
    PLACED_IT(14, "14", "placed it", R.string.log_placed),
    GRABBED_IT(19, "19", "grabbed it", R.string.log_grabbed),
    NEEDS_MAINTENANCE(45, "45", "needs maintenance", R.string.log_maintenance_needed),
    OWNER_MAINTENANCE(46, "46", "owner maintenance", R.string.log_maintained),
    UPDATE_COORDINATES(47, "47", "update coordinates", R.string.log_update),
    DISCOVERED_IT(48, "48", "discovered it", R.string.log_discovered),
    POST_REVIEWER_NOTE(18, "68", "post reviewer note", R.string.log_reviewer),
    VISIT(1001, "1001", "visit", R.string.log_tb_visit),
    WEBCAM_PHOTO_TAKEN(11, "11", "webcam photo taken", R.string.log_webcam),
    ANNOUNCEMENT(74, "74", "announcement", R.string.log_announcement),
    MOVE_COLLECTION(69, "69", "unused_collection", R.string.log_movecollection),
    MOVE_INVENTORY(70, "70", "unused_inventory", R.string.log_moveinventory),
    UNKNOWN(0, "unknown", "", R.string.err_unknown); // LogType not init. yet

    public final int id;
    public final String iconName;
    public final String type;
    private final int stringId;

    private LogType(int id, String iconName, String type, int stringId) {
        this.id = id;
        this.iconName = iconName;
        this.type = type;
        this.stringId = stringId;
    }

    private final static Map<String, LogType> FIND_BY_ICONNAME;
    private final static Map<String, LogType> FIND_BY_TYPE;
    static {
        final HashMap<String, LogType> mappingPattern = new HashMap<String, LogType>();
        final HashMap<String, LogType> mappingType = new HashMap<String, LogType>();
        for (LogType lt : values()) {
            mappingPattern.put(lt.iconName, lt);
            mappingType.put(lt.type, lt);
        }
        FIND_BY_ICONNAME = Collections.unmodifiableMap(mappingPattern);
        FIND_BY_TYPE = Collections.unmodifiableMap(mappingType);
    }

    public static LogType getById(final int id) {
        for (LogType logType : values()) {
            if (logType.id == id) {
                return logType;
            }
        }
        return UNKNOWN;
    }

    public static LogType getByIconName(final String imageType) {
        final LogType result = imageType != null ? LogType.FIND_BY_ICONNAME.get(imageType.toLowerCase().trim()) : null;
        if (result == null) {
            return UNKNOWN;
        }
        return result;
    }

    public static LogType getByType(final String type) {
        final LogType result = type != null ? LogType.FIND_BY_TYPE.get(type.toLowerCase().trim()) : null;
        if (result == null) {
            return UNKNOWN;
        }
        return result;
    }

    public final String getL10n() {
        return cgeoapplication.getInstance().getBaseContext().getResources().getString(stringId);
    }
}
!@#$%
20190527_000538,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_c03576
package cgeo.geocaching.enumerations;

import cgeo.geocaching.R;
import cgeo.geocaching.cgeoapplication;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;



/**
 * Different log types
 */
public enum LogType {

    FOUND_IT(2, "2", "found it", R.string.log_found),
    DIDNT_FIND_IT(3, "3", "didn't find it", R.string.log_dnf),
    NOTE(4, "4", "write note", R.string.log_note),
    PUBLISH_LISTING(1003, "24", "publish listing", R.string.log_published),
    ENABLE_LISTING(23, "23", "enable listing", R.string.log_enabled),
    ARCHIVE(5, "5", "archive", R.string.log_archived),
    TEMP_DISABLE_LISTING(22, "22", "temporarily disable listing", R.string.log_disabled),
    NEEDS_ARCHIVE(7, "7", "needs archived", R.string.log_needs_archived),
    WILL_ATTEND(9, "9", "will attend", R.string.log_attend),
    ATTENDED(10, "10", "attended", R.string.log_attended),
    RETRIEVED_IT(13, "13", "retrieved it", R.string.log_retrieved),
    PLACED_IT(14, "14", "placed it", R.string.log_placed),
    GRABBED_IT(19, "19", "grabbed it", R.string.log_grabbed),
    NEEDS_MAINTENANCE(45, "45", "needs maintenance", R.string.log_maintenance_needed),
    OWNER_MAINTENANCE(46, "46", "owner maintenance", R.string.log_maintained),
    UPDATE_COORDINATES(47, "47", "update coordinates", R.string.log_update),
    DISCOVERED_IT(48, "48", "discovered it", R.string.log_discovered),
    POST_REVIEWER_NOTE(18, "68", "post reviewer note", R.string.log_reviewer),
    VISIT(1001, "75", "visit", R.string.log_tb_visit),
    WEBCAM_PHOTO_TAKEN(11, "11", "webcam photo taken", R.string.log_webcam),
    ANNOUNCEMENT(74, "74", "announcement", R.string.log_announcement),
    MOVE_COLLECTION(69, "69", "unused_collection", R.string.log_movecollection),
    MOVE_INVENTORY(70, "70", "unused_inventory", R.string.log_moveinventory),
    UNKNOWN(0, "unknown", "", R.string.err_unknown); // LogType not init. yet

    public final int id;
    public final String iconName;
    public final String type;
    private final int stringId;

    private LogType(int id, String iconName, String type, int stringId) {
        this.id = id;
        this.iconName = iconName;
        this.type = type;
        this.stringId = stringId;
    }

    private final static Map<String, LogType> FIND_BY_ICONNAME;
    private final static Map<String, LogType> FIND_BY_TYPE;
    static {
        final HashMap<String, LogType> mappingPattern = new HashMap<String, LogType>();
        final HashMap<String, LogType> mappingType = new HashMap<String, LogType>();
        for (LogType lt : values()) {
            mappingPattern.put(lt.iconName, lt);
            mappingType.put(lt.type, lt);
        }
        FIND_BY_ICONNAME = Collections.unmodifiableMap(mappingPattern);
        FIND_BY_TYPE = Collections.unmodifiableMap(mappingType);
    }

    public static LogType getById(final int id) {
        for (LogType logType : values()) {
            if (logType.id == id) {
                return logType;
            }
        }
        return UNKNOWN;
    }

    public static LogType getByIconName(final String imageType) {
        final LogType result = imageType != null ? LogType.FIND_BY_ICONNAME.get(imageType.toLowerCase().trim()) : null;
        if (result == null) {
            return UNKNOWN;
        }
        return result;
    }

    public static LogType getByType(final String type) {
        final LogType result = type != null ? LogType.FIND_BY_TYPE.get(type.toLowerCase().trim()) : null;
        if (result == null) {
            return UNKNOWN;
        }
        return result;
    }

    public final String getL10n() {
        return cgeoapplication.getInstance().getBaseContext().getResources().getString(stringId);
    }
}
!@#$%
20190527_000553,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_b11000
package cgeo.geocaching.enumerations;

import cgeo.geocaching.R;
import cgeo.geocaching.cgeoapplication;

import java.util.Collections;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;



/**
 * Different log types
 */
public enum LogType {

    FOUND_IT(2, "2", "found it", R.string.log_found, R.drawable.mark_green),
    DIDNT_FIND_IT(3, "3", "didn't find it", R.string.log_dnf, R.drawable.mark_red),
    NOTE(4, "4", "write note", R.string.log_note),
    PUBLISH_LISTING(1003, "24", "publish listing", R.string.log_published, R.drawable.mark_green_more),
    ENABLE_LISTING(23, "23", "enable listing", R.string.log_enabled, R.drawable.mark_green_more),
    ARCHIVE(5, "5", "archive", R.string.log_archived, R.drawable.mark_red_more),
    TEMP_DISABLE_LISTING(22, "22", "temporarily disable listing", R.string.log_disabled, R.drawable.mark_red_more),
    NEEDS_ARCHIVE(7, "7", "needs archived", R.string.log_needs_archived, R.drawable.mark_red),
    WILL_ATTEND(9, "9", "will attend", R.string.log_attend),
    ATTENDED(10, "10", "attended", R.string.log_attended, R.drawable.mark_green),
    RETRIEVED_IT(13, "13", "retrieved it", R.string.log_retrieved, R.drawable.mark_green),
    PLACED_IT(14, "14", "placed it", R.string.log_placed),
    GRABBED_IT(19, "19", "grabbed it", R.string.log_grabbed, R.drawable.mark_green),
    NEEDS_MAINTENANCE(45, "45", "needs maintenance", R.string.log_maintenance_needed, R.drawable.mark_red),
    OWNER_MAINTENANCE(46, "46", "owner maintenance", R.string.log_maintained, R.drawable.mark_green_more),
    UPDATE_COORDINATES(47, "47", "update coordinates", R.string.log_update),
    DISCOVERED_IT(48, "48", "discovered it", R.string.log_discovered, R.drawable.mark_green),
    POST_REVIEWER_NOTE(18, "68", "post reviewer note", R.string.log_reviewer),
    VISIT(1001, "75", "visit", R.string.log_tb_visit, R.drawable.mark_green),
    WEBCAM_PHOTO_TAKEN(11, "11", "webcam photo taken", R.string.log_webcam, R.drawable.mark_green),
    ANNOUNCEMENT(74, "74", "announcement", R.string.log_announcement),
    MOVE_COLLECTION(69, "69", "unused_collection", R.string.log_movecollection),
    MOVE_INVENTORY(70, "70", "unused_inventory", R.string.log_moveinventory),
    RETRACT(25, "25", "rectract listing", R.string.log_retractlisting),
    UNKNOWN(0, "unknown", "", R.string.err_unknown, R.drawable.mark_red); // LogType not init. yet

    public final int id;
    public final String iconName;
    public final String type;
    private final int stringId;
    public final int markerId;

    private LogType(int id, String iconName, String type, int stringId, int markerId) {
        this.id = id;
        this.iconName = iconName;
        this.type = type;
        this.stringId = stringId;
        this.markerId = markerId;
    }

    private LogType(int id, String iconName, String type, int stringId) {
        this(id, iconName, type, stringId, R.drawable.mark_gray);
    }

    private final static Map<String, LogType> FIND_BY_ICONNAME;
    private final static Map<String, LogType> FIND_BY_TYPE;
    static {
        final HashMap<String, LogType> mappingPattern = new HashMap<String, LogType>();
        final HashMap<String, LogType> mappingType = new HashMap<String, LogType>();
        for (LogType lt : values()) {
            mappingPattern.put(lt.iconName, lt);
            mappingType.put(lt.type, lt);
        }
        FIND_BY_ICONNAME = Collections.unmodifiableMap(mappingPattern);
        FIND_BY_TYPE = Collections.unmodifiableMap(mappingType);
    }

    public static LogType getById(final int id) {
        for (LogType logType : values()) {
            if (logType.id == id) {
                return logType;
            }
        }
        return UNKNOWN;
    }

    public static LogType getByIconName(final String imageType) {
        final LogType result = imageType != null ? LogType.FIND_BY_ICONNAME.get(imageType.toLowerCase(Locale.US).trim()) : null;
        if (result == null) {
            return UNKNOWN;
        }
        return result;
    }

    public static LogType getByType(final String type) {
        final LogType result = type != null ? LogType.FIND_BY_TYPE.get(type.toLowerCase(Locale.US).trim()) : null;
        if (result == null) {
            return UNKNOWN;
        }
        return result;
    }

    public final String getL10n() {
        return cgeoapplication.getInstance().getBaseContext().getResources().getString(stringId);
    }
}
!@#$%
20190527_000553,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_a11000
package cgeo.geocaching.enumerations;

import cgeo.geocaching.R;
import cgeo.geocaching.cgeoapplication;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;



/**
 * Different log types
 */
public enum LogType {

    FOUND_IT(2, "2", "found it", R.string.log_found),
    DIDNT_FIND_IT(3, "3", "didn't find it", R.string.log_dnf),
    NOTE(4, "4", "write note", R.string.log_note),
    PUBLISH_LISTING(1003, "24", "publish listing", R.string.log_published),
    ENABLE_LISTING(23, "23", "enable listing", R.string.log_enabled),
    ARCHIVE(5, "5", "archive", R.string.log_archived),
    TEMP_DISABLE_LISTING(22, "22", "temporarily disable listing", R.string.log_disabled),
    NEEDS_ARCHIVE(7, "7", "needs archived", R.string.log_needs_archived),
    WILL_ATTEND(9, "9", "will attend", R.string.log_attend),
    ATTENDED(10, "10", "attended", R.string.log_attended),
    RETRIEVED_IT(13, "13", "retrieved it", R.string.log_retrieved),
    PLACED_IT(14, "14", "placed it", R.string.log_placed),
    GRABBED_IT(19, "19", "grabbed it", R.string.log_grabbed),
    NEEDS_MAINTENANCE(45, "45", "needs maintenance", R.string.log_maintenance_needed),
    OWNER_MAINTENANCE(46, "46", "owner maintenance", R.string.log_maintained),
    UPDATE_COORDINATES(47, "47", "update coordinates", R.string.log_update),
    DISCOVERED_IT(48, "48", "discovered it", R.string.log_discovered),
    POST_REVIEWER_NOTE(18, "68", "post reviewer note", R.string.log_reviewer),
    VISIT(1001, "75", "visit", R.string.log_tb_visit),
    WEBCAM_PHOTO_TAKEN(11, "11", "webcam photo taken", R.string.log_webcam),
    ANNOUNCEMENT(74, "74", "announcement", R.string.log_announcement),
    MOVE_COLLECTION(69, "69", "unused_collection", R.string.log_movecollection),
    MOVE_INVENTORY(70, "70", "unused_inventory", R.string.log_moveinventory),
    UNKNOWN(0, "unknown", "", R.string.err_unknown); // LogType not init. yet

    public final int id;
    public final String iconName;
    public final String type;
    private final int stringId;

    private LogType(int id, String iconName, String type, int stringId) {
        this.id = id;
        this.iconName = iconName;
        this.type = type;
        this.stringId = stringId;
    }

    private final static Map<String, LogType> FIND_BY_ICONNAME;
    private final static Map<String, LogType> FIND_BY_TYPE;
    static {
        final HashMap<String, LogType> mappingPattern = new HashMap<String, LogType>();
        final HashMap<String, LogType> mappingType = new HashMap<String, LogType>();
        for (LogType lt : values()) {
            mappingPattern.put(lt.iconName, lt);
            mappingType.put(lt.type, lt);
        }
        FIND_BY_ICONNAME = Collections.unmodifiableMap(mappingPattern);
        FIND_BY_TYPE = Collections.unmodifiableMap(mappingType);
    }

    public static LogType getById(final int id) {
        for (LogType logType : values()) {
            if (logType.id == id) {
                return logType;
            }
        }
        return UNKNOWN;
    }

    public static LogType getByIconName(final String imageType) {
        final LogType result = imageType != null ? LogType.FIND_BY_ICONNAME.get(imageType.toLowerCase().trim()) : null;
        if (result == null) {
            return UNKNOWN;
        }
        return result;
    }

    public static LogType getByType(final String type) {
        final LogType result = type != null ? LogType.FIND_BY_TYPE.get(type.toLowerCase().trim()) : null;
        if (result == null) {
            return UNKNOWN;
        }
        return result;
    }

    public final String getL10n() {
        return cgeoapplication.getInstance().getBaseContext().getResources().getString(stringId);
    }
}
!@#$%
20190527_000553,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_c11000
package cgeo.geocaching.enumerations;

import cgeo.geocaching.R;
import cgeo.geocaching.cgeoapplication;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;



/**
 * Different log types
 */
public enum LogType {

    FOUND_IT(2, "2", "found it", R.string.log_found),
    DIDNT_FIND_IT(3, "3", "didn't find it", R.string.log_dnf),
    NOTE(4, "4", "write note", R.string.log_note),
    PUBLISH_LISTING(1003, "24", "publish listing", R.string.log_published),
    ENABLE_LISTING(23, "23", "enable listing", R.string.log_enabled),
    ARCHIVE(5, "5", "archive", R.string.log_archived),
    UNARCHIVE(12, "12", "unarchive", R.string.log_unarchived),
    TEMP_DISABLE_LISTING(22, "22", "temporarily disable listing", R.string.log_disabled),
    NEEDS_ARCHIVE(7, "7", "needs archived", R.string.log_needs_archived),
    WILL_ATTEND(9, "9", "will attend", R.string.log_attend),
    ATTENDED(10, "10", "attended", R.string.log_attended),
    RETRIEVED_IT(13, "13", "retrieved it", R.string.log_retrieved),
    PLACED_IT(14, "14", "placed it", R.string.log_placed),
    GRABBED_IT(19, "19", "grabbed it", R.string.log_grabbed),
    NEEDS_MAINTENANCE(45, "45", "needs maintenance", R.string.log_maintenance_needed),
    OWNER_MAINTENANCE(46, "46", "owner maintenance", R.string.log_maintained),
    UPDATE_COORDINATES(47, "47", "update coordinates", R.string.log_update),
    DISCOVERED_IT(48, "48", "discovered it", R.string.log_discovered),
    POST_REVIEWER_NOTE(18, "68", "post reviewer note", R.string.log_reviewer),
    VISIT(1001, "75", "visit", R.string.log_tb_visit),
    WEBCAM_PHOTO_TAKEN(11, "11", "webcam photo taken", R.string.log_webcam),
    ANNOUNCEMENT(74, "74", "announcement", R.string.log_announcement),
    MOVE_COLLECTION(69, "69", "unused_collection", R.string.log_movecollection),
    MOVE_INVENTORY(70, "70", "unused_inventory", R.string.log_moveinventory),
    UNKNOWN(0, "unknown", "", R.string.err_unknown); // LogType not init. yet

    public final int id;
    public final String iconName;
    public final String type;
    private final int stringId;

    private LogType(int id, String iconName, String type, int stringId) {
        this.id = id;
        this.iconName = iconName;
        this.type = type;
        this.stringId = stringId;
    }

    private final static Map<String, LogType> FIND_BY_ICONNAME;
    private final static Map<String, LogType> FIND_BY_TYPE;
    static {
        final HashMap<String, LogType> mappingPattern = new HashMap<String, LogType>();
        final HashMap<String, LogType> mappingType = new HashMap<String, LogType>();
        for (LogType lt : values()) {
            mappingPattern.put(lt.iconName, lt);
            mappingType.put(lt.type, lt);
        }
        FIND_BY_ICONNAME = Collections.unmodifiableMap(mappingPattern);
        FIND_BY_TYPE = Collections.unmodifiableMap(mappingType);
    }

    public static LogType getById(final int id) {
        for (LogType logType : values()) {
            if (logType.id == id) {
                return logType;
            }
        }
        return UNKNOWN;
    }

    public static LogType getByIconName(final String imageType) {
        final LogType result = imageType != null ? LogType.FIND_BY_ICONNAME.get(imageType.toLowerCase().trim()) : null;
        if (result == null) {
            return UNKNOWN;
        }
        return result;
    }

    public static LogType getByType(final String type) {
        final LogType result = type != null ? LogType.FIND_BY_TYPE.get(type.toLowerCase().trim()) : null;
        if (result == null) {
            return UNKNOWN;
        }
        return result;
    }

    public final String getL10n() {
        return cgeoapplication.getInstance().getBaseContext().getResources().getString(stringId);
    }
}
!@#$%
20190527_000605,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_b21328
package cgeo.geocaching.enumerations;

import cgeo.geocaching.R;
import cgeo.geocaching.cgeoapplication;

import java.util.Collections;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;



/**
 * Different log types
 */
public enum LogType {

    FOUND_IT(2, "2", "found it", R.string.log_found, R.drawable.mark_green),
    DIDNT_FIND_IT(3, "3", "didn't find it", R.string.log_dnf, R.drawable.mark_red),
    NOTE(4, "4", "write note", R.string.log_note),
    PUBLISH_LISTING(1003, "24", "publish listing", R.string.log_published, R.drawable.mark_green_more),
    ENABLE_LISTING(23, "23", "enable listing", R.string.log_enabled, R.drawable.mark_green_more),
    ARCHIVE(5, "5", "archive", R.string.log_archived, R.drawable.mark_red_more),
    UNARCHIVE(12, "12", "unarchive", R.string.log_unarchived, R.drawable.mark_green_more),
    TEMP_DISABLE_LISTING(22, "22", "temporarily disable listing", R.string.log_disabled, R.drawable.mark_red_more),
    NEEDS_ARCHIVE(7, "7", "needs archived", R.string.log_needs_archived, R.drawable.mark_red),
    WILL_ATTEND(9, "9", "will attend", R.string.log_attend),
    ATTENDED(10, "10", "attended", R.string.log_attended, R.drawable.mark_green),
    RETRIEVED_IT(13, "13", "retrieved it", R.string.log_retrieved, R.drawable.mark_green),
    PLACED_IT(14, "14", "placed it", R.string.log_placed),
    GRABBED_IT(19, "19", "grabbed it", R.string.log_grabbed, R.drawable.mark_green),
    NEEDS_MAINTENANCE(45, "45", "needs maintenance", R.string.log_maintenance_needed, R.drawable.mark_red),
    OWNER_MAINTENANCE(46, "46", "owner maintenance", R.string.log_maintained, R.drawable.mark_green_more),
    UPDATE_COORDINATES(47, "47", "update coordinates", R.string.log_update),
    DISCOVERED_IT(48, "48", "discovered it", R.string.log_discovered, R.drawable.mark_green),
    POST_REVIEWER_NOTE(18, "68", "post reviewer note", R.string.log_reviewer),
    VISIT(1001, "75", "visit", R.string.log_tb_visit, R.drawable.mark_green),
    WEBCAM_PHOTO_TAKEN(11, "11", "webcam photo taken", R.string.log_webcam, R.drawable.mark_green),
    ANNOUNCEMENT(74, "74", "announcement", R.string.log_announcement),
    MOVE_COLLECTION(69, "69", "unused_collection", R.string.log_movecollection),
    MOVE_INVENTORY(70, "70", "unused_inventory", R.string.log_moveinventory),
    RETRACT(25, "25", "rectract listing", R.string.log_retractlisting),
    UNKNOWN(0, "unknown", "", R.string.err_unknown, R.drawable.mark_red); // LogType not init. yet

    public final int id;
    public final String iconName;
    public final String type;
    private final int stringId;
    public final int markerId;

    private LogType(int id, String iconName, String type, int stringId, int markerId) {
        this.id = id;
        this.iconName = iconName;
        this.type = type;
        this.stringId = stringId;
        this.markerId = markerId;
    }

    private LogType(int id, String iconName, String type, int stringId) {
        this(id, iconName, type, stringId, R.drawable.mark_gray);
    }

    private final static Map<String, LogType> FIND_BY_ICONNAME;
    private final static Map<String, LogType> FIND_BY_TYPE;
    static {
        final HashMap<String, LogType> mappingPattern = new HashMap<String, LogType>();
        final HashMap<String, LogType> mappingType = new HashMap<String, LogType>();
        for (LogType lt : values()) {
            mappingPattern.put(lt.iconName, lt);
            mappingType.put(lt.type, lt);
        }
        FIND_BY_ICONNAME = Collections.unmodifiableMap(mappingPattern);
        FIND_BY_TYPE = Collections.unmodifiableMap(mappingType);
    }

    public static LogType getById(final int id) {
        for (LogType logType : values()) {
            if (logType.id == id) {
                return logType;
            }
        }
        return UNKNOWN;
    }

    public static LogType getByIconName(final String imageType) {
        final LogType result = imageType != null ? LogType.FIND_BY_ICONNAME.get(imageType.toLowerCase(Locale.US).trim()) : null;
        if (result == null) {
            return UNKNOWN;
        }
        return result;
    }

    public static LogType getByType(final String type) {
        final LogType result = type != null ? LogType.FIND_BY_TYPE.get(type.toLowerCase(Locale.US).trim()) : null;
        if (result == null) {
            return UNKNOWN;
        }
        return result;
    }

    public final String getL10n() {
        return cgeoapplication.getInstance().getBaseContext().getResources().getString(stringId);
    }
}
!@#$%
20190527_000605,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_a21328
package cgeo.geocaching.enumerations;

import cgeo.geocaching.R;
import cgeo.geocaching.cgeoapplication;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;



/**
 * Different log types
 */
public enum LogType {

    FOUND_IT(2, "2", "found it", R.string.log_found),
    DIDNT_FIND_IT(3, "3", "didn't find it", R.string.log_dnf),
    NOTE(4, "4", "write note", R.string.log_note),
    PUBLISH_LISTING(1003, "24", "publish listing", R.string.log_published),
    ENABLE_LISTING(23, "23", "enable listing", R.string.log_enabled),
    ARCHIVE(5, "5", "archive", R.string.log_archived),
    UNARCHIVE(12, "12", "unarchive", R.string.log_unarchived),
    TEMP_DISABLE_LISTING(22, "22", "temporarily disable listing", R.string.log_disabled),
    NEEDS_ARCHIVE(7, "7", "needs archived", R.string.log_needs_archived),
    WILL_ATTEND(9, "9", "will attend", R.string.log_attend),
    ATTENDED(10, "10", "attended", R.string.log_attended),
    RETRIEVED_IT(13, "13", "retrieved it", R.string.log_retrieved),
    PLACED_IT(14, "14", "placed it", R.string.log_placed),
    GRABBED_IT(19, "19", "grabbed it", R.string.log_grabbed),
    NEEDS_MAINTENANCE(45, "45", "needs maintenance", R.string.log_maintenance_needed),
    OWNER_MAINTENANCE(46, "46", "owner maintenance", R.string.log_maintained),
    UPDATE_COORDINATES(47, "47", "update coordinates", R.string.log_update),
    DISCOVERED_IT(48, "48", "discovered it", R.string.log_discovered),
    POST_REVIEWER_NOTE(18, "68", "post reviewer note", R.string.log_reviewer),
    VISIT(1001, "75", "visit", R.string.log_tb_visit),
    WEBCAM_PHOTO_TAKEN(11, "11", "webcam photo taken", R.string.log_webcam),
    ANNOUNCEMENT(74, "74", "announcement", R.string.log_announcement),
    MOVE_COLLECTION(69, "69", "unused_collection", R.string.log_movecollection),
    MOVE_INVENTORY(70, "70", "unused_inventory", R.string.log_moveinventory),
    UNKNOWN(0, "unknown", "", R.string.err_unknown); // LogType not init. yet

    public final int id;
    public final String iconName;
    public final String type;
    private final int stringId;

    private LogType(int id, String iconName, String type, int stringId) {
        this.id = id;
        this.iconName = iconName;
        this.type = type;
        this.stringId = stringId;
    }

    private final static Map<String, LogType> FIND_BY_ICONNAME;
    private final static Map<String, LogType> FIND_BY_TYPE;
    static {
        final HashMap<String, LogType> mappingPattern = new HashMap<String, LogType>();
        final HashMap<String, LogType> mappingType = new HashMap<String, LogType>();
        for (LogType lt : values()) {
            mappingPattern.put(lt.iconName, lt);
            mappingType.put(lt.type, lt);
        }
        FIND_BY_ICONNAME = Collections.unmodifiableMap(mappingPattern);
        FIND_BY_TYPE = Collections.unmodifiableMap(mappingType);
    }

    public static LogType getById(final int id) {
        for (LogType logType : values()) {
            if (logType.id == id) {
                return logType;
            }
        }
        return UNKNOWN;
    }

    public static LogType getByIconName(final String imageType) {
        final LogType result = imageType != null ? LogType.FIND_BY_ICONNAME.get(imageType.toLowerCase().trim()) : null;
        if (result == null) {
            return UNKNOWN;
        }
        return result;
    }

    public static LogType getByType(final String type) {
        final LogType result = type != null ? LogType.FIND_BY_TYPE.get(type.toLowerCase().trim()) : null;
        if (result == null) {
            return UNKNOWN;
        }
        return result;
    }

    public final String getL10n() {
        return cgeoapplication.getInstance().getBaseContext().getResources().getString(stringId);
    }
}
!@#$%
20190527_000605,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_c21328
package cgeo.geocaching.enumerations;

import cgeo.geocaching.R;
import cgeo.geocaching.cgeoapplication;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;



/**
 * Different log types
 */
public enum LogType {

    FOUND_IT(2, "2", "found it", R.string.log_found),
    DIDNT_FIND_IT(3, "3", "didn't find it", R.string.log_dnf),
    NOTE(4, "4", "write note", R.string.log_note),
    PUBLISH_LISTING(1003, "24", "publish listing", R.string.log_published),
    ENABLE_LISTING(23, "23", "enable listing", R.string.log_enabled),
    ARCHIVE(5, "5", "archive", R.string.log_archived),
    UNARCHIVE(12, "12", "unarchive", R.string.log_unarchived),
    TEMP_DISABLE_LISTING(22, "22", "temporarily disable listing", R.string.log_disabled),
    NEEDS_ARCHIVE(7, "7", "needs archived", R.string.log_needs_archived),
    WILL_ATTEND(9, "9", "will attend", R.string.log_attend),
    ATTENDED(10, "10", "attended", R.string.log_attended),
    RETRIEVED_IT(13, "13", "retrieved it", R.string.log_retrieved),
    PLACED_IT(14, "14", "placed it", R.string.log_placed),
    GRABBED_IT(19, "19", "grabbed it", R.string.log_grabbed),
    NEEDS_MAINTENANCE(45, "45", "needs maintenance", R.string.log_maintenance_needed),
    OWNER_MAINTENANCE(46, "46", "owner maintenance", R.string.log_maintained),
    UPDATE_COORDINATES(47, "47", "update coordinates", R.string.log_update),
    DISCOVERED_IT(48, "48", "discovered it", R.string.log_discovered),
    POST_REVIEWER_NOTE(18, "68", "post reviewer note", R.string.log_reviewer),
    VISIT(1001, "75", "visit", R.string.log_tb_visit),
    WEBCAM_PHOTO_TAKEN(11, "11", "webcam photo taken", R.string.log_webcam),
    ANNOUNCEMENT(74, "74", "announcement", R.string.log_announcement),
    MOVE_COLLECTION(69, "69", "unused_collection", R.string.log_movecollection),
    MOVE_INVENTORY(70, "70", "unused_inventory", R.string.log_moveinventory),
    RETRACT(25, "25", "retract listing", R.string.log_retractlisting),
    UNKNOWN(0, "unknown", "", R.string.err_unknown); // LogType not init. yet

    public final int id;
    public final String iconName;
    public final String type;
    private final int stringId;

    private LogType(int id, String iconName, String type, int stringId) {
        this.id = id;
        this.iconName = iconName;
        this.type = type;
        this.stringId = stringId;
    }

    private final static Map<String, LogType> FIND_BY_ICONNAME;
    private final static Map<String, LogType> FIND_BY_TYPE;
    static {
        final HashMap<String, LogType> mappingPattern = new HashMap<String, LogType>();
        final HashMap<String, LogType> mappingType = new HashMap<String, LogType>();
        for (LogType lt : values()) {
            mappingPattern.put(lt.iconName, lt);
            mappingType.put(lt.type, lt);
        }
        FIND_BY_ICONNAME = Collections.unmodifiableMap(mappingPattern);
        FIND_BY_TYPE = Collections.unmodifiableMap(mappingType);
    }

    public static LogType getById(final int id) {
        for (LogType logType : values()) {
            if (logType.id == id) {
                return logType;
            }
        }
        return UNKNOWN;
    }

    public static LogType getByIconName(final String imageType) {
        final LogType result = imageType != null ? LogType.FIND_BY_ICONNAME.get(imageType.toLowerCase().trim()) : null;
        if (result == null) {
            return UNKNOWN;
        }
        return result;
    }

    public static LogType getByType(final String type) {
        final LogType result = type != null ? LogType.FIND_BY_TYPE.get(type.toLowerCase().trim()) : null;
        if (result == null) {
            return UNKNOWN;
        }
        return result;
    }

    public final String getL10n() {
        return cgeoapplication.getInstance().getBaseContext().getResources().getString(stringId);
    }
}
!@#$%
20190527_000653,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_b16200
package cgeo.geocaching.network;

import cgeo.geocaching.Settings;
import cgeo.geocaching.files.LocalStorage;
import cgeo.geocaching.utils.BaseUtils;
import cgeo.geocaching.utils.Log;

import ch.boye.httpclientandroidlib.Header;
import ch.boye.httpclientandroidlib.HeaderElement;
import ch.boye.httpclientandroidlib.HttpEntity;
import ch.boye.httpclientandroidlib.HttpException;
import ch.boye.httpclientandroidlib.HttpRequest;
import ch.boye.httpclientandroidlib.HttpRequestInterceptor;
import ch.boye.httpclientandroidlib.HttpResponse;
import ch.boye.httpclientandroidlib.HttpResponseInterceptor;
import ch.boye.httpclientandroidlib.NameValuePair;
import ch.boye.httpclientandroidlib.ProtocolException;
import ch.boye.httpclientandroidlib.client.HttpClient;
import ch.boye.httpclientandroidlib.client.entity.GzipDecompressingEntity;
import ch.boye.httpclientandroidlib.client.entity.UrlEncodedFormEntity;
import ch.boye.httpclientandroidlib.client.methods.HttpGet;
import ch.boye.httpclientandroidlib.client.methods.HttpPost;
import ch.boye.httpclientandroidlib.client.methods.HttpRequestBase;
import ch.boye.httpclientandroidlib.client.params.ClientPNames;
import ch.boye.httpclientandroidlib.entity.mime.MultipartEntity;
import ch.boye.httpclientandroidlib.entity.mime.content.FileBody;
import ch.boye.httpclientandroidlib.entity.mime.content.StringBody;
import ch.boye.httpclientandroidlib.impl.client.DefaultHttpClient;
import ch.boye.httpclientandroidlib.impl.client.DefaultRedirectStrategy;
import ch.boye.httpclientandroidlib.params.BasicHttpParams;
import ch.boye.httpclientandroidlib.params.CoreConnectionPNames;
import ch.boye.httpclientandroidlib.params.CoreProtocolPNames;
import ch.boye.httpclientandroidlib.params.HttpParams;
import ch.boye.httpclientandroidlib.protocol.HttpContext;
import ch.boye.httpclientandroidlib.util.EntityUtils;

import org.apache.commons.lang3.CharEncoding;
import org.apache.commons.lang3.StringUtils;
import org.json.JSONException;
import org.json.JSONObject;

import android.net.Uri;

import java.io.File;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.net.URLEncoder;

public abstract class Network {

    private static final int NB_DOWNLOAD_RETRIES = 4;

    /** User agent id */
    private final static String PC_USER_AGENT = "Mozilla/5.0 (X11; Linux x86_64; rv:9.0.1) Gecko/20100101 Firefox/9.0.1";
    /** Native user agent, taken from a Android 2.2 Nexus **/
    private final static String NATIVE_USER_AGENT = "Mozilla/5.0 (Linux; U; Android 2.2; en-us; Nexus One Build/FRF91) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1";

    private static final String PATTERN_PASSWORD = "(?<=[\\?&])[Pp]ass(w(or)?d)?=[^&#$]+";

    private final static HttpParams clientParams = new BasicHttpParams();

    static {
        Network.clientParams.setParameter(CoreProtocolPNames.HTTP_CONTENT_CHARSET, "UTF-8");
        Network.clientParams.setParameter(CoreConnectionPNames.CONNECTION_TIMEOUT, 30000);
        Network.clientParams.setParameter(CoreConnectionPNames.SO_TIMEOUT, 30000);
        Network.clientParams.setParameter(ClientPNames.HANDLE_REDIRECTS,  true);
    }

    private static String hidePassword(final String message) {
        return message.replaceAll(Network.PATTERN_PASSWORD, "password=***");
    }

    private static HttpClient getHttpClient() {
        final DefaultHttpClient client = new DefaultHttpClient();
        client.setCookieStore(Cookies.cookieStore);
        client.setParams(clientParams);

        client.setRedirectStrategy(new DefaultRedirectStrategy() {
            @Override
            public boolean isRedirected(HttpRequest request, HttpResponse response, HttpContext context) {
                boolean isRedirect = false;
                try {
                    isRedirect = super.isRedirected(request, response, context);
                } catch (final ProtocolException e) {
                    Log.e("httpclient.isRedirected: unable to check for redirection", e);
                }
                if (!isRedirect) {
                    final int responseCode = response.getStatusLine().getStatusCode();
                    if (responseCode == 301 || responseCode == 302) {
                        return true;
                    }
                }
                return isRedirect;
            }
        });

        client.addRequestInterceptor(new HttpRequestInterceptor() {

            @Override
            public void process(
                    final HttpRequest request,
                    final HttpContext context) throws HttpException, IOException {
                if (!request.containsHeader("Accept-Encoding")) {
                    request.addHeader("Accept-Encoding", "gzip");
                }
            }
        });
        client.addResponseInterceptor(new HttpResponseInterceptor() {

            @Override
            public void process(
                    final HttpResponse response,
                    final HttpContext context) throws HttpException, IOException {
                final HttpEntity entity = response.getEntity();
                if (entity != null) {
                    final Header contentEncoding = entity.getContentEncoding();
                    if (contentEncoding != null) {
                        for (final HeaderElement codec : contentEncoding.getElements()) {
                            if (codec.getName().equalsIgnoreCase("gzip")) {
                                Log.d("Decompressing response");
                                response.setEntity(new GzipDecompressingEntity(response.getEntity()));
                                return;
                            }
                        }
                    }
                }
            }

        });

        return client;
    }

    /**
     * POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @return the HTTP response, or null in case of an encoding error params
     */
    public static HttpResponse postRequest(final String uri, final Parameters params) {
        return request("POST", uri, params, null, null);
    }

    /**
     * POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @params headers the headers to add to the request
     * @return the HTTP response, or null in case of an encoding error params
     */
    public static HttpResponse postRequest(final String uri, final Parameters params, final Parameters headers) {
        return request("POST", uri, params, headers, null);
    }

    /**
     * Multipart POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @param fileFieldName the name of the file field name
     * @param fileContentType the content-type of the file
     * @param file the file to include in the request
     * @return the HTTP response, or null in case of an encoding error param
     */
    public static HttpResponse postRequest(final String uri, final Parameters params,
                                           final String fileFieldName, final String fileContentType, final File file) {
        final MultipartEntity entity = new MultipartEntity();
        for (final NameValuePair param : params) {
            try {
                entity.addPart(param.getName(), new StringBody(param.getValue()));
            } catch (final UnsupportedEncodingException e) {
                Log.e("Network.postRequest: unsupported encoding for parameter " + param.getName(), e);
                return null;
            }
        }
        entity.addPart(fileFieldName, new FileBody(file, fileContentType));

        final HttpPost request = new HttpPost(uri);
        request.setEntity(entity);

        addHeaders(request, null, null);
        return doRepeatedRequests(request);
    }

    /**
     * Make an HTTP request
     *
     * @param method
     *            the HTTP method to use ("GET" or "POST")
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add to the URI
     * @param headers
     *            the headers to add to the request
     * @param cacheFile
     *            the cache file used to cache this query
     * @return the HTTP response, or null in case of an encoding error in a POST request arguments
     */
    private static HttpResponse request(final String method, final String uri, final Parameters params, final Parameters headers, final File cacheFile) {
        HttpRequestBase request;
        if (method.equals("GET")) {
            final String fullUri = params == null ? uri : Uri.parse(uri).buildUpon().encodedQuery(params.toString()).build().toString();
            request = new HttpGet(fullUri);
        } else {
            request = new HttpPost(uri);
            if (params != null) {
                try {
                    ((HttpPost) request).setEntity(new UrlEncodedFormEntity(params, "UTF-8"));
                } catch (final UnsupportedEncodingException e) {
                    Log.e("request", e);
                    return null;
                }
            }
        }

        addHeaders(request, headers, cacheFile);

        return doRepeatedRequests(request);
    }

    /**
     * Add headers to HTTP request.
     * @param request
     *            the request to add headers to
     * @param headers
     *            the headers to add (in addition to the standard headers), can be null
     * @param cacheFile
     *            if non-null, the file to take ETag and If-Modified-Since information from
     */
    private static void addHeaders(final HttpRequestBase request, final Parameters headers, final File cacheFile) {
        for (final NameValuePair header : Parameters.extend(Parameters.merge(headers, cacheHeaders(cacheFile)),
                "Accept-Charset", "utf-8,iso-8859-1;q=0.8,utf-16;q=0.8,*;q=0.7",
                "Accept-Language", "en-US,*;q=0.9",
                "X-Requested-With", "XMLHttpRequest")) {
            request.setHeader(header.getName(), header.getValue());
        }
        if (Settings.getUseNativeUa()) {
            request.getParams().setParameter(CoreProtocolPNames.USER_AGENT, Network.NATIVE_USER_AGENT);
        } else {
            request.getParams().setParameter(CoreProtocolPNames.USER_AGENT, Network.PC_USER_AGENT);
        }
    }

    /**
     * Retry a request for a few times.
     *
     * @param request
     *            the request to try
     * @return
     *            the response, or null if there has been a failure
     */
    private static HttpResponse doRepeatedRequests(final HttpRequestBase request) {
        final String reqLogStr = request.getMethod() + " " + Network.hidePassword(request.getURI().toString());
        Log.d(reqLogStr);

        final HttpClient client = Network.getHttpClient();
        for (int i = 0; i <= Network.NB_DOWNLOAD_RETRIES; i++) {
            final long before = System.currentTimeMillis();
            try {
                final HttpResponse response = client.execute(request);
                int status = response.getStatusLine().getStatusCode();
                if (status == 200) {
                    Log.d(status + Network.formatTimeSpan(before) + reqLogStr);
                } else {
                    Log.w(status + " [" + response.getStatusLine().getReasonPhrase() + "]" + Network.formatTimeSpan(before) + reqLogStr);
                }
                return response;
            } catch (IOException e) {
                final String timeSpan = Network.formatTimeSpan(before);
                final String tries = (i + 1) + "/" + (Network.NB_DOWNLOAD_RETRIES + 1);
                if (i == Network.NB_DOWNLOAD_RETRIES) {
                    Log.e("Failure " + tries + timeSpan + reqLogStr, e);
                } else {
                    Log.e("Failure " + tries + " (" + e.toString() + ")" + timeSpan + "- retrying " + reqLogStr);
                }
            }
        }

        return null;
    }

    private static Parameters cacheHeaders(final File cacheFile) {
        if (cacheFile == null || !cacheFile.exists()) {
            return null;
        }

        final String etag = LocalStorage.getSavedHeader(cacheFile, "etag");
        if (etag != null) {
            return new Parameters("If-None-Match", etag);
        }

        final String lastModified = LocalStorage.getSavedHeader(cacheFile, "last-modified");
        if (lastModified != null) {
            return new Parameters("If-Modified-Since", lastModified);
        }

        return null;
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @param cacheFile
     *            the name of the file storing the cached resource, or null not to use one
     * @return the HTTP response
     */
    public static HttpResponse getRequest(final String uri, final Parameters params, final File cacheFile) {
        return request("GET", uri, params, null, cacheFile);
    }


    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @return the HTTP response
     */
    public static HttpResponse getRequest(final String uri, final Parameters params) {
        return request("GET", uri, params, null, null);
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @param headers
     *            the headers to add to the GET request
     * @return the HTTP response
     */
    public static HttpResponse getRequest(final String uri, final Parameters params, final Parameters headers) {
        return request("GET", uri, params, headers, null);
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @return the HTTP response
     */
    public static HttpResponse getRequest(final String uri) {
        return request("GET", uri, null, null, null);
    }

    private static String formatTimeSpan(final long before) {
        // don't use String.format in a pure logging routine, it has very bad performance
        return " (" + (System.currentTimeMillis() - before) + " ms) ";
    }

    static public boolean isSuccess(final HttpResponse response) {
        return response != null && response.getStatusLine().getStatusCode() == 200;
    }

    public static JSONObject requestJSON(final String uri, final Parameters params) {
        final HttpResponse response = request("GET", uri, params, new Parameters("Accept", "application/json, text/javascript, */*; q=0.01"), null);
        if (isSuccess(response)) {
            try {
                return new JSONObject(Network.getResponseData(response));
            } catch (final JSONException e) {
                Log.e("Network.requestJSON", e);
            }
        }

        return null;
    }

    private static String getResponseDataNoError(final HttpResponse response, boolean replaceWhitespace) {
        try {
            String data = EntityUtils.toString(response.getEntity(), "UTF-8");
            return replaceWhitespace ? BaseUtils.replaceWhitespace(data) : data;
        } catch (Exception e) {
            Log.e("getResponseData", e);
            return null;
        }
    }

    public static String getResponseData(final HttpResponse response) {
        return Network.getResponseData(response, true);
    }

    public static String getResponseData(final HttpResponse response, boolean replaceWhitespace) {
        if (!isSuccess(response)) {
            return null;
        }
        return getResponseDataNoError(response, replaceWhitespace);
    }

    public static String rfc3986URLEncode(String text) {
        return StringUtils.replace(Network.encode(text).replace("+", "%20"), "%7E", "~");
    }

    public static String decode(final String text) {
        try {
            return URLDecoder.decode(text, CharEncoding.UTF_8);
        } catch (UnsupportedEncodingException e) {
            Log.e("Network.decode", e);
        }
        return null;
    }

    public static String encode(final String text) {
        try {
            return URLEncoder.encode(text, CharEncoding.UTF_8);
        } catch (UnsupportedEncodingException e) {
            Log.e("Network.encode", e);
        }
        return null;
    }

}
!@#$%
20190527_000653,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_a16200
package cgeo.geocaching.network;

import cgeo.geocaching.Settings;
import cgeo.geocaching.files.LocalStorage;
import cgeo.geocaching.utils.BaseUtils;
import cgeo.geocaching.utils.Log;

import ch.boye.httpclientandroidlib.Header;
import ch.boye.httpclientandroidlib.HeaderElement;
import ch.boye.httpclientandroidlib.HttpEntity;
import ch.boye.httpclientandroidlib.HttpException;
import ch.boye.httpclientandroidlib.HttpRequest;
import ch.boye.httpclientandroidlib.HttpRequestInterceptor;
import ch.boye.httpclientandroidlib.HttpResponse;
import ch.boye.httpclientandroidlib.HttpResponseInterceptor;
import ch.boye.httpclientandroidlib.NameValuePair;
import ch.boye.httpclientandroidlib.ProtocolException;
import ch.boye.httpclientandroidlib.client.HttpClient;
import ch.boye.httpclientandroidlib.client.entity.GzipDecompressingEntity;
import ch.boye.httpclientandroidlib.client.entity.UrlEncodedFormEntity;
import ch.boye.httpclientandroidlib.client.methods.HttpGet;
import ch.boye.httpclientandroidlib.client.methods.HttpPost;
import ch.boye.httpclientandroidlib.client.methods.HttpRequestBase;
import ch.boye.httpclientandroidlib.client.params.ClientPNames;
import ch.boye.httpclientandroidlib.entity.mime.MultipartEntity;
import ch.boye.httpclientandroidlib.entity.mime.content.FileBody;
import ch.boye.httpclientandroidlib.entity.mime.content.StringBody;
import ch.boye.httpclientandroidlib.impl.client.DefaultHttpClient;
import ch.boye.httpclientandroidlib.impl.client.DefaultRedirectStrategy;
import ch.boye.httpclientandroidlib.params.BasicHttpParams;
import ch.boye.httpclientandroidlib.params.CoreConnectionPNames;
import ch.boye.httpclientandroidlib.params.CoreProtocolPNames;
import ch.boye.httpclientandroidlib.params.HttpParams;
import ch.boye.httpclientandroidlib.protocol.HttpContext;
import ch.boye.httpclientandroidlib.util.EntityUtils;

import org.apache.commons.lang3.CharEncoding;
import org.apache.commons.lang3.StringUtils;
import org.json.JSONException;
import org.json.JSONObject;

import android.net.Uri;

import java.io.File;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.net.URLEncoder;

public abstract class Network {

    private static final int NB_DOWNLOAD_RETRIES = 4;

    /** User agent id */
    private final static String PC_USER_AGENT = "Mozilla/5.0 (X11; Linux x86_64; rv:9.0.1) Gecko/20100101 Firefox/9.0.1";
    /** Native user agent, taken from a Android 2.2 Nexus **/
    private final static String NATIVE_USER_AGENT = "Mozilla/5.0 (Linux; U; Android 2.2; en-us; Nexus One Build/FRF91) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1";

    private static final String PATTERN_PASSWORD = "(?<=[\\?&])[Pp]ass(w(or)?d)?=[^&#$]+";

    private final static HttpParams clientParams = new BasicHttpParams();

    static {
        Network.clientParams.setParameter(CoreProtocolPNames.HTTP_CONTENT_CHARSET, "UTF-8");
        Network.clientParams.setParameter(CoreConnectionPNames.CONNECTION_TIMEOUT, 30000);
        Network.clientParams.setParameter(CoreConnectionPNames.SO_TIMEOUT, 30000);
        Network.clientParams.setParameter(ClientPNames.HANDLE_REDIRECTS,  true);
    }

    private static String hidePassword(final String message) {
        return message.replaceAll(Network.PATTERN_PASSWORD, "password=***");
    }

    private static HttpClient getHttpClient() {
        final DefaultHttpClient client = new DefaultHttpClient();
        client.setCookieStore(Cookies.cookieStore);
        client.setParams(clientParams);

        client.setRedirectStrategy(new DefaultRedirectStrategy() {
            @Override
            public boolean isRedirected(HttpRequest request, HttpResponse response, HttpContext context) {
                boolean isRedirect = false;
                try {
                    isRedirect = super.isRedirected(request, response, context);
                } catch (final ProtocolException e) {
                    Log.e("httpclient.isRedirected: unable to check for redirection", e);
                }
                if (!isRedirect) {
                    final int responseCode = response.getStatusLine().getStatusCode();
                    if (responseCode == 301 || responseCode == 302) {
                        return true;
                    }
                }
                return isRedirect;
            }
        });

        client.addRequestInterceptor(new HttpRequestInterceptor() {

            @Override
            public void process(
                    final HttpRequest request,
                    final HttpContext context) throws HttpException, IOException {
                if (!request.containsHeader("Accept-Encoding")) {
                    request.addHeader("Accept-Encoding", "gzip");
                }
            }
        });
        client.addResponseInterceptor(new HttpResponseInterceptor() {

            @Override
            public void process(
                    final HttpResponse response,
                    final HttpContext context) throws HttpException, IOException {
                final HttpEntity entity = response.getEntity();
                if (entity != null) {
                    final Header contentEncoding = entity.getContentEncoding();
                    if (contentEncoding != null) {
                        for (final HeaderElement codec : contentEncoding.getElements()) {
                            if (codec.getName().equalsIgnoreCase("gzip")) {
                                Log.d("Decompressing response");
                                response.setEntity(new GzipDecompressingEntity(response.getEntity()));
                                return;
                            }
                        }
                    }
                }
            }

        });

        return client;
    }

    /**
     * POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @return the HTTP response, or null in case of an encoding error params
     */
    public static HttpResponse postRequest(final String uri, final Parameters params) {
        return request("POST", uri, params, null, null);
    }

    /**
     * POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @params headers the headers to add to the request
     * @return the HTTP response, or null in case of an encoding error params
     */
    public static HttpResponse postRequest(final String uri, final Parameters params, final Parameters headers) {
        return request("POST", uri, params, headers, null);
    }

    /**
     * Multipart POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @param fileFieldName the name of the file field name
     * @param fileContentType the content-type of the file
     * @param file the file to include in the request
     * @return the HTTP response, or null in case of an encoding error param
     */
    public static HttpResponse postRequest(final String uri, final Parameters params,
                                           final String fileFieldName, final String fileContentType, final File file) {
        final MultipartEntity entity = new MultipartEntity();
        for (final NameValuePair param : params) {
            try {
                entity.addPart(param.getName(), new StringBody(param.getValue()));
            } catch (final UnsupportedEncodingException e) {
                Log.e("Network.postRequest: unsupported encoding for parameter " + param.getName(), e);
                return null;
            }
        }
        entity.addPart(fileFieldName, new FileBody(file, fileContentType));

        final HttpPost request = new HttpPost(uri);
        request.setEntity(entity);

        addHeaders(request, null, null);
        return doRepeatedRequests(request);
    }

    /**
     * Make an HTTP request
     *
     * @param method
     *            the HTTP method to use ("GET" or "POST")
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add to the URI
     * @param headers
     *            the headers to add to the request
     * @param cacheFile
     *            the cache file used to cache this query
     * @return the HTTP response, or null in case of an encoding error in a POST request arguments
     */
    private static HttpResponse request(final String method, final String uri, final Parameters params, final Parameters headers, final File cacheFile) {
        HttpRequestBase request;
        if (method.equals("GET")) {
            final String fullUri = params == null ? uri : Uri.parse(uri).buildUpon().encodedQuery(params.toString()).build().toString();
            request = new HttpGet(fullUri);
        } else {
            request = new HttpPost(uri);
            if (params != null) {
                try {
                    ((HttpPost) request).setEntity(new UrlEncodedFormEntity(params, "UTF-8"));
                } catch (final UnsupportedEncodingException e) {
                    Log.e("request", e);
                    return null;
                }
            }
        }

        addHeaders(request, headers, cacheFile);

        return doRepeatedRequests(request);
    }

    /**
     * Add headers to HTTP request.
     * @param request
     *            the request to add headers to
     * @param headers
     *            the headers to add (in addition to the standard headers), can be null
     * @param cacheFile
     *            if non-null, the file to take ETag and If-Modified-Since information from
     */
    private static void addHeaders(final HttpRequestBase request, final Parameters headers, final File cacheFile) {
        for (final NameValuePair header : Parameters.extend(Parameters.merge(headers, cacheHeaders(cacheFile)),
                "Accept-Charset", "utf-8,iso-8859-1;q=0.8,utf-16;q=0.8,*;q=0.7",
                "Accept-Language", "en-US,*;q=0.9",
                "X-Requested-With", "XMLHttpRequest")) {
            request.setHeader(header.getName(), header.getValue());
        }
        if (Settings.getUseNativeUa()) {
            request.getParams().setParameter(CoreProtocolPNames.USER_AGENT, Network.NATIVE_USER_AGENT);
        } else {
            request.getParams().setParameter(CoreProtocolPNames.USER_AGENT, Network.PC_USER_AGENT);
        }
    }

    /**
     * Retry a request for a few times.
     *
     * @param request
     *            the request to try
     * @return
     *            the response, or null if there has been a failure
     */
    private static HttpResponse doRepeatedRequests(final HttpRequestBase request) {
        final String reqLogStr = request.getMethod() + " " + Network.hidePassword(request.getURI().toString());
        Log.d(reqLogStr);

        final HttpClient client = Network.getHttpClient();
        for (int i = 0; i <= Network.NB_DOWNLOAD_RETRIES; i++) {
            final long before = System.currentTimeMillis();
            try {
                final HttpResponse response = client.execute(request);
                int status = response.getStatusLine().getStatusCode();
                if (status == 200) {
                    Log.d(status + Network.formatTimeSpan(before) + reqLogStr);
                } else {
                    Log.w(status + " [" + response.getStatusLine().getReasonPhrase() + "]" + Network.formatTimeSpan(before) + reqLogStr);
                }
                return response;
            } catch (IOException e) {
                final String timeSpan = Network.formatTimeSpan(before);
                final String tries = (i + 1) + "/" + (Network.NB_DOWNLOAD_RETRIES + 1);
                if (i == Network.NB_DOWNLOAD_RETRIES) {
                    Log.e("Failure " + tries + timeSpan + reqLogStr, e);
                } else {
                    Log.e("Failure " + tries + " (" + e.toString() + ")" + timeSpan + "- retrying " + reqLogStr);
                }
            }
        }

        return null;
    }

    private static Parameters cacheHeaders(final File cacheFile) {
        if (cacheFile == null || !cacheFile.exists()) {
            return null;
        }

        final String etag = LocalStorage.getSavedHeader(cacheFile, "etag");
        if (etag != null) {
            return new Parameters("If-None-Match", etag);
        }

        final String lastModified = LocalStorage.getSavedHeader(cacheFile, "last-modified");
        if (lastModified != null) {
            return new Parameters("If-Modified-Since", lastModified);
        }

        return null;
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @param cacheFile
     *            the name of the file storing the cached resource, or null not to use one
     * @return the HTTP response
     */
    public static HttpResponse getRequest(final String uri, final Parameters params, final File cacheFile) {
        return request("GET", uri, params, null, cacheFile);
    }


    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @return the HTTP response
     */
    public static HttpResponse getRequest(final String uri, final Parameters params) {
        return request("GET", uri, params, null, null);
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @param headers
     *            the headers to add to the GET request
     * @return the HTTP response
     */
    public static HttpResponse getRequest(final String uri, final Parameters params, final Parameters headers) {
        return request("GET", uri, params, headers, null);
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @return the HTTP response
     */
    public static HttpResponse getRequest(final String uri) {
        return request("GET", uri, null, null, null);
    }

    private static String formatTimeSpan(final long before) {
        // don't use String.format in a pure logging routine, it has very bad performance
        return " (" + (System.currentTimeMillis() - before) + " ms) ";
    }

    static public boolean isSuccess(final HttpResponse response) {
        return response != null && response.getStatusLine().getStatusCode() == 200;
    }

    public static JSONObject requestJSON(final String uri, final Parameters params) {
        final HttpResponse response = request("GET", uri, params, new Parameters("Accept", "application/json, text/javascript, */*; q=0.01"), null);
        if (isSuccess(response)) {
            try {
                return new JSONObject(Network.getResponseData(response));
            } catch (final JSONException e) {
                Log.e("Network.requestJSON", e);
            }
        }

        return null;
    }

    private static String getResponseDataNoError(final HttpResponse response, boolean replaceWhitespace) {
        try {
            String data = EntityUtils.toString(response.getEntity(), "UTF-8");
            return replaceWhitespace ? BaseUtils.replaceWhitespace(data) : data;
        } catch (Exception e) {
            Log.e("getResponseData", e);
            return null;
        }
    }

    public static String getResponseData(final HttpResponse response) {
        return Network.getResponseData(response, true);
    }

    public static String getResponseData(final HttpResponse response, boolean replaceWhitespace) {
        if (!isSuccess(response)) {
            return null;
        }
        return getResponseDataNoError(response, replaceWhitespace);
    }

    public static String rfc3986URLEncode(String text) {
        return StringUtils.replace(Network.encode(text).replace("+", "%20"), "%7E", "~");
    }

    public static String decode(final String text) {
        try {
            return URLDecoder.decode(text, CharEncoding.UTF_8);
        } catch (UnsupportedEncodingException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        return null;
    }

    public static String encode(final String text) {
        try {
            return URLEncoder.encode(text, CharEncoding.UTF_8);
        } catch (UnsupportedEncodingException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        return null;
    }

}
!@#$%
20190527_000653,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_c16200
package cgeo.geocaching.network;

import cgeo.geocaching.Settings;
import cgeo.geocaching.files.LocalStorage;
import cgeo.geocaching.utils.BaseUtils;
import cgeo.geocaching.utils.Log;

import ch.boye.httpclientandroidlib.Header;
import ch.boye.httpclientandroidlib.HeaderElement;
import ch.boye.httpclientandroidlib.HttpEntity;
import ch.boye.httpclientandroidlib.HttpException;
import ch.boye.httpclientandroidlib.HttpRequest;
import ch.boye.httpclientandroidlib.HttpRequestInterceptor;
import ch.boye.httpclientandroidlib.HttpResponse;
import ch.boye.httpclientandroidlib.HttpResponseInterceptor;
import ch.boye.httpclientandroidlib.NameValuePair;
import ch.boye.httpclientandroidlib.ProtocolException;
import ch.boye.httpclientandroidlib.client.HttpClient;
import ch.boye.httpclientandroidlib.client.entity.GzipDecompressingEntity;
import ch.boye.httpclientandroidlib.client.entity.UrlEncodedFormEntity;
import ch.boye.httpclientandroidlib.client.methods.HttpGet;
import ch.boye.httpclientandroidlib.client.methods.HttpPost;
import ch.boye.httpclientandroidlib.client.methods.HttpRequestBase;
import ch.boye.httpclientandroidlib.client.params.ClientPNames;
import ch.boye.httpclientandroidlib.entity.StringEntity;
import ch.boye.httpclientandroidlib.entity.mime.MultipartEntity;
import ch.boye.httpclientandroidlib.entity.mime.content.FileBody;
import ch.boye.httpclientandroidlib.entity.mime.content.StringBody;
import ch.boye.httpclientandroidlib.impl.client.DefaultHttpClient;
import ch.boye.httpclientandroidlib.impl.client.DefaultRedirectStrategy;
import ch.boye.httpclientandroidlib.params.BasicHttpParams;
import ch.boye.httpclientandroidlib.params.CoreConnectionPNames;
import ch.boye.httpclientandroidlib.params.CoreProtocolPNames;
import ch.boye.httpclientandroidlib.params.HttpParams;
import ch.boye.httpclientandroidlib.protocol.HttpContext;
import ch.boye.httpclientandroidlib.util.EntityUtils;

import org.apache.commons.lang3.CharEncoding;
import org.apache.commons.lang3.StringUtils;
import org.json.JSONException;
import org.json.JSONObject;

import android.net.Uri;

import java.io.File;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.net.URLEncoder;

public abstract class Network {

    private static final int NB_DOWNLOAD_RETRIES = 4;

    /** User agent id */
    private final static String PC_USER_AGENT = "Mozilla/5.0 (X11; Linux x86_64; rv:9.0.1) Gecko/20100101 Firefox/9.0.1";
    /** Native user agent, taken from a Android 2.2 Nexus **/
    private final static String NATIVE_USER_AGENT = "Mozilla/5.0 (Linux; U; Android 2.2; en-us; Nexus One Build/FRF91) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1";

    private static final String PATTERN_PASSWORD = "(?<=[\\?&])[Pp]ass(w(or)?d)?=[^&#$]+";

    private final static HttpParams clientParams = new BasicHttpParams();

    static {
        Network.clientParams.setParameter(CoreProtocolPNames.HTTP_CONTENT_CHARSET, "UTF-8");
        Network.clientParams.setParameter(CoreConnectionPNames.CONNECTION_TIMEOUT, 30000);
        Network.clientParams.setParameter(CoreConnectionPNames.SO_TIMEOUT, 30000);
        Network.clientParams.setParameter(ClientPNames.HANDLE_REDIRECTS,  true);
    }

    private static String hidePassword(final String message) {
        return message.replaceAll(Network.PATTERN_PASSWORD, "password=***");
    }

    private static HttpClient getHttpClient() {
        final DefaultHttpClient client = new DefaultHttpClient();
        client.setCookieStore(Cookies.cookieStore);
        client.setParams(clientParams);

        client.setRedirectStrategy(new DefaultRedirectStrategy() {
            @Override
            public boolean isRedirected(HttpRequest request, HttpResponse response, HttpContext context) {
                boolean isRedirect = false;
                try {
                    isRedirect = super.isRedirected(request, response, context);
                } catch (final ProtocolException e) {
                    Log.e("httpclient.isRedirected: unable to check for redirection", e);
                }
                if (!isRedirect) {
                    final int responseCode = response.getStatusLine().getStatusCode();
                    if (responseCode == 301 || responseCode == 302) {
                        return true;
                    }
                }
                return isRedirect;
            }
        });

        client.addRequestInterceptor(new HttpRequestInterceptor() {

            @Override
            public void process(
                    final HttpRequest request,
                    final HttpContext context) throws HttpException, IOException {
                if (!request.containsHeader("Accept-Encoding")) {
                    request.addHeader("Accept-Encoding", "gzip");
                }
            }
        });
        client.addResponseInterceptor(new HttpResponseInterceptor() {

            @Override
            public void process(
                    final HttpResponse response,
                    final HttpContext context) throws HttpException, IOException {
                final HttpEntity entity = response.getEntity();
                if (entity != null) {
                    final Header contentEncoding = entity.getContentEncoding();
                    if (contentEncoding != null) {
                        for (final HeaderElement codec : contentEncoding.getElements()) {
                            if (codec.getName().equalsIgnoreCase("gzip")) {
                                Log.d("Decompressing response");
                                response.setEntity(new GzipDecompressingEntity(response.getEntity()));
                                return;
                            }
                        }
                    }
                }
            }

        });

        return client;
    }

    /**
     * POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @return the HTTP response, or null in case of an encoding error params
     */
    public static HttpResponse postRequest(final String uri, final Parameters params) {
        return request("POST", uri, params, null, null);
    }

    /**
     * POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @params headers the headers to add to the request
     * @return the HTTP response, or null in case of an encoding error params
     */
    public static HttpResponse postRequest(final String uri, final Parameters params, final Parameters headers) {
        return request("POST", uri, params, headers, null);
    }

    /**
     *  POST HTTP request with Json POST DATA
     *
     * @param uri the URI to request
     * @param json the json object to add to the POST request
     * @return the HTTP response, or null in case of an encoding error params
     */
    public static HttpResponse postJsonRequest(final String uri, final JSONObject json) {
        HttpPost request;
        request = new HttpPost(uri);
        request.addHeader("Content-Type", "application/json; charset=utf-8");
        if (json != null) {
            try {
                request.setEntity(new StringEntity(json.toString()));
            } catch (UnsupportedEncodingException e) {
                Log.e("postJsonRequest:JSON Entity: UnsupportedEncodingException");
                return null;
            }
        }
        return doRepeatedRequests(request);
    }

    /**
     * Multipart POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @param fileFieldName the name of the file field name
     * @param fileContentType the content-type of the file
     * @param file the file to include in the request
     * @return the HTTP response, or null in case of an encoding error param
     */
    public static HttpResponse postRequest(final String uri, final Parameters params,
                                           final String fileFieldName, final String fileContentType, final File file) {
        final MultipartEntity entity = new MultipartEntity();
        for (final NameValuePair param : params) {
            try {
                entity.addPart(param.getName(), new StringBody(param.getValue()));
            } catch (final UnsupportedEncodingException e) {
                Log.e("Network.postRequest: unsupported encoding for parameter " + param.getName(), e);
                return null;
            }
        }
        entity.addPart(fileFieldName, new FileBody(file, fileContentType));

        final HttpPost request = new HttpPost(uri);
        request.setEntity(entity);

        addHeaders(request, null, null);
        return doRepeatedRequests(request);
    }

    /**
     * Make an HTTP request
     *
     * @param method
     *            the HTTP method to use ("GET" or "POST")
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add to the URI
     * @param headers
     *            the headers to add to the request
     * @param cacheFile
     *            the cache file used to cache this query
     * @return the HTTP response, or null in case of an encoding error in a POST request arguments
     */
    private static HttpResponse request(final String method, final String uri, final Parameters params, final Parameters headers, final File cacheFile) {
        HttpRequestBase request;
        if (method.equals("GET")) {
            final String fullUri = params == null ? uri : Uri.parse(uri).buildUpon().encodedQuery(params.toString()).build().toString();
            request = new HttpGet(fullUri);
        } else {
            request = new HttpPost(uri);
            if (params != null) {
                try {
                    ((HttpPost) request).setEntity(new UrlEncodedFormEntity(params, "UTF-8"));
                } catch (final UnsupportedEncodingException e) {
                    Log.e("request", e);
                    return null;
                }
            }
        }

        addHeaders(request, headers, cacheFile);

        return doRepeatedRequests(request);
    }

    /**
     * Add headers to HTTP request.
     * @param request
     *            the request to add headers to
     * @param headers
     *            the headers to add (in addition to the standard headers), can be null
     * @param cacheFile
     *            if non-null, the file to take ETag and If-Modified-Since information from
     */
    private static void addHeaders(final HttpRequestBase request, final Parameters headers, final File cacheFile) {
        for (final NameValuePair header : Parameters.extend(Parameters.merge(headers, cacheHeaders(cacheFile)),
                "Accept-Charset", "utf-8,iso-8859-1;q=0.8,utf-16;q=0.8,*;q=0.7",
                "Accept-Language", "en-US,*;q=0.9",
                "X-Requested-With", "XMLHttpRequest")) {
            request.setHeader(header.getName(), header.getValue());
        }
        if (Settings.getUseNativeUa()) {
            request.getParams().setParameter(CoreProtocolPNames.USER_AGENT, Network.NATIVE_USER_AGENT);
        } else {
            request.getParams().setParameter(CoreProtocolPNames.USER_AGENT, Network.PC_USER_AGENT);
        }
    }

    /**
     * Retry a request for a few times.
     *
     * @param request
     *            the request to try
     * @return
     *            the response, or null if there has been a failure
     */
    private static HttpResponse doRepeatedRequests(final HttpRequestBase request) {
        final String reqLogStr = request.getMethod() + " " + Network.hidePassword(request.getURI().toString());
        Log.d(reqLogStr);

        final HttpClient client = Network.getHttpClient();
        for (int i = 0; i <= Network.NB_DOWNLOAD_RETRIES; i++) {
            final long before = System.currentTimeMillis();
            try {
                final HttpResponse response = client.execute(request);
                int status = response.getStatusLine().getStatusCode();
                if (status == 200) {
                    Log.d(status + Network.formatTimeSpan(before) + reqLogStr);
                } else {
                    Log.w(status + " [" + response.getStatusLine().getReasonPhrase() + "]" + Network.formatTimeSpan(before) + reqLogStr);
                }
                return response;
            } catch (IOException e) {
                final String timeSpan = Network.formatTimeSpan(before);
                final String tries = (i + 1) + "/" + (Network.NB_DOWNLOAD_RETRIES + 1);
                if (i == Network.NB_DOWNLOAD_RETRIES) {
                    Log.e("Failure " + tries + timeSpan + reqLogStr, e);
                } else {
                    Log.e("Failure " + tries + " (" + e.toString() + ")" + timeSpan + "- retrying " + reqLogStr);
                }
            }
        }

        return null;
    }

    private static Parameters cacheHeaders(final File cacheFile) {
        if (cacheFile == null || !cacheFile.exists()) {
            return null;
        }

        final String etag = LocalStorage.getSavedHeader(cacheFile, "etag");
        if (etag != null) {
            return new Parameters("If-None-Match", etag);
        }

        final String lastModified = LocalStorage.getSavedHeader(cacheFile, "last-modified");
        if (lastModified != null) {
            return new Parameters("If-Modified-Since", lastModified);
        }

        return null;
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @param cacheFile
     *            the name of the file storing the cached resource, or null not to use one
     * @return the HTTP response
     */
    public static HttpResponse getRequest(final String uri, final Parameters params, final File cacheFile) {
        return request("GET", uri, params, null, cacheFile);
    }


    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @return the HTTP response
     */
    public static HttpResponse getRequest(final String uri, final Parameters params) {
        return request("GET", uri, params, null, null);
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @param headers
     *            the headers to add to the GET request
     * @return the HTTP response
     */
    public static HttpResponse getRequest(final String uri, final Parameters params, final Parameters headers) {
        return request("GET", uri, params, headers, null);
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @return the HTTP response
     */
    public static HttpResponse getRequest(final String uri) {
        return request("GET", uri, null, null, null);
    }

    private static String formatTimeSpan(final long before) {
        // don't use String.format in a pure logging routine, it has very bad performance
        return " (" + (System.currentTimeMillis() - before) + " ms) ";
    }

    static public boolean isSuccess(final HttpResponse response) {
        return response != null && response.getStatusLine().getStatusCode() == 200;
    }

    public static JSONObject requestJSON(final String uri, final Parameters params) {
        final HttpResponse response = request("GET", uri, params, new Parameters("Accept", "application/json, text/javascript, */*; q=0.01"), null);
        if (isSuccess(response)) {
            try {
                return new JSONObject(Network.getResponseData(response));
            } catch (final JSONException e) {
                Log.e("Network.requestJSON", e);
            }
        }

        return null;
    }

    private static String getResponseDataNoError(final HttpResponse response, boolean replaceWhitespace) {
        try {
            String data = EntityUtils.toString(response.getEntity(), "UTF-8");
            return replaceWhitespace ? BaseUtils.replaceWhitespace(data) : data;
        } catch (Exception e) {
            Log.e("getResponseData", e);
            return null;
        }
    }

    public static String getResponseData(final HttpResponse response) {
        return Network.getResponseData(response, true);
    }

    public static String getResponseData(final HttpResponse response, boolean replaceWhitespace) {
        if (!isSuccess(response)) {
            return null;
        }
        return getResponseDataNoError(response, replaceWhitespace);
    }

    public static String rfc3986URLEncode(String text) {
        return StringUtils.replace(Network.encode(text).replace("+", "%20"), "%7E", "~");
    }

    public static String decode(final String text) {
        try {
            return URLDecoder.decode(text, CharEncoding.UTF_8);
        } catch (UnsupportedEncodingException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        return null;
    }

    public static String encode(final String text) {
        try {
            return URLEncoder.encode(text, CharEncoding.UTF_8);
        } catch (UnsupportedEncodingException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        return null;
    }

}
!@#$%
20190527_000818,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_b18288
package cgeo.geocaching;

import cgeo.geocaching.apps.cache.navi.NavigationAppFactory.NavigationAppsEnum;
import cgeo.geocaching.connector.gc.GCConstants;
import cgeo.geocaching.connector.gc.Login;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.LiveMapStrategy.Strategy;
import cgeo.geocaching.enumerations.LogType;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.maps.MapProviderFactory;
import cgeo.geocaching.maps.google.GoogleMapProvider;
import cgeo.geocaching.maps.interfaces.GeoPointImpl;
import cgeo.geocaching.maps.interfaces.MapProvider;
import cgeo.geocaching.maps.interfaces.MapSource;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider.OfflineMapSource;
import cgeo.geocaching.utils.CryptUtils;
import cgeo.geocaching.utils.FileUtils;
import cgeo.geocaching.utils.FileUtils.FileSelector;
import cgeo.geocaching.utils.Log;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.os.Environment;
import android.preference.PreferenceManager;

import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

/**
 * General c:geo preferences/settings set by the user
 */
public final class Settings {

    private static final String KEY_TEMP_TOKEN_SECRET = "temp-token-secret";
    private static final String KEY_TEMP_TOKEN_PUBLIC = "temp-token-public";
    private static final String KEY_HELP_SHOWN = "helper";
    private static final String KEY_ANYLONGITUDE = "anylongitude";
    private static final String KEY_ANYLATITUDE = "anylatitude";
    private static final String KEY_USE_OFFLINEMAPS = "offlinemaps";
    private static final String KEY_USE_OFFLINEWPMAPS = "offlinewpmaps";
    private static final String KEY_WEB_DEVICE_CODE = "webDeviceCode";
    private static final String KEY_WEBDEVICE_NAME = "webDeviceName";
    private static final String KEY_MAP_LIVE = "maplive";
    private static final String KEY_MAP_SOURCE = "mapsource";
    private static final String KEY_USE_TWITTER = "twitter";
    private static final String KEY_SHOW_ADDRESS = "showaddress";
    private static final String KEY_SHOW_CAPTCHA = "showcaptcha";
    private static final String KEY_MAP_TRAIL = "maptrail";
    private static final String KEY_LAST_MAP_ZOOM = "mapzoom";
    private static final String KEY_LAST_MAP_LAT = "maplat";
    private static final String KEY_LAST_MAP_LON = "maplon";
    private static final String KEY_LIVE_LIST = "livelist";
    private static final String KEY_METRIC_UNITS = "units";
    private static final String KEY_SKIN = "skin";
    private static final String KEY_LAST_USED_LIST = "lastlist";
    private static final String KEY_CACHE_TYPE = "cachetype";
    private static final String KEY_TWITTER_TOKEN_SECRET = "tokensecret";
    private static final String KEY_TWITTER_TOKEN_PUBLIC = "tokenpublic";
    private static final String KEY_VERSION = "version";
    private static final String KEY_LOAD_DESCRIPTION = "autoloaddesc";
    private static final String KEY_RATING_WANTED = "ratingwanted";
    private static final String KEY_ELEVATION_WANTED = "elevationwanted";
    private static final String KEY_FRIENDLOGS_WANTED = "friendlogswanted";
    private static final String KEY_USE_ENGLISH = "useenglish";
    private static final String KEY_USE_COMPASS = "usecompass";
    private static final String KEY_AUTO_VISIT_TRACKABLES = "trackautovisit";
    private static final String KEY_AUTO_INSERT_SIGNATURE = "sigautoinsert";
    private static final String KEY_ALTITUDE_CORRECTION = "altcorrection";
    private static final String KEY_STORE_LOG_IMAGES = "logimages";
    private static final String KEY_EXCLUDE_DISABLED = "excludedisabled";
    private static final String KEY_EXCLUDE_OWN = "excludemine";
    private static final String KEY_MAPFILE = "mfmapfile";
    private static final String KEY_SIGNATURE = "signature";
    private static final String KEY_GCVOTE_PASSWORD = "pass-vote";
    private static final String KEY_PASSWORD = "password";
    private static final String KEY_USERNAME = "username";
    private static final String KEY_MEMBER_STATUS = "memberstatus";
    private static final String KEY_COORD_INPUT_FORMAT = "coordinputformat";
    private static final String KEY_LOG_OFFLINE = "log_offline";
    private static final String KEY_LOAD_DIRECTION_IMG = "loaddirectionimg";
    private static final String KEY_GC_CUSTOM_DATE = "gccustomdate";
    private static final String KEY_SHOW_WAYPOINTS_THRESHOLD = "gcshowwaypointsthreshold";
    private static final String KEY_COOKIE_STORE = "cookiestore";
    private static final String KEY_OPEN_LAST_DETAILS_PAGE = "opendetailslastpage";
    private static final String KEY_LAST_DETAILS_PAGE = "lastdetailspage";
    private static final String KEY_DEFAULT_NAVIGATION_TOOL = "defaultNavigationTool";
    private static final String KEY_DEFAULT_NAVIGATION_TOOL_2 = "defaultNavigationTool2";
    private static final String KEY_LIVE_MAP_STRATEGY = "livemapstrategy";
    private static final String KEY_DEBUG = "debug";
    private static final String KEY_HIDE_LIVE_MAP_HINT = "hidelivemaphint";
    private static final String KEY_LIVE_MAP_HINT_SHOW_COUNT = "livemaphintshowcount";
    private static final String KEY_SETTINGS_VERSION = "settingsversion";
    private static final String KEY_DB_ON_SDCARD = "dbonsdcard";
    private static final String KEY_LAST_TRACKABLE_ACTION = "trackableaction";
    private static final String KEY_SHARE_AFTER_EXPORT = "shareafterexport";
    private static final String KEY_GPX_EXPORT_DIR = "gpxExportDir";
    private static final String KEY_RENDER_THEME_BASE_FOLDER = "renderthemepath";
    private static final String KEY_RENDER_THEME_FILE_PATH = "renderthemefile";
    private static final String KEY_GPX_IMPORT_DIR = "gpxImportDir";
    private static final String KEY_PLAIN_LOGS = "plainLogs";
    private static final String KEY_NATIVE_UA = "nativeUa";
    private static final String KEY_MAP_DIRECTORY = "mapDirectory";

    private final static int unitsMetric = 1;

    // twitter api keys
    private final static String keyConsumerPublic = CryptUtils.rot13("ESnsCvAv3kEupF1GCR3jGj");
    private final static String keyConsumerSecret = CryptUtils.rot13("7vQWceACV9umEjJucmlpFe9FCMZSeqIqfkQ2BnhV9x");

    private interface PrefRunnable {
        void edit(final Editor edit);
    }

    public enum coordInputFormatEnum {
        Plain,
        Deg,
        Min,
        Sec;

        static coordInputFormatEnum fromInt(int id) {
            final coordInputFormatEnum[] values = coordInputFormatEnum.values();
            if (id < 0 || id >= values.length) {
                return Min;
            }
            return values[id];
        }
    }

    private static String username = null;
    private static String password = null;

    private static final SharedPreferences sharedPrefs = PreferenceManager.getDefaultSharedPreferences(cgeoapplication.getInstance().getBaseContext());
    static {
        migrateSettings();
        Log.setDebugUnsaved(sharedPrefs.getBoolean(KEY_DEBUG, false));
    }

    // maps
    private static MapProvider mapProvider = null;

    private Settings() {
        // this class is not to be instantiated;
    }

    private static void migrateSettings() {
        // migrate from non standard file location and integer based boolean types
        if (sharedPrefs.getInt(KEY_SETTINGS_VERSION, 0) < 1) {
            final String oldPreferencesName = "cgeo.pref";
            final SharedPreferences old = cgeoapplication.getInstance().getSharedPreferences(oldPreferencesName, Context.MODE_PRIVATE);
            final Editor e = sharedPrefs.edit();

            e.putString(KEY_TEMP_TOKEN_SECRET, old.getString(KEY_TEMP_TOKEN_SECRET, null));
            e.putString(KEY_TEMP_TOKEN_PUBLIC, old.getString(KEY_TEMP_TOKEN_PUBLIC, null));
            e.putBoolean(KEY_HELP_SHOWN, old.getInt(KEY_HELP_SHOWN, 0) != 0);
            e.putFloat(KEY_ANYLONGITUDE, old.getFloat(KEY_ANYLONGITUDE, 0));
            e.putFloat(KEY_ANYLATITUDE, old.getFloat(KEY_ANYLATITUDE, 0));
            e.putBoolean(KEY_USE_OFFLINEMAPS, 0 != old.getInt(KEY_USE_OFFLINEMAPS, 1));
            e.putBoolean(KEY_USE_OFFLINEWPMAPS, 0 != old.getInt(KEY_USE_OFFLINEWPMAPS, 0));
            e.putString(KEY_WEB_DEVICE_CODE, old.getString(KEY_WEB_DEVICE_CODE, null));
            e.putString(KEY_WEBDEVICE_NAME, old.getString(KEY_WEBDEVICE_NAME, null));
            e.putBoolean(KEY_MAP_LIVE, old.getInt(KEY_MAP_LIVE, 1) != 0);
            e.putInt(KEY_MAP_SOURCE, old.getInt(KEY_MAP_SOURCE, 0));
            e.putBoolean(KEY_USE_TWITTER, 0 != old.getInt(KEY_USE_TWITTER, 0));
            e.putBoolean(KEY_SHOW_ADDRESS, 0 != old.getInt(KEY_SHOW_ADDRESS, 1));
            e.putBoolean(KEY_SHOW_CAPTCHA, old.getBoolean(KEY_SHOW_CAPTCHA, false));
            e.putBoolean(KEY_MAP_TRAIL, old.getInt(KEY_MAP_TRAIL, 1) != 0);
            e.putInt(KEY_LAST_MAP_ZOOM, old.getInt(KEY_LAST_MAP_ZOOM, 14));
            e.putBoolean(KEY_LIVE_LIST, 0 != old.getInt(KEY_LIVE_LIST, 1));
            e.putBoolean(KEY_METRIC_UNITS, old.getInt(KEY_METRIC_UNITS, unitsMetric) == unitsMetric);
            e.putBoolean(KEY_SKIN, old.getInt(KEY_SKIN, 0) != 0);
            e.putInt(KEY_LAST_USED_LIST, old.getInt(KEY_LAST_USED_LIST, StoredList.STANDARD_LIST_ID));
            e.putString(KEY_CACHE_TYPE, old.getString(KEY_CACHE_TYPE, CacheType.ALL.id));
            e.putString(KEY_TWITTER_TOKEN_SECRET, old.getString(KEY_TWITTER_TOKEN_SECRET, null));
            e.putString(KEY_TWITTER_TOKEN_PUBLIC, old.getString(KEY_TWITTER_TOKEN_PUBLIC, null));
            e.putInt(KEY_VERSION, old.getInt(KEY_VERSION, 0));
            e.putBoolean(KEY_LOAD_DESCRIPTION, 0 != old.getInt(KEY_LOAD_DESCRIPTION, 0));
            e.putBoolean(KEY_RATING_WANTED, old.getBoolean(KEY_RATING_WANTED, true));
            e.putBoolean(KEY_ELEVATION_WANTED, old.getBoolean(KEY_ELEVATION_WANTED, true));
            e.putBoolean(KEY_FRIENDLOGS_WANTED, old.getBoolean(KEY_FRIENDLOGS_WANTED, true));
            e.putBoolean(KEY_USE_ENGLISH, old.getBoolean(KEY_USE_ENGLISH, false));
            e.putBoolean(KEY_USE_COMPASS, 0 != old.getInt(KEY_USE_COMPASS, 1));
            e.putBoolean(KEY_AUTO_VISIT_TRACKABLES, old.getBoolean(KEY_AUTO_VISIT_TRACKABLES, false));
            e.putBoolean(KEY_AUTO_INSERT_SIGNATURE, old.getBoolean(KEY_AUTO_INSERT_SIGNATURE, false));
            e.putInt(KEY_ALTITUDE_CORRECTION, old.getInt(KEY_ALTITUDE_CORRECTION, 0));
            e.putBoolean(KEY_STORE_LOG_IMAGES, old.getBoolean(KEY_STORE_LOG_IMAGES, false));
            e.putBoolean(KEY_EXCLUDE_DISABLED, 0 != old.getInt(KEY_EXCLUDE_DISABLED, 0));
            e.putBoolean(KEY_EXCLUDE_OWN, 0 != old.getInt(KEY_EXCLUDE_OWN, 0));
            e.putString(KEY_MAPFILE, old.getString(KEY_MAPFILE, null));
            e.putString(KEY_SIGNATURE, old.getString(KEY_SIGNATURE, null));
            e.putString(KEY_GCVOTE_PASSWORD, old.getString(KEY_GCVOTE_PASSWORD, null));
            e.putString(KEY_PASSWORD, old.getString(KEY_PASSWORD, null));
            e.putString(KEY_USERNAME, old.getString(KEY_USERNAME, null));
            e.putString(KEY_MEMBER_STATUS, old.getString(KEY_MEMBER_STATUS, ""));
            e.putInt(KEY_COORD_INPUT_FORMAT, old.getInt(KEY_COORD_INPUT_FORMAT, 0));
            e.putBoolean(KEY_LOG_OFFLINE, old.getBoolean(KEY_LOG_OFFLINE, false));
            e.putBoolean(KEY_LOAD_DIRECTION_IMG, old.getBoolean(KEY_LOAD_DIRECTION_IMG, true));
            e.putString(KEY_GC_CUSTOM_DATE, old.getString(KEY_GC_CUSTOM_DATE, null));
            e.putInt(KEY_SHOW_WAYPOINTS_THRESHOLD, old.getInt(KEY_SHOW_WAYPOINTS_THRESHOLD, 0));
            e.putString(KEY_COOKIE_STORE, old.getString(KEY_COOKIE_STORE, null));
            e.putBoolean(KEY_OPEN_LAST_DETAILS_PAGE, old.getBoolean(KEY_OPEN_LAST_DETAILS_PAGE, false));
            e.putInt(KEY_LAST_DETAILS_PAGE, old.getInt(KEY_LAST_DETAILS_PAGE, 1));
            e.putInt(KEY_DEFAULT_NAVIGATION_TOOL, old.getInt(KEY_DEFAULT_NAVIGATION_TOOL, NavigationAppsEnum.COMPASS.id));
            e.putInt(KEY_DEFAULT_NAVIGATION_TOOL_2, old.getInt(KEY_DEFAULT_NAVIGATION_TOOL_2, NavigationAppsEnum.INTERNAL_MAP.id));
            e.putInt(KEY_LIVE_MAP_STRATEGY, old.getInt(KEY_LIVE_MAP_STRATEGY, Strategy.AUTO.id));
            e.putBoolean(KEY_DEBUG, old.getBoolean(KEY_DEBUG, false));
            e.putBoolean(KEY_HIDE_LIVE_MAP_HINT, old.getInt(KEY_HIDE_LIVE_MAP_HINT, 0) != 0);
            e.putInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, old.getInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, 0));

            e.putInt(KEY_SETTINGS_VERSION, 1); // mark migrated
            e.commit();
        }
    }

    public static void setLanguage(boolean useEnglish) {
        final Configuration config = new Configuration();
        config.locale = useEnglish ? new Locale("en") : Locale.getDefault();
        final Resources resources = cgeoapplication.getInstance().getResources();
        resources.updateConfiguration(config, resources.getDisplayMetrics());
    }

    public static boolean isLogin() {
        final String preUsername = sharedPrefs.getString(KEY_USERNAME, null);
        final String prePassword = sharedPrefs.getString(KEY_PASSWORD, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    /**
     * Get login and password information.
     *
     * @return a pair (login, password) or null if no valid information is stored
     */
    public static ImmutablePair<String, String> getLogin() {
        if (username == null || password == null) {
            final String preUsername = sharedPrefs.getString(KEY_USERNAME, null);
            final String prePassword = sharedPrefs.getString(KEY_PASSWORD, null);

            if (preUsername == null || prePassword == null) {
                return null;
            }

            username = preUsername;
            password = prePassword;
        }
        return new ImmutablePair<String, String>(username, password);
    }

    public static String getUsername() {
        return username != null ? username : sharedPrefs.getString(KEY_USERNAME, null);
    }

    public static boolean setLogin(final String username, final String password) {
        Settings.username = username;
        Settings.password = password;
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
                    // erase username and password
                    edit.remove(KEY_USERNAME);
                    edit.remove(KEY_PASSWORD);
                } else {
                    // save username and password
                    edit.putString(KEY_USERNAME, username);
                    edit.putString(KEY_PASSWORD, password);
                }
            }
        });
    }

    public static boolean isPremiumMember() {
        // Basic Member, Premium Member, ???
        String memberStatus = Settings.getMemberStatus();
        if (memberStatus == null) {
            return false;
        }
        return GCConstants.MEMBER_STATUS_PM.equalsIgnoreCase(memberStatus);
    }

    public static String getMemberStatus() {
        return sharedPrefs.getString(KEY_MEMBER_STATUS, "");
    }

    public static boolean setMemberStatus(final String memberStatus) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(memberStatus)) {
                    edit.remove(KEY_MEMBER_STATUS);
                } else {
                    edit.putString(KEY_MEMBER_STATUS, memberStatus);
                }
            }
        });
    }

    public static boolean isGCvoteLogin() {
        final String preUsername = sharedPrefs.getString(KEY_USERNAME, null);
        final String prePassword = sharedPrefs.getString(KEY_GCVOTE_PASSWORD, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    public static boolean setGCvoteLogin(final String password) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(password)) {
                    // erase password
                    edit.remove(KEY_GCVOTE_PASSWORD);
                } else {
                    // save password
                    edit.putString(KEY_GCVOTE_PASSWORD, password);
                }
            }
        });
    }

    public static ImmutablePair<String, String> getGCvoteLogin() {
        final String username = sharedPrefs.getString(KEY_USERNAME, null);
        final String password = sharedPrefs.getString(KEY_GCVOTE_PASSWORD, null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return null;
        }

        return new ImmutablePair<String, String>(username, password);
    }

    public static boolean setSignature(final String signature) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(signature)) {
                    // erase signature
                    edit.remove(KEY_SIGNATURE);
                } else {
                    // save signature
                    edit.putString(KEY_SIGNATURE, signature);
                }
            }
        });
    }

    public static String getSignature() {
        return sharedPrefs.getString(KEY_SIGNATURE, null);
    }

    public static boolean setCookieStore(final String cookies) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(final Editor edit) {
                if (StringUtils.isBlank(cookies)) {
                    // erase cookies
                    edit.remove(KEY_COOKIE_STORE);
                } else {
                    // save cookies
                    edit.putString(KEY_COOKIE_STORE, cookies);
                }
            }
        });
    }

    public static String getCookieStore() {
        return sharedPrefs.getString(KEY_COOKIE_STORE, null);
    }

    /**
     * @param cacheType
     *            The cache type used for future filtering
     */
    public static void setCacheType(final CacheType cacheType) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                if (cacheType == null) {
                    edit.remove(KEY_CACHE_TYPE);
                } else {
                    edit.putString(KEY_CACHE_TYPE, cacheType.id);
                }
            }
        });
    }

    public static void setLiveMap(final boolean live) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_MAP_LIVE, live);
            }
        });
    }

    public static int getLastList() {
        return sharedPrefs.getInt(KEY_LAST_USED_LIST, StoredList.STANDARD_LIST_ID);
    }

    public static void saveLastList(final int listId) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_USED_LIST, listId);
            }
        });
    }

    public static void setWebNameCode(final String name, final String code) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {

                edit.putString(KEY_WEBDEVICE_NAME, name);
                edit.putString(KEY_WEB_DEVICE_CODE, code);
            }
        });
    }

    public static MapProvider getMapProvider() {
        if (mapProvider == null) {
            mapProvider = getMapSource().getMapProvider();
        }
        return mapProvider;
    }

    public static String getMapFile() {
        return sharedPrefs.getString(KEY_MAPFILE, null);
    }

    public static boolean setMapFile(final String mapFile) {
        boolean result = editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_MAPFILE, mapFile);
            }
        });
        if (mapFile != null) {
            setMapFileDirectory(new File(mapFile).getParent());
        }
        return result;
    }

    public static String getMapFileDirectory() {
        final String mapDir = sharedPrefs.getString(KEY_MAP_DIRECTORY, null);
        if (mapDir != null) {
            return mapDir;
        }
        final String mapFile = getMapFile();
        if (mapFile != null) {
            return new File(mapFile).getParent();
        }
        return null;
    }

    public static boolean setMapFileDirectory(final String mapFileDirectory) {
        return editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_MAP_DIRECTORY, mapFileDirectory);
                MapsforgeMapProvider.getInstance().updateOfflineMaps();
            }
        });
    }

    public static boolean isValidMapFile() {
        return isValidMapFile(getMapFile());
    }

    public static boolean isValidMapFile(final String mapFileIn) {
        return MapsforgeMapProvider.isValidMapFile(mapFileIn);
    }

    public static coordInputFormatEnum getCoordInputFormat() {
        return coordInputFormatEnum.fromInt(sharedPrefs.getInt(KEY_COORD_INPUT_FORMAT, 0));
    }

    public static void setCoordInputFormat(final coordInputFormatEnum format) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_COORD_INPUT_FORMAT, format.ordinal());
            }
        });
    }

    static void setLogOffline(final boolean offline) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LOG_OFFLINE, offline);
            }
        });
    }

    public static boolean getLogOffline() {
        return sharedPrefs.getBoolean(KEY_LOG_OFFLINE, false);
    }

    static void setLoadDirImg(final boolean value) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LOAD_DIRECTION_IMG, value);
            }
        });
    }

    public static boolean getLoadDirImg() {
        return !isPremiumMember() && sharedPrefs.getBoolean(KEY_LOAD_DIRECTION_IMG, true);
    }

    public static void setGcCustomDate(final String format) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_GC_CUSTOM_DATE, format);
            }
        });
    }

    /**
     * @return User selected date format on GC.com
     * @see Login#gcCustomDateFormats
     */
    public static String getGcCustomDate() {
        return sharedPrefs.getString(KEY_GC_CUSTOM_DATE, null);
    }

    public static boolean isExcludeMyCaches() {
        return sharedPrefs.getBoolean(KEY_EXCLUDE_OWN, false);
    }

    /**
     * edit some settings without knowing how to get the settings editor or how to commit
     *
     * @param runnable
     * @return
     */
    private static boolean editSharedSettings(final PrefRunnable runnable) {
        final SharedPreferences.Editor prefsEdit = sharedPrefs.edit();
        runnable.edit(prefsEdit);
        return prefsEdit.commit();
    }

    public static void setExcludeMine(final boolean exclude) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_EXCLUDE_OWN, exclude);
            }
        });
    }

    public static void setUseEnglish(final boolean english) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_ENGLISH, english);
                setLanguage(english);
            }
        });
    }

    public static boolean isUseEnglish() {
        return sharedPrefs.getBoolean(KEY_USE_ENGLISH, false);
    }

    public static boolean isShowAddress() {
        return sharedPrefs.getBoolean(KEY_SHOW_ADDRESS, true);
    }

    public static void setShowAddress(final boolean showAddress) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SHOW_ADDRESS, showAddress);
            }
        });
    }

    public static boolean isShowCaptcha() {
        return !isPremiumMember() && sharedPrefs.getBoolean(KEY_SHOW_CAPTCHA, false);
    }

    public static void setShowCaptcha(final boolean showCaptcha) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SHOW_CAPTCHA, showCaptcha);
            }
        });
    }

    public static boolean isExcludeDisabledCaches() {
        return sharedPrefs.getBoolean(KEY_EXCLUDE_DISABLED, false);
    }

    public static void setExcludeDisabledCaches(final boolean exclude) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_EXCLUDE_DISABLED, exclude);
            }
        });
    }

    public static boolean isStoreOfflineMaps() {
        return sharedPrefs.getBoolean(KEY_USE_OFFLINEMAPS, true);
    }

    public static void setStoreOfflineMaps(final boolean offlineMaps) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_OFFLINEMAPS, offlineMaps);
            }
        });
    }

    public static boolean isStoreOfflineWpMaps() {
        return sharedPrefs.getBoolean(KEY_USE_OFFLINEWPMAPS, false);
    }

    public static void setStoreOfflineWpMaps(final boolean offlineMaps) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_OFFLINEWPMAPS, offlineMaps);
            }
        });
    }

    public static boolean isStoreLogImages() {
        return sharedPrefs.getBoolean(KEY_STORE_LOG_IMAGES, false);
    }

    public static void setStoreLogImages(final boolean storeLogImages) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_STORE_LOG_IMAGES, storeLogImages);
            }
        });
    }

    public static boolean isAutoLoadDescription() {
        return sharedPrefs.getBoolean(KEY_LOAD_DESCRIPTION, false);
    }

    public static void setAutoLoadDesc(final boolean autoLoad) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LOAD_DESCRIPTION, autoLoad);
            }
        });
    }

    public static boolean isRatingWanted() {
        return sharedPrefs.getBoolean(KEY_RATING_WANTED, true);
    }

    public static void setRatingWanted(final boolean ratingWanted) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_RATING_WANTED, ratingWanted);
            }
        });
    }

    public static boolean isElevationWanted() {
        return sharedPrefs.getBoolean(KEY_ELEVATION_WANTED, true);
    }

    public static void setElevationWanted(final boolean elevationWanted) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_ELEVATION_WANTED, elevationWanted);
            }
        });
    }

    public static boolean isFriendLogsWanted() {
        if (!isLogin()) {
            // don't show a friends log if the user is anonymous
            return false;
        }
        return sharedPrefs.getBoolean(KEY_FRIENDLOGS_WANTED, true);
    }

    public static void setFriendLogsWanted(final boolean friendLogsWanted) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_FRIENDLOGS_WANTED, friendLogsWanted);
            }
        });
    }

    public static boolean isLiveList() {
        return sharedPrefs.getBoolean(KEY_LIVE_LIST, true);
    }

    public static void setLiveList(final boolean liveList) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LIVE_LIST, liveList);
            }
        });
    }

    public static boolean isTrackableAutoVisit() {
        return sharedPrefs.getBoolean(KEY_AUTO_VISIT_TRACKABLES, false);
    }

    public static void setTrackableAutoVisit(final boolean autoVisit) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_AUTO_VISIT_TRACKABLES, autoVisit);
            }
        });
    }

    public static boolean isAutoInsertSignature() {
        return sharedPrefs.getBoolean(KEY_AUTO_INSERT_SIGNATURE, false);
    }

    public static void setAutoInsertSignature(final boolean autoInsert) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_AUTO_INSERT_SIGNATURE, autoInsert);
            }
        });
    }

    public static boolean isUseMetricUnits() {
        return sharedPrefs.getBoolean(KEY_METRIC_UNITS, true);
    }

    public static void setUseMetricUnits(final boolean metric) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_METRIC_UNITS, metric);
            }
        });
    }

    public static boolean isLiveMap() {
        return sharedPrefs.getBoolean(KEY_MAP_LIVE, true);
    }

    public static boolean isMapTrail() {
        return sharedPrefs.getBoolean(KEY_MAP_TRAIL, true);
    }

    public static void setMapTrail(final boolean showTrail) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_MAP_TRAIL, showTrail);
            }
        });
    }

    public static int getMapZoom() {
        return sharedPrefs.getInt(KEY_LAST_MAP_ZOOM, 14);
    }

    public static void setMapZoom(final int mapZoomLevel) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_MAP_ZOOM, mapZoomLevel);
            }
        });
    }

    public static GeoPointImpl getMapCenter() {
        return getMapProvider().getMapItemFactory()
                .getGeoPointBase(new Geopoint(sharedPrefs.getInt(KEY_LAST_MAP_LAT, 0) / 1e6,
                        sharedPrefs.getInt(KEY_LAST_MAP_LON, 0) / 1e6));
    }

    public static void setMapCenter(final GeoPointImpl mapViewCenter) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_MAP_LAT, mapViewCenter.getLatitudeE6());
                edit.putInt(KEY_LAST_MAP_LON, mapViewCenter.getLongitudeE6());
            }
        });
    }

    public static MapSource getMapSource() {
        final int id = getConvertedMapId();
        final MapSource map = MapProviderFactory.getMapSource(id);
        if (map != null) {
            // don't use offline maps if the map file is not valid
            if ((!(map instanceof OfflineMapSource)) || (isValidMapFile())) {
                return map;
            }
        }
        // fallback to first available map
        return MapProviderFactory.getDefaultSource();
    }

    private final static int GOOGLEMAP_BASEID = 30;
    private final static int MAP = 1;
    private final static int SATELLITE = 2;

    private final static int MFMAP_BASEID = 40;
    private final static int MAPNIK = 1;
    private final static int CYCLEMAP = 3;
    private final static int OFFLINE = 4;

    /**
     * convert old preference ids for maps (based on constant values) into new hash based ids
     *
     * @return
     */
    private static int getConvertedMapId() {
        final int id = sharedPrefs.getInt(KEY_MAP_SOURCE, 0);
        switch (id) {
            case GOOGLEMAP_BASEID + MAP:
                return GoogleMapProvider.GOOGLE_MAP_ID.hashCode();
            case GOOGLEMAP_BASEID + SATELLITE:
                return GoogleMapProvider.GOOGLE_SATELLITE_ID.hashCode();
            case MFMAP_BASEID + MAPNIK:
                return MapsforgeMapProvider.MAPSFORGE_MAPNIK_ID.hashCode();
            case MFMAP_BASEID + CYCLEMAP:
                return MapsforgeMapProvider.MAPSFORGE_CYCLEMAP_ID.hashCode();
            case MFMAP_BASEID + OFFLINE: {
                final String mapFile = Settings.getMapFile();
                if (StringUtils.isNotEmpty(mapFile)) {
                    return mapFile.hashCode();
                }
                break;
            }
            default:
                break;
        }
        return id;
    }

    public static void setMapSource(final MapSource newMapSource) {
        if (!MapProviderFactory.isSameActivity(getMapSource(), newMapSource)) {
            mapProvider = null;
        }
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_MAP_SOURCE, newMapSource.getNumericalId());
            }
        });
        if (newMapSource instanceof OfflineMapSource) {
            setMapFile(((OfflineMapSource) newMapSource).getFileName());
        }
    }

    public static void setAnyCoordinates(final Geopoint coords) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (null != coords) {
                    edit.putFloat(KEY_ANYLATITUDE, (float) coords.getLatitude());
                    edit.putFloat(KEY_ANYLONGITUDE, (float) coords.getLongitude());
                } else {
                    edit.remove(KEY_ANYLATITUDE);
                    edit.remove(KEY_ANYLONGITUDE);
                }
            }
        });

    }

    public static Geopoint getAnyCoordinates() {
        if (sharedPrefs.contains(KEY_ANYLATITUDE) && sharedPrefs.contains(KEY_ANYLONGITUDE)) {
            float lat = sharedPrefs.getFloat(KEY_ANYLATITUDE, 0);
            float lon = sharedPrefs.getFloat(KEY_ANYLONGITUDE, 0);
            return new Geopoint(lat, lon);
        }
        return null;
    }

    public static boolean isUseCompass() {
        return sharedPrefs.getBoolean(KEY_USE_COMPASS, true);
    }

    public static void setUseCompass(final boolean useCompass) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_COMPASS, useCompass);
            }
        });
    }

    public static boolean isHelpShown() {
        return sharedPrefs.getBoolean(KEY_HELP_SHOWN, false);
    }

    public static void setHelpShown() {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_HELP_SHOWN, true);
            }
        });
    }

    public static boolean isLightSkin() {
        return sharedPrefs.getBoolean(KEY_SKIN, false);
    }

    public static void setLightSkin(final boolean lightSkin) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SKIN, lightSkin);
            }
        });
    }

    public static String getKeyConsumerPublic() {
        return keyConsumerPublic;
    }

    public static String getKeyConsumerSecret() {
        return keyConsumerSecret;
    }

    public static int getAltCorrection() {
        return sharedPrefs.getInt(KEY_ALTITUDE_CORRECTION, 0);
    }

    public static boolean setAltCorrection(final int altitude) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_ALTITUDE_CORRECTION, altitude);
            }
        });
    }

    public static String getWebDeviceCode() {
        return sharedPrefs.getString(KEY_WEB_DEVICE_CODE, null);
    }

    public static String getWebDeviceName() {
        return sharedPrefs.getString(KEY_WEBDEVICE_NAME, null);
    }

    /**
     * @return The cache type used for filtering or ALL if no filter is active. Returns never null
     */
    public static CacheType getCacheType() {
        return CacheType.getById(sharedPrefs.getString(KEY_CACHE_TYPE, CacheType.ALL.id));
    }

    /**
     * The Threshold for the showing of child waypoints
     *
     * @return
     */

    public static int getWayPointsThreshold() {
        return sharedPrefs.getInt(KEY_SHOW_WAYPOINTS_THRESHOLD, 0);
    }

    public static void setShowWaypointsThreshold(final int threshold) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_SHOW_WAYPOINTS_THRESHOLD, threshold);
            }
        });
    }

    public static boolean isUseTwitter() {
        return sharedPrefs.getBoolean(KEY_USE_TWITTER, false);
    }

    public static void setUseTwitter(final boolean useTwitter) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_TWITTER, useTwitter);
            }
        });
    }

    public static boolean isTwitterLoginValid() {
        return !StringUtils.isBlank(getTokenPublic()) && !StringUtils.isBlank(getTokenSecret());
    }

    public static String getTokenPublic() {
        return sharedPrefs.getString(KEY_TWITTER_TOKEN_PUBLIC, null);
    }

    public static String getTokenSecret() {
        return sharedPrefs.getString(KEY_TWITTER_TOKEN_SECRET, null);

    }

    public static int getVersion() {
        return sharedPrefs.getInt(KEY_VERSION, 0);
    }

    public static void setTwitterTokens(final String tokenPublic, final String tokenSecret, boolean enableTwitter) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_TWITTER_TOKEN_PUBLIC, tokenPublic);
                edit.putString(KEY_TWITTER_TOKEN_SECRET, tokenSecret);
                if (tokenPublic != null) {
                    edit.remove(KEY_TEMP_TOKEN_PUBLIC);
                    edit.remove(KEY_TEMP_TOKEN_SECRET);
                }
            }
        });
        setUseTwitter(enableTwitter);
    }

    public static void setTwitterTempTokens(final String tokenPublic, final String tokenSecret) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_TEMP_TOKEN_PUBLIC, tokenPublic);
                edit.putString(KEY_TEMP_TOKEN_SECRET, tokenSecret);
            }
        });
    }

    public static ImmutablePair<String, String> getTempToken() {
        String tokenPublic = sharedPrefs.getString(KEY_TEMP_TOKEN_PUBLIC, null);
        String tokenSecret = sharedPrefs.getString(KEY_TEMP_TOKEN_SECRET, null);
        return new ImmutablePair<String, String>(tokenPublic, tokenSecret);
    }

    public static void setVersion(final int version) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_VERSION, version);
            }
        });
    }

    public static boolean isOpenLastDetailsPage() {
        return sharedPrefs.getBoolean(KEY_OPEN_LAST_DETAILS_PAGE, false);
    }

    public static void setOpenLastDetailsPage(final boolean openLastPage) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_OPEN_LAST_DETAILS_PAGE, openLastPage);
            }
        });
    }

    public static int getLastDetailsPage() {
        return sharedPrefs.getInt(KEY_LAST_DETAILS_PAGE, 1);
    }

    public static void setLastDetailsPage(final int index) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_DETAILS_PAGE, index);
            }
        });
    }

    public static int getDefaultNavigationTool() {
        return sharedPrefs.getInt(KEY_DEFAULT_NAVIGATION_TOOL, NavigationAppsEnum.COMPASS.id);
    }

    public static void setDefaultNavigationTool(final int defaultNavigationTool) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_DEFAULT_NAVIGATION_TOOL, defaultNavigationTool);
            }
        });
    }

    public static int getDefaultNavigationTool2() {
        return sharedPrefs.getInt(KEY_DEFAULT_NAVIGATION_TOOL_2, NavigationAppsEnum.INTERNAL_MAP.id);
    }

    public static void setDefaultNavigationTool2(final int defaultNavigationTool) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_DEFAULT_NAVIGATION_TOOL_2, defaultNavigationTool);
            }
        });
    }

    public static Strategy getLiveMapStrategy() {
        return Strategy.getById(sharedPrefs.getInt(KEY_LIVE_MAP_STRATEGY, Strategy.AUTO.id));
    }

    public static void setLiveMapStrategy(final Strategy strategy) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LIVE_MAP_STRATEGY, strategy.id);
            }
        });
    }

    public static boolean isDebug() {
        return Log.isDebug();
    }

    public static void setDebug(final boolean debug) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_DEBUG, debug);
            }
        });
        Log.setDebugUnsaved(debug);
    }

    public static boolean getHideLiveMapHint() {
        return sharedPrefs.getBoolean(KEY_HIDE_LIVE_MAP_HINT, false);
    }

    public static void setHideLiveHint(final boolean hide) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_HIDE_LIVE_MAP_HINT, hide);
            }
        });
    }

    public static int getLiveMapHintShowCount() {
        return sharedPrefs.getInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, 0);
    }

    public static void setLiveMapHintShowCount(final int showCount) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, showCount);
            }
        });
    }

    public static boolean isDbOnSDCard() {
        return sharedPrefs.getBoolean(KEY_DB_ON_SDCARD, false);
    }

    public static void setDbOnSDCard(final boolean dbOnSDCard) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_DB_ON_SDCARD, dbOnSDCard);
            }
        });
    }

    public static String getGpxExportDir() {
        return sharedPrefs.getString(KEY_GPX_EXPORT_DIR, Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static void setGpxExportDir(final String gpxExportDir) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_GPX_EXPORT_DIR, gpxExportDir);
            }
        });
    }

    public static String getGpxImportDir() {
        return sharedPrefs.getString(KEY_GPX_IMPORT_DIR, Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static void setGpxImportDir(final String gpxImportDir) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_GPX_IMPORT_DIR, gpxImportDir);
            }
        });
    }

    public static boolean getShareAfterExport() {
        return sharedPrefs.getBoolean(KEY_SHARE_AFTER_EXPORT, true);
    }

    public static void setShareAfterExport(final boolean shareAfterExport) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SHARE_AFTER_EXPORT, shareAfterExport);
            }
        });
    }

    public static int getTrackableAction() {
        return sharedPrefs.getInt(KEY_LAST_TRACKABLE_ACTION, LogType.RETRIEVED_IT.id);
    }

    public static void setTrackableAction(final int trackableAction) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_TRACKABLE_ACTION, trackableAction);
            }
        });
    }

    public static String getCustomRenderThemeBaseFolder() {
        return sharedPrefs.getString(KEY_RENDER_THEME_BASE_FOLDER, "");
    }

    public static boolean setCustomRenderThemeBaseFolder(final String customRenderThemeBaseFolder) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_RENDER_THEME_BASE_FOLDER, customRenderThemeBaseFolder);
            }
        });
    }

    public static String getCustomRenderThemeFilePath() {
        return sharedPrefs.getString(KEY_RENDER_THEME_FILE_PATH, "");
    }

    public static void setCustomRenderThemeFile(final String customRenderThemeFile) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_RENDER_THEME_FILE_PATH, customRenderThemeFile);
            }
        });
    }

    public static File[] getMapThemeFiles() {

        File directory = new File(Settings.getCustomRenderThemeBaseFolder());

        List<File> result = new ArrayList<File>();

        FileUtils.listDir(result, directory, new ExtensionsBasedFileSelector(new String[] { "xml" }), null);

        return result.toArray(new File[result.size()]);
    }

    private static class ExtensionsBasedFileSelector extends FileSelector {

        private final String[] extensions;

        public ExtensionsBasedFileSelector(String[] extensions) {
            this.extensions = extensions;
        }

        @Override
        public boolean isSelected(File file) {
            String filename = file.getName();
            for (String ext : extensions) {
                if (StringUtils.endsWithIgnoreCase(filename, ext)) {
                    return true;
                }
            }
            return false;
        }

        @Override
        public boolean shouldEnd() {
            return false;
        }
    }

    public static String getPreferencesName() {
        // there is currently no Android API to get the file name of the shared preferences
        return cgeoapplication.getInstance().getPackageName() + "_preferences";
    }

    public static boolean getPlainLogs() {
        return sharedPrefs.getBoolean(KEY_PLAIN_LOGS, false);
    }

    public static void setPlainLogs(final boolean plainLogs) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_PLAIN_LOGS, plainLogs);
            }
        });
    }

    public static boolean getUseNativeUa() {
        return sharedPrefs.getBoolean(KEY_NATIVE_UA, false);
    }

    public static void setUseNativeUa(final boolean useNativeUa) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_NATIVE_UA, useNativeUa);
            }
        });
    }
}
!@#$%
20190527_000818,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_a18288
package cgeo.geocaching;

import cgeo.geocaching.apps.cache.navi.NavigationAppFactory.NavigationAppsEnum;
import cgeo.geocaching.connector.gc.GCConstants;
import cgeo.geocaching.connector.gc.Login;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.LiveMapStrategy.Strategy;
import cgeo.geocaching.enumerations.LogType;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.maps.MapProviderFactory;
import cgeo.geocaching.maps.google.GoogleMapProvider;
import cgeo.geocaching.maps.interfaces.GeoPointImpl;
import cgeo.geocaching.maps.interfaces.MapProvider;
import cgeo.geocaching.maps.interfaces.MapSource;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider.OfflineMapSource;
import cgeo.geocaching.utils.CryptUtils;
import cgeo.geocaching.utils.FileUtils;
import cgeo.geocaching.utils.FileUtils.FileSelector;
import cgeo.geocaching.utils.Log;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.os.Environment;
import android.preference.PreferenceManager;

import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

/**
 * General c:geo preferences/settings set by the user
 */
public final class Settings {

    private static final String KEY_TEMP_TOKEN_SECRET = "temp-token-secret";
    private static final String KEY_TEMP_TOKEN_PUBLIC = "temp-token-public";
    private static final String KEY_HELP_SHOWN = "helper";
    private static final String KEY_ANYLONGITUDE = "anylongitude";
    private static final String KEY_ANYLATITUDE = "anylatitude";
    private static final String KEY_USE_OFFLINEMAPS = "offlinemaps";
    private static final String KEY_USE_OFFLINEWPMAPS = "offlinewpmaps";
    private static final String KEY_WEB_DEVICE_CODE = "webDeviceCode";
    private static final String KEY_WEBDEVICE_NAME = "webDeviceName";
    private static final String KEY_MAP_LIVE = "maplive";
    private static final String KEY_MAP_SOURCE = "mapsource";
    private static final String KEY_USE_TWITTER = "twitter";
    private static final String KEY_SHOW_ADDRESS = "showaddress";
    private static final String KEY_SHOW_CAPTCHA = "showcaptcha";
    private static final String KEY_MAP_TRAIL = "maptrail";
    private static final String KEY_LAST_MAP_ZOOM = "mapzoom";
    private static final String KEY_LAST_MAP_LAT = "maplat";
    private static final String KEY_LAST_MAP_LON = "maplon";
    private static final String KEY_LIVE_LIST = "livelist";
    private static final String KEY_METRIC_UNITS = "units";
    private static final String KEY_SKIN = "skin";
    private static final String KEY_LAST_USED_LIST = "lastlist";
    private static final String KEY_CACHE_TYPE = "cachetype";
    private static final String KEY_TWITTER_TOKEN_SECRET = "tokensecret";
    private static final String KEY_TWITTER_TOKEN_PUBLIC = "tokenpublic";
    private static final String KEY_VERSION = "version";
    private static final String KEY_LOAD_DESCRIPTION = "autoloaddesc";
    private static final String KEY_RATING_WANTED = "ratingwanted";
    private static final String KEY_ELEVATION_WANTED = "elevationwanted";
    private static final String KEY_FRIENDLOGS_WANTED = "friendlogswanted";
    private static final String KEY_USE_ENGLISH = "useenglish";
    private static final String KEY_USE_COMPASS = "usecompass";
    private static final String KEY_AUTO_VISIT_TRACKABLES = "trackautovisit";
    private static final String KEY_AUTO_INSERT_SIGNATURE = "sigautoinsert";
    private static final String KEY_ALTITUDE_CORRECTION = "altcorrection";
    private static final String KEY_USE_GOOGLE_NAVIGATION = "usegnav";
    private static final String KEY_STORE_LOG_IMAGES = "logimages";
    private static final String KEY_EXCLUDE_DISABLED = "excludedisabled";
    private static final String KEY_EXCLUDE_OWN = "excludemine";
    private static final String KEY_MAPFILE = "mfmapfile";
    private static final String KEY_SIGNATURE = "signature";
    private static final String KEY_GCVOTE_PASSWORD = "pass-vote";
    private static final String KEY_PASSWORD = "password";
    private static final String KEY_USERNAME = "username";
    private static final String KEY_MEMBER_STATUS = "memberstatus";
    private static final String KEY_COORD_INPUT_FORMAT = "coordinputformat";
    private static final String KEY_LOG_OFFLINE = "log_offline";
    private static final String KEY_LOAD_DIRECTION_IMG = "loaddirectionimg";
    private static final String KEY_GC_CUSTOM_DATE = "gccustomdate";
    private static final String KEY_SHOW_WAYPOINTS_THRESHOLD = "gcshowwaypointsthreshold";
    private static final String KEY_COOKIE_STORE = "cookiestore";
    private static final String KEY_OPEN_LAST_DETAILS_PAGE = "opendetailslastpage";
    private static final String KEY_LAST_DETAILS_PAGE = "lastdetailspage";
    private static final String KEY_DEFAULT_NAVIGATION_TOOL = "defaultNavigationTool";
    private static final String KEY_DEFAULT_NAVIGATION_TOOL_2 = "defaultNavigationTool2";
    private static final String KEY_LIVE_MAP_STRATEGY = "livemapstrategy";
    private static final String KEY_DEBUG = "debug";
    private static final String KEY_HIDE_LIVE_MAP_HINT = "hidelivemaphint";
    private static final String KEY_LIVE_MAP_HINT_SHOW_COUNT = "livemaphintshowcount";
    private static final String KEY_SETTINGS_VERSION = "settingsversion";
    private static final String KEY_DB_ON_SDCARD = "dbonsdcard";
    private static final String KEY_LAST_TRACKABLE_ACTION = "trackableaction";
    private static final String KEY_SHARE_AFTER_EXPORT = "shareafterexport";
    private static final String KEY_GPX_EXPORT_DIR = "gpxExportDir";
    private static final String KEY_RENDER_THEME_BASE_FOLDER = "renderthemepath";
    private static final String KEY_RENDER_THEME_FILE_PATH = "renderthemefile";
    private static final String KEY_GPX_IMPORT_DIR = "gpxImportDir";
    private static final String KEY_PLAIN_LOGS = "plainLogs";
    private static final String KEY_NATIVE_UA = "nativeUa";
    private static final String KEY_MAP_DIRECTORY = "mapDirectory";

    private final static int unitsMetric = 1;

    // twitter api keys
    private final static String keyConsumerPublic = CryptUtils.rot13("ESnsCvAv3kEupF1GCR3jGj");
    private final static String keyConsumerSecret = CryptUtils.rot13("7vQWceACV9umEjJucmlpFe9FCMZSeqIqfkQ2BnhV9x");

    private interface PrefRunnable {
        void edit(final Editor edit);
    }

    public enum coordInputFormatEnum {
        Plain,
        Deg,
        Min,
        Sec;

        static coordInputFormatEnum fromInt(int id) {
            final coordInputFormatEnum[] values = coordInputFormatEnum.values();
            if (id < 0 || id >= values.length) {
                return Min;
            }
            return values[id];
        }
    }

    private static String username = null;
    private static String password = null;

    private static final SharedPreferences sharedPrefs = PreferenceManager.getDefaultSharedPreferences(cgeoapplication.getInstance().getBaseContext());
    static {
        migrateSettings();
        Log.setDebugUnsaved(sharedPrefs.getBoolean(KEY_DEBUG, false));
    }

    // maps
    private static MapProvider mapProvider = null;

    private Settings() {
        // this class is not to be instantiated;
    }

    private static void migrateSettings() {
        // migrate from non standard file location and integer based boolean types
        if (sharedPrefs.getInt(KEY_SETTINGS_VERSION, 0) < 1) {
            final String oldPreferencesName = "cgeo.pref";
            final SharedPreferences old = cgeoapplication.getInstance().getSharedPreferences(oldPreferencesName, Context.MODE_PRIVATE);
            final Editor e = sharedPrefs.edit();

            e.putString(KEY_TEMP_TOKEN_SECRET, old.getString(KEY_TEMP_TOKEN_SECRET, null));
            e.putString(KEY_TEMP_TOKEN_PUBLIC, old.getString(KEY_TEMP_TOKEN_PUBLIC, null));
            e.putBoolean(KEY_HELP_SHOWN, old.getInt(KEY_HELP_SHOWN, 0) != 0);
            e.putFloat(KEY_ANYLONGITUDE, old.getFloat(KEY_ANYLONGITUDE, 0));
            e.putFloat(KEY_ANYLATITUDE, old.getFloat(KEY_ANYLATITUDE, 0));
            e.putBoolean(KEY_USE_OFFLINEMAPS, 0 != old.getInt(KEY_USE_OFFLINEMAPS, 1));
            e.putBoolean(KEY_USE_OFFLINEWPMAPS, 0 != old.getInt(KEY_USE_OFFLINEWPMAPS, 0));
            e.putString(KEY_WEB_DEVICE_CODE, old.getString(KEY_WEB_DEVICE_CODE, null));
            e.putString(KEY_WEBDEVICE_NAME, old.getString(KEY_WEBDEVICE_NAME, null));
            e.putBoolean(KEY_MAP_LIVE, old.getInt(KEY_MAP_LIVE, 1) != 0);
            e.putInt(KEY_MAP_SOURCE, old.getInt(KEY_MAP_SOURCE, 0));
            e.putBoolean(KEY_USE_TWITTER, 0 != old.getInt(KEY_USE_TWITTER, 0));
            e.putBoolean(KEY_SHOW_ADDRESS, 0 != old.getInt(KEY_SHOW_ADDRESS, 1));
            e.putBoolean(KEY_SHOW_CAPTCHA, old.getBoolean(KEY_SHOW_CAPTCHA, false));
            e.putBoolean(KEY_MAP_TRAIL, old.getInt(KEY_MAP_TRAIL, 1) != 0);
            e.putInt(KEY_LAST_MAP_ZOOM, old.getInt(KEY_LAST_MAP_ZOOM, 14));
            e.putBoolean(KEY_LIVE_LIST, 0 != old.getInt(KEY_LIVE_LIST, 1));
            e.putBoolean(KEY_METRIC_UNITS, old.getInt(KEY_METRIC_UNITS, unitsMetric) == unitsMetric);
            e.putBoolean(KEY_SKIN, old.getInt(KEY_SKIN, 0) != 0);
            e.putInt(KEY_LAST_USED_LIST, old.getInt(KEY_LAST_USED_LIST, StoredList.STANDARD_LIST_ID));
            e.putString(KEY_CACHE_TYPE, old.getString(KEY_CACHE_TYPE, CacheType.ALL.id));
            e.putString(KEY_TWITTER_TOKEN_SECRET, old.getString(KEY_TWITTER_TOKEN_SECRET, null));
            e.putString(KEY_TWITTER_TOKEN_PUBLIC, old.getString(KEY_TWITTER_TOKEN_PUBLIC, null));
            e.putInt(KEY_VERSION, old.getInt(KEY_VERSION, 0));
            e.putBoolean(KEY_LOAD_DESCRIPTION, 0 != old.getInt(KEY_LOAD_DESCRIPTION, 0));
            e.putBoolean(KEY_RATING_WANTED, old.getBoolean(KEY_RATING_WANTED, true));
            e.putBoolean(KEY_ELEVATION_WANTED, old.getBoolean(KEY_ELEVATION_WANTED, true));
            e.putBoolean(KEY_FRIENDLOGS_WANTED, old.getBoolean(KEY_FRIENDLOGS_WANTED, true));
            e.putBoolean(KEY_USE_ENGLISH, old.getBoolean(KEY_USE_ENGLISH, false));
            e.putBoolean(KEY_USE_COMPASS, 0 != old.getInt(KEY_USE_COMPASS, 1));
            e.putBoolean(KEY_AUTO_VISIT_TRACKABLES, old.getBoolean(KEY_AUTO_VISIT_TRACKABLES, false));
            e.putBoolean(KEY_AUTO_INSERT_SIGNATURE, old.getBoolean(KEY_AUTO_INSERT_SIGNATURE, false));
            e.putInt(KEY_ALTITUDE_CORRECTION, old.getInt(KEY_ALTITUDE_CORRECTION, 0));
            e.putBoolean(KEY_USE_GOOGLE_NAVIGATION, 0 != old.getInt(KEY_USE_GOOGLE_NAVIGATION, 1));
            e.putBoolean(KEY_STORE_LOG_IMAGES, old.getBoolean(KEY_STORE_LOG_IMAGES, false));
            e.putBoolean(KEY_EXCLUDE_DISABLED, 0 != old.getInt(KEY_EXCLUDE_DISABLED, 0));
            e.putBoolean(KEY_EXCLUDE_OWN, 0 != old.getInt(KEY_EXCLUDE_OWN, 0));
            e.putString(KEY_MAPFILE, old.getString(KEY_MAPFILE, null));
            e.putString(KEY_SIGNATURE, old.getString(KEY_SIGNATURE, null));
            e.putString(KEY_GCVOTE_PASSWORD, old.getString(KEY_GCVOTE_PASSWORD, null));
            e.putString(KEY_PASSWORD, old.getString(KEY_PASSWORD, null));
            e.putString(KEY_USERNAME, old.getString(KEY_USERNAME, null));
            e.putString(KEY_MEMBER_STATUS, old.getString(KEY_MEMBER_STATUS, ""));
            e.putInt(KEY_COORD_INPUT_FORMAT, old.getInt(KEY_COORD_INPUT_FORMAT, 0));
            e.putBoolean(KEY_LOG_OFFLINE, old.getBoolean(KEY_LOG_OFFLINE, false));
            e.putBoolean(KEY_LOAD_DIRECTION_IMG, old.getBoolean(KEY_LOAD_DIRECTION_IMG, true));
            e.putString(KEY_GC_CUSTOM_DATE, old.getString(KEY_GC_CUSTOM_DATE, null));
            e.putInt(KEY_SHOW_WAYPOINTS_THRESHOLD, old.getInt(KEY_SHOW_WAYPOINTS_THRESHOLD, 0));
            e.putString(KEY_COOKIE_STORE, old.getString(KEY_COOKIE_STORE, null));
            e.putBoolean(KEY_OPEN_LAST_DETAILS_PAGE, old.getBoolean(KEY_OPEN_LAST_DETAILS_PAGE, false));
            e.putInt(KEY_LAST_DETAILS_PAGE, old.getInt(KEY_LAST_DETAILS_PAGE, 1));
            e.putInt(KEY_DEFAULT_NAVIGATION_TOOL, old.getInt(KEY_DEFAULT_NAVIGATION_TOOL, NavigationAppsEnum.COMPASS.id));
            e.putInt(KEY_DEFAULT_NAVIGATION_TOOL_2, old.getInt(KEY_DEFAULT_NAVIGATION_TOOL_2, NavigationAppsEnum.INTERNAL_MAP.id));
            e.putInt(KEY_LIVE_MAP_STRATEGY, old.getInt(KEY_LIVE_MAP_STRATEGY, Strategy.AUTO.id));
            e.putBoolean(KEY_DEBUG, old.getBoolean(KEY_DEBUG, false));
            e.putBoolean(KEY_HIDE_LIVE_MAP_HINT, old.getInt(KEY_HIDE_LIVE_MAP_HINT, 0) != 0);
            e.putInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, old.getInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, 0));

            e.putInt(KEY_SETTINGS_VERSION, 1); // mark migrated
            e.commit();
        }
    }

    public static void setLanguage(boolean useEnglish) {
        final Configuration config = new Configuration();
        config.locale = useEnglish ? new Locale("en") : Locale.getDefault();
        final Resources resources = cgeoapplication.getInstance().getResources();
        resources.updateConfiguration(config, resources.getDisplayMetrics());
    }

    public static boolean isLogin() {
        final String preUsername = sharedPrefs.getString(KEY_USERNAME, null);
        final String prePassword = sharedPrefs.getString(KEY_PASSWORD, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    /**
     * Get login and password information.
     *
     * @return a pair (login, password) or null if no valid information is stored
     */
    public static ImmutablePair<String, String> getLogin() {
        if (username == null || password == null) {
            final String preUsername = sharedPrefs.getString(KEY_USERNAME, null);
            final String prePassword = sharedPrefs.getString(KEY_PASSWORD, null);

            if (preUsername == null || prePassword == null) {
                return null;
            }

            username = preUsername;
            password = prePassword;
        }
        return new ImmutablePair<String, String>(username, password);
    }

    public static String getUsername() {
        return username != null ? username : sharedPrefs.getString(KEY_USERNAME, null);
    }

    public static boolean setLogin(final String username, final String password) {
        Settings.username = username;
        Settings.password = password;
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
                    // erase username and password
                    edit.remove(KEY_USERNAME);
                    edit.remove(KEY_PASSWORD);
                } else {
                    // save username and password
                    edit.putString(KEY_USERNAME, username);
                    edit.putString(KEY_PASSWORD, password);
                }
            }
        });
    }

    public static boolean isPremiumMember() {
        // Basic Member, Premium Member, ???
        String memberStatus = Settings.getMemberStatus();
        if (memberStatus == null) {
            return false;
        }
        return GCConstants.MEMBER_STATUS_PM.equalsIgnoreCase(memberStatus);
    }

    public static String getMemberStatus() {
        return sharedPrefs.getString(KEY_MEMBER_STATUS, "");
    }

    public static boolean setMemberStatus(final String memberStatus) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(memberStatus)) {
                    edit.remove(KEY_MEMBER_STATUS);
                } else {
                    edit.putString(KEY_MEMBER_STATUS, memberStatus);
                }
            }
        });
    }

    public static boolean isGCvoteLogin() {
        final String preUsername = sharedPrefs.getString(KEY_USERNAME, null);
        final String prePassword = sharedPrefs.getString(KEY_GCVOTE_PASSWORD, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    public static boolean setGCvoteLogin(final String password) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(password)) {
                    // erase password
                    edit.remove(KEY_GCVOTE_PASSWORD);
                } else {
                    // save password
                    edit.putString(KEY_GCVOTE_PASSWORD, password);
                }
            }
        });
    }

    public static ImmutablePair<String, String> getGCvoteLogin() {
        final String username = sharedPrefs.getString(KEY_USERNAME, null);
        final String password = sharedPrefs.getString(KEY_GCVOTE_PASSWORD, null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return null;
        }

        return new ImmutablePair<String, String>(username, password);
    }

    public static boolean setSignature(final String signature) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(signature)) {
                    // erase signature
                    edit.remove(KEY_SIGNATURE);
                } else {
                    // save signature
                    edit.putString(KEY_SIGNATURE, signature);
                }
            }
        });
    }

    public static String getSignature() {
        return sharedPrefs.getString(KEY_SIGNATURE, null);
    }

    public static boolean setCookieStore(final String cookies) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(final Editor edit) {
                if (StringUtils.isBlank(cookies)) {
                    // erase cookies
                    edit.remove(KEY_COOKIE_STORE);
                } else {
                    // save cookies
                    edit.putString(KEY_COOKIE_STORE, cookies);
                }
            }
        });
    }

    public static String getCookieStore() {
        return sharedPrefs.getString(KEY_COOKIE_STORE, null);
    }

    /**
     * @param cacheType
     *            The cache type used for future filtering
     */
    public static void setCacheType(final CacheType cacheType) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                if (cacheType == null) {
                    edit.remove(KEY_CACHE_TYPE);
                } else {
                    edit.putString(KEY_CACHE_TYPE, cacheType.id);
                }
            }
        });
    }

    public static void setLiveMap(final boolean live) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_MAP_LIVE, live);
            }
        });
    }

    public static int getLastList() {
        return sharedPrefs.getInt(KEY_LAST_USED_LIST, StoredList.STANDARD_LIST_ID);
    }

    public static void saveLastList(final int listId) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_USED_LIST, listId);
            }
        });
    }

    public static void setWebNameCode(final String name, final String code) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {

                edit.putString(KEY_WEBDEVICE_NAME, name);
                edit.putString(KEY_WEB_DEVICE_CODE, code);
            }
        });
    }

    public static MapProvider getMapProvider() {
        if (mapProvider == null) {
            mapProvider = getMapSource().getMapProvider();
        }
        return mapProvider;
    }

    public static String getMapFile() {
        return sharedPrefs.getString(KEY_MAPFILE, null);
    }

    public static boolean setMapFile(final String mapFile) {
        boolean result = editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_MAPFILE, mapFile);
            }
        });
        if (mapFile != null) {
            setMapFileDirectory(new File(mapFile).getParent());
        }
        return result;
    }

    public static String getMapFileDirectory() {
        final String mapDir = sharedPrefs.getString(KEY_MAP_DIRECTORY, null);
        if (mapDir != null) {
            return mapDir;
        }
        final String mapFile = getMapFile();
        if (mapFile != null) {
            return new File(mapFile).getParent();
        }
        return null;
    }

    public static boolean setMapFileDirectory(final String mapFileDirectory) {
        return editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_MAP_DIRECTORY, mapFileDirectory);
                MapsforgeMapProvider.getInstance().updateOfflineMaps();
            }
        });
    }

    public static boolean isValidMapFile() {
        return isValidMapFile(getMapFile());
    }

    public static boolean isValidMapFile(final String mapFileIn) {
        return MapsforgeMapProvider.isValidMapFile(mapFileIn);
    }

    public static coordInputFormatEnum getCoordInputFormat() {
        return coordInputFormatEnum.fromInt(sharedPrefs.getInt(KEY_COORD_INPUT_FORMAT, 0));
    }

    public static void setCoordInputFormat(final coordInputFormatEnum format) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_COORD_INPUT_FORMAT, format.ordinal());
            }
        });
    }

    static void setLogOffline(final boolean offline) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LOG_OFFLINE, offline);
            }
        });
    }

    public static boolean getLogOffline() {
        return sharedPrefs.getBoolean(KEY_LOG_OFFLINE, false);
    }

    static void setLoadDirImg(final boolean value) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LOAD_DIRECTION_IMG, value);
            }
        });
    }

    public static boolean getLoadDirImg() {
        return !isPremiumMember() && sharedPrefs.getBoolean(KEY_LOAD_DIRECTION_IMG, true);
    }

    public static void setGcCustomDate(final String format) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_GC_CUSTOM_DATE, format);
            }
        });
    }

    /**
     * @return User selected date format on GC.com
     * @see Login#gcCustomDateFormats
     */
    public static String getGcCustomDate() {
        return sharedPrefs.getString(KEY_GC_CUSTOM_DATE, null);
    }

    public static boolean isExcludeMyCaches() {
        return sharedPrefs.getBoolean(KEY_EXCLUDE_OWN, false);
    }

    /**
     * edit some settings without knowing how to get the settings editor or how to commit
     *
     * @param runnable
     * @return
     */
    private static boolean editSharedSettings(final PrefRunnable runnable) {
        final SharedPreferences.Editor prefsEdit = sharedPrefs.edit();
        runnable.edit(prefsEdit);
        return prefsEdit.commit();
    }

    public static void setExcludeMine(final boolean exclude) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_EXCLUDE_OWN, exclude);
            }
        });
    }

    public static void setUseEnglish(final boolean english) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_ENGLISH, english);
                setLanguage(english);
            }
        });
    }

    public static boolean isUseEnglish() {
        return sharedPrefs.getBoolean(KEY_USE_ENGLISH, false);
    }

    public static boolean isShowAddress() {
        return sharedPrefs.getBoolean(KEY_SHOW_ADDRESS, true);
    }

    public static void setShowAddress(final boolean showAddress) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SHOW_ADDRESS, showAddress);
            }
        });
    }

    public static boolean isShowCaptcha() {
        return !isPremiumMember() && sharedPrefs.getBoolean(KEY_SHOW_CAPTCHA, false);
    }

    public static void setShowCaptcha(final boolean showCaptcha) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SHOW_CAPTCHA, showCaptcha);
            }
        });
    }

    public static boolean isExcludeDisabledCaches() {
        return sharedPrefs.getBoolean(KEY_EXCLUDE_DISABLED, false);
    }

    public static void setExcludeDisabledCaches(final boolean exclude) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_EXCLUDE_DISABLED, exclude);
            }
        });
    }

    public static boolean isStoreOfflineMaps() {
        return sharedPrefs.getBoolean(KEY_USE_OFFLINEMAPS, true);
    }

    public static void setStoreOfflineMaps(final boolean offlineMaps) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_OFFLINEMAPS, offlineMaps);
            }
        });
    }

    public static boolean isStoreOfflineWpMaps() {
        return sharedPrefs.getBoolean(KEY_USE_OFFLINEWPMAPS, false);
    }

    public static void setStoreOfflineWpMaps(final boolean offlineMaps) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_OFFLINEWPMAPS, offlineMaps);
            }
        });
    }

    public static boolean isStoreLogImages() {
        return sharedPrefs.getBoolean(KEY_STORE_LOG_IMAGES, false);
    }

    public static void setStoreLogImages(final boolean storeLogImages) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_STORE_LOG_IMAGES, storeLogImages);
            }
        });
    }

    public static boolean isUseGoogleNavigation() {
        return sharedPrefs.getBoolean(KEY_USE_GOOGLE_NAVIGATION, true);
    }

    public static void setUseGoogleNavigation(final boolean useGoogleNavigation) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_GOOGLE_NAVIGATION, useGoogleNavigation);
            }
        });
    }

    public static boolean isAutoLoadDescription() {
        return sharedPrefs.getBoolean(KEY_LOAD_DESCRIPTION, false);
    }

    public static void setAutoLoadDesc(final boolean autoLoad) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LOAD_DESCRIPTION, autoLoad);
            }
        });
    }

    public static boolean isRatingWanted() {
        return sharedPrefs.getBoolean(KEY_RATING_WANTED, true);
    }

    public static void setRatingWanted(final boolean ratingWanted) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_RATING_WANTED, ratingWanted);
            }
        });
    }

    public static boolean isElevationWanted() {
        return sharedPrefs.getBoolean(KEY_ELEVATION_WANTED, true);
    }

    public static void setElevationWanted(final boolean elevationWanted) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_ELEVATION_WANTED, elevationWanted);
            }
        });
    }

    public static boolean isFriendLogsWanted() {
        if (!isLogin()) {
            // don't show a friends log if the user is anonymous
            return false;
        }
        return sharedPrefs.getBoolean(KEY_FRIENDLOGS_WANTED, true);
    }

    public static void setFriendLogsWanted(final boolean friendLogsWanted) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_FRIENDLOGS_WANTED, friendLogsWanted);
            }
        });
    }

    public static boolean isLiveList() {
        return sharedPrefs.getBoolean(KEY_LIVE_LIST, true);
    }

    public static void setLiveList(final boolean liveList) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LIVE_LIST, liveList);
            }
        });
    }

    public static boolean isTrackableAutoVisit() {
        return sharedPrefs.getBoolean(KEY_AUTO_VISIT_TRACKABLES, false);
    }

    public static void setTrackableAutoVisit(final boolean autoVisit) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_AUTO_VISIT_TRACKABLES, autoVisit);
            }
        });
    }

    public static boolean isAutoInsertSignature() {
        return sharedPrefs.getBoolean(KEY_AUTO_INSERT_SIGNATURE, false);
    }

    public static void setAutoInsertSignature(final boolean autoInsert) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_AUTO_INSERT_SIGNATURE, autoInsert);
            }
        });
    }

    public static boolean isUseMetricUnits() {
        return sharedPrefs.getBoolean(KEY_METRIC_UNITS, true);
    }

    public static void setUseMetricUnits(final boolean metric) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_METRIC_UNITS, metric);
            }
        });
    }

    public static boolean isLiveMap() {
        return sharedPrefs.getBoolean(KEY_MAP_LIVE, true);
    }

    public static boolean isMapTrail() {
        return sharedPrefs.getBoolean(KEY_MAP_TRAIL, true);
    }

    public static void setMapTrail(final boolean showTrail) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_MAP_TRAIL, showTrail);
            }
        });
    }

    public static int getMapZoom() {
        return sharedPrefs.getInt(KEY_LAST_MAP_ZOOM, 14);
    }

    public static void setMapZoom(final int mapZoomLevel) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_MAP_ZOOM, mapZoomLevel);
            }
        });
    }

    public static GeoPointImpl getMapCenter() {
        return getMapProvider().getMapItemFactory()
                .getGeoPointBase(new Geopoint(sharedPrefs.getInt(KEY_LAST_MAP_LAT, 0) / 1e6,
                        sharedPrefs.getInt(KEY_LAST_MAP_LON, 0) / 1e6));
    }

    public static void setMapCenter(final GeoPointImpl mapViewCenter) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_MAP_LAT, mapViewCenter.getLatitudeE6());
                edit.putInt(KEY_LAST_MAP_LON, mapViewCenter.getLongitudeE6());
            }
        });
    }

    public static MapSource getMapSource() {
        final int id = getConvertedMapId();
        final MapSource map = MapProviderFactory.getMapSource(id);
        if (map != null) {
            // don't use offline maps if the map file is not valid
            if ((!(map instanceof OfflineMapSource)) || (isValidMapFile())) {
                return map;
            }
        }
        // fallback to first available map
        return MapProviderFactory.getDefaultSource();
    }

    private final static int GOOGLEMAP_BASEID = 30;
    private final static int MAP = 1;
    private final static int SATELLITE = 2;

    private final static int MFMAP_BASEID = 40;
    private final static int MAPNIK = 1;
    private final static int CYCLEMAP = 3;
    private final static int OFFLINE = 4;

    /**
     * convert old preference ids for maps (based on constant values) into new hash based ids
     *
     * @return
     */
    private static int getConvertedMapId() {
        final int id = sharedPrefs.getInt(KEY_MAP_SOURCE, 0);
        switch (id) {
            case GOOGLEMAP_BASEID + MAP:
                return GoogleMapProvider.GOOGLE_MAP_ID.hashCode();
            case GOOGLEMAP_BASEID + SATELLITE:
                return GoogleMapProvider.GOOGLE_SATELLITE_ID.hashCode();
            case MFMAP_BASEID + MAPNIK:
                return MapsforgeMapProvider.MAPSFORGE_MAPNIK_ID.hashCode();
            case MFMAP_BASEID + CYCLEMAP:
                return MapsforgeMapProvider.MAPSFORGE_CYCLEMAP_ID.hashCode();
            case MFMAP_BASEID + OFFLINE: {
                final String mapFile = Settings.getMapFile();
                if (StringUtils.isNotEmpty(mapFile)) {
                    return mapFile.hashCode();
                }
                break;
            }
            default:
                break;
        }
        return id;
    }

    public static void setMapSource(final MapSource newMapSource) {
        if (!MapProviderFactory.isSameActivity(getMapSource(), newMapSource)) {
            mapProvider = null;
        }
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_MAP_SOURCE, newMapSource.getNumericalId());
            }
        });
        if (newMapSource instanceof OfflineMapSource) {
            setMapFile(((OfflineMapSource) newMapSource).getFileName());
        }
    }

    public static void setAnyCoordinates(final Geopoint coords) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (null != coords) {
                    edit.putFloat(KEY_ANYLATITUDE, (float) coords.getLatitude());
                    edit.putFloat(KEY_ANYLONGITUDE, (float) coords.getLongitude());
                } else {
                    edit.remove(KEY_ANYLATITUDE);
                    edit.remove(KEY_ANYLONGITUDE);
                }
            }
        });

    }

    public static Geopoint getAnyCoordinates() {
        if (sharedPrefs.contains(KEY_ANYLATITUDE) && sharedPrefs.contains(KEY_ANYLONGITUDE)) {
            float lat = sharedPrefs.getFloat(KEY_ANYLATITUDE, 0);
            float lon = sharedPrefs.getFloat(KEY_ANYLONGITUDE, 0);
            return new Geopoint(lat, lon);
        }
        return null;
    }

    public static boolean isUseCompass() {
        return sharedPrefs.getBoolean(KEY_USE_COMPASS, true);
    }

    public static void setUseCompass(final boolean useCompass) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_COMPASS, useCompass);
            }
        });
    }

    public static boolean isHelpShown() {
        return sharedPrefs.getBoolean(KEY_HELP_SHOWN, false);
    }

    public static void setHelpShown() {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_HELP_SHOWN, true);
            }
        });
    }

    public static boolean isLightSkin() {
        return sharedPrefs.getBoolean(KEY_SKIN, false);
    }

    public static void setLightSkin(final boolean lightSkin) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SKIN, lightSkin);
            }
        });
    }

    public static String getKeyConsumerPublic() {
        return keyConsumerPublic;
    }

    public static String getKeyConsumerSecret() {
        return keyConsumerSecret;
    }

    public static int getAltCorrection() {
        return sharedPrefs.getInt(KEY_ALTITUDE_CORRECTION, 0);
    }

    public static boolean setAltCorrection(final int altitude) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_ALTITUDE_CORRECTION, altitude);
            }
        });
    }

    public static String getWebDeviceCode() {
        return sharedPrefs.getString(KEY_WEB_DEVICE_CODE, null);
    }

    public static String getWebDeviceName() {
        return sharedPrefs.getString(KEY_WEBDEVICE_NAME, null);
    }

    /**
     * @return The cache type used for filtering or ALL if no filter is active. Returns never null
     */
    public static CacheType getCacheType() {
        return CacheType.getById(sharedPrefs.getString(KEY_CACHE_TYPE, CacheType.ALL.id));
    }

    /**
     * The Threshold for the showing of child waypoints
     *
     * @return
     */

    public static int getWayPointsThreshold() {
        return sharedPrefs.getInt(KEY_SHOW_WAYPOINTS_THRESHOLD, 0);
    }

    public static void setShowWaypointsThreshold(final int threshold) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_SHOW_WAYPOINTS_THRESHOLD, threshold);
            }
        });
    }

    public static boolean isUseTwitter() {
        return sharedPrefs.getBoolean(KEY_USE_TWITTER, false);
    }

    public static void setUseTwitter(final boolean useTwitter) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_TWITTER, useTwitter);
            }
        });
    }

    public static boolean isTwitterLoginValid() {
        return !StringUtils.isBlank(getTokenPublic()) && !StringUtils.isBlank(getTokenSecret());
    }

    public static String getTokenPublic() {
        return sharedPrefs.getString(KEY_TWITTER_TOKEN_PUBLIC, null);
    }

    public static String getTokenSecret() {
        return sharedPrefs.getString(KEY_TWITTER_TOKEN_SECRET, null);

    }

    public static int getVersion() {
        return sharedPrefs.getInt(KEY_VERSION, 0);
    }

    public static void setTwitterTokens(final String tokenPublic, final String tokenSecret, boolean enableTwitter) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_TWITTER_TOKEN_PUBLIC, tokenPublic);
                edit.putString(KEY_TWITTER_TOKEN_SECRET, tokenSecret);
                if (tokenPublic != null) {
                    edit.remove(KEY_TEMP_TOKEN_PUBLIC);
                    edit.remove(KEY_TEMP_TOKEN_SECRET);
                }
            }
        });
        setUseTwitter(enableTwitter);
    }

    public static void setTwitterTempTokens(final String tokenPublic, final String tokenSecret) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_TEMP_TOKEN_PUBLIC, tokenPublic);
                edit.putString(KEY_TEMP_TOKEN_SECRET, tokenSecret);
            }
        });
    }

    public static ImmutablePair<String, String> getTempToken() {
        String tokenPublic = sharedPrefs.getString(KEY_TEMP_TOKEN_PUBLIC, null);
        String tokenSecret = sharedPrefs.getString(KEY_TEMP_TOKEN_SECRET, null);
        return new ImmutablePair<String, String>(tokenPublic, tokenSecret);
    }

    public static void setVersion(final int version) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_VERSION, version);
            }
        });
    }

    public static boolean isOpenLastDetailsPage() {
        return sharedPrefs.getBoolean(KEY_OPEN_LAST_DETAILS_PAGE, false);
    }

    public static void setOpenLastDetailsPage(final boolean openLastPage) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_OPEN_LAST_DETAILS_PAGE, openLastPage);
            }
        });
    }

    public static int getLastDetailsPage() {
        return sharedPrefs.getInt(KEY_LAST_DETAILS_PAGE, 1);
    }

    public static void setLastDetailsPage(final int index) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_DETAILS_PAGE, index);
            }
        });
    }

    public static int getDefaultNavigationTool() {
        return sharedPrefs.getInt(KEY_DEFAULT_NAVIGATION_TOOL, NavigationAppsEnum.COMPASS.id);
    }

    public static void setDefaultNavigationTool(final int defaultNavigationTool) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_DEFAULT_NAVIGATION_TOOL, defaultNavigationTool);
            }
        });
    }

    public static int getDefaultNavigationTool2() {
        return sharedPrefs.getInt(KEY_DEFAULT_NAVIGATION_TOOL_2, NavigationAppsEnum.INTERNAL_MAP.id);
    }

    public static void setDefaultNavigationTool2(final int defaultNavigationTool) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_DEFAULT_NAVIGATION_TOOL_2, defaultNavigationTool);
            }
        });
    }

    public static Strategy getLiveMapStrategy() {
        return Strategy.getById(sharedPrefs.getInt(KEY_LIVE_MAP_STRATEGY, Strategy.AUTO.id));
    }

    public static void setLiveMapStrategy(final Strategy strategy) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LIVE_MAP_STRATEGY, strategy.id);
            }
        });
    }

    public static boolean isDebug() {
        return Log.isDebug();
    }

    public static void setDebug(final boolean debug) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_DEBUG, debug);
            }
        });
        Log.setDebugUnsaved(debug);
    }

    public static boolean getHideLiveMapHint() {
        return sharedPrefs.getBoolean(KEY_HIDE_LIVE_MAP_HINT, false);
    }

    public static void setHideLiveHint(final boolean hide) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_HIDE_LIVE_MAP_HINT, hide);
            }
        });
    }

    public static int getLiveMapHintShowCount() {
        return sharedPrefs.getInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, 0);
    }

    public static void setLiveMapHintShowCount(final int showCount) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, showCount);
            }
        });
    }

    public static boolean isDbOnSDCard() {
        return sharedPrefs.getBoolean(KEY_DB_ON_SDCARD, false);
    }

    public static void setDbOnSDCard(final boolean dbOnSDCard) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_DB_ON_SDCARD, dbOnSDCard);
            }
        });
    }

    public static String getGpxExportDir() {
        return sharedPrefs.getString(KEY_GPX_EXPORT_DIR, Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static void setGpxExportDir(final String gpxExportDir) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_GPX_EXPORT_DIR, gpxExportDir);
            }
        });
    }

    public static String getGpxImportDir() {
        return sharedPrefs.getString(KEY_GPX_IMPORT_DIR, Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static void setGpxImportDir(final String gpxImportDir) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_GPX_IMPORT_DIR, gpxImportDir);
            }
        });
    }

    public static boolean getShareAfterExport() {
        return sharedPrefs.getBoolean(KEY_SHARE_AFTER_EXPORT, true);
    }

    public static void setShareAfterExport(final boolean shareAfterExport) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SHARE_AFTER_EXPORT, shareAfterExport);
            }
        });
    }

    public static int getTrackableAction() {
        return sharedPrefs.getInt(KEY_LAST_TRACKABLE_ACTION, LogType.RETRIEVED_IT.id);
    }

    public static void setTrackableAction(final int trackableAction) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_TRACKABLE_ACTION, trackableAction);
            }
        });
    }

    public static String getCustomRenderThemeBaseFolder() {
        return sharedPrefs.getString(KEY_RENDER_THEME_BASE_FOLDER, "");
    }

    public static boolean setCustomRenderThemeBaseFolder(final String customRenderThemeBaseFolder) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_RENDER_THEME_BASE_FOLDER, customRenderThemeBaseFolder);
            }
        });
    }

    public static String getCustomRenderThemeFilePath() {
        return sharedPrefs.getString(KEY_RENDER_THEME_FILE_PATH, "");
    }

    public static void setCustomRenderThemeFile(final String customRenderThemeFile) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_RENDER_THEME_FILE_PATH, customRenderThemeFile);
            }
        });
    }

    public static File[] getMapThemeFiles() {

        File directory = new File(Settings.getCustomRenderThemeBaseFolder());

        List<File> result = new ArrayList<File>();

        FileUtils.listDir(result, directory, new ExtensionsBasedFileSelector(new String[] { "xml" }), null);

        return result.toArray(new File[] {});
    }

    private static class ExtensionsBasedFileSelector extends FileSelector {

        private final String[] extensions;

        public ExtensionsBasedFileSelector(String[] extensions) {
            this.extensions = extensions;
        }

        @Override
        public boolean isSelected(File file) {
            String filename = file.getName();
            for (String ext : extensions) {
                if (StringUtils.endsWithIgnoreCase(filename, ext)) {
                    return true;
                }
            }
            return false;
        }

        @Override
        public boolean shouldEnd() {
            return false;
        }
    }

    public static String getPreferencesName() {
        // there is currently no Android API to get the file name of the shared preferences
        return cgeoapplication.getInstance().getPackageName() + "_preferences";
    }

    public static boolean getPlainLogs() {
        return sharedPrefs.getBoolean(KEY_PLAIN_LOGS, false);
    }

    public static void setPlainLogs(final boolean plainLogs) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_PLAIN_LOGS, plainLogs);
            }
        });
    }

    public static boolean getUseNativeUa() {
        return sharedPrefs.getBoolean(KEY_NATIVE_UA, false);
    }

    public static void setUseNativeUa(final boolean useNativeUa) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_NATIVE_UA, useNativeUa);
            }
        });
    }
}
!@#$%
20190527_000818,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_c18288
package cgeo.geocaching;

import cgeo.geocaching.apps.cache.navi.NavigationAppFactory.NavigationAppsEnum;
import cgeo.geocaching.connector.gc.GCConstants;
import cgeo.geocaching.connector.gc.Login;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.LiveMapStrategy.Strategy;
import cgeo.geocaching.enumerations.LogType;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.maps.MapProviderFactory;
import cgeo.geocaching.maps.google.GoogleMapProvider;
import cgeo.geocaching.maps.interfaces.GeoPointImpl;
import cgeo.geocaching.maps.interfaces.MapProvider;
import cgeo.geocaching.maps.interfaces.MapSource;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider.OfflineMapSource;
import cgeo.geocaching.utils.CryptUtils;
import cgeo.geocaching.utils.FileUtils;
import cgeo.geocaching.utils.FileUtils.FileSelector;
import cgeo.geocaching.utils.Log;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.os.Environment;
import android.preference.PreferenceManager;

import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

/**
 * General c:geo preferences/settings set by the user
 */
public final class Settings {

    private static final String KEY_TEMP_TOKEN_SECRET = "temp-token-secret";
    private static final String KEY_TEMP_TOKEN_PUBLIC = "temp-token-public";
    private static final String KEY_HELP_SHOWN = "helper";
    private static final String KEY_ANYLONGITUDE = "anylongitude";
    private static final String KEY_ANYLATITUDE = "anylatitude";
    private static final String KEY_USE_OFFLINEMAPS = "offlinemaps";
    private static final String KEY_USE_OFFLINEWPMAPS = "offlinewpmaps";
    private static final String KEY_WEB_DEVICE_CODE = "webDeviceCode";
    private static final String KEY_WEBDEVICE_NAME = "webDeviceName";
    private static final String KEY_MAP_LIVE = "maplive";
    private static final String KEY_MAP_SOURCE = "mapsource";
    private static final String KEY_USE_TWITTER = "twitter";
    private static final String KEY_SHOW_ADDRESS = "showaddress";
    private static final String KEY_SHOW_CAPTCHA = "showcaptcha";
    private static final String KEY_MAP_TRAIL = "maptrail";
    private static final String KEY_LAST_MAP_ZOOM = "mapzoom";
    private static final String KEY_LAST_MAP_LAT = "maplat";
    private static final String KEY_LAST_MAP_LON = "maplon";
    private static final String KEY_LIVE_LIST = "livelist";
    private static final String KEY_METRIC_UNITS = "units";
    private static final String KEY_SKIN = "skin";
    private static final String KEY_LAST_USED_LIST = "lastlist";
    private static final String KEY_CACHE_TYPE = "cachetype";
    private static final String KEY_TWITTER_TOKEN_SECRET = "tokensecret";
    private static final String KEY_TWITTER_TOKEN_PUBLIC = "tokenpublic";
    private static final String KEY_VERSION = "version";
    private static final String KEY_LOAD_DESCRIPTION = "autoloaddesc";
    private static final String KEY_RATING_WANTED = "ratingwanted";
    private static final String KEY_ELEVATION_WANTED = "elevationwanted";
    private static final String KEY_FRIENDLOGS_WANTED = "friendlogswanted";
    private static final String KEY_USE_ENGLISH = "useenglish";
    private static final String KEY_USE_COMPASS = "usecompass";
    private static final String KEY_AUTO_VISIT_TRACKABLES = "trackautovisit";
    private static final String KEY_AUTO_INSERT_SIGNATURE = "sigautoinsert";
    private static final String KEY_ALTITUDE_CORRECTION = "altcorrection";
    private static final String KEY_USE_GOOGLE_NAVIGATION = "usegnav";
    private static final String KEY_STORE_LOG_IMAGES = "logimages";
    private static final String KEY_EXCLUDE_DISABLED = "excludedisabled";
    private static final String KEY_EXCLUDE_OWN = "excludemine";
    private static final String KEY_MAPFILE = "mfmapfile";
    private static final String KEY_SIGNATURE = "signature";
    private static final String KEY_GCVOTE_PASSWORD = "pass-vote";
    private static final String KEY_PASSWORD = "password";
    private static final String KEY_USERNAME = "username";
    private static final String KEY_MEMBER_STATUS = "memberstatus";
    private static final String KEY_COORD_INPUT_FORMAT = "coordinputformat";
    private static final String KEY_LOG_OFFLINE = "log_offline";
    private static final String KEY_LOAD_DIRECTION_IMG = "loaddirectionimg";
    private static final String KEY_GC_CUSTOM_DATE = "gccustomdate";
    private static final String KEY_SHOW_WAYPOINTS_THRESHOLD = "gcshowwaypointsthreshold";
    private static final String KEY_COOKIE_STORE = "cookiestore";
    private static final String KEY_OPEN_LAST_DETAILS_PAGE = "opendetailslastpage";
    private static final String KEY_LAST_DETAILS_PAGE = "lastdetailspage";
    private static final String KEY_DEFAULT_NAVIGATION_TOOL = "defaultNavigationTool";
    private static final String KEY_DEFAULT_NAVIGATION_TOOL_2 = "defaultNavigationTool2";
    private static final String KEY_LIVE_MAP_STRATEGY = "livemapstrategy";
    private static final String KEY_DEBUG = "debug";
    private static final String KEY_HIDE_LIVE_MAP_HINT = "hidelivemaphint";
    private static final String KEY_LIVE_MAP_HINT_SHOW_COUNT = "livemaphintshowcount";
    private static final String KEY_SETTINGS_VERSION = "settingsversion";
    private static final String KEY_DB_ON_SDCARD = "dbonsdcard";
    private static final String KEY_LAST_TRACKABLE_ACTION = "trackableaction";
    private static final String KEY_SHARE_AFTER_EXPORT = "shareafterexport";
    private static final String KEY_GPX_EXPORT_DIR = "gpxExportDir";
    private static final String KEY_RENDER_THEME_BASE_FOLDER = "renderthemepath";
    private static final String KEY_RENDER_THEME_FILE_PATH = "renderthemefile";
    private static final String KEY_GPX_IMPORT_DIR = "gpxImportDir";
    private static final String KEY_PLAIN_LOGS = "plainLogs";
    private static final String KEY_NATIVE_UA = "nativeUa";
    private static final String KEY_MAP_DIRECTORY = "mapDirectory";

    private final static int unitsMetric = 1;

    // twitter api keys
    private final static String keyConsumerPublic = CryptUtils.rot13("ESnsCvAv3kEupF1GCR3jGj");
    private final static String keyConsumerSecret = CryptUtils.rot13("7vQWceACV9umEjJucmlpFe9FCMZSeqIqfkQ2BnhV9x");

    private interface PrefRunnable {
        void edit(final Editor edit);
    }

    public enum coordInputFormatEnum {
        Plain,
        Deg,
        Min,
        Sec;

        static coordInputFormatEnum fromInt(int id) {
            final coordInputFormatEnum[] values = coordInputFormatEnum.values();
            if (id < 0 || id >= values.length) {
                return Min;
            }
            return values[id];
        }
    }

    private static String username = null;
    private static String password = null;

    private static final SharedPreferences sharedPrefs = PreferenceManager.getDefaultSharedPreferences(cgeoapplication.getInstance().getBaseContext());
    static {
        migrateSettings();
        Log.setDebugUnsaved(sharedPrefs.getBoolean(KEY_DEBUG, false));
    }

    // maps
    private static MapProvider mapProvider = null;

    private Settings() {
        // this class is not to be instantiated;
    }

    private static void migrateSettings() {
        // migrate from non standard file location and integer based boolean types
        if (sharedPrefs.getInt(KEY_SETTINGS_VERSION, 0) < 1) {
            final String oldPreferencesName = "cgeo.pref";
            final SharedPreferences old = cgeoapplication.getInstance().getSharedPreferences(oldPreferencesName, Context.MODE_PRIVATE);
            final Editor e = sharedPrefs.edit();

            e.putString(KEY_TEMP_TOKEN_SECRET, old.getString(KEY_TEMP_TOKEN_SECRET, null));
            e.putString(KEY_TEMP_TOKEN_PUBLIC, old.getString(KEY_TEMP_TOKEN_PUBLIC, null));
            e.putBoolean(KEY_HELP_SHOWN, old.getInt(KEY_HELP_SHOWN, 0) != 0);
            e.putFloat(KEY_ANYLONGITUDE, old.getFloat(KEY_ANYLONGITUDE, 0));
            e.putFloat(KEY_ANYLATITUDE, old.getFloat(KEY_ANYLATITUDE, 0));
            e.putBoolean(KEY_USE_OFFLINEMAPS, 0 != old.getInt(KEY_USE_OFFLINEMAPS, 1));
            e.putBoolean(KEY_USE_OFFLINEWPMAPS, 0 != old.getInt(KEY_USE_OFFLINEWPMAPS, 0));
            e.putString(KEY_WEB_DEVICE_CODE, old.getString(KEY_WEB_DEVICE_CODE, null));
            e.putString(KEY_WEBDEVICE_NAME, old.getString(KEY_WEBDEVICE_NAME, null));
            e.putBoolean(KEY_MAP_LIVE, old.getInt(KEY_MAP_LIVE, 1) != 0);
            e.putInt(KEY_MAP_SOURCE, old.getInt(KEY_MAP_SOURCE, 0));
            e.putBoolean(KEY_USE_TWITTER, 0 != old.getInt(KEY_USE_TWITTER, 0));
            e.putBoolean(KEY_SHOW_ADDRESS, 0 != old.getInt(KEY_SHOW_ADDRESS, 1));
            e.putBoolean(KEY_SHOW_CAPTCHA, old.getBoolean(KEY_SHOW_CAPTCHA, false));
            e.putBoolean(KEY_MAP_TRAIL, old.getInt(KEY_MAP_TRAIL, 1) != 0);
            e.putInt(KEY_LAST_MAP_ZOOM, old.getInt(KEY_LAST_MAP_ZOOM, 14));
            e.putBoolean(KEY_LIVE_LIST, 0 != old.getInt(KEY_LIVE_LIST, 1));
            e.putBoolean(KEY_METRIC_UNITS, old.getInt(KEY_METRIC_UNITS, unitsMetric) == unitsMetric);
            e.putBoolean(KEY_SKIN, old.getInt(KEY_SKIN, 0) != 0);
            e.putInt(KEY_LAST_USED_LIST, old.getInt(KEY_LAST_USED_LIST, StoredList.STANDARD_LIST_ID));
            e.putString(KEY_CACHE_TYPE, old.getString(KEY_CACHE_TYPE, CacheType.ALL.id));
            e.putString(KEY_TWITTER_TOKEN_SECRET, old.getString(KEY_TWITTER_TOKEN_SECRET, null));
            e.putString(KEY_TWITTER_TOKEN_PUBLIC, old.getString(KEY_TWITTER_TOKEN_PUBLIC, null));
            e.putInt(KEY_VERSION, old.getInt(KEY_VERSION, 0));
            e.putBoolean(KEY_LOAD_DESCRIPTION, 0 != old.getInt(KEY_LOAD_DESCRIPTION, 0));
            e.putBoolean(KEY_RATING_WANTED, old.getBoolean(KEY_RATING_WANTED, true));
            e.putBoolean(KEY_ELEVATION_WANTED, old.getBoolean(KEY_ELEVATION_WANTED, true));
            e.putBoolean(KEY_FRIENDLOGS_WANTED, old.getBoolean(KEY_FRIENDLOGS_WANTED, true));
            e.putBoolean(KEY_USE_ENGLISH, old.getBoolean(KEY_USE_ENGLISH, false));
            e.putBoolean(KEY_USE_COMPASS, 0 != old.getInt(KEY_USE_COMPASS, 1));
            e.putBoolean(KEY_AUTO_VISIT_TRACKABLES, old.getBoolean(KEY_AUTO_VISIT_TRACKABLES, false));
            e.putBoolean(KEY_AUTO_INSERT_SIGNATURE, old.getBoolean(KEY_AUTO_INSERT_SIGNATURE, false));
            e.putInt(KEY_ALTITUDE_CORRECTION, old.getInt(KEY_ALTITUDE_CORRECTION, 0));
            e.putBoolean(KEY_USE_GOOGLE_NAVIGATION, 0 != old.getInt(KEY_USE_GOOGLE_NAVIGATION, 1));
            e.putBoolean(KEY_STORE_LOG_IMAGES, old.getBoolean(KEY_STORE_LOG_IMAGES, false));
            e.putBoolean(KEY_EXCLUDE_DISABLED, 0 != old.getInt(KEY_EXCLUDE_DISABLED, 0));
            e.putBoolean(KEY_EXCLUDE_OWN, 0 != old.getInt(KEY_EXCLUDE_OWN, 0));
            e.putString(KEY_MAPFILE, old.getString(KEY_MAPFILE, null));
            e.putString(KEY_SIGNATURE, old.getString(KEY_SIGNATURE, null));
            e.putString(KEY_GCVOTE_PASSWORD, old.getString(KEY_GCVOTE_PASSWORD, null));
            e.putString(KEY_PASSWORD, old.getString(KEY_PASSWORD, null));
            e.putString(KEY_USERNAME, old.getString(KEY_USERNAME, null));
            e.putString(KEY_MEMBER_STATUS, old.getString(KEY_MEMBER_STATUS, ""));
            e.putInt(KEY_COORD_INPUT_FORMAT, old.getInt(KEY_COORD_INPUT_FORMAT, 0));
            e.putBoolean(KEY_LOG_OFFLINE, old.getBoolean(KEY_LOG_OFFLINE, false));
            e.putBoolean(KEY_LOAD_DIRECTION_IMG, old.getBoolean(KEY_LOAD_DIRECTION_IMG, true));
            e.putString(KEY_GC_CUSTOM_DATE, old.getString(KEY_GC_CUSTOM_DATE, null));
            e.putInt(KEY_SHOW_WAYPOINTS_THRESHOLD, old.getInt(KEY_SHOW_WAYPOINTS_THRESHOLD, 0));
            e.putString(KEY_COOKIE_STORE, old.getString(KEY_COOKIE_STORE, null));
            e.putBoolean(KEY_OPEN_LAST_DETAILS_PAGE, old.getBoolean(KEY_OPEN_LAST_DETAILS_PAGE, false));
            e.putInt(KEY_LAST_DETAILS_PAGE, old.getInt(KEY_LAST_DETAILS_PAGE, 1));
            e.putInt(KEY_DEFAULT_NAVIGATION_TOOL, old.getInt(KEY_DEFAULT_NAVIGATION_TOOL, NavigationAppsEnum.COMPASS.id));
            e.putInt(KEY_DEFAULT_NAVIGATION_TOOL_2, old.getInt(KEY_DEFAULT_NAVIGATION_TOOL_2, NavigationAppsEnum.INTERNAL_MAP.id));
            e.putInt(KEY_LIVE_MAP_STRATEGY, old.getInt(KEY_LIVE_MAP_STRATEGY, Strategy.AUTO.id));
            e.putBoolean(KEY_DEBUG, old.getBoolean(KEY_DEBUG, false));
            e.putBoolean(KEY_HIDE_LIVE_MAP_HINT, old.getInt(KEY_HIDE_LIVE_MAP_HINT, 0) != 0);
            e.putInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, old.getInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, 0));

            e.putInt(KEY_SETTINGS_VERSION, 1); // mark migrated
            e.commit();
        }
    }

    public static void setLanguage(boolean useEnglish) {
        final Configuration config = new Configuration();
        config.locale = useEnglish ? new Locale("en") : Locale.getDefault();
        final Resources resources = cgeoapplication.getInstance().getResources();
        resources.updateConfiguration(config, resources.getDisplayMetrics());
    }

    public static boolean isLogin() {
        final String preUsername = sharedPrefs.getString(KEY_USERNAME, null);
        final String prePassword = sharedPrefs.getString(KEY_PASSWORD, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    /**
     * Get login and password information.
     *
     * @return a pair (login, password) or null if no valid information is stored
     */
    public static ImmutablePair<String, String> getLogin() {
        if (username == null || password == null) {
            final String preUsername = sharedPrefs.getString(KEY_USERNAME, null);
            final String prePassword = sharedPrefs.getString(KEY_PASSWORD, null);

            if (preUsername == null || prePassword == null) {
                return null;
            }

            username = preUsername;
            password = prePassword;
        }
        return new ImmutablePair<String, String>(username, password);
    }

    public static String getUsername() {
        return username != null ? username : sharedPrefs.getString(KEY_USERNAME, null);
    }

    public static boolean setLogin(final String username, final String password) {
        Settings.username = username;
        Settings.password = password;
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
                    // erase username and password
                    edit.remove(KEY_USERNAME);
                    edit.remove(KEY_PASSWORD);
                } else {
                    // save username and password
                    edit.putString(KEY_USERNAME, username);
                    edit.putString(KEY_PASSWORD, password);
                }
            }
        });
    }

    public static boolean isPremiumMember() {
        // Basic Member, Premium Member, ???
        String memberStatus = Settings.getMemberStatus();
        if (memberStatus == null) {
            return false;
        }
        return GCConstants.MEMBER_STATUS_PM.equalsIgnoreCase(memberStatus);
    }

    public static String getMemberStatus() {
        return sharedPrefs.getString(KEY_MEMBER_STATUS, "");
    }

    public static boolean setMemberStatus(final String memberStatus) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(memberStatus)) {
                    edit.remove(KEY_MEMBER_STATUS);
                } else {
                    edit.putString(KEY_MEMBER_STATUS, memberStatus);
                }
            }
        });
    }

    public static boolean isGCvoteLogin() {
        final String preUsername = sharedPrefs.getString(KEY_USERNAME, null);
        final String prePassword = sharedPrefs.getString(KEY_GCVOTE_PASSWORD, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    public static boolean setGCvoteLogin(final String password) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(password)) {
                    // erase password
                    edit.remove(KEY_GCVOTE_PASSWORD);
                } else {
                    // save password
                    edit.putString(KEY_GCVOTE_PASSWORD, password);
                }
            }
        });
    }

    public static ImmutablePair<String, String> getGCvoteLogin() {
        final String username = sharedPrefs.getString(KEY_USERNAME, null);
        final String password = sharedPrefs.getString(KEY_GCVOTE_PASSWORD, null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return null;
        }

        return new ImmutablePair<String, String>(username, password);
    }

    public static boolean setSignature(final String signature) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(signature)) {
                    // erase signature
                    edit.remove(KEY_SIGNATURE);
                } else {
                    // save signature
                    edit.putString(KEY_SIGNATURE, signature);
                }
            }
        });
    }

    public static String getSignature() {
        return sharedPrefs.getString(KEY_SIGNATURE, null);
    }

    public static boolean setCookieStore(final String cookies) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(final Editor edit) {
                if (StringUtils.isBlank(cookies)) {
                    // erase cookies
                    edit.remove(KEY_COOKIE_STORE);
                } else {
                    // save cookies
                    edit.putString(KEY_COOKIE_STORE, cookies);
                }
            }
        });
    }

    public static String getCookieStore() {
        return sharedPrefs.getString(KEY_COOKIE_STORE, null);
    }

    /**
     * @param cacheType
     *            The cache type used for future filtering
     */
    public static void setCacheType(final CacheType cacheType) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                if (cacheType == null) {
                    edit.remove(KEY_CACHE_TYPE);
                } else {
                    edit.putString(KEY_CACHE_TYPE, cacheType.id);
                }
            }
        });
    }

    public static void setLiveMap(final boolean live) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_MAP_LIVE, live);
            }
        });
    }

    public static int getLastList() {
        return sharedPrefs.getInt(KEY_LAST_USED_LIST, StoredList.STANDARD_LIST_ID);
    }

    public static void saveLastList(final int listId) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_USED_LIST, listId);
            }
        });
    }

    public static void setWebNameCode(final String name, final String code) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {

                edit.putString(KEY_WEBDEVICE_NAME, name);
                edit.putString(KEY_WEB_DEVICE_CODE, code);
            }
        });
    }

    public static MapProvider getMapProvider() {
        if (mapProvider == null) {
            mapProvider = getMapSource().getMapProvider();
        }
        return mapProvider;
    }

    public static String getMapFile() {
        return sharedPrefs.getString(KEY_MAPFILE, null);
    }

    public static boolean setMapFile(final String mapFile) {
        boolean result = editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_MAPFILE, mapFile);
            }
        });
        if (mapFile != null) {
            setMapFileDirectory(new File(mapFile).getParent());
        }
        return result;
    }

    public static String getMapFileDirectory() {
        final String mapDir = sharedPrefs.getString(KEY_MAP_DIRECTORY, null);
        if (mapDir != null) {
            return mapDir;
        }
        final String mapFile = getMapFile();
        if (mapFile != null) {
            return new File(mapFile).getParent();
        }
        return null;
    }

    public static boolean setMapFileDirectory(final String mapFileDirectory) {
        return editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_MAP_DIRECTORY, mapFileDirectory);
                MapsforgeMapProvider.getInstance().updateOfflineMaps();
            }
        });
    }

    public static boolean isValidMapFile() {
        return isValidMapFile(getMapFile());
    }

    public static boolean isValidMapFile(final String mapFileIn) {
        return MapsforgeMapProvider.isValidMapFile(mapFileIn);
    }

    public static coordInputFormatEnum getCoordInputFormat() {
        return coordInputFormatEnum.fromInt(sharedPrefs.getInt(KEY_COORD_INPUT_FORMAT, 0));
    }

    public static void setCoordInputFormat(final coordInputFormatEnum format) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_COORD_INPUT_FORMAT, format.ordinal());
            }
        });
    }

    static void setLogOffline(final boolean offline) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LOG_OFFLINE, offline);
            }
        });
    }

    public static boolean getLogOffline() {
        return sharedPrefs.getBoolean(KEY_LOG_OFFLINE, false);
    }

    static void setLoadDirImg(final boolean value) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LOAD_DIRECTION_IMG, value);
            }
        });
    }

    public static boolean getLoadDirImg() {
        return !isPremiumMember() && sharedPrefs.getBoolean(KEY_LOAD_DIRECTION_IMG, true);
    }

    public static void setGcCustomDate(final String format) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_GC_CUSTOM_DATE, format);
            }
        });
    }

    /**
     * @return User selected date format on GC.com
     * @see Login#gcCustomDateFormats
     */
    public static String getGcCustomDate() {
        return sharedPrefs.getString(KEY_GC_CUSTOM_DATE, null);
    }

    public static boolean isExcludeMyCaches() {
        return sharedPrefs.getBoolean(KEY_EXCLUDE_OWN, false);
    }

    /**
     * edit some settings without knowing how to get the settings editor or how to commit
     *
     * @param runnable
     * @return
     */
    private static boolean editSharedSettings(final PrefRunnable runnable) {
        final SharedPreferences.Editor prefsEdit = sharedPrefs.edit();
        runnable.edit(prefsEdit);
        return prefsEdit.commit();
    }

    public static void setExcludeMine(final boolean exclude) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_EXCLUDE_OWN, exclude);
            }
        });
    }

    public static void setUseEnglish(final boolean english) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_ENGLISH, english);
                setLanguage(english);
            }
        });
    }

    public static boolean isUseEnglish() {
        return sharedPrefs.getBoolean(KEY_USE_ENGLISH, false);
    }

    public static boolean isShowAddress() {
        return sharedPrefs.getBoolean(KEY_SHOW_ADDRESS, true);
    }

    public static void setShowAddress(final boolean showAddress) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SHOW_ADDRESS, showAddress);
            }
        });
    }

    public static boolean isShowCaptcha() {
        return !isPremiumMember() && sharedPrefs.getBoolean(KEY_SHOW_CAPTCHA, false);
    }

    public static void setShowCaptcha(final boolean showCaptcha) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SHOW_CAPTCHA, showCaptcha);
            }
        });
    }

    public static boolean isExcludeDisabledCaches() {
        return sharedPrefs.getBoolean(KEY_EXCLUDE_DISABLED, false);
    }

    public static void setExcludeDisabledCaches(final boolean exclude) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_EXCLUDE_DISABLED, exclude);
            }
        });
    }

    public static boolean isStoreOfflineMaps() {
        return sharedPrefs.getBoolean(KEY_USE_OFFLINEMAPS, true);
    }

    public static void setStoreOfflineMaps(final boolean offlineMaps) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_OFFLINEMAPS, offlineMaps);
            }
        });
    }

    public static boolean isStoreOfflineWpMaps() {
        return sharedPrefs.getBoolean(KEY_USE_OFFLINEWPMAPS, false);
    }

    public static void setStoreOfflineWpMaps(final boolean offlineMaps) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_OFFLINEWPMAPS, offlineMaps);
            }
        });
    }

    public static boolean isStoreLogImages() {
        return sharedPrefs.getBoolean(KEY_STORE_LOG_IMAGES, false);
    }

    public static void setStoreLogImages(final boolean storeLogImages) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_STORE_LOG_IMAGES, storeLogImages);
            }
        });
    }

    public static boolean isUseGoogleNavigation() {
        return sharedPrefs.getBoolean(KEY_USE_GOOGLE_NAVIGATION, true);
    }

    public static void setUseGoogleNavigation(final boolean useGoogleNavigation) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_GOOGLE_NAVIGATION, useGoogleNavigation);
            }
        });
    }

    public static boolean isAutoLoadDescription() {
        return sharedPrefs.getBoolean(KEY_LOAD_DESCRIPTION, false);
    }

    public static void setAutoLoadDesc(final boolean autoLoad) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LOAD_DESCRIPTION, autoLoad);
            }
        });
    }

    public static boolean isRatingWanted() {
        return sharedPrefs.getBoolean(KEY_RATING_WANTED, true);
    }

    public static void setRatingWanted(final boolean ratingWanted) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_RATING_WANTED, ratingWanted);
            }
        });
    }

    public static boolean isElevationWanted() {
        return sharedPrefs.getBoolean(KEY_ELEVATION_WANTED, true);
    }

    public static void setElevationWanted(final boolean elevationWanted) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_ELEVATION_WANTED, elevationWanted);
            }
        });
    }

    public static boolean isFriendLogsWanted() {
        if (!isLogin()) {
            // don't show a friends log if the user is anonymous
            return false;
        }
        return sharedPrefs.getBoolean(KEY_FRIENDLOGS_WANTED, true);
    }

    public static void setFriendLogsWanted(final boolean friendLogsWanted) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_FRIENDLOGS_WANTED, friendLogsWanted);
            }
        });
    }

    public static boolean isLiveList() {
        return sharedPrefs.getBoolean(KEY_LIVE_LIST, true);
    }

    public static void setLiveList(final boolean liveList) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LIVE_LIST, liveList);
            }
        });
    }

    public static boolean isTrackableAutoVisit() {
        return sharedPrefs.getBoolean(KEY_AUTO_VISIT_TRACKABLES, false);
    }

    public static void setTrackableAutoVisit(final boolean autoVisit) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_AUTO_VISIT_TRACKABLES, autoVisit);
            }
        });
    }

    public static boolean isAutoInsertSignature() {
        return sharedPrefs.getBoolean(KEY_AUTO_INSERT_SIGNATURE, false);
    }

    public static void setAutoInsertSignature(final boolean autoInsert) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_AUTO_INSERT_SIGNATURE, autoInsert);
            }
        });
    }

    public static boolean isUseMetricUnits() {
        return sharedPrefs.getBoolean(KEY_METRIC_UNITS, true);
    }

    public static void setUseMetricUnits(final boolean metric) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_METRIC_UNITS, metric);
            }
        });
    }

    public static boolean isLiveMap() {
        return sharedPrefs.getBoolean(KEY_MAP_LIVE, true);
    }

    public static boolean isMapTrail() {
        return sharedPrefs.getBoolean(KEY_MAP_TRAIL, true);
    }

    public static void setMapTrail(final boolean showTrail) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_MAP_TRAIL, showTrail);
            }
        });
    }

    public static int getMapZoom() {
        return sharedPrefs.getInt(KEY_LAST_MAP_ZOOM, 14);
    }

    public static void setMapZoom(final int mapZoomLevel) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_MAP_ZOOM, mapZoomLevel);
            }
        });
    }

    public static GeoPointImpl getMapCenter() {
        return getMapProvider().getMapItemFactory()
                .getGeoPointBase(new Geopoint(sharedPrefs.getInt(KEY_LAST_MAP_LAT, 0) / 1e6,
                        sharedPrefs.getInt(KEY_LAST_MAP_LON, 0) / 1e6));
    }

    public static void setMapCenter(final GeoPointImpl mapViewCenter) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_MAP_LAT, mapViewCenter.getLatitudeE6());
                edit.putInt(KEY_LAST_MAP_LON, mapViewCenter.getLongitudeE6());
            }
        });
    }

    public static MapSource getMapSource() {
        final int id = getConvertedMapId();
        final MapSource map = MapProviderFactory.getMapSource(id);
        if (map != null) {
            // don't use offline maps if the map file is not valid
            if ((!(map instanceof OfflineMapSource)) || (isValidMapFile())) {
                return map;
            }
        }
        // fallback to first available map
        return MapProviderFactory.getDefaultSource();
    }

    private final static int GOOGLEMAP_BASEID = 30;
    private final static int MAP = 1;
    private final static int SATELLITE = 2;

    private final static int MFMAP_BASEID = 40;
    private final static int MAPNIK = 1;
    private final static int CYCLEMAP = 3;
    private final static int OFFLINE = 4;

    /**
     * convert old preference ids for maps (based on constant values) into new hash based ids
     *
     * @return
     */
    private static int getConvertedMapId() {
        final int id = sharedPrefs.getInt(KEY_MAP_SOURCE, 0);
        switch (id) {
            case GOOGLEMAP_BASEID + MAP:
                return GoogleMapProvider.GOOGLE_MAP_ID.hashCode();
            case GOOGLEMAP_BASEID + SATELLITE:
                return GoogleMapProvider.GOOGLE_SATELLITE_ID.hashCode();
            case MFMAP_BASEID + MAPNIK:
                return MapsforgeMapProvider.MAPSFORGE_MAPNIK_ID.hashCode();
            case MFMAP_BASEID + CYCLEMAP:
                return MapsforgeMapProvider.MAPSFORGE_CYCLEMAP_ID.hashCode();
            case MFMAP_BASEID + OFFLINE: {
                final String mapFile = Settings.getMapFile();
                if (StringUtils.isNotEmpty(mapFile)) {
                    return mapFile.hashCode();
                }
                break;
            }
            default:
                break;
        }
        return id;
    }

    public static void setMapSource(final MapSource newMapSource) {
        if (!MapProviderFactory.isSameActivity(getMapSource(), newMapSource)) {
            mapProvider = null;
        }
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_MAP_SOURCE, newMapSource.getNumericalId());
            }
        });
        if (newMapSource instanceof OfflineMapSource) {
            setMapFile(((OfflineMapSource) newMapSource).getFileName());
        }
    }

    public static void setAnyCoordinates(final Geopoint coords) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (null != coords) {
                    edit.putFloat(KEY_ANYLATITUDE, (float) coords.getLatitude());
                    edit.putFloat(KEY_ANYLONGITUDE, (float) coords.getLongitude());
                } else {
                    edit.remove(KEY_ANYLATITUDE);
                    edit.remove(KEY_ANYLONGITUDE);
                }
            }
        });

    }

    public static Geopoint getAnyCoordinates() {
        if (sharedPrefs.contains(KEY_ANYLATITUDE) && sharedPrefs.contains(KEY_ANYLONGITUDE)) {
            float lat = sharedPrefs.getFloat(KEY_ANYLATITUDE, 0);
            float lon = sharedPrefs.getFloat(KEY_ANYLONGITUDE, 0);
            return new Geopoint(lat, lon);
        }
        return null;
    }

    public static boolean isUseCompass() {
        return sharedPrefs.getBoolean(KEY_USE_COMPASS, true);
    }

    public static void setUseCompass(final boolean useCompass) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_COMPASS, useCompass);
            }
        });
    }

    public static boolean isHelpShown() {
        return sharedPrefs.getBoolean(KEY_HELP_SHOWN, false);
    }

    public static void setHelpShown() {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_HELP_SHOWN, true);
            }
        });
    }

    public static boolean isLightSkin() {
        return sharedPrefs.getBoolean(KEY_SKIN, false);
    }

    public static void setLightSkin(final boolean lightSkin) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SKIN, lightSkin);
            }
        });
    }

    public static String getKeyConsumerPublic() {
        return keyConsumerPublic;
    }

    public static String getKeyConsumerSecret() {
        return keyConsumerSecret;
    }

    public static int getAltCorrection() {
        return sharedPrefs.getInt(KEY_ALTITUDE_CORRECTION, 0);
    }

    public static boolean setAltCorrection(final int altitude) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_ALTITUDE_CORRECTION, altitude);
            }
        });
    }

    public static String getWebDeviceCode() {
        return sharedPrefs.getString(KEY_WEB_DEVICE_CODE, null);
    }

    public static String getWebDeviceName() {
        return sharedPrefs.getString(KEY_WEBDEVICE_NAME, null);
    }

    /**
     * @return The cache type used for filtering or ALL if no filter is active. Returns never null
     */
    public static CacheType getCacheType() {
        return CacheType.getById(sharedPrefs.getString(KEY_CACHE_TYPE, CacheType.ALL.id));
    }

    /**
     * The Threshold for the showing of child waypoints
     *
     * @return
     */

    public static int getWayPointsThreshold() {
        return sharedPrefs.getInt(KEY_SHOW_WAYPOINTS_THRESHOLD, 0);
    }

    public static void setShowWaypointsThreshold(final int threshold) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_SHOW_WAYPOINTS_THRESHOLD, threshold);
            }
        });
    }

    public static boolean isUseTwitter() {
        return sharedPrefs.getBoolean(KEY_USE_TWITTER, false);
    }

    public static void setUseTwitter(final boolean useTwitter) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_TWITTER, useTwitter);
            }
        });
    }

    public static boolean isTwitterLoginValid() {
        return !StringUtils.isBlank(getTokenPublic()) && !StringUtils.isBlank(getTokenSecret());
    }

    public static String getTokenPublic() {
        return sharedPrefs.getString(KEY_TWITTER_TOKEN_PUBLIC, null);
    }

    public static String getTokenSecret() {
        return sharedPrefs.getString(KEY_TWITTER_TOKEN_SECRET, null);

    }

    public static int getVersion() {
        return sharedPrefs.getInt(KEY_VERSION, 0);
    }

    public static void setTwitterTokens(final String tokenPublic, final String tokenSecret, boolean enableTwitter) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_TWITTER_TOKEN_PUBLIC, tokenPublic);
                edit.putString(KEY_TWITTER_TOKEN_SECRET, tokenSecret);
                if (tokenPublic != null) {
                    edit.remove(KEY_TEMP_TOKEN_PUBLIC);
                    edit.remove(KEY_TEMP_TOKEN_SECRET);
                }
            }
        });
        setUseTwitter(enableTwitter);
    }

    public static void setTwitterTempTokens(final String tokenPublic, final String tokenSecret) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_TEMP_TOKEN_PUBLIC, tokenPublic);
                edit.putString(KEY_TEMP_TOKEN_SECRET, tokenSecret);
            }
        });
    }

    public static ImmutablePair<String, String> getTempToken() {
        String tokenPublic = sharedPrefs.getString(KEY_TEMP_TOKEN_PUBLIC, null);
        String tokenSecret = sharedPrefs.getString(KEY_TEMP_TOKEN_SECRET, null);
        return new ImmutablePair<String, String>(tokenPublic, tokenSecret);
    }

    public static void setVersion(final int version) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_VERSION, version);
            }
        });
    }

    public static boolean isOpenLastDetailsPage() {
        return sharedPrefs.getBoolean(KEY_OPEN_LAST_DETAILS_PAGE, false);
    }

    public static void setOpenLastDetailsPage(final boolean openLastPage) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_OPEN_LAST_DETAILS_PAGE, openLastPage);
            }
        });
    }

    public static int getLastDetailsPage() {
        return sharedPrefs.getInt(KEY_LAST_DETAILS_PAGE, 1);
    }

    public static void setLastDetailsPage(final int index) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_DETAILS_PAGE, index);
            }
        });
    }

    public static int getDefaultNavigationTool() {
        return sharedPrefs.getInt(KEY_DEFAULT_NAVIGATION_TOOL, NavigationAppsEnum.COMPASS.id);
    }

    public static void setDefaultNavigationTool(final int defaultNavigationTool) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_DEFAULT_NAVIGATION_TOOL, defaultNavigationTool);
            }
        });
    }

    public static int getDefaultNavigationTool2() {
        return sharedPrefs.getInt(KEY_DEFAULT_NAVIGATION_TOOL_2, NavigationAppsEnum.INTERNAL_MAP.id);
    }

    public static void setDefaultNavigationTool2(final int defaultNavigationTool) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_DEFAULT_NAVIGATION_TOOL_2, defaultNavigationTool);
            }
        });
    }

    public static Strategy getLiveMapStrategy() {
        return Strategy.getById(sharedPrefs.getInt(KEY_LIVE_MAP_STRATEGY, Strategy.AUTO.id));
    }

    public static void setLiveMapStrategy(final Strategy strategy) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LIVE_MAP_STRATEGY, strategy.id);
            }
        });
    }

    public static boolean isDebug() {
        return Log.isDebug();
    }

    public static void setDebug(final boolean debug) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_DEBUG, debug);
            }
        });
        Log.setDebugUnsaved(debug);
    }

    public static boolean getHideLiveMapHint() {
        return sharedPrefs.getBoolean(KEY_HIDE_LIVE_MAP_HINT, false);
    }

    public static void setHideLiveHint(final boolean hide) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_HIDE_LIVE_MAP_HINT, hide);
            }
        });
    }

    public static int getLiveMapHintShowCount() {
        return sharedPrefs.getInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, 0);
    }

    public static void setLiveMapHintShowCount(final int showCount) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, showCount);
            }
        });
    }

    public static boolean isDbOnSDCard() {
        return sharedPrefs.getBoolean(KEY_DB_ON_SDCARD, false);
    }

    public static void setDbOnSDCard(final boolean dbOnSDCard) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_DB_ON_SDCARD, dbOnSDCard);
            }
        });
    }

    public static String getGpxExportDir() {
        return sharedPrefs.getString(KEY_GPX_EXPORT_DIR, Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static void setGpxExportDir(final String gpxExportDir) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_GPX_EXPORT_DIR, gpxExportDir);
            }
        });
    }

    public static String getGpxImportDir() {
        return sharedPrefs.getString(KEY_GPX_IMPORT_DIR, Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static void setGpxImportDir(final String gpxImportDir) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_GPX_IMPORT_DIR, gpxImportDir);
            }
        });
    }

    public static boolean getShareAfterExport() {
        return sharedPrefs.getBoolean(KEY_SHARE_AFTER_EXPORT, true);
    }

    public static void setShareAfterExport(final boolean shareAfterExport) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SHARE_AFTER_EXPORT, shareAfterExport);
            }
        });
    }

    public static int getTrackableAction() {
        return sharedPrefs.getInt(KEY_LAST_TRACKABLE_ACTION, LogType.RETRIEVED_IT.id);
    }

    public static void setTrackableAction(final int trackableAction) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_TRACKABLE_ACTION, trackableAction);
            }
        });
    }

    public static String getCustomRenderThemeBaseFolder() {
        return sharedPrefs.getString(KEY_RENDER_THEME_BASE_FOLDER, "");
    }

    public static boolean setCustomRenderThemeBaseFolder(final String customRenderThemeBaseFolder) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_RENDER_THEME_BASE_FOLDER, customRenderThemeBaseFolder);
            }
        });
    }

    public static String getCustomRenderThemeFilePath() {
        return sharedPrefs.getString(KEY_RENDER_THEME_FILE_PATH, "");
    }

    public static void setCustomRenderThemeFile(final String customRenderThemeFile) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_RENDER_THEME_FILE_PATH, customRenderThemeFile);
            }
        });
    }

    public static File[] getMapThemeFiles() {

        File directory = new File(Settings.getCustomRenderThemeBaseFolder());

        List<File> result = new ArrayList<File>();

        FileUtils.listDir(result, directory, new ExtensionsBasedFileSelector(new String[] { "xml" }), null);

        return result.toArray(new File[] {});
    }

    private static class ExtensionsBasedFileSelector extends FileSelector {

        private final String[] extensions;

        public ExtensionsBasedFileSelector(String[] extensions) {
            this.extensions = extensions;
        }

        @Override
        public boolean isSelected(File file) {
            String filename = file.getName();
            for (String ext : extensions) {
                if (StringUtils.endsWithIgnoreCase(filename, ext)) {
                    return true;
                }
            }
            return false;
        }

        @Override
        public boolean shouldEnd() {
            return false;
        }
    }

    public static String getPreferencesName() {
        // There is currently no Android API to get the file name of the shared preferences. Let's hardcode
        // it without needing a cgeoapplication instance.
        return "cgeo.geocaching_preferences";
    }

    public static boolean getPlainLogs() {
        return sharedPrefs.getBoolean(KEY_PLAIN_LOGS, false);
    }

    public static void setPlainLogs(final boolean plainLogs) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_PLAIN_LOGS, plainLogs);
            }
        });
    }

    public static boolean getUseNativeUa() {
        return sharedPrefs.getBoolean(KEY_NATIVE_UA, false);
    }

    public static void setUseNativeUa(final boolean useNativeUa) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_NATIVE_UA, useNativeUa);
            }
        });
    }
}
!@#$%
20190527_000909,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_b07016
package cgeo.geocaching;

import cgeo.geocaching.apps.cache.navi.NavigationAppFactory.NavigationAppsEnum;
import cgeo.geocaching.connector.gc.GCConstants;
import cgeo.geocaching.connector.gc.Login;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.LiveMapStrategy.Strategy;
import cgeo.geocaching.enumerations.LogType;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.maps.MapProviderFactory;
import cgeo.geocaching.maps.google.GoogleMapProvider;
import cgeo.geocaching.maps.interfaces.GeoPointImpl;
import cgeo.geocaching.maps.interfaces.MapProvider;
import cgeo.geocaching.maps.interfaces.MapSource;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider.OfflineMapSource;
import cgeo.geocaching.utils.CryptUtils;
import cgeo.geocaching.utils.FileUtils;
import cgeo.geocaching.utils.FileUtils.FileSelector;
import cgeo.geocaching.utils.Log;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.os.Environment;
import android.preference.PreferenceManager;

import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

/**
 * General c:geo preferences/settings set by the user
 */
public final class Settings {

    private static final String KEY_TEMP_TOKEN_SECRET = "temp-token-secret";
    private static final String KEY_TEMP_TOKEN_PUBLIC = "temp-token-public";
    private static final String KEY_HELP_SHOWN = "helper";
    private static final String KEY_ANYLONGITUDE = "anylongitude";
    private static final String KEY_ANYLATITUDE = "anylatitude";
    private static final String KEY_USE_OFFLINEMAPS = "offlinemaps";
    private static final String KEY_USE_OFFLINEWPMAPS = "offlinewpmaps";
    private static final String KEY_WEB_DEVICE_CODE = "webDeviceCode";
    private static final String KEY_WEBDEVICE_NAME = "webDeviceName";
    private static final String KEY_MAP_LIVE = "maplive";
    private static final String KEY_MAP_SOURCE = "mapsource";
    private static final String KEY_USE_TWITTER = "twitter";
    private static final String KEY_SHOW_ADDRESS = "showaddress";
    private static final String KEY_SHOW_CAPTCHA = "showcaptcha";
    private static final String KEY_MAP_TRAIL = "maptrail";
    private static final String KEY_LAST_MAP_ZOOM = "mapzoom";
    private static final String KEY_LAST_MAP_LAT = "maplat";
    private static final String KEY_LAST_MAP_LON = "maplon";
    private static final String KEY_LIVE_LIST = "livelist";
    private static final String KEY_METRIC_UNITS = "units";
    private static final String KEY_SKIN = "skin";
    private static final String KEY_LAST_USED_LIST = "lastlist";
    private static final String KEY_CACHE_TYPE = "cachetype";
    private static final String KEY_TWITTER_TOKEN_SECRET = "tokensecret";
    private static final String KEY_TWITTER_TOKEN_PUBLIC = "tokenpublic";
    private static final String KEY_VERSION = "version";
    private static final String KEY_LOAD_DESCRIPTION = "autoloaddesc";
    private static final String KEY_RATING_WANTED = "ratingwanted";
    private static final String KEY_ELEVATION_WANTED = "elevationwanted";
    private static final String KEY_FRIENDLOGS_WANTED = "friendlogswanted";
    private static final String KEY_USE_ENGLISH = "useenglish";
    private static final String KEY_USE_COMPASS = "usecompass";
    private static final String KEY_AUTO_VISIT_TRACKABLES = "trackautovisit";
    private static final String KEY_AUTO_INSERT_SIGNATURE = "sigautoinsert";
    private static final String KEY_ALTITUDE_CORRECTION = "altcorrection";
    private static final String KEY_STORE_LOG_IMAGES = "logimages";
    private static final String KEY_EXCLUDE_DISABLED = "excludedisabled";
    private static final String KEY_EXCLUDE_OWN = "excludemine";
    private static final String KEY_MAPFILE = "mfmapfile";
    private static final String KEY_SIGNATURE = "signature";
    private static final String KEY_GCVOTE_PASSWORD = "pass-vote";
    private static final String KEY_PASSWORD = "password";
    private static final String KEY_USERNAME = "username";
    private static final String KEY_MEMBER_STATUS = "memberstatus";
    private static final String KEY_COORD_INPUT_FORMAT = "coordinputformat";
    private static final String KEY_LOG_OFFLINE = "log_offline";
    private static final String KEY_LOAD_DIRECTION_IMG = "loaddirectionimg";
    private static final String KEY_GC_CUSTOM_DATE = "gccustomdate";
    private static final String KEY_SHOW_WAYPOINTS_THRESHOLD = "gcshowwaypointsthreshold";
    private static final String KEY_COOKIE_STORE = "cookiestore";
    private static final String KEY_OPEN_LAST_DETAILS_PAGE = "opendetailslastpage";
    private static final String KEY_LAST_DETAILS_PAGE = "lastdetailspage";
    private static final String KEY_DEFAULT_NAVIGATION_TOOL = "defaultNavigationTool";
    private static final String KEY_DEFAULT_NAVIGATION_TOOL_2 = "defaultNavigationTool2";
    private static final String KEY_LIVE_MAP_STRATEGY = "livemapstrategy";
    private static final String KEY_DEBUG = "debug";
    private static final String KEY_HIDE_LIVE_MAP_HINT = "hidelivemaphint";
    private static final String KEY_LIVE_MAP_HINT_SHOW_COUNT = "livemaphintshowcount";
    private static final String KEY_SETTINGS_VERSION = "settingsversion";
    private static final String KEY_DB_ON_SDCARD = "dbonsdcard";
    private static final String KEY_LAST_TRACKABLE_ACTION = "trackableaction";
    private static final String KEY_SHARE_AFTER_EXPORT = "shareafterexport";
    private static final String KEY_GPX_EXPORT_DIR = "gpxExportDir";
    private static final String KEY_RENDER_THEME_BASE_FOLDER = "renderthemepath";
    private static final String KEY_RENDER_THEME_FILE_PATH = "renderthemefile";
    private static final String KEY_GPX_IMPORT_DIR = "gpxImportDir";
    private static final String KEY_PLAIN_LOGS = "plainLogs";
    private static final String KEY_NATIVE_UA = "nativeUa";
    private static final String KEY_MAP_DIRECTORY = "mapDirectory";

    private final static int unitsMetric = 1;

    // twitter api keys
    private final static String keyConsumerPublic = CryptUtils.rot13("ESnsCvAv3kEupF1GCR3jGj");
    private final static String keyConsumerSecret = CryptUtils.rot13("7vQWceACV9umEjJucmlpFe9FCMZSeqIqfkQ2BnhV9x");

    private interface PrefRunnable {
        void edit(final Editor edit);
    }

    public enum coordInputFormatEnum {
        Plain,
        Deg,
        Min,
        Sec;

        static coordInputFormatEnum fromInt(int id) {
            final coordInputFormatEnum[] values = coordInputFormatEnum.values();
            if (id < 0 || id >= values.length) {
                return Min;
            }
            return values[id];
        }
    }

    private static String username = null;
    private static String password = null;

    private static final SharedPreferences sharedPrefs = PreferenceManager.getDefaultSharedPreferences(cgeoapplication.getInstance().getBaseContext());
    static {
        migrateSettings();
        Log.setDebugUnsaved(sharedPrefs.getBoolean(KEY_DEBUG, false));
    }

    // maps
    private static MapProvider mapProvider = null;

    private Settings() {
        // this class is not to be instantiated;
    }

    private static void migrateSettings() {
        // migrate from non standard file location and integer based boolean types
        if (sharedPrefs.getInt(KEY_SETTINGS_VERSION, 0) < 1) {
            final String oldPreferencesName = "cgeo.pref";
            final SharedPreferences old = cgeoapplication.getInstance().getSharedPreferences(oldPreferencesName, Context.MODE_PRIVATE);
            final Editor e = sharedPrefs.edit();

            e.putString(KEY_TEMP_TOKEN_SECRET, old.getString(KEY_TEMP_TOKEN_SECRET, null));
            e.putString(KEY_TEMP_TOKEN_PUBLIC, old.getString(KEY_TEMP_TOKEN_PUBLIC, null));
            e.putBoolean(KEY_HELP_SHOWN, old.getInt(KEY_HELP_SHOWN, 0) != 0);
            e.putFloat(KEY_ANYLONGITUDE, old.getFloat(KEY_ANYLONGITUDE, 0));
            e.putFloat(KEY_ANYLATITUDE, old.getFloat(KEY_ANYLATITUDE, 0));
            e.putBoolean(KEY_USE_OFFLINEMAPS, 0 != old.getInt(KEY_USE_OFFLINEMAPS, 1));
            e.putBoolean(KEY_USE_OFFLINEWPMAPS, 0 != old.getInt(KEY_USE_OFFLINEWPMAPS, 0));
            e.putString(KEY_WEB_DEVICE_CODE, old.getString(KEY_WEB_DEVICE_CODE, null));
            e.putString(KEY_WEBDEVICE_NAME, old.getString(KEY_WEBDEVICE_NAME, null));
            e.putBoolean(KEY_MAP_LIVE, old.getInt(KEY_MAP_LIVE, 1) != 0);
            e.putInt(KEY_MAP_SOURCE, old.getInt(KEY_MAP_SOURCE, 0));
            e.putBoolean(KEY_USE_TWITTER, 0 != old.getInt(KEY_USE_TWITTER, 0));
            e.putBoolean(KEY_SHOW_ADDRESS, 0 != old.getInt(KEY_SHOW_ADDRESS, 1));
            e.putBoolean(KEY_SHOW_CAPTCHA, old.getBoolean(KEY_SHOW_CAPTCHA, false));
            e.putBoolean(KEY_MAP_TRAIL, old.getInt(KEY_MAP_TRAIL, 1) != 0);
            e.putInt(KEY_LAST_MAP_ZOOM, old.getInt(KEY_LAST_MAP_ZOOM, 14));
            e.putBoolean(KEY_LIVE_LIST, 0 != old.getInt(KEY_LIVE_LIST, 1));
            e.putBoolean(KEY_METRIC_UNITS, old.getInt(KEY_METRIC_UNITS, unitsMetric) == unitsMetric);
            e.putBoolean(KEY_SKIN, old.getInt(KEY_SKIN, 0) != 0);
            e.putInt(KEY_LAST_USED_LIST, old.getInt(KEY_LAST_USED_LIST, StoredList.STANDARD_LIST_ID));
            e.putString(KEY_CACHE_TYPE, old.getString(KEY_CACHE_TYPE, CacheType.ALL.id));
            e.putString(KEY_TWITTER_TOKEN_SECRET, old.getString(KEY_TWITTER_TOKEN_SECRET, null));
            e.putString(KEY_TWITTER_TOKEN_PUBLIC, old.getString(KEY_TWITTER_TOKEN_PUBLIC, null));
            e.putInt(KEY_VERSION, old.getInt(KEY_VERSION, 0));
            e.putBoolean(KEY_LOAD_DESCRIPTION, 0 != old.getInt(KEY_LOAD_DESCRIPTION, 0));
            e.putBoolean(KEY_RATING_WANTED, old.getBoolean(KEY_RATING_WANTED, true));
            e.putBoolean(KEY_ELEVATION_WANTED, old.getBoolean(KEY_ELEVATION_WANTED, true));
            e.putBoolean(KEY_FRIENDLOGS_WANTED, old.getBoolean(KEY_FRIENDLOGS_WANTED, true));
            e.putBoolean(KEY_USE_ENGLISH, old.getBoolean(KEY_USE_ENGLISH, false));
            e.putBoolean(KEY_USE_COMPASS, 0 != old.getInt(KEY_USE_COMPASS, 1));
            e.putBoolean(KEY_AUTO_VISIT_TRACKABLES, old.getBoolean(KEY_AUTO_VISIT_TRACKABLES, false));
            e.putBoolean(KEY_AUTO_INSERT_SIGNATURE, old.getBoolean(KEY_AUTO_INSERT_SIGNATURE, false));
            e.putInt(KEY_ALTITUDE_CORRECTION, old.getInt(KEY_ALTITUDE_CORRECTION, 0));
            e.putBoolean(KEY_STORE_LOG_IMAGES, old.getBoolean(KEY_STORE_LOG_IMAGES, false));
            e.putBoolean(KEY_EXCLUDE_DISABLED, 0 != old.getInt(KEY_EXCLUDE_DISABLED, 0));
            e.putBoolean(KEY_EXCLUDE_OWN, 0 != old.getInt(KEY_EXCLUDE_OWN, 0));
            e.putString(KEY_MAPFILE, old.getString(KEY_MAPFILE, null));
            e.putString(KEY_SIGNATURE, old.getString(KEY_SIGNATURE, null));
            e.putString(KEY_GCVOTE_PASSWORD, old.getString(KEY_GCVOTE_PASSWORD, null));
            e.putString(KEY_PASSWORD, old.getString(KEY_PASSWORD, null));
            e.putString(KEY_USERNAME, old.getString(KEY_USERNAME, null));
            e.putString(KEY_MEMBER_STATUS, old.getString(KEY_MEMBER_STATUS, ""));
            e.putInt(KEY_COORD_INPUT_FORMAT, old.getInt(KEY_COORD_INPUT_FORMAT, 0));
            e.putBoolean(KEY_LOG_OFFLINE, old.getBoolean(KEY_LOG_OFFLINE, false));
            e.putBoolean(KEY_LOAD_DIRECTION_IMG, old.getBoolean(KEY_LOAD_DIRECTION_IMG, true));
            e.putString(KEY_GC_CUSTOM_DATE, old.getString(KEY_GC_CUSTOM_DATE, null));
            e.putInt(KEY_SHOW_WAYPOINTS_THRESHOLD, old.getInt(KEY_SHOW_WAYPOINTS_THRESHOLD, 0));
            e.putString(KEY_COOKIE_STORE, old.getString(KEY_COOKIE_STORE, null));
            e.putBoolean(KEY_OPEN_LAST_DETAILS_PAGE, old.getBoolean(KEY_OPEN_LAST_DETAILS_PAGE, false));
            e.putInt(KEY_LAST_DETAILS_PAGE, old.getInt(KEY_LAST_DETAILS_PAGE, 1));
            e.putInt(KEY_DEFAULT_NAVIGATION_TOOL, old.getInt(KEY_DEFAULT_NAVIGATION_TOOL, NavigationAppsEnum.COMPASS.id));
            e.putInt(KEY_DEFAULT_NAVIGATION_TOOL_2, old.getInt(KEY_DEFAULT_NAVIGATION_TOOL_2, NavigationAppsEnum.INTERNAL_MAP.id));
            e.putInt(KEY_LIVE_MAP_STRATEGY, old.getInt(KEY_LIVE_MAP_STRATEGY, Strategy.AUTO.id));
            e.putBoolean(KEY_DEBUG, old.getBoolean(KEY_DEBUG, false));
            e.putBoolean(KEY_HIDE_LIVE_MAP_HINT, old.getInt(KEY_HIDE_LIVE_MAP_HINT, 0) != 0);
            e.putInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, old.getInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, 0));

            e.putInt(KEY_SETTINGS_VERSION, 1); // mark migrated
            e.commit();
        }
    }

    public static void setLanguage(boolean useEnglish) {
        final Configuration config = new Configuration();
        config.locale = useEnglish ? new Locale("en") : Locale.getDefault();
        final Resources resources = cgeoapplication.getInstance().getResources();
        resources.updateConfiguration(config, resources.getDisplayMetrics());
    }

    public static boolean isLogin() {
        final String preUsername = sharedPrefs.getString(KEY_USERNAME, null);
        final String prePassword = sharedPrefs.getString(KEY_PASSWORD, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    /**
     * Get login and password information.
     *
     * @return a pair (login, password) or null if no valid information is stored
     */
    public static ImmutablePair<String, String> getLogin() {
        if (username == null || password == null) {
            final String preUsername = sharedPrefs.getString(KEY_USERNAME, null);
            final String prePassword = sharedPrefs.getString(KEY_PASSWORD, null);

            if (preUsername == null || prePassword == null) {
                return null;
            }

            username = preUsername;
            password = prePassword;
        }
        return new ImmutablePair<String, String>(username, password);
    }

    public static String getUsername() {
        return username != null ? username : sharedPrefs.getString(KEY_USERNAME, null);
    }

    public static boolean setLogin(final String username, final String password) {
        Settings.username = username;
        Settings.password = password;
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
                    // erase username and password
                    edit.remove(KEY_USERNAME);
                    edit.remove(KEY_PASSWORD);
                } else {
                    // save username and password
                    edit.putString(KEY_USERNAME, username);
                    edit.putString(KEY_PASSWORD, password);
                }
            }
        });
    }

    public static boolean isPremiumMember() {
        // Basic Member, Premium Member, ???
        String memberStatus = Settings.getMemberStatus();
        if (memberStatus == null) {
            return false;
        }
        return GCConstants.MEMBER_STATUS_PM.equalsIgnoreCase(memberStatus);
    }

    public static String getMemberStatus() {
        return sharedPrefs.getString(KEY_MEMBER_STATUS, "");
    }

    public static boolean setMemberStatus(final String memberStatus) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(memberStatus)) {
                    edit.remove(KEY_MEMBER_STATUS);
                } else {
                    edit.putString(KEY_MEMBER_STATUS, memberStatus);
                }
            }
        });
    }

    public static boolean isGCvoteLogin() {
        final String preUsername = sharedPrefs.getString(KEY_USERNAME, null);
        final String prePassword = sharedPrefs.getString(KEY_GCVOTE_PASSWORD, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    public static boolean setGCvoteLogin(final String password) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(password)) {
                    // erase password
                    edit.remove(KEY_GCVOTE_PASSWORD);
                } else {
                    // save password
                    edit.putString(KEY_GCVOTE_PASSWORD, password);
                }
            }
        });
    }

    public static ImmutablePair<String, String> getGCvoteLogin() {
        final String username = sharedPrefs.getString(KEY_USERNAME, null);
        final String password = sharedPrefs.getString(KEY_GCVOTE_PASSWORD, null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return null;
        }

        return new ImmutablePair<String, String>(username, password);
    }

    public static boolean setSignature(final String signature) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(signature)) {
                    // erase signature
                    edit.remove(KEY_SIGNATURE);
                } else {
                    // save signature
                    edit.putString(KEY_SIGNATURE, signature);
                }
            }
        });
    }

    public static String getSignature() {
        return sharedPrefs.getString(KEY_SIGNATURE, null);
    }

    public static boolean setCookieStore(final String cookies) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(final Editor edit) {
                if (StringUtils.isBlank(cookies)) {
                    // erase cookies
                    edit.remove(KEY_COOKIE_STORE);
                } else {
                    // save cookies
                    edit.putString(KEY_COOKIE_STORE, cookies);
                }
            }
        });
    }

    public static String getCookieStore() {
        return sharedPrefs.getString(KEY_COOKIE_STORE, null);
    }

    /**
     * @param cacheType
     *            The cache type used for future filtering
     */
    public static void setCacheType(final CacheType cacheType) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                if (cacheType == null) {
                    edit.remove(KEY_CACHE_TYPE);
                } else {
                    edit.putString(KEY_CACHE_TYPE, cacheType.id);
                }
            }
        });
    }

    public static void setLiveMap(final boolean live) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_MAP_LIVE, live);
            }
        });
    }

    public static int getLastList() {
        return sharedPrefs.getInt(KEY_LAST_USED_LIST, StoredList.STANDARD_LIST_ID);
    }

    public static void saveLastList(final int listId) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_USED_LIST, listId);
            }
        });
    }

    public static void setWebNameCode(final String name, final String code) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {

                edit.putString(KEY_WEBDEVICE_NAME, name);
                edit.putString(KEY_WEB_DEVICE_CODE, code);
            }
        });
    }

    public static MapProvider getMapProvider() {
        if (mapProvider == null) {
            mapProvider = getMapSource().getMapProvider();
        }
        return mapProvider;
    }

    public static String getMapFile() {
        return sharedPrefs.getString(KEY_MAPFILE, null);
    }

    public static boolean setMapFile(final String mapFile) {
        boolean result = editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_MAPFILE, mapFile);
            }
        });
        if (mapFile != null) {
            setMapFileDirectory(new File(mapFile).getParent());
        }
        return result;
    }

    public static String getMapFileDirectory() {
        final String mapDir = sharedPrefs.getString(KEY_MAP_DIRECTORY, null);
        if (mapDir != null) {
            return mapDir;
        }
        final String mapFile = getMapFile();
        if (mapFile != null) {
            return new File(mapFile).getParent();
        }
        return null;
    }

    public static boolean setMapFileDirectory(final String mapFileDirectory) {
        return editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_MAP_DIRECTORY, mapFileDirectory);
                MapsforgeMapProvider.getInstance().updateOfflineMaps();
            }
        });
    }

    public static boolean isValidMapFile() {
        return isValidMapFile(getMapFile());
    }

    public static boolean isValidMapFile(final String mapFileIn) {
        return MapsforgeMapProvider.isValidMapFile(mapFileIn);
    }

    public static coordInputFormatEnum getCoordInputFormat() {
        return coordInputFormatEnum.fromInt(sharedPrefs.getInt(KEY_COORD_INPUT_FORMAT, 0));
    }

    public static void setCoordInputFormat(final coordInputFormatEnum format) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_COORD_INPUT_FORMAT, format.ordinal());
            }
        });
    }

    static void setLogOffline(final boolean offline) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LOG_OFFLINE, offline);
            }
        });
    }

    public static boolean getLogOffline() {
        return sharedPrefs.getBoolean(KEY_LOG_OFFLINE, false);
    }

    static void setLoadDirImg(final boolean value) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LOAD_DIRECTION_IMG, value);
            }
        });
    }

    public static boolean getLoadDirImg() {
        return !isPremiumMember() && sharedPrefs.getBoolean(KEY_LOAD_DIRECTION_IMG, true);
    }

    public static void setGcCustomDate(final String format) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_GC_CUSTOM_DATE, format);
            }
        });
    }

    /**
     * @return User selected date format on GC.com
     * @see Login#gcCustomDateFormats
     */
    public static String getGcCustomDate() {
        return sharedPrefs.getString(KEY_GC_CUSTOM_DATE, null);
    }

    public static boolean isExcludeMyCaches() {
        return sharedPrefs.getBoolean(KEY_EXCLUDE_OWN, false);
    }

    /**
     * edit some settings without knowing how to get the settings editor or how to commit
     *
     * @param runnable
     * @return
     */
    private static boolean editSharedSettings(final PrefRunnable runnable) {
        final SharedPreferences.Editor prefsEdit = sharedPrefs.edit();
        runnable.edit(prefsEdit);
        return prefsEdit.commit();
    }

    public static void setExcludeMine(final boolean exclude) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_EXCLUDE_OWN, exclude);
            }
        });
    }

    public static void setUseEnglish(final boolean english) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_ENGLISH, english);
                setLanguage(english);
            }
        });
    }

    public static boolean isUseEnglish() {
        return sharedPrefs.getBoolean(KEY_USE_ENGLISH, false);
    }

    public static boolean isShowAddress() {
        return sharedPrefs.getBoolean(KEY_SHOW_ADDRESS, true);
    }

    public static void setShowAddress(final boolean showAddress) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SHOW_ADDRESS, showAddress);
            }
        });
    }

    public static boolean isShowCaptcha() {
        return !isPremiumMember() && sharedPrefs.getBoolean(KEY_SHOW_CAPTCHA, false);
    }

    public static void setShowCaptcha(final boolean showCaptcha) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SHOW_CAPTCHA, showCaptcha);
            }
        });
    }

    public static boolean isExcludeDisabledCaches() {
        return sharedPrefs.getBoolean(KEY_EXCLUDE_DISABLED, false);
    }

    public static void setExcludeDisabledCaches(final boolean exclude) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_EXCLUDE_DISABLED, exclude);
            }
        });
    }

    public static boolean isStoreOfflineMaps() {
        return sharedPrefs.getBoolean(KEY_USE_OFFLINEMAPS, true);
    }

    public static void setStoreOfflineMaps(final boolean offlineMaps) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_OFFLINEMAPS, offlineMaps);
            }
        });
    }

    public static boolean isStoreOfflineWpMaps() {
        return sharedPrefs.getBoolean(KEY_USE_OFFLINEWPMAPS, false);
    }

    public static void setStoreOfflineWpMaps(final boolean offlineMaps) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_OFFLINEWPMAPS, offlineMaps);
            }
        });
    }

    public static boolean isStoreLogImages() {
        return sharedPrefs.getBoolean(KEY_STORE_LOG_IMAGES, false);
    }

    public static void setStoreLogImages(final boolean storeLogImages) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_STORE_LOG_IMAGES, storeLogImages);
            }
        });
    }

    public static boolean isAutoLoadDescription() {
        return sharedPrefs.getBoolean(KEY_LOAD_DESCRIPTION, false);
    }

    public static void setAutoLoadDesc(final boolean autoLoad) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LOAD_DESCRIPTION, autoLoad);
            }
        });
    }

    public static boolean isRatingWanted() {
        return sharedPrefs.getBoolean(KEY_RATING_WANTED, true);
    }

    public static void setRatingWanted(final boolean ratingWanted) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_RATING_WANTED, ratingWanted);
            }
        });
    }

    public static boolean isElevationWanted() {
        return sharedPrefs.getBoolean(KEY_ELEVATION_WANTED, true);
    }

    public static void setElevationWanted(final boolean elevationWanted) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_ELEVATION_WANTED, elevationWanted);
            }
        });
    }

    public static boolean isFriendLogsWanted() {
        if (!isLogin()) {
            // don't show a friends log if the user is anonymous
            return false;
        }
        return sharedPrefs.getBoolean(KEY_FRIENDLOGS_WANTED, true);
    }

    public static void setFriendLogsWanted(final boolean friendLogsWanted) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_FRIENDLOGS_WANTED, friendLogsWanted);
            }
        });
    }

    public static boolean isLiveList() {
        return sharedPrefs.getBoolean(KEY_LIVE_LIST, true);
    }

    public static void setLiveList(final boolean liveList) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LIVE_LIST, liveList);
            }
        });
    }

    public static boolean isTrackableAutoVisit() {
        return sharedPrefs.getBoolean(KEY_AUTO_VISIT_TRACKABLES, false);
    }

    public static void setTrackableAutoVisit(final boolean autoVisit) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_AUTO_VISIT_TRACKABLES, autoVisit);
            }
        });
    }

    public static boolean isAutoInsertSignature() {
        return sharedPrefs.getBoolean(KEY_AUTO_INSERT_SIGNATURE, false);
    }

    public static void setAutoInsertSignature(final boolean autoInsert) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_AUTO_INSERT_SIGNATURE, autoInsert);
            }
        });
    }

    public static boolean isUseMetricUnits() {
        return sharedPrefs.getBoolean(KEY_METRIC_UNITS, true);
    }

    public static void setUseMetricUnits(final boolean metric) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_METRIC_UNITS, metric);
            }
        });
    }

    public static boolean isLiveMap() {
        return sharedPrefs.getBoolean(KEY_MAP_LIVE, true);
    }

    public static boolean isMapTrail() {
        return sharedPrefs.getBoolean(KEY_MAP_TRAIL, true);
    }

    public static void setMapTrail(final boolean showTrail) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_MAP_TRAIL, showTrail);
            }
        });
    }

    public static int getMapZoom() {
        return sharedPrefs.getInt(KEY_LAST_MAP_ZOOM, 14);
    }

    public static void setMapZoom(final int mapZoomLevel) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_MAP_ZOOM, mapZoomLevel);
            }
        });
    }

    public static GeoPointImpl getMapCenter() {
        return getMapProvider().getMapItemFactory()
                .getGeoPointBase(new Geopoint(sharedPrefs.getInt(KEY_LAST_MAP_LAT, 0) / 1e6,
                        sharedPrefs.getInt(KEY_LAST_MAP_LON, 0) / 1e6));
    }

    public static void setMapCenter(final GeoPointImpl mapViewCenter) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_MAP_LAT, mapViewCenter.getLatitudeE6());
                edit.putInt(KEY_LAST_MAP_LON, mapViewCenter.getLongitudeE6());
            }
        });
    }

    public static MapSource getMapSource() {
        final int id = getConvertedMapId();
        final MapSource map = MapProviderFactory.getMapSource(id);
        if (map != null) {
            // don't use offline maps if the map file is not valid
            if ((!(map instanceof OfflineMapSource)) || (isValidMapFile())) {
                return map;
            }
        }
        // fallback to first available map
        return MapProviderFactory.getDefaultSource();
    }

    private final static int GOOGLEMAP_BASEID = 30;
    private final static int MAP = 1;
    private final static int SATELLITE = 2;

    private final static int MFMAP_BASEID = 40;
    private final static int MAPNIK = 1;
    private final static int CYCLEMAP = 3;
    private final static int OFFLINE = 4;

    /**
     * convert old preference ids for maps (based on constant values) into new hash based ids
     *
     * @return
     */
    private static int getConvertedMapId() {
        final int id = sharedPrefs.getInt(KEY_MAP_SOURCE, 0);
        switch (id) {
            case GOOGLEMAP_BASEID + MAP:
                return GoogleMapProvider.GOOGLE_MAP_ID.hashCode();
            case GOOGLEMAP_BASEID + SATELLITE:
                return GoogleMapProvider.GOOGLE_SATELLITE_ID.hashCode();
            case MFMAP_BASEID + MAPNIK:
                return MapsforgeMapProvider.MAPSFORGE_MAPNIK_ID.hashCode();
            case MFMAP_BASEID + CYCLEMAP:
                return MapsforgeMapProvider.MAPSFORGE_CYCLEMAP_ID.hashCode();
            case MFMAP_BASEID + OFFLINE: {
                final String mapFile = Settings.getMapFile();
                if (StringUtils.isNotEmpty(mapFile)) {
                    return mapFile.hashCode();
                }
                break;
            }
            default:
                break;
        }
        return id;
    }

    public static void setMapSource(final MapSource newMapSource) {
        if (!MapProviderFactory.isSameActivity(getMapSource(), newMapSource)) {
            mapProvider = null;
        }
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_MAP_SOURCE, newMapSource.getNumericalId());
            }
        });
        if (newMapSource instanceof OfflineMapSource) {
            setMapFile(((OfflineMapSource) newMapSource).getFileName());
        }
    }

    public static void setAnyCoordinates(final Geopoint coords) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (null != coords) {
                    edit.putFloat(KEY_ANYLATITUDE, (float) coords.getLatitude());
                    edit.putFloat(KEY_ANYLONGITUDE, (float) coords.getLongitude());
                } else {
                    edit.remove(KEY_ANYLATITUDE);
                    edit.remove(KEY_ANYLONGITUDE);
                }
            }
        });

    }

    public static Geopoint getAnyCoordinates() {
        if (sharedPrefs.contains(KEY_ANYLATITUDE) && sharedPrefs.contains(KEY_ANYLONGITUDE)) {
            float lat = sharedPrefs.getFloat(KEY_ANYLATITUDE, 0);
            float lon = sharedPrefs.getFloat(KEY_ANYLONGITUDE, 0);
            return new Geopoint(lat, lon);
        }
        return null;
    }

    public static boolean isUseCompass() {
        return sharedPrefs.getBoolean(KEY_USE_COMPASS, true);
    }

    public static void setUseCompass(final boolean useCompass) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_COMPASS, useCompass);
            }
        });
    }

    public static boolean isHelpShown() {
        return sharedPrefs.getBoolean(KEY_HELP_SHOWN, false);
    }

    public static void setHelpShown() {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_HELP_SHOWN, true);
            }
        });
    }

    public static boolean isLightSkin() {
        return sharedPrefs.getBoolean(KEY_SKIN, false);
    }

    public static void setLightSkin(final boolean lightSkin) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SKIN, lightSkin);
            }
        });
    }

    public static String getKeyConsumerPublic() {
        return keyConsumerPublic;
    }

    public static String getKeyConsumerSecret() {
        return keyConsumerSecret;
    }

    public static int getAltCorrection() {
        return sharedPrefs.getInt(KEY_ALTITUDE_CORRECTION, 0);
    }

    public static boolean setAltCorrection(final int altitude) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_ALTITUDE_CORRECTION, altitude);
            }
        });
    }

    public static String getWebDeviceCode() {
        return sharedPrefs.getString(KEY_WEB_DEVICE_CODE, null);
    }

    public static String getWebDeviceName() {
        return sharedPrefs.getString(KEY_WEBDEVICE_NAME, null);
    }

    /**
     * @return The cache type used for filtering or ALL if no filter is active. Returns never null
     */
    public static CacheType getCacheType() {
        return CacheType.getById(sharedPrefs.getString(KEY_CACHE_TYPE, CacheType.ALL.id));
    }

    /**
     * The Threshold for the showing of child waypoints
     *
     * @return
     */

    public static int getWayPointsThreshold() {
        return sharedPrefs.getInt(KEY_SHOW_WAYPOINTS_THRESHOLD, 0);
    }

    public static void setShowWaypointsThreshold(final int threshold) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_SHOW_WAYPOINTS_THRESHOLD, threshold);
            }
        });
    }

    public static boolean isUseTwitter() {
        return sharedPrefs.getBoolean(KEY_USE_TWITTER, false);
    }

    public static void setUseTwitter(final boolean useTwitter) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_TWITTER, useTwitter);
            }
        });
    }

    public static boolean isTwitterLoginValid() {
        return !StringUtils.isBlank(getTokenPublic()) && !StringUtils.isBlank(getTokenSecret());
    }

    public static String getTokenPublic() {
        return sharedPrefs.getString(KEY_TWITTER_TOKEN_PUBLIC, null);
    }

    public static String getTokenSecret() {
        return sharedPrefs.getString(KEY_TWITTER_TOKEN_SECRET, null);

    }

    public static int getVersion() {
        return sharedPrefs.getInt(KEY_VERSION, 0);
    }

    public static void setTwitterTokens(final String tokenPublic, final String tokenSecret, boolean enableTwitter) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_TWITTER_TOKEN_PUBLIC, tokenPublic);
                edit.putString(KEY_TWITTER_TOKEN_SECRET, tokenSecret);
                if (tokenPublic != null) {
                    edit.remove(KEY_TEMP_TOKEN_PUBLIC);
                    edit.remove(KEY_TEMP_TOKEN_SECRET);
                }
            }
        });
        setUseTwitter(enableTwitter);
    }

    public static void setTwitterTempTokens(final String tokenPublic, final String tokenSecret) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_TEMP_TOKEN_PUBLIC, tokenPublic);
                edit.putString(KEY_TEMP_TOKEN_SECRET, tokenSecret);
            }
        });
    }

    public static ImmutablePair<String, String> getTempToken() {
        String tokenPublic = sharedPrefs.getString(KEY_TEMP_TOKEN_PUBLIC, null);
        String tokenSecret = sharedPrefs.getString(KEY_TEMP_TOKEN_SECRET, null);
        return new ImmutablePair<String, String>(tokenPublic, tokenSecret);
    }

    public static void setVersion(final int version) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_VERSION, version);
            }
        });
    }

    public static boolean isOpenLastDetailsPage() {
        return sharedPrefs.getBoolean(KEY_OPEN_LAST_DETAILS_PAGE, false);
    }

    public static void setOpenLastDetailsPage(final boolean openLastPage) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_OPEN_LAST_DETAILS_PAGE, openLastPage);
            }
        });
    }

    public static int getLastDetailsPage() {
        return sharedPrefs.getInt(KEY_LAST_DETAILS_PAGE, 1);
    }

    public static void setLastDetailsPage(final int index) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_DETAILS_PAGE, index);
            }
        });
    }

    public static int getDefaultNavigationTool() {
        return sharedPrefs.getInt(KEY_DEFAULT_NAVIGATION_TOOL, NavigationAppsEnum.COMPASS.id);
    }

    public static void setDefaultNavigationTool(final int defaultNavigationTool) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_DEFAULT_NAVIGATION_TOOL, defaultNavigationTool);
            }
        });
    }

    public static int getDefaultNavigationTool2() {
        return sharedPrefs.getInt(KEY_DEFAULT_NAVIGATION_TOOL_2, NavigationAppsEnum.INTERNAL_MAP.id);
    }

    public static void setDefaultNavigationTool2(final int defaultNavigationTool) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_DEFAULT_NAVIGATION_TOOL_2, defaultNavigationTool);
            }
        });
    }

    public static Strategy getLiveMapStrategy() {
        return Strategy.getById(sharedPrefs.getInt(KEY_LIVE_MAP_STRATEGY, Strategy.AUTO.id));
    }

    public static void setLiveMapStrategy(final Strategy strategy) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LIVE_MAP_STRATEGY, strategy.id);
            }
        });
    }

    public static boolean isDebug() {
        return Log.isDebug();
    }

    public static void setDebug(final boolean debug) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_DEBUG, debug);
            }
        });
        Log.setDebugUnsaved(debug);
    }

    public static boolean getHideLiveMapHint() {
        return sharedPrefs.getBoolean(KEY_HIDE_LIVE_MAP_HINT, false);
    }

    public static void setHideLiveHint(final boolean hide) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_HIDE_LIVE_MAP_HINT, hide);
            }
        });
    }

    public static int getLiveMapHintShowCount() {
        return sharedPrefs.getInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, 0);
    }

    public static void setLiveMapHintShowCount(final int showCount) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, showCount);
            }
        });
    }

    public static boolean isDbOnSDCard() {
        return sharedPrefs.getBoolean(KEY_DB_ON_SDCARD, false);
    }

    public static void setDbOnSDCard(final boolean dbOnSDCard) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_DB_ON_SDCARD, dbOnSDCard);
            }
        });
    }

    public static String getGpxExportDir() {
        return sharedPrefs.getString(KEY_GPX_EXPORT_DIR, Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static void setGpxExportDir(final String gpxExportDir) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_GPX_EXPORT_DIR, gpxExportDir);
            }
        });
    }

    public static String getGpxImportDir() {
        return sharedPrefs.getString(KEY_GPX_IMPORT_DIR, Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static void setGpxImportDir(final String gpxImportDir) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_GPX_IMPORT_DIR, gpxImportDir);
            }
        });
    }

    public static boolean getShareAfterExport() {
        return sharedPrefs.getBoolean(KEY_SHARE_AFTER_EXPORT, true);
    }

    public static void setShareAfterExport(final boolean shareAfterExport) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SHARE_AFTER_EXPORT, shareAfterExport);
            }
        });
    }

    public static int getTrackableAction() {
        return sharedPrefs.getInt(KEY_LAST_TRACKABLE_ACTION, LogType.RETRIEVED_IT.id);
    }

    public static void setTrackableAction(final int trackableAction) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_TRACKABLE_ACTION, trackableAction);
            }
        });
    }

    public static String getCustomRenderThemeBaseFolder() {
        return sharedPrefs.getString(KEY_RENDER_THEME_BASE_FOLDER, "");
    }

    public static boolean setCustomRenderThemeBaseFolder(final String customRenderThemeBaseFolder) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_RENDER_THEME_BASE_FOLDER, customRenderThemeBaseFolder);
            }
        });
    }

    public static String getCustomRenderThemeFilePath() {
        return sharedPrefs.getString(KEY_RENDER_THEME_FILE_PATH, "");
    }

    public static void setCustomRenderThemeFile(final String customRenderThemeFile) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_RENDER_THEME_FILE_PATH, customRenderThemeFile);
            }
        });
    }

    public static File[] getMapThemeFiles() {

        File directory = new File(Settings.getCustomRenderThemeBaseFolder());

        List<File> result = new ArrayList<File>();

        FileUtils.listDir(result, directory, new ExtensionsBasedFileSelector(new String[] { "xml" }), null);

        return result.toArray(new File[result.size()]);
    }

    private static class ExtensionsBasedFileSelector extends FileSelector {

        private final String[] extensions;

        public ExtensionsBasedFileSelector(String[] extensions) {
            this.extensions = extensions;
        }

        @Override
        public boolean isSelected(File file) {
            String filename = file.getName();
            for (String ext : extensions) {
                if (StringUtils.endsWithIgnoreCase(filename, ext)) {
                    return true;
                }
            }
            return false;
        }

        @Override
        public boolean shouldEnd() {
            return false;
        }
    }

    public static String getPreferencesName() {
        // There is currently no Android API to get the file name of the shared preferences. Let's hardcode
        // it without needing a cgeoapplication instance.
        return "cgeo.geocaching_preferences";
    }

    public static boolean getPlainLogs() {
        return sharedPrefs.getBoolean(KEY_PLAIN_LOGS, false);
    }

    public static void setPlainLogs(final boolean plainLogs) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_PLAIN_LOGS, plainLogs);
            }
        });
    }

    public static boolean getUseNativeUa() {
        return sharedPrefs.getBoolean(KEY_NATIVE_UA, false);
    }

    public static void setUseNativeUa(final boolean useNativeUa) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_NATIVE_UA, useNativeUa);
            }
        });
    }
}
!@#$%
20190527_000909,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_a07016
package cgeo.geocaching;

import cgeo.geocaching.apps.cache.navi.NavigationAppFactory.NavigationAppsEnum;
import cgeo.geocaching.connector.gc.GCConstants;
import cgeo.geocaching.connector.gc.Login;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.LiveMapStrategy.Strategy;
import cgeo.geocaching.enumerations.LogType;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.maps.MapProviderFactory;
import cgeo.geocaching.maps.google.GoogleMapProvider;
import cgeo.geocaching.maps.interfaces.GeoPointImpl;
import cgeo.geocaching.maps.interfaces.MapProvider;
import cgeo.geocaching.maps.interfaces.MapSource;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider.OfflineMapSource;
import cgeo.geocaching.utils.CryptUtils;
import cgeo.geocaching.utils.FileUtils;
import cgeo.geocaching.utils.FileUtils.FileSelector;
import cgeo.geocaching.utils.Log;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.os.Environment;
import android.preference.PreferenceManager;

import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

/**
 * General c:geo preferences/settings set by the user
 */
public final class Settings {

    private static final String KEY_TEMP_TOKEN_SECRET = "temp-token-secret";
    private static final String KEY_TEMP_TOKEN_PUBLIC = "temp-token-public";
    private static final String KEY_HELP_SHOWN = "helper";
    private static final String KEY_ANYLONGITUDE = "anylongitude";
    private static final String KEY_ANYLATITUDE = "anylatitude";
    private static final String KEY_USE_OFFLINEMAPS = "offlinemaps";
    private static final String KEY_USE_OFFLINEWPMAPS = "offlinewpmaps";
    private static final String KEY_WEB_DEVICE_CODE = "webDeviceCode";
    private static final String KEY_WEBDEVICE_NAME = "webDeviceName";
    private static final String KEY_MAP_LIVE = "maplive";
    private static final String KEY_MAP_SOURCE = "mapsource";
    private static final String KEY_USE_TWITTER = "twitter";
    private static final String KEY_SHOW_ADDRESS = "showaddress";
    private static final String KEY_SHOW_CAPTCHA = "showcaptcha";
    private static final String KEY_MAP_TRAIL = "maptrail";
    private static final String KEY_LAST_MAP_ZOOM = "mapzoom";
    private static final String KEY_LAST_MAP_LAT = "maplat";
    private static final String KEY_LAST_MAP_LON = "maplon";
    private static final String KEY_LIVE_LIST = "livelist";
    private static final String KEY_METRIC_UNITS = "units";
    private static final String KEY_SKIN = "skin";
    private static final String KEY_LAST_USED_LIST = "lastlist";
    private static final String KEY_CACHE_TYPE = "cachetype";
    private static final String KEY_TWITTER_TOKEN_SECRET = "tokensecret";
    private static final String KEY_TWITTER_TOKEN_PUBLIC = "tokenpublic";
    private static final String KEY_VERSION = "version";
    private static final String KEY_LOAD_DESCRIPTION = "autoloaddesc";
    private static final String KEY_RATING_WANTED = "ratingwanted";
    private static final String KEY_ELEVATION_WANTED = "elevationwanted";
    private static final String KEY_FRIENDLOGS_WANTED = "friendlogswanted";
    private static final String KEY_USE_ENGLISH = "useenglish";
    private static final String KEY_USE_COMPASS = "usecompass";
    private static final String KEY_AUTO_VISIT_TRACKABLES = "trackautovisit";
    private static final String KEY_AUTO_INSERT_SIGNATURE = "sigautoinsert";
    private static final String KEY_ALTITUDE_CORRECTION = "altcorrection";
    private static final String KEY_STORE_LOG_IMAGES = "logimages";
    private static final String KEY_EXCLUDE_DISABLED = "excludedisabled";
    private static final String KEY_EXCLUDE_OWN = "excludemine";
    private static final String KEY_MAPFILE = "mfmapfile";
    private static final String KEY_SIGNATURE = "signature";
    private static final String KEY_GCVOTE_PASSWORD = "pass-vote";
    private static final String KEY_PASSWORD = "password";
    private static final String KEY_USERNAME = "username";
    private static final String KEY_MEMBER_STATUS = "memberstatus";
    private static final String KEY_COORD_INPUT_FORMAT = "coordinputformat";
    private static final String KEY_LOG_OFFLINE = "log_offline";
    private static final String KEY_LOAD_DIRECTION_IMG = "loaddirectionimg";
    private static final String KEY_GC_CUSTOM_DATE = "gccustomdate";
    private static final String KEY_SHOW_WAYPOINTS_THRESHOLD = "gcshowwaypointsthreshold";
    private static final String KEY_COOKIE_STORE = "cookiestore";
    private static final String KEY_OPEN_LAST_DETAILS_PAGE = "opendetailslastpage";
    private static final String KEY_LAST_DETAILS_PAGE = "lastdetailspage";
    private static final String KEY_DEFAULT_NAVIGATION_TOOL = "defaultNavigationTool";
    private static final String KEY_DEFAULT_NAVIGATION_TOOL_2 = "defaultNavigationTool2";
    private static final String KEY_LIVE_MAP_STRATEGY = "livemapstrategy";
    private static final String KEY_DEBUG = "debug";
    private static final String KEY_HIDE_LIVE_MAP_HINT = "hidelivemaphint";
    private static final String KEY_LIVE_MAP_HINT_SHOW_COUNT = "livemaphintshowcount";
    private static final String KEY_SETTINGS_VERSION = "settingsversion";
    private static final String KEY_DB_ON_SDCARD = "dbonsdcard";
    private static final String KEY_LAST_TRACKABLE_ACTION = "trackableaction";
    private static final String KEY_SHARE_AFTER_EXPORT = "shareafterexport";
    private static final String KEY_GPX_EXPORT_DIR = "gpxExportDir";
    private static final String KEY_RENDER_THEME_BASE_FOLDER = "renderthemepath";
    private static final String KEY_RENDER_THEME_FILE_PATH = "renderthemefile";
    private static final String KEY_GPX_IMPORT_DIR = "gpxImportDir";
    private static final String KEY_PLAIN_LOGS = "plainLogs";
    private static final String KEY_NATIVE_UA = "nativeUa";
    private static final String KEY_MAP_DIRECTORY = "mapDirectory";

    private final static int unitsMetric = 1;

    // twitter api keys
    private final static String keyConsumerPublic = CryptUtils.rot13("ESnsCvAv3kEupF1GCR3jGj");
    private final static String keyConsumerSecret = CryptUtils.rot13("7vQWceACV9umEjJucmlpFe9FCMZSeqIqfkQ2BnhV9x");

    private interface PrefRunnable {
        void edit(final Editor edit);
    }

    public enum coordInputFormatEnum {
        Plain,
        Deg,
        Min,
        Sec;

        static coordInputFormatEnum fromInt(int id) {
            final coordInputFormatEnum[] values = coordInputFormatEnum.values();
            if (id < 0 || id >= values.length) {
                return Min;
            }
            return values[id];
        }
    }

    private static String username = null;
    private static String password = null;

    private static final SharedPreferences sharedPrefs = PreferenceManager.getDefaultSharedPreferences(cgeoapplication.getInstance().getBaseContext());
    static {
        migrateSettings();
        Log.setDebugUnsaved(sharedPrefs.getBoolean(KEY_DEBUG, false));
    }

    // maps
    private static MapProvider mapProvider = null;

    private Settings() {
        // this class is not to be instantiated;
    }

    private static void migrateSettings() {
        // migrate from non standard file location and integer based boolean types
        if (sharedPrefs.getInt(KEY_SETTINGS_VERSION, 0) < 1) {
            final String oldPreferencesName = "cgeo.pref";
            final SharedPreferences old = cgeoapplication.getInstance().getSharedPreferences(oldPreferencesName, Context.MODE_PRIVATE);
            final Editor e = sharedPrefs.edit();

            e.putString(KEY_TEMP_TOKEN_SECRET, old.getString(KEY_TEMP_TOKEN_SECRET, null));
            e.putString(KEY_TEMP_TOKEN_PUBLIC, old.getString(KEY_TEMP_TOKEN_PUBLIC, null));
            e.putBoolean(KEY_HELP_SHOWN, old.getInt(KEY_HELP_SHOWN, 0) != 0);
            e.putFloat(KEY_ANYLONGITUDE, old.getFloat(KEY_ANYLONGITUDE, 0));
            e.putFloat(KEY_ANYLATITUDE, old.getFloat(KEY_ANYLATITUDE, 0));
            e.putBoolean(KEY_USE_OFFLINEMAPS, 0 != old.getInt(KEY_USE_OFFLINEMAPS, 1));
            e.putBoolean(KEY_USE_OFFLINEWPMAPS, 0 != old.getInt(KEY_USE_OFFLINEWPMAPS, 0));
            e.putString(KEY_WEB_DEVICE_CODE, old.getString(KEY_WEB_DEVICE_CODE, null));
            e.putString(KEY_WEBDEVICE_NAME, old.getString(KEY_WEBDEVICE_NAME, null));
            e.putBoolean(KEY_MAP_LIVE, old.getInt(KEY_MAP_LIVE, 1) != 0);
            e.putInt(KEY_MAP_SOURCE, old.getInt(KEY_MAP_SOURCE, 0));
            e.putBoolean(KEY_USE_TWITTER, 0 != old.getInt(KEY_USE_TWITTER, 0));
            e.putBoolean(KEY_SHOW_ADDRESS, 0 != old.getInt(KEY_SHOW_ADDRESS, 1));
            e.putBoolean(KEY_SHOW_CAPTCHA, old.getBoolean(KEY_SHOW_CAPTCHA, false));
            e.putBoolean(KEY_MAP_TRAIL, old.getInt(KEY_MAP_TRAIL, 1) != 0);
            e.putInt(KEY_LAST_MAP_ZOOM, old.getInt(KEY_LAST_MAP_ZOOM, 14));
            e.putBoolean(KEY_LIVE_LIST, 0 != old.getInt(KEY_LIVE_LIST, 1));
            e.putBoolean(KEY_METRIC_UNITS, old.getInt(KEY_METRIC_UNITS, unitsMetric) == unitsMetric);
            e.putBoolean(KEY_SKIN, old.getInt(KEY_SKIN, 0) != 0);
            e.putInt(KEY_LAST_USED_LIST, old.getInt(KEY_LAST_USED_LIST, StoredList.STANDARD_LIST_ID));
            e.putString(KEY_CACHE_TYPE, old.getString(KEY_CACHE_TYPE, CacheType.ALL.id));
            e.putString(KEY_TWITTER_TOKEN_SECRET, old.getString(KEY_TWITTER_TOKEN_SECRET, null));
            e.putString(KEY_TWITTER_TOKEN_PUBLIC, old.getString(KEY_TWITTER_TOKEN_PUBLIC, null));
            e.putInt(KEY_VERSION, old.getInt(KEY_VERSION, 0));
            e.putBoolean(KEY_LOAD_DESCRIPTION, 0 != old.getInt(KEY_LOAD_DESCRIPTION, 0));
            e.putBoolean(KEY_RATING_WANTED, old.getBoolean(KEY_RATING_WANTED, true));
            e.putBoolean(KEY_ELEVATION_WANTED, old.getBoolean(KEY_ELEVATION_WANTED, true));
            e.putBoolean(KEY_FRIENDLOGS_WANTED, old.getBoolean(KEY_FRIENDLOGS_WANTED, true));
            e.putBoolean(KEY_USE_ENGLISH, old.getBoolean(KEY_USE_ENGLISH, false));
            e.putBoolean(KEY_USE_COMPASS, 0 != old.getInt(KEY_USE_COMPASS, 1));
            e.putBoolean(KEY_AUTO_VISIT_TRACKABLES, old.getBoolean(KEY_AUTO_VISIT_TRACKABLES, false));
            e.putBoolean(KEY_AUTO_INSERT_SIGNATURE, old.getBoolean(KEY_AUTO_INSERT_SIGNATURE, false));
            e.putInt(KEY_ALTITUDE_CORRECTION, old.getInt(KEY_ALTITUDE_CORRECTION, 0));
            e.putBoolean(KEY_STORE_LOG_IMAGES, old.getBoolean(KEY_STORE_LOG_IMAGES, false));
            e.putBoolean(KEY_EXCLUDE_DISABLED, 0 != old.getInt(KEY_EXCLUDE_DISABLED, 0));
            e.putBoolean(KEY_EXCLUDE_OWN, 0 != old.getInt(KEY_EXCLUDE_OWN, 0));
            e.putString(KEY_MAPFILE, old.getString(KEY_MAPFILE, null));
            e.putString(KEY_SIGNATURE, old.getString(KEY_SIGNATURE, null));
            e.putString(KEY_GCVOTE_PASSWORD, old.getString(KEY_GCVOTE_PASSWORD, null));
            e.putString(KEY_PASSWORD, old.getString(KEY_PASSWORD, null));
            e.putString(KEY_USERNAME, old.getString(KEY_USERNAME, null));
            e.putString(KEY_MEMBER_STATUS, old.getString(KEY_MEMBER_STATUS, ""));
            e.putInt(KEY_COORD_INPUT_FORMAT, old.getInt(KEY_COORD_INPUT_FORMAT, 0));
            e.putBoolean(KEY_LOG_OFFLINE, old.getBoolean(KEY_LOG_OFFLINE, false));
            e.putBoolean(KEY_LOAD_DIRECTION_IMG, old.getBoolean(KEY_LOAD_DIRECTION_IMG, true));
            e.putString(KEY_GC_CUSTOM_DATE, old.getString(KEY_GC_CUSTOM_DATE, null));
            e.putInt(KEY_SHOW_WAYPOINTS_THRESHOLD, old.getInt(KEY_SHOW_WAYPOINTS_THRESHOLD, 0));
            e.putString(KEY_COOKIE_STORE, old.getString(KEY_COOKIE_STORE, null));
            e.putBoolean(KEY_OPEN_LAST_DETAILS_PAGE, old.getBoolean(KEY_OPEN_LAST_DETAILS_PAGE, false));
            e.putInt(KEY_LAST_DETAILS_PAGE, old.getInt(KEY_LAST_DETAILS_PAGE, 1));
            e.putInt(KEY_DEFAULT_NAVIGATION_TOOL, old.getInt(KEY_DEFAULT_NAVIGATION_TOOL, NavigationAppsEnum.COMPASS.id));
            e.putInt(KEY_DEFAULT_NAVIGATION_TOOL_2, old.getInt(KEY_DEFAULT_NAVIGATION_TOOL_2, NavigationAppsEnum.INTERNAL_MAP.id));
            e.putInt(KEY_LIVE_MAP_STRATEGY, old.getInt(KEY_LIVE_MAP_STRATEGY, Strategy.AUTO.id));
            e.putBoolean(KEY_DEBUG, old.getBoolean(KEY_DEBUG, false));
            e.putBoolean(KEY_HIDE_LIVE_MAP_HINT, old.getInt(KEY_HIDE_LIVE_MAP_HINT, 0) != 0);
            e.putInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, old.getInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, 0));

            e.putInt(KEY_SETTINGS_VERSION, 1); // mark migrated
            e.commit();
        }
    }

    public static void setLanguage(boolean useEnglish) {
        final Configuration config = new Configuration();
        config.locale = useEnglish ? new Locale("en") : Locale.getDefault();
        final Resources resources = cgeoapplication.getInstance().getResources();
        resources.updateConfiguration(config, resources.getDisplayMetrics());
    }

    public static boolean isLogin() {
        final String preUsername = sharedPrefs.getString(KEY_USERNAME, null);
        final String prePassword = sharedPrefs.getString(KEY_PASSWORD, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    /**
     * Get login and password information.
     *
     * @return a pair (login, password) or null if no valid information is stored
     */
    public static ImmutablePair<String, String> getLogin() {
        if (username == null || password == null) {
            final String preUsername = sharedPrefs.getString(KEY_USERNAME, null);
            final String prePassword = sharedPrefs.getString(KEY_PASSWORD, null);

            if (preUsername == null || prePassword == null) {
                return null;
            }

            username = preUsername;
            password = prePassword;
        }
        return new ImmutablePair<String, String>(username, password);
    }

    public static String getUsername() {
        return username != null ? username : sharedPrefs.getString(KEY_USERNAME, null);
    }

    public static boolean setLogin(final String username, final String password) {
        Settings.username = username;
        Settings.password = password;
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
                    // erase username and password
                    edit.remove(KEY_USERNAME);
                    edit.remove(KEY_PASSWORD);
                } else {
                    // save username and password
                    edit.putString(KEY_USERNAME, username);
                    edit.putString(KEY_PASSWORD, password);
                }
            }
        });
    }

    public static boolean isPremiumMember() {
        // Basic Member, Premium Member, ???
        String memberStatus = Settings.getMemberStatus();
        if (memberStatus == null) {
            return false;
        }
        return GCConstants.MEMBER_STATUS_PM.equalsIgnoreCase(memberStatus);
    }

    public static String getMemberStatus() {
        return sharedPrefs.getString(KEY_MEMBER_STATUS, "");
    }

    public static boolean setMemberStatus(final String memberStatus) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(memberStatus)) {
                    edit.remove(KEY_MEMBER_STATUS);
                } else {
                    edit.putString(KEY_MEMBER_STATUS, memberStatus);
                }
            }
        });
    }

    public static boolean isGCvoteLogin() {
        final String preUsername = sharedPrefs.getString(KEY_USERNAME, null);
        final String prePassword = sharedPrefs.getString(KEY_GCVOTE_PASSWORD, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    public static boolean setGCvoteLogin(final String password) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(password)) {
                    // erase password
                    edit.remove(KEY_GCVOTE_PASSWORD);
                } else {
                    // save password
                    edit.putString(KEY_GCVOTE_PASSWORD, password);
                }
            }
        });
    }

    public static ImmutablePair<String, String> getGCvoteLogin() {
        final String username = sharedPrefs.getString(KEY_USERNAME, null);
        final String password = sharedPrefs.getString(KEY_GCVOTE_PASSWORD, null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return null;
        }

        return new ImmutablePair<String, String>(username, password);
    }

    public static boolean setSignature(final String signature) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(signature)) {
                    // erase signature
                    edit.remove(KEY_SIGNATURE);
                } else {
                    // save signature
                    edit.putString(KEY_SIGNATURE, signature);
                }
            }
        });
    }

    public static String getSignature() {
        return sharedPrefs.getString(KEY_SIGNATURE, null);
    }

    public static boolean setCookieStore(final String cookies) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(final Editor edit) {
                if (StringUtils.isBlank(cookies)) {
                    // erase cookies
                    edit.remove(KEY_COOKIE_STORE);
                } else {
                    // save cookies
                    edit.putString(KEY_COOKIE_STORE, cookies);
                }
            }
        });
    }

    public static String getCookieStore() {
        return sharedPrefs.getString(KEY_COOKIE_STORE, null);
    }

    /**
     * @param cacheType
     *            The cache type used for future filtering
     */
    public static void setCacheType(final CacheType cacheType) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                if (cacheType == null) {
                    edit.remove(KEY_CACHE_TYPE);
                } else {
                    edit.putString(KEY_CACHE_TYPE, cacheType.id);
                }
            }
        });
    }

    public static void setLiveMap(final boolean live) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_MAP_LIVE, live);
            }
        });
    }

    public static int getLastList() {
        return sharedPrefs.getInt(KEY_LAST_USED_LIST, StoredList.STANDARD_LIST_ID);
    }

    public static void saveLastList(final int listId) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_USED_LIST, listId);
            }
        });
    }

    public static void setWebNameCode(final String name, final String code) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {

                edit.putString(KEY_WEBDEVICE_NAME, name);
                edit.putString(KEY_WEB_DEVICE_CODE, code);
            }
        });
    }

    public static MapProvider getMapProvider() {
        if (mapProvider == null) {
            mapProvider = getMapSource().getMapProvider();
        }
        return mapProvider;
    }

    public static String getMapFile() {
        return sharedPrefs.getString(KEY_MAPFILE, null);
    }

    public static boolean setMapFile(final String mapFile) {
        boolean result = editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_MAPFILE, mapFile);
            }
        });
        if (mapFile != null) {
            setMapFileDirectory(new File(mapFile).getParent());
        }
        return result;
    }

    public static String getMapFileDirectory() {
        final String mapDir = sharedPrefs.getString(KEY_MAP_DIRECTORY, null);
        if (mapDir != null) {
            return mapDir;
        }
        final String mapFile = getMapFile();
        if (mapFile != null) {
            return new File(mapFile).getParent();
        }
        return null;
    }

    public static boolean setMapFileDirectory(final String mapFileDirectory) {
        return editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_MAP_DIRECTORY, mapFileDirectory);
                MapsforgeMapProvider.getInstance().updateOfflineMaps();
            }
        });
    }

    public static boolean isValidMapFile() {
        return isValidMapFile(getMapFile());
    }

    public static boolean isValidMapFile(final String mapFileIn) {
        return MapsforgeMapProvider.isValidMapFile(mapFileIn);
    }

    public static coordInputFormatEnum getCoordInputFormat() {
        return coordInputFormatEnum.fromInt(sharedPrefs.getInt(KEY_COORD_INPUT_FORMAT, 0));
    }

    public static void setCoordInputFormat(final coordInputFormatEnum format) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_COORD_INPUT_FORMAT, format.ordinal());
            }
        });
    }

    static void setLogOffline(final boolean offline) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LOG_OFFLINE, offline);
            }
        });
    }

    public static boolean getLogOffline() {
        return sharedPrefs.getBoolean(KEY_LOG_OFFLINE, false);
    }

    static void setLoadDirImg(final boolean value) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LOAD_DIRECTION_IMG, value);
            }
        });
    }

    public static boolean getLoadDirImg() {
        return !isPremiumMember() && sharedPrefs.getBoolean(KEY_LOAD_DIRECTION_IMG, true);
    }

    public static void setGcCustomDate(final String format) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_GC_CUSTOM_DATE, format);
            }
        });
    }

    /**
     * @return User selected date format on GC.com
     * @see Login#gcCustomDateFormats
     */
    public static String getGcCustomDate() {
        return sharedPrefs.getString(KEY_GC_CUSTOM_DATE, null);
    }

    public static boolean isExcludeMyCaches() {
        return sharedPrefs.getBoolean(KEY_EXCLUDE_OWN, false);
    }

    /**
     * edit some settings without knowing how to get the settings editor or how to commit
     *
     * @param runnable
     * @return
     */
    private static boolean editSharedSettings(final PrefRunnable runnable) {
        final SharedPreferences.Editor prefsEdit = sharedPrefs.edit();
        runnable.edit(prefsEdit);
        return prefsEdit.commit();
    }

    public static void setExcludeMine(final boolean exclude) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_EXCLUDE_OWN, exclude);
            }
        });
    }

    public static void setUseEnglish(final boolean english) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_ENGLISH, english);
                setLanguage(english);
            }
        });
    }

    public static boolean isUseEnglish() {
        return sharedPrefs.getBoolean(KEY_USE_ENGLISH, false);
    }

    public static boolean isShowAddress() {
        return sharedPrefs.getBoolean(KEY_SHOW_ADDRESS, true);
    }

    public static void setShowAddress(final boolean showAddress) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SHOW_ADDRESS, showAddress);
            }
        });
    }

    public static boolean isShowCaptcha() {
        return !isPremiumMember() && sharedPrefs.getBoolean(KEY_SHOW_CAPTCHA, false);
    }

    public static void setShowCaptcha(final boolean showCaptcha) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SHOW_CAPTCHA, showCaptcha);
            }
        });
    }

    public static boolean isExcludeDisabledCaches() {
        return sharedPrefs.getBoolean(KEY_EXCLUDE_DISABLED, false);
    }

    public static void setExcludeDisabledCaches(final boolean exclude) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_EXCLUDE_DISABLED, exclude);
            }
        });
    }

    public static boolean isStoreOfflineMaps() {
        return sharedPrefs.getBoolean(KEY_USE_OFFLINEMAPS, true);
    }

    public static void setStoreOfflineMaps(final boolean offlineMaps) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_OFFLINEMAPS, offlineMaps);
            }
        });
    }

    public static boolean isStoreOfflineWpMaps() {
        return sharedPrefs.getBoolean(KEY_USE_OFFLINEWPMAPS, false);
    }

    public static void setStoreOfflineWpMaps(final boolean offlineMaps) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_OFFLINEWPMAPS, offlineMaps);
            }
        });
    }

    public static boolean isStoreLogImages() {
        return sharedPrefs.getBoolean(KEY_STORE_LOG_IMAGES, false);
    }

    public static void setStoreLogImages(final boolean storeLogImages) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_STORE_LOG_IMAGES, storeLogImages);
            }
        });
    }

    public static boolean isAutoLoadDescription() {
        return sharedPrefs.getBoolean(KEY_LOAD_DESCRIPTION, false);
    }

    public static void setAutoLoadDesc(final boolean autoLoad) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LOAD_DESCRIPTION, autoLoad);
            }
        });
    }

    public static boolean isRatingWanted() {
        return sharedPrefs.getBoolean(KEY_RATING_WANTED, true);
    }

    public static void setRatingWanted(final boolean ratingWanted) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_RATING_WANTED, ratingWanted);
            }
        });
    }

    public static boolean isElevationWanted() {
        return sharedPrefs.getBoolean(KEY_ELEVATION_WANTED, true);
    }

    public static void setElevationWanted(final boolean elevationWanted) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_ELEVATION_WANTED, elevationWanted);
            }
        });
    }

    public static boolean isFriendLogsWanted() {
        if (!isLogin()) {
            // don't show a friends log if the user is anonymous
            return false;
        }
        return sharedPrefs.getBoolean(KEY_FRIENDLOGS_WANTED, true);
    }

    public static void setFriendLogsWanted(final boolean friendLogsWanted) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_FRIENDLOGS_WANTED, friendLogsWanted);
            }
        });
    }

    public static boolean isLiveList() {
        return sharedPrefs.getBoolean(KEY_LIVE_LIST, true);
    }

    public static void setLiveList(final boolean liveList) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LIVE_LIST, liveList);
            }
        });
    }

    public static boolean isTrackableAutoVisit() {
        return sharedPrefs.getBoolean(KEY_AUTO_VISIT_TRACKABLES, false);
    }

    public static void setTrackableAutoVisit(final boolean autoVisit) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_AUTO_VISIT_TRACKABLES, autoVisit);
            }
        });
    }

    public static boolean isAutoInsertSignature() {
        return sharedPrefs.getBoolean(KEY_AUTO_INSERT_SIGNATURE, false);
    }

    public static void setAutoInsertSignature(final boolean autoInsert) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_AUTO_INSERT_SIGNATURE, autoInsert);
            }
        });
    }

    public static boolean isUseMetricUnits() {
        return sharedPrefs.getBoolean(KEY_METRIC_UNITS, true);
    }

    public static void setUseMetricUnits(final boolean metric) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_METRIC_UNITS, metric);
            }
        });
    }

    public static boolean isLiveMap() {
        return sharedPrefs.getBoolean(KEY_MAP_LIVE, true);
    }

    public static boolean isMapTrail() {
        return sharedPrefs.getBoolean(KEY_MAP_TRAIL, true);
    }

    public static void setMapTrail(final boolean showTrail) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_MAP_TRAIL, showTrail);
            }
        });
    }

    public static int getMapZoom() {
        return sharedPrefs.getInt(KEY_LAST_MAP_ZOOM, 14);
    }

    public static void setMapZoom(final int mapZoomLevel) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_MAP_ZOOM, mapZoomLevel);
            }
        });
    }

    public static GeoPointImpl getMapCenter() {
        return getMapProvider().getMapItemFactory()
                .getGeoPointBase(new Geopoint(sharedPrefs.getInt(KEY_LAST_MAP_LAT, 0) / 1e6,
                        sharedPrefs.getInt(KEY_LAST_MAP_LON, 0) / 1e6));
    }

    public static void setMapCenter(final GeoPointImpl mapViewCenter) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_MAP_LAT, mapViewCenter.getLatitudeE6());
                edit.putInt(KEY_LAST_MAP_LON, mapViewCenter.getLongitudeE6());
            }
        });
    }

    public static MapSource getMapSource() {
        final int id = getConvertedMapId();
        final MapSource map = MapProviderFactory.getMapSource(id);
        if (map != null) {
            // don't use offline maps if the map file is not valid
            if ((!(map instanceof OfflineMapSource)) || (isValidMapFile())) {
                return map;
            }
        }
        // fallback to first available map
        return MapProviderFactory.getDefaultSource();
    }

    private final static int GOOGLEMAP_BASEID = 30;
    private final static int MAP = 1;
    private final static int SATELLITE = 2;

    private final static int MFMAP_BASEID = 40;
    private final static int MAPNIK = 1;
    private final static int CYCLEMAP = 3;
    private final static int OFFLINE = 4;

    /**
     * convert old preference ids for maps (based on constant values) into new hash based ids
     *
     * @return
     */
    private static int getConvertedMapId() {
        final int id = sharedPrefs.getInt(KEY_MAP_SOURCE, 0);
        switch (id) {
            case GOOGLEMAP_BASEID + MAP:
                return GoogleMapProvider.GOOGLE_MAP_ID.hashCode();
            case GOOGLEMAP_BASEID + SATELLITE:
                return GoogleMapProvider.GOOGLE_SATELLITE_ID.hashCode();
            case MFMAP_BASEID + MAPNIK:
                return MapsforgeMapProvider.MAPSFORGE_MAPNIK_ID.hashCode();
            case MFMAP_BASEID + CYCLEMAP:
                return MapsforgeMapProvider.MAPSFORGE_CYCLEMAP_ID.hashCode();
            case MFMAP_BASEID + OFFLINE: {
                final String mapFile = Settings.getMapFile();
                if (StringUtils.isNotEmpty(mapFile)) {
                    return mapFile.hashCode();
                }
                break;
            }
            default:
                break;
        }
        return id;
    }

    public static void setMapSource(final MapSource newMapSource) {
        if (!MapProviderFactory.isSameActivity(getMapSource(), newMapSource)) {
            mapProvider = null;
        }
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_MAP_SOURCE, newMapSource.getNumericalId());
            }
        });
        if (newMapSource instanceof OfflineMapSource) {
            setMapFile(((OfflineMapSource) newMapSource).getFileName());
        }
    }

    public static void setAnyCoordinates(final Geopoint coords) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (null != coords) {
                    edit.putFloat(KEY_ANYLATITUDE, (float) coords.getLatitude());
                    edit.putFloat(KEY_ANYLONGITUDE, (float) coords.getLongitude());
                } else {
                    edit.remove(KEY_ANYLATITUDE);
                    edit.remove(KEY_ANYLONGITUDE);
                }
            }
        });

    }

    public static Geopoint getAnyCoordinates() {
        if (sharedPrefs.contains(KEY_ANYLATITUDE) && sharedPrefs.contains(KEY_ANYLONGITUDE)) {
            float lat = sharedPrefs.getFloat(KEY_ANYLATITUDE, 0);
            float lon = sharedPrefs.getFloat(KEY_ANYLONGITUDE, 0);
            return new Geopoint(lat, lon);
        }
        return null;
    }

    public static boolean isUseCompass() {
        return sharedPrefs.getBoolean(KEY_USE_COMPASS, true);
    }

    public static void setUseCompass(final boolean useCompass) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_COMPASS, useCompass);
            }
        });
    }

    public static boolean isHelpShown() {
        return sharedPrefs.getBoolean(KEY_HELP_SHOWN, false);
    }

    public static void setHelpShown() {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_HELP_SHOWN, true);
            }
        });
    }

    public static boolean isLightSkin() {
        return sharedPrefs.getBoolean(KEY_SKIN, false);
    }

    public static void setLightSkin(final boolean lightSkin) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SKIN, lightSkin);
            }
        });
    }

    public static String getKeyConsumerPublic() {
        return keyConsumerPublic;
    }

    public static String getKeyConsumerSecret() {
        return keyConsumerSecret;
    }

    public static int getAltCorrection() {
        return sharedPrefs.getInt(KEY_ALTITUDE_CORRECTION, 0);
    }

    public static boolean setAltCorrection(final int altitude) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_ALTITUDE_CORRECTION, altitude);
            }
        });
    }

    public static String getWebDeviceCode() {
        return sharedPrefs.getString(KEY_WEB_DEVICE_CODE, null);
    }

    public static String getWebDeviceName() {
        return sharedPrefs.getString(KEY_WEBDEVICE_NAME, null);
    }

    /**
     * @return The cache type used for filtering or ALL if no filter is active. Returns never null
     */
    public static CacheType getCacheType() {
        return CacheType.getById(sharedPrefs.getString(KEY_CACHE_TYPE, CacheType.ALL.id));
    }

    /**
     * The Threshold for the showing of child waypoints
     *
     * @return
     */

    public static int getWayPointsThreshold() {
        return sharedPrefs.getInt(KEY_SHOW_WAYPOINTS_THRESHOLD, 0);
    }

    public static void setShowWaypointsThreshold(final int threshold) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_SHOW_WAYPOINTS_THRESHOLD, threshold);
            }
        });
    }

    public static boolean isUseTwitter() {
        return sharedPrefs.getBoolean(KEY_USE_TWITTER, false);
    }

    public static void setUseTwitter(final boolean useTwitter) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_TWITTER, useTwitter);
            }
        });
    }

    public static boolean isTwitterLoginValid() {
        return !StringUtils.isBlank(getTokenPublic()) && !StringUtils.isBlank(getTokenSecret());
    }

    public static String getTokenPublic() {
        return sharedPrefs.getString(KEY_TWITTER_TOKEN_PUBLIC, null);
    }

    public static String getTokenSecret() {
        return sharedPrefs.getString(KEY_TWITTER_TOKEN_SECRET, null);

    }

    public static int getVersion() {
        return sharedPrefs.getInt(KEY_VERSION, 0);
    }

    public static void setTwitterTokens(final String tokenPublic, final String tokenSecret, boolean enableTwitter) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_TWITTER_TOKEN_PUBLIC, tokenPublic);
                edit.putString(KEY_TWITTER_TOKEN_SECRET, tokenSecret);
                if (tokenPublic != null) {
                    edit.remove(KEY_TEMP_TOKEN_PUBLIC);
                    edit.remove(KEY_TEMP_TOKEN_SECRET);
                }
            }
        });
        setUseTwitter(enableTwitter);
    }

    public static void setTwitterTempTokens(final String tokenPublic, final String tokenSecret) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_TEMP_TOKEN_PUBLIC, tokenPublic);
                edit.putString(KEY_TEMP_TOKEN_SECRET, tokenSecret);
            }
        });
    }

    public static ImmutablePair<String, String> getTempToken() {
        String tokenPublic = sharedPrefs.getString(KEY_TEMP_TOKEN_PUBLIC, null);
        String tokenSecret = sharedPrefs.getString(KEY_TEMP_TOKEN_SECRET, null);
        return new ImmutablePair<String, String>(tokenPublic, tokenSecret);
    }

    public static void setVersion(final int version) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_VERSION, version);
            }
        });
    }

    public static boolean isOpenLastDetailsPage() {
        return sharedPrefs.getBoolean(KEY_OPEN_LAST_DETAILS_PAGE, false);
    }

    public static void setOpenLastDetailsPage(final boolean openLastPage) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_OPEN_LAST_DETAILS_PAGE, openLastPage);
            }
        });
    }

    public static int getLastDetailsPage() {
        return sharedPrefs.getInt(KEY_LAST_DETAILS_PAGE, 1);
    }

    public static void setLastDetailsPage(final int index) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_DETAILS_PAGE, index);
            }
        });
    }

    public static int getDefaultNavigationTool() {
        return sharedPrefs.getInt(KEY_DEFAULT_NAVIGATION_TOOL, NavigationAppsEnum.COMPASS.id);
    }

    public static void setDefaultNavigationTool(final int defaultNavigationTool) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_DEFAULT_NAVIGATION_TOOL, defaultNavigationTool);
            }
        });
    }

    public static int getDefaultNavigationTool2() {
        return sharedPrefs.getInt(KEY_DEFAULT_NAVIGATION_TOOL_2, NavigationAppsEnum.INTERNAL_MAP.id);
    }

    public static void setDefaultNavigationTool2(final int defaultNavigationTool) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_DEFAULT_NAVIGATION_TOOL_2, defaultNavigationTool);
            }
        });
    }

    public static Strategy getLiveMapStrategy() {
        return Strategy.getById(sharedPrefs.getInt(KEY_LIVE_MAP_STRATEGY, Strategy.AUTO.id));
    }

    public static void setLiveMapStrategy(final Strategy strategy) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LIVE_MAP_STRATEGY, strategy.id);
            }
        });
    }

    public static boolean isDebug() {
        return Log.isDebug();
    }

    public static void setDebug(final boolean debug) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_DEBUG, debug);
            }
        });
        Log.setDebugUnsaved(debug);
    }

    public static boolean getHideLiveMapHint() {
        return sharedPrefs.getBoolean(KEY_HIDE_LIVE_MAP_HINT, false);
    }

    public static void setHideLiveHint(final boolean hide) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_HIDE_LIVE_MAP_HINT, hide);
            }
        });
    }

    public static int getLiveMapHintShowCount() {
        return sharedPrefs.getInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, 0);
    }

    public static void setLiveMapHintShowCount(final int showCount) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, showCount);
            }
        });
    }

    public static boolean isDbOnSDCard() {
        return sharedPrefs.getBoolean(KEY_DB_ON_SDCARD, false);
    }

    public static void setDbOnSDCard(final boolean dbOnSDCard) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_DB_ON_SDCARD, dbOnSDCard);
            }
        });
    }

    public static String getGpxExportDir() {
        return sharedPrefs.getString(KEY_GPX_EXPORT_DIR, Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static void setGpxExportDir(final String gpxExportDir) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_GPX_EXPORT_DIR, gpxExportDir);
            }
        });
    }

    public static String getGpxImportDir() {
        return sharedPrefs.getString(KEY_GPX_IMPORT_DIR, Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static void setGpxImportDir(final String gpxImportDir) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_GPX_IMPORT_DIR, gpxImportDir);
            }
        });
    }

    public static boolean getShareAfterExport() {
        return sharedPrefs.getBoolean(KEY_SHARE_AFTER_EXPORT, true);
    }

    public static void setShareAfterExport(final boolean shareAfterExport) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SHARE_AFTER_EXPORT, shareAfterExport);
            }
        });
    }

    public static int getTrackableAction() {
        return sharedPrefs.getInt(KEY_LAST_TRACKABLE_ACTION, LogType.RETRIEVED_IT.id);
    }

    public static void setTrackableAction(final int trackableAction) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_TRACKABLE_ACTION, trackableAction);
            }
        });
    }

    public static String getCustomRenderThemeBaseFolder() {
        return sharedPrefs.getString(KEY_RENDER_THEME_BASE_FOLDER, "");
    }

    public static boolean setCustomRenderThemeBaseFolder(final String customRenderThemeBaseFolder) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_RENDER_THEME_BASE_FOLDER, customRenderThemeBaseFolder);
            }
        });
    }

    public static String getCustomRenderThemeFilePath() {
        return sharedPrefs.getString(KEY_RENDER_THEME_FILE_PATH, "");
    }

    public static void setCustomRenderThemeFile(final String customRenderThemeFile) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_RENDER_THEME_FILE_PATH, customRenderThemeFile);
            }
        });
    }

    public static File[] getMapThemeFiles() {

        File directory = new File(Settings.getCustomRenderThemeBaseFolder());

        List<File> result = new ArrayList<File>();

        FileUtils.listDir(result, directory, new ExtensionsBasedFileSelector(new String[] { "xml" }), null);

        return result.toArray(new File[result.size()]);
    }

    private static class ExtensionsBasedFileSelector extends FileSelector {

        private final String[] extensions;

        public ExtensionsBasedFileSelector(String[] extensions) {
            this.extensions = extensions;
        }

        @Override
        public boolean isSelected(File file) {
            String filename = file.getName();
            for (String ext : extensions) {
                if (StringUtils.endsWithIgnoreCase(filename, ext)) {
                    return true;
                }
            }
            return false;
        }

        @Override
        public boolean shouldEnd() {
            return false;
        }
    }

    public static String getPreferencesName() {
        // there is currently no Android API to get the file name of the shared preferences
        return cgeoapplication.getInstance().getPackageName() + "_preferences";
    }

    public static boolean getPlainLogs() {
        return sharedPrefs.getBoolean(KEY_PLAIN_LOGS, false);
    }

    public static void setPlainLogs(final boolean plainLogs) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_PLAIN_LOGS, plainLogs);
            }
        });
    }

    public static boolean getUseNativeUa() {
        return sharedPrefs.getBoolean(KEY_NATIVE_UA, false);
    }

    public static void setUseNativeUa(final boolean useNativeUa) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_NATIVE_UA, useNativeUa);
            }
        });
    }
}
!@#$%
20190527_000909,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_c07016
package cgeo.geocaching;

import cgeo.geocaching.apps.cache.navi.NavigationAppFactory.NavigationAppsEnum;
import cgeo.geocaching.connector.gc.GCConstants;
import cgeo.geocaching.connector.gc.Login;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.LiveMapStrategy.Strategy;
import cgeo.geocaching.enumerations.LogType;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.maps.MapProviderFactory;
import cgeo.geocaching.maps.google.GoogleMapProvider;
import cgeo.geocaching.maps.interfaces.GeoPointImpl;
import cgeo.geocaching.maps.interfaces.MapProvider;
import cgeo.geocaching.maps.interfaces.MapSource;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider.OfflineMapSource;
import cgeo.geocaching.utils.CryptUtils;
import cgeo.geocaching.utils.FileUtils;
import cgeo.geocaching.utils.FileUtils.FileSelector;
import cgeo.geocaching.utils.Log;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.os.Environment;
import android.preference.PreferenceManager;

import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

/**
 * General c:geo preferences/settings set by the user
 */
public final class Settings {

    private static final String KEY_TEMP_TOKEN_SECRET = "temp-token-secret";
    private static final String KEY_TEMP_TOKEN_PUBLIC = "temp-token-public";
    private static final String KEY_HELP_SHOWN = "helper";
    private static final String KEY_ANYLONGITUDE = "anylongitude";
    private static final String KEY_ANYLATITUDE = "anylatitude";
    private static final String KEY_USE_OFFLINEMAPS = "offlinemaps";
    private static final String KEY_USE_OFFLINEWPMAPS = "offlinewpmaps";
    private static final String KEY_WEB_DEVICE_CODE = "webDeviceCode";
    private static final String KEY_WEBDEVICE_NAME = "webDeviceName";
    private static final String KEY_MAP_LIVE = "maplive";
    private static final String KEY_MAP_SOURCE = "mapsource";
    private static final String KEY_USE_TWITTER = "twitter";
    private static final String KEY_SHOW_ADDRESS = "showaddress";
    private static final String KEY_SHOW_CAPTCHA = "showcaptcha";
    private static final String KEY_MAP_TRAIL = "maptrail";
    private static final String KEY_LAST_MAP_ZOOM = "mapzoom";
    private static final String KEY_LAST_MAP_LAT = "maplat";
    private static final String KEY_LAST_MAP_LON = "maplon";
    private static final String KEY_LIVE_LIST = "livelist";
    private static final String KEY_METRIC_UNITS = "units";
    private static final String KEY_SKIN = "skin";
    private static final String KEY_LAST_USED_LIST = "lastlist";
    private static final String KEY_CACHE_TYPE = "cachetype";
    private static final String KEY_TWITTER_TOKEN_SECRET = "tokensecret";
    private static final String KEY_TWITTER_TOKEN_PUBLIC = "tokenpublic";
    private static final String KEY_VERSION = "version";
    private static final String KEY_LOAD_DESCRIPTION = "autoloaddesc";
    private static final String KEY_RATING_WANTED = "ratingwanted";
    private static final String KEY_ELEVATION_WANTED = "elevationwanted";
    private static final String KEY_FRIENDLOGS_WANTED = "friendlogswanted";
    private static final String KEY_USE_ENGLISH = "useenglish";
    private static final String KEY_USE_COMPASS = "usecompass";
    private static final String KEY_AUTO_VISIT_TRACKABLES = "trackautovisit";
    private static final String KEY_AUTO_INSERT_SIGNATURE = "sigautoinsert";
    private static final String KEY_ALTITUDE_CORRECTION = "altcorrection";
    private static final String KEY_STORE_LOG_IMAGES = "logimages";
    private static final String KEY_EXCLUDE_DISABLED = "excludedisabled";
    private static final String KEY_EXCLUDE_OWN = "excludemine";
    private static final String KEY_MAPFILE = "mfmapfile";
    private static final String KEY_SIGNATURE = "signature";
    private static final String KEY_GCVOTE_PASSWORD = "pass-vote";
    private static final String KEY_PASSWORD = "password";
    private static final String KEY_USERNAME = "username";
    private static final String KEY_MEMBER_STATUS = "memberstatus";
    private static final String KEY_COORD_INPUT_FORMAT = "coordinputformat";
    private static final String KEY_LOG_OFFLINE = "log_offline";
    private static final String KEY_LOAD_DIRECTION_IMG = "loaddirectionimg";
    private static final String KEY_GC_CUSTOM_DATE = "gccustomdate";
    private static final String KEY_SHOW_WAYPOINTS_THRESHOLD = "gcshowwaypointsthreshold";
    private static final String KEY_COOKIE_STORE = "cookiestore";
    private static final String KEY_OPEN_LAST_DETAILS_PAGE = "opendetailslastpage";
    private static final String KEY_LAST_DETAILS_PAGE = "lastdetailspage";
    private static final String KEY_DEFAULT_NAVIGATION_TOOL = "defaultNavigationTool";
    private static final String KEY_DEFAULT_NAVIGATION_TOOL_2 = "defaultNavigationTool2";
    private static final String KEY_LIVE_MAP_STRATEGY = "livemapstrategy";
    private static final String KEY_DEBUG = "debug";
    private static final String KEY_HIDE_LIVE_MAP_HINT = "hidelivemaphint";
    private static final String KEY_LIVE_MAP_HINT_SHOW_COUNT = "livemaphintshowcount";
    private static final String KEY_SETTINGS_VERSION = "settingsversion";
    private static final String KEY_DB_ON_SDCARD = "dbonsdcard";
    private static final String KEY_LAST_TRACKABLE_ACTION = "trackableaction";
    private static final String KEY_SHARE_AFTER_EXPORT = "shareafterexport";
    private static final String KEY_GPX_EXPORT_DIR = "gpxExportDir";
    private static final String KEY_RENDER_THEME_BASE_FOLDER = "renderthemepath";
    private static final String KEY_RENDER_THEME_FILE_PATH = "renderthemefile";
    private static final String KEY_GPX_IMPORT_DIR = "gpxImportDir";
    private static final String KEY_PLAIN_LOGS = "plainLogs";
    private static final String KEY_NATIVE_UA = "nativeUa";
    private static final String KEY_MAP_DIRECTORY = "mapDirectory";
    private static final String KEY_CONNECTOR_OC_ACTIVE = "connectorOCActive";
    private static final String KEY_CONNECTOR_OC_USER = "connectorOCUser";

    private final static int unitsMetric = 1;

    // twitter api keys
    private final static String keyConsumerPublic = CryptUtils.rot13("ESnsCvAv3kEupF1GCR3jGj");
    private final static String keyConsumerSecret = CryptUtils.rot13("7vQWceACV9umEjJucmlpFe9FCMZSeqIqfkQ2BnhV9x");

    private interface PrefRunnable {
        void edit(final Editor edit);
    }

    public enum coordInputFormatEnum {
        Plain,
        Deg,
        Min,
        Sec;

        static coordInputFormatEnum fromInt(int id) {
            final coordInputFormatEnum[] values = coordInputFormatEnum.values();
            if (id < 0 || id >= values.length) {
                return Min;
            }
            return values[id];
        }
    }

    private static String username = null;
    private static String password = null;

    private static final SharedPreferences sharedPrefs = PreferenceManager.getDefaultSharedPreferences(cgeoapplication.getInstance().getBaseContext());
    static {
        migrateSettings();
        Log.setDebugUnsaved(sharedPrefs.getBoolean(KEY_DEBUG, false));
    }

    // maps
    private static MapProvider mapProvider = null;

    private Settings() {
        // this class is not to be instantiated;
    }

    private static void migrateSettings() {
        // migrate from non standard file location and integer based boolean types
        if (sharedPrefs.getInt(KEY_SETTINGS_VERSION, 0) < 1) {
            final String oldPreferencesName = "cgeo.pref";
            final SharedPreferences old = cgeoapplication.getInstance().getSharedPreferences(oldPreferencesName, Context.MODE_PRIVATE);
            final Editor e = sharedPrefs.edit();

            e.putString(KEY_TEMP_TOKEN_SECRET, old.getString(KEY_TEMP_TOKEN_SECRET, null));
            e.putString(KEY_TEMP_TOKEN_PUBLIC, old.getString(KEY_TEMP_TOKEN_PUBLIC, null));
            e.putBoolean(KEY_HELP_SHOWN, old.getInt(KEY_HELP_SHOWN, 0) != 0);
            e.putFloat(KEY_ANYLONGITUDE, old.getFloat(KEY_ANYLONGITUDE, 0));
            e.putFloat(KEY_ANYLATITUDE, old.getFloat(KEY_ANYLATITUDE, 0));
            e.putBoolean(KEY_USE_OFFLINEMAPS, 0 != old.getInt(KEY_USE_OFFLINEMAPS, 1));
            e.putBoolean(KEY_USE_OFFLINEWPMAPS, 0 != old.getInt(KEY_USE_OFFLINEWPMAPS, 0));
            e.putString(KEY_WEB_DEVICE_CODE, old.getString(KEY_WEB_DEVICE_CODE, null));
            e.putString(KEY_WEBDEVICE_NAME, old.getString(KEY_WEBDEVICE_NAME, null));
            e.putBoolean(KEY_MAP_LIVE, old.getInt(KEY_MAP_LIVE, 1) != 0);
            e.putInt(KEY_MAP_SOURCE, old.getInt(KEY_MAP_SOURCE, 0));
            e.putBoolean(KEY_USE_TWITTER, 0 != old.getInt(KEY_USE_TWITTER, 0));
            e.putBoolean(KEY_SHOW_ADDRESS, 0 != old.getInt(KEY_SHOW_ADDRESS, 1));
            e.putBoolean(KEY_SHOW_CAPTCHA, old.getBoolean(KEY_SHOW_CAPTCHA, false));
            e.putBoolean(KEY_MAP_TRAIL, old.getInt(KEY_MAP_TRAIL, 1) != 0);
            e.putInt(KEY_LAST_MAP_ZOOM, old.getInt(KEY_LAST_MAP_ZOOM, 14));
            e.putBoolean(KEY_LIVE_LIST, 0 != old.getInt(KEY_LIVE_LIST, 1));
            e.putBoolean(KEY_METRIC_UNITS, old.getInt(KEY_METRIC_UNITS, unitsMetric) == unitsMetric);
            e.putBoolean(KEY_SKIN, old.getInt(KEY_SKIN, 0) != 0);
            e.putInt(KEY_LAST_USED_LIST, old.getInt(KEY_LAST_USED_LIST, StoredList.STANDARD_LIST_ID));
            e.putString(KEY_CACHE_TYPE, old.getString(KEY_CACHE_TYPE, CacheType.ALL.id));
            e.putString(KEY_TWITTER_TOKEN_SECRET, old.getString(KEY_TWITTER_TOKEN_SECRET, null));
            e.putString(KEY_TWITTER_TOKEN_PUBLIC, old.getString(KEY_TWITTER_TOKEN_PUBLIC, null));
            e.putInt(KEY_VERSION, old.getInt(KEY_VERSION, 0));
            e.putBoolean(KEY_LOAD_DESCRIPTION, 0 != old.getInt(KEY_LOAD_DESCRIPTION, 0));
            e.putBoolean(KEY_RATING_WANTED, old.getBoolean(KEY_RATING_WANTED, true));
            e.putBoolean(KEY_ELEVATION_WANTED, old.getBoolean(KEY_ELEVATION_WANTED, true));
            e.putBoolean(KEY_FRIENDLOGS_WANTED, old.getBoolean(KEY_FRIENDLOGS_WANTED, true));
            e.putBoolean(KEY_USE_ENGLISH, old.getBoolean(KEY_USE_ENGLISH, false));
            e.putBoolean(KEY_USE_COMPASS, 0 != old.getInt(KEY_USE_COMPASS, 1));
            e.putBoolean(KEY_AUTO_VISIT_TRACKABLES, old.getBoolean(KEY_AUTO_VISIT_TRACKABLES, false));
            e.putBoolean(KEY_AUTO_INSERT_SIGNATURE, old.getBoolean(KEY_AUTO_INSERT_SIGNATURE, false));
            e.putInt(KEY_ALTITUDE_CORRECTION, old.getInt(KEY_ALTITUDE_CORRECTION, 0));
            e.putBoolean(KEY_STORE_LOG_IMAGES, old.getBoolean(KEY_STORE_LOG_IMAGES, false));
            e.putBoolean(KEY_EXCLUDE_DISABLED, 0 != old.getInt(KEY_EXCLUDE_DISABLED, 0));
            e.putBoolean(KEY_EXCLUDE_OWN, 0 != old.getInt(KEY_EXCLUDE_OWN, 0));
            e.putString(KEY_MAPFILE, old.getString(KEY_MAPFILE, null));
            e.putString(KEY_SIGNATURE, old.getString(KEY_SIGNATURE, null));
            e.putString(KEY_GCVOTE_PASSWORD, old.getString(KEY_GCVOTE_PASSWORD, null));
            e.putString(KEY_PASSWORD, old.getString(KEY_PASSWORD, null));
            e.putString(KEY_USERNAME, old.getString(KEY_USERNAME, null));
            e.putString(KEY_MEMBER_STATUS, old.getString(KEY_MEMBER_STATUS, ""));
            e.putInt(KEY_COORD_INPUT_FORMAT, old.getInt(KEY_COORD_INPUT_FORMAT, 0));
            e.putBoolean(KEY_LOG_OFFLINE, old.getBoolean(KEY_LOG_OFFLINE, false));
            e.putBoolean(KEY_LOAD_DIRECTION_IMG, old.getBoolean(KEY_LOAD_DIRECTION_IMG, true));
            e.putString(KEY_GC_CUSTOM_DATE, old.getString(KEY_GC_CUSTOM_DATE, null));
            e.putInt(KEY_SHOW_WAYPOINTS_THRESHOLD, old.getInt(KEY_SHOW_WAYPOINTS_THRESHOLD, 0));
            e.putString(KEY_COOKIE_STORE, old.getString(KEY_COOKIE_STORE, null));
            e.putBoolean(KEY_OPEN_LAST_DETAILS_PAGE, old.getBoolean(KEY_OPEN_LAST_DETAILS_PAGE, false));
            e.putInt(KEY_LAST_DETAILS_PAGE, old.getInt(KEY_LAST_DETAILS_PAGE, 1));
            e.putInt(KEY_DEFAULT_NAVIGATION_TOOL, old.getInt(KEY_DEFAULT_NAVIGATION_TOOL, NavigationAppsEnum.COMPASS.id));
            e.putInt(KEY_DEFAULT_NAVIGATION_TOOL_2, old.getInt(KEY_DEFAULT_NAVIGATION_TOOL_2, NavigationAppsEnum.INTERNAL_MAP.id));
            e.putInt(KEY_LIVE_MAP_STRATEGY, old.getInt(KEY_LIVE_MAP_STRATEGY, Strategy.AUTO.id));
            e.putBoolean(KEY_DEBUG, old.getBoolean(KEY_DEBUG, false));
            e.putBoolean(KEY_HIDE_LIVE_MAP_HINT, old.getInt(KEY_HIDE_LIVE_MAP_HINT, 0) != 0);
            e.putInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, old.getInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, 0));

            e.putInt(KEY_SETTINGS_VERSION, 1); // mark migrated
            e.commit();
        }
    }

    public static void setLanguage(boolean useEnglish) {
        final Configuration config = new Configuration();
        config.locale = useEnglish ? new Locale("en") : Locale.getDefault();
        final Resources resources = cgeoapplication.getInstance().getResources();
        resources.updateConfiguration(config, resources.getDisplayMetrics());
    }

    public static boolean isLogin() {
        final String preUsername = sharedPrefs.getString(KEY_USERNAME, null);
        final String prePassword = sharedPrefs.getString(KEY_PASSWORD, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    /**
     * Get login and password information.
     *
     * @return a pair (login, password) or null if no valid information is stored
     */
    public static ImmutablePair<String, String> getLogin() {
        if (username == null || password == null) {
            final String preUsername = sharedPrefs.getString(KEY_USERNAME, null);
            final String prePassword = sharedPrefs.getString(KEY_PASSWORD, null);

            if (preUsername == null || prePassword == null) {
                return null;
            }

            username = preUsername;
            password = prePassword;
        }
        return new ImmutablePair<String, String>(username, password);
    }

    public static String getUsername() {
        return username != null ? username : sharedPrefs.getString(KEY_USERNAME, null);
    }

    public static boolean setLogin(final String username, final String password) {
        Settings.username = username;
        Settings.password = password;
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
                    // erase username and password
                    edit.remove(KEY_USERNAME);
                    edit.remove(KEY_PASSWORD);
                } else {
                    // save username and password
                    edit.putString(KEY_USERNAME, username);
                    edit.putString(KEY_PASSWORD, password);
                }
            }
        });
    }

    public static boolean isPremiumMember() {
        // Basic Member, Premium Member, ???
        String memberStatus = Settings.getMemberStatus();
        if (memberStatus == null) {
            return false;
        }
        return GCConstants.MEMBER_STATUS_PM.equalsIgnoreCase(memberStatus);
    }

    public static String getMemberStatus() {
        return sharedPrefs.getString(KEY_MEMBER_STATUS, "");
    }

    public static boolean setMemberStatus(final String memberStatus) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(memberStatus)) {
                    edit.remove(KEY_MEMBER_STATUS);
                } else {
                    edit.putString(KEY_MEMBER_STATUS, memberStatus);
                }
            }
        });
    }

    public static boolean isOCConnectorActive() {
        return sharedPrefs.getBoolean(KEY_CONNECTOR_OC_ACTIVE, false);
    }

    public static boolean setOCConnectorActive(final boolean isActive) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_CONNECTOR_OC_ACTIVE, isActive);
            }
        });
    }

    public static String getOCConnectorUserName() {
        String ocConnectorUser = sharedPrefs.getString(KEY_CONNECTOR_OC_USER, null);
        if (StringUtils.isBlank(ocConnectorUser)) {
            return StringUtils.EMPTY;
        }
        return ocConnectorUser;
    }

    public static boolean setOCConnectorUserName(final String userName) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(userName)) {
                    edit.remove(KEY_CONNECTOR_OC_USER);
                } else {
                    edit.putString(KEY_CONNECTOR_OC_USER, userName);
                }
            }
        });
    }

    public static boolean isGCvoteLogin() {
        final String preUsername = sharedPrefs.getString(KEY_USERNAME, null);
        final String prePassword = sharedPrefs.getString(KEY_GCVOTE_PASSWORD, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    public static boolean setGCvoteLogin(final String password) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(password)) {
                    // erase password
                    edit.remove(KEY_GCVOTE_PASSWORD);
                } else {
                    // save password
                    edit.putString(KEY_GCVOTE_PASSWORD, password);
                }
            }
        });
    }

    public static ImmutablePair<String, String> getGCvoteLogin() {
        final String username = sharedPrefs.getString(KEY_USERNAME, null);
        final String password = sharedPrefs.getString(KEY_GCVOTE_PASSWORD, null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return null;
        }

        return new ImmutablePair<String, String>(username, password);
    }

    public static boolean setSignature(final String signature) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(signature)) {
                    // erase signature
                    edit.remove(KEY_SIGNATURE);
                } else {
                    // save signature
                    edit.putString(KEY_SIGNATURE, signature);
                }
            }
        });
    }

    public static String getSignature() {
        return sharedPrefs.getString(KEY_SIGNATURE, null);
    }

    public static boolean setCookieStore(final String cookies) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(final Editor edit) {
                if (StringUtils.isBlank(cookies)) {
                    // erase cookies
                    edit.remove(KEY_COOKIE_STORE);
                } else {
                    // save cookies
                    edit.putString(KEY_COOKIE_STORE, cookies);
                }
            }
        });
    }

    public static String getCookieStore() {
        return sharedPrefs.getString(KEY_COOKIE_STORE, null);
    }

    /**
     * @param cacheType
     *            The cache type used for future filtering
     */
    public static void setCacheType(final CacheType cacheType) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                if (cacheType == null) {
                    edit.remove(KEY_CACHE_TYPE);
                } else {
                    edit.putString(KEY_CACHE_TYPE, cacheType.id);
                }
            }
        });
    }

    public static void setLiveMap(final boolean live) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_MAP_LIVE, live);
            }
        });
    }

    public static int getLastList() {
        return sharedPrefs.getInt(KEY_LAST_USED_LIST, StoredList.STANDARD_LIST_ID);
    }

    public static void saveLastList(final int listId) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_USED_LIST, listId);
            }
        });
    }

    public static void setWebNameCode(final String name, final String code) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {

                edit.putString(KEY_WEBDEVICE_NAME, name);
                edit.putString(KEY_WEB_DEVICE_CODE, code);
            }
        });
    }

    public static MapProvider getMapProvider() {
        if (mapProvider == null) {
            mapProvider = getMapSource().getMapProvider();
        }
        return mapProvider;
    }

    public static String getMapFile() {
        return sharedPrefs.getString(KEY_MAPFILE, null);
    }

    public static boolean setMapFile(final String mapFile) {
        boolean result = editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_MAPFILE, mapFile);
            }
        });
        if (mapFile != null) {
            setMapFileDirectory(new File(mapFile).getParent());
        }
        return result;
    }

    public static String getMapFileDirectory() {
        final String mapDir = sharedPrefs.getString(KEY_MAP_DIRECTORY, null);
        if (mapDir != null) {
            return mapDir;
        }
        final String mapFile = getMapFile();
        if (mapFile != null) {
            return new File(mapFile).getParent();
        }
        return null;
    }

    public static boolean setMapFileDirectory(final String mapFileDirectory) {
        return editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_MAP_DIRECTORY, mapFileDirectory);
                MapsforgeMapProvider.getInstance().updateOfflineMaps();
            }
        });
    }

    public static boolean isValidMapFile() {
        return isValidMapFile(getMapFile());
    }

    public static boolean isValidMapFile(final String mapFileIn) {
        return MapsforgeMapProvider.isValidMapFile(mapFileIn);
    }

    public static coordInputFormatEnum getCoordInputFormat() {
        return coordInputFormatEnum.fromInt(sharedPrefs.getInt(KEY_COORD_INPUT_FORMAT, 0));
    }

    public static void setCoordInputFormat(final coordInputFormatEnum format) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_COORD_INPUT_FORMAT, format.ordinal());
            }
        });
    }

    static void setLogOffline(final boolean offline) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LOG_OFFLINE, offline);
            }
        });
    }

    public static boolean getLogOffline() {
        return sharedPrefs.getBoolean(KEY_LOG_OFFLINE, false);
    }

    static void setLoadDirImg(final boolean value) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LOAD_DIRECTION_IMG, value);
            }
        });
    }

    public static boolean getLoadDirImg() {
        return !isPremiumMember() && sharedPrefs.getBoolean(KEY_LOAD_DIRECTION_IMG, true);
    }

    public static void setGcCustomDate(final String format) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_GC_CUSTOM_DATE, format);
            }
        });
    }

    /**
     * @return User selected date format on GC.com
     * @see Login#gcCustomDateFormats
     */
    public static String getGcCustomDate() {
        return sharedPrefs.getString(KEY_GC_CUSTOM_DATE, null);
    }

    public static boolean isExcludeMyCaches() {
        return sharedPrefs.getBoolean(KEY_EXCLUDE_OWN, false);
    }

    /**
     * edit some settings without knowing how to get the settings editor or how to commit
     *
     * @param runnable
     * @return
     */
    private static boolean editSharedSettings(final PrefRunnable runnable) {
        final SharedPreferences.Editor prefsEdit = sharedPrefs.edit();
        runnable.edit(prefsEdit);
        return prefsEdit.commit();
    }

    public static void setExcludeMine(final boolean exclude) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_EXCLUDE_OWN, exclude);
            }
        });
    }

    public static void setUseEnglish(final boolean english) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_ENGLISH, english);
                setLanguage(english);
            }
        });
    }

    public static boolean isUseEnglish() {
        return sharedPrefs.getBoolean(KEY_USE_ENGLISH, false);
    }

    public static boolean isShowAddress() {
        return sharedPrefs.getBoolean(KEY_SHOW_ADDRESS, true);
    }

    public static void setShowAddress(final boolean showAddress) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SHOW_ADDRESS, showAddress);
            }
        });
    }

    public static boolean isShowCaptcha() {
        return !isPremiumMember() && sharedPrefs.getBoolean(KEY_SHOW_CAPTCHA, false);
    }

    public static void setShowCaptcha(final boolean showCaptcha) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SHOW_CAPTCHA, showCaptcha);
            }
        });
    }

    public static boolean isExcludeDisabledCaches() {
        return sharedPrefs.getBoolean(KEY_EXCLUDE_DISABLED, false);
    }

    public static void setExcludeDisabledCaches(final boolean exclude) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_EXCLUDE_DISABLED, exclude);
            }
        });
    }

    public static boolean isStoreOfflineMaps() {
        return sharedPrefs.getBoolean(KEY_USE_OFFLINEMAPS, true);
    }

    public static void setStoreOfflineMaps(final boolean offlineMaps) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_OFFLINEMAPS, offlineMaps);
            }
        });
    }

    public static boolean isStoreOfflineWpMaps() {
        return sharedPrefs.getBoolean(KEY_USE_OFFLINEWPMAPS, false);
    }

    public static void setStoreOfflineWpMaps(final boolean offlineMaps) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_OFFLINEWPMAPS, offlineMaps);
            }
        });
    }

    public static boolean isStoreLogImages() {
        return sharedPrefs.getBoolean(KEY_STORE_LOG_IMAGES, false);
    }

    public static void setStoreLogImages(final boolean storeLogImages) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_STORE_LOG_IMAGES, storeLogImages);
            }
        });
    }

    public static boolean isAutoLoadDescription() {
        return sharedPrefs.getBoolean(KEY_LOAD_DESCRIPTION, false);
    }

    public static void setAutoLoadDesc(final boolean autoLoad) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LOAD_DESCRIPTION, autoLoad);
            }
        });
    }

    public static boolean isRatingWanted() {
        return sharedPrefs.getBoolean(KEY_RATING_WANTED, true);
    }

    public static void setRatingWanted(final boolean ratingWanted) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_RATING_WANTED, ratingWanted);
            }
        });
    }

    public static boolean isElevationWanted() {
        return sharedPrefs.getBoolean(KEY_ELEVATION_WANTED, true);
    }

    public static void setElevationWanted(final boolean elevationWanted) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_ELEVATION_WANTED, elevationWanted);
            }
        });
    }

    public static boolean isFriendLogsWanted() {
        if (!isLogin()) {
            // don't show a friends log if the user is anonymous
            return false;
        }
        return sharedPrefs.getBoolean(KEY_FRIENDLOGS_WANTED, true);
    }

    public static void setFriendLogsWanted(final boolean friendLogsWanted) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_FRIENDLOGS_WANTED, friendLogsWanted);
            }
        });
    }

    public static boolean isLiveList() {
        return sharedPrefs.getBoolean(KEY_LIVE_LIST, true);
    }

    public static void setLiveList(final boolean liveList) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LIVE_LIST, liveList);
            }
        });
    }

    public static boolean isTrackableAutoVisit() {
        return sharedPrefs.getBoolean(KEY_AUTO_VISIT_TRACKABLES, false);
    }

    public static void setTrackableAutoVisit(final boolean autoVisit) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_AUTO_VISIT_TRACKABLES, autoVisit);
            }
        });
    }

    public static boolean isAutoInsertSignature() {
        return sharedPrefs.getBoolean(KEY_AUTO_INSERT_SIGNATURE, false);
    }

    public static void setAutoInsertSignature(final boolean autoInsert) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_AUTO_INSERT_SIGNATURE, autoInsert);
            }
        });
    }

    public static boolean isUseMetricUnits() {
        return sharedPrefs.getBoolean(KEY_METRIC_UNITS, true);
    }

    public static void setUseMetricUnits(final boolean metric) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_METRIC_UNITS, metric);
            }
        });
    }

    public static boolean isLiveMap() {
        return sharedPrefs.getBoolean(KEY_MAP_LIVE, true);
    }

    public static boolean isMapTrail() {
        return sharedPrefs.getBoolean(KEY_MAP_TRAIL, true);
    }

    public static void setMapTrail(final boolean showTrail) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_MAP_TRAIL, showTrail);
            }
        });
    }

    public static int getMapZoom() {
        return sharedPrefs.getInt(KEY_LAST_MAP_ZOOM, 14);
    }

    public static void setMapZoom(final int mapZoomLevel) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_MAP_ZOOM, mapZoomLevel);
            }
        });
    }

    public static GeoPointImpl getMapCenter() {
        return getMapProvider().getMapItemFactory()
                .getGeoPointBase(new Geopoint(sharedPrefs.getInt(KEY_LAST_MAP_LAT, 0) / 1e6,
                        sharedPrefs.getInt(KEY_LAST_MAP_LON, 0) / 1e6));
    }

    public static void setMapCenter(final GeoPointImpl mapViewCenter) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_MAP_LAT, mapViewCenter.getLatitudeE6());
                edit.putInt(KEY_LAST_MAP_LON, mapViewCenter.getLongitudeE6());
            }
        });
    }

    public static MapSource getMapSource() {
        final int id = getConvertedMapId();
        final MapSource map = MapProviderFactory.getMapSource(id);
        if (map != null) {
            // don't use offline maps if the map file is not valid
            if ((!(map instanceof OfflineMapSource)) || (isValidMapFile())) {
                return map;
            }
        }
        // fallback to first available map
        return MapProviderFactory.getDefaultSource();
    }

    private final static int GOOGLEMAP_BASEID = 30;
    private final static int MAP = 1;
    private final static int SATELLITE = 2;

    private final static int MFMAP_BASEID = 40;
    private final static int MAPNIK = 1;
    private final static int CYCLEMAP = 3;
    private final static int OFFLINE = 4;

    /**
     * convert old preference ids for maps (based on constant values) into new hash based ids
     *
     * @return
     */
    private static int getConvertedMapId() {
        final int id = sharedPrefs.getInt(KEY_MAP_SOURCE, 0);
        switch (id) {
            case GOOGLEMAP_BASEID + MAP:
                return GoogleMapProvider.GOOGLE_MAP_ID.hashCode();
            case GOOGLEMAP_BASEID + SATELLITE:
                return GoogleMapProvider.GOOGLE_SATELLITE_ID.hashCode();
            case MFMAP_BASEID + MAPNIK:
                return MapsforgeMapProvider.MAPSFORGE_MAPNIK_ID.hashCode();
            case MFMAP_BASEID + CYCLEMAP:
                return MapsforgeMapProvider.MAPSFORGE_CYCLEMAP_ID.hashCode();
            case MFMAP_BASEID + OFFLINE: {
                final String mapFile = Settings.getMapFile();
                if (StringUtils.isNotEmpty(mapFile)) {
                    return mapFile.hashCode();
                }
                break;
            }
            default:
                break;
        }
        return id;
    }

    public static void setMapSource(final MapSource newMapSource) {
        if (!MapProviderFactory.isSameActivity(getMapSource(), newMapSource)) {
            mapProvider = null;
        }
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_MAP_SOURCE, newMapSource.getNumericalId());
            }
        });
        if (newMapSource instanceof OfflineMapSource) {
            setMapFile(((OfflineMapSource) newMapSource).getFileName());
        }
    }

    public static void setAnyCoordinates(final Geopoint coords) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (null != coords) {
                    edit.putFloat(KEY_ANYLATITUDE, (float) coords.getLatitude());
                    edit.putFloat(KEY_ANYLONGITUDE, (float) coords.getLongitude());
                } else {
                    edit.remove(KEY_ANYLATITUDE);
                    edit.remove(KEY_ANYLONGITUDE);
                }
            }
        });

    }

    public static Geopoint getAnyCoordinates() {
        if (sharedPrefs.contains(KEY_ANYLATITUDE) && sharedPrefs.contains(KEY_ANYLONGITUDE)) {
            float lat = sharedPrefs.getFloat(KEY_ANYLATITUDE, 0);
            float lon = sharedPrefs.getFloat(KEY_ANYLONGITUDE, 0);
            return new Geopoint(lat, lon);
        }
        return null;
    }

    public static boolean isUseCompass() {
        return sharedPrefs.getBoolean(KEY_USE_COMPASS, true);
    }

    public static void setUseCompass(final boolean useCompass) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_COMPASS, useCompass);
            }
        });
    }

    public static boolean isHelpShown() {
        return sharedPrefs.getBoolean(KEY_HELP_SHOWN, false);
    }

    public static void setHelpShown() {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_HELP_SHOWN, true);
            }
        });
    }

    public static boolean isLightSkin() {
        return sharedPrefs.getBoolean(KEY_SKIN, false);
    }

    public static void setLightSkin(final boolean lightSkin) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SKIN, lightSkin);
            }
        });
    }

    public static String getKeyConsumerPublic() {
        return keyConsumerPublic;
    }

    public static String getKeyConsumerSecret() {
        return keyConsumerSecret;
    }

    public static int getAltCorrection() {
        return sharedPrefs.getInt(KEY_ALTITUDE_CORRECTION, 0);
    }

    public static boolean setAltCorrection(final int altitude) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_ALTITUDE_CORRECTION, altitude);
            }
        });
    }

    public static String getWebDeviceCode() {
        return sharedPrefs.getString(KEY_WEB_DEVICE_CODE, null);
    }

    public static String getWebDeviceName() {
        return sharedPrefs.getString(KEY_WEBDEVICE_NAME, null);
    }

    /**
     * @return The cache type used for filtering or ALL if no filter is active. Returns never null
     */
    public static CacheType getCacheType() {
        return CacheType.getById(sharedPrefs.getString(KEY_CACHE_TYPE, CacheType.ALL.id));
    }

    /**
     * The Threshold for the showing of child waypoints
     *
     * @return
     */

    public static int getWayPointsThreshold() {
        return sharedPrefs.getInt(KEY_SHOW_WAYPOINTS_THRESHOLD, 0);
    }

    public static void setShowWaypointsThreshold(final int threshold) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_SHOW_WAYPOINTS_THRESHOLD, threshold);
            }
        });
    }

    public static boolean isUseTwitter() {
        return sharedPrefs.getBoolean(KEY_USE_TWITTER, false);
    }

    public static void setUseTwitter(final boolean useTwitter) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_TWITTER, useTwitter);
            }
        });
    }

    public static boolean isTwitterLoginValid() {
        return !StringUtils.isBlank(getTokenPublic()) && !StringUtils.isBlank(getTokenSecret());
    }

    public static String getTokenPublic() {
        return sharedPrefs.getString(KEY_TWITTER_TOKEN_PUBLIC, null);
    }

    public static String getTokenSecret() {
        return sharedPrefs.getString(KEY_TWITTER_TOKEN_SECRET, null);

    }

    public static int getVersion() {
        return sharedPrefs.getInt(KEY_VERSION, 0);
    }

    public static void setTwitterTokens(final String tokenPublic, final String tokenSecret, boolean enableTwitter) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_TWITTER_TOKEN_PUBLIC, tokenPublic);
                edit.putString(KEY_TWITTER_TOKEN_SECRET, tokenSecret);
                if (tokenPublic != null) {
                    edit.remove(KEY_TEMP_TOKEN_PUBLIC);
                    edit.remove(KEY_TEMP_TOKEN_SECRET);
                }
            }
        });
        setUseTwitter(enableTwitter);
    }

    public static void setTwitterTempTokens(final String tokenPublic, final String tokenSecret) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_TEMP_TOKEN_PUBLIC, tokenPublic);
                edit.putString(KEY_TEMP_TOKEN_SECRET, tokenSecret);
            }
        });
    }

    public static ImmutablePair<String, String> getTempToken() {
        String tokenPublic = sharedPrefs.getString(KEY_TEMP_TOKEN_PUBLIC, null);
        String tokenSecret = sharedPrefs.getString(KEY_TEMP_TOKEN_SECRET, null);
        return new ImmutablePair<String, String>(tokenPublic, tokenSecret);
    }

    public static void setVersion(final int version) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_VERSION, version);
            }
        });
    }

    public static boolean isOpenLastDetailsPage() {
        return sharedPrefs.getBoolean(KEY_OPEN_LAST_DETAILS_PAGE, false);
    }

    public static void setOpenLastDetailsPage(final boolean openLastPage) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_OPEN_LAST_DETAILS_PAGE, openLastPage);
            }
        });
    }

    public static int getLastDetailsPage() {
        return sharedPrefs.getInt(KEY_LAST_DETAILS_PAGE, 1);
    }

    public static void setLastDetailsPage(final int index) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_DETAILS_PAGE, index);
            }
        });
    }

    public static int getDefaultNavigationTool() {
        return sharedPrefs.getInt(KEY_DEFAULT_NAVIGATION_TOOL, NavigationAppsEnum.COMPASS.id);
    }

    public static void setDefaultNavigationTool(final int defaultNavigationTool) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_DEFAULT_NAVIGATION_TOOL, defaultNavigationTool);
            }
        });
    }

    public static int getDefaultNavigationTool2() {
        return sharedPrefs.getInt(KEY_DEFAULT_NAVIGATION_TOOL_2, NavigationAppsEnum.INTERNAL_MAP.id);
    }

    public static void setDefaultNavigationTool2(final int defaultNavigationTool) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_DEFAULT_NAVIGATION_TOOL_2, defaultNavigationTool);
            }
        });
    }

    public static Strategy getLiveMapStrategy() {
        return Strategy.getById(sharedPrefs.getInt(KEY_LIVE_MAP_STRATEGY, Strategy.AUTO.id));
    }

    public static void setLiveMapStrategy(final Strategy strategy) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LIVE_MAP_STRATEGY, strategy.id);
            }
        });
    }

    public static boolean isDebug() {
        return Log.isDebug();
    }

    public static void setDebug(final boolean debug) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_DEBUG, debug);
            }
        });
        Log.setDebugUnsaved(debug);
    }

    public static boolean getHideLiveMapHint() {
        return sharedPrefs.getBoolean(KEY_HIDE_LIVE_MAP_HINT, false);
    }

    public static void setHideLiveHint(final boolean hide) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_HIDE_LIVE_MAP_HINT, hide);
            }
        });
    }

    public static int getLiveMapHintShowCount() {
        return sharedPrefs.getInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, 0);
    }

    public static void setLiveMapHintShowCount(final int showCount) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, showCount);
            }
        });
    }

    public static boolean isDbOnSDCard() {
        return sharedPrefs.getBoolean(KEY_DB_ON_SDCARD, false);
    }

    public static void setDbOnSDCard(final boolean dbOnSDCard) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_DB_ON_SDCARD, dbOnSDCard);
            }
        });
    }

    public static String getGpxExportDir() {
        return sharedPrefs.getString(KEY_GPX_EXPORT_DIR, Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static void setGpxExportDir(final String gpxExportDir) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_GPX_EXPORT_DIR, gpxExportDir);
            }
        });
    }

    public static String getGpxImportDir() {
        return sharedPrefs.getString(KEY_GPX_IMPORT_DIR, Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static void setGpxImportDir(final String gpxImportDir) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_GPX_IMPORT_DIR, gpxImportDir);
            }
        });
    }

    public static boolean getShareAfterExport() {
        return sharedPrefs.getBoolean(KEY_SHARE_AFTER_EXPORT, true);
    }

    public static void setShareAfterExport(final boolean shareAfterExport) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SHARE_AFTER_EXPORT, shareAfterExport);
            }
        });
    }

    public static int getTrackableAction() {
        return sharedPrefs.getInt(KEY_LAST_TRACKABLE_ACTION, LogType.RETRIEVED_IT.id);
    }

    public static void setTrackableAction(final int trackableAction) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_TRACKABLE_ACTION, trackableAction);
            }
        });
    }

    public static String getCustomRenderThemeBaseFolder() {
        return sharedPrefs.getString(KEY_RENDER_THEME_BASE_FOLDER, "");
    }

    public static boolean setCustomRenderThemeBaseFolder(final String customRenderThemeBaseFolder) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_RENDER_THEME_BASE_FOLDER, customRenderThemeBaseFolder);
            }
        });
    }

    public static String getCustomRenderThemeFilePath() {
        return sharedPrefs.getString(KEY_RENDER_THEME_FILE_PATH, "");
    }

    public static void setCustomRenderThemeFile(final String customRenderThemeFile) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_RENDER_THEME_FILE_PATH, customRenderThemeFile);
            }
        });
    }

    public static File[] getMapThemeFiles() {

        File directory = new File(Settings.getCustomRenderThemeBaseFolder());

        List<File> result = new ArrayList<File>();

        FileUtils.listDir(result, directory, new ExtensionsBasedFileSelector(new String[] { "xml" }), null);

        return result.toArray(new File[result.size()]);
    }

    private static class ExtensionsBasedFileSelector extends FileSelector {

        private final String[] extensions;

        public ExtensionsBasedFileSelector(String[] extensions) {
            this.extensions = extensions;
        }

        @Override
        public boolean isSelected(File file) {
            String filename = file.getName();
            for (String ext : extensions) {
                if (StringUtils.endsWithIgnoreCase(filename, ext)) {
                    return true;
                }
            }
            return false;
        }

        @Override
        public boolean shouldEnd() {
            return false;
        }
    }

    public static String getPreferencesName() {
        // there is currently no Android API to get the file name of the shared preferences
        return cgeoapplication.getInstance().getPackageName() + "_preferences";
    }

    public static boolean getPlainLogs() {
        return sharedPrefs.getBoolean(KEY_PLAIN_LOGS, false);
    }

    public static void setPlainLogs(final boolean plainLogs) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_PLAIN_LOGS, plainLogs);
            }
        });
    }

    public static boolean getUseNativeUa() {
        return sharedPrefs.getBoolean(KEY_NATIVE_UA, false);
    }

    public static void setUseNativeUa(final boolean useNativeUa) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_NATIVE_UA, useNativeUa);
            }
        });
    }
}
!@#$%
20190527_000946,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_b13452
package cgeo.geocaching;

import cgeo.calendar.ICalendar;
import cgeo.geocaching.activity.AbstractViewPagerActivity;
import cgeo.geocaching.activity.Progress;
import cgeo.geocaching.apps.cache.navi.NavigationAppFactory;
import cgeo.geocaching.compatibility.Compatibility;
import cgeo.geocaching.connector.ConnectorFactory;
import cgeo.geocaching.connector.IConnector;
import cgeo.geocaching.connector.gc.GCConnector;
import cgeo.geocaching.enumerations.CacheAttribute;
import cgeo.geocaching.enumerations.LoadFlags;
import cgeo.geocaching.enumerations.LoadFlags.SaveFlag;
import cgeo.geocaching.enumerations.LogType;
import cgeo.geocaching.enumerations.WaypointType;
import cgeo.geocaching.geopoint.GeopointFormatter;
import cgeo.geocaching.geopoint.Units;
import cgeo.geocaching.network.HtmlImage;
import cgeo.geocaching.network.Network;
import cgeo.geocaching.network.Parameters;
import cgeo.geocaching.ui.AbstractCachingPageViewCreator;
import cgeo.geocaching.ui.CacheDetailsCreator;
import cgeo.geocaching.ui.DecryptTextClickListener;
import cgeo.geocaching.ui.EditorDialog;
import cgeo.geocaching.ui.Formatter;
import cgeo.geocaching.ui.ImagesList;
import cgeo.geocaching.ui.ImagesList.ImageType;
import cgeo.geocaching.ui.LoggingUI;
import cgeo.geocaching.utils.BaseUtils;
import cgeo.geocaching.utils.CancellableHandler;
import cgeo.geocaching.utils.ClipboardUtils;
import cgeo.geocaching.utils.CryptUtils;
import cgeo.geocaching.utils.GeoDirHandler;
import cgeo.geocaching.utils.HtmlUtils;
import cgeo.geocaching.utils.ImageHelper;
import cgeo.geocaching.utils.Log;
import cgeo.geocaching.utils.MatcherWrapper;
import cgeo.geocaching.utils.TranslationUtils;
import cgeo.geocaching.utils.UnknownTagsHandler;

import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang3.StringEscapeUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.apache.commons.lang3.tuple.Pair;

import android.R.color;
import android.app.Activity;
import android.app.AlertDialog;
import android.app.ProgressDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.graphics.Bitmap;
import android.graphics.Typeface;
import android.graphics.drawable.BitmapDrawable;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.text.Editable;
import android.text.Html;
import android.text.Spannable;
import android.text.Spanned;
import android.text.format.DateUtils;
import android.text.method.LinkMovementMethod;
import android.text.style.ForegroundColorSpan;
import android.text.style.StrikethroughSpan;
import android.text.style.StyleSpan;
import android.view.ContextMenu;
import android.view.Menu;
import android.view.MenuItem;
import android.view.SubMenu;
import android.view.View;
import android.view.View.OnLongClickListener;
import android.view.ViewGroup;
import android.view.ViewGroup.LayoutParams;
import android.view.ViewParent;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.ArrayAdapter;
import android.widget.Button;
import android.widget.FrameLayout;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.ListView;
import android.widget.RadioButton;
import android.widget.ScrollView;
import android.widget.TextView;
import android.widget.TextView.BufferType;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.EnumSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Map.Entry;
import java.util.regex.Pattern;

/**
 * Activity to handle all single-cache-stuff.
 *
 * e.g. details, description, logs, waypoints, inventory...
 */
public class CacheDetailActivity extends AbstractViewPagerActivity<CacheDetailActivity.Page> {

    private static final int MENU_FIELD_COPY = 1;
    private static final int MENU_FIELD_TRANSLATE = 2;
    private static final int MENU_FIELD_TRANSLATE_EN = 3;
    private static final int MENU_FIELD_SHARE = 4;
    private static final int MENU_SHARE = 12;
    private static final int MENU_CALENDAR = 11;
    private static final int MENU_CACHES_AROUND = 10;
    private static final int MENU_BROWSER = 7;
    private static final int MENU_DEFAULT_NAVIGATION = 13;

    private static final int CONTEXT_MENU_WAYPOINT_EDIT = 1234;
    private static final int CONTEXT_MENU_WAYPOINT_DUPLICATE = 1235;
    private static final int CONTEXT_MENU_WAYPOINT_DELETE = 1236;
    private static final int CONTEXT_MENU_WAYPOINT_NAVIGATE = 1238;
    private static final int CONTEXT_MENU_WAYPOINT_CACHES_AROUND = 1239;
    private static final int CONTEXT_MENU_WAYPOINT_DEFAULT_NAVIGATION = 1240;
    private static final int CONTEXT_MENU_WAYPOINT_RESET_ORIGINAL_CACHE_COORDINATES = 1241;

    private static final Pattern DARK_COLOR_PATTERN = Pattern.compile(Pattern.quote("color=\"#") + "(0[0-9]){3}" + "\"");

    private cgCache cache;
    private final Progress progress = new Progress();
    private SearchResult search;

    private final GeoDirHandler locationUpdater = new GeoDirHandler() {
        @Override
        public void updateGeoData(final IGeoData geo) {
            if (cacheDistanceView == null) {
                return;
            }

            try {
                final StringBuilder dist = new StringBuilder();

                if (geo.getCoords() != null && cache != null && cache.getCoords() != null) {
                    dist.append(Units.getDistanceFromKilometers(geo.getCoords().distanceTo(cache.getCoords())));
                }

                if (cache != null && cache.getElevation() != null) {
                    if (geo.getAltitude() != 0.0) {
                        final float diff = (float) (cache.getElevation() - geo.getAltitude());
                        dist.append(' ').append(Units.getElevation(diff));
                    }
                }

                cacheDistanceView.setText(dist.toString());
                cacheDistanceView.bringToFront();
            } catch (Exception e) {
                Log.w("Failed to update location.");
            }
        }
    };

    private CharSequence clickedItemText = null;
    private int contextMenuWPIndex = -1;

    /**
     * If another activity is called and can modify the data of this activity, we refresh it on resume.
     */
    private boolean refreshOnResume = false;

    // some views that must be available from everywhere // TODO: Reference can block GC?
    private TextView cacheDistanceView;

    private Handler cacheChangeNotificationHandler = new Handler() {
        @Override
        public void handleMessage(Message msg) {
            notifyDataSetChanged();
        }
    };
    protected ImagesList imagesList;

    public CacheDetailActivity() {
        // identifier for manual
        super("c:geolocation-cache-details");
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        // initialize the main view and set a default title
        setTheme();
        setContentView(R.layout.cacheview);
        setTitle(res.getString(R.string.cache));

        String geocode = null;

        // TODO Why can it happen that search is not null? onCreate should be called only once and it is not set before.
        if (search != null) {
            cache = search.getFirstCacheFromResult(LoadFlags.LOAD_ALL_DB_ONLY);
            if (cache != null && cache.getGeocode() != null) {
                geocode = cache.getGeocode();
            }
        }

        // get parameters
        final Bundle extras = getIntent().getExtras();
        final Uri uri = getIntent().getData();

        // try to get data from extras
        String name = null;
        String guid = null;
        if (geocode == null && extras != null) {
            geocode = extras.getString("geocode");
            name = extras.getString("name");
            guid = extras.getString("guid");
        }

        // try to get data from URI
        if (geocode == null && guid == null && uri != null) {
            String uriHost = uri.getHost().toLowerCase(Locale.US);
            String uriPath = uri.getPath().toLowerCase(Locale.US);
            String uriQuery = uri.getQuery();

            if (uriQuery != null) {
                Log.i("Opening URI: " + uriHost + uriPath + "?" + uriQuery);
            } else {
                Log.i("Opening URI: " + uriHost + uriPath);
            }

            if (uriHost.contains("geocaching.com")) {
                geocode = uri.getQueryParameter("wp");
                guid = uri.getQueryParameter("guid");

                if (StringUtils.isNotBlank(geocode)) {
                    geocode = geocode.toUpperCase(Locale.US);
                    guid = null;
                } else if (StringUtils.isNotBlank(guid)) {
                    geocode = null;
                    guid = guid.toLowerCase(Locale.US);
                } else {
                    showToast(res.getString(R.string.err_detail_open));
                    finish();
                    return;
                }
            } else if (uriHost.contains("coord.info")) {
                if (uriPath != null && uriPath.startsWith("/gc")) {
                    geocode = uriPath.substring(1).toUpperCase(Locale.US);
                } else {
                    showToast(res.getString(R.string.err_detail_open));
                    finish();
                    return;
                }
            }
        }

        // no given data
        if (geocode == null && guid == null) {
            showToast(res.getString(R.string.err_detail_cache));
            finish();
            return;
        }

        final LoadCacheHandler loadCacheHandler = new LoadCacheHandler();

        try {
            String title = res.getString(R.string.cache);
            if (StringUtils.isNotBlank(name)) {
                title = name;
            } else if (null != geocode && StringUtils.isNotBlank(geocode)) { // can't be null, but the compiler doesn't understand StringUtils.isNotBlank()
                title = geocode;
            }
            progress.show(this, title, res.getString(R.string.cache_dialog_loading_details), true, loadCacheHandler.cancelMessage());
        } catch (Exception e) {
            // nothing, we lost the window
        }

        ImageView defaultNavigationImageView = (ImageView) findViewById(R.id.defaultNavigation);
        defaultNavigationImageView.setOnLongClickListener(new OnLongClickListener() {
            @Override
            public boolean onLongClick(View v) {
                startDefaultNavigation2();
                return true;
            }
        });

        final int pageToOpen = Settings.isOpenLastDetailsPage() ? Settings.getLastDetailsPage() : 1;
        createViewPager(pageToOpen, new OnPageSelectedListener() {

            @Override
            public void onPageSelected(int position) {
                if (Settings.isOpenLastDetailsPage()) {
                    Settings.setLastDetailsPage(position);
                }
                // lazy loading of cache images
                if (getPage(position) == Page.IMAGES) {
                    loadCacheImages();
                }
            }
        });

        // Initialization done. Let's load the data with the given information.
        new LoadCacheThread(geocode, guid, loadCacheHandler).start();
    }

    @Override
    public void onResume() {
        super.onResume();

        if (refreshOnResume) {
            notifyDataSetChanged();
            refreshOnResume = false;
        }
        locationUpdater.startGeo();
    }

    @Override
    public void onStop() {
        if (cache != null) {
            cache.setChangeNotificationHandler(null);
        }
        super.onStop();
    }

    @Override
    public void onPause() {
        locationUpdater.stopGeo();
        super.onPause();
    }

    @Override
    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenu.ContextMenuInfo info) {
        super.onCreateContextMenu(menu, view, info);
        final int viewId = view.getId();
        contextMenuWPIndex = -1;
        switch (viewId) {
            case R.id.value: // coordinates
                clickedItemText = ((TextView) view).getText();
                buildOptionsContextmenu(menu, viewId, res.getString(R.string.cache_coordinates), true);
                break;
            case R.id.shortdesc:
                clickedItemText = ((TextView) view).getText();
                buildOptionsContextmenu(menu, viewId, res.getString(R.string.cache_description), false);
                break;
            case R.id.longdesc:
                // combine short and long description
                String shortDesc = cache.getShortDescription();
                if (StringUtils.isBlank(shortDesc)) {
                    clickedItemText = ((TextView) view).getText();
                } else {
                    clickedItemText = shortDesc + "\n\n" + ((TextView) view).getText();
                }
                buildOptionsContextmenu(menu, viewId, res.getString(R.string.cache_description), false);
                break;
            case R.id.personalnote:
                clickedItemText = ((TextView) view).getText();
                buildOptionsContextmenu(menu, viewId, res.getString(R.string.cache_personal_note), true);
                break;
            case R.id.hint:
                clickedItemText = ((TextView) view).getText();
                buildOptionsContextmenu(menu, viewId, res.getString(R.string.cache_hint), false);
                break;
            case R.id.log:
                clickedItemText = ((TextView) view).getText();
                buildOptionsContextmenu(menu, viewId, res.getString(R.string.cache_logs), false);
                break;
            case -1:
                if (null != cache.getWaypoints()) {
                    try {
                        final ViewGroup parent = ((ViewGroup) view.getParent());
                        for (int i = 0; i < parent.getChildCount(); i++) {
                            if (parent.getChildAt(i) == view) {
                                final List<Waypoint> sortedWaypoints = new ArrayList<Waypoint>(cache.getWaypoints());
                                Collections.sort(sortedWaypoints);
                                final Waypoint waypoint = sortedWaypoints.get(i);
                                final int index = cache.getWaypoints().indexOf(waypoint);
                                menu.setHeaderTitle(res.getString(R.string.waypoint));
                                if (waypoint.getWaypointType().equals(WaypointType.ORIGINAL)) {
                                    menu.add(CONTEXT_MENU_WAYPOINT_RESET_ORIGINAL_CACHE_COORDINATES, index, 0, R.string.waypoint_reset_cache_coords);
                                } else {
                                    menu.add(CONTEXT_MENU_WAYPOINT_EDIT, index, 0, R.string.waypoint_edit);
                                    menu.add(CONTEXT_MENU_WAYPOINT_DUPLICATE, index, 0, R.string.waypoint_duplicate);
                                }
                                contextMenuWPIndex = index;
                                if (waypoint.isUserDefined() && !waypoint.getWaypointType().equals(WaypointType.ORIGINAL)) {
                                    menu.add(CONTEXT_MENU_WAYPOINT_DELETE, index, 0, R.string.waypoint_delete);
                                }
                                if (waypoint.getCoords() != null) {
                                    menu.add(CONTEXT_MENU_WAYPOINT_DEFAULT_NAVIGATION, index, 0, NavigationAppFactory.getDefaultNavigationApplication().getName());
                                    menu.add(CONTEXT_MENU_WAYPOINT_NAVIGATE, index, 0, R.string.cache_menu_navigate).setIcon(R.drawable.ic_menu_mapmode);
                                    menu.add(CONTEXT_MENU_WAYPOINT_CACHES_AROUND, index, 0, R.string.cache_menu_around);
                                }
                                break;
                            }
                        }
                    } catch (Exception e) {
                    }
                }
                break;
            default:
                if (imagesList != null) {
                    imagesList.onCreateContextMenu(menu, view);
                }
                break;
        }
    }

    private void buildOptionsContextmenu(ContextMenu menu, int viewId, String fieldTitle, boolean copyOnly) {
        menu.setHeaderTitle(fieldTitle);
        menu.add(viewId, MENU_FIELD_COPY, 0, res.getString(android.R.string.copy));
        if (!copyOnly) {
            if (clickedItemText.length() > TranslationUtils.translationTextLengthToWarn) {
                showToast(res.getString(R.string.translate_length_warning));
            }
            menu.add(viewId, MENU_FIELD_TRANSLATE, 0, res.getString(R.string.translate_to_sys_lang, Locale.getDefault().getDisplayLanguage()));
            if (Settings.isUseEnglish() && !StringUtils.equals(Locale.getDefault().getLanguage(), Locale.ENGLISH.getLanguage())) {
                menu.add(viewId, MENU_FIELD_TRANSLATE_EN, 0, res.getString(R.string.translate_to_english));
            }

        }
        menu.add(viewId, MENU_FIELD_SHARE, 0, res.getString(R.string.cache_share_field));
    }

    @Override
    public boolean onContextItemSelected(MenuItem item) {
        final int groupId = item.getGroupId();
        final int index = item.getItemId();
        switch (groupId) {
            case R.id.value:
            case R.id.shortdesc:
            case R.id.longdesc:
            case R.id.personalnote:
            case R.id.hint:
            case R.id.log:
                switch (index) {
                    case MENU_FIELD_COPY:
                        ClipboardUtils.copyToClipboard(clickedItemText);
                        showToast(res.getString(R.string.clipboard_copy_ok));
                        return true;
                    case MENU_FIELD_TRANSLATE:
                        TranslationUtils.startActivityTranslate(this, Locale.getDefault().getLanguage(), HtmlUtils.extractText(clickedItemText));
                        return true;
                    case MENU_FIELD_TRANSLATE_EN:
                        TranslationUtils.startActivityTranslate(this, Locale.ENGLISH.getLanguage(), HtmlUtils.extractText(clickedItemText));
                        return true;
                    case MENU_FIELD_SHARE:
                        final Intent intent = new Intent(Intent.ACTION_SEND);
                        intent.setType("text/plain");
                        intent.putExtra(Intent.EXTRA_TEXT, clickedItemText.toString());
                        startActivity(Intent.createChooser(intent, res.getText(R.string.cache_share_field)));
                        return true;
                    default:
                        break;
                }

                break;
            case CONTEXT_MENU_WAYPOINT_EDIT:
                final Waypoint waypointEdit = cache.getWaypoint(index);
                if (waypointEdit != null) {
                    EditWaypointActivity.startActivityEditWaypoint(this, waypointEdit.getId());
                    refreshOnResume = true;
                }
                break;
            case CONTEXT_MENU_WAYPOINT_DUPLICATE:
                final Waypoint waypointDuplicate = cache.getWaypoint(index);
                if (cache.duplicateWaypoint(waypointDuplicate)) {
                    cgData.saveCache(cache, EnumSet.of(SaveFlag.SAVE_DB));
                    notifyDataSetChanged();
                }
                break;
            case CONTEXT_MENU_WAYPOINT_DELETE:
                final Waypoint waypointDelete = cache.getWaypoint(index);
                if (cache.deleteWaypoint(waypointDelete)) {
                    cgData.saveCache(cache, EnumSet.of(SaveFlag.SAVE_DB));
                    notifyDataSetChanged();
                }
                break;
            case CONTEXT_MENU_WAYPOINT_DEFAULT_NAVIGATION:
                final Waypoint waypointNavigation = cache.getWaypoint(index);
                if (waypointNavigation != null) {
                    NavigationAppFactory.startDefaultNavigationApplication(1, this, waypointNavigation);
                }
                break;
            case CONTEXT_MENU_WAYPOINT_NAVIGATE:
                final Waypoint waypointNav = cache.getWaypoint(contextMenuWPIndex);
                if (waypointNav != null) {
                    NavigationAppFactory.showNavigationMenu(this, null, waypointNav, null);
                }
                break;
            case CONTEXT_MENU_WAYPOINT_CACHES_AROUND:
                final Waypoint waypointAround = cache.getWaypoint(index);
                if (waypointAround != null) {
                    cgeocaches.startActivityCoordinates(this, waypointAround.getCoords());
                }
                break;

            case CONTEXT_MENU_WAYPOINT_RESET_ORIGINAL_CACHE_COORDINATES:
                new ResetCacheCoordinatesDialog(cache, cache.getWaypoint(index), this).show();
                break;

            default:
                if (imagesList != null && imagesList.onContextItemSelected(item)) {
                    return true;
                }
                return onOptionsItemSelected(item);
        }
        return false;
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        if (null != cache) {
            menu.add(0, MENU_DEFAULT_NAVIGATION, 0, NavigationAppFactory.getDefaultNavigationApplication().getName()).setIcon(R.drawable.ic_menu_compass); // default navigation tool

            final SubMenu subMenu = menu.addSubMenu(0, 0, 0, res.getString(R.string.cache_menu_navigate)).setIcon(R.drawable.ic_menu_mapmode);
            NavigationAppFactory.addMenuItems(subMenu, cache);

            menu.add(0, MENU_CALENDAR, 0, res.getString(R.string.cache_menu_event)).setIcon(R.drawable.ic_menu_agenda); // add event to calendar
            LoggingUI.addMenuItems(menu, cache);
            menu.add(0, MENU_CACHES_AROUND, 0, res.getString(R.string.cache_menu_around)).setIcon(R.drawable.ic_menu_rotate); // caches around
            menu.add(0, MENU_BROWSER, 0, res.getString(R.string.cache_menu_browser)).setIcon(R.drawable.ic_menu_globe); // browser
            menu.add(0, MENU_SHARE, 0, res.getString(R.string.cache_menu_share)).setIcon(R.drawable.ic_menu_share); // share cache
        }
        return true;
    }

    @Override
    public boolean onPrepareOptionsMenu(Menu menu) {
        if (cache != null) {
            menu.findItem(MENU_DEFAULT_NAVIGATION).setVisible(null != cache.getCoords());
            menu.findItem(MENU_CALENDAR).setVisible(cache.canBeAddedToCalendar());
            menu.findItem(MENU_CACHES_AROUND).setVisible(null != cache.getCoords() && cache.supportsCachesAround());
            menu.findItem(MENU_BROWSER).setVisible(cache.canOpenInBrowser());
        }
        return super.onPrepareOptionsMenu(menu);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        final int menuItem = item.getItemId();

        switch (menuItem) {
            case 0:
                // no menu selected, but a new sub menu shown
                return false;
            case MENU_DEFAULT_NAVIGATION:
                startDefaultNavigation();
                return true;
            case MENU_BROWSER:
                cache.openInBrowser(this);
                return true;
            case MENU_CACHES_AROUND:
                cgeocaches.startActivityCoordinates(this, cache.getCoords());
                return true;
            case MENU_CALENDAR:
                addToCalendarWithIntent();
                return true;
            case MENU_SHARE:
                if (cache != null) {
                    cache.shareCache(this, res);
                    return true;
                }
                return false;
            default:
                if (NavigationAppFactory.onMenuItemSelected(item, this, cache)) {
                    return true;
                }
                if (LoggingUI.onMenuItemSelected(item, this, cache)) {
                    refreshOnResume = true;
                    return true;
                }
        }

        return true;
    }

    private class LoadCacheHandler extends CancellableHandler {
        @Override
        public void handleRegularMessage(final Message msg) {
            if (UPDATE_LOAD_PROGRESS_DETAIL == msg.what && msg.obj instanceof String) {
                updateStatusMsg((String) msg.obj);
            } else {
                if (search == null) {
                    showToast(res.getString(R.string.err_dwld_details_failed));

                    finish();
                    return;
                }

                if (search.getError() != null) {
                    showToast(res.getString(R.string.err_dwld_details_failed) + " " + search.getError().getErrorString(res) + ".");

                    finish();
                    return;
                }

                updateStatusMsg(res.getString(R.string.cache_dialog_loading_details_status_render));

                // Data loaded, we're ready to show it!
                notifyDataSetChanged();
            }
        }

        private void updateStatusMsg(final String msg) {
            progress.setMessage(res.getString(R.string.cache_dialog_loading_details)
                    + "\n\n"
                    + msg);
        }

        @Override
        public void handleCancel(final Object extra) {
            finish();
        }

    }

    private void notifyDataSetChanged() {
        if (search == null) {
            return;
        }

        cache = search.getFirstCacheFromResult(LoadFlags.LOAD_ALL_DB_ONLY);

        if (cache == null) {
            progress.dismiss();
            showToast(res.getString(R.string.err_detail_cache_find_some));
            finish();
            return;
        }

        // allow cache to notify CacheDetailActivity when it changes so it can be reloaded
        cache.setChangeNotificationHandler(cacheChangeNotificationHandler);

        // action bar: title and icon
        if (StringUtils.isNotBlank(cache.getName())) {
            setTitle(cache.getName() + " (" + cache.getGeocode() + ')');
        } else {
            setTitle(cache.getGeocode());
        }
        ((TextView) findViewById(R.id.actionbar_title)).setCompoundDrawablesWithIntrinsicBounds(getResources().getDrawable(cache.getType().markerId), null, null, null);

        reinitializeViewPager();

        // rendering done! remove progress popup if any there
        invalidateOptionsMenuCompatible();
        progress.dismiss();
    }

    /**
     * Loads the cache with the given geocode or guid.
     */
    private class LoadCacheThread extends Thread {

        private CancellableHandler handler = null;
        private String geocode;
        private String guid;

        public LoadCacheThread(final String geocode, final String guid, final CancellableHandler handlerIn) {
            handler = handlerIn;

            if (StringUtils.isBlank(geocode) && StringUtils.isBlank(guid)) {
                showToast(res.getString(R.string.err_detail_cache_forgot));

                finish();
                return;
            }

            this.geocode = geocode;
            this.guid = guid;
        }

        @Override
        public void run() {
            search = cgCache.searchByGeocode(geocode, StringUtils.isBlank(geocode) ? guid : null, 0, false, handler);
            handler.sendMessage(Message.obtain());
        }
    }

    /**
     * Indicates whether the specified action can be used as an intent. This
     * method queries the package manager for installed packages that can
     * respond to an intent with the specified action. If no suitable package is
     * found, this method returns false.
     *
     * @param context
     *            The application's environment.
     * @param action
     *            The Intent action to check for availability.
     * @param uri
     *            The Intent URI to check for availability.
     *
     * @return True if an Intent with the specified action can be sent and
     *         responded to, false otherwise.
     */
    private static boolean isIntentAvailable(Context context, String action, Uri uri) {
        final PackageManager packageManager = context.getPackageManager();
        final Intent intent;
        if (uri == null) {
            intent = new Intent(action);
        } else {
            intent = new Intent(action, uri);
        }
        final List<ResolveInfo> list = packageManager.queryIntentActivities(intent,
                PackageManager.MATCH_DEFAULT_ONLY);
        return !list.isEmpty();
    }

    private void addToCalendarWithIntent() {

        final boolean calendarAddOnAvailable = isIntentAvailable(this, ICalendar.INTENT, Uri.parse(ICalendar.URI_SCHEME + "://" + ICalendar.URI_HOST));

        if (calendarAddOnAvailable) {
            final Parameters params = new Parameters(
                    ICalendar.PARAM_NAME, cache.getName(),
                    ICalendar.PARAM_NOTE, StringUtils.defaultString(cache.getPersonalNote()),
                    ICalendar.PARAM_HIDDEN_DATE, String.valueOf(cache.getHiddenDate().getTime()),
                    ICalendar.PARAM_URL, StringUtils.defaultString(cache.getUrl()),
                    ICalendar.PARAM_COORDS, cache.getCoords() == null ? "" : cache.getCoords().format(GeopointFormatter.Format.LAT_LON_DECMINUTE_RAW),
                    ICalendar.PARAM_LOCATION, StringUtils.defaultString(cache.getLocation()),
                    ICalendar.PARAM_SHORT_DESC, StringUtils.defaultString(cache.getShortDescription()),
                    ICalendar.PARAM_START_TIME_MINUTES, StringUtils.defaultString(cache.guessEventTimeMinutes())
                    );

            startActivity(new Intent(ICalendar.INTENT,
                    Uri.parse(ICalendar.URI_SCHEME + "://" + ICalendar.URI_HOST + "?" + params.toString())));
        } else {
            // Inform user the calendar add-on is not installed and let them get it from Google Play
            new AlertDialog.Builder(this)
                    .setTitle(res.getString(R.string.addon_missing_title))
                    .setMessage(new StringBuilder(res.getString(R.string.helper_calendar_missing))
                            .append(' ')
                            .append(res.getString(R.string.addon_download_prompt))
                            .toString())
                    .setPositiveButton(getString(android.R.string.yes), new DialogInterface.OnClickListener() {
                        @Override
                        public void onClick(DialogInterface dialog, int id) {
                            Intent intent = new Intent(Intent.ACTION_VIEW);
                            intent.setData(Uri.parse(ICalendar.CALENDAR_ADDON_URI));
                            startActivity(intent);
                        }
                    })
                    .setNegativeButton(getString(android.R.string.no), new DialogInterface.OnClickListener() {
                        @Override
                        public void onClick(DialogInterface dialog, int id) {
                            dialog.cancel();
                        }
                    })
                    .create()
                    .show();
        }
    }

    /**
     * Tries to navigate to the {@link cgCache} of this activity.
     */
    private void startDefaultNavigation() {
        NavigationAppFactory.startDefaultNavigationApplication(1, this, cache);
    }

    /**
     * Tries to navigate to the {@link cgCache} of this activity.
     */
    private void startDefaultNavigation2() {
        NavigationAppFactory.startDefaultNavigationApplication(2, this, cache);
    }

    /**
     * Wrapper for the referenced method in the xml-layout.
     */
    public void startDefaultNavigation(@SuppressWarnings("unused") View view) {
        startDefaultNavigation();
    }

    /**
     * referenced from XML view
     */
    public void showNavigationMenu(@SuppressWarnings("unused") View view) {
        NavigationAppFactory.showNavigationMenu(this, cache, null, null, true, true);
    }

    /**
     * Listener for clicks on username
     */
    private class UserActionsClickListener implements View.OnClickListener {

        @Override
        public void onClick(View view) {
            if (view == null) {
                return;
            }
            if (!cache.supportsUserActions()) {
                return;
            }

            clickedItemText = ((TextView) view).getText().toString();
            showUserActionsDialog(clickedItemText);
        }
    }

    /**
     * Listener for clicks on owner name
     */
    private class OwnerActionsClickListener implements View.OnClickListener {

        @Override
        public void onClick(View view) {
            if (view == null) {
                return;
            }
            if (!cache.supportsUserActions()) {
                return;
            }

            // Use real owner name vice the one owner chose to display
            if (StringUtils.isNotBlank(cache.getOwnerUserId())) {
                clickedItemText = cache.getOwnerUserId();
            } else {
                clickedItemText = ((TextView) view).getText().toString();
            }
            showUserActionsDialog(clickedItemText);
        }
    }

    /**
     * Opens a dialog to do actions on an username
     */
    private void showUserActionsDialog(final CharSequence name) {
        final CharSequence[] items = { res.getString(R.string.user_menu_view_hidden),
                res.getString(R.string.user_menu_view_found),
                res.getString(R.string.user_menu_open_browser)
        };

        AlertDialog.Builder builder = new AlertDialog.Builder(this);
        builder.setTitle(res.getString(R.string.user_menu_title) + " " + name);
        builder.setItems(items, new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int item) {
                switch (item) {
                    case 0:
                        cgeocaches.startActivityOwner(CacheDetailActivity.this, name.toString());
                        return;
                    case 1:
                        cgeocaches.startActivityUserName(CacheDetailActivity.this, name.toString());
                        return;
                    case 2:
                        startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse("http://www.geocaching.com/profile/?u=" + Network.encode(name.toString()))));
                        return;
                    default:
                        break;
                }
            }
        });
        AlertDialog alert = builder.create();
        alert.show();
    }

    private void loadCacheImages() {
        if (imagesList != null) {
            return;
        }
        PageViewCreator creator = getViewCreator(Page.IMAGES);
        if (creator == null) {
            return;
        }
        View imageView = creator.getView();
        if (imageView == null) {
            return;
        }
        imagesList = new ImagesList(this, cache.getGeocode());
        imagesList.loadImages(imageView, cache.getImages(), ImageType.AllImages, false);
    }

    public static void startActivity(final Context context, final String geocode) {
        final Intent detailIntent = new Intent(context, CacheDetailActivity.class);
        detailIntent.putExtra("geocode", geocode);
        context.startActivity(detailIntent);
    }

    /**
     * Enum of all possible pages with methods to get the view and a title.
     */
    public enum Page {
        DETAILS(R.string.detail),
        DESCRIPTION(R.string.cache_description),
        LOGS(R.string.cache_logs),
        LOGSFRIENDS(R.string.cache_logsfriends),
        WAYPOINTS(R.string.cache_waypoints),
        INVENTORY(R.string.cache_inventory),
        IMAGES(R.string.cache_images);

        final private int titleStringId;

        Page(final int titleStringId) {
            this.titleStringId = titleStringId;
        }
    }

    private class AttributeViewBuilder {
        private ViewGroup attributeIconsLayout; // layout for attribute icons
        private ViewGroup attributeDescriptionsLayout; // layout for attribute descriptions
        private boolean attributesShowAsIcons = true; // default: show icons
        /**
         * If the cache is from a non GC source, it might be without icons. Disable switching in those cases.
         */
        private boolean noAttributeIconsFound = false;
        private int attributeBoxMaxWidth;

        public void fillView(final LinearLayout attributeBox) {
            // first ensure that the view is empty
            attributeBox.removeAllViews();

            // maximum width for attribute icons is screen width - paddings of parents
            attributeBoxMaxWidth = Compatibility.getDisplayWidth();
            ViewParent child = attributeBox;
            do {
                if (child instanceof View) {
                    attributeBoxMaxWidth -= ((View) child).getPaddingLeft() + ((View) child).getPaddingRight();
                }
                child = child.getParent();
            } while (child != null);

            // delete views holding description / icons
            attributeDescriptionsLayout = null;
            attributeIconsLayout = null;

            attributeBox.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    // toggle between attribute icons and descriptions
                    toggleAttributeDisplay(attributeBox, attributeBoxMaxWidth);
                }
            });

            // icons or text?
            //
            // also show icons when noAttributeImagesFound == true. Explanation:
            //  1. no icons could be found in the first invocation of this method
            //  2. user refreshes cache from web
            //  3. now this method is called again
            //  4. attributeShowAsIcons is false but noAttributeImagesFound is true
            //     => try to show them now
            if (attributesShowAsIcons || noAttributeIconsFound) {
                showAttributeIcons(attributeBox, attributeBoxMaxWidth);
            } else {
                showAttributeDescriptions(attributeBox);
            }
        }

        /**
         * lazy-creates the layout holding the icons of the caches attributes
         * and makes it visible
         */
        private void showAttributeIcons(LinearLayout attribBox, int parentWidth) {
            if (attributeIconsLayout == null) {
                attributeIconsLayout = createAttributeIconsLayout(parentWidth);
                // no matching icons found? show text
                if (noAttributeIconsFound) {
                    showAttributeDescriptions(attribBox);
                    return;
                }
            }
            attribBox.removeAllViews();
            attribBox.addView(attributeIconsLayout);
            attributesShowAsIcons = true;
        }

        /**
         * lazy-creates the layout holding the descriptions of the caches attributes
         * and makes it visible
         */
        private void showAttributeDescriptions(LinearLayout attribBox) {
            if (attributeDescriptionsLayout == null) {
                attributeDescriptionsLayout = createAttributeDescriptionsLayout();
            }
            attribBox.removeAllViews();
            attribBox.addView(attributeDescriptionsLayout);
            attributesShowAsIcons = false;
        }

        /**
         * toggle attribute descriptions and icons
         */
        private void toggleAttributeDisplay(LinearLayout attribBox, int parentWidth) {
            // Don't toggle when there are no icons to show.
            if (noAttributeIconsFound) {
                return;
            }

            // toggle
            if (attributesShowAsIcons) {
                showAttributeDescriptions(attribBox);
            } else {
                showAttributeIcons(attribBox, parentWidth);
            }
        }

        private ViewGroup createAttributeIconsLayout(int parentWidth) {
            final LinearLayout rows = new LinearLayout(CacheDetailActivity.this);
            rows.setLayoutParams(new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT));
            rows.setOrientation(LinearLayout.VERTICAL);

            LinearLayout attributeRow = newAttributeIconsRow();
            rows.addView(attributeRow);

            noAttributeIconsFound = true;

            for (String attributeName : cache.getAttributes()) {
                // check if another attribute icon fits in this row
                attributeRow.measure(0, 0);
                int rowWidth = attributeRow.getMeasuredWidth();
                FrameLayout fl = (FrameLayout) getLayoutInflater().inflate(R.layout.attribute_image, null);
                ImageView iv = (ImageView) fl.getChildAt(0);
                if ((parentWidth - rowWidth) < iv.getLayoutParams().width) {
                    // make a new row
                    attributeRow = newAttributeIconsRow();
                    rows.addView(attributeRow);
                }

                final boolean strikethru = !CacheAttribute.isEnabled(attributeName);
                final CacheAttribute attrib = CacheAttribute.getByGcRawName(CacheAttribute.trimAttributeName(attributeName));
                if (attrib != CacheAttribute.UNKNOWN) {
                    noAttributeIconsFound = false;
                    Drawable d = res.getDrawable(attrib.drawableId);
                    iv.setImageDrawable(d);
                    // strike through?
                    if (strikethru) {
                        // generate strikethru image with same properties as attribute image
                        ImageView strikethruImage = new ImageView(CacheDetailActivity.this);
                        strikethruImage.setLayoutParams(iv.getLayoutParams());
                        d = res.getDrawable(R.drawable.attribute__strikethru);
                        strikethruImage.setImageDrawable(d);
                        fl.addView(strikethruImage);
                    }
                } else {
                    Drawable d = res.getDrawable(R.drawable.attribute_icon_not_found);
                    iv.setImageDrawable(d);
                }

                attributeRow.addView(fl);
            }

            return rows;
        }

        private LinearLayout newAttributeIconsRow() {
            LinearLayout rowLayout = new LinearLayout(CacheDetailActivity.this);
            rowLayout.setLayoutParams(new LayoutParams(LayoutParams.MATCH_PARENT,
                    LayoutParams.WRAP_CONTENT));
            rowLayout.setOrientation(LinearLayout.HORIZONTAL);
            return rowLayout;
        }

        private ViewGroup createAttributeDescriptionsLayout() {
            final LinearLayout descriptions = (LinearLayout) getLayoutInflater().inflate(
                    R.layout.attribute_descriptions, null);
            final TextView attribView = (TextView) descriptions.getChildAt(0);

            final StringBuilder buffer = new StringBuilder();
            for (String attributeName : cache.getAttributes()) {
                final boolean enabled = CacheAttribute.isEnabled(attributeName);
                // search for a translation of the attribute
                CacheAttribute attrib = CacheAttribute.getByGcRawName(CacheAttribute.trimAttributeName(attributeName));
                if (attrib != CacheAttribute.UNKNOWN) {
                    attributeName = attrib.getL10n(enabled);
                }
                if (buffer.length() > 0) {
                    buffer.append('\n');
                }
                buffer.append(attributeName);
            }

            attribView.setText(buffer);

            return descriptions;
        }
    }

    /**
     * Creator for details-view.
     */
    private class DetailsViewCreator extends AbstractCachingPageViewCreator<ScrollView> {
        /**
         * Reference to the details list, so that the helper-method can access it without an additional argument
         */
        private LinearLayout detailsList;

        // TODO Do we need this thread-references?
        private StoreCacheThread storeThread;
        private RefreshCacheThread refreshThread;
        private Thread watchlistThread;

        @Override
        public ScrollView getDispatchedView() {
            if (cache == null) {
                // something is really wrong
                return null;
            }

            view = (ScrollView) getLayoutInflater().inflate(R.layout.cacheview_details, null);

            // Start loading preview map
            if (Settings.isStoreOfflineMaps()) {
                new PreviewMapTask().execute((Void) null);
            }

            detailsList = (LinearLayout) view.findViewById(R.id.details_list);
            final CacheDetailsCreator details = new CacheDetailsCreator(CacheDetailActivity.this, detailsList);

            // cache name (full name)
            Spannable span = (new Spannable.Factory()).newSpannable(Html.fromHtml(cache.getName()).toString());
            if (cache.isDisabled() || cache.isArchived()) { // strike
                span.setSpan(new StrikethroughSpan(), 0, span.toString().length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
            }
            if (cache.isArchived()) {
                span.setSpan(new ForegroundColorSpan(res.getColor(R.color.archived_cache_color)), 0, span.toString().length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
            }

            details.add(R.string.cache_name, span);
            details.add(R.string.cache_type, cache.getType().getL10n());
            details.addSize(cache);
            details.add(R.string.cache_geocode, cache.getGeocode());
            details.addCacheState(cache);

            details.addDistance(cache, cacheDistanceView);
            cacheDistanceView = details.getValueView();

            details.addDifficulty(cache);
            details.addTerrain(cache);
            details.addRating(cache);

            // favorite count
            if (cache.getFavoritePoints() > 0) {
                details.add(R.string.cache_favourite, cache.getFavoritePoints() + "");
            }

            // own rating
            if (cache.getMyVote() > 0) {
                details.addStars(R.string.cache_own_rating, cache.getMyVote());
            }

            // cache author
            if (StringUtils.isNotBlank(cache.getOwnerDisplayName()) || StringUtils.isNotBlank(cache.getOwnerUserId())) {
                TextView ownerView = details.add(R.string.cache_owner, "");
                if (StringUtils.isNotBlank(cache.getOwnerDisplayName())) {
                    ownerView.setText(cache.getOwnerDisplayName(), TextView.BufferType.SPANNABLE);
                } else { // OwnerReal guaranteed to be not blank based on above
                    ownerView.setText(cache.getOwnerUserId(), TextView.BufferType.SPANNABLE);
                }
                ownerView.setOnClickListener(new OwnerActionsClickListener());
            }

            // cache hidden
            if (cache.getHiddenDate() != null) {
                long time = cache.getHiddenDate().getTime();
                if (time > 0) {
                    String dateString = Formatter.formatFullDate(time);
                    if (cache.isEventCache()) {
                        dateString = DateUtils.formatDateTime(cgeoapplication.getInstance().getBaseContext(), time, DateUtils.FORMAT_SHOW_WEEKDAY) + ", " + dateString;
                    }
                    details.add(cache.isEventCache() ? R.string.cache_event : R.string.cache_hidden, dateString);
                }
            }

            // cache location
            if (StringUtils.isNotBlank(cache.getLocation())) {
                details.add(R.string.cache_location, cache.getLocation());
            }

            // cache coordinates
            if (cache.getCoords() != null) {
                TextView valueView = details.add(R.string.cache_coordinates, cache.getCoords().toString());
                valueView.setOnClickListener(new View.OnClickListener() {
                    private int position = 0;
                    private GeopointFormatter.Format[] availableFormats = new GeopointFormatter.Format[] {
                            GeopointFormatter.Format.LAT_LON_DECMINUTE,
                            GeopointFormatter.Format.LAT_LON_DECSECOND,
                            GeopointFormatter.Format.LAT_LON_DECDEGREE
                    };

                    // rotate coordinate formats on click
                    @Override
                    public void onClick(View view) {
                        position = (position + 1) % availableFormats.length;

                        final TextView valueView = (TextView) view.findViewById(R.id.value);
                        valueView.setText(cache.getCoords().format(availableFormats[position]));
                    }
                });
                registerForContextMenu(valueView);
            }

            // cache attributes
            if (cache.getAttributes().isNotEmpty()) {
                new AttributeViewBuilder().fillView((LinearLayout) view.findViewById(R.id.attributes_innerbox));
                view.findViewById(R.id.attributes_box).setVisibility(View.VISIBLE);
            }

            updateOfflineBox();

            // watchlist
            Button buttonWatchlistAdd = (Button) view.findViewById(R.id.add_to_watchlist);
            Button buttonWatchlistRemove = (Button) view.findViewById(R.id.remove_from_watchlist);
            buttonWatchlistAdd.setOnClickListener(new AddToWatchlistClickListener());
            buttonWatchlistRemove.setOnClickListener(new RemoveFromWatchlistClickListener());
            updateWatchlistBox();

            // favorite points
            Button buttonFavPointAdd = (Button) view.findViewById(R.id.add_to_favpoint);
            Button buttonFavPointRemove = (Button) view.findViewById(R.id.remove_from_favpoint);
            buttonFavPointAdd.setOnClickListener(new FavoriteAddClickListener());
            buttonFavPointRemove.setOnClickListener(new FavoriteRemoveClickListener());
            updateFavPointBox();

            // data license
            IConnector connector = ConnectorFactory.getConnector(cache);
            if (connector != null) {
                String license = connector.getLicenseText(cache);
                if (StringUtils.isNotBlank(license)) {
                    view.findViewById(R.id.license_box).setVisibility(View.VISIBLE);
                    TextView licenseView = ((TextView) view.findViewById(R.id.license));
                    licenseView.setText(Html.fromHtml(license), BufferType.SPANNABLE);
                    licenseView.setClickable(true);
                    licenseView.setMovementMethod(LinkMovementMethod.getInstance());
                } else {
                    view.findViewById(R.id.license_box).setVisibility(View.GONE);
                }
            }

            return view;
        }

        private class StoreCacheHandler extends CancellableHandler {
            @Override
            public void handleRegularMessage(Message msg) {
                if (UPDATE_LOAD_PROGRESS_DETAIL == msg.what && msg.obj instanceof String) {
                    updateStatusMsg((String) msg.obj);
                } else {
                    storeThread = null;
                    CacheDetailActivity.this.notifyDataSetChanged(); // reload cache details
                }
            }

            private void updateStatusMsg(final String msg) {
                progress.setMessage(res.getString(R.string.cache_dialog_offline_save_message)
                        + "\n\n"
                        + msg);
            }
        }

        private class RefreshCacheHandler extends CancellableHandler {
            @Override
            public void handleRegularMessage(Message msg) {
                if (UPDATE_LOAD_PROGRESS_DETAIL == msg.what && msg.obj instanceof String) {
                    updateStatusMsg((String) msg.obj);
                } else {
                    refreshThread = null;
                    CacheDetailActivity.this.notifyDataSetChanged(); // reload cache details
                }
            }

            private void updateStatusMsg(final String msg) {
                progress.setMessage(res.getString(R.string.cache_dialog_refresh_message)
                        + "\n\n"
                        + msg);
            }
        }

        private class DropCacheHandler extends Handler {
            @Override
            public void handleMessage(Message msg) {
                CacheDetailActivity.this.notifyDataSetChanged();
            }
        }

        private class StoreCacheClickListener implements View.OnClickListener {
            @Override
            public void onClick(View arg0) {
                if (progress.isShowing()) {
                    showToast(res.getString(R.string.err_detail_still_working));
                    return;
                }

                final StoreCacheHandler storeCacheHandler = new StoreCacheHandler();

                progress.show(CacheDetailActivity.this, res.getString(R.string.cache_dialog_offline_save_title), res.getString(R.string.cache_dialog_offline_save_message), true, storeCacheHandler.cancelMessage());

                if (storeThread != null) {
                    storeThread.interrupt();
                }

                storeThread = new StoreCacheThread(storeCacheHandler);
                storeThread.start();
            }
        }

        private class RefreshCacheClickListener implements View.OnClickListener {
            @Override
            public void onClick(View arg0) {
                if (progress.isShowing()) {
                    showToast(res.getString(R.string.err_detail_still_working));
                    return;
                }

                final RefreshCacheHandler refreshCacheHandler = new RefreshCacheHandler();

                progress.show(CacheDetailActivity.this, res.getString(R.string.cache_dialog_refresh_title), res.getString(R.string.cache_dialog_refresh_message), true, refreshCacheHandler.cancelMessage());

                if (refreshThread != null) {
                    refreshThread.interrupt();
                }

                refreshThread = new RefreshCacheThread(refreshCacheHandler);
                refreshThread.start();
            }
        }

        private class StoreCacheThread extends Thread {
            final private CancellableHandler handler;

            public StoreCacheThread(final CancellableHandler handler) {
                this.handler = handler;
            }

            @Override
            public void run() {
                cache.store(handler);
            }
        }

        private class RefreshCacheThread extends Thread {
            final private CancellableHandler handler;

            public RefreshCacheThread(final CancellableHandler handler) {
                this.handler = handler;
            }

            @Override
            public void run() {
                cache.refresh(cache.getListId(), handler);

                handler.sendEmptyMessage(0);
            }
        }

        private class DropCacheClickListener implements View.OnClickListener {
            @Override
            public void onClick(View arg0) {
                if (progress.isShowing()) {
                    showToast(res.getString(R.string.err_detail_still_working));
                    return;
                }

                final DropCacheHandler dropCacheHandler = new DropCacheHandler();

                progress.show(CacheDetailActivity.this, res.getString(R.string.cache_dialog_offline_drop_title), res.getString(R.string.cache_dialog_offline_drop_message), true, null);
                new DropCacheThread(dropCacheHandler).start();
            }
        }

        private class DropCacheThread extends Thread {

            private Handler handler = null;

            public DropCacheThread(Handler handlerIn) {
                handler = handlerIn;
            }

            @Override
            public void run() {
                cache.drop(handler);
            }
        }

        /**
         * Abstract Listener for add / remove buttons for watchlist
         */
        private abstract class AbstractWatchlistClickListener implements View.OnClickListener {
            public void doExecute(int titleId, int messageId, Thread thread) {
                if (progress.isShowing()) {
                    showToast(res.getString(R.string.err_watchlist_still_managing));
                    return;
                }
                progress.show(CacheDetailActivity.this, res.getString(titleId), res.getString(messageId), true, null);

                if (watchlistThread != null) {
                    watchlistThread.interrupt();
                }

                watchlistThread = thread;
                watchlistThread.start();
            }
        }

        /**
         * Listener for "add to watchlist" button
         */
        private class AddToWatchlistClickListener extends AbstractWatchlistClickListener {
            @Override
            public void onClick(View arg0) {
                doExecute(R.string.cache_dialog_watchlist_add_title,
                        R.string.cache_dialog_watchlist_add_message,
                        new WatchlistAddThread(new WatchlistHandler()));
            }
        }

        /**
         * Listener for "remove from watchlist" button
         */
        private class RemoveFromWatchlistClickListener extends AbstractWatchlistClickListener {
            @Override
            public void onClick(View arg0) {
                doExecute(R.string.cache_dialog_watchlist_remove_title,
                        R.string.cache_dialog_watchlist_remove_message,
                        new WatchlistRemoveThread(new WatchlistHandler()));
            }
        }

        /** Thread to add this cache to the watchlist of the user */
        private class WatchlistAddThread extends Thread {
            private final Handler handler;

            public WatchlistAddThread(Handler handler) {
                this.handler = handler;
            }

            @Override
            public void run() {
                handler.sendEmptyMessage(GCConnector.addToWatchlist(cache) ? 1 : -1);
            }
        }

        /** Thread to remove this cache from the watchlist of the user */
        private class WatchlistRemoveThread extends Thread {
            private final Handler handler;

            public WatchlistRemoveThread(Handler handler) {
                this.handler = handler;
            }

            @Override
            public void run() {
                handler.sendEmptyMessage(GCConnector.removeFromWatchlist(cache) ? 1 : -1);
            }
        }

        /** Thread to add this cache to the favourite list of the user */
        private class FavoriteAddThread extends Thread {
            private final Handler handler;

            public FavoriteAddThread(Handler handler) {
                this.handler = handler;
            }

            @Override
            public void run() {
                handler.sendEmptyMessage(GCConnector.addToFavorites(cache) ? 1 : -1);
            }
        }

        /** Thread to remove this cache to the favourite list of the user */
        private class FavoriteRemoveThread extends Thread {
            private final Handler handler;

            public FavoriteRemoveThread(Handler handler) {
                this.handler = handler;
            }

            @Override
            public void run() {
                handler.sendEmptyMessage(GCConnector.removeFromFavorites(cache) ? 1 : -1);
            }
        }

        private class FavoriteUpdateHandler extends Handler {
            @Override
            public void handleMessage(Message msg) {
                progress.dismiss();
                if (msg.what == -1) {
                    showToast(res.getString(R.string.err_favorite_failed));
                } else {
                    CacheDetailActivity.this.notifyDataSetChanged(); // reload cache details
                }
            }
        }

        /**
         * Listener for "add to favourites" button
         */
        private class FavoriteAddClickListener extends AbstractWatchlistClickListener {
            @Override
            public void onClick(View arg0) {
                doExecute(R.string.cache_dialog_favourite_add_title,
                        R.string.cache_dialog_favourite_add_message,
                        new FavoriteAddThread(new FavoriteUpdateHandler()));
            }
        }

        /**
         * Listener for "remove from favourites" button
         */
        private class FavoriteRemoveClickListener extends AbstractWatchlistClickListener {
            @Override
            public void onClick(View arg0) {
                doExecute(R.string.cache_dialog_favourite_remove_title,
                        R.string.cache_dialog_favourite_remove_message,
                        new FavoriteRemoveThread(new FavoriteUpdateHandler()));
            }
        }

        /**
         * shows/hides buttons, sets text in watchlist box
         */
        private void updateWatchlistBox() {
            LinearLayout layout = (LinearLayout) view.findViewById(R.id.watchlist_box);
            boolean supportsWatchList = cache.supportsWatchList();
            layout.setVisibility(supportsWatchList ? View.VISIBLE : View.GONE);
            if (!supportsWatchList) {
                return;
            }
            Button buttonAdd = (Button) view.findViewById(R.id.add_to_watchlist);
            Button buttonRemove = (Button) view.findViewById(R.id.remove_from_watchlist);
            TextView text = (TextView) view.findViewById(R.id.watchlist_text);

            if (cache.isOnWatchlist() || cache.isOwn()) {
                buttonAdd.setVisibility(View.GONE);
                buttonRemove.setVisibility(View.VISIBLE);
                text.setText(R.string.cache_watchlist_on);
            } else {
                buttonAdd.setVisibility(View.VISIBLE);
                buttonRemove.setVisibility(View.GONE);
                text.setText(R.string.cache_watchlist_not_on);
            }

            // the owner of a cache has it always on his watchlist. Adding causes an error
            if (cache.isOwn()) {
                buttonAdd.setEnabled(false);
                buttonAdd.setVisibility(View.GONE);
                buttonRemove.setEnabled(false);
                buttonRemove.setVisibility(View.GONE);
            }

        }

        /**
         * shows/hides buttons, sets text in watchlist box
         */
        private void updateFavPointBox() {
            LinearLayout layout = (LinearLayout) view.findViewById(R.id.favpoint_box);
            boolean supportsFavoritePoints = cache.supportsFavoritePoints();
            layout.setVisibility(supportsFavoritePoints ? View.VISIBLE : View.GONE);
            if (!supportsFavoritePoints || cache.isOwn() || !Settings.isPremiumMember()) {
                return;
            }
            Button buttonAdd = (Button) view.findViewById(R.id.add_to_favpoint);
            Button buttonRemove = (Button) view.findViewById(R.id.remove_from_favpoint);
            TextView text = (TextView) view.findViewById(R.id.favpoint_text);

            if (cache.isFavorite()) {
                buttonAdd.setVisibility(View.GONE);
                buttonRemove.setVisibility(View.VISIBLE);
                text.setText(R.string.cache_favpoint_on);
            } else {
                buttonAdd.setVisibility(View.VISIBLE);
                buttonRemove.setVisibility(View.GONE);
                text.setText(R.string.cache_favpoint_not_on);
            }

            // Add/remove to Favorites is only possible if the cache has been found
            if (!cache.isFound()) {
                buttonAdd.setEnabled(false);
                buttonAdd.setVisibility(View.GONE);
                buttonRemove.setEnabled(false);
                buttonRemove.setVisibility(View.GONE);
            }
        }

        /**
         * Handler, called when watchlist add or remove is done
         */
        private class WatchlistHandler extends Handler {
            @Override
            public void handleMessage(Message msg) {
                watchlistThread = null;
                progress.dismiss();
                if (msg.what == -1) {
                    showToast(res.getString(R.string.err_watchlist_failed));
                } else {
                    CacheDetailActivity.this.notifyDataSetChanged(); // reload cache details
                }
            }
        }

        private void updateOfflineBox() {
            // offline use
            final TextView offlineText = (TextView) view.findViewById(R.id.offline_text);
            final Button offlineRefresh = (Button) view.findViewById(R.id.offline_refresh);
            final Button offlineStore = (Button) view.findViewById(R.id.offline_store);

            if (cache.isOffline()) {
                long diff = (System.currentTimeMillis() / (60 * 1000)) - (cache.getDetailedUpdate() / (60 * 1000)); // minutes

                String ago;
                if (diff < 15) {
                    ago = res.getString(R.string.cache_offline_time_mins_few);
                } else if (diff < 50) {
                    ago = res.getString(R.string.cache_offline_time_about) + " " + diff + " " + res.getString(R.string.cache_offline_time_mins);
                } else if (diff < 90) {
                    ago = res.getString(R.string.cache_offline_time_about) + " " + res.getString(R.string.cache_offline_time_hour);
                } else if (diff < (48 * 60)) {
                    ago = res.getString(R.string.cache_offline_time_about) + " " + (diff / 60) + " " + res.getString(R.string.cache_offline_time_hours);
                } else {
                    ago = res.getString(R.string.cache_offline_time_about) + " " + (diff / (24 * 60)) + " " + res.getString(R.string.cache_offline_time_days);
                }

                offlineText.setText(res.getString(R.string.cache_offline_stored) + "\n" + ago);
                offlineRefresh.setOnClickListener(new RefreshCacheClickListener());

                offlineStore.setText(res.getString(R.string.cache_offline_drop));
                offlineStore.setClickable(true);
                offlineStore.setOnClickListener(new DropCacheClickListener());
            } else {
                offlineText.setText(res.getString(R.string.cache_offline_not_ready));
                offlineRefresh.setOnClickListener(new RefreshCacheClickListener());

                offlineStore.setText(res.getString(R.string.cache_offline_store));
                offlineStore.setClickable(true);
                offlineStore.setOnClickListener(new StoreCacheClickListener());
            }
            offlineRefresh.setVisibility(cache.supportsRefresh() ? View.VISIBLE : View.GONE);
            offlineRefresh.setClickable(true);
        }

        private class PreviewMapTask extends AsyncTask<Void, Void, BitmapDrawable> {
            @Override
            protected BitmapDrawable doInBackground(Void... parameters) {
                try {
                    // persistent preview from storage
                    Bitmap image = decode(cache);

                    if (image == null) {
                        StaticMapsProvider.storeCachePreviewMap(cache);
                        image = decode(cache);
                        if (image == null) {
                            return null;
                        }
                    }

                    return ImageHelper.scaleBitmapToFitDisplay(image);
                } catch (Exception e) {
                    Log.w("CacheDetailActivity.PreviewMapTask", e);
                    return null;
                }
            }

            private Bitmap decode(final cgCache cache) {
                return StaticMapsProvider.getPreviewMap(cache.getGeocode());
            }

            @Override
            protected void onPostExecute(BitmapDrawable image) {
                if (image == null) {
                    return;
                }

                try {
                    final Bitmap bitmap = image.getBitmap();
                    if (bitmap == null || bitmap.getWidth() <= 10) {
                        return;
                    }

                    ((ImageView) view.findViewById(R.id.map_preview)).setImageDrawable(image);
                    view.findViewById(R.id.map_preview_box).setVisibility(View.VISIBLE);
                } catch (Exception e) {
                    Log.e("CacheDetailActivity.PreviewMapTask", e);
                }
            }
        }

    }

    private class DescriptionViewCreator extends AbstractCachingPageViewCreator<ScrollView> {

        @Override
        public ScrollView getDispatchedView() {
            if (cache == null) {
                // something is really wrong
                return null;
            }

            view = (ScrollView) getLayoutInflater().inflate(R.layout.cacheview_description, null);

            // cache short description
            if (StringUtils.isNotBlank(cache.getShortDescription())) {
                new LoadDescriptionTask().execute(cache.getShortDescription(), view.findViewById(R.id.shortdesc), null);
                registerForContextMenu(view.findViewById(R.id.shortdesc));
            }

            // long description
            if (StringUtils.isNotBlank(cache.getDescription())) {
                if (Settings.isAutoLoadDescription()) {
                    loadLongDescription();
                } else {
                    Button showDesc = (Button) view.findViewById(R.id.show_description);
                    showDesc.setVisibility(View.VISIBLE);
                    showDesc.setOnClickListener(new View.OnClickListener() {
                        @Override
                        public void onClick(View arg0) {
                            loadLongDescription();
                        }
                    });
                }
            }

            // cache personal note
            final TextView personalNoteView = (TextView) view.findViewById(R.id.personalnote);
            setPersonalNote(personalNoteView);
            personalNoteView.setMovementMethod(LinkMovementMethod.getInstance());
            registerForContextMenu(personalNoteView);
            final Button personalNoteEdit = (Button) view.findViewById(R.id.edit_personalnote);
            if (cache.isOffline()) {
                personalNoteEdit.setVisibility(View.VISIBLE);
                personalNoteEdit.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(View v) {
                        EditorDialog editor = new EditorDialog(CacheDetailActivity.this, personalNoteView.getText());
                        editor.setOnEditorUpdate(new EditorDialog.EditorUpdate() {
                            @Override
                            public void update(CharSequence editorText) {
                                cache.setPersonalNote(editorText.toString());
                                setPersonalNote(personalNoteView);
                                cgData.saveCache(cache, EnumSet.of(SaveFlag.SAVE_DB));
                            }
                        });
                        editor.show();
                    }
                });
            } else {
                personalNoteEdit.setVisibility(View.INVISIBLE);
            }

            // cache hint and spoiler images
            final View hintBoxView = view.findViewById(R.id.hint_box);
            if (StringUtils.isNotBlank(cache.getHint()) || CollectionUtils.isNotEmpty(cache.getSpoilers())) {
                hintBoxView.setVisibility(View.VISIBLE);
            } else {
                hintBoxView.setVisibility(View.GONE);
            }

            final TextView hintView = ((TextView) view.findViewById(R.id.hint));
            if (StringUtils.isNotBlank(cache.getHint())) {
                if (BaseUtils.containsHtml(cache.getHint())) {
                    hintView.setText(Html.fromHtml(cache.getHint(), new HtmlImage(cache.getGeocode(), false, cache.getListId(), false), null), TextView.BufferType.SPANNABLE);
                    hintView.setText(CryptUtils.rot13((Spannable) hintView.getText()));
                }
                else {
                    hintView.setText(CryptUtils.rot13(cache.getHint()));
                }
                hintView.setVisibility(View.VISIBLE);
                hintView.setClickable(true);
                hintView.setOnClickListener(new DecryptTextClickListener());
                registerForContextMenu(hintView);
            } else {
                hintView.setVisibility(View.GONE);
                hintView.setClickable(false);
                hintView.setOnClickListener(null);
            }

            final TextView spoilerlinkView = ((TextView) view.findViewById(R.id.hint_spoilerlink));
            if (CollectionUtils.isNotEmpty(cache.getSpoilers())) {
                spoilerlinkView.setVisibility(View.VISIBLE);
                spoilerlinkView.setClickable(true);
                spoilerlinkView.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(View arg0) {
                        if (cache == null || CollectionUtils.isEmpty(cache.getSpoilers())) {
                            showToast(res.getString(R.string.err_detail_no_spoiler));
                            return;
                        }

                        ImagesActivity.startActivitySpoilerImages(CacheDetailActivity.this, cache.getGeocode(), cache.getSpoilers());
                    }
                });
            } else {
                spoilerlinkView.setVisibility(View.GONE);
                spoilerlinkView.setClickable(true);
                spoilerlinkView.setOnClickListener(null);
            }

            return view;
        }

        private void setPersonalNote(final TextView personalNoteView) {
            final String personalNote = cache.getPersonalNote();
            personalNoteView.setText(personalNote, TextView.BufferType.SPANNABLE);
            if (StringUtils.isNotBlank(personalNote)) {
                personalNoteView.setVisibility(View.VISIBLE);
            }
            else {
                personalNoteView.setVisibility(View.GONE);
            }
        }

        private void loadLongDescription() {
            Button showDesc = (Button) view.findViewById(R.id.show_description);
            showDesc.setVisibility(View.GONE);
            showDesc.setOnClickListener(null);
            view.findViewById(R.id.loading).setVisibility(View.VISIBLE);

            new LoadDescriptionTask().execute(cache.getDescription(), view.findViewById(R.id.longdesc), view.findViewById(R.id.loading));
            registerForContextMenu(view.findViewById(R.id.longdesc));
        }

    }

    /**
     * Loads the description in background. <br />
     * <br />
     * Params:
     * <ol>
     * <li>description string (String)</li>
     * <li>target description view (TextView)</li>
     * <li>loading indicator view (View, may be null)</li>
     * </ol>
     */
    private class LoadDescriptionTask extends AsyncTask<Object, Void, Void> {
        private View loadingIndicatorView;
        private TextView descriptionView;
        private String descriptionString;
        private Spanned description;

        private class HtmlImageCounter implements Html.ImageGetter {

            private int imageCount = 0;

            @Override
            public Drawable getDrawable(String url) {
                imageCount++;
                return null;
            }

            public int getImageCount() {
                return imageCount;
            }
        }

        @Override
        protected Void doInBackground(Object... params) {
            try {
                descriptionString = ((String) params[0]);
                descriptionView = (TextView) params[1];
                loadingIndicatorView = (View) params[2];

                // Fast preview: parse only HTML without loading any images
                HtmlImageCounter imageCounter = new HtmlImageCounter();
                final UnknownTagsHandler unknownTagsHandler = new UnknownTagsHandler();
                description = Html.fromHtml(descriptionString, imageCounter, unknownTagsHandler);
                publishProgress();
                if (imageCounter.getImageCount() > 0) {
                    // Complete view: parse again with loading images - if necessary ! If there are any images causing problems the user can see at least the preview
                    description = Html.fromHtml(descriptionString, new HtmlImage(cache.getGeocode(), true, cache.getListId(), false), unknownTagsHandler);
                    publishProgress();
                }

                // If description has an HTML construct which may be problematic to render, add a note at the end of the long description.
                // Technically, it may not be a table, but a pre, which has the same problems as a table, so the message is ok even though
                // sometimes technically incorrect.
                if (unknownTagsHandler.isProblematicDetected() && descriptionView != null) {
                    final int startPos = description.length();
                    ((Editable) description).append("\n\n").append(res.getString(R.string.cache_description_table_note));
                    ((Editable) description).setSpan(new StyleSpan(Typeface.ITALIC), startPos, description.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
                    publishProgress();
                }
            } catch (Exception e) {
                Log.e("LoadDescriptionTask: ", e);
            }
            return null;
        }

        /*
         * (non-Javadoc)
         *
         * @see android.os.AsyncTask#onProgressUpdate(Progress[])
         */
        @Override
        protected void onProgressUpdate(Void... values) {
            if (description != null) {
                if (StringUtils.isNotBlank(descriptionString)) {
                    descriptionView.setText(description, TextView.BufferType.SPANNABLE);
                    descriptionView.setMovementMethod(LinkMovementMethod.getInstance());
                    fixBlackTextColor(descriptionView, descriptionString);
                }

                descriptionView.setVisibility(View.VISIBLE);
            } else {
                showToast(res.getString(R.string.err_load_descr_failed));
            }

            if (null != loadingIndicatorView) {
                loadingIndicatorView.setVisibility(View.GONE);
            }
        }

        /**
         * handle caches with black font color
         *
         * @param view
         * @param text
         */
        private void fixBlackTextColor(final TextView view, final String text) {
            if (Settings.isLightSkin()) {
                return;
            }
            int backcolor = color.black;
            if (-1 != StringUtils.indexOfAny(text, new String[] { "color=\"black", "color=\"#000080\"" })) {
                backcolor = color.darker_gray;
            }
            else {
                MatcherWrapper matcher = new MatcherWrapper(DARK_COLOR_PATTERN, text);
                if (matcher.find()) {
                    backcolor = color.darker_gray;
                }
            }
            view.setBackgroundResource(backcolor);
        }
    }

    private class LogsViewCreator extends AbstractCachingPageViewCreator<ListView> {
        private final boolean allLogs;

        LogsViewCreator(boolean allLogs) {
            this.allLogs = allLogs;
        }

        @Override
        public ListView getDispatchedView() {
            if (cache == null) {
                // something is really wrong
                return null;
            }

            view = (ListView) getLayoutInflater().inflate(R.layout.cacheview_logs, null);

            // log count
            final Map<LogType, Integer> logCounts = cache.getLogCounts();
            if (logCounts != null) {
                final List<Entry<LogType, Integer>> sortedLogCounts = new ArrayList<Entry<LogType, Integer>>(logCounts.size());
                for (Entry<LogType, Integer> entry : logCounts.entrySet()) {
                    // it may happen that the label is unknown -> then avoid any output for this type
                    if (entry.getKey() != LogType.PUBLISH_LISTING && entry.getKey().getL10n() != null) {
                        sortedLogCounts.add(entry);
                    }
                }

                if (!sortedLogCounts.isEmpty()) {
                    // sort the log counts by type id ascending. that way the FOUND, DNF log types are the first and most visible ones
                    Collections.sort(sortedLogCounts, new Comparator<Entry<LogType, Integer>>() {

                        @Override
                        public int compare(Entry<LogType, Integer> logCountItem1, Entry<LogType, Integer> logCountItem2) {
                            return logCountItem1.getKey().compareTo(logCountItem2.getKey());
                        }
                    });

                    ArrayList<String> labels = new ArrayList<String>(sortedLogCounts.size());
                    for (Entry<LogType, Integer> pair : sortedLogCounts) {
                        labels.add(pair.getValue() + " " + pair.getKey().getL10n());
                    }

                    final TextView countView = new TextView(CacheDetailActivity.this);
                    countView.setText(res.getString(R.string.cache_log_types) + ": " + StringUtils.join(labels, ", "));
                    view.addHeaderView(countView, null, false);
                }
            }

            final List<LogEntry> logs = allLogs ? cache.getLogs().asList() : cache.getFriendsLogs();
            view.setAdapter(new ArrayAdapter<LogEntry>(CacheDetailActivity.this, R.layout.cacheview_logs_item, logs) {
                final UserActionsClickListener userActionsClickListener = new UserActionsClickListener();
                final DecryptTextClickListener decryptTextClickListener = new DecryptTextClickListener();

                @Override
                public View getView(final int position, final View convertView, final ViewGroup parent) {
                    View rowView = convertView;
                    if (null == rowView) {
                        rowView = getLayoutInflater().inflate(R.layout.cacheview_logs_item, null);
                    }
                    LogViewHolder holder = (LogViewHolder) rowView.getTag();
                    if (null == holder) {
                        holder = new LogViewHolder(rowView);
                        rowView.setTag(holder);
                    }

                    final LogEntry log = getItem(position);

                    if (log.date > 0) {
                        holder.date.setText(Formatter.formatShortDate(log.date));
                        holder.date.setVisibility(View.VISIBLE);
                    } else {
                        holder.date.setVisibility(View.GONE);
                    }

                    holder.type.setText(log.type.getL10n());
                    holder.author.setText(StringEscapeUtils.unescapeHtml4(log.author));

                    // finds count
                    holder.count.setVisibility(View.VISIBLE);
                    if (log.found == -1) {
                        holder.count.setVisibility(View.GONE);
                    } else {
                        holder.count.setText(res.getQuantityString(R.plurals.cache_counts, log.found, log.found));
                    }

                    // logtext, avoid parsing HTML if not necessary
                    String logText = log.log;
                    if (BaseUtils.containsHtml(logText)) {
                        logText = log.getDisplayText();
                        holder.text.setText(Html.fromHtml(logText, new HtmlImage(cache.getGeocode(), false, cache.getListId(), false), null), TextView.BufferType.SPANNABLE);
                    }
                    else {
                        holder.text.setText(logText);
                    }

                    // images
                    if (log.hasLogImages()) {
                        holder.images.setText(log.getImageTitles());
                        holder.images.setVisibility(View.VISIBLE);
                        holder.images.setOnClickListener(new View.OnClickListener() {
                            @Override
                            public void onClick(View v) {
                                ImagesActivity.startActivityLogImages(CacheDetailActivity.this, cache.getGeocode(), new ArrayList<Image>(log.getLogImages()));
                            }
                        });
                    } else {
                        holder.images.setVisibility(View.GONE);
                    }

                    // colored marker
                    int marker = log.type.markerId;
                    if (marker != 0) {
                        holder.statusMarker.setVisibility(View.VISIBLE);
                        holder.statusMarker.setImageResource(marker);
                    }
                    else {
                        holder.statusMarker.setVisibility(View.GONE);
                    }

                    if (null == convertView) {
                        // if convertView != null then this listeners are already set
                        holder.author.setOnClickListener(userActionsClickListener);
                        holder.text.setMovementMethod(LinkMovementMethod.getInstance());
                        holder.text.setOnClickListener(decryptTextClickListener);
                        registerForContextMenu(holder.text);
                    }

                    return rowView;
                }
            });

            return view;
        }

        private class LogViewHolder {
            final TextView date;
            final TextView type;
            final TextView author;
            final TextView count;
            final TextView text;
            final TextView images;
            final ImageView statusMarker;

            public LogViewHolder(View base) {
                date = (TextView) base.findViewById(R.id.added);
                type = (TextView) base.findViewById(R.id.type);
                author = (TextView) base.findViewById(R.id.author);
                count = (TextView) base.findViewById(R.id.count);
                text = (TextView) base.findViewById(R.id.log);
                images = (TextView) base.findViewById(R.id.log_images);
                statusMarker = (ImageView) base.findViewById(R.id.log_mark);
            }
        }
    }

    private class WaypointsViewCreator extends AbstractCachingPageViewCreator<ScrollView> {

        @Override
        public ScrollView getDispatchedView() {
            if (cache == null) {
                // something is really wrong
                return null;
            }

            view = (ScrollView) getLayoutInflater().inflate(R.layout.cacheview_waypoints, null);

            final LinearLayout waypoints = (LinearLayout) view.findViewById(R.id.waypoints);

            // sort waypoints: PP, Sx, FI, OWN
            final List<Waypoint> sortedWaypoints = new ArrayList<Waypoint>(cache.getWaypoints());
            Collections.sort(sortedWaypoints);

            for (final Waypoint wpt : sortedWaypoints) {
                final LinearLayout waypointView = (LinearLayout) getLayoutInflater().inflate(R.layout.waypoint_item, null);

                // coordinates
                if (null != wpt.getCoords()) {
                    final TextView coordinatesView = (TextView) waypointView.findViewById(R.id.coordinates);
                    coordinatesView.setText(wpt.getCoords().toString());
                    coordinatesView.setVisibility(View.VISIBLE);
                }

                // info
                final String waypointInfo = Formatter.formatWaypointInfo(wpt);
                if (StringUtils.isNotBlank(waypointInfo)) {
                    final TextView infoView = (TextView) waypointView.findViewById(R.id.info);
                    infoView.setText(waypointInfo);
                    infoView.setVisibility(View.VISIBLE);
                }

                // title
                final TextView nameView = (TextView) waypointView.findViewById(R.id.name);
                if (StringUtils.isNotBlank(wpt.getName())) {
                    nameView.setText(StringEscapeUtils.unescapeHtml4(wpt.getName()));
                } else if (null != wpt.getCoords()) {
                    nameView.setText(wpt.getCoords().toString());
                } else {
                    nameView.setText(res.getString(R.string.waypoint));
                }
                wpt.setIcon(res, nameView);

                // note
                if (StringUtils.isNotBlank(wpt.getNote())) {
                    final TextView noteView = (TextView) waypointView.findViewById(R.id.note);
                    noteView.setVisibility(View.VISIBLE);
                    if (BaseUtils.containsHtml(wpt.getNote())) {
                        noteView.setText(Html.fromHtml(wpt.getNote()), TextView.BufferType.SPANNABLE);
                    }
                    else {
                        noteView.setText(wpt.getNote());
                    }
                }

                final View wpNavView = waypointView.findViewById(R.id.wpDefaultNavigation);
                wpNavView.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(View v) {
                        NavigationAppFactory.startDefaultNavigationApplication(1, CacheDetailActivity.this, wpt);
                    }
                });
                wpNavView.setOnLongClickListener(new View.OnLongClickListener() {
                    @Override
                    public boolean onLongClick(View v) {
                        NavigationAppFactory.startDefaultNavigationApplication(2, CacheDetailActivity.this, wpt);
                        return true;
                    }
                });

                registerForContextMenu(waypointView);
                waypointView.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(View v) {
                        openContextMenu(v);
                    }
                });

                waypoints.addView(waypointView);
            }

            final Button addWaypoint = (Button) view.findViewById(R.id.add_waypoint);
            addWaypoint.setClickable(true);
            addWaypoint.setOnClickListener(new View.OnClickListener() {

                @Override
                public void onClick(View v) {
                    EditWaypointActivity.startActivityAddWaypoint(CacheDetailActivity.this, cache);
                    refreshOnResume = true;
                }
            });

            return view;
        }
    }

    private class InventoryViewCreator extends AbstractCachingPageViewCreator<ListView> {

        @Override
        public ListView getDispatchedView() {
            if (cache == null) {
                // something is really wrong
                return null;
            }

            view = (ListView) getLayoutInflater().inflate(R.layout.cacheview_inventory, null);

            // TODO: fix layout, then switch back to Android-resource and delete copied one
            // this copy is modified to respect the text color
            view.setAdapter(new ArrayAdapter<Trackable>(CacheDetailActivity.this, R.layout.simple_list_item_1, cache.getInventory()));
            view.setOnItemClickListener(new OnItemClickListener() {
                @Override
                public void onItemClick(AdapterView<?> arg0, View arg1, int arg2, long arg3) {
                    Object selection = arg0.getItemAtPosition(arg2);
                    if (selection instanceof Trackable) {
                        Trackable trackable = (Trackable) selection;
                        TrackableActivity.startActivity(CacheDetailActivity.this, trackable.getGuid(), trackable.getGeocode(), trackable.getName());
                    }
                }
            });

            return view;
        }
    }

    private class ImagesViewCreator extends AbstractCachingPageViewCreator<View> {

        @Override
        public View getDispatchedView() {
            if (cache == null) {
                return null; // something is really wrong
            }

            view = getLayoutInflater().inflate(R.layout.caches_images, null);
            if (imagesList == null && isCurrentPage(Page.IMAGES)) {
                loadCacheImages();
            }
            return view;
        }
    }

    public static void startActivity(final Context context, final String geocode, final String cacheName) {
        final Intent cachesIntent = new Intent(context, CacheDetailActivity.class);
        cachesIntent.putExtra("geocode", geocode);
        cachesIntent.putExtra("name", cacheName);
        context.startActivity(cachesIntent);
    }

    public static void startActivityGuid(final Context context, final String guid, final String cacheName) {
        final Intent cacheIntent = new Intent(context, CacheDetailActivity.class);
        cacheIntent.putExtra("guid", guid);
        cacheIntent.putExtra("name", cacheName);
        context.startActivity(cacheIntent);
    }

    /**
     * A dialog to allow the user to select reseting coordinates local/remote/both.
     */
    private class ResetCacheCoordinatesDialog extends AlertDialog {

        final RadioButton resetBoth;
        final RadioButton resetLocal;

        public ResetCacheCoordinatesDialog(final cgCache cache, final Waypoint wpt, final Activity activity) {
            super(activity);

            View layout = activity.getLayoutInflater().inflate(R.layout.reset_cache_coords_dialog, null);
            setView(layout);

            resetLocal = (RadioButton) layout.findViewById(R.id.reset_cache_coordinates_local);
            resetBoth = (RadioButton) layout.findViewById(R.id.reset_cache_coordinates_local_and_remote);

            if (ConnectorFactory.getConnector(cache).supportsOwnCoordinates()) {
                resetBoth.setVisibility(View.VISIBLE);
            }

            layout.findViewById(R.id.reset).setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    dismiss();
                    final ProgressDialog p = ProgressDialog.show(CacheDetailActivity.this, res.getString(R.string.cache), res.getString(R.string.waypoint_reset), true);
                    final Handler h = new Handler() {
                        private boolean remoteFinished = false;
                        private boolean localFinished = false;

                        @Override
                        public void handleMessage(Message msg) {
                            if (msg.what == ResetCoordsThread.LOCAL) {
                                localFinished = true;
                            } else {
                                remoteFinished = true;
                            }

                            if ((localFinished) && (remoteFinished || !resetBoth.isChecked())) {
                                p.dismiss();
                                notifyDataSetChanged();
                            }
                        }

                    };
                    new ResetCoordsThread(cache, h, wpt, resetLocal.isChecked() || resetBoth.isChecked(), resetBoth.isChecked(), p).start();
                }
            });
        }
    }

    private class ResetCoordsThread extends Thread {

        private final cgCache cache;
        private final Handler handler;
        private final boolean local;
        private final boolean remote;
        private final Waypoint wpt;
        private ProgressDialog progress;
        public static final int LOCAL = 0;
        public static final int ON_WEBSITE = 1;

        public ResetCoordsThread(cgCache cache, Handler handler, final Waypoint wpt, boolean local, boolean remote, final ProgressDialog progress) {
            this.cache = cache;
            this.handler = handler;
            this.local = local;
            this.remote = remote;
            this.wpt = wpt;
            this.progress = progress;
        }

        @Override
        public void run() {

            if (local) {
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        progress.setMessage(res.getString(R.string.waypoint_reset_cache_coords));
                    }
                });
                cache.setCoords(wpt.getCoords());
                cache.setUserModifiedCoords(false);
                cache.deleteWaypointForce(wpt);
                cgData.saveChangedCache(cache);
                handler.sendEmptyMessage(LOCAL);
            }

            IConnector con = ConnectorFactory.getConnector(cache);
            if (remote && con.supportsOwnCoordinates()) {
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        progress.setMessage(res.getString(R.string.waypoint_coordinates_being_reset_on_website));
                    }
                });

                final boolean result = con.deleteModifiedCoordinates(cache);

                runOnUiThread(new Runnable() {

                    @Override
                    public void run() {
                        if (result) {
                            showToast(getString(R.string.waypoint_coordinates_has_been_reset_on_website));
                        } else {
                            showToast(getString(R.string.waypoint_coordinates_upload_error));
                        }
                        handler.sendEmptyMessage(ON_WEBSITE);
                        notifyDataSetChanged();
                    }

                });

            }
        }
    }

    @Override
    protected String getTitle(Page page) {
        // show number of waypoints directly in waypoint title
        if (page == Page.WAYPOINTS) {
            final int waypointCount = cache.getWaypoints().size();
            return res.getQuantityString(R.plurals.waypoints, waypointCount, waypointCount);
        }
        return res.getString(page.titleStringId);
    }

    @Override
    protected Pair<List<? extends Page>, Integer> getOrderedPages() {
        final ArrayList<Page> pages = new ArrayList<Page>();
        pages.add(Page.WAYPOINTS);
        pages.add(Page.DETAILS);
        final int detailsIndex = pages.size() - 1;
        pages.add(Page.DESCRIPTION);
        if (cache.getLogs().isNotEmpty()) {
            pages.add(Page.LOGS);
        }
        if (CollectionUtils.isNotEmpty(cache.getFriendsLogs())) {
            pages.add(Page.LOGSFRIENDS);
        }
        if (CollectionUtils.isNotEmpty(cache.getInventory())) {
            pages.add(Page.INVENTORY);
        }
        if (CollectionUtils.isNotEmpty(cache.getImages())) {
            pages.add(Page.IMAGES);
        }
        return new ImmutablePair<List<? extends Page>, Integer>(pages, detailsIndex);
    }

    @Override
    protected AbstractViewPagerActivity.PageViewCreator createViewCreator(Page page) {
        switch (page) {
            case DETAILS:
                return new DetailsViewCreator();

            case DESCRIPTION:
                return new DescriptionViewCreator();

            case LOGS:
                return new LogsViewCreator(true);

            case LOGSFRIENDS:
                return new LogsViewCreator(false);

            case WAYPOINTS:
                return new WaypointsViewCreator();

            case INVENTORY:
                return new InventoryViewCreator();

            case IMAGES:
                return new ImagesViewCreator();

            default:
                throw new IllegalArgumentException();
        }
    }

}
!@#$%
20190527_000946,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_a13452
package cgeo.geocaching;

import cgeo.calendar.ICalendar;
import cgeo.geocaching.activity.AbstractViewPagerActivity;
import cgeo.geocaching.activity.Progress;
import cgeo.geocaching.apps.cache.navi.NavigationAppFactory;
import cgeo.geocaching.compatibility.Compatibility;
import cgeo.geocaching.connector.ConnectorFactory;
import cgeo.geocaching.connector.IConnector;
import cgeo.geocaching.connector.gc.GCConnector;
import cgeo.geocaching.enumerations.CacheAttribute;
import cgeo.geocaching.enumerations.LoadFlags;
import cgeo.geocaching.enumerations.LoadFlags.SaveFlag;
import cgeo.geocaching.enumerations.LogType;
import cgeo.geocaching.enumerations.WaypointType;
import cgeo.geocaching.geopoint.GeopointFormatter;
import cgeo.geocaching.geopoint.Units;
import cgeo.geocaching.network.HtmlImage;
import cgeo.geocaching.network.Network;
import cgeo.geocaching.network.Parameters;
import cgeo.geocaching.ui.AbstractCachingPageViewCreator;
import cgeo.geocaching.ui.CacheDetailsCreator;
import cgeo.geocaching.ui.DecryptTextClickListener;
import cgeo.geocaching.ui.EditorDialog;
import cgeo.geocaching.ui.Formatter;
import cgeo.geocaching.ui.ImagesList;
import cgeo.geocaching.ui.ImagesList.ImageType;
import cgeo.geocaching.ui.LoggingUI;
import cgeo.geocaching.utils.BaseUtils;
import cgeo.geocaching.utils.CancellableHandler;
import cgeo.geocaching.utils.ClipboardUtils;
import cgeo.geocaching.utils.CryptUtils;
import cgeo.geocaching.utils.GeoDirHandler;
import cgeo.geocaching.utils.HtmlUtils;
import cgeo.geocaching.utils.ImageHelper;
import cgeo.geocaching.utils.Log;
import cgeo.geocaching.utils.MatcherWrapper;
import cgeo.geocaching.utils.TranslationUtils;
import cgeo.geocaching.utils.UnknownTagsHandler;

import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang3.StringEscapeUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.apache.commons.lang3.tuple.Pair;

import android.R.color;
import android.app.Activity;
import android.app.AlertDialog;
import android.app.ProgressDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.graphics.Bitmap;
import android.graphics.Typeface;
import android.graphics.drawable.BitmapDrawable;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.text.Editable;
import android.text.Html;
import android.text.Spannable;
import android.text.Spanned;
import android.text.format.DateUtils;
import android.text.method.LinkMovementMethod;
import android.text.style.ForegroundColorSpan;
import android.text.style.StrikethroughSpan;
import android.text.style.StyleSpan;
import android.view.ContextMenu;
import android.view.Menu;
import android.view.MenuItem;
import android.view.SubMenu;
import android.view.View;
import android.view.View.OnLongClickListener;
import android.view.ViewGroup;
import android.view.ViewGroup.LayoutParams;
import android.view.ViewParent;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.ArrayAdapter;
import android.widget.Button;
import android.widget.FrameLayout;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.ListView;
import android.widget.RadioButton;
import android.widget.ScrollView;
import android.widget.TextView;
import android.widget.TextView.BufferType;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.EnumSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Map.Entry;
import java.util.regex.Pattern;

/**
 * Activity to handle all single-cache-stuff.
 *
 * e.g. details, description, logs, waypoints, inventory...
 */
public class CacheDetailActivity extends AbstractViewPagerActivity<CacheDetailActivity.Page> {

    private static final int MENU_FIELD_COPY = 1;
    private static final int MENU_FIELD_TRANSLATE = 2;
    private static final int MENU_FIELD_TRANSLATE_EN = 3;
    private static final int MENU_FIELD_SHARE = 4;
    private static final int MENU_SHARE = 12;
    private static final int MENU_CALENDAR = 11;
    private static final int MENU_CACHES_AROUND = 10;
    private static final int MENU_BROWSER = 7;
    private static final int MENU_DEFAULT_NAVIGATION = 13;

    private static final int CONTEXT_MENU_WAYPOINT_EDIT = 1234;
    private static final int CONTEXT_MENU_WAYPOINT_DUPLICATE = 1235;
    private static final int CONTEXT_MENU_WAYPOINT_DELETE = 1236;
    private static final int CONTEXT_MENU_WAYPOINT_NAVIGATE = 1238;
    private static final int CONTEXT_MENU_WAYPOINT_CACHES_AROUND = 1239;
    private static final int CONTEXT_MENU_WAYPOINT_DEFAULT_NAVIGATION = 1240;
    private static final int CONTEXT_MENU_WAYPOINT_RESET_ORIGINAL_CACHE_COORDINATES = 1241;

    private static final Pattern DARK_COLOR_PATTERN = Pattern.compile(Pattern.quote("color=\"#") + "(0[0-9]){3}" + "\"");

    private cgCache cache;
    private final Progress progress = new Progress();
    private SearchResult search;

    private final GeoDirHandler locationUpdater = new GeoDirHandler() {
        @Override
        public void updateGeoData(final IGeoData geo) {
            if (cacheDistanceView == null) {
                return;
            }

            try {
                final StringBuilder dist = new StringBuilder();

                if (geo.getCoords() != null && cache != null && cache.getCoords() != null) {
                    dist.append(Units.getDistanceFromKilometers(geo.getCoords().distanceTo(cache.getCoords())));
                }

                if (cache != null && cache.getElevation() != null) {
                    if (geo.getAltitude() != 0.0) {
                        final float diff = (float) (cache.getElevation() - geo.getAltitude());
                        dist.append(' ').append(Units.getElevation(diff));
                    }
                }

                cacheDistanceView.setText(dist.toString());
                cacheDistanceView.bringToFront();
            } catch (Exception e) {
                Log.w("Failed to update location.");
            }
        }
    };

    private CharSequence clickedItemText = null;
    private int contextMenuWPIndex = -1;

    /**
     * If another activity is called and can modify the data of this activity, we refresh it on resume.
     */
    private boolean refreshOnResume = false;

    // some views that must be available from everywhere // TODO: Reference can block GC?
    private TextView cacheDistanceView;

    private Handler cacheChangeNotificationHandler = new Handler() {
        @Override
        public void handleMessage(Message msg) {
            notifyDataSetChanged();
        }
    };
    protected ImagesList imagesList;

    public CacheDetailActivity() {
        // identifier for manual
        super("c:geolocation-cache-details");
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        // initialize the main view and set a default title
        setTheme();
        setContentView(R.layout.cacheview);
        setTitle(res.getString(R.string.cache));

        String geocode = null;

        // TODO Why can it happen that search is not null? onCreate should be called only once and it is not set before.
        if (search != null) {
            cache = search.getFirstCacheFromResult(LoadFlags.LOAD_ALL_DB_ONLY);
            if (cache != null && cache.getGeocode() != null) {
                geocode = cache.getGeocode();
            }
        }

        // get parameters
        final Bundle extras = getIntent().getExtras();
        final Uri uri = getIntent().getData();

        // try to get data from extras
        String name = null;
        String guid = null;
        if (geocode == null && extras != null) {
            geocode = extras.getString("geocode");
            name = extras.getString("name");
            guid = extras.getString("guid");
        }

        // try to get data from URI
        if (geocode == null && guid == null && uri != null) {
            String uriHost = uri.getHost().toLowerCase(Locale.US);
            String uriPath = uri.getPath().toLowerCase(Locale.US);
            String uriQuery = uri.getQuery();

            if (uriQuery != null) {
                Log.i("Opening URI: " + uriHost + uriPath + "?" + uriQuery);
            } else {
                Log.i("Opening URI: " + uriHost + uriPath);
            }

            if (uriHost.contains("geocaching.com")) {
                geocode = uri.getQueryParameter("wp");
                guid = uri.getQueryParameter("guid");

                if (StringUtils.isNotBlank(geocode)) {
                    geocode = geocode.toUpperCase(Locale.US);
                    guid = null;
                } else if (StringUtils.isNotBlank(guid)) {
                    geocode = null;
                    guid = guid.toLowerCase(Locale.US);
                } else {
                    showToast(res.getString(R.string.err_detail_open));
                    finish();
                    return;
                }
            } else if (uriHost.contains("coord.info")) {
                if (uriPath != null && uriPath.startsWith("/gc")) {
                    geocode = uriPath.substring(1).toUpperCase(Locale.US);
                } else {
                    showToast(res.getString(R.string.err_detail_open));
                    finish();
                    return;
                }
            }
        }

        // no given data
        if (geocode == null && guid == null) {
            showToast(res.getString(R.string.err_detail_cache));
            finish();
            return;
        }

        final LoadCacheHandler loadCacheHandler = new LoadCacheHandler();

        try {
            String title = res.getString(R.string.cache);
            if (StringUtils.isNotBlank(name)) {
                title = name;
            } else if (null != geocode && StringUtils.isNotBlank(geocode)) { // can't be null, but the compiler doesn't understand StringUtils.isNotBlank()
                title = geocode;
            }
            progress.show(this, title, res.getString(R.string.cache_dialog_loading_details), true, loadCacheHandler.cancelMessage());
        } catch (Exception e) {
            // nothing, we lost the window
        }

        ImageView defaultNavigationImageView = (ImageView) findViewById(R.id.defaultNavigation);
        defaultNavigationImageView.setOnLongClickListener(new OnLongClickListener() {
            @Override
            public boolean onLongClick(View v) {
                startDefaultNavigation2();
                return true;
            }
        });

        final int pageToOpen = Settings.isOpenLastDetailsPage() ? Settings.getLastDetailsPage() : 1;
        createViewPager(pageToOpen, new OnPageSelectedListener() {

            @Override
            public void onPageSelected(int position) {
                if (Settings.isOpenLastDetailsPage()) {
                    Settings.setLastDetailsPage(position);
                }
                // lazy loading of cache images
                if (getPage(position) == Page.IMAGES) {
                    loadCacheImages();
                }
            }
        });

        // Initialization done. Let's load the data with the given information.
        new LoadCacheThread(geocode, guid, loadCacheHandler).start();
    }

    @Override
    public void onResume() {
        super.onResume();

        if (refreshOnResume) {
            notifyDataSetChanged();
            refreshOnResume = false;
        }
        locationUpdater.startGeo();
    }

    @Override
    public void onStop() {
        if (cache != null) {
            cache.setChangeNotificationHandler(null);
        }
        super.onStop();
    }

    @Override
    public void onPause() {
        locationUpdater.stopGeo();
        super.onPause();
    }

    @Override
    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenu.ContextMenuInfo info) {
        super.onCreateContextMenu(menu, view, info);
        final int viewId = view.getId();
        contextMenuWPIndex = -1;
        switch (viewId) {
            case R.id.value: // coordinates
                clickedItemText = ((TextView) view).getText();
                buildOptionsContextmenu(menu, viewId, res.getString(R.string.cache_coordinates), true);
                break;
            case R.id.shortdesc:
                clickedItemText = ((TextView) view).getText();
                buildOptionsContextmenu(menu, viewId, res.getString(R.string.cache_description), false);
                break;
            case R.id.longdesc:
                // combine short and long description
                String shortDesc = cache.getShortDescription();
                if (StringUtils.isBlank(shortDesc)) {
                    clickedItemText = ((TextView) view).getText();
                } else {
                    clickedItemText = shortDesc + "\n\n" + ((TextView) view).getText();
                }
                buildOptionsContextmenu(menu, viewId, res.getString(R.string.cache_description), false);
                break;
            case R.id.personalnote:
                clickedItemText = ((TextView) view).getText();
                buildOptionsContextmenu(menu, viewId, res.getString(R.string.cache_personal_note), true);
                break;
            case R.id.hint:
                clickedItemText = ((TextView) view).getText();
                buildOptionsContextmenu(menu, viewId, res.getString(R.string.cache_hint), false);
                break;
            case R.id.log:
                clickedItemText = ((TextView) view).getText();
                buildOptionsContextmenu(menu, viewId, res.getString(R.string.cache_logs), false);
                break;
            case -1:
                if (null != cache.getWaypoints()) {
                    try {
                        final ViewGroup parent = ((ViewGroup) view.getParent());
                        for (int i = 0; i < parent.getChildCount(); i++) {
                            if (parent.getChildAt(i) == view) {
                                final List<Waypoint> sortedWaypoints = new ArrayList<Waypoint>(cache.getWaypoints());
                                Collections.sort(sortedWaypoints);
                                final Waypoint waypoint = sortedWaypoints.get(i);
                                final int index = cache.getWaypoints().indexOf(waypoint);
                                menu.setHeaderTitle(res.getString(R.string.waypoint));
                                if (waypoint.getWaypointType().equals(WaypointType.ORIGINAL)) {
                                    menu.add(CONTEXT_MENU_WAYPOINT_RESET_ORIGINAL_CACHE_COORDINATES, index, 0, R.string.waypoint_reset_cache_coords);
                                } else {
                                    menu.add(CONTEXT_MENU_WAYPOINT_EDIT, index, 0, R.string.waypoint_edit);
                                    menu.add(CONTEXT_MENU_WAYPOINT_DUPLICATE, index, 0, R.string.waypoint_duplicate);
                                }
                                contextMenuWPIndex = index;
                                if (waypoint.isUserDefined() && !waypoint.getWaypointType().equals(WaypointType.ORIGINAL)) {
                                    menu.add(CONTEXT_MENU_WAYPOINT_DELETE, index, 0, R.string.waypoint_delete);
                                }
                                if (waypoint.getCoords() != null) {
                                    menu.add(CONTEXT_MENU_WAYPOINT_DEFAULT_NAVIGATION, index, 0, NavigationAppFactory.getDefaultNavigationApplication().getName());
                                    menu.add(CONTEXT_MENU_WAYPOINT_NAVIGATE, index, 0, R.string.cache_menu_navigate).setIcon(R.drawable.ic_menu_mapmode);
                                    menu.add(CONTEXT_MENU_WAYPOINT_CACHES_AROUND, index, 0, R.string.cache_menu_around);
                                }
                                break;
                            }
                        }
                    } catch (Exception e) {
                    }
                }
                break;
            default:
                if (imagesList != null) {
                    imagesList.onCreateContextMenu(menu, view);
                }
                break;
        }
    }

    private void buildOptionsContextmenu(ContextMenu menu, int viewId, String fieldTitle, boolean copyOnly) {
        menu.setHeaderTitle(fieldTitle);
        menu.add(viewId, MENU_FIELD_COPY, 0, res.getString(android.R.string.copy));
        if (!copyOnly) {
            if (clickedItemText.length() > TranslationUtils.translationTextLengthToWarn) {
                showToast(res.getString(R.string.translate_length_warning));
            }
            menu.add(viewId, MENU_FIELD_TRANSLATE, 0, res.getString(R.string.translate_to_sys_lang, Locale.getDefault().getDisplayLanguage()));
            if (Settings.isUseEnglish() && !StringUtils.equals(Locale.getDefault().getLanguage(), Locale.ENGLISH.getLanguage())) {
                menu.add(viewId, MENU_FIELD_TRANSLATE_EN, 0, res.getString(R.string.translate_to_english));
            }

        }
        menu.add(viewId, MENU_FIELD_SHARE, 0, res.getString(R.string.cache_share_field));
    }

    @Override
    public boolean onContextItemSelected(MenuItem item) {
        final int groupId = item.getGroupId();
        final int index = item.getItemId();
        switch (groupId) {
            case R.id.value:
            case R.id.shortdesc:
            case R.id.longdesc:
            case R.id.personalnote:
            case R.id.hint:
            case R.id.log:
                switch (index) {
                    case MENU_FIELD_COPY:
                        ClipboardUtils.copyToClipboard(clickedItemText);
                        showToast(res.getString(R.string.clipboard_copy_ok));
                        return true;
                    case MENU_FIELD_TRANSLATE:
                        TranslationUtils.startActivityTranslate(this, Locale.getDefault().getLanguage(), HtmlUtils.extractText(clickedItemText));
                        return true;
                    case MENU_FIELD_TRANSLATE_EN:
                        TranslationUtils.startActivityTranslate(this, Locale.ENGLISH.getLanguage(), HtmlUtils.extractText(clickedItemText));
                        return true;
                    case MENU_FIELD_SHARE:
                        final Intent intent = new Intent(Intent.ACTION_SEND);
                        intent.setType("text/plain");
                        intent.putExtra(Intent.EXTRA_TEXT, clickedItemText.toString());
                        startActivity(Intent.createChooser(intent, res.getText(R.string.cache_share_field)));
                        return true;
                    default:
                        break;
                }

                break;
            case CONTEXT_MENU_WAYPOINT_EDIT:
                final Waypoint waypointEdit = cache.getWaypoint(index);
                if (waypointEdit != null) {
                    EditWaypointActivity.startActivityEditWaypoint(this, waypointEdit.getId());
                    refreshOnResume = true;
                }
                break;
            case CONTEXT_MENU_WAYPOINT_DUPLICATE:
                final Waypoint waypointDuplicate = cache.getWaypoint(index);
                if (cache.duplicateWaypoint(waypointDuplicate)) {
                    cgData.saveCache(cache, EnumSet.of(SaveFlag.SAVE_DB));
                    notifyDataSetChanged();
                }
                break;
            case CONTEXT_MENU_WAYPOINT_DELETE:
                final Waypoint waypointDelete = cache.getWaypoint(index);
                if (cache.deleteWaypoint(waypointDelete)) {
                    cgData.saveCache(cache, EnumSet.of(SaveFlag.SAVE_DB));
                    notifyDataSetChanged();
                }
                break;
            case CONTEXT_MENU_WAYPOINT_DEFAULT_NAVIGATION:
                final Waypoint waypointNavigation = cache.getWaypoint(index);
                if (waypointNavigation != null) {
                    NavigationAppFactory.startDefaultNavigationApplication(1, this, waypointNavigation);
                }
                break;
            case CONTEXT_MENU_WAYPOINT_NAVIGATE:
                final Waypoint waypointNav = cache.getWaypoint(contextMenuWPIndex);
                if (waypointNav != null) {
                    NavigationAppFactory.showNavigationMenu(this, null, waypointNav, null);
                }
                break;
            case CONTEXT_MENU_WAYPOINT_CACHES_AROUND:
                final Waypoint waypointAround = cache.getWaypoint(index);
                if (waypointAround != null) {
                    cgeocaches.startActivityCoordinates(this, waypointAround.getCoords());
                }
                break;

            case CONTEXT_MENU_WAYPOINT_RESET_ORIGINAL_CACHE_COORDINATES:
                new ResetCacheCoordinatesDialog(cache, cache.getWaypoint(index), this).show();
                break;

            default:
                if (imagesList != null && imagesList.onContextItemSelected(item)) {
                    return true;
                }
                return onOptionsItemSelected(item);
        }
        return false;
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        if (null != cache) {
            menu.add(0, MENU_DEFAULT_NAVIGATION, 0, NavigationAppFactory.getDefaultNavigationApplication().getName()).setIcon(R.drawable.ic_menu_compass); // default navigation tool

            final SubMenu subMenu = menu.addSubMenu(0, 0, 0, res.getString(R.string.cache_menu_navigate)).setIcon(R.drawable.ic_menu_mapmode);
            NavigationAppFactory.addMenuItems(subMenu, cache);

            menu.add(0, MENU_CALENDAR, 0, res.getString(R.string.cache_menu_event)).setIcon(R.drawable.ic_menu_agenda); // add event to calendar
            LoggingUI.addMenuItems(menu, cache);
            menu.add(0, MENU_CACHES_AROUND, 0, res.getString(R.string.cache_menu_around)).setIcon(R.drawable.ic_menu_rotate); // caches around
            menu.add(0, MENU_BROWSER, 0, res.getString(R.string.cache_menu_browser)).setIcon(R.drawable.ic_menu_globe); // browser
            menu.add(0, MENU_SHARE, 0, res.getString(R.string.cache_menu_share)).setIcon(R.drawable.ic_menu_share); // share cache
        }
        return true;
    }

    @Override
    public boolean onPrepareOptionsMenu(Menu menu) {
        if (cache != null) {
            menu.findItem(MENU_DEFAULT_NAVIGATION).setVisible(null != cache.getCoords());
            menu.findItem(MENU_CALENDAR).setVisible(cache.canBeAddedToCalendar());
            menu.findItem(MENU_CACHES_AROUND).setVisible(null != cache.getCoords() && cache.supportsCachesAround());
            menu.findItem(MENU_BROWSER).setVisible(cache.canOpenInBrowser());
        }
        return super.onPrepareOptionsMenu(menu);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        final int menuItem = item.getItemId();

        switch (menuItem) {
            case 0:
                // no menu selected, but a new sub menu shown
                return false;
            case MENU_DEFAULT_NAVIGATION:
                startDefaultNavigation();
                return true;
            case MENU_BROWSER:
                cache.openInBrowser(this);
                return true;
            case MENU_CACHES_AROUND:
                cgeocaches.startActivityCoordinates(this, cache.getCoords());
                return true;
            case MENU_CALENDAR:
                addToCalendarWithIntent();
                return true;
            case MENU_SHARE:
                if (cache != null) {
                    cache.shareCache(this, res);
                    return true;
                }
                return false;
            default:
                if (NavigationAppFactory.onMenuItemSelected(item, this, cache)) {
                    return true;
                }
                if (LoggingUI.onMenuItemSelected(item, this, cache)) {
                    refreshOnResume = true;
                    return true;
                }
        }

        return true;
    }

    private class LoadCacheHandler extends CancellableHandler {
        @Override
        public void handleRegularMessage(final Message msg) {
            if (UPDATE_LOAD_PROGRESS_DETAIL == msg.what && msg.obj instanceof String) {
                updateStatusMsg((String) msg.obj);
            } else {
                if (search == null) {
                    showToast(res.getString(R.string.err_dwld_details_failed));

                    finish();
                    return;
                }

                if (search.getError() != null) {
                    showToast(res.getString(R.string.err_dwld_details_failed) + " " + search.getError().getErrorString(res) + ".");

                    finish();
                    return;
                }

                updateStatusMsg(res.getString(R.string.cache_dialog_loading_details_status_render));

                // Data loaded, we're ready to show it!
                notifyDataSetChanged();
            }
        }

        private void updateStatusMsg(final String msg) {
            progress.setMessage(res.getString(R.string.cache_dialog_loading_details)
                    + "\n\n"
                    + msg);
        }

        @Override
        public void handleCancel(final Object extra) {
            finish();
        }

    }

    private void notifyDataSetChanged() {
        if (search == null) {
            return;
        }

        cache = search.getFirstCacheFromResult(LoadFlags.LOAD_ALL_DB_ONLY);

        if (cache == null) {
            progress.dismiss();
            showToast(res.getString(R.string.err_detail_cache_find_some));
            finish();
            return;
        }

        // allow cache to notify CacheDetailActivity when it changes so it can be reloaded
        cache.setChangeNotificationHandler(cacheChangeNotificationHandler);

        // action bar: title and icon
        if (StringUtils.isNotBlank(cache.getName())) {
            setTitle(cache.getName() + " (" + cache.getGeocode() + ')');
        } else {
            setTitle(cache.getGeocode());
        }
        ((TextView) findViewById(R.id.actionbar_title)).setCompoundDrawablesWithIntrinsicBounds(getResources().getDrawable(cache.getType().markerId), null, null, null);

        reinitializeViewPager();

        // rendering done! remove progress popup if any there
        invalidateOptionsMenuCompatible();
        progress.dismiss();
    }

    /**
     * Loads the cache with the given geocode or guid.
     */
    private class LoadCacheThread extends Thread {

        private CancellableHandler handler = null;
        private String geocode;
        private String guid;

        public LoadCacheThread(final String geocode, final String guid, final CancellableHandler handlerIn) {
            handler = handlerIn;

            if (StringUtils.isBlank(geocode) && StringUtils.isBlank(guid)) {
                showToast(res.getString(R.string.err_detail_cache_forgot));

                finish();
                return;
            }

            this.geocode = geocode;
            this.guid = guid;
        }

        @Override
        public void run() {
            search = cgCache.searchByGeocode(geocode, StringUtils.isBlank(geocode) ? guid : null, 0, false, handler);
            handler.sendMessage(Message.obtain());
        }
    }

    /**
     * Indicates whether the specified action can be used as an intent. This
     * method queries the package manager for installed packages that can
     * respond to an intent with the specified action. If no suitable package is
     * found, this method returns false.
     *
     * @param context
     *            The application's environment.
     * @param action
     *            The Intent action to check for availability.
     * @param uri
     *            The Intent URI to check for availability.
     *
     * @return True if an Intent with the specified action can be sent and
     *         responded to, false otherwise.
     */
    private static boolean isIntentAvailable(Context context, String action, Uri uri) {
        final PackageManager packageManager = context.getPackageManager();
        final Intent intent;
        if (uri == null) {
            intent = new Intent(action);
        } else {
            intent = new Intent(action, uri);
        }
        final List<ResolveInfo> list = packageManager.queryIntentActivities(intent,
                PackageManager.MATCH_DEFAULT_ONLY);
        return !list.isEmpty();
    }

    private void addToCalendarWithIntent() {

        final boolean calendarAddOnAvailable = isIntentAvailable(this, ICalendar.INTENT, Uri.parse(ICalendar.URI_SCHEME + "://" + ICalendar.URI_HOST));

        if (calendarAddOnAvailable) {
            final Parameters params = new Parameters(
                    ICalendar.PARAM_NAME, cache.getName(),
                    ICalendar.PARAM_NOTE, StringUtils.defaultString(cache.getPersonalNote()),
                    ICalendar.PARAM_HIDDEN_DATE, String.valueOf(cache.getHiddenDate().getTime()),
                    ICalendar.PARAM_URL, StringUtils.defaultString(cache.getUrl()),
                    ICalendar.PARAM_COORDS, cache.getCoords() == null ? "" : cache.getCoords().format(GeopointFormatter.Format.LAT_LON_DECMINUTE_RAW),
                    ICalendar.PARAM_LOCATION, StringUtils.defaultString(cache.getLocation()),
                    ICalendar.PARAM_SHORT_DESC, StringUtils.defaultString(cache.getShortDescription()),
                    ICalendar.PARAM_START_TIME_MINUTES, StringUtils.defaultString(cache.guessEventTimeMinutes())
                    );

            startActivity(new Intent(ICalendar.INTENT,
                    Uri.parse(ICalendar.URI_SCHEME + "://" + ICalendar.URI_HOST + "?" + params.toString())));
        } else {
            // Inform user the calendar add-on is not installed and let them get it from Google Play
            new AlertDialog.Builder(this)
                    .setTitle(res.getString(R.string.addon_missing_title))
                    .setMessage(new StringBuilder(res.getString(R.string.helper_calendar_missing))
                            .append(' ')
                            .append(res.getString(R.string.addon_download_prompt))
                            .toString())
                    .setPositiveButton(getString(android.R.string.yes), new DialogInterface.OnClickListener() {
                        @Override
                        public void onClick(DialogInterface dialog, int id) {
                            Intent intent = new Intent(Intent.ACTION_VIEW);
                            intent.setData(Uri.parse(ICalendar.CALENDAR_ADDON_URI));
                            startActivity(intent);
                        }
                    })
                    .setNegativeButton(getString(android.R.string.no), new DialogInterface.OnClickListener() {
                        @Override
                        public void onClick(DialogInterface dialog, int id) {
                            dialog.cancel();
                        }
                    })
                    .create()
                    .show();
        }
    }

    /**
     * Tries to navigate to the {@link cgCache} of this activity.
     */
    private void startDefaultNavigation() {
        NavigationAppFactory.startDefaultNavigationApplication(1, this, cache);
    }

    /**
     * Tries to navigate to the {@link cgCache} of this activity.
     */
    private void startDefaultNavigation2() {
        NavigationAppFactory.startDefaultNavigationApplication(2, this, cache);
    }

    /**
     * Wrapper for the referenced method in the xml-layout.
     */
    public void startDefaultNavigation(@SuppressWarnings("unused") View view) {
        startDefaultNavigation();
    }

    /**
     * referenced from XML view
     */
    public void showNavigationMenu(@SuppressWarnings("unused") View view) {
        NavigationAppFactory.showNavigationMenu(this, cache, null, null, true, true);
    }

    /**
     * Listener for clicks on username
     */
    private class UserActionsClickListener implements View.OnClickListener {

        @Override
        public void onClick(View view) {
            if (view == null) {
                return;
            }
            if (!cache.supportsUserActions()) {
                return;
            }

            clickedItemText = ((TextView) view).getText().toString();
            showUserActionsDialog(clickedItemText);
        }
    }

    /**
     * Listener for clicks on owner name
     */
    private class OwnerActionsClickListener implements View.OnClickListener {

        @Override
        public void onClick(View view) {
            if (view == null) {
                return;
            }
            if (!cache.supportsUserActions()) {
                return;
            }

            // Use real owner name vice the one owner chose to display
            if (StringUtils.isNotBlank(cache.getOwnerUserId())) {
                clickedItemText = cache.getOwnerUserId();
            } else {
                clickedItemText = ((TextView) view).getText().toString();
            }
            showUserActionsDialog(clickedItemText);
        }
    }

    /**
     * Opens a dialog to do actions on an username
     */
    private void showUserActionsDialog(final CharSequence name) {
        final CharSequence[] items = { res.getString(R.string.user_menu_view_hidden),
                res.getString(R.string.user_menu_view_found),
                res.getString(R.string.user_menu_open_browser)
        };

        AlertDialog.Builder builder = new AlertDialog.Builder(this);
        builder.setTitle(res.getString(R.string.user_menu_title) + " " + name);
        builder.setItems(items, new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int item) {
                switch (item) {
                    case 0:
                        cgeocaches.startActivityOwner(CacheDetailActivity.this, name.toString());
                        return;
                    case 1:
                        cgeocaches.startActivityUserName(CacheDetailActivity.this, name.toString());
                        return;
                    case 2:
                        startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse("http://www.geocaching.com/profile/?u=" + Network.encode(name.toString()))));
                        return;
                    default:
                        break;
                }
            }
        });
        AlertDialog alert = builder.create();
        alert.show();
    }

    private void loadCacheImages() {
        if (imagesList != null) {
            return;
        }
        PageViewCreator creator = getViewCreator(Page.IMAGES);
        if (creator == null) {
            return;
        }
        View imageView = creator.getView();
        if (imageView == null) {
            return;
        }
        imagesList = new ImagesList(this, cache.getGeocode());
        imagesList.loadImages(imageView, cache.getImages(), ImageType.AllImages, false);
    }

    public static void startActivity(final Context context, final String geocode) {
        final Intent detailIntent = new Intent(context, CacheDetailActivity.class);
        detailIntent.putExtra("geocode", geocode);
        context.startActivity(detailIntent);
    }

    /**
     * Enum of all possible pages with methods to get the view and a title.
     */
    public enum Page {
        DETAILS(R.string.detail),
        DESCRIPTION(R.string.cache_description),
        LOGS(R.string.cache_logs),
        LOGSFRIENDS(R.string.cache_logsfriends),
        WAYPOINTS(R.string.cache_waypoints),
        INVENTORY(R.string.cache_inventory),
        IMAGES(R.string.cache_images);

        final private int titleStringId;

        Page(final int titleStringId) {
            this.titleStringId = titleStringId;
        }
    }

    private class AttributeViewBuilder {
        private ViewGroup attributeIconsLayout; // layout for attribute icons
        private ViewGroup attributeDescriptionsLayout; // layout for attribute descriptions
        private boolean attributesShowAsIcons = true; // default: show icons
        /**
         * If the cache is from a non GC source, it might be without icons. Disable switching in those cases.
         */
        private boolean noAttributeIconsFound = false;
        private int attributeBoxMaxWidth;

        public void fillView(final LinearLayout attributeBox) {
            // first ensure that the view is empty
            attributeBox.removeAllViews();

            // maximum width for attribute icons is screen width - paddings of parents
            attributeBoxMaxWidth = Compatibility.getDisplayWidth();
            ViewParent child = attributeBox;
            do {
                if (child instanceof View) {
                    attributeBoxMaxWidth -= ((View) child).getPaddingLeft() + ((View) child).getPaddingRight();
                }
                child = child.getParent();
            } while (child != null);

            // delete views holding description / icons
            attributeDescriptionsLayout = null;
            attributeIconsLayout = null;

            attributeBox.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    // toggle between attribute icons and descriptions
                    toggleAttributeDisplay(attributeBox, attributeBoxMaxWidth);
                }
            });

            // icons or text?
            //
            // also show icons when noAttributeImagesFound == true. Explanation:
            //  1. no icons could be found in the first invocation of this method
            //  2. user refreshes cache from web
            //  3. now this method is called again
            //  4. attributeShowAsIcons is false but noAttributeImagesFound is true
            //     => try to show them now
            if (attributesShowAsIcons || noAttributeIconsFound) {
                showAttributeIcons(attributeBox, attributeBoxMaxWidth);
            } else {
                showAttributeDescriptions(attributeBox);
            }
        }

        /**
         * lazy-creates the layout holding the icons of the caches attributes
         * and makes it visible
         */
        private void showAttributeIcons(LinearLayout attribBox, int parentWidth) {
            if (attributeIconsLayout == null) {
                attributeIconsLayout = createAttributeIconsLayout(parentWidth);
                // no matching icons found? show text
                if (noAttributeIconsFound) {
                    showAttributeDescriptions(attribBox);
                    return;
                }
            }
            attribBox.removeAllViews();
            attribBox.addView(attributeIconsLayout);
            attributesShowAsIcons = true;
        }

        /**
         * lazy-creates the layout holding the descriptions of the caches attributes
         * and makes it visible
         */
        private void showAttributeDescriptions(LinearLayout attribBox) {
            if (attributeDescriptionsLayout == null) {
                attributeDescriptionsLayout = createAttributeDescriptionsLayout();
            }
            attribBox.removeAllViews();
            attribBox.addView(attributeDescriptionsLayout);
            attributesShowAsIcons = false;
        }

        /**
         * toggle attribute descriptions and icons
         */
        private void toggleAttributeDisplay(LinearLayout attribBox, int parentWidth) {
            // Don't toggle when there are no icons to show.
            if (noAttributeIconsFound) {
                return;
            }

            // toggle
            if (attributesShowAsIcons) {
                showAttributeDescriptions(attribBox);
            } else {
                showAttributeIcons(attribBox, parentWidth);
            }
        }

        private ViewGroup createAttributeIconsLayout(int parentWidth) {
            final LinearLayout rows = new LinearLayout(CacheDetailActivity.this);
            rows.setLayoutParams(new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT));
            rows.setOrientation(LinearLayout.VERTICAL);

            LinearLayout attributeRow = newAttributeIconsRow();
            rows.addView(attributeRow);

            noAttributeIconsFound = true;

            for (String attributeName : cache.getAttributes()) {
                // check if another attribute icon fits in this row
                attributeRow.measure(0, 0);
                int rowWidth = attributeRow.getMeasuredWidth();
                FrameLayout fl = (FrameLayout) getLayoutInflater().inflate(R.layout.attribute_image, null);
                ImageView iv = (ImageView) fl.getChildAt(0);
                if ((parentWidth - rowWidth) < iv.getLayoutParams().width) {
                    // make a new row
                    attributeRow = newAttributeIconsRow();
                    rows.addView(attributeRow);
                }

                final boolean strikethru = !CacheAttribute.isEnabled(attributeName);
                final CacheAttribute attrib = CacheAttribute.getByGcRawName(CacheAttribute.trimAttributeName(attributeName));
                if (attrib != CacheAttribute.UNKNOWN) {
                    noAttributeIconsFound = false;
                    Drawable d = res.getDrawable(attrib.drawableId);
                    iv.setImageDrawable(d);
                    // strike through?
                    if (strikethru) {
                        // generate strikethru image with same properties as attribute image
                        ImageView strikethruImage = new ImageView(CacheDetailActivity.this);
                        strikethruImage.setLayoutParams(iv.getLayoutParams());
                        d = res.getDrawable(R.drawable.attribute__strikethru);
                        strikethruImage.setImageDrawable(d);
                        fl.addView(strikethruImage);
                    }
                } else {
                    Drawable d = res.getDrawable(R.drawable.attribute_icon_not_found);
                    iv.setImageDrawable(d);
                }

                attributeRow.addView(fl);
            }

            return rows;
        }

        private LinearLayout newAttributeIconsRow() {
            LinearLayout rowLayout = new LinearLayout(CacheDetailActivity.this);
            rowLayout.setLayoutParams(new LayoutParams(LayoutParams.MATCH_PARENT,
                    LayoutParams.WRAP_CONTENT));
            rowLayout.setOrientation(LinearLayout.HORIZONTAL);
            return rowLayout;
        }

        private ViewGroup createAttributeDescriptionsLayout() {
            final LinearLayout descriptions = (LinearLayout) getLayoutInflater().inflate(
                    R.layout.attribute_descriptions, null);
            final TextView attribView = (TextView) descriptions.getChildAt(0);

            final StringBuilder buffer = new StringBuilder();
            for (String attributeName : cache.getAttributes()) {
                final boolean enabled = CacheAttribute.isEnabled(attributeName);
                // search for a translation of the attribute
                CacheAttribute attrib = CacheAttribute.getByGcRawName(CacheAttribute.trimAttributeName(attributeName));
                if (attrib != CacheAttribute.UNKNOWN) {
                    attributeName = attrib.getL10n(enabled);
                }
                if (buffer.length() > 0) {
                    buffer.append('\n');
                }
                buffer.append(attributeName);
            }

            attribView.setText(buffer);

            return descriptions;
        }
    }

    /**
     * Creator for details-view.
     */
    private class DetailsViewCreator extends AbstractCachingPageViewCreator<ScrollView> {
        /**
         * Reference to the details list, so that the helper-method can access it without an additional argument
         */
        private LinearLayout detailsList;

        // TODO Do we need this thread-references?
        private StoreCacheThread storeThread;
        private RefreshCacheThread refreshThread;
        private Thread watchlistThread;

        @Override
        public ScrollView getDispatchedView() {
            if (cache == null) {
                // something is really wrong
                return null;
            }

            view = (ScrollView) getLayoutInflater().inflate(R.layout.cacheview_details, null);

            // Start loading preview map
            if (Settings.isStoreOfflineMaps()) {
                new PreviewMapTask().execute((Void) null);
            }

            detailsList = (LinearLayout) view.findViewById(R.id.details_list);
            final CacheDetailsCreator details = new CacheDetailsCreator(CacheDetailActivity.this, detailsList);

            // cache name (full name)
            Spannable span = (new Spannable.Factory()).newSpannable(Html.fromHtml(cache.getName()).toString());
            if (cache.isDisabled() || cache.isArchived()) { // strike
                span.setSpan(new StrikethroughSpan(), 0, span.toString().length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
            }
            if (cache.isArchived()) {
                span.setSpan(new ForegroundColorSpan(res.getColor(R.color.archived_cache_color)), 0, span.toString().length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
            }

            details.add(R.string.cache_name, span);
            details.add(R.string.cache_type, cache.getType().getL10n());
            details.addSize(cache);
            details.add(R.string.cache_geocode, cache.getGeocode());
            details.addCacheState(cache);

            details.addDistance(cache, cacheDistanceView);
            cacheDistanceView = details.getValueView();

            details.addDifficulty(cache);
            details.addTerrain(cache);
            details.addRating(cache);

            // favorite count
            if (cache.getFavoritePoints() > 0) {
                details.add(R.string.cache_favourite, cache.getFavoritePoints() + "");
            }

            // own rating
            if (cache.getMyVote() > 0) {
                details.addStars(R.string.cache_own_rating, cache.getMyVote());
            }

            // cache author
            if (StringUtils.isNotBlank(cache.getOwnerDisplayName()) || StringUtils.isNotBlank(cache.getOwnerUserId())) {
                TextView ownerView = details.add(R.string.cache_owner, "");
                if (StringUtils.isNotBlank(cache.getOwnerDisplayName())) {
                    ownerView.setText(cache.getOwnerDisplayName(), TextView.BufferType.SPANNABLE);
                } else { // OwnerReal guaranteed to be not blank based on above
                    ownerView.setText(cache.getOwnerUserId(), TextView.BufferType.SPANNABLE);
                }
                ownerView.setOnClickListener(new OwnerActionsClickListener());
            }

            // cache hidden
            if (cache.getHiddenDate() != null) {
                long time = cache.getHiddenDate().getTime();
                if (time > 0) {
                    String dateString = Formatter.formatFullDate(time);
                    if (cache.isEventCache()) {
                        dateString = DateUtils.formatDateTime(cgeoapplication.getInstance().getBaseContext(), time, DateUtils.FORMAT_SHOW_WEEKDAY) + ", " + dateString;
                    }
                    details.add(cache.isEventCache() ? R.string.cache_event : R.string.cache_hidden, dateString);
                }
            }

            // cache location
            if (StringUtils.isNotBlank(cache.getLocation())) {
                details.add(R.string.cache_location, cache.getLocation());
            }

            // cache coordinates
            if (cache.getCoords() != null) {
                TextView valueView = details.add(R.string.cache_coordinates, cache.getCoords().toString());
                valueView.setOnClickListener(new View.OnClickListener() {
                    private int position = 0;
                    private GeopointFormatter.Format[] availableFormats = new GeopointFormatter.Format[] {
                            GeopointFormatter.Format.LAT_LON_DECMINUTE,
                            GeopointFormatter.Format.LAT_LON_DECSECOND,
                            GeopointFormatter.Format.LAT_LON_DECDEGREE
                    };

                    // rotate coordinate formats on click
                    @Override
                    public void onClick(View view) {
                        position = (position + 1) % availableFormats.length;

                        final TextView valueView = (TextView) view.findViewById(R.id.value);
                        valueView.setText(cache.getCoords().format(availableFormats[position]));
                    }
                });
                registerForContextMenu(valueView);
            }

            // cache attributes
            if (cache.getAttributes().isNotEmpty()) {
                new AttributeViewBuilder().fillView((LinearLayout) view.findViewById(R.id.attributes_innerbox));
                view.findViewById(R.id.attributes_box).setVisibility(View.VISIBLE);
            }

            updateOfflineBox();

            // watchlist
            Button buttonWatchlistAdd = (Button) view.findViewById(R.id.add_to_watchlist);
            Button buttonWatchlistRemove = (Button) view.findViewById(R.id.remove_from_watchlist);
            buttonWatchlistAdd.setOnClickListener(new AddToWatchlistClickListener());
            buttonWatchlistRemove.setOnClickListener(new RemoveFromWatchlistClickListener());
            updateWatchlistBox();

            // favorite points
            Button buttonFavPointAdd = (Button) view.findViewById(R.id.add_to_favpoint);
            Button buttonFavPointRemove = (Button) view.findViewById(R.id.remove_from_favpoint);
            buttonFavPointAdd.setOnClickListener(new FavoriteAddClickListener());
            buttonFavPointRemove.setOnClickListener(new FavoriteRemoveClickListener());
            updateFavPointBox();

            // data license
            IConnector connector = ConnectorFactory.getConnector(cache);
            if (connector != null) {
                String license = connector.getLicenseText(cache);
                if (StringUtils.isNotBlank(license)) {
                    view.findViewById(R.id.license_box).setVisibility(View.VISIBLE);
                    TextView licenseView = ((TextView) view.findViewById(R.id.license));
                    licenseView.setText(Html.fromHtml(license), BufferType.SPANNABLE);
                    licenseView.setClickable(true);
                    licenseView.setMovementMethod(LinkMovementMethod.getInstance());
                } else {
                    view.findViewById(R.id.license_box).setVisibility(View.GONE);
                }
            }

            return view;
        }

        private class StoreCacheHandler extends CancellableHandler {
            @Override
            public void handleRegularMessage(Message msg) {
                if (UPDATE_LOAD_PROGRESS_DETAIL == msg.what && msg.obj instanceof String) {
                    updateStatusMsg((String) msg.obj);
                } else {
                    storeThread = null;
                    CacheDetailActivity.this.notifyDataSetChanged(); // reload cache details
                }
            }

            private void updateStatusMsg(final String msg) {
                progress.setMessage(res.getString(R.string.cache_dialog_offline_save_message)
                        + "\n\n"
                        + msg);
            }
        }

        private class RefreshCacheHandler extends CancellableHandler {
            @Override
            public void handleRegularMessage(Message msg) {
                if (UPDATE_LOAD_PROGRESS_DETAIL == msg.what && msg.obj instanceof String) {
                    updateStatusMsg((String) msg.obj);
                } else {
                    refreshThread = null;
                    CacheDetailActivity.this.notifyDataSetChanged(); // reload cache details
                }
            }

            private void updateStatusMsg(final String msg) {
                progress.setMessage(res.getString(R.string.cache_dialog_refresh_message)
                        + "\n\n"
                        + msg);
            }
        }

        private class DropCacheHandler extends Handler {
            @Override
            public void handleMessage(Message msg) {
                CacheDetailActivity.this.notifyDataSetChanged();
            }
        }

        private class StoreCacheClickListener implements View.OnClickListener {
            @Override
            public void onClick(View arg0) {
                if (progress.isShowing()) {
                    showToast(res.getString(R.string.err_detail_still_working));
                    return;
                }

                final StoreCacheHandler storeCacheHandler = new StoreCacheHandler();

                progress.show(CacheDetailActivity.this, res.getString(R.string.cache_dialog_offline_save_title), res.getString(R.string.cache_dialog_offline_save_message), true, storeCacheHandler.cancelMessage());

                if (storeThread != null) {
                    storeThread.interrupt();
                }

                storeThread = new StoreCacheThread(storeCacheHandler);
                storeThread.start();
            }
        }

        private class RefreshCacheClickListener implements View.OnClickListener {
            @Override
            public void onClick(View arg0) {
                if (progress.isShowing()) {
                    showToast(res.getString(R.string.err_detail_still_working));
                    return;
                }

                final RefreshCacheHandler refreshCacheHandler = new RefreshCacheHandler();

                progress.show(CacheDetailActivity.this, res.getString(R.string.cache_dialog_refresh_title), res.getString(R.string.cache_dialog_refresh_message), true, refreshCacheHandler.cancelMessage());

                if (refreshThread != null) {
                    refreshThread.interrupt();
                }

                refreshThread = new RefreshCacheThread(refreshCacheHandler);
                refreshThread.start();
            }
        }

        private class StoreCacheThread extends Thread {
            final private CancellableHandler handler;

            public StoreCacheThread(final CancellableHandler handler) {
                this.handler = handler;
            }

            @Override
            public void run() {
                cache.store(handler);
            }
        }

        private class RefreshCacheThread extends Thread {
            final private CancellableHandler handler;

            public RefreshCacheThread(final CancellableHandler handler) {
                this.handler = handler;
            }

            @Override
            public void run() {
                cache.refresh(cache.getListId(), handler);

                handler.sendEmptyMessage(0);
            }
        }

        private class DropCacheClickListener implements View.OnClickListener {
            @Override
            public void onClick(View arg0) {
                if (progress.isShowing()) {
                    showToast(res.getString(R.string.err_detail_still_working));
                    return;
                }

                final DropCacheHandler dropCacheHandler = new DropCacheHandler();

                progress.show(CacheDetailActivity.this, res.getString(R.string.cache_dialog_offline_drop_title), res.getString(R.string.cache_dialog_offline_drop_message), true, null);
                new DropCacheThread(dropCacheHandler).start();
            }
        }

        private class DropCacheThread extends Thread {

            private Handler handler = null;

            public DropCacheThread(Handler handlerIn) {
                handler = handlerIn;
            }

            @Override
            public void run() {
                cache.drop(handler);
            }
        }

        /**
         * Abstract Listener for add / remove buttons for watchlist
         */
        private abstract class AbstractWatchlistClickListener implements View.OnClickListener {
            public void doExecute(int titleId, int messageId, Thread thread) {
                if (progress.isShowing()) {
                    showToast(res.getString(R.string.err_watchlist_still_managing));
                    return;
                }
                progress.show(CacheDetailActivity.this, res.getString(titleId), res.getString(messageId), true, null);

                if (watchlistThread != null) {
                    watchlistThread.interrupt();
                }

                watchlistThread = thread;
                watchlistThread.start();
            }
        }

        /**
         * Listener for "add to watchlist" button
         */
        private class AddToWatchlistClickListener extends AbstractWatchlistClickListener {
            @Override
            public void onClick(View arg0) {
                doExecute(R.string.cache_dialog_watchlist_add_title,
                        R.string.cache_dialog_watchlist_add_message,
                        new WatchlistAddThread(new WatchlistHandler()));
            }
        }

        /**
         * Listener for "remove from watchlist" button
         */
        private class RemoveFromWatchlistClickListener extends AbstractWatchlistClickListener {
            @Override
            public void onClick(View arg0) {
                doExecute(R.string.cache_dialog_watchlist_remove_title,
                        R.string.cache_dialog_watchlist_remove_message,
                        new WatchlistRemoveThread(new WatchlistHandler()));
            }
        }

        /** Thread to add this cache to the watchlist of the user */
        private class WatchlistAddThread extends Thread {
            private final Handler handler;

            public WatchlistAddThread(Handler handler) {
                this.handler = handler;
            }

            @Override
            public void run() {
                handler.sendEmptyMessage(GCConnector.addToWatchlist(cache) ? 1 : -1);
            }
        }

        /** Thread to remove this cache from the watchlist of the user */
        private class WatchlistRemoveThread extends Thread {
            private final Handler handler;

            public WatchlistRemoveThread(Handler handler) {
                this.handler = handler;
            }

            @Override
            public void run() {
                handler.sendEmptyMessage(GCConnector.removeFromWatchlist(cache) ? 1 : -1);
            }
        }

        /** Thread to add this cache to the favourite list of the user */
        private class FavoriteAddThread extends Thread {
            private final Handler handler;

            public FavoriteAddThread(Handler handler) {
                this.handler = handler;
            }

            @Override
            public void run() {
                handler.sendEmptyMessage(GCConnector.addToFavorites(cache) ? 1 : -1);
            }
        }

        /** Thread to remove this cache to the favourite list of the user */
        private class FavoriteRemoveThread extends Thread {
            private final Handler handler;

            public FavoriteRemoveThread(Handler handler) {
                this.handler = handler;
            }

            @Override
            public void run() {
                handler.sendEmptyMessage(GCConnector.removeFromFavorites(cache) ? 1 : -1);
            }
        }

        private class FavoriteUpdateHandler extends Handler {
            @Override
            public void handleMessage(Message msg) {
                progress.dismiss();
                if (msg.what == -1) {
                    showToast(res.getString(R.string.err_favorite_failed));
                } else {
                    CacheDetailActivity.this.notifyDataSetChanged(); // reload cache details
                }
            }
        }

        /**
         * Listener for "add to favourites" button
         */
        private class FavoriteAddClickListener extends AbstractWatchlistClickListener {
            @Override
            public void onClick(View arg0) {
                doExecute(R.string.cache_dialog_favourite_add_title,
                        R.string.cache_dialog_favourite_add_message,
                        new FavoriteAddThread(new FavoriteUpdateHandler()));
            }
        }

        /**
         * Listener for "remove from favourites" button
         */
        private class FavoriteRemoveClickListener extends AbstractWatchlistClickListener {
            @Override
            public void onClick(View arg0) {
                doExecute(R.string.cache_dialog_favourite_remove_title,
                        R.string.cache_dialog_favourite_remove_message,
                        new FavoriteRemoveThread(new FavoriteUpdateHandler()));
            }
        }

        /**
         * shows/hides buttons, sets text in watchlist box
         */
        private void updateWatchlistBox() {
            LinearLayout layout = (LinearLayout) view.findViewById(R.id.watchlist_box);
            boolean supportsWatchList = cache.supportsWatchList();
            layout.setVisibility(supportsWatchList ? View.VISIBLE : View.GONE);
            if (!supportsWatchList) {
                return;
            }
            Button buttonAdd = (Button) view.findViewById(R.id.add_to_watchlist);
            Button buttonRemove = (Button) view.findViewById(R.id.remove_from_watchlist);
            TextView text = (TextView) view.findViewById(R.id.watchlist_text);

            if (cache.isOnWatchlist() || cache.isOwn()) {
                buttonAdd.setVisibility(View.GONE);
                buttonRemove.setVisibility(View.VISIBLE);
                text.setText(R.string.cache_watchlist_on);
            } else {
                buttonAdd.setVisibility(View.VISIBLE);
                buttonRemove.setVisibility(View.GONE);
                text.setText(R.string.cache_watchlist_not_on);
            }

            // the owner of a cache has it always on his watchlist. Adding causes an error
            if (cache.isOwn()) {
                buttonAdd.setEnabled(false);
                buttonAdd.setVisibility(View.GONE);
                buttonRemove.setEnabled(false);
                buttonRemove.setVisibility(View.GONE);
            }

        }

        /**
         * shows/hides buttons, sets text in watchlist box
         */
        private void updateFavPointBox() {
            LinearLayout layout = (LinearLayout) view.findViewById(R.id.favpoint_box);
            boolean supportsFavoritePoints = cache.supportsFavoritePoints();
            layout.setVisibility(supportsFavoritePoints ? View.VISIBLE : View.GONE);
            if (!supportsFavoritePoints || cache.isOwn() || !Settings.isPremiumMember()) {
                return;
            }
            Button buttonAdd = (Button) view.findViewById(R.id.add_to_favpoint);
            Button buttonRemove = (Button) view.findViewById(R.id.remove_from_favpoint);
            TextView text = (TextView) view.findViewById(R.id.favpoint_text);

            if (cache.isFavorite()) {
                buttonAdd.setVisibility(View.GONE);
                buttonRemove.setVisibility(View.VISIBLE);
                text.setText(R.string.cache_favpoint_on);
            } else {
                buttonAdd.setVisibility(View.VISIBLE);
                buttonRemove.setVisibility(View.GONE);
                text.setText(R.string.cache_favpoint_not_on);
            }

            // Add/remove to Favorites is only possible if the cache has been found
            if (!cache.isFound()) {
                buttonAdd.setEnabled(false);
                buttonAdd.setVisibility(View.GONE);
                buttonRemove.setEnabled(false);
                buttonRemove.setVisibility(View.GONE);
            }
        }

        /**
         * Handler, called when watchlist add or remove is done
         */
        private class WatchlistHandler extends Handler {
            @Override
            public void handleMessage(Message msg) {
                watchlistThread = null;
                progress.dismiss();
                if (msg.what == -1) {
                    showToast(res.getString(R.string.err_watchlist_failed));
                } else {
                    CacheDetailActivity.this.notifyDataSetChanged(); // reload cache details
                }
            }
        }

        private void updateOfflineBox() {
            // offline use
            final TextView offlineText = (TextView) view.findViewById(R.id.offline_text);
            final Button offlineRefresh = (Button) view.findViewById(R.id.offline_refresh);
            final Button offlineStore = (Button) view.findViewById(R.id.offline_store);

            if (cache.isOffline()) {
                long diff = (System.currentTimeMillis() / (60 * 1000)) - (cache.getDetailedUpdate() / (60 * 1000)); // minutes

                String ago;
                if (diff < 15) {
                    ago = res.getString(R.string.cache_offline_time_mins_few);
                } else if (diff < 50) {
                    ago = res.getString(R.string.cache_offline_time_about) + " " + diff + " " + res.getString(R.string.cache_offline_time_mins);
                } else if (diff < 90) {
                    ago = res.getString(R.string.cache_offline_time_about) + " " + res.getString(R.string.cache_offline_time_hour);
                } else if (diff < (48 * 60)) {
                    ago = res.getString(R.string.cache_offline_time_about) + " " + (diff / 60) + " " + res.getString(R.string.cache_offline_time_hours);
                } else {
                    ago = res.getString(R.string.cache_offline_time_about) + " " + (diff / (24 * 60)) + " " + res.getString(R.string.cache_offline_time_days);
                }

                offlineText.setText(res.getString(R.string.cache_offline_stored) + "\n" + ago);
                offlineRefresh.setOnClickListener(new RefreshCacheClickListener());

                offlineStore.setText(res.getString(R.string.cache_offline_drop));
                offlineStore.setClickable(true);
                offlineStore.setOnClickListener(new DropCacheClickListener());
            } else {
                offlineText.setText(res.getString(R.string.cache_offline_not_ready));
                offlineRefresh.setOnClickListener(new RefreshCacheClickListener());

                offlineStore.setText(res.getString(R.string.cache_offline_store));
                offlineStore.setClickable(true);
                offlineStore.setOnClickListener(new StoreCacheClickListener());
            }
            offlineRefresh.setVisibility(cache.supportsRefresh() ? View.VISIBLE : View.GONE);
            offlineRefresh.setClickable(true);
        }

        private class PreviewMapTask extends AsyncTask<Void, Void, BitmapDrawable> {
            @Override
            protected BitmapDrawable doInBackground(Void... parameters) {
                try {
                    // persistent preview from storage
                    Bitmap image = decode(cache);

                    if (image == null) {
                        StaticMapsProvider.storeCachePreviewMap(cache);
                        image = decode(cache);
                        if (image == null) {
                            return null;
                        }
                    }

                    return ImageHelper.scaleBitmapToFitDisplay(image);
                } catch (Exception e) {
                    Log.w("CacheDetailActivity.PreviewMapTask", e);
                    return null;
                }
            }

            private Bitmap decode(final cgCache cache) {
                return StaticMapsProvider.getPreviewMap(cache.getGeocode());
            }

            @Override
            protected void onPostExecute(BitmapDrawable image) {
                if (image == null) {
                    return;
                }

                try {
                    final Bitmap bitmap = image.getBitmap();
                    if (bitmap == null || bitmap.getWidth() <= 10) {
                        return;
                    }

                    ((ImageView) view.findViewById(R.id.map_preview)).setImageDrawable(image);
                    view.findViewById(R.id.map_preview_box).setVisibility(View.VISIBLE);
                } catch (Exception e) {
                    Log.e("CacheDetailActivity.PreviewMapTask", e);
                }
            }
        }

    }

    private class DescriptionViewCreator extends AbstractCachingPageViewCreator<ScrollView> {

        @Override
        public ScrollView getDispatchedView() {
            if (cache == null) {
                // something is really wrong
                return null;
            }

            view = (ScrollView) getLayoutInflater().inflate(R.layout.cacheview_description, null);

            // cache short description
            if (StringUtils.isNotBlank(cache.getShortDescription())) {
                new LoadDescriptionTask().execute(cache.getShortDescription(), view.findViewById(R.id.shortdesc), null);
                registerForContextMenu(view.findViewById(R.id.shortdesc));
            }

            // long description
            if (StringUtils.isNotBlank(cache.getDescription())) {
                if (Settings.isAutoLoadDescription()) {
                    loadLongDescription();
                } else {
                    Button showDesc = (Button) view.findViewById(R.id.show_description);
                    showDesc.setVisibility(View.VISIBLE);
                    showDesc.setOnClickListener(new View.OnClickListener() {
                        @Override
                        public void onClick(View arg0) {
                            loadLongDescription();
                        }
                    });
                }
            }

            // cache personal note
            final TextView personalNoteView = (TextView) view.findViewById(R.id.personalnote);
            setPersonalNote(personalNoteView);
            personalNoteView.setMovementMethod(LinkMovementMethod.getInstance());
            registerForContextMenu(personalNoteView);
            final Button personalNoteEdit = (Button) view.findViewById(R.id.edit_personalnote);
            if (cache.isOffline()) {
                personalNoteEdit.setVisibility(View.VISIBLE);
                personalNoteEdit.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(View v) {
                        EditorDialog editor = new EditorDialog(CacheDetailActivity.this, personalNoteView.getText());
                        editor.setOnEditorUpdate(new EditorDialog.EditorUpdate() {
                            @Override
                            public void update(CharSequence editorText) {
                                cache.setPersonalNote(editorText.toString());
                                setPersonalNote(personalNoteView);
                                cgData.saveCache(cache, EnumSet.of(SaveFlag.SAVE_DB));
                            }
                        });
                        editor.show();
                    }
                });
            } else {
                personalNoteEdit.setVisibility(View.INVISIBLE);
            }

            // cache hint and spoiler images
            final View hintBoxView = view.findViewById(R.id.hint_box);
            if (StringUtils.isNotBlank(cache.getHint()) || CollectionUtils.isNotEmpty(cache.getSpoilers())) {
                hintBoxView.setVisibility(View.VISIBLE);
            } else {
                hintBoxView.setVisibility(View.GONE);
            }

            final TextView hintView = ((TextView) view.findViewById(R.id.hint));
            if (StringUtils.isNotBlank(cache.getHint())) {
                if (BaseUtils.containsHtml(cache.getHint())) {
                    hintView.setText(Html.fromHtml(cache.getHint(), new HtmlImage(cache.getGeocode(), false, cache.getListId(), false), null), TextView.BufferType.SPANNABLE);
                    hintView.setText(CryptUtils.rot13((Spannable) hintView.getText()));
                }
                else {
                    hintView.setText(CryptUtils.rot13(cache.getHint()));
                }
                hintView.setVisibility(View.VISIBLE);
                hintView.setClickable(true);
                hintView.setOnClickListener(new DecryptTextClickListener());
                registerForContextMenu(hintView);
            } else {
                hintView.setVisibility(View.GONE);
                hintView.setClickable(false);
                hintView.setOnClickListener(null);
            }

            final TextView spoilerlinkView = ((TextView) view.findViewById(R.id.hint_spoilerlink));
            if (CollectionUtils.isNotEmpty(cache.getSpoilers())) {
                spoilerlinkView.setVisibility(View.VISIBLE);
                spoilerlinkView.setClickable(true);
                spoilerlinkView.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(View arg0) {
                        if (cache == null || CollectionUtils.isEmpty(cache.getSpoilers())) {
                            showToast(res.getString(R.string.err_detail_no_spoiler));
                            return;
                        }

                        ImagesActivity.startActivitySpoilerImages(CacheDetailActivity.this, cache.getGeocode(), cache.getSpoilers());
                    }
                });
            } else {
                spoilerlinkView.setVisibility(View.GONE);
                spoilerlinkView.setClickable(true);
                spoilerlinkView.setOnClickListener(null);
            }

            return view;
        }

        private void setPersonalNote(final TextView personalNoteView) {
            final String personalNote = cache.getPersonalNote();
            personalNoteView.setText(personalNote, TextView.BufferType.SPANNABLE);
            if (StringUtils.isNotBlank(personalNote)) {
                personalNoteView.setVisibility(View.VISIBLE);
            }
            else {
                personalNoteView.setVisibility(View.GONE);
            }
        }

        private void loadLongDescription() {
            Button showDesc = (Button) view.findViewById(R.id.show_description);
            showDesc.setVisibility(View.GONE);
            showDesc.setOnClickListener(null);
            view.findViewById(R.id.loading).setVisibility(View.VISIBLE);

            new LoadDescriptionTask().execute(cache.getDescription(), view.findViewById(R.id.longdesc), view.findViewById(R.id.loading));
            registerForContextMenu(view.findViewById(R.id.longdesc));
        }

    }

    /**
     * Loads the description in background. <br />
     * <br />
     * Params:
     * <ol>
     * <li>description string (String)</li>
     * <li>target description view (TextView)</li>
     * <li>loading indicator view (View, may be null)</li>
     * </ol>
     */
    private class LoadDescriptionTask extends AsyncTask<Object, Void, Void> {
        private View loadingIndicatorView;
        private TextView descriptionView;
        private String descriptionString;
        private Spanned description;

        private class HtmlImageCounter implements Html.ImageGetter {

            private int imageCount = 0;

            @Override
            public Drawable getDrawable(String url) {
                imageCount++;
                return null;
            }

            public int getImageCount() {
                return imageCount;
            }
        }

        @Override
        protected Void doInBackground(Object... params) {
            try {
                descriptionString = ((String) params[0]);
                descriptionView = (TextView) params[1];
                loadingIndicatorView = (View) params[2];

                // Fast preview: parse only HTML without loading any images
                HtmlImageCounter imageCounter = new HtmlImageCounter();
                final UnknownTagsHandler unknownTagsHandler = new UnknownTagsHandler();
                description = Html.fromHtml(descriptionString, imageCounter, unknownTagsHandler);
                publishProgress();
                if (imageCounter.getImageCount() > 0) {
                    // Complete view: parse again with loading images - if necessary ! If there are any images causing problems the user can see at least the preview
                    description = Html.fromHtml(descriptionString, new HtmlImage(cache.getGeocode(), true, cache.getListId(), false), unknownTagsHandler);
                    publishProgress();
                }

                // If description has an HTML construct which may be problematic to render, add a note at the end of the long description.
                // Technically, it may not be a table, but a pre, which has the same problems as a table, so the message is ok even though
                // sometimes technically incorrect.
                if (unknownTagsHandler.isProblematicDetected() && descriptionView != null) {
                    final int startPos = description.length();
                    ((Editable) description).append("\n\n").append(res.getString(R.string.cache_description_table_note));
                    ((Editable) description).setSpan(new StyleSpan(Typeface.ITALIC), startPos, description.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
                    publishProgress();
                }
            } catch (Exception e) {
                Log.e("LoadDescriptionTask: ", e);
            }
            return null;
        }

        /*
         * (non-Javadoc)
         *
         * @see android.os.AsyncTask#onProgressUpdate(Progress[])
         */
        @Override
        protected void onProgressUpdate(Void... values) {
            if (description != null) {
                if (StringUtils.isNotBlank(descriptionString)) {
                    descriptionView.setText(description, TextView.BufferType.SPANNABLE);
                    descriptionView.setMovementMethod(LinkMovementMethod.getInstance());
                    fixBlackTextColor(descriptionView, descriptionString);
                }

                descriptionView.setVisibility(View.VISIBLE);
            } else {
                showToast(res.getString(R.string.err_load_descr_failed));
            }

            if (null != loadingIndicatorView) {
                loadingIndicatorView.setVisibility(View.GONE);
            }
        }

        /**
         * handle caches with black font color
         *
         * @param view
         * @param text
         */
        private void fixBlackTextColor(final TextView view, final String text) {
            if (Settings.isLightSkin()) {
                return;
            }
            int backcolor = color.black;
            if (-1 != StringUtils.indexOfAny(text, new String[] { "color=\"black", "color=\"#000080\"" })) {
                backcolor = color.darker_gray;
            }
            else {
                MatcherWrapper matcher = new MatcherWrapper(DARK_COLOR_PATTERN, text);
                if (matcher.find()) {
                    backcolor = color.darker_gray;
                }
            }
            view.setBackgroundResource(backcolor);
        }
    }

    private class LogsViewCreator extends AbstractCachingPageViewCreator<ListView> {
        private final boolean allLogs;

        LogsViewCreator(boolean allLogs) {
            this.allLogs = allLogs;
        }

        @Override
        public ListView getDispatchedView() {
            if (cache == null) {
                // something is really wrong
                return null;
            }

            view = (ListView) getLayoutInflater().inflate(R.layout.cacheview_logs, null);

            // log count
            final Map<LogType, Integer> logCounts = cache.getLogCounts();
            if (logCounts != null) {
                final List<Entry<LogType, Integer>> sortedLogCounts = new ArrayList<Entry<LogType, Integer>>(logCounts.size());
                for (Entry<LogType, Integer> entry : logCounts.entrySet()) {
                    // it may happen that the label is unknown -> then avoid any output for this type
                    if (entry.getKey() != LogType.PUBLISH_LISTING && entry.getKey().getL10n() != null) {
                        sortedLogCounts.add(entry);
                    }
                }

                if (!sortedLogCounts.isEmpty()) {
                    // sort the log counts by type id ascending. that way the FOUND, DNF log types are the first and most visible ones
                    Collections.sort(sortedLogCounts, new Comparator<Entry<LogType, Integer>>() {

                        @Override
                        public int compare(Entry<LogType, Integer> logCountItem1, Entry<LogType, Integer> logCountItem2) {
                            return logCountItem1.getKey().compareTo(logCountItem2.getKey());
                        }
                    });

                    ArrayList<String> labels = new ArrayList<String>(sortedLogCounts.size());
                    for (Entry<LogType, Integer> pair : sortedLogCounts) {
                        labels.add(pair.getValue() + " " + pair.getKey().getL10n());
                    }

                    final TextView countView = new TextView(CacheDetailActivity.this);
                    countView.setText(res.getString(R.string.cache_log_types) + ": " + StringUtils.join(labels, ", "));
                    view.addHeaderView(countView, null, false);
                }
            }

            final List<LogEntry> logs = allLogs ? cache.getLogs().asList() : cache.getFriendsLogs();
            view.setAdapter(new ArrayAdapter<LogEntry>(CacheDetailActivity.this, R.layout.cacheview_logs_item, logs) {
                final UserActionsClickListener userActionsClickListener = new UserActionsClickListener();
                final DecryptTextClickListener decryptTextClickListener = new DecryptTextClickListener();

                @Override
                public View getView(final int position, final View convertView, final ViewGroup parent) {
                    View rowView = convertView;
                    if (null == rowView) {
                        rowView = getLayoutInflater().inflate(R.layout.cacheview_logs_item, null);
                    }
                    LogViewHolder holder = (LogViewHolder) rowView.getTag();
                    if (null == holder) {
                        holder = new LogViewHolder(rowView);
                        rowView.setTag(holder);
                    }

                    final LogEntry log = getItem(position);

                    if (log.date > 0) {
                        holder.date.setText(Formatter.formatShortDate(log.date));
                        holder.date.setVisibility(View.VISIBLE);
                    } else {
                        holder.date.setVisibility(View.GONE);
                    }

                    holder.type.setText(log.type.getL10n());
                    holder.author.setText(StringEscapeUtils.unescapeHtml4(log.author));

                    // finds count
                    holder.count.setVisibility(View.VISIBLE);
                    if (log.found == -1) {
                        holder.count.setVisibility(View.GONE);
                    } else {
                        holder.count.setText(res.getQuantityString(R.plurals.cache_counts, log.found, log.found));
                    }

                    // logtext, avoid parsing HTML if not necessary
                    String logText = log.log;
                    if (BaseUtils.containsHtml(logText)) {
                        logText = log.getDisplayText();
                        holder.text.setText(Html.fromHtml(logText, new HtmlImage(cache.getGeocode(), false, cache.getListId(), false), null), TextView.BufferType.SPANNABLE);
                    }
                    else {
                        holder.text.setText(logText);
                    }

                    // images
                    if (log.hasLogImages()) {
                        holder.images.setText(log.getImageTitles());
                        holder.images.setVisibility(View.VISIBLE);
                        holder.images.setOnClickListener(new View.OnClickListener() {
                            @Override
                            public void onClick(View v) {
                                ImagesActivity.startActivityLogImages(CacheDetailActivity.this, cache.getGeocode(), new ArrayList<Image>(log.getLogImages()));
                            }
                        });
                    } else {
                        holder.images.setVisibility(View.GONE);
                    }

                    // colored marker
                    int marker = log.type.markerId;
                    if (marker != 0) {
                        holder.statusMarker.setVisibility(View.VISIBLE);
                        holder.statusMarker.setImageResource(marker);
                    }
                    else {
                        holder.statusMarker.setVisibility(View.GONE);
                    }

                    if (null == convertView) {
                        // if convertView != null then this listeners are already set
                        holder.author.setOnClickListener(userActionsClickListener);
                        holder.text.setMovementMethod(LinkMovementMethod.getInstance());
                        holder.text.setOnClickListener(decryptTextClickListener);
                        registerForContextMenu(holder.text);
                    }

                    return rowView;
                }
            });

            return view;
        }

        private class LogViewHolder {
            final TextView date;
            final TextView type;
            final TextView author;
            final TextView count;
            final TextView text;
            final TextView images;
            final ImageView statusMarker;

            public LogViewHolder(View base) {
                date = (TextView) base.findViewById(R.id.added);
                type = (TextView) base.findViewById(R.id.type);
                author = (TextView) base.findViewById(R.id.author);
                count = (TextView) base.findViewById(R.id.count);
                text = (TextView) base.findViewById(R.id.log);
                images = (TextView) base.findViewById(R.id.log_images);
                statusMarker = (ImageView) base.findViewById(R.id.log_mark);
            }
        }
    }

    private class WaypointsViewCreator extends AbstractCachingPageViewCreator<ScrollView> {

        @Override
        public ScrollView getDispatchedView() {
            if (cache == null) {
                // something is really wrong
                return null;
            }

            view = (ScrollView) getLayoutInflater().inflate(R.layout.cacheview_waypoints, null);

            final LinearLayout waypoints = (LinearLayout) view.findViewById(R.id.waypoints);

            // sort waypoints: PP, Sx, FI, OWN
            final List<Waypoint> sortedWaypoints = new ArrayList<Waypoint>(cache.getWaypoints());
            Collections.sort(sortedWaypoints);

            for (final Waypoint wpt : sortedWaypoints) {
                final LinearLayout waypointView = (LinearLayout) getLayoutInflater().inflate(R.layout.waypoint_item, null);

                // coordinates
                if (null != wpt.getCoords()) {
                    final TextView coordinatesView = (TextView) waypointView.findViewById(R.id.coordinates);
                    coordinatesView.setText(wpt.getCoords().toString());
                    coordinatesView.setVisibility(View.VISIBLE);
                }

                // info
                final String waypointInfo = Formatter.formatWaypointInfo(wpt);
                if (StringUtils.isNotBlank(waypointInfo)) {
                    final TextView infoView = (TextView) waypointView.findViewById(R.id.info);
                    infoView.setText(waypointInfo);
                    infoView.setVisibility(View.VISIBLE);
                }

                // title
                final TextView nameView = (TextView) waypointView.findViewById(R.id.name);
                if (StringUtils.isNotBlank(wpt.getName())) {
                    nameView.setText(StringEscapeUtils.unescapeHtml4(wpt.getName()));
                } else if (null != wpt.getCoords()) {
                    nameView.setText(wpt.getCoords().toString());
                } else {
                    nameView.setText(res.getString(R.string.waypoint));
                }
                wpt.setIcon(res, nameView);

                // note
                if (StringUtils.isNotBlank(wpt.getNote())) {
                    final TextView noteView = (TextView) waypointView.findViewById(R.id.note);
                    noteView.setVisibility(View.VISIBLE);
                    if (BaseUtils.containsHtml(wpt.getNote())) {
                        noteView.setText(Html.fromHtml(wpt.getNote()), TextView.BufferType.SPANNABLE);
                    }
                    else {
                        noteView.setText(wpt.getNote());
                    }
                }

                final View wpNavView = waypointView.findViewById(R.id.wpDefaultNavigation);
                wpNavView.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(View v) {
                        NavigationAppFactory.startDefaultNavigationApplication(1, CacheDetailActivity.this, wpt);
                    }
                });
                wpNavView.setOnLongClickListener(new View.OnLongClickListener() {
                    @Override
                    public boolean onLongClick(View v) {
                        NavigationAppFactory.startDefaultNavigationApplication(2, CacheDetailActivity.this, wpt);
                        return true;
                    }
                });

                registerForContextMenu(waypointView);
                waypointView.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(View v) {
                        openContextMenu(v);
                    }
                });

                waypoints.addView(waypointView);
            }

            final Button addWaypoint = (Button) view.findViewById(R.id.add_waypoint);
            addWaypoint.setClickable(true);
            addWaypoint.setOnClickListener(new View.OnClickListener() {

                @Override
                public void onClick(View v) {
                    EditWaypointActivity.startActivityAddWaypoint(CacheDetailActivity.this, cache);
                    refreshOnResume = true;
                }
            });

            return view;
        }
    }

    private class InventoryViewCreator extends AbstractCachingPageViewCreator<ListView> {

        @Override
        public ListView getDispatchedView() {
            if (cache == null) {
                // something is really wrong
                return null;
            }

            view = (ListView) getLayoutInflater().inflate(R.layout.cacheview_inventory, null);

            // TODO: fix layout, then switch back to Android-resource and delete copied one
            // this copy is modified to respect the text color
            view.setAdapter(new ArrayAdapter<Trackable>(CacheDetailActivity.this, R.layout.simple_list_item_1, cache.getInventory()));
            view.setOnItemClickListener(new OnItemClickListener() {
                @Override
                public void onItemClick(AdapterView<?> arg0, View arg1, int arg2, long arg3) {
                    Object selection = arg0.getItemAtPosition(arg2);
                    if (selection instanceof Trackable) {
                        Trackable trackable = (Trackable) selection;
                        TrackableActivity.startActivity(CacheDetailActivity.this, trackable.getGuid(), trackable.getGeocode(), trackable.getName());
                    }
                }
            });

            return view;
        }
    }

    private class ImagesViewCreator extends AbstractCachingPageViewCreator<View> {

        @Override
        public View getDispatchedView() {
            if (cache == null) {
                return null; // something is really wrong
            }

            view = getLayoutInflater().inflate(R.layout.caches_images, null);
            if (imagesList == null && isCurrentPage(Page.IMAGES)) {
                loadCacheImages();
            }
            return view;
        }
    }

    public static void startActivity(final Context context, final String geocode, final String cacheName) {
        final Intent cachesIntent = new Intent(context, CacheDetailActivity.class);
        cachesIntent.putExtra("geocode", geocode);
        cachesIntent.putExtra("name", cacheName);
        context.startActivity(cachesIntent);
    }

    public static void startActivityGuid(final Context context, final String guid, final String cacheName) {
        final Intent cacheIntent = new Intent(context, CacheDetailActivity.class);
        cacheIntent.putExtra("guid", guid);
        cacheIntent.putExtra("name", cacheName);
        context.startActivity(cacheIntent);
    }

    /**
     * A dialog to allow the user to select reseting coordinates local/remote/both.
     */
    private class ResetCacheCoordinatesDialog extends AlertDialog {

        final RadioButton resetBoth;
        final RadioButton resetLocal;

        public ResetCacheCoordinatesDialog(final cgCache cache, final Waypoint wpt, final Activity activity) {
            super(activity);

            View layout = activity.getLayoutInflater().inflate(R.layout.reset_cache_coords_dialog, null);
            setView(layout);

            resetLocal = (RadioButton) layout.findViewById(R.id.reset_cache_coordinates_local);
            resetBoth = (RadioButton) layout.findViewById(R.id.reset_cache_coordinates_local_and_remote);

            if (ConnectorFactory.getConnector(cache).supportsOwnCoordinates()) {
                resetBoth.setVisibility(View.VISIBLE);
            }

            layout.findViewById(R.id.reset).setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    dismiss();
                    final ProgressDialog p = ProgressDialog.show(CacheDetailActivity.this, res.getString(R.string.cache), res.getString(R.string.waypoint_reset), true);
                    final Handler h = new Handler() {
                        private boolean remoteFinished = false;
                        private boolean localFinished = false;

                        @Override
                        public void handleMessage(Message msg) {
                            if (msg.what == ResetCoordsThread.LOCAL) {
                                localFinished = true;
                            } else {
                                remoteFinished = true;
                            }

                            if ((localFinished) && (remoteFinished || !resetBoth.isChecked())) {
                                p.dismiss();
                                notifyDataSetChanged();
                            }
                        }

                    };
                    new ResetCoordsThread(cache, h, wpt, resetLocal.isChecked() || resetBoth.isChecked(), resetBoth.isChecked(), p).start();
                }
            });
        }
    }

    private class ResetCoordsThread extends Thread {

        private final cgCache cache;
        private final Handler handler;
        private final boolean local;
        private final boolean remote;
        private final Waypoint wpt;
        private ProgressDialog progress;
        public static final int LOCAL = 0;
        public static final int ON_WEBSITE = 1;

        public ResetCoordsThread(cgCache cache, Handler handler, final Waypoint wpt, boolean local, boolean remote, final ProgressDialog progress) {
            this.cache = cache;
            this.handler = handler;
            this.local = local;
            this.remote = remote;
            this.wpt = wpt;
            this.progress = progress;
        }

        @Override
        public void run() {

            if (local) {
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        progress.setMessage(res.getString(R.string.waypoint_reset_cache_coords));
                    }
                });
                cache.setCoords(wpt.getCoords());
                cache.setUserModifiedCoords(false);
                cache.deleteWaypointForce(wpt);
                cgData.saveChangedCache(cache);
                handler.sendEmptyMessage(LOCAL);
            }

            IConnector con = ConnectorFactory.getConnector(cache);
            if (remote && con.supportsOwnCoordinates()) {
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        progress.setMessage(res.getString(R.string.waypoint_coordinates_being_reset_on_website));
                    }
                });

                final boolean result = con.deleteModifiedCoordinates(cache);

                runOnUiThread(new Runnable() {

                    @Override
                    public void run() {
                        if (result) {
                            showToast(getString(R.string.waypoint_coordinates_has_been_reset_on_website));
                        } else {
                            showToast(getString(R.string.waypoint_coordinates_upload_error));
                        }
                        handler.sendEmptyMessage(ON_WEBSITE);
                        notifyDataSetChanged();
                    }

                });

            }
        }
    }

    @Override
    protected String getTitle(Page page) {
        // show number of waypoints directly in waypoint title
        if (page == Page.WAYPOINTS) {
            final int waypointCount = cache.getWaypoints().size();
            return res.getQuantityString(R.plurals.waypoints, waypointCount, waypointCount);
        }
        return res.getString(page.titleStringId);
    }

    @Override
    protected Pair<List<? extends Page>, Integer> getOrderedPages() {
        final ArrayList<Page> pages = new ArrayList<Page>();
        pages.add(Page.WAYPOINTS);
        pages.add(Page.DETAILS);
        final int detailsIndex = pages.size() - 1;
        pages.add(Page.DESCRIPTION);
        if (cache.getLogs().isNotEmpty()) {
            pages.add(Page.LOGS);
        }
        if (CollectionUtils.isNotEmpty(cache.getFriendsLogs())) {
            pages.add(Page.LOGSFRIENDS);
        }
        if (CollectionUtils.isNotEmpty(cache.getInventory())) {
            pages.add(Page.INVENTORY);
        }
        if (CollectionUtils.isNotEmpty(cache.getImages())) {
            pages.add(Page.IMAGES);
        }
        return new ImmutablePair<List<? extends Page>, Integer>(pages, detailsIndex);
    }

    @Override
    protected AbstractViewPagerActivity.PageViewCreator createViewCreator(Page page) {
        switch (page) {
            case DETAILS:
                return new DetailsViewCreator();

            case DESCRIPTION:
                return new DescriptionViewCreator();

            case LOGS:
                return new LogsViewCreator(true);

            case LOGSFRIENDS:
                return new LogsViewCreator(false);

            case WAYPOINTS:
                return new WaypointsViewCreator();

            case INVENTORY:
                return new InventoryViewCreator();

            case IMAGES:
                return new ImagesViewCreator();

            default:
                throw new IllegalArgumentException();
        }
    }

}
!@#$%
20190527_000946,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_c13452
package cgeo.geocaching;

import cgeo.calendar.ICalendar;
import cgeo.geocaching.activity.AbstractViewPagerActivity;
import cgeo.geocaching.activity.Progress;
import cgeo.geocaching.apps.cache.navi.NavigationAppFactory;
import cgeo.geocaching.compatibility.Compatibility;
import cgeo.geocaching.connector.ConnectorFactory;
import cgeo.geocaching.connector.IConnector;
import cgeo.geocaching.connector.gc.GCConnector;
import cgeo.geocaching.enumerations.CacheAttribute;
import cgeo.geocaching.enumerations.LoadFlags;
import cgeo.geocaching.enumerations.LoadFlags.SaveFlag;
import cgeo.geocaching.enumerations.LogType;
import cgeo.geocaching.enumerations.WaypointType;
import cgeo.geocaching.geopoint.GeopointFormatter;
import cgeo.geocaching.geopoint.Units;
import cgeo.geocaching.network.HtmlImage;
import cgeo.geocaching.network.Network;
import cgeo.geocaching.network.Parameters;
import cgeo.geocaching.ui.AbstractCachingPageViewCreator;
import cgeo.geocaching.ui.CacheDetailsCreator;
import cgeo.geocaching.ui.DecryptTextClickListener;
import cgeo.geocaching.ui.EditorDialog;
import cgeo.geocaching.ui.Formatter;
import cgeo.geocaching.ui.ImagesList;
import cgeo.geocaching.ui.ImagesList.ImageType;
import cgeo.geocaching.ui.LoggingUI;
import cgeo.geocaching.utils.BaseUtils;
import cgeo.geocaching.utils.CancellableHandler;
import cgeo.geocaching.utils.ClipboardUtils;
import cgeo.geocaching.utils.CryptUtils;
import cgeo.geocaching.utils.GeoDirHandler;
import cgeo.geocaching.utils.HtmlUtils;
import cgeo.geocaching.utils.ImageHelper;
import cgeo.geocaching.utils.Log;
import cgeo.geocaching.utils.MatcherWrapper;
import cgeo.geocaching.utils.TranslationUtils;
import cgeo.geocaching.utils.UnknownTagsHandler;

import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang3.StringEscapeUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.apache.commons.lang3.tuple.Pair;

import android.R.color;
import android.app.Activity;
import android.app.AlertDialog;
import android.app.ProgressDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.graphics.Bitmap;
import android.graphics.Typeface;
import android.graphics.drawable.BitmapDrawable;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.text.Editable;
import android.text.Html;
import android.text.Spannable;
import android.text.Spanned;
import android.text.format.DateUtils;
import android.text.method.LinkMovementMethod;
import android.text.style.ForegroundColorSpan;
import android.text.style.StrikethroughSpan;
import android.text.style.StyleSpan;
import android.view.ContextMenu;
import android.view.Menu;
import android.view.MenuItem;
import android.view.SubMenu;
import android.view.View;
import android.view.View.OnLongClickListener;
import android.view.ViewGroup;
import android.view.ViewGroup.LayoutParams;
import android.view.ViewParent;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.ArrayAdapter;
import android.widget.Button;
import android.widget.FrameLayout;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.ListView;
import android.widget.RadioButton;
import android.widget.ScrollView;
import android.widget.TextView;
import android.widget.TextView.BufferType;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.EnumSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Map.Entry;
import java.util.regex.Pattern;

/**
 * Activity to handle all single-cache-stuff.
 *
 * e.g. details, description, logs, waypoints, inventory...
 */
public class CacheDetailActivity extends AbstractViewPagerActivity<CacheDetailActivity.Page> {

    private static final int MENU_FIELD_COPY = 1;
    private static final int MENU_FIELD_TRANSLATE = 2;
    private static final int MENU_FIELD_TRANSLATE_EN = 3;
    private static final int MENU_FIELD_SHARE = 4;
    private static final int MENU_SHARE = 12;
    private static final int MENU_CALENDAR = 11;
    private static final int MENU_CACHES_AROUND = 10;
    private static final int MENU_BROWSER = 7;
    private static final int MENU_DEFAULT_NAVIGATION = 13;

    private static final int CONTEXT_MENU_WAYPOINT_EDIT = 1234;
    private static final int CONTEXT_MENU_WAYPOINT_DUPLICATE = 1235;
    private static final int CONTEXT_MENU_WAYPOINT_DELETE = 1236;
    private static final int CONTEXT_MENU_WAYPOINT_NAVIGATE = 1238;
    private static final int CONTEXT_MENU_WAYPOINT_CACHES_AROUND = 1239;
    private static final int CONTEXT_MENU_WAYPOINT_DEFAULT_NAVIGATION = 1240;
    private static final int CONTEXT_MENU_WAYPOINT_RESET_ORIGINAL_CACHE_COORDINATES = 1241;

    private static final Pattern DARK_COLOR_PATTERN = Pattern.compile(Pattern.quote("color=\"#") + "(0[0-9]){3}" + "\"");

    private cgCache cache;
    private final Progress progress = new Progress();
    private SearchResult search;

    private final GeoDirHandler locationUpdater = new GeoDirHandler() {
        @Override
        public void updateGeoData(final IGeoData geo) {
            if (cacheDistanceView == null) {
                return;
            }

            try {
                final StringBuilder dist = new StringBuilder();

                if (geo.getCoords() != null && cache != null && cache.getCoords() != null) {
                    dist.append(Units.getDistanceFromKilometers(geo.getCoords().distanceTo(cache.getCoords())));
                }

                if (cache != null && cache.getElevation() != null) {
                    if (geo.getAltitude() != 0.0) {
                        final float diff = (float) (cache.getElevation() - geo.getAltitude());
                        dist.append(' ').append(Units.getElevation(diff));
                    }
                }

                cacheDistanceView.setText(dist.toString());
                cacheDistanceView.bringToFront();
            } catch (Exception e) {
                Log.w("Failed to update location.");
            }
        }
    };

    private CharSequence clickedItemText = null;
    private int contextMenuWPIndex = -1;

    /**
     * If another activity is called and can modify the data of this activity, we refresh it on resume.
     */
    private boolean refreshOnResume = false;

    // some views that must be available from everywhere // TODO: Reference can block GC?
    private TextView cacheDistanceView;

    private Handler cacheChangeNotificationHandler = new Handler() {
        @Override
        public void handleMessage(Message msg) {
            notifyDataSetChanged();
        }
    };
    protected ImagesList imagesList;

    public CacheDetailActivity() {
        // identifier for manual
        super("c:geolocation-cache-details");
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        // initialize the main view and set a default title
        setTheme();
        setContentView(R.layout.cacheview);
        setTitle(res.getString(R.string.cache));

        String geocode = null;

        // TODO Why can it happen that search is not null? onCreate should be called only once and it is not set before.
        if (search != null) {
            cache = search.getFirstCacheFromResult(LoadFlags.LOAD_ALL_DB_ONLY);
            if (cache != null && cache.getGeocode() != null) {
                geocode = cache.getGeocode();
            }
        }

        // get parameters
        final Bundle extras = getIntent().getExtras();
        final Uri uri = getIntent().getData();

        // try to get data from extras
        String name = null;
        String guid = null;
        if (geocode == null && extras != null) {
            geocode = extras.getString("geocode");
            name = extras.getString("name");
            guid = extras.getString("guid");
        }

        // try to get data from URI
        if (geocode == null && guid == null && uri != null) {
            String uriHost = uri.getHost().toLowerCase(Locale.US);
            String uriPath = uri.getPath().toLowerCase(Locale.US);
            String uriQuery = uri.getQuery();

            if (uriQuery != null) {
                Log.i("Opening URI: " + uriHost + uriPath + "?" + uriQuery);
            } else {
                Log.i("Opening URI: " + uriHost + uriPath);
            }

            if (uriHost.contains("geocaching.com")) {
                geocode = uri.getQueryParameter("wp");
                guid = uri.getQueryParameter("guid");

                if (StringUtils.isNotBlank(geocode)) {
                    geocode = geocode.toUpperCase(Locale.US);
                    guid = null;
                } else if (StringUtils.isNotBlank(guid)) {
                    geocode = null;
                    guid = guid.toLowerCase(Locale.US);
                } else {
                    showToast(res.getString(R.string.err_detail_open));
                    finish();
                    return;
                }
            } else if (uriHost.contains("coord.info")) {
                if (uriPath != null && uriPath.startsWith("/gc")) {
                    geocode = uriPath.substring(1).toUpperCase(Locale.US);
                } else {
                    showToast(res.getString(R.string.err_detail_open));
                    finish();
                    return;
                }
            }
        }

        // no given data
        if (geocode == null && guid == null) {
            showToast(res.getString(R.string.err_detail_cache));
            finish();
            return;
        }

        final LoadCacheHandler loadCacheHandler = new LoadCacheHandler();

        try {
            String title = res.getString(R.string.cache);
            if (StringUtils.isNotBlank(name)) {
                title = name;
            } else if (null != geocode && StringUtils.isNotBlank(geocode)) { // can't be null, but the compiler doesn't understand StringUtils.isNotBlank()
                title = geocode;
            }
            progress.show(this, title, res.getString(R.string.cache_dialog_loading_details), true, loadCacheHandler.cancelMessage());
        } catch (Exception e) {
            // nothing, we lost the window
        }

        ImageView defaultNavigationImageView = (ImageView) findViewById(R.id.defaultNavigation);
        defaultNavigationImageView.setOnLongClickListener(new OnLongClickListener() {
            @Override
            public boolean onLongClick(View v) {
                startDefaultNavigation2();
                return true;
            }
        });

        final int pageToOpen = Settings.isOpenLastDetailsPage() ? Settings.getLastDetailsPage() : 1;
        createViewPager(pageToOpen, new OnPageSelectedListener() {

            @Override
            public void onPageSelected(int position) {
                if (Settings.isOpenLastDetailsPage()) {
                    Settings.setLastDetailsPage(position);
                }
                // lazy loading of cache images
                if (getPage(position) == Page.IMAGES) {
                    loadCacheImages();
                }
            }
        });

        // Initialization done. Let's load the data with the given information.
        new LoadCacheThread(geocode, guid, loadCacheHandler).start();
    }

    @Override
    public void onResume() {
        super.onResume();

        if (refreshOnResume) {
            notifyDataSetChanged();
            refreshOnResume = false;
        }
        locationUpdater.startGeo();
    }

    @Override
    public void onStop() {
        if (cache != null) {
            cache.setChangeNotificationHandler(null);
        }
        super.onStop();
    }

    @Override
    public void onPause() {
        locationUpdater.stopGeo();
        super.onPause();
    }

    @Override
    public void onCreateContextMenu(ContextMenu menu, View view, ContextMenu.ContextMenuInfo info) {
        super.onCreateContextMenu(menu, view, info);
        final int viewId = view.getId();
        contextMenuWPIndex = -1;
        switch (viewId) {
            case R.id.value: // coordinates
                clickedItemText = ((TextView) view).getText();
                buildOptionsContextmenu(menu, viewId, res.getString(R.string.cache_coordinates), true);
                break;
            case R.id.shortdesc:
                clickedItemText = ((TextView) view).getText();
                buildOptionsContextmenu(menu, viewId, res.getString(R.string.cache_description), false);
                break;
            case R.id.longdesc:
                // combine short and long description
                String shortDesc = cache.getShortDescription();
                if (StringUtils.isBlank(shortDesc)) {
                    clickedItemText = ((TextView) view).getText();
                } else {
                    clickedItemText = shortDesc + "\n\n" + ((TextView) view).getText();
                }
                buildOptionsContextmenu(menu, viewId, res.getString(R.string.cache_description), false);
                break;
            case R.id.personalnote:
                clickedItemText = ((TextView) view).getText();
                buildOptionsContextmenu(menu, viewId, res.getString(R.string.cache_personal_note), true);
                break;
            case R.id.hint:
                clickedItemText = ((TextView) view).getText();
                buildOptionsContextmenu(menu, viewId, res.getString(R.string.cache_hint), false);
                break;
            case R.id.log:
                clickedItemText = ((TextView) view).getText();
                buildOptionsContextmenu(menu, viewId, res.getString(R.string.cache_logs), false);
                break;
            case -1:
                if (null != cache.getWaypoints()) {
                    try {
                        final ViewGroup parent = ((ViewGroup) view.getParent());
                        for (int i = 0; i < parent.getChildCount(); i++) {
                            if (parent.getChildAt(i) == view) {
                                final List<Waypoint> sortedWaypoints = new ArrayList<Waypoint>(cache.getWaypoints());
                                Collections.sort(sortedWaypoints);
                                final Waypoint waypoint = sortedWaypoints.get(i);
                                final int index = cache.getWaypoints().indexOf(waypoint);
                                menu.setHeaderTitle(res.getString(R.string.waypoint));
                                if (waypoint.getWaypointType().equals(WaypointType.ORIGINAL)) {
                                    menu.add(CONTEXT_MENU_WAYPOINT_RESET_ORIGINAL_CACHE_COORDINATES, index, 0, R.string.waypoint_reset_cache_coords);
                                } else {
                                    menu.add(CONTEXT_MENU_WAYPOINT_EDIT, index, 0, R.string.waypoint_edit);
                                    menu.add(CONTEXT_MENU_WAYPOINT_DUPLICATE, index, 0, R.string.waypoint_duplicate);
                                }
                                contextMenuWPIndex = index;
                                if (waypoint.isUserDefined() && !waypoint.getWaypointType().equals(WaypointType.ORIGINAL)) {
                                    menu.add(CONTEXT_MENU_WAYPOINT_DELETE, index, 0, R.string.waypoint_delete);
                                }
                                if (waypoint.getCoords() != null) {
                                    menu.add(CONTEXT_MENU_WAYPOINT_DEFAULT_NAVIGATION, index, 0, NavigationAppFactory.getDefaultNavigationApplication().getName());
                                    menu.add(CONTEXT_MENU_WAYPOINT_NAVIGATE, index, 0, R.string.cache_menu_navigate).setIcon(R.drawable.ic_menu_mapmode);
                                    menu.add(CONTEXT_MENU_WAYPOINT_CACHES_AROUND, index, 0, R.string.cache_menu_around);
                                }
                                break;
                            }
                        }
                    } catch (Exception e) {
                    }
                }
                break;
            default:
                if (imagesList != null) {
                    imagesList.onCreateContextMenu(menu, view);
                }
                break;
        }
    }

    private void buildOptionsContextmenu(ContextMenu menu, int viewId, String fieldTitle, boolean copyOnly) {
        menu.setHeaderTitle(fieldTitle);
        menu.add(viewId, MENU_FIELD_COPY, 0, res.getString(android.R.string.copy));
        if (!copyOnly) {
            if (clickedItemText.length() > TranslationUtils.translationTextLengthToWarn) {
                showToast(res.getString(R.string.translate_length_warning));
            }
            menu.add(viewId, MENU_FIELD_TRANSLATE, 0, res.getString(R.string.translate_to_sys_lang, Locale.getDefault().getDisplayLanguage()));
            if (Settings.isUseEnglish() && !StringUtils.equals(Locale.getDefault().getLanguage(), Locale.ENGLISH.getLanguage())) {
                menu.add(viewId, MENU_FIELD_TRANSLATE_EN, 0, res.getString(R.string.translate_to_english));
            }

        }
        menu.add(viewId, MENU_FIELD_SHARE, 0, res.getString(R.string.cache_share_field));
    }

    @Override
    public boolean onContextItemSelected(MenuItem item) {
        final int groupId = item.getGroupId();
        final int index = item.getItemId();
        switch (groupId) {
            case R.id.value:
            case R.id.shortdesc:
            case R.id.longdesc:
            case R.id.personalnote:
            case R.id.hint:
            case R.id.log:
                switch (index) {
                    case MENU_FIELD_COPY:
                        ClipboardUtils.copyToClipboard(clickedItemText);
                        showToast(res.getString(R.string.clipboard_copy_ok));
                        return true;
                    case MENU_FIELD_TRANSLATE:
                        TranslationUtils.startActivityTranslate(this, Locale.getDefault().getLanguage(), HtmlUtils.extractText(clickedItemText));
                        return true;
                    case MENU_FIELD_TRANSLATE_EN:
                        TranslationUtils.startActivityTranslate(this, Locale.ENGLISH.getLanguage(), HtmlUtils.extractText(clickedItemText));
                        return true;
                    case MENU_FIELD_SHARE:
                        final Intent intent = new Intent(Intent.ACTION_SEND);
                        intent.setType("text/plain");
                        intent.putExtra(Intent.EXTRA_TEXT, clickedItemText.toString());
                        startActivity(Intent.createChooser(intent, res.getText(R.string.cache_share_field)));
                        return true;
                    default:
                        break;
                }

                break;
            case CONTEXT_MENU_WAYPOINT_EDIT:
                final Waypoint waypointEdit = cache.getWaypoint(index);
                if (waypointEdit != null) {
                    EditWaypointActivity.startActivityEditWaypoint(this, waypointEdit.getId());
                    refreshOnResume = true;
                }
                break;
            case CONTEXT_MENU_WAYPOINT_DUPLICATE:
                final Waypoint waypointDuplicate = cache.getWaypoint(index);
                if (cache.duplicateWaypoint(waypointDuplicate)) {
                    cgData.saveCache(cache, EnumSet.of(SaveFlag.SAVE_DB));
                    notifyDataSetChanged();
                }
                break;
            case CONTEXT_MENU_WAYPOINT_DELETE:
                final Waypoint waypointDelete = cache.getWaypoint(index);
                if (cache.deleteWaypoint(waypointDelete)) {
                    cgData.saveCache(cache, EnumSet.of(SaveFlag.SAVE_DB));
                    notifyDataSetChanged();
                }
                break;
            case CONTEXT_MENU_WAYPOINT_DEFAULT_NAVIGATION:
                final Waypoint waypointNavigation = cache.getWaypoint(index);
                if (waypointNavigation != null) {
                    NavigationAppFactory.startDefaultNavigationApplication(1, this, waypointNavigation);
                }
                break;
            case CONTEXT_MENU_WAYPOINT_NAVIGATE:
                final Waypoint waypointNav = cache.getWaypoint(contextMenuWPIndex);
                if (waypointNav != null) {
                    NavigationAppFactory.showNavigationMenu(this, null, waypointNav, null);
                }
                break;
            case CONTEXT_MENU_WAYPOINT_CACHES_AROUND:
                final Waypoint waypointAround = cache.getWaypoint(index);
                if (waypointAround != null) {
                    cgeocaches.startActivityCoordinates(this, waypointAround.getCoords());
                }
                break;

            case CONTEXT_MENU_WAYPOINT_RESET_ORIGINAL_CACHE_COORDINATES:
                new ResetCacheCoordinatesDialog(cache, cache.getWaypoint(index), this).show();
                break;

            default:
                if (imagesList != null && imagesList.onContextItemSelected(item)) {
                    return true;
                }
                return onOptionsItemSelected(item);
        }
        return false;
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        if (null != cache) {
            menu.add(0, MENU_DEFAULT_NAVIGATION, 0, NavigationAppFactory.getDefaultNavigationApplication().getName()).setIcon(R.drawable.ic_menu_compass); // default navigation tool

            final SubMenu subMenu = menu.addSubMenu(0, 0, 0, res.getString(R.string.cache_menu_navigate)).setIcon(R.drawable.ic_menu_mapmode);
            NavigationAppFactory.addMenuItems(subMenu, cache);

            menu.add(0, MENU_CALENDAR, 0, res.getString(R.string.cache_menu_event)).setIcon(R.drawable.ic_menu_agenda); // add event to calendar
            LoggingUI.addMenuItems(menu, cache);
            menu.add(0, MENU_CACHES_AROUND, 0, res.getString(R.string.cache_menu_around)).setIcon(R.drawable.ic_menu_rotate); // caches around
            menu.add(0, MENU_BROWSER, 0, res.getString(R.string.cache_menu_browser)).setIcon(R.drawable.ic_menu_globe); // browser
            menu.add(0, MENU_SHARE, 0, res.getString(R.string.cache_menu_share)).setIcon(R.drawable.ic_menu_share); // share cache
        }
        return true;
    }

    @Override
    public boolean onPrepareOptionsMenu(Menu menu) {
        if (cache != null) {
            menu.findItem(MENU_DEFAULT_NAVIGATION).setVisible(null != cache.getCoords());
            menu.findItem(MENU_CALENDAR).setVisible(cache.canBeAddedToCalendar());
            menu.findItem(MENU_CACHES_AROUND).setVisible(null != cache.getCoords() && cache.supportsCachesAround());
            menu.findItem(MENU_BROWSER).setVisible(cache.canOpenInBrowser());
        }
        return super.onPrepareOptionsMenu(menu);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        final int menuItem = item.getItemId();

        switch (menuItem) {
            case 0:
                // no menu selected, but a new sub menu shown
                return false;
            case MENU_DEFAULT_NAVIGATION:
                startDefaultNavigation();
                return true;
            case MENU_BROWSER:
                cache.openInBrowser(this);
                return true;
            case MENU_CACHES_AROUND:
                cgeocaches.startActivityCoordinates(this, cache.getCoords());
                return true;
            case MENU_CALENDAR:
                addToCalendarWithIntent();
                return true;
            case MENU_SHARE:
                if (cache != null) {
                    cache.shareCache(this, res);
                    return true;
                }
                return false;
            default:
                if (NavigationAppFactory.onMenuItemSelected(item, this, cache)) {
                    return true;
                }
                if (LoggingUI.onMenuItemSelected(item, this, cache)) {
                    refreshOnResume = true;
                    return true;
                }
        }

        return true;
    }

    private class LoadCacheHandler extends CancellableHandler {
        @Override
        public void handleRegularMessage(final Message msg) {
            if (UPDATE_LOAD_PROGRESS_DETAIL == msg.what && msg.obj instanceof String) {
                updateStatusMsg((String) msg.obj);
            } else {
                if (search == null) {
                    showToast(res.getString(R.string.err_dwld_details_failed));

                    progress.dismiss();
                    finish();
                    return;
                }

                if (search.getError() != null) {
                    showToast(res.getString(R.string.err_dwld_details_failed) + " " + search.getError().getErrorString(res) + ".");

                    progress.dismiss();
                    finish();
                    return;
                }

                updateStatusMsg(res.getString(R.string.cache_dialog_loading_details_status_render));

                // Data loaded, we're ready to show it!
                notifyDataSetChanged();
            }
        }

        private void updateStatusMsg(final String msg) {
            progress.setMessage(res.getString(R.string.cache_dialog_loading_details)
                    + "\n\n"
                    + msg);
        }

        @Override
        public void handleCancel(final Object extra) {
            finish();
        }

    }

    private void notifyDataSetChanged() {
        if (search == null) {
            return;
        }

        cache = search.getFirstCacheFromResult(LoadFlags.LOAD_ALL_DB_ONLY);

        if (cache == null) {
            progress.dismiss();
            showToast(res.getString(R.string.err_detail_cache_find_some));
            finish();
            return;
        }

        // allow cache to notify CacheDetailActivity when it changes so it can be reloaded
        cache.setChangeNotificationHandler(cacheChangeNotificationHandler);

        // action bar: title and icon
        if (StringUtils.isNotBlank(cache.getName())) {
            setTitle(cache.getName() + " (" + cache.getGeocode() + ')');
        } else {
            setTitle(cache.getGeocode());
        }
        ((TextView) findViewById(R.id.actionbar_title)).setCompoundDrawablesWithIntrinsicBounds(getResources().getDrawable(cache.getType().markerId), null, null, null);

        reinitializeViewPager();

        // rendering done! remove progress popup if any there
        invalidateOptionsMenuCompatible();
        progress.dismiss();
    }

    /**
     * Loads the cache with the given geocode or guid.
     */
    private class LoadCacheThread extends Thread {

        private CancellableHandler handler = null;
        private String geocode;
        private String guid;

        public LoadCacheThread(final String geocode, final String guid, final CancellableHandler handlerIn) {
            handler = handlerIn;

            if (StringUtils.isBlank(geocode) && StringUtils.isBlank(guid)) {
                showToast(res.getString(R.string.err_detail_cache_forgot));

                progress.dismiss();
                finish();
                return;
            }

            this.geocode = geocode;
            this.guid = guid;
        }

        @Override
        public void run() {
            search = cgCache.searchByGeocode(geocode, StringUtils.isBlank(geocode) ? guid : null, 0, false, handler);
            handler.sendMessage(Message.obtain());
        }
    }

    /**
     * Indicates whether the specified action can be used as an intent. This
     * method queries the package manager for installed packages that can
     * respond to an intent with the specified action. If no suitable package is
     * found, this method returns false.
     *
     * @param context
     *            The application's environment.
     * @param action
     *            The Intent action to check for availability.
     * @param uri
     *            The Intent URI to check for availability.
     *
     * @return True if an Intent with the specified action can be sent and
     *         responded to, false otherwise.
     */
    private static boolean isIntentAvailable(Context context, String action, Uri uri) {
        final PackageManager packageManager = context.getPackageManager();
        final Intent intent;
        if (uri == null) {
            intent = new Intent(action);
        } else {
            intent = new Intent(action, uri);
        }
        final List<ResolveInfo> list = packageManager.queryIntentActivities(intent,
                PackageManager.MATCH_DEFAULT_ONLY);
        return !list.isEmpty();
    }

    private void addToCalendarWithIntent() {

        final boolean calendarAddOnAvailable = isIntentAvailable(this, ICalendar.INTENT, Uri.parse(ICalendar.URI_SCHEME + "://" + ICalendar.URI_HOST));

        if (calendarAddOnAvailable) {
            final Parameters params = new Parameters(
                    ICalendar.PARAM_NAME, cache.getName(),
                    ICalendar.PARAM_NOTE, StringUtils.defaultString(cache.getPersonalNote()),
                    ICalendar.PARAM_HIDDEN_DATE, String.valueOf(cache.getHiddenDate().getTime()),
                    ICalendar.PARAM_URL, StringUtils.defaultString(cache.getUrl()),
                    ICalendar.PARAM_COORDS, cache.getCoords() == null ? "" : cache.getCoords().format(GeopointFormatter.Format.LAT_LON_DECMINUTE_RAW),
                    ICalendar.PARAM_LOCATION, StringUtils.defaultString(cache.getLocation()),
                    ICalendar.PARAM_SHORT_DESC, StringUtils.defaultString(cache.getShortDescription()),
                    ICalendar.PARAM_START_TIME_MINUTES, StringUtils.defaultString(cache.guessEventTimeMinutes())
                    );

            startActivity(new Intent(ICalendar.INTENT,
                    Uri.parse(ICalendar.URI_SCHEME + "://" + ICalendar.URI_HOST + "?" + params.toString())));
        } else {
            // Inform user the calendar add-on is not installed and let them get it from Google Play
            new AlertDialog.Builder(this)
                    .setTitle(res.getString(R.string.addon_missing_title))
                    .setMessage(new StringBuilder(res.getString(R.string.helper_calendar_missing))
                            .append(' ')
                            .append(res.getString(R.string.addon_download_prompt))
                            .toString())
                    .setPositiveButton(getString(android.R.string.yes), new DialogInterface.OnClickListener() {
                        @Override
                        public void onClick(DialogInterface dialog, int id) {
                            Intent intent = new Intent(Intent.ACTION_VIEW);
                            intent.setData(Uri.parse(ICalendar.CALENDAR_ADDON_URI));
                            startActivity(intent);
                        }
                    })
                    .setNegativeButton(getString(android.R.string.no), new DialogInterface.OnClickListener() {
                        @Override
                        public void onClick(DialogInterface dialog, int id) {
                            dialog.cancel();
                        }
                    })
                    .create()
                    .show();
        }
    }

    /**
     * Tries to navigate to the {@link cgCache} of this activity.
     */
    private void startDefaultNavigation() {
        NavigationAppFactory.startDefaultNavigationApplication(1, this, cache);
    }

    /**
     * Tries to navigate to the {@link cgCache} of this activity.
     */
    private void startDefaultNavigation2() {
        NavigationAppFactory.startDefaultNavigationApplication(2, this, cache);
    }

    /**
     * Wrapper for the referenced method in the xml-layout.
     */
    public void startDefaultNavigation(@SuppressWarnings("unused") View view) {
        startDefaultNavigation();
    }

    /**
     * referenced from XML view
     */
    public void showNavigationMenu(@SuppressWarnings("unused") View view) {
        NavigationAppFactory.showNavigationMenu(this, cache, null, null, true, true);
    }

    /**
     * Listener for clicks on username
     */
    private class UserActionsClickListener implements View.OnClickListener {

        @Override
        public void onClick(View view) {
            if (view == null) {
                return;
            }
            if (!cache.supportsUserActions()) {
                return;
            }

            clickedItemText = ((TextView) view).getText().toString();
            showUserActionsDialog(clickedItemText);
        }
    }

    /**
     * Listener for clicks on owner name
     */
    private class OwnerActionsClickListener implements View.OnClickListener {

        @Override
        public void onClick(View view) {
            if (view == null) {
                return;
            }
            if (!cache.supportsUserActions()) {
                return;
            }

            // Use real owner name vice the one owner chose to display
            if (StringUtils.isNotBlank(cache.getOwnerUserId())) {
                clickedItemText = cache.getOwnerUserId();
            } else {
                clickedItemText = ((TextView) view).getText().toString();
            }
            showUserActionsDialog(clickedItemText);
        }
    }

    /**
     * Opens a dialog to do actions on an username
     */
    private void showUserActionsDialog(final CharSequence name) {
        final CharSequence[] items = { res.getString(R.string.user_menu_view_hidden),
                res.getString(R.string.user_menu_view_found),
                res.getString(R.string.user_menu_open_browser)
        };

        AlertDialog.Builder builder = new AlertDialog.Builder(this);
        builder.setTitle(res.getString(R.string.user_menu_title) + " " + name);
        builder.setItems(items, new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int item) {
                switch (item) {
                    case 0:
                        cgeocaches.startActivityOwner(CacheDetailActivity.this, name.toString());
                        return;
                    case 1:
                        cgeocaches.startActivityUserName(CacheDetailActivity.this, name.toString());
                        return;
                    case 2:
                        startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse("http://www.geocaching.com/profile/?u=" + Network.encode(name.toString()))));
                        return;
                    default:
                        break;
                }
            }
        });
        AlertDialog alert = builder.create();
        alert.show();
    }

    private void loadCacheImages() {
        if (imagesList != null) {
            return;
        }
        PageViewCreator creator = getViewCreator(Page.IMAGES);
        if (creator == null) {
            return;
        }
        View imageView = creator.getView();
        if (imageView == null) {
            return;
        }
        imagesList = new ImagesList(this, cache.getGeocode());
        imagesList.loadImages(imageView, cache.getImages(), ImageType.AllImages, false);
    }

    public static void startActivity(final Context context, final String geocode) {
        final Intent detailIntent = new Intent(context, CacheDetailActivity.class);
        detailIntent.putExtra("geocode", geocode);
        context.startActivity(detailIntent);
    }

    /**
     * Enum of all possible pages with methods to get the view and a title.
     */
    public enum Page {
        DETAILS(R.string.detail),
        DESCRIPTION(R.string.cache_description),
        LOGS(R.string.cache_logs),
        LOGSFRIENDS(R.string.cache_logsfriends),
        WAYPOINTS(R.string.cache_waypoints),
        INVENTORY(R.string.cache_inventory),
        IMAGES(R.string.cache_images);

        final private int titleStringId;

        Page(final int titleStringId) {
            this.titleStringId = titleStringId;
        }
    }

    private class AttributeViewBuilder {
        private ViewGroup attributeIconsLayout; // layout for attribute icons
        private ViewGroup attributeDescriptionsLayout; // layout for attribute descriptions
        private boolean attributesShowAsIcons = true; // default: show icons
        /**
         * If the cache is from a non GC source, it might be without icons. Disable switching in those cases.
         */
        private boolean noAttributeIconsFound = false;
        private int attributeBoxMaxWidth;

        public void fillView(final LinearLayout attributeBox) {
            // first ensure that the view is empty
            attributeBox.removeAllViews();

            // maximum width for attribute icons is screen width - paddings of parents
            attributeBoxMaxWidth = Compatibility.getDisplayWidth();
            ViewParent child = attributeBox;
            do {
                if (child instanceof View) {
                    attributeBoxMaxWidth -= ((View) child).getPaddingLeft() + ((View) child).getPaddingRight();
                }
                child = child.getParent();
            } while (child != null);

            // delete views holding description / icons
            attributeDescriptionsLayout = null;
            attributeIconsLayout = null;

            attributeBox.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    // toggle between attribute icons and descriptions
                    toggleAttributeDisplay(attributeBox, attributeBoxMaxWidth);
                }
            });

            // icons or text?
            //
            // also show icons when noAttributeImagesFound == true. Explanation:
            //  1. no icons could be found in the first invocation of this method
            //  2. user refreshes cache from web
            //  3. now this method is called again
            //  4. attributeShowAsIcons is false but noAttributeImagesFound is true
            //     => try to show them now
            if (attributesShowAsIcons || noAttributeIconsFound) {
                showAttributeIcons(attributeBox, attributeBoxMaxWidth);
            } else {
                showAttributeDescriptions(attributeBox);
            }
        }

        /**
         * lazy-creates the layout holding the icons of the caches attributes
         * and makes it visible
         */
        private void showAttributeIcons(LinearLayout attribBox, int parentWidth) {
            if (attributeIconsLayout == null) {
                attributeIconsLayout = createAttributeIconsLayout(parentWidth);
                // no matching icons found? show text
                if (noAttributeIconsFound) {
                    showAttributeDescriptions(attribBox);
                    return;
                }
            }
            attribBox.removeAllViews();
            attribBox.addView(attributeIconsLayout);
            attributesShowAsIcons = true;
        }

        /**
         * lazy-creates the layout holding the descriptions of the caches attributes
         * and makes it visible
         */
        private void showAttributeDescriptions(LinearLayout attribBox) {
            if (attributeDescriptionsLayout == null) {
                attributeDescriptionsLayout = createAttributeDescriptionsLayout();
            }
            attribBox.removeAllViews();
            attribBox.addView(attributeDescriptionsLayout);
            attributesShowAsIcons = false;
        }

        /**
         * toggle attribute descriptions and icons
         */
        private void toggleAttributeDisplay(LinearLayout attribBox, int parentWidth) {
            // Don't toggle when there are no icons to show.
            if (noAttributeIconsFound) {
                return;
            }

            // toggle
            if (attributesShowAsIcons) {
                showAttributeDescriptions(attribBox);
            } else {
                showAttributeIcons(attribBox, parentWidth);
            }
        }

        private ViewGroup createAttributeIconsLayout(int parentWidth) {
            final LinearLayout rows = new LinearLayout(CacheDetailActivity.this);
            rows.setLayoutParams(new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT));
            rows.setOrientation(LinearLayout.VERTICAL);

            LinearLayout attributeRow = newAttributeIconsRow();
            rows.addView(attributeRow);

            noAttributeIconsFound = true;

            for (String attributeName : cache.getAttributes()) {
                // check if another attribute icon fits in this row
                attributeRow.measure(0, 0);
                int rowWidth = attributeRow.getMeasuredWidth();
                FrameLayout fl = (FrameLayout) getLayoutInflater().inflate(R.layout.attribute_image, null);
                ImageView iv = (ImageView) fl.getChildAt(0);
                if ((parentWidth - rowWidth) < iv.getLayoutParams().width) {
                    // make a new row
                    attributeRow = newAttributeIconsRow();
                    rows.addView(attributeRow);
                }

                final boolean strikethru = !CacheAttribute.isEnabled(attributeName);
                final CacheAttribute attrib = CacheAttribute.getByGcRawName(CacheAttribute.trimAttributeName(attributeName));
                if (attrib != CacheAttribute.UNKNOWN) {
                    noAttributeIconsFound = false;
                    Drawable d = res.getDrawable(attrib.drawableId);
                    iv.setImageDrawable(d);
                    // strike through?
                    if (strikethru) {
                        // generate strikethru image with same properties as attribute image
                        ImageView strikethruImage = new ImageView(CacheDetailActivity.this);
                        strikethruImage.setLayoutParams(iv.getLayoutParams());
                        d = res.getDrawable(R.drawable.attribute__strikethru);
                        strikethruImage.setImageDrawable(d);
                        fl.addView(strikethruImage);
                    }
                } else {
                    Drawable d = res.getDrawable(R.drawable.attribute_icon_not_found);
                    iv.setImageDrawable(d);
                }

                attributeRow.addView(fl);
            }

            return rows;
        }

        private LinearLayout newAttributeIconsRow() {
            LinearLayout rowLayout = new LinearLayout(CacheDetailActivity.this);
            rowLayout.setLayoutParams(new LayoutParams(LayoutParams.MATCH_PARENT,
                    LayoutParams.WRAP_CONTENT));
            rowLayout.setOrientation(LinearLayout.HORIZONTAL);
            return rowLayout;
        }

        private ViewGroup createAttributeDescriptionsLayout() {
            final LinearLayout descriptions = (LinearLayout) getLayoutInflater().inflate(
                    R.layout.attribute_descriptions, null);
            final TextView attribView = (TextView) descriptions.getChildAt(0);

            final StringBuilder buffer = new StringBuilder();
            for (String attributeName : cache.getAttributes()) {
                final boolean enabled = CacheAttribute.isEnabled(attributeName);
                // search for a translation of the attribute
                CacheAttribute attrib = CacheAttribute.getByGcRawName(CacheAttribute.trimAttributeName(attributeName));
                if (attrib != CacheAttribute.UNKNOWN) {
                    attributeName = attrib.getL10n(enabled);
                }
                if (buffer.length() > 0) {
                    buffer.append('\n');
                }
                buffer.append(attributeName);
            }

            attribView.setText(buffer);

            return descriptions;
        }
    }

    /**
     * Creator for details-view.
     */
    private class DetailsViewCreator extends AbstractCachingPageViewCreator<ScrollView> {
        /**
         * Reference to the details list, so that the helper-method can access it without an additional argument
         */
        private LinearLayout detailsList;

        // TODO Do we need this thread-references?
        private StoreCacheThread storeThread;
        private RefreshCacheThread refreshThread;
        private Thread watchlistThread;

        @Override
        public ScrollView getDispatchedView() {
            if (cache == null) {
                // something is really wrong
                return null;
            }

            view = (ScrollView) getLayoutInflater().inflate(R.layout.cacheview_details, null);

            // Start loading preview map
            if (Settings.isStoreOfflineMaps()) {
                new PreviewMapTask().execute((Void) null);
            }

            detailsList = (LinearLayout) view.findViewById(R.id.details_list);
            final CacheDetailsCreator details = new CacheDetailsCreator(CacheDetailActivity.this, detailsList);

            // cache name (full name)
            Spannable span = (new Spannable.Factory()).newSpannable(Html.fromHtml(cache.getName()).toString());
            if (cache.isDisabled() || cache.isArchived()) { // strike
                span.setSpan(new StrikethroughSpan(), 0, span.toString().length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
            }
            if (cache.isArchived()) {
                span.setSpan(new ForegroundColorSpan(res.getColor(R.color.archived_cache_color)), 0, span.toString().length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
            }

            details.add(R.string.cache_name, span);
            details.add(R.string.cache_type, cache.getType().getL10n());
            details.addSize(cache);
            details.add(R.string.cache_geocode, cache.getGeocode());
            details.addCacheState(cache);

            details.addDistance(cache, cacheDistanceView);
            cacheDistanceView = details.getValueView();

            details.addDifficulty(cache);
            details.addTerrain(cache);
            details.addRating(cache);

            // favorite count
            if (cache.getFavoritePoints() > 0) {
                details.add(R.string.cache_favourite, cache.getFavoritePoints() + "");
            }

            // own rating
            if (cache.getMyVote() > 0) {
                details.addStars(R.string.cache_own_rating, cache.getMyVote());
            }

            // cache author
            if (StringUtils.isNotBlank(cache.getOwnerDisplayName()) || StringUtils.isNotBlank(cache.getOwnerUserId())) {
                TextView ownerView = details.add(R.string.cache_owner, "");
                if (StringUtils.isNotBlank(cache.getOwnerDisplayName())) {
                    ownerView.setText(cache.getOwnerDisplayName(), TextView.BufferType.SPANNABLE);
                } else { // OwnerReal guaranteed to be not blank based on above
                    ownerView.setText(cache.getOwnerUserId(), TextView.BufferType.SPANNABLE);
                }
                ownerView.setOnClickListener(new OwnerActionsClickListener());
            }

            // cache hidden
            if (cache.getHiddenDate() != null) {
                long time = cache.getHiddenDate().getTime();
                if (time > 0) {
                    String dateString = Formatter.formatFullDate(time);
                    if (cache.isEventCache()) {
                        dateString = DateUtils.formatDateTime(cgeoapplication.getInstance().getBaseContext(), time, DateUtils.FORMAT_SHOW_WEEKDAY) + ", " + dateString;
                    }
                    details.add(cache.isEventCache() ? R.string.cache_event : R.string.cache_hidden, dateString);
                }
            }

            // cache location
            if (StringUtils.isNotBlank(cache.getLocation())) {
                details.add(R.string.cache_location, cache.getLocation());
            }

            // cache coordinates
            if (cache.getCoords() != null) {
                TextView valueView = details.add(R.string.cache_coordinates, cache.getCoords().toString());
                valueView.setOnClickListener(new View.OnClickListener() {
                    private int position = 0;
                    private GeopointFormatter.Format[] availableFormats = new GeopointFormatter.Format[] {
                            GeopointFormatter.Format.LAT_LON_DECMINUTE,
                            GeopointFormatter.Format.LAT_LON_DECSECOND,
                            GeopointFormatter.Format.LAT_LON_DECDEGREE
                    };

                    // rotate coordinate formats on click
                    @Override
                    public void onClick(View view) {
                        position = (position + 1) % availableFormats.length;

                        final TextView valueView = (TextView) view.findViewById(R.id.value);
                        valueView.setText(cache.getCoords().format(availableFormats[position]));
                    }
                });
                registerForContextMenu(valueView);
            }

            // cache attributes
            if (cache.getAttributes().isNotEmpty()) {
                new AttributeViewBuilder().fillView((LinearLayout) view.findViewById(R.id.attributes_innerbox));
                view.findViewById(R.id.attributes_box).setVisibility(View.VISIBLE);
            }

            updateOfflineBox();

            // watchlist
            Button buttonWatchlistAdd = (Button) view.findViewById(R.id.add_to_watchlist);
            Button buttonWatchlistRemove = (Button) view.findViewById(R.id.remove_from_watchlist);
            buttonWatchlistAdd.setOnClickListener(new AddToWatchlistClickListener());
            buttonWatchlistRemove.setOnClickListener(new RemoveFromWatchlistClickListener());
            updateWatchlistBox();

            // favorite points
            Button buttonFavPointAdd = (Button) view.findViewById(R.id.add_to_favpoint);
            Button buttonFavPointRemove = (Button) view.findViewById(R.id.remove_from_favpoint);
            buttonFavPointAdd.setOnClickListener(new FavoriteAddClickListener());
            buttonFavPointRemove.setOnClickListener(new FavoriteRemoveClickListener());
            updateFavPointBox();

            // data license
            IConnector connector = ConnectorFactory.getConnector(cache);
            if (connector != null) {
                String license = connector.getLicenseText(cache);
                if (StringUtils.isNotBlank(license)) {
                    view.findViewById(R.id.license_box).setVisibility(View.VISIBLE);
                    TextView licenseView = ((TextView) view.findViewById(R.id.license));
                    licenseView.setText(Html.fromHtml(license), BufferType.SPANNABLE);
                    licenseView.setClickable(true);
                    licenseView.setMovementMethod(LinkMovementMethod.getInstance());
                } else {
                    view.findViewById(R.id.license_box).setVisibility(View.GONE);
                }
            }

            return view;
        }

        private class StoreCacheHandler extends CancellableHandler {
            @Override
            public void handleRegularMessage(Message msg) {
                if (UPDATE_LOAD_PROGRESS_DETAIL == msg.what && msg.obj instanceof String) {
                    updateStatusMsg((String) msg.obj);
                } else {
                    storeThread = null;
                    CacheDetailActivity.this.notifyDataSetChanged(); // reload cache details
                }
            }

            private void updateStatusMsg(final String msg) {
                progress.setMessage(res.getString(R.string.cache_dialog_offline_save_message)
                        + "\n\n"
                        + msg);
            }
        }

        private class RefreshCacheHandler extends CancellableHandler {
            @Override
            public void handleRegularMessage(Message msg) {
                if (UPDATE_LOAD_PROGRESS_DETAIL == msg.what && msg.obj instanceof String) {
                    updateStatusMsg((String) msg.obj);
                } else {
                    refreshThread = null;
                    CacheDetailActivity.this.notifyDataSetChanged(); // reload cache details
                }
            }

            private void updateStatusMsg(final String msg) {
                progress.setMessage(res.getString(R.string.cache_dialog_refresh_message)
                        + "\n\n"
                        + msg);
            }
        }

        private class DropCacheHandler extends Handler {
            @Override
            public void handleMessage(Message msg) {
                CacheDetailActivity.this.notifyDataSetChanged();
            }
        }

        private class StoreCacheClickListener implements View.OnClickListener {
            @Override
            public void onClick(View arg0) {
                if (progress.isShowing()) {
                    showToast(res.getString(R.string.err_detail_still_working));
                    return;
                }

                final StoreCacheHandler storeCacheHandler = new StoreCacheHandler();

                progress.show(CacheDetailActivity.this, res.getString(R.string.cache_dialog_offline_save_title), res.getString(R.string.cache_dialog_offline_save_message), true, storeCacheHandler.cancelMessage());

                if (storeThread != null) {
                    storeThread.interrupt();
                }

                storeThread = new StoreCacheThread(storeCacheHandler);
                storeThread.start();
            }
        }

        private class RefreshCacheClickListener implements View.OnClickListener {
            @Override
            public void onClick(View arg0) {
                if (progress.isShowing()) {
                    showToast(res.getString(R.string.err_detail_still_working));
                    return;
                }

                final RefreshCacheHandler refreshCacheHandler = new RefreshCacheHandler();

                progress.show(CacheDetailActivity.this, res.getString(R.string.cache_dialog_refresh_title), res.getString(R.string.cache_dialog_refresh_message), true, refreshCacheHandler.cancelMessage());

                if (refreshThread != null) {
                    refreshThread.interrupt();
                }

                refreshThread = new RefreshCacheThread(refreshCacheHandler);
                refreshThread.start();
            }
        }

        private class StoreCacheThread extends Thread {
            final private CancellableHandler handler;

            public StoreCacheThread(final CancellableHandler handler) {
                this.handler = handler;
            }

            @Override
            public void run() {
                cache.store(handler);
            }
        }

        private class RefreshCacheThread extends Thread {
            final private CancellableHandler handler;

            public RefreshCacheThread(final CancellableHandler handler) {
                this.handler = handler;
            }

            @Override
            public void run() {
                cache.refresh(cache.getListId(), handler);

                handler.sendEmptyMessage(0);
            }
        }

        private class DropCacheClickListener implements View.OnClickListener {
            @Override
            public void onClick(View arg0) {
                if (progress.isShowing()) {
                    showToast(res.getString(R.string.err_detail_still_working));
                    return;
                }

                final DropCacheHandler dropCacheHandler = new DropCacheHandler();

                progress.show(CacheDetailActivity.this, res.getString(R.string.cache_dialog_offline_drop_title), res.getString(R.string.cache_dialog_offline_drop_message), true, null);
                new DropCacheThread(dropCacheHandler).start();
            }
        }

        private class DropCacheThread extends Thread {

            private Handler handler = null;

            public DropCacheThread(Handler handlerIn) {
                handler = handlerIn;
            }

            @Override
            public void run() {
                cache.drop(handler);
            }
        }

        /**
         * Abstract Listener for add / remove buttons for watchlist
         */
        private abstract class AbstractWatchlistClickListener implements View.OnClickListener {
            public void doExecute(int titleId, int messageId, Thread thread) {
                if (progress.isShowing()) {
                    showToast(res.getString(R.string.err_watchlist_still_managing));
                    return;
                }
                progress.show(CacheDetailActivity.this, res.getString(titleId), res.getString(messageId), true, null);

                if (watchlistThread != null) {
                    watchlistThread.interrupt();
                }

                watchlistThread = thread;
                watchlistThread.start();
            }
        }

        /**
         * Listener for "add to watchlist" button
         */
        private class AddToWatchlistClickListener extends AbstractWatchlistClickListener {
            @Override
            public void onClick(View arg0) {
                doExecute(R.string.cache_dialog_watchlist_add_title,
                        R.string.cache_dialog_watchlist_add_message,
                        new WatchlistAddThread(new WatchlistHandler()));
            }
        }

        /**
         * Listener for "remove from watchlist" button
         */
        private class RemoveFromWatchlistClickListener extends AbstractWatchlistClickListener {
            @Override
            public void onClick(View arg0) {
                doExecute(R.string.cache_dialog_watchlist_remove_title,
                        R.string.cache_dialog_watchlist_remove_message,
                        new WatchlistRemoveThread(new WatchlistHandler()));
            }
        }

        /** Thread to add this cache to the watchlist of the user */
        private class WatchlistAddThread extends Thread {
            private final Handler handler;

            public WatchlistAddThread(Handler handler) {
                this.handler = handler;
            }

            @Override
            public void run() {
                handler.sendEmptyMessage(GCConnector.addToWatchlist(cache) ? 1 : -1);
            }
        }

        /** Thread to remove this cache from the watchlist of the user */
        private class WatchlistRemoveThread extends Thread {
            private final Handler handler;

            public WatchlistRemoveThread(Handler handler) {
                this.handler = handler;
            }

            @Override
            public void run() {
                handler.sendEmptyMessage(GCConnector.removeFromWatchlist(cache) ? 1 : -1);
            }
        }

        /** Thread to add this cache to the favourite list of the user */
        private class FavoriteAddThread extends Thread {
            private final Handler handler;

            public FavoriteAddThread(Handler handler) {
                this.handler = handler;
            }

            @Override
            public void run() {
                handler.sendEmptyMessage(GCConnector.addToFavorites(cache) ? 1 : -1);
            }
        }

        /** Thread to remove this cache to the favourite list of the user */
        private class FavoriteRemoveThread extends Thread {
            private final Handler handler;

            public FavoriteRemoveThread(Handler handler) {
                this.handler = handler;
            }

            @Override
            public void run() {
                handler.sendEmptyMessage(GCConnector.removeFromFavorites(cache) ? 1 : -1);
            }
        }

        private class FavoriteUpdateHandler extends Handler {
            @Override
            public void handleMessage(Message msg) {
                progress.dismiss();
                if (msg.what == -1) {
                    showToast(res.getString(R.string.err_favorite_failed));
                } else {
                    CacheDetailActivity.this.notifyDataSetChanged(); // reload cache details
                }
            }
        }

        /**
         * Listener for "add to favourites" button
         */
        private class FavoriteAddClickListener extends AbstractWatchlistClickListener {
            @Override
            public void onClick(View arg0) {
                doExecute(R.string.cache_dialog_favourite_add_title,
                        R.string.cache_dialog_favourite_add_message,
                        new FavoriteAddThread(new FavoriteUpdateHandler()));
            }
        }

        /**
         * Listener for "remove from favourites" button
         */
        private class FavoriteRemoveClickListener extends AbstractWatchlistClickListener {
            @Override
            public void onClick(View arg0) {
                doExecute(R.string.cache_dialog_favourite_remove_title,
                        R.string.cache_dialog_favourite_remove_message,
                        new FavoriteRemoveThread(new FavoriteUpdateHandler()));
            }
        }

        /**
         * shows/hides buttons, sets text in watchlist box
         */
        private void updateWatchlistBox() {
            LinearLayout layout = (LinearLayout) view.findViewById(R.id.watchlist_box);
            boolean supportsWatchList = cache.supportsWatchList();
            layout.setVisibility(supportsWatchList ? View.VISIBLE : View.GONE);
            if (!supportsWatchList) {
                return;
            }
            Button buttonAdd = (Button) view.findViewById(R.id.add_to_watchlist);
            Button buttonRemove = (Button) view.findViewById(R.id.remove_from_watchlist);
            TextView text = (TextView) view.findViewById(R.id.watchlist_text);

            if (cache.isOnWatchlist() || cache.isOwn()) {
                buttonAdd.setVisibility(View.GONE);
                buttonRemove.setVisibility(View.VISIBLE);
                text.setText(R.string.cache_watchlist_on);
            } else {
                buttonAdd.setVisibility(View.VISIBLE);
                buttonRemove.setVisibility(View.GONE);
                text.setText(R.string.cache_watchlist_not_on);
            }

            // the owner of a cache has it always on his watchlist. Adding causes an error
            if (cache.isOwn()) {
                buttonAdd.setEnabled(false);
                buttonAdd.setVisibility(View.GONE);
                buttonRemove.setEnabled(false);
                buttonRemove.setVisibility(View.GONE);
            }

        }

        /**
         * shows/hides buttons, sets text in watchlist box
         */
        private void updateFavPointBox() {
            LinearLayout layout = (LinearLayout) view.findViewById(R.id.favpoint_box);
            boolean supportsFavoritePoints = cache.supportsFavoritePoints();
            layout.setVisibility(supportsFavoritePoints ? View.VISIBLE : View.GONE);
            if (!supportsFavoritePoints || cache.isOwn() || !Settings.isPremiumMember()) {
                return;
            }
            Button buttonAdd = (Button) view.findViewById(R.id.add_to_favpoint);
            Button buttonRemove = (Button) view.findViewById(R.id.remove_from_favpoint);
            TextView text = (TextView) view.findViewById(R.id.favpoint_text);

            if (cache.isFavorite()) {
                buttonAdd.setVisibility(View.GONE);
                buttonRemove.setVisibility(View.VISIBLE);
                text.setText(R.string.cache_favpoint_on);
            } else {
                buttonAdd.setVisibility(View.VISIBLE);
                buttonRemove.setVisibility(View.GONE);
                text.setText(R.string.cache_favpoint_not_on);
            }

            // Add/remove to Favorites is only possible if the cache has been found
            if (!cache.isFound()) {
                buttonAdd.setEnabled(false);
                buttonAdd.setVisibility(View.GONE);
                buttonRemove.setEnabled(false);
                buttonRemove.setVisibility(View.GONE);
            }
        }

        /**
         * Handler, called when watchlist add or remove is done
         */
        private class WatchlistHandler extends Handler {
            @Override
            public void handleMessage(Message msg) {
                watchlistThread = null;
                progress.dismiss();
                if (msg.what == -1) {
                    showToast(res.getString(R.string.err_watchlist_failed));
                } else {
                    CacheDetailActivity.this.notifyDataSetChanged(); // reload cache details
                }
            }
        }

        private void updateOfflineBox() {
            // offline use
            final TextView offlineText = (TextView) view.findViewById(R.id.offline_text);
            final Button offlineRefresh = (Button) view.findViewById(R.id.offline_refresh);
            final Button offlineStore = (Button) view.findViewById(R.id.offline_store);

            if (cache.isOffline()) {
                long diff = (System.currentTimeMillis() / (60 * 1000)) - (cache.getDetailedUpdate() / (60 * 1000)); // minutes

                String ago;
                if (diff < 15) {
                    ago = res.getString(R.string.cache_offline_time_mins_few);
                } else if (diff < 50) {
                    ago = res.getString(R.string.cache_offline_time_about) + " " + diff + " " + res.getString(R.string.cache_offline_time_mins);
                } else if (diff < 90) {
                    ago = res.getString(R.string.cache_offline_time_about) + " " + res.getString(R.string.cache_offline_time_hour);
                } else if (diff < (48 * 60)) {
                    ago = res.getString(R.string.cache_offline_time_about) + " " + (diff / 60) + " " + res.getString(R.string.cache_offline_time_hours);
                } else {
                    ago = res.getString(R.string.cache_offline_time_about) + " " + (diff / (24 * 60)) + " " + res.getString(R.string.cache_offline_time_days);
                }

                offlineText.setText(res.getString(R.string.cache_offline_stored) + "\n" + ago);
                offlineRefresh.setOnClickListener(new RefreshCacheClickListener());

                offlineStore.setText(res.getString(R.string.cache_offline_drop));
                offlineStore.setClickable(true);
                offlineStore.setOnClickListener(new DropCacheClickListener());
            } else {
                offlineText.setText(res.getString(R.string.cache_offline_not_ready));
                offlineRefresh.setOnClickListener(new RefreshCacheClickListener());

                offlineStore.setText(res.getString(R.string.cache_offline_store));
                offlineStore.setClickable(true);
                offlineStore.setOnClickListener(new StoreCacheClickListener());
            }
            offlineRefresh.setVisibility(cache.supportsRefresh() ? View.VISIBLE : View.GONE);
            offlineRefresh.setClickable(true);
        }

        private class PreviewMapTask extends AsyncTask<Void, Void, BitmapDrawable> {
            @Override
            protected BitmapDrawable doInBackground(Void... parameters) {
                try {
                    // persistent preview from storage
                    Bitmap image = decode(cache);

                    if (image == null) {
                        StaticMapsProvider.storeCachePreviewMap(cache);
                        image = decode(cache);
                        if (image == null) {
                            return null;
                        }
                    }

                    return ImageHelper.scaleBitmapToFitDisplay(image);
                } catch (Exception e) {
                    Log.w("CacheDetailActivity.PreviewMapTask", e);
                    return null;
                }
            }

            private Bitmap decode(final cgCache cache) {
                return StaticMapsProvider.getPreviewMap(cache.getGeocode());
            }

            @Override
            protected void onPostExecute(BitmapDrawable image) {
                if (image == null) {
                    return;
                }

                try {
                    final Bitmap bitmap = image.getBitmap();
                    if (bitmap == null || bitmap.getWidth() <= 10) {
                        return;
                    }

                    ((ImageView) view.findViewById(R.id.map_preview)).setImageDrawable(image);
                    view.findViewById(R.id.map_preview_box).setVisibility(View.VISIBLE);
                } catch (Exception e) {
                    Log.e("CacheDetailActivity.PreviewMapTask", e);
                }
            }
        }

    }

    private class DescriptionViewCreator extends AbstractCachingPageViewCreator<ScrollView> {

        @Override
        public ScrollView getDispatchedView() {
            if (cache == null) {
                // something is really wrong
                return null;
            }

            view = (ScrollView) getLayoutInflater().inflate(R.layout.cacheview_description, null);

            // cache short description
            if (StringUtils.isNotBlank(cache.getShortDescription())) {
                new LoadDescriptionTask().execute(cache.getShortDescription(), view.findViewById(R.id.shortdesc), null);
                registerForContextMenu(view.findViewById(R.id.shortdesc));
            }

            // long description
            if (StringUtils.isNotBlank(cache.getDescription())) {
                if (Settings.isAutoLoadDescription()) {
                    loadLongDescription();
                } else {
                    Button showDesc = (Button) view.findViewById(R.id.show_description);
                    showDesc.setVisibility(View.VISIBLE);
                    showDesc.setOnClickListener(new View.OnClickListener() {
                        @Override
                        public void onClick(View arg0) {
                            loadLongDescription();
                        }
                    });
                }
            }

            // cache personal note
            final TextView personalNoteView = (TextView) view.findViewById(R.id.personalnote);
            setPersonalNote(personalNoteView);
            personalNoteView.setMovementMethod(LinkMovementMethod.getInstance());
            registerForContextMenu(personalNoteView);
            final Button personalNoteEdit = (Button) view.findViewById(R.id.edit_personalnote);
            if (cache.isOffline()) {
                personalNoteEdit.setVisibility(View.VISIBLE);
                personalNoteEdit.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(View v) {
                        EditorDialog editor = new EditorDialog(CacheDetailActivity.this, personalNoteView.getText());
                        editor.setOnEditorUpdate(new EditorDialog.EditorUpdate() {
                            @Override
                            public void update(CharSequence editorText) {
                                cache.setPersonalNote(editorText.toString());
                                setPersonalNote(personalNoteView);
                                cgData.saveCache(cache, EnumSet.of(SaveFlag.SAVE_DB));
                            }
                        });
                        editor.show();
                    }
                });
            } else {
                personalNoteEdit.setVisibility(View.INVISIBLE);
            }

            // cache hint and spoiler images
            final View hintBoxView = view.findViewById(R.id.hint_box);
            if (StringUtils.isNotBlank(cache.getHint()) || CollectionUtils.isNotEmpty(cache.getSpoilers())) {
                hintBoxView.setVisibility(View.VISIBLE);
            } else {
                hintBoxView.setVisibility(View.GONE);
            }

            final TextView hintView = ((TextView) view.findViewById(R.id.hint));
            if (StringUtils.isNotBlank(cache.getHint())) {
                if (BaseUtils.containsHtml(cache.getHint())) {
                    hintView.setText(Html.fromHtml(cache.getHint(), new HtmlImage(cache.getGeocode(), false, cache.getListId(), false), null), TextView.BufferType.SPANNABLE);
                    hintView.setText(CryptUtils.rot13((Spannable) hintView.getText()));
                }
                else {
                    hintView.setText(CryptUtils.rot13(cache.getHint()));
                }
                hintView.setVisibility(View.VISIBLE);
                hintView.setClickable(true);
                hintView.setOnClickListener(new DecryptTextClickListener());
                registerForContextMenu(hintView);
            } else {
                hintView.setVisibility(View.GONE);
                hintView.setClickable(false);
                hintView.setOnClickListener(null);
            }

            final TextView spoilerlinkView = ((TextView) view.findViewById(R.id.hint_spoilerlink));
            if (CollectionUtils.isNotEmpty(cache.getSpoilers())) {
                spoilerlinkView.setVisibility(View.VISIBLE);
                spoilerlinkView.setClickable(true);
                spoilerlinkView.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(View arg0) {
                        if (cache == null || CollectionUtils.isEmpty(cache.getSpoilers())) {
                            showToast(res.getString(R.string.err_detail_no_spoiler));
                            return;
                        }

                        ImagesActivity.startActivitySpoilerImages(CacheDetailActivity.this, cache.getGeocode(), cache.getSpoilers());
                    }
                });
            } else {
                spoilerlinkView.setVisibility(View.GONE);
                spoilerlinkView.setClickable(true);
                spoilerlinkView.setOnClickListener(null);
            }

            return view;
        }

        private void setPersonalNote(final TextView personalNoteView) {
            final String personalNote = cache.getPersonalNote();
            personalNoteView.setText(personalNote, TextView.BufferType.SPANNABLE);
            if (StringUtils.isNotBlank(personalNote)) {
                personalNoteView.setVisibility(View.VISIBLE);
            }
            else {
                personalNoteView.setVisibility(View.GONE);
            }
        }

        private void loadLongDescription() {
            Button showDesc = (Button) view.findViewById(R.id.show_description);
            showDesc.setVisibility(View.GONE);
            showDesc.setOnClickListener(null);
            view.findViewById(R.id.loading).setVisibility(View.VISIBLE);

            new LoadDescriptionTask().execute(cache.getDescription(), view.findViewById(R.id.longdesc), view.findViewById(R.id.loading));
            registerForContextMenu(view.findViewById(R.id.longdesc));
        }

    }

    /**
     * Loads the description in background. <br />
     * <br />
     * Params:
     * <ol>
     * <li>description string (String)</li>
     * <li>target description view (TextView)</li>
     * <li>loading indicator view (View, may be null)</li>
     * </ol>
     */
    private class LoadDescriptionTask extends AsyncTask<Object, Void, Void> {
        private View loadingIndicatorView;
        private TextView descriptionView;
        private String descriptionString;
        private Spanned description;

        private class HtmlImageCounter implements Html.ImageGetter {

            private int imageCount = 0;

            @Override
            public Drawable getDrawable(String url) {
                imageCount++;
                return null;
            }

            public int getImageCount() {
                return imageCount;
            }
        }

        @Override
        protected Void doInBackground(Object... params) {
            try {
                descriptionString = ((String) params[0]);
                descriptionView = (TextView) params[1];
                loadingIndicatorView = (View) params[2];

                // Fast preview: parse only HTML without loading any images
                HtmlImageCounter imageCounter = new HtmlImageCounter();
                final UnknownTagsHandler unknownTagsHandler = new UnknownTagsHandler();
                description = Html.fromHtml(descriptionString, imageCounter, unknownTagsHandler);
                publishProgress();
                if (imageCounter.getImageCount() > 0) {
                    // Complete view: parse again with loading images - if necessary ! If there are any images causing problems the user can see at least the preview
                    description = Html.fromHtml(descriptionString, new HtmlImage(cache.getGeocode(), true, cache.getListId(), false), unknownTagsHandler);
                    publishProgress();
                }

                // If description has an HTML construct which may be problematic to render, add a note at the end of the long description.
                // Technically, it may not be a table, but a pre, which has the same problems as a table, so the message is ok even though
                // sometimes technically incorrect.
                if (unknownTagsHandler.isProblematicDetected() && descriptionView != null) {
                    final int startPos = description.length();
                    ((Editable) description).append("\n\n").append(res.getString(R.string.cache_description_table_note));
                    ((Editable) description).setSpan(new StyleSpan(Typeface.ITALIC), startPos, description.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
                    publishProgress();
                }
            } catch (Exception e) {
                Log.e("LoadDescriptionTask: ", e);
            }
            return null;
        }

        /*
         * (non-Javadoc)
         *
         * @see android.os.AsyncTask#onProgressUpdate(Progress[])
         */
        @Override
        protected void onProgressUpdate(Void... values) {
            if (description != null) {
                if (StringUtils.isNotBlank(descriptionString)) {
                    descriptionView.setText(description, TextView.BufferType.SPANNABLE);
                    descriptionView.setMovementMethod(LinkMovementMethod.getInstance());
                    fixBlackTextColor(descriptionView, descriptionString);
                }

                descriptionView.setVisibility(View.VISIBLE);
            } else {
                showToast(res.getString(R.string.err_load_descr_failed));
            }

            if (null != loadingIndicatorView) {
                loadingIndicatorView.setVisibility(View.GONE);
            }
        }

        /**
         * handle caches with black font color
         *
         * @param view
         * @param text
         */
        private void fixBlackTextColor(final TextView view, final String text) {
            if (Settings.isLightSkin()) {
                return;
            }
            int backcolor = color.black;
            if (-1 != StringUtils.indexOfAny(text, new String[] { "color=\"black", "color=\"#000080\"" })) {
                backcolor = color.darker_gray;
            }
            else {
                MatcherWrapper matcher = new MatcherWrapper(DARK_COLOR_PATTERN, text);
                if (matcher.find()) {
                    backcolor = color.darker_gray;
                }
            }
            view.setBackgroundResource(backcolor);
        }
    }

    private class LogsViewCreator extends AbstractCachingPageViewCreator<ListView> {
        private final boolean allLogs;

        LogsViewCreator(boolean allLogs) {
            this.allLogs = allLogs;
        }

        @Override
        public ListView getDispatchedView() {
            if (cache == null) {
                // something is really wrong
                return null;
            }

            view = (ListView) getLayoutInflater().inflate(R.layout.cacheview_logs, null);

            // log count
            final Map<LogType, Integer> logCounts = cache.getLogCounts();
            if (logCounts != null) {
                final List<Entry<LogType, Integer>> sortedLogCounts = new ArrayList<Entry<LogType, Integer>>(logCounts.size());
                for (Entry<LogType, Integer> entry : logCounts.entrySet()) {
                    // it may happen that the label is unknown -> then avoid any output for this type
                    if (entry.getKey() != LogType.PUBLISH_LISTING && entry.getKey().getL10n() != null) {
                        sortedLogCounts.add(entry);
                    }
                }

                if (!sortedLogCounts.isEmpty()) {
                    // sort the log counts by type id ascending. that way the FOUND, DNF log types are the first and most visible ones
                    Collections.sort(sortedLogCounts, new Comparator<Entry<LogType, Integer>>() {

                        @Override
                        public int compare(Entry<LogType, Integer> logCountItem1, Entry<LogType, Integer> logCountItem2) {
                            return logCountItem1.getKey().compareTo(logCountItem2.getKey());
                        }
                    });

                    ArrayList<String> labels = new ArrayList<String>(sortedLogCounts.size());
                    for (Entry<LogType, Integer> pair : sortedLogCounts) {
                        labels.add(pair.getValue() + " " + pair.getKey().getL10n());
                    }

                    final TextView countView = new TextView(CacheDetailActivity.this);
                    countView.setText(res.getString(R.string.cache_log_types) + ": " + StringUtils.join(labels, ", "));
                    view.addHeaderView(countView, null, false);
                }
            }

            final List<LogEntry> logs = allLogs ? cache.getLogs().asList() : cache.getFriendsLogs();
            view.setAdapter(new ArrayAdapter<LogEntry>(CacheDetailActivity.this, R.layout.cacheview_logs_item, logs) {
                final UserActionsClickListener userActionsClickListener = new UserActionsClickListener();
                final DecryptTextClickListener decryptTextClickListener = new DecryptTextClickListener();

                @Override
                public View getView(final int position, final View convertView, final ViewGroup parent) {
                    View rowView = convertView;
                    if (null == rowView) {
                        rowView = getLayoutInflater().inflate(R.layout.cacheview_logs_item, null);
                    }
                    LogViewHolder holder = (LogViewHolder) rowView.getTag();
                    if (null == holder) {
                        holder = new LogViewHolder(rowView);
                        rowView.setTag(holder);
                    }

                    final LogEntry log = getItem(position);

                    if (log.date > 0) {
                        holder.date.setText(Formatter.formatShortDate(log.date));
                        holder.date.setVisibility(View.VISIBLE);
                    } else {
                        holder.date.setVisibility(View.GONE);
                    }

                    holder.type.setText(log.type.getL10n());
                    holder.author.setText(StringEscapeUtils.unescapeHtml4(log.author));

                    // finds count
                    holder.count.setVisibility(View.VISIBLE);
                    if (log.found == -1) {
                        holder.count.setVisibility(View.GONE);
                    } else {
                        holder.count.setText(res.getQuantityString(R.plurals.cache_counts, log.found, log.found));
                    }

                    // logtext, avoid parsing HTML if not necessary
                    String logText = log.log;
                    if (BaseUtils.containsHtml(logText)) {
                        logText = log.getDisplayText();
                        holder.text.setText(Html.fromHtml(logText, new HtmlImage(cache.getGeocode(), false, cache.getListId(), false), null), TextView.BufferType.SPANNABLE);
                    }
                    else {
                        holder.text.setText(logText);
                    }

                    // images
                    if (log.hasLogImages()) {
                        holder.images.setText(log.getImageTitles());
                        holder.images.setVisibility(View.VISIBLE);
                        holder.images.setOnClickListener(new View.OnClickListener() {
                            @Override
                            public void onClick(View v) {
                                ImagesActivity.startActivityLogImages(CacheDetailActivity.this, cache.getGeocode(), new ArrayList<Image>(log.getLogImages()));
                            }
                        });
                    } else {
                        holder.images.setVisibility(View.GONE);
                    }

                    // colored marker
                    int marker = log.type.markerId;
                    if (marker != 0) {
                        holder.statusMarker.setVisibility(View.VISIBLE);
                        holder.statusMarker.setImageResource(marker);
                    }
                    else {
                        holder.statusMarker.setVisibility(View.GONE);
                    }

                    if (null == convertView) {
                        // if convertView != null then this listeners are already set
                        holder.author.setOnClickListener(userActionsClickListener);
                        holder.text.setMovementMethod(LinkMovementMethod.getInstance());
                        holder.text.setOnClickListener(decryptTextClickListener);
                        registerForContextMenu(holder.text);
                    }

                    return rowView;
                }
            });

            return view;
        }

        private class LogViewHolder {
            final TextView date;
            final TextView type;
            final TextView author;
            final TextView count;
            final TextView text;
            final TextView images;
            final ImageView statusMarker;

            public LogViewHolder(View base) {
                date = (TextView) base.findViewById(R.id.added);
                type = (TextView) base.findViewById(R.id.type);
                author = (TextView) base.findViewById(R.id.author);
                count = (TextView) base.findViewById(R.id.count);
                text = (TextView) base.findViewById(R.id.log);
                images = (TextView) base.findViewById(R.id.log_images);
                statusMarker = (ImageView) base.findViewById(R.id.log_mark);
            }
        }
    }

    private class WaypointsViewCreator extends AbstractCachingPageViewCreator<ScrollView> {

        @Override
        public ScrollView getDispatchedView() {
            if (cache == null) {
                // something is really wrong
                return null;
            }

            view = (ScrollView) getLayoutInflater().inflate(R.layout.cacheview_waypoints, null);

            final LinearLayout waypoints = (LinearLayout) view.findViewById(R.id.waypoints);

            // sort waypoints: PP, Sx, FI, OWN
            final List<Waypoint> sortedWaypoints = new ArrayList<Waypoint>(cache.getWaypoints());
            Collections.sort(sortedWaypoints);

            for (final Waypoint wpt : sortedWaypoints) {
                final LinearLayout waypointView = (LinearLayout) getLayoutInflater().inflate(R.layout.waypoint_item, null);

                // coordinates
                if (null != wpt.getCoords()) {
                    final TextView coordinatesView = (TextView) waypointView.findViewById(R.id.coordinates);
                    coordinatesView.setText(wpt.getCoords().toString());
                    coordinatesView.setVisibility(View.VISIBLE);
                }

                // info
                final String waypointInfo = Formatter.formatWaypointInfo(wpt);
                if (StringUtils.isNotBlank(waypointInfo)) {
                    final TextView infoView = (TextView) waypointView.findViewById(R.id.info);
                    infoView.setText(waypointInfo);
                    infoView.setVisibility(View.VISIBLE);
                }

                // title
                final TextView nameView = (TextView) waypointView.findViewById(R.id.name);
                if (StringUtils.isNotBlank(wpt.getName())) {
                    nameView.setText(StringEscapeUtils.unescapeHtml4(wpt.getName()));
                } else if (null != wpt.getCoords()) {
                    nameView.setText(wpt.getCoords().toString());
                } else {
                    nameView.setText(res.getString(R.string.waypoint));
                }
                wpt.setIcon(res, nameView);

                // note
                if (StringUtils.isNotBlank(wpt.getNote())) {
                    final TextView noteView = (TextView) waypointView.findViewById(R.id.note);
                    noteView.setVisibility(View.VISIBLE);
                    if (BaseUtils.containsHtml(wpt.getNote())) {
                        noteView.setText(Html.fromHtml(wpt.getNote()), TextView.BufferType.SPANNABLE);
                    }
                    else {
                        noteView.setText(wpt.getNote());
                    }
                }

                final View wpNavView = waypointView.findViewById(R.id.wpDefaultNavigation);
                wpNavView.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(View v) {
                        NavigationAppFactory.startDefaultNavigationApplication(1, CacheDetailActivity.this, wpt);
                    }
                });
                wpNavView.setOnLongClickListener(new View.OnLongClickListener() {
                    @Override
                    public boolean onLongClick(View v) {
                        NavigationAppFactory.startDefaultNavigationApplication(2, CacheDetailActivity.this, wpt);
                        return true;
                    }
                });

                registerForContextMenu(waypointView);
                waypointView.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(View v) {
                        openContextMenu(v);
                    }
                });

                waypoints.addView(waypointView);
            }

            final Button addWaypoint = (Button) view.findViewById(R.id.add_waypoint);
            addWaypoint.setClickable(true);
            addWaypoint.setOnClickListener(new View.OnClickListener() {

                @Override
                public void onClick(View v) {
                    EditWaypointActivity.startActivityAddWaypoint(CacheDetailActivity.this, cache);
                    refreshOnResume = true;
                }
            });

            return view;
        }
    }

    private class InventoryViewCreator extends AbstractCachingPageViewCreator<ListView> {

        @Override
        public ListView getDispatchedView() {
            if (cache == null) {
                // something is really wrong
                return null;
            }

            view = (ListView) getLayoutInflater().inflate(R.layout.cacheview_inventory, null);

            // TODO: fix layout, then switch back to Android-resource and delete copied one
            // this copy is modified to respect the text color
            view.setAdapter(new ArrayAdapter<Trackable>(CacheDetailActivity.this, R.layout.simple_list_item_1, cache.getInventory()));
            view.setOnItemClickListener(new OnItemClickListener() {
                @Override
                public void onItemClick(AdapterView<?> arg0, View arg1, int arg2, long arg3) {
                    Object selection = arg0.getItemAtPosition(arg2);
                    if (selection instanceof Trackable) {
                        Trackable trackable = (Trackable) selection;
                        TrackableActivity.startActivity(CacheDetailActivity.this, trackable.getGuid(), trackable.getGeocode(), trackable.getName());
                    }
                }
            });

            return view;
        }
    }

    private class ImagesViewCreator extends AbstractCachingPageViewCreator<View> {

        @Override
        public View getDispatchedView() {
            if (cache == null) {
                return null; // something is really wrong
            }

            view = getLayoutInflater().inflate(R.layout.caches_images, null);
            if (imagesList == null && isCurrentPage(Page.IMAGES)) {
                loadCacheImages();
            }
            return view;
        }
    }

    public static void startActivity(final Context context, final String geocode, final String cacheName) {
        final Intent cachesIntent = new Intent(context, CacheDetailActivity.class);
        cachesIntent.putExtra("geocode", geocode);
        cachesIntent.putExtra("name", cacheName);
        context.startActivity(cachesIntent);
    }

    public static void startActivityGuid(final Context context, final String guid, final String cacheName) {
        final Intent cacheIntent = new Intent(context, CacheDetailActivity.class);
        cacheIntent.putExtra("guid", guid);
        cacheIntent.putExtra("name", cacheName);
        context.startActivity(cacheIntent);
    }

    /**
     * A dialog to allow the user to select reseting coordinates local/remote/both.
     */
    private class ResetCacheCoordinatesDialog extends AlertDialog {

        final RadioButton resetBoth;
        final RadioButton resetLocal;

        public ResetCacheCoordinatesDialog(final cgCache cache, final Waypoint wpt, final Activity activity) {
            super(activity);

            View layout = activity.getLayoutInflater().inflate(R.layout.reset_cache_coords_dialog, null);
            setView(layout);

            resetLocal = (RadioButton) layout.findViewById(R.id.reset_cache_coordinates_local);
            resetBoth = (RadioButton) layout.findViewById(R.id.reset_cache_coordinates_local_and_remote);

            if (ConnectorFactory.getConnector(cache).supportsOwnCoordinates()) {
                resetBoth.setVisibility(View.VISIBLE);
            }

            layout.findViewById(R.id.reset).setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    dismiss();
                    final ProgressDialog p = ProgressDialog.show(CacheDetailActivity.this, res.getString(R.string.cache), res.getString(R.string.waypoint_reset), true);
                    final Handler h = new Handler() {
                        private boolean remoteFinished = false;
                        private boolean localFinished = false;

                        @Override
                        public void handleMessage(Message msg) {
                            if (msg.what == ResetCoordsThread.LOCAL) {
                                localFinished = true;
                            } else {
                                remoteFinished = true;
                            }

                            if ((localFinished) && (remoteFinished || !resetBoth.isChecked())) {
                                p.dismiss();
                                notifyDataSetChanged();
                            }
                        }

                    };
                    new ResetCoordsThread(cache, h, wpt, resetLocal.isChecked() || resetBoth.isChecked(), resetBoth.isChecked(), p).start();
                }
            });
        }
    }

    private class ResetCoordsThread extends Thread {

        private final cgCache cache;
        private final Handler handler;
        private final boolean local;
        private final boolean remote;
        private final Waypoint wpt;
        private ProgressDialog progress;
        public static final int LOCAL = 0;
        public static final int ON_WEBSITE = 1;

        public ResetCoordsThread(cgCache cache, Handler handler, final Waypoint wpt, boolean local, boolean remote, final ProgressDialog progress) {
            this.cache = cache;
            this.handler = handler;
            this.local = local;
            this.remote = remote;
            this.wpt = wpt;
            this.progress = progress;
        }

        @Override
        public void run() {

            if (local) {
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        progress.setMessage(res.getString(R.string.waypoint_reset_cache_coords));
                    }
                });
                cache.setCoords(wpt.getCoords());
                cache.setUserModifiedCoords(false);
                cache.deleteWaypointForce(wpt);
                cgData.saveChangedCache(cache);
                handler.sendEmptyMessage(LOCAL);
            }

            IConnector con = ConnectorFactory.getConnector(cache);
            if (remote && con.supportsOwnCoordinates()) {
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        progress.setMessage(res.getString(R.string.waypoint_coordinates_being_reset_on_website));
                    }
                });

                final boolean result = con.deleteModifiedCoordinates(cache);

                runOnUiThread(new Runnable() {

                    @Override
                    public void run() {
                        if (result) {
                            showToast(getString(R.string.waypoint_coordinates_has_been_reset_on_website));
                        } else {
                            showToast(getString(R.string.waypoint_coordinates_upload_error));
                        }
                        handler.sendEmptyMessage(ON_WEBSITE);
                        notifyDataSetChanged();
                    }

                });

            }
        }
    }

    @Override
    protected String getTitle(Page page) {
        // show number of waypoints directly in waypoint title
        if (page == Page.WAYPOINTS) {
            final int waypointCount = cache.getWaypoints().size();
            return res.getQuantityString(R.plurals.waypoints, waypointCount, waypointCount);
        }
        return res.getString(page.titleStringId);
    }

    @Override
    protected Pair<List<? extends Page>, Integer> getOrderedPages() {
        final ArrayList<Page> pages = new ArrayList<Page>();
        pages.add(Page.WAYPOINTS);
        pages.add(Page.DETAILS);
        final int detailsIndex = pages.size() - 1;
        pages.add(Page.DESCRIPTION);
        if (cache.getLogs().isNotEmpty()) {
            pages.add(Page.LOGS);
        }
        if (CollectionUtils.isNotEmpty(cache.getFriendsLogs())) {
            pages.add(Page.LOGSFRIENDS);
        }
        if (CollectionUtils.isNotEmpty(cache.getInventory())) {
            pages.add(Page.INVENTORY);
        }
        if (CollectionUtils.isNotEmpty(cache.getImages())) {
            pages.add(Page.IMAGES);
        }
        return new ImmutablePair<List<? extends Page>, Integer>(pages, detailsIndex);
    }

    @Override
    protected AbstractViewPagerActivity.PageViewCreator createViewCreator(Page page) {
        switch (page) {
            case DETAILS:
                return new DetailsViewCreator();

            case DESCRIPTION:
                return new DescriptionViewCreator();

            case LOGS:
                return new LogsViewCreator(true);

            case LOGSFRIENDS:
                return new LogsViewCreator(false);

            case WAYPOINTS:
                return new WaypointsViewCreator();

            case INVENTORY:
                return new InventoryViewCreator();

            case IMAGES:
                return new ImagesViewCreator();

            default:
                throw new IllegalArgumentException();
        }
    }

}
!@#$%
20190527_001041,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_b19984
package cgeo.geocaching.network;

import cgeo.geocaching.Settings;
import cgeo.geocaching.files.LocalStorage;
import cgeo.geocaching.utils.BaseUtils;
import cgeo.geocaching.utils.Log;

import ch.boye.httpclientandroidlib.Header;
import ch.boye.httpclientandroidlib.HeaderElement;
import ch.boye.httpclientandroidlib.HttpEntity;
import ch.boye.httpclientandroidlib.HttpException;
import ch.boye.httpclientandroidlib.HttpRequest;
import ch.boye.httpclientandroidlib.HttpRequestInterceptor;
import ch.boye.httpclientandroidlib.HttpResponse;
import ch.boye.httpclientandroidlib.HttpResponseInterceptor;
import ch.boye.httpclientandroidlib.NameValuePair;
import ch.boye.httpclientandroidlib.ProtocolException;
import ch.boye.httpclientandroidlib.client.HttpClient;
import ch.boye.httpclientandroidlib.client.entity.GzipDecompressingEntity;
import ch.boye.httpclientandroidlib.client.entity.UrlEncodedFormEntity;
import ch.boye.httpclientandroidlib.client.methods.HttpGet;
import ch.boye.httpclientandroidlib.client.methods.HttpPost;
import ch.boye.httpclientandroidlib.client.methods.HttpRequestBase;
import ch.boye.httpclientandroidlib.client.params.ClientPNames;
import ch.boye.httpclientandroidlib.entity.StringEntity;
import ch.boye.httpclientandroidlib.entity.mime.MultipartEntity;
import ch.boye.httpclientandroidlib.entity.mime.content.FileBody;
import ch.boye.httpclientandroidlib.entity.mime.content.StringBody;
import ch.boye.httpclientandroidlib.impl.client.DefaultHttpClient;
import ch.boye.httpclientandroidlib.impl.client.DefaultRedirectStrategy;
import ch.boye.httpclientandroidlib.params.BasicHttpParams;
import ch.boye.httpclientandroidlib.params.CoreConnectionPNames;
import ch.boye.httpclientandroidlib.params.CoreProtocolPNames;
import ch.boye.httpclientandroidlib.params.HttpParams;
import ch.boye.httpclientandroidlib.protocol.HttpContext;
import ch.boye.httpclientandroidlib.util.EntityUtils;

import org.apache.commons.lang3.CharEncoding;
import org.apache.commons.lang3.StringUtils;
import org.json.JSONException;
import org.json.JSONObject;

import android.net.Uri;

import java.io.File;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.net.URLEncoder;

public abstract class Network {

    private static final int NB_DOWNLOAD_RETRIES = 4;

    /** User agent id */
    private final static String PC_USER_AGENT = "Mozilla/5.0 (X11; Linux x86_64; rv:9.0.1) Gecko/20100101 Firefox/9.0.1";
    /** Native user agent, taken from a Android 2.2 Nexus **/
    private final static String NATIVE_USER_AGENT = "Mozilla/5.0 (Linux; U; Android 2.2; en-us; Nexus One Build/FRF91) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1";

    private static final String PATTERN_PASSWORD = "(?<=[\\?&])[Pp]ass(w(or)?d)?=[^&#$]+";

    private final static HttpParams clientParams = new BasicHttpParams();

    static {
        Network.clientParams.setParameter(CoreProtocolPNames.HTTP_CONTENT_CHARSET, CharEncoding.UTF_8);
        Network.clientParams.setParameter(CoreConnectionPNames.CONNECTION_TIMEOUT, 30000);
        Network.clientParams.setParameter(CoreConnectionPNames.SO_TIMEOUT, 30000);
        Network.clientParams.setParameter(ClientPNames.HANDLE_REDIRECTS,  true);
    }

    private static String hidePassword(final String message) {
        return message.replaceAll(Network.PATTERN_PASSWORD, "password=***");
    }

    private static HttpClient getHttpClient() {
        final DefaultHttpClient client = new DefaultHttpClient();
        client.setCookieStore(Cookies.cookieStore);
        client.setParams(clientParams);

        client.setRedirectStrategy(new DefaultRedirectStrategy() {
            @Override
            public boolean isRedirected(HttpRequest request, HttpResponse response, HttpContext context) {
                boolean isRedirect = false;
                try {
                    isRedirect = super.isRedirected(request, response, context);
                } catch (final ProtocolException e) {
                    Log.e("httpclient.isRedirected: unable to check for redirection", e);
                }
                if (!isRedirect) {
                    final int responseCode = response.getStatusLine().getStatusCode();
                    if (responseCode == 301 || responseCode == 302) {
                        return true;
                    }
                }
                return isRedirect;
            }
        });

        client.addRequestInterceptor(new HttpRequestInterceptor() {

            @Override
            public void process(
                    final HttpRequest request,
                    final HttpContext context) throws HttpException, IOException {
                if (!request.containsHeader("Accept-Encoding")) {
                    request.addHeader("Accept-Encoding", "gzip");
                }
            }
        });
        client.addResponseInterceptor(new HttpResponseInterceptor() {

            @Override
            public void process(
                    final HttpResponse response,
                    final HttpContext context) throws HttpException, IOException {
                final HttpEntity entity = response.getEntity();
                if (entity != null) {
                    final Header contentEncoding = entity.getContentEncoding();
                    if (contentEncoding != null) {
                        for (final HeaderElement codec : contentEncoding.getElements()) {
                            if (codec.getName().equalsIgnoreCase("gzip")) {
                                response.setEntity(new GzipDecompressingEntity(response.getEntity()));
                                return;
                            }
                        }
                    }
                }
            }

        });

        return client;
    }

    /**
     * POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @return the HTTP response, or null in case of an encoding error params
     */
    public static HttpResponse postRequest(final String uri, final Parameters params) {
        return request("POST", uri, params, null, null);
    }

    /**
     * POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @params headers the headers to add to the request
     * @return the HTTP response, or null in case of an encoding error params
     */
    public static HttpResponse postRequest(final String uri, final Parameters params, final Parameters headers) {
        return request("POST", uri, params, headers, null);
    }

    /**
     *  POST HTTP request with Json POST DATA
     *
     * @param uri the URI to request
     * @param json the json object to add to the POST request
     * @return the HTTP response, or null in case of an encoding error params
     */
    public static HttpResponse postJsonRequest(final String uri, final JSONObject json) {
        HttpPost request = new HttpPost(uri);
        request.addHeader("Content-Type", "application/json; charset=utf-8");
        if (json != null) {
            try {
                request.setEntity(new StringEntity(json.toString()));
            } catch (UnsupportedEncodingException e) {
                Log.e("postJsonRequest:JSON Entity: UnsupportedEncodingException");
                return null;
            }
        }
        return doRepeatedRequests(request);
    }

    /**
     * Multipart POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @param fileFieldName the name of the file field name
     * @param fileContentType the content-type of the file
     * @param file the file to include in the request
     * @return the HTTP response, or null in case of an encoding error param
     */
    public static HttpResponse postRequest(final String uri, final Parameters params,
                                           final String fileFieldName, final String fileContentType, final File file) {
        final MultipartEntity entity = new MultipartEntity();
        for (final NameValuePair param : params) {
            try {
                entity.addPart(param.getName(), new StringBody(param.getValue()));
            } catch (final UnsupportedEncodingException e) {
                Log.e("Network.postRequest: unsupported encoding for parameter " + param.getName(), e);
                return null;
            }
        }
        entity.addPart(fileFieldName, new FileBody(file, fileContentType));

        final HttpPost request = new HttpPost(uri);
        request.setEntity(entity);

        addHeaders(request, null, null);
        return doRepeatedRequests(request);
    }

    /**
     * Make an HTTP request
     *
     * @param method
     *            the HTTP method to use ("GET" or "POST")
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add to the URI
     * @param headers
     *            the headers to add to the request
     * @param cacheFile
     *            the cache file used to cache this query
     * @return the HTTP response, or null in case of an encoding error in a POST request arguments
     */
    private static HttpResponse request(final String method, final String uri, final Parameters params, final Parameters headers, final File cacheFile) {
        HttpRequestBase request;
        if (method.equals("GET")) {
            final String fullUri = params == null ? uri : Uri.parse(uri).buildUpon().encodedQuery(params.toString()).build().toString();
            request = new HttpGet(fullUri);
        } else {
            request = new HttpPost(uri);
            if (params != null) {
                try {
                    ((HttpPost) request).setEntity(new UrlEncodedFormEntity(params, CharEncoding.UTF_8));
                } catch (final UnsupportedEncodingException e) {
                    Log.e("request", e);
                    return null;
                }
            }
        }

        addHeaders(request, headers, cacheFile);

        return doRepeatedRequests(request);
    }

    /**
     * Add headers to HTTP request.
     * @param request
     *            the request to add headers to
     * @param headers
     *            the headers to add (in addition to the standard headers), can be null
     * @param cacheFile
     *            if non-null, the file to take ETag and If-Modified-Since information from
     */
    private static void addHeaders(final HttpRequestBase request, final Parameters headers, final File cacheFile) {
        for (final NameValuePair header : Parameters.extend(Parameters.merge(headers, cacheHeaders(cacheFile)),
                "Accept-Charset", "utf-8,iso-8859-1;q=0.8,utf-16;q=0.8,*;q=0.7",
                "Accept-Language", "en-US,*;q=0.9",
                "X-Requested-With", "XMLHttpRequest")) {
            request.setHeader(header.getName(), header.getValue());
        }
        request.getParams().setParameter(CoreProtocolPNames.USER_AGENT,
                Settings.getUseNativeUa() ? Network.NATIVE_USER_AGENT : Network.PC_USER_AGENT);
    }

    /**
     * Retry a request for a few times.
     *
     * @param request
     *            the request to try
     * @return
     *            the response, or null if there has been a failure
     */
    private static HttpResponse doRepeatedRequests(final HttpRequestBase request) {
        final String reqLogStr = request.getMethod() + " " + Network.hidePassword(request.getURI().toString());
        Log.d(reqLogStr);

        final HttpClient client = Network.getHttpClient();
        for (int i = 0; i <= Network.NB_DOWNLOAD_RETRIES; i++) {
            final long before = System.currentTimeMillis();
            try {
                final HttpResponse response = client.execute(request);
                int status = response.getStatusLine().getStatusCode();
                if (status == 200) {
                    Log.d(status + Network.formatTimeSpan(before) + reqLogStr);
                } else {
                    Log.w(status + " [" + response.getStatusLine().getReasonPhrase() + "]" + Network.formatTimeSpan(before) + reqLogStr);
                }
                return response;
            } catch (IOException e) {
                final String timeSpan = Network.formatTimeSpan(before);
                final String tries = (i + 1) + "/" + (Network.NB_DOWNLOAD_RETRIES + 1);
                if (i == Network.NB_DOWNLOAD_RETRIES) {
                    Log.e("Failure " + tries + timeSpan + reqLogStr, e);
                } else {
                    Log.e("Failure " + tries + " (" + e.toString() + ")" + timeSpan + "- retrying " + reqLogStr);
                }
            }
        }

        return null;
    }

    private static Parameters cacheHeaders(final File cacheFile) {
        if (cacheFile == null || !cacheFile.exists()) {
            return null;
        }

        final String etag = LocalStorage.getSavedHeader(cacheFile, "etag");
        if (etag != null) {
            return new Parameters("If-None-Match", etag);
        }

        final String lastModified = LocalStorage.getSavedHeader(cacheFile, "last-modified");
        if (lastModified != null) {
            return new Parameters("If-Modified-Since", lastModified);
        }

        return null;
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @param cacheFile
     *            the name of the file storing the cached resource, or null not to use one
     * @return the HTTP response
     */
    public static HttpResponse getRequest(final String uri, final Parameters params, final File cacheFile) {
        return request("GET", uri, params, null, cacheFile);
    }


    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @return the HTTP response
     */
    public static HttpResponse getRequest(final String uri, final Parameters params) {
        return request("GET", uri, params, null, null);
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @param headers
     *            the headers to add to the GET request
     * @return the HTTP response
     */
    public static HttpResponse getRequest(final String uri, final Parameters params, final Parameters headers) {
        return request("GET", uri, params, headers, null);
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @return the HTTP response
     */
    public static HttpResponse getRequest(final String uri) {
        return request("GET", uri, null, null, null);
    }

    private static String formatTimeSpan(final long before) {
        // don't use String.format in a pure logging routine, it has very bad performance
        return " (" + (System.currentTimeMillis() - before) + " ms) ";
    }

    static public boolean isSuccess(final HttpResponse response) {
        return response != null && response.getStatusLine().getStatusCode() == 200;
    }

    public static JSONObject requestJSON(final String uri, final Parameters params) {
        final HttpResponse response = request("GET", uri, params, new Parameters("Accept", "application/json, text/javascript, */*; q=0.01"), null);
        if (isSuccess(response)) {
            try {
                return new JSONObject(Network.getResponseData(response));
            } catch (final JSONException e) {
                Log.e("Network.requestJSON", e);
            }
        }

        return null;
    }

    private static String getResponseDataNoError(final HttpResponse response, boolean replaceWhitespace) {
        try {
            String data = EntityUtils.toString(response.getEntity(), CharEncoding.UTF_8);
            return replaceWhitespace ? BaseUtils.replaceWhitespace(data) : data;
        } catch (Exception e) {
            Log.e("getResponseData", e);
            return null;
        }
    }

    public static String getResponseData(final HttpResponse response) {
        return Network.getResponseData(response, true);
    }

    public static String getResponseData(final HttpResponse response, boolean replaceWhitespace) {
        if (!isSuccess(response)) {
            return null;
        }
        return getResponseDataNoError(response, replaceWhitespace);
    }

    public static String rfc3986URLEncode(String text) {
        return StringUtils.replace(Network.encode(text).replace("+", "%20"), "%7E", "~");
    }

    public static String decode(final String text) {
        try {
            return URLDecoder.decode(text, CharEncoding.UTF_8);
        } catch (UnsupportedEncodingException e) {
            Log.e("Network.decode", e);
        }
        return null;
    }

    public static String encode(final String text) {
        try {
            return URLEncoder.encode(text, CharEncoding.UTF_8);
        } catch (UnsupportedEncodingException e) {
            Log.e("Network.encode", e);
        }
        return null;
    }

}
!@#$%
20190527_001041,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_a19984
package cgeo.geocaching.network;

import cgeo.geocaching.Settings;
import cgeo.geocaching.files.LocalStorage;
import cgeo.geocaching.utils.BaseUtils;
import cgeo.geocaching.utils.Log;

import ch.boye.httpclientandroidlib.Header;
import ch.boye.httpclientandroidlib.HeaderElement;
import ch.boye.httpclientandroidlib.HttpEntity;
import ch.boye.httpclientandroidlib.HttpException;
import ch.boye.httpclientandroidlib.HttpRequest;
import ch.boye.httpclientandroidlib.HttpRequestInterceptor;
import ch.boye.httpclientandroidlib.HttpResponse;
import ch.boye.httpclientandroidlib.HttpResponseInterceptor;
import ch.boye.httpclientandroidlib.NameValuePair;
import ch.boye.httpclientandroidlib.ProtocolException;
import ch.boye.httpclientandroidlib.client.HttpClient;
import ch.boye.httpclientandroidlib.client.entity.GzipDecompressingEntity;
import ch.boye.httpclientandroidlib.client.entity.UrlEncodedFormEntity;
import ch.boye.httpclientandroidlib.client.methods.HttpGet;
import ch.boye.httpclientandroidlib.client.methods.HttpPost;
import ch.boye.httpclientandroidlib.client.methods.HttpRequestBase;
import ch.boye.httpclientandroidlib.client.params.ClientPNames;
import ch.boye.httpclientandroidlib.entity.mime.MultipartEntity;
import ch.boye.httpclientandroidlib.entity.mime.content.FileBody;
import ch.boye.httpclientandroidlib.entity.mime.content.StringBody;
import ch.boye.httpclientandroidlib.impl.client.DefaultHttpClient;
import ch.boye.httpclientandroidlib.impl.client.DefaultRedirectStrategy;
import ch.boye.httpclientandroidlib.params.BasicHttpParams;
import ch.boye.httpclientandroidlib.params.CoreConnectionPNames;
import ch.boye.httpclientandroidlib.params.CoreProtocolPNames;
import ch.boye.httpclientandroidlib.params.HttpParams;
import ch.boye.httpclientandroidlib.protocol.HttpContext;
import ch.boye.httpclientandroidlib.util.EntityUtils;

import org.apache.commons.lang3.StringUtils;
import org.json.JSONException;
import org.json.JSONObject;

import android.net.Uri;

import java.io.File;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;

public abstract class Network {

    private static final int NB_DOWNLOAD_RETRIES = 4;
    /** User agent id */
    private final static String PC_USER_AGENT = "Mozilla/5.0 (X11; Linux x86_64; rv:9.0.1) Gecko/20100101 Firefox/9.0.1";
    /** Native user agent, taken from a Android 2.2 Nexus **/
    private final static String NATIVE_USER_AGENT = "Mozilla/5.0 (Linux; U; Android 2.2; en-us; Nexus One Build/FRF91) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1";

    private static final String PATTERN_PASSWORD = "(?<=[\\?&])[Pp]ass(w(or)?d)?=[^&#$]+";

    private final static HttpParams clientParams = new BasicHttpParams();

    static {
        Network.clientParams.setParameter(CoreProtocolPNames.HTTP_CONTENT_CHARSET, "UTF-8");
        Network.clientParams.setParameter(CoreConnectionPNames.CONNECTION_TIMEOUT, 30000);
        Network.clientParams.setParameter(CoreConnectionPNames.SO_TIMEOUT, 30000);
        Network.clientParams.setParameter(ClientPNames.HANDLE_REDIRECTS,  true);
    }

    private static String hidePassword(final String message) {
        return message.replaceAll(Network.PATTERN_PASSWORD, "password=***");
    }

    private static HttpClient getHttpClient() {
        final DefaultHttpClient client = new DefaultHttpClient();
        client.setCookieStore(Cookies.cookieStore);
        client.setParams(clientParams);

        client.setRedirectStrategy(new DefaultRedirectStrategy() {
            @Override
            public boolean isRedirected(HttpRequest request, HttpResponse response, HttpContext context) {
                boolean isRedirect = false;
                try {
                    isRedirect = super.isRedirected(request, response, context);
                } catch (final ProtocolException e) {
                    Log.e("httpclient.isRedirected: unable to check for redirection", e);
                }
                if (!isRedirect) {
                    final int responseCode = response.getStatusLine().getStatusCode();
                    if (responseCode == 301 || responseCode == 302) {
                        return true;
                    }
                }
                return isRedirect;
            }
        });

        client.addRequestInterceptor(new HttpRequestInterceptor() {

            @Override
            public void process(
                    final HttpRequest request,
                    final HttpContext context) throws HttpException, IOException {
                if (!request.containsHeader("Accept-Encoding")) {
                    request.addHeader("Accept-Encoding", "gzip");
                }
            }
        });
        client.addResponseInterceptor(new HttpResponseInterceptor() {

            @Override
            public void process(
                    final HttpResponse response,
                    final HttpContext context) throws HttpException, IOException {
                final HttpEntity entity = response.getEntity();
                if (entity != null) {
                    final Header contentEncoding = entity.getContentEncoding();
                    if (contentEncoding != null) {
                        for (final HeaderElement codec : contentEncoding.getElements()) {
                            if (codec.getName().equalsIgnoreCase("gzip")) {
                                Log.d("Decompressing response");
                                response.setEntity(new GzipDecompressingEntity(response.getEntity()));
                                return;
                            }
                        }
                    }
                }
            }

        });

        return client;
    }

    /**
     * POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @return the HTTP response, or null in case of an encoding error params
     */
    public static HttpResponse postRequest(final String uri, final Parameters params) {
        return request("POST", uri, params, null, null);
    }

    /**
     * POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @params headers the headers to add to the request
     * @return the HTTP response, or null in case of an encoding error params
     */
    public static HttpResponse postRequest(final String uri, final Parameters params, final Parameters headers) {
        return request("POST", uri, params, headers, null);
    }

    /**
     * Multipart POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @param fileFieldName the name of the file field name
     * @param fileContentType the content-type of the file
     * @param file the file to include in the request
     * @return the HTTP response, or null in case of an encoding error param
     */
    public static HttpResponse postRequest(final String uri, final Parameters params,
                                           final String fileFieldName, final String fileContentType, final File file) {
        final MultipartEntity entity = new MultipartEntity();
        for (final NameValuePair param : params) {
            try {
                entity.addPart(param.getName(), new StringBody(param.getValue()));
            } catch (final UnsupportedEncodingException e) {
                Log.e("Network.postRequest: unsupported encoding for parameter " + param.getName(), e);
                return null;
            }
        }
        entity.addPart(fileFieldName, new FileBody(file, fileContentType));

        final HttpPost request = new HttpPost(uri);
        request.setEntity(entity);

        addHeaders(request, null, null);
        return doRepeatedRequests(request);
    }

    /**
     * Make an HTTP request
     *
     * @param method
     *            the HTTP method to use ("GET" or "POST")
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add to the URI
     * @param headers
     *            the headers to add to the request
     * @param cacheFile
     *            the cache file used to cache this query
     * @return the HTTP response, or null in case of an encoding error in a POST request arguments
     */
    private static HttpResponse request(final String method, final String uri, final Parameters params, final Parameters headers, final File cacheFile) {
        HttpRequestBase request;
        if (method.equals("GET")) {
            final String fullUri = params == null ? uri : Uri.parse(uri).buildUpon().encodedQuery(params.toString()).build().toString();
            request = new HttpGet(fullUri);
        } else {
            request = new HttpPost(uri);
            if (params != null) {
                try {
                    ((HttpPost) request).setEntity(new UrlEncodedFormEntity(params, "UTF-8"));
                } catch (final UnsupportedEncodingException e) {
                    Log.e("request", e);
                    return null;
                }
            }
        }

        addHeaders(request, headers, cacheFile);

        return doRepeatedRequests(request);
    }

    /**
     * Add headers to HTTP request.
     * @param request
     *            the request to add headers to
     * @param headers
     *            the headers to add (in addition to the standard headers), can be null
     * @param cacheFile
     *            if non-null, the file to take ETag and If-Modified-Since information from
     */
    private static void addHeaders(final HttpRequestBase request, final Parameters headers, final File cacheFile) {
        for (final NameValuePair header : Parameters.extend(Parameters.merge(headers, cacheHeaders(cacheFile)),
                "Accept-Charset", "utf-8,iso-8859-1;q=0.8,utf-16;q=0.8,*;q=0.7",
                "Accept-Language", "en-US,*;q=0.9",
                "X-Requested-With", "XMLHttpRequest")) {
            request.setHeader(header.getName(), header.getValue());
        }
        if (Settings.getUseNativeUa()) {
            request.getParams().setParameter(CoreProtocolPNames.USER_AGENT, Network.NATIVE_USER_AGENT);
        } else {
            request.getParams().setParameter(CoreProtocolPNames.USER_AGENT, Network.PC_USER_AGENT);
        }
    }

    /**
     * Retry a request for a few times.
     *
     * @param request
     *            the request to try
     * @return
     *            the response, or null if there has been a failure
     */
    private static HttpResponse doRepeatedRequests(final HttpRequestBase request) {
        final String reqLogStr = request.getMethod() + " " + Network.hidePassword(request.getURI().toString());
        Log.d(reqLogStr);

        final HttpClient client = Network.getHttpClient();
        for (int i = 0; i <= Network.NB_DOWNLOAD_RETRIES; i++) {
            final long before = System.currentTimeMillis();
            try {
                final HttpResponse response = client.execute(request);
                int status = response.getStatusLine().getStatusCode();
                if (status == 200) {
                    Log.d(status + Network.formatTimeSpan(before) + reqLogStr);
                } else {
                    Log.w(status + " [" + response.getStatusLine().getReasonPhrase() + "]" + Network.formatTimeSpan(before) + reqLogStr);
                }
                return response;
            } catch (IOException e) {
                final String timeSpan = Network.formatTimeSpan(before);
                final String tries = (i + 1) + "/" + (Network.NB_DOWNLOAD_RETRIES + 1);
                if (i == Network.NB_DOWNLOAD_RETRIES) {
                    Log.e("Failure " + tries + timeSpan + reqLogStr, e);
                } else {
                    Log.e("Failure " + tries + " (" + e.toString() + ")" + timeSpan + "- retrying " + reqLogStr);
                }
            }
        }

        return null;
    }

    private static Parameters cacheHeaders(final File cacheFile) {
        if (cacheFile == null || !cacheFile.exists()) {
            return null;
        }

        final String etag = LocalStorage.getSavedHeader(cacheFile, "etag");
        if (etag != null) {
            return new Parameters("If-None-Match", etag);
        }

        final String lastModified = LocalStorage.getSavedHeader(cacheFile, "last-modified");
        if (lastModified != null) {
            return new Parameters("If-Modified-Since", lastModified);
        }

        return null;
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @param cacheFile
     *            the name of the file storing the cached resource, or null not to use one
     * @return the HTTP response
     */
    public static HttpResponse getRequest(final String uri, final Parameters params, final File cacheFile) {
        return request("GET", uri, params, null, cacheFile);
    }


    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @return the HTTP response
     */
    public static HttpResponse getRequest(final String uri, final Parameters params) {
        return request("GET", uri, params, null, null);
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @param headers
     *            the headers to add to the GET request
     * @return the HTTP response
     */
    public static HttpResponse getRequest(final String uri, final Parameters params, final Parameters headers) {
        return request("GET", uri, params, headers, null);
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @return the HTTP response
     */
    public static HttpResponse getRequest(final String uri) {
        return request("GET", uri, null, null, null);
    }

    private static String formatTimeSpan(final long before) {
        // don't use String.format in a pure logging routine, it has very bad performance
        return " (" + (System.currentTimeMillis() - before) + " ms) ";
    }

    static public boolean isSuccess(final HttpResponse response) {
        return response != null && response.getStatusLine().getStatusCode() == 200;
    }

    public static JSONObject requestJSON(final String uri, final Parameters params) {
        final HttpResponse response = request("GET", uri, params, new Parameters("Accept", "application/json, text/javascript, */*; q=0.01"), null);
        if (isSuccess(response)) {
            try {
                return new JSONObject(Network.getResponseData(response));
            } catch (final JSONException e) {
                Log.e("Network.requestJSON", e);
            }
        }

        return null;
    }

    private static String getResponseDataNoError(final HttpResponse response, boolean replaceWhitespace) {
        try {
            String data = EntityUtils.toString(response.getEntity(), "UTF-8");
            return replaceWhitespace ? BaseUtils.replaceWhitespace(data) : data;
        } catch (Exception e) {
            Log.e("getResponseData", e);
            return null;
        }
    }

    public static String getResponseData(final HttpResponse response) {
        return Network.getResponseData(response, true);
    }

    public static String getResponseData(final HttpResponse response, boolean replaceWhitespace) {
        if (!isSuccess(response)) {
            return null;
        }
        return getResponseDataNoError(response, replaceWhitespace);
    }

    public static String rfc3986URLEncode(String text) {
        return StringUtils.replace(URLEncoder.encode(text).replace("+", "%20"), "%7E", "~");
    }

}
!@#$%
20190527_001041,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_c19984
package cgeo.geocaching.network;

import cgeo.geocaching.Settings;
import cgeo.geocaching.files.LocalStorage;
import cgeo.geocaching.utils.BaseUtils;
import cgeo.geocaching.utils.Log;

import ch.boye.httpclientandroidlib.Header;
import ch.boye.httpclientandroidlib.HeaderElement;
import ch.boye.httpclientandroidlib.HttpEntity;
import ch.boye.httpclientandroidlib.HttpException;
import ch.boye.httpclientandroidlib.HttpRequest;
import ch.boye.httpclientandroidlib.HttpRequestInterceptor;
import ch.boye.httpclientandroidlib.HttpResponse;
import ch.boye.httpclientandroidlib.HttpResponseInterceptor;
import ch.boye.httpclientandroidlib.NameValuePair;
import ch.boye.httpclientandroidlib.ProtocolException;
import ch.boye.httpclientandroidlib.client.HttpClient;
import ch.boye.httpclientandroidlib.client.entity.GzipDecompressingEntity;
import ch.boye.httpclientandroidlib.client.entity.UrlEncodedFormEntity;
import ch.boye.httpclientandroidlib.client.methods.HttpGet;
import ch.boye.httpclientandroidlib.client.methods.HttpPost;
import ch.boye.httpclientandroidlib.client.methods.HttpRequestBase;
import ch.boye.httpclientandroidlib.client.params.ClientPNames;
import ch.boye.httpclientandroidlib.entity.mime.MultipartEntity;
import ch.boye.httpclientandroidlib.entity.mime.content.FileBody;
import ch.boye.httpclientandroidlib.entity.mime.content.StringBody;
import ch.boye.httpclientandroidlib.impl.client.DefaultHttpClient;
import ch.boye.httpclientandroidlib.impl.client.DefaultRedirectStrategy;
import ch.boye.httpclientandroidlib.params.BasicHttpParams;
import ch.boye.httpclientandroidlib.params.CoreConnectionPNames;
import ch.boye.httpclientandroidlib.params.CoreProtocolPNames;
import ch.boye.httpclientandroidlib.params.HttpParams;
import ch.boye.httpclientandroidlib.protocol.HttpContext;
import ch.boye.httpclientandroidlib.util.EntityUtils;

import org.apache.commons.lang3.StringUtils;
import org.json.JSONException;
import org.json.JSONObject;

import android.net.Uri;

import java.io.File;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;

public abstract class Network {

    private static final int NB_DOWNLOAD_RETRIES = 4;
    /** User agent id */
    private final static String PC_USER_AGENT = "Mozilla/5.0 (X11; Linux x86_64; rv:9.0.1) Gecko/20100101 Firefox/9.0.1";
    /** Native user agent, taken from a Android 2.2 Nexus **/
    private final static String NATIVE_USER_AGENT = "Mozilla/5.0 (Linux; U; Android 2.2; en-us; Nexus One Build/FRF91) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1";

    private static final String PATTERN_PASSWORD = "(?<=[\\?&])[Pp]ass(w(or)?d)?=[^&#$]+";

    private final static HttpParams clientParams = new BasicHttpParams();

    static {
        Network.clientParams.setParameter(CoreProtocolPNames.HTTP_CONTENT_CHARSET, "UTF-8");
        Network.clientParams.setParameter(CoreConnectionPNames.CONNECTION_TIMEOUT, 30000);
        Network.clientParams.setParameter(CoreConnectionPNames.SO_TIMEOUT, 30000);
        Network.clientParams.setParameter(ClientPNames.HANDLE_REDIRECTS,  true);
    }

    private static String hidePassword(final String message) {
        return message.replaceAll(Network.PATTERN_PASSWORD, "password=***");
    }

    private static HttpClient getHttpClient() {
        final DefaultHttpClient client = new DefaultHttpClient();
        client.setCookieStore(Cookies.cookieStore);
        client.setParams(clientParams);

        client.setRedirectStrategy(new DefaultRedirectStrategy() {
            @Override
            public boolean isRedirected(HttpRequest request, HttpResponse response, HttpContext context) {
                boolean isRedirect = false;
                try {
                    isRedirect = super.isRedirected(request, response, context);
                } catch (final ProtocolException e) {
                    Log.e("httpclient.isRedirected: unable to check for redirection", e);
                }
                if (!isRedirect) {
                    final int responseCode = response.getStatusLine().getStatusCode();
                    if (responseCode == 301 || responseCode == 302) {
                        return true;
                    }
                }
                return isRedirect;
            }
        });

        client.addRequestInterceptor(new HttpRequestInterceptor() {

            @Override
            public void process(
                    final HttpRequest request,
                    final HttpContext context) throws HttpException, IOException {
                if (!request.containsHeader("Accept-Encoding")) {
                    request.addHeader("Accept-Encoding", "gzip");
                }
            }
        });
        client.addResponseInterceptor(new HttpResponseInterceptor() {

            @Override
            public void process(
                    final HttpResponse response,
                    final HttpContext context) throws HttpException, IOException {
                final HttpEntity entity = response.getEntity();
                if (entity != null) {
                    final Header contentEncoding = entity.getContentEncoding();
                    if (contentEncoding != null) {
                        for (final HeaderElement codec : contentEncoding.getElements()) {
                            if (codec.getName().equalsIgnoreCase("gzip")) {
                                Log.d("Decompressing response");
                                response.setEntity(new GzipDecompressingEntity(response.getEntity()));
                                return;
                            }
                        }
                    }
                }
            }

        });

        return client;
    }

    /**
     * POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @return the HTTP response, or null in case of an encoding error params
     */
    public static HttpResponse postRequest(final String uri, final Parameters params) {
        return request("POST", uri, params, null, null);
    }

    /**
     * POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @params headers the headers to add to the request
     * @return the HTTP response, or null in case of an encoding error params
     */
    public static HttpResponse postRequest(final String uri, final Parameters params, final Parameters headers) {
        return request("POST", uri, params, headers, null);
    }

    /**
     * Multipart POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @param fileFieldName the name of the file field name
     * @param fileContentType the content-type of the file
     * @param file the file to include in the request
     * @return the HTTP response, or null in case of an encoding error param
     */
    public static HttpResponse postRequest(final String uri, final Parameters params,
                                           final String fileFieldName, final String fileContentType, final File file) {
        final MultipartEntity entity = new MultipartEntity();
        for (final NameValuePair param : params) {
            try {
                entity.addPart(param.getName(), new StringBody(param.getValue()));
            } catch (final UnsupportedEncodingException e) {
                Log.e("Network.postRequest: unsupported encoding for parameter " + param.getName(), e);
                return null;
            }
        }
        entity.addPart(fileFieldName, new FileBody(file, fileContentType));

        final HttpPost request = new HttpPost(uri);
        request.setEntity(entity);

        addHeaders(request, null, null);
        return doRepeatedRequests(request);
    }

    /**
     * Make an HTTP request
     *
     * @param method
     *            the HTTP method to use ("GET" or "POST")
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add to the URI
     * @param headers
     *            the headers to add to the request
     * @param cacheFile
     *            the cache file used to cache this query
     * @return the HTTP response, or null in case of an encoding error in a POST request arguments
     */
    private static HttpResponse request(final String method, final String uri, final Parameters params, final Parameters headers, final File cacheFile) {
        HttpRequestBase request;
        if (method.equals("GET")) {
            final String fullUri = params == null ? uri : Uri.parse(uri).buildUpon().encodedQuery(params.toString()).build().toString();
            request = new HttpGet(fullUri);
        } else {
            request = new HttpPost(uri);
            if (params != null) {
                try {
                    ((HttpPost) request).setEntity(new UrlEncodedFormEntity(params, "UTF-8"));
                } catch (final UnsupportedEncodingException e) {
                    Log.e("request", e);
                    return null;
                }
            }
        }

        addHeaders(request, headers, cacheFile);

        return doRepeatedRequests(request);
    }

    /**
     * Add headers to HTTP request.
     * @param request
     *            the request to add headers to
     * @param headers
     *            the headers to add (in addition to the standard headers), can be null
     * @param cacheFile
     *            if non-null, the file to take ETag and If-Modified-Since information from
     */
    private static void addHeaders(final HttpRequestBase request, final Parameters headers, final File cacheFile) {
        for (final NameValuePair header : Parameters.extend(Parameters.merge(headers, cacheHeaders(cacheFile)),
                "Accept-Charset", "utf-8,iso-8859-1;q=0.8,utf-16;q=0.8,*;q=0.7",
                "Accept-Language", "en-US,*;q=0.9",
                "X-Requested-With", "XMLHttpRequest")) {
            request.setHeader(header.getName(), header.getValue());
        }
        if (Settings.getUseNativeUa()) {
            request.getParams().setParameter(CoreProtocolPNames.USER_AGENT, Network.NATIVE_USER_AGENT);
        } else {
            request.getParams().setParameter(CoreProtocolPNames.USER_AGENT, Network.PC_USER_AGENT);
        }
    }

    /**
     * Retry a request for a few times.
     *
     * @param request
     *            the request to try
     * @return
     *            the response, or null if there has been a failure
     */
    private static HttpResponse doRepeatedRequests(final HttpRequestBase request) {
        final String reqLogStr = request.getMethod() + " " + Network.hidePassword(request.getURI().toString());
        Log.d(reqLogStr);

        final HttpClient client = Network.getHttpClient();
        for (int i = 0; i <= Network.NB_DOWNLOAD_RETRIES; i++) {
            final long before = System.currentTimeMillis();
            try {
                final HttpResponse response = client.execute(request);
                int status = response.getStatusLine().getStatusCode();
                if (status == 200) {
                    Log.d(status + Network.formatTimeSpan(before) + reqLogStr);
                } else {
                    Log.w(status + " [" + response.getStatusLine().getReasonPhrase() + "]" + Network.formatTimeSpan(before) + reqLogStr);
                }
                return response;
            } catch (IOException e) {
                final String timeSpan = Network.formatTimeSpan(before);
                final String tries = (i + 1) + "/" + (Network.NB_DOWNLOAD_RETRIES + 1);
                if (i == Network.NB_DOWNLOAD_RETRIES) {
                    Log.e("Failure " + tries + timeSpan + reqLogStr, e);
                } else {
                    Log.e("Failure " + tries + " (" + e.toString() + ")" + timeSpan + "- retrying " + reqLogStr);
                }
            }
        }

        return null;
    }

    private static Parameters cacheHeaders(final File cacheFile) {
        if (cacheFile == null || !cacheFile.exists()) {
            return null;
        }

        final String etag = LocalStorage.getSavedHeader(cacheFile, "etag");
        if (etag != null) {
            return new Parameters("If-None-Match", etag);
        }

        final String lastModified = LocalStorage.getSavedHeader(cacheFile, "last-modified");
        if (lastModified != null) {
            return new Parameters("If-Modified-Since", lastModified);
        }

        return null;
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @param cacheFile
     *            the name of the file storing the cached resource, or null not to use one
     * @return the HTTP response
     */
    public static HttpResponse getRequest(final String uri, final Parameters params, final File cacheFile) {
        return request("GET", uri, params, null, cacheFile);
    }


    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @return the HTTP response
     */
    public static HttpResponse getRequest(final String uri, final Parameters params) {
        return request("GET", uri, params, null, null);
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @param headers
     *            the headers to add to the GET request
     * @return the HTTP response
     */
    public static HttpResponse getRequest(final String uri, final Parameters params, final Parameters headers) {
        return request("GET", uri, params, headers, null);
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @return the HTTP response
     */
    public static HttpResponse getRequest(final String uri) {
        return request("GET", uri, null, null, null);
    }

    private static String formatTimeSpan(final long before) {
        // don't use String.format in a pure logging routine, it has very bad performance
        return " (" + (System.currentTimeMillis() - before) + " ms) ";
    }

    static public boolean isSuccess(final HttpResponse response) {
        return response != null && response.getStatusLine().getStatusCode() == 200;
    }

    public static JSONObject requestJSON(final String uri, final Parameters params) {
        final HttpResponse response = request("GET", uri, params, new Parameters("Accept", "application/json, text/javascript, */*; q=0.01"), null);
        if (isSuccess(response)) {
            try {
                return new JSONObject(Network.getResponseData(response));
            } catch (final JSONException e) {
                Log.e("Network.requestJSON", e);
            } catch (final NullPointerException e) {
                Log.e("Network.requestJSON", e);
            }
        }

        return null;
    }

    private static String getResponseDataNoError(final HttpResponse response, boolean replaceWhitespace) {
        try {
            String data = EntityUtils.toString(response.getEntity(), "UTF-8");
            return replaceWhitespace ? BaseUtils.replaceWhitespace(data) : data;
        } catch (Exception e) {
            Log.e("getResponseData", e);
            return null;
        }
    }

    public static String getResponseData(final HttpResponse response) {
        return Network.getResponseData(response, true);
    }

    public static String getResponseData(final HttpResponse response, boolean replaceWhitespace) {
        if (!isSuccess(response)) {
            return null;
        }
        return getResponseDataNoError(response, replaceWhitespace);
    }

    public static String rfc3986URLEncode(String text) {
        return StringUtils.replace(URLEncoder.encode(text).replace("+", "%20"), "%7E", "~");
    }

}
!@#$%
20190527_001119,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_b20332
package cgeo.geocaching.connector.gc;

import cgeo.geocaching.R;
import cgeo.geocaching.Settings;
import cgeo.geocaching.cgeoapplication;
import cgeo.geocaching.enumerations.StatusCode;
import cgeo.geocaching.network.Cookies;
import cgeo.geocaching.network.HtmlImage;
import cgeo.geocaching.network.Network;
import cgeo.geocaching.network.Parameters;
import cgeo.geocaching.utils.BaseUtils;
import cgeo.geocaching.utils.Log;
import cgeo.geocaching.utils.MatcherWrapper;

import ch.boye.httpclientandroidlib.HttpResponse;

import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;

import android.graphics.drawable.BitmapDrawable;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

public abstract class Login {

    private final static String ENGLISH = "<a href=\"#\">English&#9660;</a>";

    // false = not logged in
    private static boolean actualLoginStatus = false;
    private static String actualUserName = "";
    private static int actualCachesFound = -1;
    private static String actualStatus = "";

    private final static Map<String, SimpleDateFormat> gcCustomDateFormats;
    public static final String LANGUAGE_CHANGE_URI = "http://www.geocaching.com/my/souvenirs.aspx";

    static {
        final String[] formats = new String[] {
                "MM/dd/yyyy",
                "yyyy-MM-dd",
                "yyyy/MM/dd",
                "dd/MMM/yyyy",
                "MMM/dd/yyyy",
                "dd MMM yy",
                "dd/MM/yyyy"
        };

        Map<String, SimpleDateFormat> map = new HashMap<String, SimpleDateFormat>();

        for (String format : formats) {
            map.put(format, new SimpleDateFormat(format, Locale.ENGLISH));
        }

        gcCustomDateFormats = Collections.unmodifiableMap(map);
    }

    public static StatusCode login() {
        return login(true);
    }

    private static StatusCode login(boolean retry) {
        final ImmutablePair<String, String> login = Settings.getLogin();

        if (login == null || StringUtils.isEmpty(login.left) || StringUtils.isEmpty(login.right)) {
            Login.setActualStatus(cgeoapplication.getInstance().getString(R.string.err_login));
            Log.e("Login.login: No login information stored");
            return StatusCode.NO_LOGIN_INFO_STORED;
        }

        Login.setActualStatus(cgeoapplication.getInstance().getString(R.string.init_login_popup_working));
        HttpResponse loginResponse = Network.getRequest("https://www.geocaching.com/login/default.aspx");
        String loginData = Network.getResponseData(loginResponse);
        if (loginResponse != null && loginResponse.getStatusLine().getStatusCode() == 503 && BaseUtils.matches(loginData, GCConstants.PATTERN_MAINTENANCE)) {
            return StatusCode.MAINTENANCE;
        }

        if (StringUtils.isBlank(loginData)) {
            Log.e("Login.login: Failed to retrieve login page (1st)");
            return StatusCode.CONNECTION_FAILED; // no loginpage
        }

        if (Login.getLoginStatus(loginData)) {
            Log.i("Already logged in Geocaching.com as " + login.left + " (" + Settings.getMemberStatus() + ')');
            Login.switchToEnglish(loginData);
            return StatusCode.NO_ERROR; // logged in
        }

        Cookies.clearCookies();
        Settings.setCookieStore(null);

        final Parameters params = new Parameters(
                "__EVENTTARGET", "",
                "__EVENTARGUMENT", "",
                "ctl00$ContentBody$tbUsername", login.left,
                "ctl00$ContentBody$tbPassword", login.right,
                "ctl00$ContentBody$cbRememberMe", "on",
                "ctl00$ContentBody$btnSignIn", "Login");
        final String[] viewstates = Login.getViewstates(loginData);
        if (isEmpty(viewstates)) {
            Log.e("Login.login: Failed to find viewstates");
            return StatusCode.LOGIN_PARSE_ERROR; // no viewstates
        }
        Login.putViewstates(params, viewstates);

        loginResponse = Network.postRequest("https://www.geocaching.com/login/default.aspx", params);
        loginData = Network.getResponseData(loginResponse);

        if (StringUtils.isBlank(loginData)) {
            Log.e("Login.login: Failed to retrieve login page (2nd)");
            // FIXME: should it be CONNECTION_FAILED to match the first attempt?
            return StatusCode.COMMUNICATION_ERROR; // no login page
        }

        if (Login.getLoginStatus(loginData)) {
            Log.i("Successfully logged in Geocaching.com as " + login.left + " (" + Settings.getMemberStatus() + ')');

            Login.switchToEnglish(loginData);
            Settings.setCookieStore(Cookies.dumpCookieStore());

            return StatusCode.NO_ERROR; // logged in
        }

        if (loginData.contains("Your username/password combination does not match.")) {
            Log.i("Failed to log in Geocaching.com as " + login.left + " because of wrong username/password");
            return StatusCode.WRONG_LOGIN_DATA; // wrong login
        }

        Log.i("Failed to log in Geocaching.com as " + login.left + " for some unknown reason");
        if (retry) {
            Login.switchToEnglish(loginData);
            return login(false);
        }

        return StatusCode.UNKNOWN_ERROR; // can't login
    }

    public static StatusCode logout() {
        HttpResponse logoutResponse = Network.getRequest("https://www.geocaching.com/login/default.aspx?RESET=Y&redir=http%3a%2f%2fwww.geocaching.com%2fdefault.aspx%3f");
        String logoutData = Network.getResponseData(logoutResponse);
        if (logoutResponse != null && logoutResponse.getStatusLine().getStatusCode() == 503 && BaseUtils.matches(logoutData, GCConstants.PATTERN_MAINTENANCE)) {
            return StatusCode.MAINTENANCE;
        }

        Cookies.clearCookies();
        Settings.setCookieStore(null);
        return StatusCode.NO_ERROR;
    }

    static void setActualCachesFound(final int found) {
        actualCachesFound = found;
    }

    public static String getActualStatus() {
        return actualStatus;
    }

    private static void setActualStatus(final String status) {
        actualStatus = status;
    }

    public static boolean isActualLoginStatus() {
        return actualLoginStatus;
    }

    private static void setActualLoginStatus(boolean loginStatus) {
        actualLoginStatus = loginStatus;
    }

    public static String getActualUserName() {
        return actualUserName;
    }

    private static void setActualUserName(String userName) {
        actualUserName = userName;
    }

    public static int getActualCachesFound() {
        return actualCachesFound;
    }

    /**
     * Check if the user has been logged in when he retrieved the data.
     *
     * @param page
     * @return <code>true</code> if user is logged in, <code>false</code> otherwise
     */
    public static boolean getLoginStatus(final String page) {
        if (StringUtils.isBlank(page)) {
            Log.e("Login.checkLogin: No page given");
            return false;
        }

        setActualStatus(cgeoapplication.getInstance().getString(R.string.init_login_popup_ok));

        // on every page except login page
        setActualLoginStatus(BaseUtils.matches(page, GCConstants.PATTERN_LOGIN_NAME));
        if (isActualLoginStatus()) {
            setActualUserName(BaseUtils.getMatch(page, GCConstants.PATTERN_LOGIN_NAME, true, "???"));
            setActualCachesFound(Integer.parseInt(BaseUtils.getMatch(page, GCConstants.PATTERN_CACHES_FOUND, true, "0").replaceAll("[,.]", "")));
            Settings.setMemberStatus(BaseUtils.getMatch(page, GCConstants.PATTERN_MEMBER_STATUS, true, null));
            if ( page.contains(GCConstants.MEMBER_STATUS_RENEW) ) {
                Settings.setMemberStatus(GCConstants.MEMBER_STATUS_PM);
            }
            return true;
        }

        // login page
        setActualLoginStatus(BaseUtils.matches(page, GCConstants.PATTERN_LOGIN_NAME_LOGIN_PAGE));
        if (isActualLoginStatus()) {
            setActualUserName(Settings.getUsername());
            // number of caches found is not part of this page
            return true;
        }

        setActualStatus(cgeoapplication.getInstance().getString(R.string.init_login_popup_failed));
        return false;
    }

    private static void switchToEnglish(String previousPage) {
        if (previousPage != null && previousPage.contains(ENGLISH)) {
            Log.i("Geocaching.com language already set to English");
            // get find count
            getLoginStatus(Network.getResponseData(Network.getRequest("http://www.geocaching.com/email/")));
        } else {
            final String page = Network.getResponseData(Network.getRequest(LANGUAGE_CHANGE_URI));
            getLoginStatus(page);
            if (page == null) {
                Log.e("Failed to read viewstates to set geocaching.com language");
            }
            final Parameters params = new Parameters(
                    "__EVENTTARGET", "ctl00$uxLocaleList$uxLocaleList$ctl00$uxLocaleItem", // switch to english
                    "__EVENTARGUMENT", "");
            Login.transferViewstates(page, params);
            final HttpResponse response = Network.postRequest(LANGUAGE_CHANGE_URI, params, new Parameters("Referer", LANGUAGE_CHANGE_URI));
            if (Network.isSuccess(response)) {
                Log.i("changed language on geocaching.com to English");
            } else {
                Log.e("Failed to set geocaching.com language to English");
            }
        }
    }

    public static BitmapDrawable downloadAvatarAndGetMemberStatus() {
        try {
            final String profile = BaseUtils.replaceWhitespace(Network.getResponseData(Network.getRequest("http://www.geocaching.com/my/")));

            Settings.setMemberStatus(BaseUtils.getMatch(profile, GCConstants.PATTERN_MEMBER_STATUS, true, null));
            if (profile.contains(GCConstants.MEMBER_STATUS_RENEW)) {
                Settings.setMemberStatus(GCConstants.MEMBER_STATUS_PM);
            }

            setActualCachesFound(Integer.parseInt(BaseUtils.getMatch(profile, GCConstants.PATTERN_CACHES_FOUND, true, "-1").replaceAll("[,.]", "")));

            final String avatarURL = BaseUtils.getMatch(profile, GCConstants.PATTERN_AVATAR_IMAGE_PROFILE_PAGE, false, null);
            if (null != avatarURL) {
                final HtmlImage imgGetter = new HtmlImage("", false, 0, false);
                return imgGetter.getDrawable(avatarURL);
            }
            // No match? There may be no avatar set by user.
            Log.d("No avatar set for user");
        } catch (Exception e) {
            Log.w("Error when retrieving user avatar", e);
        }
        return null;
    }

    /**
     * Detect user date settings on geocaching.com
     */
    public static void detectGcCustomDate() {

        final String result = Network.getResponseData(Network.getRequest("http://www.geocaching.com/account/ManagePreferences.aspx"));

        if (null == result) {
            Log.w("Login.detectGcCustomDate: result is null");
            return;
        }

        String customDate = BaseUtils.getMatch(result, GCConstants.PATTERN_CUSTOMDATE, true, null);
        if (null != customDate) {
            Settings.setGcCustomDate(customDate);
        }
    }

    public static Date parseGcCustomDate(final String input, final String format) throws ParseException {
        if (StringUtils.isBlank(input)) {
            throw new ParseException("Input is null", 0);
        }

        final String trimmed = input.trim();

        if (gcCustomDateFormats.containsKey(format)) {
            try {
                return gcCustomDateFormats.get(format).parse(trimmed);
            } catch (ParseException e) {
            }
        }

        for (SimpleDateFormat sdf : gcCustomDateFormats.values()) {
            try {
                return sdf.parse(trimmed);
            } catch (ParseException e) {
            }
        }

        throw new ParseException("No matching pattern", 0);
    }

    public static Date parseGcCustomDate(final String input) throws ParseException {
        return parseGcCustomDate(input, Settings.getGcCustomDate());
    }

    /**
     * checks if an Array of Strings is empty or not. Empty means:
     * - Array is null
     * - or all elements are null or empty strings
     */
    public static boolean isEmpty(String[] a) {
        if (a == null) {
            return true;
        }

        for (String s : a) {
            if (StringUtils.isNotEmpty(s)) {
                return false;
            }
        }
        return true;
    }

    /**
     * read all viewstates from page
     *
     * @return String[] with all view states
     */
    public static String[] getViewstates(String page) {
        // Get the number of viewstates.
        // If there is only one viewstate, __VIEWSTATEFIELDCOUNT is not present

        if (page == null) { // no network access
            return null;
        }

        int count = 1;
        final MatcherWrapper matcherViewstateCount = new MatcherWrapper(GCConstants.PATTERN_VIEWSTATEFIELDCOUNT, page);
        if (matcherViewstateCount.find()) {
            try {
                count = Integer.parseInt(matcherViewstateCount.group(1));
            } catch (NumberFormatException e) {
                Log.e("getViewStates", e);
            }
        }

        String[] viewstates = new String[count];

        // Get the viewstates
        final MatcherWrapper matcherViewstates = new MatcherWrapper(GCConstants.PATTERN_VIEWSTATES, page);
        while (matcherViewstates.find()) {
            String sno = matcherViewstates.group(1); // number of viewstate
            int no;
            if (StringUtils.isEmpty(sno)) {
                no = 0;
            } else {
                try {
                    no = Integer.parseInt(sno);
                } catch (NumberFormatException e) {
                    Log.e("getViewStates", e);
                    no = 0;
                }
            }
            viewstates[no] = matcherViewstates.group(2);
        }

        if (viewstates.length != 1 || viewstates[0] != null) {
            return viewstates;
        }
        // no viewstates were present
        return null;
    }

    /**
     * put viewstates into request parameters
     */
    public static void putViewstates(final Parameters params, final String[] viewstates) {
        if (ArrayUtils.isEmpty(viewstates)) {
            return;
        }
        params.put("__VIEWSTATE", viewstates[0]);
        if (viewstates.length > 1) {
            for (int i = 1; i < viewstates.length; i++) {
                params.put("__VIEWSTATE" + i, viewstates[i]);
            }
            params.put("__VIEWSTATEFIELDCOUNT", String.valueOf(viewstates.length));
        }
    }

    /**
     * transfers the viewstates variables from a page (response) to parameters
     * (next request)
     */
    public static void transferViewstates(final String page, final Parameters params) {
        putViewstates(params, getViewstates(page));
    }

    /**
     * POST HTTP request. Do the request a second time if the user is not logged in
     *
     * @param uri
     * @return
     */
    public static String postRequestLogged(final String uri, final Parameters params) {
        HttpResponse response = Network.postRequest(uri, params);
        String data = Network.getResponseData(response);

        if (!getLoginStatus(data)) {
            if (login() == StatusCode.NO_ERROR) {
                response = Network.postRequest(uri, params);
                data = Network.getResponseData(response);
            } else {
                Log.i("Working as guest.");
            }
        }
        return data;
    }

    /**
     * GET HTTP request. Do the request a second time if the user is not logged in
     *
     * @param uri
     * @param params
     * @return
     */
    public static String getRequestLogged(final String uri, final Parameters params) {
        final String data = Network.getResponseData(Network.getRequest(uri, params));

        if (getLoginStatus(data)) {
            return data;
        }

        if (login() == StatusCode.NO_ERROR) {
            return Network.getResponseData(Network.getRequest(uri, params));
        }

        Log.w("Working as guest.");
        return data;
    }

    /** Get user session & session token from the Live Map. Needed for following requests */
    public static String[] getMapTokens() {
        final HttpResponse response = Network.getRequest(GCConstants.URL_LIVE_MAP);
        final String data = Network.getResponseData(response);
        final String userSession = BaseUtils.getMatch(data, GCConstants.PATTERN_USERSESSION, "");
        final String sessionToken = BaseUtils.getMatch(data, GCConstants.PATTERN_SESSIONTOKEN, "");
        return new String[] { userSession, sessionToken };
    }
}
!@#$%
20190527_001119,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_a20332
package cgeo.geocaching.connector.gc;

import cgeo.geocaching.R;
import cgeo.geocaching.Settings;
import cgeo.geocaching.cgeoapplication;
import cgeo.geocaching.enumerations.StatusCode;
import cgeo.geocaching.network.Cookies;
import cgeo.geocaching.network.HtmlImage;
import cgeo.geocaching.network.Network;
import cgeo.geocaching.network.Parameters;
import cgeo.geocaching.utils.BaseUtils;
import cgeo.geocaching.utils.Log;

import ch.boye.httpclientandroidlib.HttpResponse;

import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;

import android.graphics.drawable.BitmapDrawable;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;
import java.util.regex.Matcher;

public abstract class Login {

    private final static String ENGLISH = "<a href=\"#\">English&#9660;</a>";

    // false = not logged in
    private static boolean actualLoginStatus = false;
    private static String actualUserName = "";
    private static int actualCachesFound = -1;
    private static String actualStatus = "";

    private final static Map<String, SimpleDateFormat> gcCustomDateFormats;
    public static final String LANGUAGE_CHANGE_URI = "http://www.geocaching.com/my/souvenirs.aspx";

    static {
        final String[] formats = new String[] {
                "MM/dd/yyyy",
                "yyyy-MM-dd",
                "yyyy/MM/dd",
                "dd/MMM/yyyy",
                "MMM/dd/yyyy",
                "dd MMM yy",
                "dd/MM/yyyy"
        };

        Map<String, SimpleDateFormat> map = new HashMap<String, SimpleDateFormat>();

        for (String format : formats) {
            map.put(format, new SimpleDateFormat(format, Locale.ENGLISH));
        }

        gcCustomDateFormats = Collections.unmodifiableMap(map);
    }

    public static StatusCode login() {
        return login(true);
    }

    private static StatusCode login(boolean retry) {
        final ImmutablePair<String, String> login = Settings.getLogin();

        if (login == null || StringUtils.isEmpty(login.left) || StringUtils.isEmpty(login.right)) {
            Login.setActualStatus(cgeoapplication.getInstance().getString(R.string.err_login));
            Log.e("Login.login: No login information stored");
            return StatusCode.NO_LOGIN_INFO_STORED;
        }

        Login.setActualStatus(cgeoapplication.getInstance().getString(R.string.init_login_popup_working));
        HttpResponse loginResponse = Network.getRequest("https://www.geocaching.com/login/default.aspx");
        String loginData = Network.getResponseData(loginResponse);
        if (loginResponse != null && loginResponse.getStatusLine().getStatusCode() == 503 && BaseUtils.matches(loginData, GCConstants.PATTERN_MAINTENANCE)) {
            return StatusCode.MAINTENANCE;
        }

        if (StringUtils.isBlank(loginData)) {
            Log.e("Login.login: Failed to retrieve login page (1st)");
            return StatusCode.CONNECTION_FAILED; // no loginpage
        }

        if (Login.getLoginStatus(loginData)) {
            Log.i("Already logged in Geocaching.com as " + login.left + " (" + Settings.getMemberStatus() + ')');
            Login.switchToEnglish(loginData);
            return StatusCode.NO_ERROR; // logged in
        }

        Cookies.clearCookies();
        Settings.setCookieStore(null);

        final Parameters params = new Parameters(
                "__EVENTTARGET", "",
                "__EVENTARGUMENT", "",
                "ctl00$ContentBody$tbUsername", login.left,
                "ctl00$ContentBody$tbPassword", login.right,
                "ctl00$ContentBody$cbRememberMe", "on",
                "ctl00$ContentBody$btnSignIn", "Login");
        final String[] viewstates = Login.getViewstates(loginData);
        if (isEmpty(viewstates)) {
            Log.e("Login.login: Failed to find viewstates");
            return StatusCode.LOGIN_PARSE_ERROR; // no viewstates
        }
        Login.putViewstates(params, viewstates);

        loginResponse = Network.postRequest("https://www.geocaching.com/login/default.aspx", params);
        loginData = Network.getResponseData(loginResponse);

        if (StringUtils.isBlank(loginData)) {
            Log.e("Login.login: Failed to retrieve login page (2nd)");
            // FIXME: should it be CONNECTION_FAILED to match the first attempt?
            return StatusCode.COMMUNICATION_ERROR; // no login page
        }

        if (Login.getLoginStatus(loginData)) {
            Log.i("Successfully logged in Geocaching.com as " + login.left + " (" + Settings.getMemberStatus() + ')');

            Login.switchToEnglish(loginData);
            Settings.setCookieStore(Cookies.dumpCookieStore());

            return StatusCode.NO_ERROR; // logged in
        }

        if (loginData.contains("Your username/password combination does not match.")) {
            Log.i("Failed to log in Geocaching.com as " + login.left + " because of wrong username/password");
            return StatusCode.WRONG_LOGIN_DATA; // wrong login
        }

        Log.i("Failed to log in Geocaching.com as " + login.left + " for some unknown reason");
        if (retry) {
            Login.switchToEnglish(loginData);
            return login(false);
        }

        return StatusCode.UNKNOWN_ERROR; // can't login
    }

    public static StatusCode logout() {
        HttpResponse logoutResponse = Network.getRequest("https://www.geocaching.com/login/default.aspx?RESET=Y&redir=http%3a%2f%2fwww.geocaching.com%2fdefault.aspx%3f");
        String logoutData = Network.getResponseData(logoutResponse);
        if (logoutResponse != null && logoutResponse.getStatusLine().getStatusCode() == 503 && BaseUtils.matches(logoutData, GCConstants.PATTERN_MAINTENANCE)) {
            return StatusCode.MAINTENANCE;
        }

        Cookies.clearCookies();
        Settings.setCookieStore(null);
        return StatusCode.NO_ERROR;
    }

    static void setActualCachesFound(final int found) {
        actualCachesFound = found;
    }

    public static String getActualStatus() {
        return actualStatus;
    }

    private static void setActualStatus(final String status) {
        actualStatus = status;
    }

    public static boolean isActualLoginStatus() {
        return actualLoginStatus;
    }

    private static void setActualLoginStatus(boolean loginStatus) {
        actualLoginStatus = loginStatus;
    }

    public static String getActualUserName() {
        return actualUserName;
    }

    private static void setActualUserName(String userName) {
        actualUserName = userName;
    }

    public static int getActualCachesFound() {
        return actualCachesFound;
    }

    /**
     * Check if the user has been logged in when he retrieved the data.
     *
     * @param page
     * @return <code>true</code> if user is logged in, <code>false</code> otherwise
     */
    public static boolean getLoginStatus(final String page) {
        if (StringUtils.isBlank(page)) {
            Log.e("Login.checkLogin: No page given");
            return false;
        }

        setActualStatus(cgeoapplication.getInstance().getString(R.string.init_login_popup_ok));

        // on every page except login page
        setActualLoginStatus(BaseUtils.matches(page, GCConstants.PATTERN_LOGIN_NAME));
        if (isActualLoginStatus()) {
            setActualUserName(BaseUtils.getMatch(page, GCConstants.PATTERN_LOGIN_NAME, true, "???"));
            setActualCachesFound(Integer.parseInt(BaseUtils.getMatch(page, GCConstants.PATTERN_CACHES_FOUND, true, "0").replaceAll("[,.]", "")));
            Settings.setMemberStatus(BaseUtils.getMatch(page, GCConstants.PATTERN_MEMBER_STATUS, true, null));
            if ( page.contains(GCConstants.MEMBER_STATUS_RENEW) ) {
                Settings.setMemberStatus(GCConstants.MEMBER_STATUS_PM);
            }
            return true;
        }

        // login page
        setActualLoginStatus(BaseUtils.matches(page, GCConstants.PATTERN_LOGIN_NAME_LOGIN_PAGE));
        if (isActualLoginStatus()) {
            setActualUserName(Settings.getUsername());
            // number of caches found is not part of this page
            return true;
        }

        setActualStatus(cgeoapplication.getInstance().getString(R.string.init_login_popup_failed));
        return false;
    }

    private static void switchToEnglish(String previousPage) {
        if (previousPage != null && previousPage.contains(ENGLISH)) {
            Log.i("Geocaching.com language already set to English");
            // get find count
            getLoginStatus(Network.getResponseData(Network.getRequest("http://www.geocaching.com/email/")));
        } else {
            final String page = Network.getResponseData(Network.getRequest(LANGUAGE_CHANGE_URI));
            getLoginStatus(page);
            if (page == null) {
                Log.e("Failed to read viewstates to set geocaching.com language");
            }
            final Parameters params = new Parameters(
                    "__EVENTTARGET", "ctl00$uxLocaleList$uxLocaleList$ctl00$uxLocaleItem", // switch to english
                    "__EVENTARGUMENT", "");
            Login.transferViewstates(page, params);
            final HttpResponse response = Network.postRequest(LANGUAGE_CHANGE_URI, params, new Parameters("Referer", LANGUAGE_CHANGE_URI));
            if (Network.isSuccess(response)) {
                Log.i("changed language on geocaching.com to English");
            } else {
                Log.e("Failed to set geocaching.com language to English");
            }
        }
    }

    public static BitmapDrawable downloadAvatarAndGetMemberStatus() {
        try {
            final String profile = BaseUtils.replaceWhitespace(Network.getResponseData(Network.getRequest("http://www.geocaching.com/my/")));

            Settings.setMemberStatus(BaseUtils.getMatch(profile, GCConstants.PATTERN_MEMBER_STATUS, true, null));
            if (profile.contains(GCConstants.MEMBER_STATUS_RENEW)) {
                Settings.setMemberStatus(GCConstants.MEMBER_STATUS_PM);
            }

            setActualCachesFound(Integer.parseInt(BaseUtils.getMatch(profile, GCConstants.PATTERN_CACHES_FOUND, true, "-1").replaceAll("[,.]", "")));

            final String avatarURL = BaseUtils.getMatch(profile, GCConstants.PATTERN_AVATAR_IMAGE_PROFILE_PAGE, false, null);
            if (null != avatarURL) {
                final HtmlImage imgGetter = new HtmlImage("", false, 0, false);
                return imgGetter.getDrawable(avatarURL);
            }
            // No match? There may be no avatar set by user.
            Log.d("No avatar set for user");
        } catch (Exception e) {
            Log.w("Error when retrieving user avatar", e);
        }
        return null;
    }

    /**
     * Detect user date settings on geocaching.com
     */
    public static void detectGcCustomDate() {

        final String result = Network.getResponseData(Network.getRequest("http://www.geocaching.com/account/ManagePreferences.aspx"));

        if (null == result) {
            Log.w("Login.detectGcCustomDate: result is null");
            return;
        }

        String customDate = BaseUtils.getMatch(result, GCConstants.PATTERN_CUSTOMDATE, true, null);
        if (null != customDate) {
            Settings.setGcCustomDate(customDate);
        }
    }

    public static Date parseGcCustomDate(final String input, final String format) throws ParseException {
        if (StringUtils.isBlank(input)) {
            throw new ParseException("Input is null", 0);
        }

        final String trimmed = input.trim();

        if (gcCustomDateFormats.containsKey(format)) {
            try {
                return gcCustomDateFormats.get(format).parse(trimmed);
            } catch (ParseException e) {
            }
        }

        for (SimpleDateFormat sdf : gcCustomDateFormats.values()) {
            try {
                return sdf.parse(trimmed);
            } catch (ParseException e) {
            }
        }

        throw new ParseException("No matching pattern", 0);
    }

    public static Date parseGcCustomDate(final String input) throws ParseException {
        return parseGcCustomDate(input, Settings.getGcCustomDate());
    }

    /**
     * checks if an Array of Strings is empty or not. Empty means:
     * - Array is null
     * - or all elements are null or empty strings
     */
    public static boolean isEmpty(String[] a) {
        if (a == null) {
            return true;
        }

        for (String s : a) {
            if (StringUtils.isNotEmpty(s)) {
                return false;
            }
        }
        return true;
    }

    /**
     * read all viewstates from page
     *
     * @return String[] with all view states
     */
    public static String[] getViewstates(String page) {
        // Get the number of viewstates.
        // If there is only one viewstate, __VIEWSTATEFIELDCOUNT is not present

        if (page == null) { // no network access
            return null;
        }

        int count = 1;
        final Matcher matcherViewstateCount = GCConstants.PATTERN_VIEWSTATEFIELDCOUNT.matcher(page);
        if (matcherViewstateCount.find()) {
            try {
                count = Integer.parseInt(matcherViewstateCount.group(1));
            } catch (NumberFormatException e) {
                Log.e("getViewStates", e);
            }
        }

        String[] viewstates = new String[count];

        // Get the viewstates
        int no;
        final Matcher matcherViewstates = GCConstants.PATTERN_VIEWSTATES.matcher(page);
        while (matcherViewstates.find()) {
            String sno = matcherViewstates.group(1); // number of viewstate
            if (sno.length() == 0) {
                no = 0;
            }
            else {
                try {
                    no = Integer.parseInt(sno);
                } catch (NumberFormatException e) {
                    Log.e("getViewStates", e);
                    no = 0;
                }
            }
            viewstates[no] = matcherViewstates.group(2);
        }

        if (viewstates.length != 1 || viewstates[0] != null) {
            return viewstates;
        }
        // no viewstates were present
        return null;
    }

    /**
     * put viewstates into request parameters
     */
    public static void putViewstates(final Parameters params, final String[] viewstates) {
        if (ArrayUtils.isEmpty(viewstates)) {
            return;
        }
        params.put("__VIEWSTATE", viewstates[0]);
        if (viewstates.length > 1) {
            for (int i = 1; i < viewstates.length; i++) {
                params.put("__VIEWSTATE" + i, viewstates[i]);
            }
            params.put("__VIEWSTATEFIELDCOUNT", String.valueOf(viewstates.length));
        }
    }

    /**
     * transfers the viewstates variables from a page (response) to parameters
     * (next request)
     */
    public static void transferViewstates(final String page, final Parameters params) {
        putViewstates(params, getViewstates(page));
    }

    /**
     * POST HTTP request. Do the request a second time if the user is not logged in
     *
     * @param uri
     * @return
     */
    public static String postRequestLogged(final String uri, final Parameters params) {
        HttpResponse response = Network.postRequest(uri, params);
        String data = Network.getResponseData(response);

        if (!getLoginStatus(data)) {
            if (login() == StatusCode.NO_ERROR) {
                response = Network.postRequest(uri, params);
                data = Network.getResponseData(response);
            } else {
                Log.i("Working as guest.");
            }
        }
        return data;
    }

    /**
     * GET HTTP request. Do the request a second time if the user is not logged in
     *
     * @param uri
     * @param params
     * @return
     */
    public static String getRequestLogged(final String uri, final Parameters params) {
        final String data = Network.getResponseData(Network.getRequest(uri, params));

        if (getLoginStatus(data)) {
            return data;
        }

        if (login() == StatusCode.NO_ERROR) {
            return Network.getResponseData(Network.getRequest(uri, params));
        }

        Log.w("Working as guest.");
        return data;
    }

    /** Get user session & session token from the Live Map. Needed for following requests */
    public static String[] getMapTokens() {
        final HttpResponse response = Network.getRequest(GCConstants.URL_LIVE_MAP);
        final String data = Network.getResponseData(response);
        final String userSession = BaseUtils.getMatch(data, GCConstants.PATTERN_USERSESSION, "");
        final String sessionToken = BaseUtils.getMatch(data, GCConstants.PATTERN_SESSIONTOKEN, "");
        return new String[] { userSession, sessionToken };
    }
}
!@#$%
20190527_001119,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_c20332
package cgeo.geocaching.connector.gc;

import cgeo.geocaching.R;
import cgeo.geocaching.Settings;
import cgeo.geocaching.cgeoapplication;
import cgeo.geocaching.enumerations.StatusCode;
import cgeo.geocaching.network.Cookies;
import cgeo.geocaching.network.HtmlImage;
import cgeo.geocaching.network.Network;
import cgeo.geocaching.network.Parameters;
import cgeo.geocaching.utils.BaseUtils;
import cgeo.geocaching.utils.Log;

import ch.boye.httpclientandroidlib.HttpResponse;

import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;

import android.graphics.drawable.BitmapDrawable;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;
import java.util.regex.Matcher;

public abstract class Login {

    private final static String ENGLISH = "<a href=\"#\">English&#9660;</a>";

    // false = not logged in
    private static boolean actualLoginStatus = false;
    private static String actualUserName = "";
    private static int actualCachesFound = -1;
    private static String actualStatus = "";

    private final static Map<String, SimpleDateFormat> gcCustomDateFormats;
    public static final String LANGUAGE_CHANGE_URI = "http://www.geocaching.com/my/souvenirs.aspx";

    static {
        final String[] formats = new String[] {
                "MM/dd/yyyy",
                "yyyy-MM-dd",
                "yyyy/MM/dd",
                "dd/MMM/yyyy",
                "MMM/dd/yyyy",
                "dd MMM yy",
                "dd/MM/yyyy"
        };

        Map<String, SimpleDateFormat> map = new HashMap<String, SimpleDateFormat>();

        for (String format : formats) {
            map.put(format, new SimpleDateFormat(format, Locale.ENGLISH));
        }

        gcCustomDateFormats = Collections.unmodifiableMap(map);
    }

    public static StatusCode login() {
        return login(true);
    }

    private static StatusCode login(boolean retry) {
        final ImmutablePair<String, String> login = Settings.getLogin();

        if (login == null || StringUtils.isEmpty(login.left) || StringUtils.isEmpty(login.right)) {
            Login.setActualStatus(cgeoapplication.getInstance().getString(R.string.err_login));
            Log.e("Login.login: No login information stored");
            return StatusCode.NO_LOGIN_INFO_STORED;
        }

        Login.setActualStatus(cgeoapplication.getInstance().getString(R.string.init_login_popup_working));
        HttpResponse loginResponse = Network.getRequest("https://www.geocaching.com/login/default.aspx");
        String loginData = Network.getResponseData(loginResponse);
        if (loginResponse != null && loginResponse.getStatusLine().getStatusCode() == 503 && BaseUtils.matches(loginData, GCConstants.PATTERN_MAINTENANCE)) {
            return StatusCode.MAINTENANCE;
        }

        if (StringUtils.isBlank(loginData)) {
            Log.e("Login.login: Failed to retrieve login page (1st)");
            return StatusCode.CONNECTION_FAILED; // no loginpage
        }

        if (Login.getLoginStatus(loginData)) {
            Log.i("Already logged in Geocaching.com as " + login.left + " (" + Settings.getMemberStatus() + ')');
            Login.switchToEnglish(loginData);
            return StatusCode.NO_ERROR; // logged in
        }

        Cookies.clearCookies();
        Settings.setCookieStore(null);

        final Parameters params = new Parameters(
                "__EVENTTARGET", "",
                "__EVENTARGUMENT", "",
                "ctl00$ContentBody$tbUsername", login.left,
                "ctl00$ContentBody$tbPassword", login.right,
                "ctl00$ContentBody$cbRememberMe", "on",
                "ctl00$ContentBody$btnSignIn", "Login");
        final String[] viewstates = Login.getViewstates(loginData);
        if (isEmpty(viewstates)) {
            Log.e("Login.login: Failed to find viewstates");
            return StatusCode.LOGIN_PARSE_ERROR; // no viewstates
        }
        Login.putViewstates(params, viewstates);

        loginResponse = Network.postRequest("https://www.geocaching.com/login/default.aspx", params);
        loginData = Network.getResponseData(loginResponse);

        if (StringUtils.isBlank(loginData)) {
            Log.e("Login.login: Failed to retrieve login page (2nd)");
            // FIXME: should it be CONNECTION_FAILED to match the first attempt?
            return StatusCode.COMMUNICATION_ERROR; // no login page
        }

        if (Login.getLoginStatus(loginData)) {
            Log.i("Successfully logged in Geocaching.com as " + login.left + " (" + Settings.getMemberStatus() + ')');

            Login.switchToEnglish(loginData);
            Settings.setCookieStore(Cookies.dumpCookieStore());

            return StatusCode.NO_ERROR; // logged in
        }

        if (loginData.contains("Your username/password combination does not match.")) {
            Log.i("Failed to log in Geocaching.com as " + login.left + " because of wrong username/password");
            return StatusCode.WRONG_LOGIN_DATA; // wrong login
        }

        if (loginData.contains("You must validate your account before you can log in.")) {
            Log.i("Failued to log in Geocaching.com as " + login.left + " because account needs to be validated first");
            return StatusCode.UNVALIDATED_ACCOUNT;
        }

        Log.i("Failed to log in Geocaching.com as " + login.left + " for some unknown reason");
        if (retry) {
            Login.switchToEnglish(loginData);
            return login(false);
        }

        return StatusCode.UNKNOWN_ERROR; // can't login
    }

    public static StatusCode logout() {
        HttpResponse logoutResponse = Network.getRequest("https://www.geocaching.com/login/default.aspx?RESET=Y&redir=http%3a%2f%2fwww.geocaching.com%2fdefault.aspx%3f");
        String logoutData = Network.getResponseData(logoutResponse);
        if (logoutResponse != null && logoutResponse.getStatusLine().getStatusCode() == 503 && BaseUtils.matches(logoutData, GCConstants.PATTERN_MAINTENANCE)) {
            return StatusCode.MAINTENANCE;
        }

        Cookies.clearCookies();
        Settings.setCookieStore(null);
        return StatusCode.NO_ERROR;
    }

    static void setActualCachesFound(final int found) {
        actualCachesFound = found;
    }

    public static String getActualStatus() {
        return actualStatus;
    }

    private static void setActualStatus(final String status) {
        actualStatus = status;
    }

    public static boolean isActualLoginStatus() {
        return actualLoginStatus;
    }

    private static void setActualLoginStatus(boolean loginStatus) {
        actualLoginStatus = loginStatus;
    }

    public static String getActualUserName() {
        return actualUserName;
    }

    private static void setActualUserName(String userName) {
        actualUserName = userName;
    }

    public static int getActualCachesFound() {
        return actualCachesFound;
    }

    /**
     * Check if the user has been logged in when he retrieved the data.
     *
     * @param page
     * @return <code>true</code> if user is logged in, <code>false</code> otherwise
     */
    public static boolean getLoginStatus(final String page) {
        if (StringUtils.isBlank(page)) {
            Log.e("Login.checkLogin: No page given");
            return false;
        }

        setActualStatus(cgeoapplication.getInstance().getString(R.string.init_login_popup_ok));

        // on every page except login page
        setActualLoginStatus(BaseUtils.matches(page, GCConstants.PATTERN_LOGIN_NAME));
        if (isActualLoginStatus()) {
            setActualUserName(BaseUtils.getMatch(page, GCConstants.PATTERN_LOGIN_NAME, true, "???"));
            setActualCachesFound(Integer.parseInt(BaseUtils.getMatch(page, GCConstants.PATTERN_CACHES_FOUND, true, "0").replaceAll("[,.]", "")));
            Settings.setMemberStatus(BaseUtils.getMatch(page, GCConstants.PATTERN_MEMBER_STATUS, true, null));
            if ( page.contains(GCConstants.MEMBER_STATUS_RENEW) ) {
                Settings.setMemberStatus(GCConstants.MEMBER_STATUS_PM);
            }
            return true;
        }

        // login page
        setActualLoginStatus(BaseUtils.matches(page, GCConstants.PATTERN_LOGIN_NAME_LOGIN_PAGE));
        if (isActualLoginStatus()) {
            setActualUserName(Settings.getUsername());
            // number of caches found is not part of this page
            return true;
        }

        setActualStatus(cgeoapplication.getInstance().getString(R.string.init_login_popup_failed));
        return false;
    }

    private static void switchToEnglish(String previousPage) {
        if (previousPage != null && previousPage.contains(ENGLISH)) {
            Log.i("Geocaching.com language already set to English");
            // get find count
            getLoginStatus(Network.getResponseData(Network.getRequest("http://www.geocaching.com/email/")));
        } else {
            final String page = Network.getResponseData(Network.getRequest(LANGUAGE_CHANGE_URI));
            getLoginStatus(page);
            if (page == null) {
                Log.e("Failed to read viewstates to set geocaching.com language");
            }
            final Parameters params = new Parameters(
                    "__EVENTTARGET", "ctl00$uxLocaleList$uxLocaleList$ctl00$uxLocaleItem", // switch to english
                    "__EVENTARGUMENT", "");
            Login.transferViewstates(page, params);
            final HttpResponse response = Network.postRequest(LANGUAGE_CHANGE_URI, params, new Parameters("Referer", LANGUAGE_CHANGE_URI));
            if (Network.isSuccess(response)) {
                Log.i("changed language on geocaching.com to English");
            } else {
                Log.e("Failed to set geocaching.com language to English");
            }
        }
    }

    public static BitmapDrawable downloadAvatarAndGetMemberStatus() {
        try {
            final String profile = BaseUtils.replaceWhitespace(Network.getResponseData(Network.getRequest("http://www.geocaching.com/my/")));

            Settings.setMemberStatus(BaseUtils.getMatch(profile, GCConstants.PATTERN_MEMBER_STATUS, true, null));
            if (profile.contains(GCConstants.MEMBER_STATUS_RENEW)) {
                Settings.setMemberStatus(GCConstants.MEMBER_STATUS_PM);
            }

            setActualCachesFound(Integer.parseInt(BaseUtils.getMatch(profile, GCConstants.PATTERN_CACHES_FOUND, true, "-1").replaceAll("[,.]", "")));

            final String avatarURL = BaseUtils.getMatch(profile, GCConstants.PATTERN_AVATAR_IMAGE_PROFILE_PAGE, false, null);
            if (null != avatarURL) {
                final HtmlImage imgGetter = new HtmlImage("", false, 0, false);
                return imgGetter.getDrawable(avatarURL);
            }
            // No match? There may be no avatar set by user.
            Log.d("No avatar set for user");
        } catch (Exception e) {
            Log.w("Error when retrieving user avatar", e);
        }
        return null;
    }

    /**
     * Detect user date settings on geocaching.com
     */
    public static void detectGcCustomDate() {

        final String result = Network.getResponseData(Network.getRequest("http://www.geocaching.com/account/ManagePreferences.aspx"));

        if (null == result) {
            Log.w("Login.detectGcCustomDate: result is null");
            return;
        }

        String customDate = BaseUtils.getMatch(result, GCConstants.PATTERN_CUSTOMDATE, true, null);
        if (null != customDate) {
            Settings.setGcCustomDate(customDate);
        }
    }

    public static Date parseGcCustomDate(final String input, final String format) throws ParseException {
        if (StringUtils.isBlank(input)) {
            throw new ParseException("Input is null", 0);
        }

        final String trimmed = input.trim();

        if (gcCustomDateFormats.containsKey(format)) {
            try {
                return gcCustomDateFormats.get(format).parse(trimmed);
            } catch (ParseException e) {
            }
        }

        for (SimpleDateFormat sdf : gcCustomDateFormats.values()) {
            try {
                return sdf.parse(trimmed);
            } catch (ParseException e) {
            }
        }

        throw new ParseException("No matching pattern", 0);
    }

    public static Date parseGcCustomDate(final String input) throws ParseException {
        return parseGcCustomDate(input, Settings.getGcCustomDate());
    }

    /**
     * checks if an Array of Strings is empty or not. Empty means:
     * - Array is null
     * - or all elements are null or empty strings
     */
    public static boolean isEmpty(String[] a) {
        if (a == null) {
            return true;
        }

        for (String s : a) {
            if (StringUtils.isNotEmpty(s)) {
                return false;
            }
        }
        return true;
    }

    /**
     * read all viewstates from page
     *
     * @return String[] with all view states
     */
    public static String[] getViewstates(String page) {
        // Get the number of viewstates.
        // If there is only one viewstate, __VIEWSTATEFIELDCOUNT is not present

        if (page == null) { // no network access
            return null;
        }

        int count = 1;
        final Matcher matcherViewstateCount = GCConstants.PATTERN_VIEWSTATEFIELDCOUNT.matcher(page);
        if (matcherViewstateCount.find()) {
            try {
                count = Integer.parseInt(matcherViewstateCount.group(1));
            } catch (NumberFormatException e) {
                Log.e("getViewStates", e);
            }
        }

        String[] viewstates = new String[count];

        // Get the viewstates
        int no;
        final Matcher matcherViewstates = GCConstants.PATTERN_VIEWSTATES.matcher(page);
        while (matcherViewstates.find()) {
            String sno = matcherViewstates.group(1); // number of viewstate
            if (sno.length() == 0) {
                no = 0;
            }
            else {
                try {
                    no = Integer.parseInt(sno);
                } catch (NumberFormatException e) {
                    Log.e("getViewStates", e);
                    no = 0;
                }
            }
            viewstates[no] = matcherViewstates.group(2);
        }

        if (viewstates.length != 1 || viewstates[0] != null) {
            return viewstates;
        }
        // no viewstates were present
        return null;
    }

    /**
     * put viewstates into request parameters
     */
    public static void putViewstates(final Parameters params, final String[] viewstates) {
        if (ArrayUtils.isEmpty(viewstates)) {
            return;
        }
        params.put("__VIEWSTATE", viewstates[0]);
        if (viewstates.length > 1) {
            for (int i = 1; i < viewstates.length; i++) {
                params.put("__VIEWSTATE" + i, viewstates[i]);
            }
            params.put("__VIEWSTATEFIELDCOUNT", String.valueOf(viewstates.length));
        }
    }

    /**
     * transfers the viewstates variables from a page (response) to parameters
     * (next request)
     */
    public static void transferViewstates(final String page, final Parameters params) {
        putViewstates(params, getViewstates(page));
    }

    /**
     * POST HTTP request. Do the request a second time if the user is not logged in
     *
     * @param uri
     * @return
     */
    public static String postRequestLogged(final String uri, final Parameters params) {
        HttpResponse response = Network.postRequest(uri, params);
        String data = Network.getResponseData(response);

        if (!getLoginStatus(data)) {
            if (login() == StatusCode.NO_ERROR) {
                response = Network.postRequest(uri, params);
                data = Network.getResponseData(response);
            } else {
                Log.i("Working as guest.");
            }
        }
        return data;
    }

    /**
     * GET HTTP request. Do the request a second time if the user is not logged in
     *
     * @param uri
     * @param params
     * @return
     */
    public static String getRequestLogged(final String uri, final Parameters params) {
        final String data = Network.getResponseData(Network.getRequest(uri, params));

        if (getLoginStatus(data)) {
            return data;
        }

        if (login() == StatusCode.NO_ERROR) {
            return Network.getResponseData(Network.getRequest(uri, params));
        }

        Log.w("Working as guest.");
        return data;
    }

    /** Get user session & session token from the Live Map. Needed for following requests */
    public static String[] getMapTokens() {
        final HttpResponse response = Network.getRequest(GCConstants.URL_LIVE_MAP);
        final String data = Network.getResponseData(response);
        final String userSession = BaseUtils.getMatch(data, GCConstants.PATTERN_USERSESSION, "");
        final String sessionToken = BaseUtils.getMatch(data, GCConstants.PATTERN_SESSIONTOKEN, "");
        return new String[] { userSession, sessionToken };
    }
}
!@#$%
20190527_001133,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_b19768
package cgeo.geocaching.export;

import cgeo.geocaching.LogEntry;
import cgeo.geocaching.R;
import cgeo.geocaching.activity.ActivityMixin;
import cgeo.geocaching.activity.Progress;
import cgeo.geocaching.cgCache;
import cgeo.geocaching.cgData;
import cgeo.geocaching.connector.gc.Login;
import cgeo.geocaching.enumerations.StatusCode;
import cgeo.geocaching.network.Network;
import cgeo.geocaching.network.Parameters;
import cgeo.geocaching.utils.IOUtils;
import cgeo.geocaching.utils.Log;

import org.apache.commons.lang3.CharEncoding;
import org.apache.commons.lang3.StringUtils;

import android.app.Activity;
import android.app.AlertDialog;
import android.os.AsyncTask;
import android.os.Environment;
import android.view.View;
import android.widget.CheckBox;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import java.util.Locale;
import java.util.TimeZone;

/**
 * Exports offline-logs in the Groundspeak Field Note format.<br>
 * <br>
 *
 * Field Notes are simple plain text files, but poorly documented. Syntax:<br>
 * <code>GCxxxxx,yyyy-mm-ddThh:mm:ssZ,Found it,"logtext"</code>
 */
class FieldnoteExport extends AbstractExport {
    private static final File exportLocation = new File(Environment.getExternalStorageDirectory().getAbsolutePath() + "/field-notes");
    private static final SimpleDateFormat fieldNoteDateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.US);
    static {
        fieldNoteDateFormat.setTimeZone(TimeZone.getTimeZone("UTC"));
    }

    protected FieldnoteExport() {
        super(getString(R.string.export_fieldnotes));
    }

    /**
     * A dialog to allow the user to set options for the export.
     *
     * Currently available options are: upload field notes, only new logs since last export/upload
     */
    private class ExportOptionsDialog extends AlertDialog {
        public ExportOptionsDialog(final List<cgCache> caches, final Activity activity) {
            super(activity);

            View layout = activity.getLayoutInflater().inflate(R.layout.fieldnote_export_dialog, null);
            setView(layout);

            final CheckBox uploadOption = (CheckBox) layout.findViewById(R.id.upload);
            final CheckBox onlyNewOption = (CheckBox) layout.findViewById(R.id.onlynew);

            uploadOption.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    onlyNewOption.setEnabled(uploadOption.isChecked());
                }
            });

            layout.findViewById(R.id.export).setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    dismiss();
                    new ExportTask(
                            caches,
                            activity,
                            uploadOption.isChecked(),
                            onlyNewOption.isChecked())
                            .execute((Void) null);
                }
            });
        }
    }

    @Override
    public void export(final List<cgCache> caches, final Activity activity) {
        if (null == activity) {
            // No activity given, so no user interaction possible.
            // Start export with default parameters.
            new ExportTask(caches, null, false, false).execute((Void) null);
        } else {
            // Show configuration dialog
            new ExportOptionsDialog(caches, activity).show();
        }
    }

    private class ExportTask extends AsyncTask<Void, Integer, Boolean> {
        private final List<cgCache> caches;
        private final Activity activity;
        private final boolean upload;
        private final boolean onlyNew;
        private final Progress progress = new Progress();
        private File exportFile;

        private static final int STATUS_UPLOAD = -1;

        /**
         * Instantiates and configurates the task for exporting field notes.
         *
         * @param caches
         *            The {@link List} of {@link cgCache} to be exported
         * @param activity
         *            optional: Show a progress bar and toasts
         * @param upload
         *            Upload the Field Note to geocaching.com
         * @param onlyNew
         *            Upload/export only new logs since last export
         */
        public ExportTask(final List<cgCache> caches, final Activity activity, final boolean upload, final boolean onlyNew) {
            this.caches = caches;
            this.activity = activity;
            this.upload = upload;
            this.onlyNew = onlyNew;
        }

        @Override
        protected void onPreExecute() {
            if (null != activity) {
                progress.show(activity, getString(R.string.export) + ": " + getName(), getString(R.string.export_fieldnotes_creating), true, null);
            }
        }

        @Override
        protected Boolean doInBackground(Void... params) {
            final StringBuilder fieldNoteBuffer = new StringBuilder();
            try {
                int i = 0;
                for (cgCache cache : caches) {
                    if (cache.isLogOffline()) {
                        appendFieldNote(fieldNoteBuffer, cache, cgData.loadLogOffline(cache.getGeocode()));
                        publishProgress(++i);
                    }
                }
            } catch (Exception e) {
                Log.e("FieldnoteExport.ExportTask generation", e);
                return false;
            }

            fieldNoteBuffer.append('\n');

            if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
                return false;
            }

            exportLocation.mkdirs();

            SimpleDateFormat fileNameDateFormat = new SimpleDateFormat("yyyyMMddHHmmss", Locale.US);
            exportFile = new File(exportLocation.toString() + '/' + fileNameDateFormat.format(new Date()) + ".txt");

            Writer fw = null;
            try {
                OutputStream os = new FileOutputStream(exportFile);
                fw = new OutputStreamWriter(os, CharEncoding.UTF_16);
                fw.write(fieldNoteBuffer.toString());
            } catch (IOException e) {
                Log.e("FieldnoteExport.ExportTask export", e);
                return false;
            } finally {
                IOUtils.closeQuietly(fw);
            }

            if (upload) {
                publishProgress(STATUS_UPLOAD);

                if (!Login.isActualLoginStatus()) {
                    // no need to upload (possibly large file) if we're not logged in
                    final StatusCode loginState = Login.login();
                    if (loginState != StatusCode.NO_ERROR) {
                        Log.e("FieldnoteExport.ExportTask upload: Login failed");
                    }
                }

                final String uri = "http://www.geocaching.com/my/uploadfieldnotes.aspx";
                String page = Network.getResponseData(Network.getRequest(uri));

                if (!Login.getLoginStatus(page)) {
                    // Login.isActualLoginStatus() was wrong, we are not logged in
                    final StatusCode loginState = Login.login();
                    if (loginState == StatusCode.NO_ERROR) {
                        page = Network.getResponseData(Network.getRequest(uri));
                    } else {
                        Log.e("FieldnoteExport.ExportTask upload: No login (error: " + loginState + ')');
                        return false;
                    }
                }

                final String[] viewstates = Login.getViewstates(page);

                final Parameters uploadParams = new Parameters(
                        "__EVENTTARGET", "",
                        "__EVENTARGUMENT", "",
                        "ctl00$ContentBody$btnUpload", "Upload Field Note");

                if (onlyNew) {
                    uploadParams.put("ctl00$ContentBody$chkSuppressDate", "on");
                }

                Login.putViewstates(uploadParams, viewstates);

                Network.getResponseData(Network.postRequest(uri, uploadParams, "ctl00$ContentBody$FieldNoteLoader", "text/plain", exportFile));

                if (StringUtils.isBlank(page)) {
                    Log.e("FieldnoteExport.ExportTask upload: No data from server");
                    return false;
                }
            }

            return true;
        }

        @Override
        protected void onPostExecute(Boolean result) {
            if (null != activity) {
                progress.dismiss();

                if (result) {
                    //                    if (onlyNew) {
                    //                        // update last export time in settings when doing it ourself (currently we use the date check from gc.com)
                    //                    }

                    ActivityMixin.showToast(activity, getName() + ' ' + getString(R.string.export_exportedto) + ": " + exportFile.toString());

                    if (upload) {
                        ActivityMixin.showToast(activity, getString(R.string.export_fieldnotes_upload_success));
                    }
                } else {
                    ActivityMixin.showToast(activity, getString(R.string.export_failed));
                }
            }
        }

        @Override
        protected void onProgressUpdate(Integer... status) {
            if (null != activity) {
                if (STATUS_UPLOAD == status[0]) {
                    progress.setMessage(getString(R.string.export_fieldnotes_uploading));
                } else {
                    progress.setMessage(getString(R.string.export_fieldnotes_creating) + " (" + status[0] + ')');
                }
            }
        }
    }

    static void appendFieldNote(final StringBuilder fieldNoteBuffer, final cgCache cache, final LogEntry log) {
        fieldNoteBuffer.append(cache.getGeocode())
                .append(',')
                .append(fieldNoteDateFormat.format(new Date(log.date)))
                .append(',')
                .append(StringUtils.capitalize(log.type.type))
                .append(",\"")
                .append(StringUtils.replaceChars(log.log, '"', '\''))
                .append("\"\n");
    }
}
!@#$%
20190527_001133,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_a19768
package cgeo.geocaching.export;

import cgeo.geocaching.LogEntry;
import cgeo.geocaching.R;
import cgeo.geocaching.cgCache;
import cgeo.geocaching.cgeoapplication;
import cgeo.geocaching.activity.ActivityMixin;
import cgeo.geocaching.activity.Progress;
import cgeo.geocaching.connector.gc.Login;
import cgeo.geocaching.enumerations.StatusCode;
import cgeo.geocaching.network.Network;
import cgeo.geocaching.network.Parameters;
import cgeo.geocaching.utils.Log;

import org.apache.commons.lang3.StringUtils;

import android.app.Activity;
import android.app.AlertDialog;
import android.os.AsyncTask;
import android.os.Environment;
import android.view.View;
import android.widget.CheckBox;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import java.util.Locale;

/**
 * Exports offline-logs in the Groundspeak Field Note format.<br>
 * <br>
 *
 * Field Notes are simple plain text files, but poorly documented. Syntax:<br>
 * <code>GCxxxxx,yyyy-mm-ddThh:mm:ssZ,Found it,"logtext"</code>
 */
class FieldnoteExport extends AbstractExport {
    private static final File exportLocation = new File(Environment.getExternalStorageDirectory().getAbsolutePath() + "/field-notes");
    private static final SimpleDateFormat fieldNoteDateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.US);

    protected FieldnoteExport() {
        super(getString(R.string.export_fieldnotes));
    }

    /**
     * A dialog to allow the user to set options for the export.
     *
     * Currently available options are: upload field notes, only new logs since last export/upload
     */
    private class ExportOptionsDialog extends AlertDialog {
        public ExportOptionsDialog(final List<cgCache> caches, final Activity activity) {
            super(activity);

            View layout = activity.getLayoutInflater().inflate(R.layout.fieldnote_export_dialog, null);
            setView(layout);

            final CheckBox uploadOption = (CheckBox) layout.findViewById(R.id.upload);
            final CheckBox onlyNewOption = (CheckBox) layout.findViewById(R.id.onlynew);

            uploadOption.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    onlyNewOption.setEnabled(uploadOption.isChecked());
                }
            });

            layout.findViewById(R.id.export).setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    dismiss();
                    new ExportTask(
                            caches,
                            activity,
                            uploadOption.isChecked(),
                            onlyNewOption.isChecked())
                            .execute((Void) null);
                }
            });
        }
    }

    @Override
    public void export(final List<cgCache> caches, final Activity activity) {
        if (null == activity) {
            // No activity given, so no user interaction possible.
            // Start export with default parameters.
            new ExportTask(caches, null, false, false).execute((Void) null);
        } else {
            // Show configuration dialog
            new ExportOptionsDialog(caches, activity).show();
        }
    }

    private class ExportTask extends AsyncTask<Void, Integer, Boolean> {
        private final List<cgCache> caches;
        private final Activity activity;
        private final boolean upload;
        private final boolean onlyNew;
        private final Progress progress = new Progress();
        private File exportFile;

        private static final int STATUS_UPLOAD = -1;

        /**
         * Instantiates and configurates the task for exporting field notes.
         *
         * @param caches
         *            The {@link List} of {@link cgCache} to be exported
         * @param activity
         *            optional: Show a progress bar and toasts
         * @param upload
         *            Upload the Field Note to geocaching.com
         * @param onlyNew
         *            Upload/export only new logs since last export
         */
        public ExportTask(final List<cgCache> caches, final Activity activity, final boolean upload, final boolean onlyNew) {
            this.caches = caches;
            this.activity = activity;
            this.upload = upload;
            this.onlyNew = onlyNew;
        }

        @Override
        protected void onPreExecute() {
            if (null != activity) {
                progress.show(activity, getString(R.string.export) + ": " + getName(), getString(R.string.export_fieldnotes_creating), true, null);
            }
        }

        @Override
        protected Boolean doInBackground(Void... params) {
            final StringBuilder fieldNoteBuffer = new StringBuilder();
            final cgeoapplication app = cgeoapplication.getInstance();

            try {
                int i = 0;
                for (cgCache cache : caches) {
                    if (cache.isLogOffline()) {
                        appendFieldNote(fieldNoteBuffer, cache, app.loadLogOffline(cache.getGeocode()));
                        publishProgress(++i);
                    }
                }
            } catch (Exception e) {
                Log.e("FieldnoteExport.ExportTask generation", e);
                return false;
            }

            fieldNoteBuffer.append('\n');

            if (Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
                exportLocation.mkdirs();

                SimpleDateFormat fileNameDateFormat = new SimpleDateFormat("yyyyMMddHHmmss", Locale.US);
                exportFile = new File(exportLocation.toString() + '/' + fileNameDateFormat.format(new Date()) + ".txt");

                OutputStream os;
                Writer fw = null;
                try {
                    os = new FileOutputStream(exportFile);
                    fw = new OutputStreamWriter(os, "UTF-16");
                    fw.write(fieldNoteBuffer.toString());
                } catch (IOException e) {
                    Log.e("FieldnoteExport.ExportTask export", e);
                    return false;
                } finally {
                    if (fw != null) {
                        try {
                            fw.close();
                        } catch (IOException e) {
                            Log.e("FieldnoteExport.ExportTask export", e);
                            return false;
                        }
                    }
                }
            } else {
                return false;
            }

            if (upload) {
                publishProgress(STATUS_UPLOAD);

                final String uri = "http://www.geocaching.com/my/uploadfieldnotes.aspx";

                if (!Login.isActualLoginStatus()) {
                    // no need to upload (possibly large file) if we're not logged in
                    final StatusCode loginState = Login.login();
                    if (loginState != StatusCode.NO_ERROR) {
                        Log.e("FieldnoteExport.ExportTask upload: Login failed");
                    }
                }

                String page = Network.getResponseData(Network.getRequest(uri));

                if (!Login.getLoginStatus(page)) {
                    // Login.isActualLoginStatus() was wrong, we are not logged in
                    final StatusCode loginState = Login.login();
                    if (loginState == StatusCode.NO_ERROR) {
                        page = Network.getResponseData(Network.getRequest(uri));
                    } else {
                        Log.e("FieldnoteExport.ExportTask upload: No login (error: " + loginState + ')');
                        return false;
                    }
                }

                final String[] viewstates = Login.getViewstates(page);

                final Parameters uploadParams = new Parameters(
                        "__EVENTTARGET", "",
                        "__EVENTARGUMENT", "",
                        "ctl00$ContentBody$btnUpload", "Upload Field Note");

                if (onlyNew) {
                    uploadParams.put("ctl00$ContentBody$chkSuppressDate", "on");
                }

                Login.putViewstates(uploadParams, viewstates);

                Network.getResponseData(Network.postRequest(uri, uploadParams, "ctl00$ContentBody$FieldNoteLoader", "text/plain", exportFile));

                if (StringUtils.isBlank(page)) {
                    Log.e("FieldnoteExport.ExportTask upload: No data from server");
                    return false;
                }
            }

            return true;
        }

        @Override
        protected void onPostExecute(Boolean result) {
            if (null != activity) {
                progress.dismiss();

                if (result) {
                    //                    if (onlyNew) {
                    //                        // update last export time in settings when doing it ourself (currently we use the date check from gc.com)
                    //                    }

                    ActivityMixin.showToast(activity, getName() + ' ' + getString(R.string.export_exportedto) + ": " + exportFile.toString());

                    if (upload) {
                        ActivityMixin.showToast(activity, getString(R.string.export_fieldnotes_upload_success));
                    }
                } else {
                    ActivityMixin.showToast(activity, getString(R.string.export_failed));
                }
            }
        }

        @Override
        protected void onProgressUpdate(Integer... status) {
            if (null != activity) {
                if (STATUS_UPLOAD == status[0]) {
                    progress.setMessage(getString(R.string.export_fieldnotes_uploading));
                } else {
                    progress.setMessage(getString(R.string.export_fieldnotes_creating) + " (" + status[0] + ')');
                }
            }
        }
    }

    static void appendFieldNote(final StringBuilder fieldNoteBuffer, final cgCache cache, final LogEntry log) {
        fieldNoteBuffer.append(cache.getGeocode())
                .append(',')
                .append(fieldNoteDateFormat.format(new Date(log.date)))
                .append(',')
                .append(StringUtils.capitalize(log.type.type))
                .append(",\"")
                .append(StringUtils.replaceChars(log.log, '"', '\''))
                .append("\"\n");
    }
}
!@#$%
20190527_001133,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_c19768
package cgeo.geocaching.export;

import cgeo.geocaching.LogEntry;
import cgeo.geocaching.R;
import cgeo.geocaching.cgCache;
import cgeo.geocaching.cgeoapplication;
import cgeo.geocaching.activity.ActivityMixin;
import cgeo.geocaching.activity.Progress;
import cgeo.geocaching.connector.gc.Login;
import cgeo.geocaching.enumerations.StatusCode;
import cgeo.geocaching.network.Network;
import cgeo.geocaching.network.Parameters;
import cgeo.geocaching.utils.Log;

import org.apache.commons.lang3.StringUtils;

import android.app.Activity;
import android.app.AlertDialog;
import android.os.AsyncTask;
import android.os.Environment;
import android.view.View;
import android.widget.CheckBox;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import java.util.Locale;
import java.util.TimeZone;

/**
 * Exports offline-logs in the Groundspeak Field Note format.<br>
 * <br>
 *
 * Field Notes are simple plain text files, but poorly documented. Syntax:<br>
 * <code>GCxxxxx,yyyy-mm-ddThh:mm:ssZ,Found it,"logtext"</code>
 */
class FieldnoteExport extends AbstractExport {
    private static final File exportLocation = new File(Environment.getExternalStorageDirectory().getAbsolutePath() + "/field-notes");
    private static final SimpleDateFormat fieldNoteDateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.US);
    static {
        fieldNoteDateFormat.setTimeZone(TimeZone.getTimeZone("UTC"));
    }

    protected FieldnoteExport() {
        super(getString(R.string.export_fieldnotes));
    }

    /**
     * A dialog to allow the user to set options for the export.
     *
     * Currently available options are: upload field notes, only new logs since last export/upload
     */
    private class ExportOptionsDialog extends AlertDialog {
        public ExportOptionsDialog(final List<cgCache> caches, final Activity activity) {
            super(activity);

            View layout = activity.getLayoutInflater().inflate(R.layout.fieldnote_export_dialog, null);
            setView(layout);

            final CheckBox uploadOption = (CheckBox) layout.findViewById(R.id.upload);
            final CheckBox onlyNewOption = (CheckBox) layout.findViewById(R.id.onlynew);

            uploadOption.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    onlyNewOption.setEnabled(uploadOption.isChecked());
                }
            });

            layout.findViewById(R.id.export).setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    dismiss();
                    new ExportTask(
                            caches,
                            activity,
                            uploadOption.isChecked(),
                            onlyNewOption.isChecked())
                            .execute((Void) null);
                }
            });
        }
    }

    @Override
    public void export(final List<cgCache> caches, final Activity activity) {
        if (null == activity) {
            // No activity given, so no user interaction possible.
            // Start export with default parameters.
            new ExportTask(caches, null, false, false).execute((Void) null);
        } else {
            // Show configuration dialog
            new ExportOptionsDialog(caches, activity).show();
        }
    }

    private class ExportTask extends AsyncTask<Void, Integer, Boolean> {
        private final List<cgCache> caches;
        private final Activity activity;
        private final boolean upload;
        private final boolean onlyNew;
        private final Progress progress = new Progress();
        private File exportFile;

        private static final int STATUS_UPLOAD = -1;

        /**
         * Instantiates and configurates the task for exporting field notes.
         *
         * @param caches
         *            The {@link List} of {@link cgCache} to be exported
         * @param activity
         *            optional: Show a progress bar and toasts
         * @param upload
         *            Upload the Field Note to geocaching.com
         * @param onlyNew
         *            Upload/export only new logs since last export
         */
        public ExportTask(final List<cgCache> caches, final Activity activity, final boolean upload, final boolean onlyNew) {
            this.caches = caches;
            this.activity = activity;
            this.upload = upload;
            this.onlyNew = onlyNew;
        }

        @Override
        protected void onPreExecute() {
            if (null != activity) {
                progress.show(activity, getString(R.string.export) + ": " + getName(), getString(R.string.export_fieldnotes_creating), true, null);
            }
        }

        @Override
        protected Boolean doInBackground(Void... params) {
            final StringBuilder fieldNoteBuffer = new StringBuilder();
            final cgeoapplication app = cgeoapplication.getInstance();

            try {
                int i = 0;
                for (cgCache cache : caches) {
                    if (cache.isLogOffline()) {
                        appendFieldNote(fieldNoteBuffer, cache, app.loadLogOffline(cache.getGeocode()));
                        publishProgress(++i);
                    }
                }
            } catch (Exception e) {
                Log.e("FieldnoteExport.ExportTask generation", e);
                return false;
            }

            fieldNoteBuffer.append('\n');

            if (Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
                exportLocation.mkdirs();

                SimpleDateFormat fileNameDateFormat = new SimpleDateFormat("yyyyMMddHHmmss", Locale.US);
                exportFile = new File(exportLocation.toString() + '/' + fileNameDateFormat.format(new Date()) + ".txt");

                OutputStream os;
                Writer fw = null;
                try {
                    os = new FileOutputStream(exportFile);
                    fw = new OutputStreamWriter(os, "UTF-16");
                    fw.write(fieldNoteBuffer.toString());
                } catch (IOException e) {
                    Log.e("FieldnoteExport.ExportTask export", e);
                    return false;
                } finally {
                    if (fw != null) {
                        try {
                            fw.close();
                        } catch (IOException e) {
                            Log.e("FieldnoteExport.ExportTask export", e);
                            return false;
                        }
                    }
                }
            } else {
                return false;
            }

            if (upload) {
                publishProgress(STATUS_UPLOAD);

                final String uri = "http://www.geocaching.com/my/uploadfieldnotes.aspx";

                if (!Login.isActualLoginStatus()) {
                    // no need to upload (possibly large file) if we're not logged in
                    final StatusCode loginState = Login.login();
                    if (loginState != StatusCode.NO_ERROR) {
                        Log.e("FieldnoteExport.ExportTask upload: Login failed");
                    }
                }

                String page = Network.getResponseData(Network.getRequest(uri));

                if (!Login.getLoginStatus(page)) {
                    // Login.isActualLoginStatus() was wrong, we are not logged in
                    final StatusCode loginState = Login.login();
                    if (loginState == StatusCode.NO_ERROR) {
                        page = Network.getResponseData(Network.getRequest(uri));
                    } else {
                        Log.e("FieldnoteExport.ExportTask upload: No login (error: " + loginState + ')');
                        return false;
                    }
                }

                final String[] viewstates = Login.getViewstates(page);

                final Parameters uploadParams = new Parameters(
                        "__EVENTTARGET", "",
                        "__EVENTARGUMENT", "",
                        "ctl00$ContentBody$btnUpload", "Upload Field Note");

                if (onlyNew) {
                    uploadParams.put("ctl00$ContentBody$chkSuppressDate", "on");
                }

                Login.putViewstates(uploadParams, viewstates);

                Network.getResponseData(Network.postRequest(uri, uploadParams, "ctl00$ContentBody$FieldNoteLoader", "text/plain", exportFile));

                if (StringUtils.isBlank(page)) {
                    Log.e("FieldnoteExport.ExportTask upload: No data from server");
                    return false;
                }
            }

            return true;
        }

        @Override
        protected void onPostExecute(Boolean result) {
            if (null != activity) {
                progress.dismiss();

                if (result) {
                    //                    if (onlyNew) {
                    //                        // update last export time in settings when doing it ourself (currently we use the date check from gc.com)
                    //                    }

                    ActivityMixin.showToast(activity, getName() + ' ' + getString(R.string.export_exportedto) + ": " + exportFile.toString());

                    if (upload) {
                        ActivityMixin.showToast(activity, getString(R.string.export_fieldnotes_upload_success));
                    }
                } else {
                    ActivityMixin.showToast(activity, getString(R.string.export_failed));
                }
            }
        }

        @Override
        protected void onProgressUpdate(Integer... status) {
            if (null != activity) {
                if (STATUS_UPLOAD == status[0]) {
                    progress.setMessage(getString(R.string.export_fieldnotes_uploading));
                } else {
                    progress.setMessage(getString(R.string.export_fieldnotes_creating) + " (" + status[0] + ')');
                }
            }
        }
    }

    static void appendFieldNote(final StringBuilder fieldNoteBuffer, final cgCache cache, final LogEntry log) {
        fieldNoteBuffer.append(cache.getGeocode())
                .append(',')
                .append(fieldNoteDateFormat.format(new Date(log.date)))
                .append(',')
                .append(StringUtils.capitalize(log.type.type))
                .append(",\"")
                .append(StringUtils.replaceChars(log.log, '"', '\''))
                .append("\"\n");
    }
}
!@#$%
20190527_001156,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_b15628
package cgeo.geocaching;

import cgeo.geocaching.apps.cache.navi.NavigationAppFactory.NavigationAppsEnum;
import cgeo.geocaching.connector.gc.GCConstants;
import cgeo.geocaching.connector.gc.Login;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.LiveMapStrategy.Strategy;
import cgeo.geocaching.enumerations.LogType;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.maps.MapProviderFactory;
import cgeo.geocaching.maps.google.GoogleMapProvider;
import cgeo.geocaching.maps.interfaces.GeoPointImpl;
import cgeo.geocaching.maps.interfaces.MapProvider;
import cgeo.geocaching.maps.interfaces.MapSource;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider.OfflineMapSource;
import cgeo.geocaching.utils.CryptUtils;
import cgeo.geocaching.utils.FileUtils;
import cgeo.geocaching.utils.FileUtils.FileSelector;
import cgeo.geocaching.utils.Log;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.os.Environment;
import android.preference.PreferenceManager;

import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

/**
 * General c:geo preferences/settings set by the user
 */
public final class Settings {

    private static final String KEY_TEMP_TOKEN_SECRET = "temp-token-secret";
    private static final String KEY_TEMP_TOKEN_PUBLIC = "temp-token-public";
    private static final String KEY_HELP_SHOWN = "helper";
    private static final String KEY_ANYLONGITUDE = "anylongitude";
    private static final String KEY_ANYLATITUDE = "anylatitude";
    private static final String KEY_USE_OFFLINEMAPS = "offlinemaps";
    private static final String KEY_USE_OFFLINEWPMAPS = "offlinewpmaps";
    private static final String KEY_WEB_DEVICE_CODE = "webDeviceCode";
    private static final String KEY_WEBDEVICE_NAME = "webDeviceName";
    private static final String KEY_MAP_LIVE = "maplive";
    private static final String KEY_MAP_SOURCE = "mapsource";
    private static final String KEY_USE_TWITTER = "twitter";
    private static final String KEY_SHOW_ADDRESS = "showaddress";
    private static final String KEY_SHOW_CAPTCHA = "showcaptcha";
    private static final String KEY_MAP_TRAIL = "maptrail";
    private static final String KEY_LAST_MAP_ZOOM = "mapzoom";
    private static final String KEY_LAST_MAP_LAT = "maplat";
    private static final String KEY_LAST_MAP_LON = "maplon";
    private static final String KEY_LIVE_LIST = "livelist";
    private static final String KEY_METRIC_UNITS = "units";
    private static final String KEY_SKIN = "skin";
    private static final String KEY_LAST_USED_LIST = "lastlist";
    private static final String KEY_CACHE_TYPE = "cachetype";
    private static final String KEY_TWITTER_TOKEN_SECRET = "tokensecret";
    private static final String KEY_TWITTER_TOKEN_PUBLIC = "tokenpublic";
    private static final String KEY_VERSION = "version";
    private static final String KEY_LOAD_DESCRIPTION = "autoloaddesc";
    private static final String KEY_RATING_WANTED = "ratingwanted";
    private static final String KEY_ELEVATION_WANTED = "elevationwanted";
    private static final String KEY_FRIENDLOGS_WANTED = "friendlogswanted";
    private static final String KEY_USE_ENGLISH = "useenglish";
    private static final String KEY_USE_COMPASS = "usecompass";
    private static final String KEY_AUTO_VISIT_TRACKABLES = "trackautovisit";
    private static final String KEY_AUTO_INSERT_SIGNATURE = "sigautoinsert";
    private static final String KEY_ALTITUDE_CORRECTION = "altcorrection";
    private static final String KEY_STORE_LOG_IMAGES = "logimages";
    private static final String KEY_EXCLUDE_DISABLED = "excludedisabled";
    private static final String KEY_EXCLUDE_OWN = "excludemine";
    private static final String KEY_MAPFILE = "mfmapfile";
    private static final String KEY_SIGNATURE = "signature";
    private static final String KEY_GCVOTE_PASSWORD = "pass-vote";
    private static final String KEY_PASSWORD = "password";
    private static final String KEY_USERNAME = "username";
    private static final String KEY_MEMBER_STATUS = "memberstatus";
    private static final String KEY_COORD_INPUT_FORMAT = "coordinputformat";
    private static final String KEY_LOG_OFFLINE = "log_offline";
    private static final String KEY_LOAD_DIRECTION_IMG = "loaddirectionimg";
    private static final String KEY_GC_CUSTOM_DATE = "gccustomdate";
    private static final String KEY_SHOW_WAYPOINTS_THRESHOLD = "gcshowwaypointsthreshold";
    private static final String KEY_COOKIE_STORE = "cookiestore";
    private static final String KEY_OPEN_LAST_DETAILS_PAGE = "opendetailslastpage";
    private static final String KEY_LAST_DETAILS_PAGE = "lastdetailspage";
    private static final String KEY_DEFAULT_NAVIGATION_TOOL = "defaultNavigationTool";
    private static final String KEY_DEFAULT_NAVIGATION_TOOL_2 = "defaultNavigationTool2";
    private static final String KEY_LIVE_MAP_STRATEGY = "livemapstrategy";
    private static final String KEY_DEBUG = "debug";
    private static final String KEY_HIDE_LIVE_MAP_HINT = "hidelivemaphint";
    private static final String KEY_LIVE_MAP_HINT_SHOW_COUNT = "livemaphintshowcount";
    private static final String KEY_SETTINGS_VERSION = "settingsversion";
    private static final String KEY_DB_ON_SDCARD = "dbonsdcard";
    private static final String KEY_LAST_TRACKABLE_ACTION = "trackableaction";
    private static final String KEY_SHARE_AFTER_EXPORT = "shareafterexport";
    private static final String KEY_GPX_EXPORT_DIR = "gpxExportDir";
    private static final String KEY_RENDER_THEME_BASE_FOLDER = "renderthemepath";
    private static final String KEY_RENDER_THEME_FILE_PATH = "renderthemefile";
    private static final String KEY_GPX_IMPORT_DIR = "gpxImportDir";
    private static final String KEY_PLAIN_LOGS = "plainLogs";
    private static final String KEY_NATIVE_UA = "nativeUa";
    private static final String KEY_MAP_DIRECTORY = "mapDirectory";
    private static final String KEY_CONNECTOR_OC_ACTIVE = "connectorOCActive";
    private static final String KEY_CONNECTOR_OC_USER = "connectorOCUser";

    private final static int unitsMetric = 1;

    // twitter api keys
    private final static String keyConsumerPublic = CryptUtils.rot13("ESnsCvAv3kEupF1GCR3jGj");
    private final static String keyConsumerSecret = CryptUtils.rot13("7vQWceACV9umEjJucmlpFe9FCMZSeqIqfkQ2BnhV9x");

    private interface PrefRunnable {
        void edit(final Editor edit);
    }

    public enum coordInputFormatEnum {
        Plain,
        Deg,
        Min,
        Sec;

        static coordInputFormatEnum fromInt(int id) {
            final coordInputFormatEnum[] values = coordInputFormatEnum.values();
            if (id < 0 || id >= values.length) {
                return Min;
            }
            return values[id];
        }
    }

    private static String username = null;
    private static String password = null;

    private static final SharedPreferences sharedPrefs = PreferenceManager.getDefaultSharedPreferences(cgeoapplication.getInstance().getBaseContext());
    static {
        migrateSettings();
        Log.setDebugUnsaved(sharedPrefs.getBoolean(KEY_DEBUG, false));
    }

    // maps
    private static MapProvider mapProvider = null;

    private Settings() {
        // this class is not to be instantiated;
    }

    private static void migrateSettings() {
        // migrate from non standard file location and integer based boolean types
        if (sharedPrefs.getInt(KEY_SETTINGS_VERSION, 0) < 1) {
            final String oldPreferencesName = "cgeo.pref";
            final SharedPreferences old = cgeoapplication.getInstance().getSharedPreferences(oldPreferencesName, Context.MODE_PRIVATE);
            final Editor e = sharedPrefs.edit();

            e.putString(KEY_TEMP_TOKEN_SECRET, old.getString(KEY_TEMP_TOKEN_SECRET, null));
            e.putString(KEY_TEMP_TOKEN_PUBLIC, old.getString(KEY_TEMP_TOKEN_PUBLIC, null));
            e.putBoolean(KEY_HELP_SHOWN, old.getInt(KEY_HELP_SHOWN, 0) != 0);
            e.putFloat(KEY_ANYLONGITUDE, old.getFloat(KEY_ANYLONGITUDE, 0));
            e.putFloat(KEY_ANYLATITUDE, old.getFloat(KEY_ANYLATITUDE, 0));
            e.putBoolean(KEY_USE_OFFLINEMAPS, 0 != old.getInt(KEY_USE_OFFLINEMAPS, 1));
            e.putBoolean(KEY_USE_OFFLINEWPMAPS, 0 != old.getInt(KEY_USE_OFFLINEWPMAPS, 0));
            e.putString(KEY_WEB_DEVICE_CODE, old.getString(KEY_WEB_DEVICE_CODE, null));
            e.putString(KEY_WEBDEVICE_NAME, old.getString(KEY_WEBDEVICE_NAME, null));
            e.putBoolean(KEY_MAP_LIVE, old.getInt(KEY_MAP_LIVE, 1) != 0);
            e.putInt(KEY_MAP_SOURCE, old.getInt(KEY_MAP_SOURCE, 0));
            e.putBoolean(KEY_USE_TWITTER, 0 != old.getInt(KEY_USE_TWITTER, 0));
            e.putBoolean(KEY_SHOW_ADDRESS, 0 != old.getInt(KEY_SHOW_ADDRESS, 1));
            e.putBoolean(KEY_SHOW_CAPTCHA, old.getBoolean(KEY_SHOW_CAPTCHA, false));
            e.putBoolean(KEY_MAP_TRAIL, old.getInt(KEY_MAP_TRAIL, 1) != 0);
            e.putInt(KEY_LAST_MAP_ZOOM, old.getInt(KEY_LAST_MAP_ZOOM, 14));
            e.putBoolean(KEY_LIVE_LIST, 0 != old.getInt(KEY_LIVE_LIST, 1));
            e.putBoolean(KEY_METRIC_UNITS, old.getInt(KEY_METRIC_UNITS, unitsMetric) == unitsMetric);
            e.putBoolean(KEY_SKIN, old.getInt(KEY_SKIN, 0) != 0);
            e.putInt(KEY_LAST_USED_LIST, old.getInt(KEY_LAST_USED_LIST, StoredList.STANDARD_LIST_ID));
            e.putString(KEY_CACHE_TYPE, old.getString(KEY_CACHE_TYPE, CacheType.ALL.id));
            e.putString(KEY_TWITTER_TOKEN_SECRET, old.getString(KEY_TWITTER_TOKEN_SECRET, null));
            e.putString(KEY_TWITTER_TOKEN_PUBLIC, old.getString(KEY_TWITTER_TOKEN_PUBLIC, null));
            e.putInt(KEY_VERSION, old.getInt(KEY_VERSION, 0));
            e.putBoolean(KEY_LOAD_DESCRIPTION, 0 != old.getInt(KEY_LOAD_DESCRIPTION, 0));
            e.putBoolean(KEY_RATING_WANTED, old.getBoolean(KEY_RATING_WANTED, true));
            e.putBoolean(KEY_ELEVATION_WANTED, old.getBoolean(KEY_ELEVATION_WANTED, true));
            e.putBoolean(KEY_FRIENDLOGS_WANTED, old.getBoolean(KEY_FRIENDLOGS_WANTED, true));
            e.putBoolean(KEY_USE_ENGLISH, old.getBoolean(KEY_USE_ENGLISH, false));
            e.putBoolean(KEY_USE_COMPASS, 0 != old.getInt(KEY_USE_COMPASS, 1));
            e.putBoolean(KEY_AUTO_VISIT_TRACKABLES, old.getBoolean(KEY_AUTO_VISIT_TRACKABLES, false));
            e.putBoolean(KEY_AUTO_INSERT_SIGNATURE, old.getBoolean(KEY_AUTO_INSERT_SIGNATURE, false));
            e.putInt(KEY_ALTITUDE_CORRECTION, old.getInt(KEY_ALTITUDE_CORRECTION, 0));
            e.putBoolean(KEY_STORE_LOG_IMAGES, old.getBoolean(KEY_STORE_LOG_IMAGES, false));
            e.putBoolean(KEY_EXCLUDE_DISABLED, 0 != old.getInt(KEY_EXCLUDE_DISABLED, 0));
            e.putBoolean(KEY_EXCLUDE_OWN, 0 != old.getInt(KEY_EXCLUDE_OWN, 0));
            e.putString(KEY_MAPFILE, old.getString(KEY_MAPFILE, null));
            e.putString(KEY_SIGNATURE, old.getString(KEY_SIGNATURE, null));
            e.putString(KEY_GCVOTE_PASSWORD, old.getString(KEY_GCVOTE_PASSWORD, null));
            e.putString(KEY_PASSWORD, old.getString(KEY_PASSWORD, null));
            e.putString(KEY_USERNAME, old.getString(KEY_USERNAME, null));
            e.putString(KEY_MEMBER_STATUS, old.getString(KEY_MEMBER_STATUS, ""));
            e.putInt(KEY_COORD_INPUT_FORMAT, old.getInt(KEY_COORD_INPUT_FORMAT, 0));
            e.putBoolean(KEY_LOG_OFFLINE, old.getBoolean(KEY_LOG_OFFLINE, false));
            e.putBoolean(KEY_LOAD_DIRECTION_IMG, old.getBoolean(KEY_LOAD_DIRECTION_IMG, true));
            e.putString(KEY_GC_CUSTOM_DATE, old.getString(KEY_GC_CUSTOM_DATE, null));
            e.putInt(KEY_SHOW_WAYPOINTS_THRESHOLD, old.getInt(KEY_SHOW_WAYPOINTS_THRESHOLD, 0));
            e.putString(KEY_COOKIE_STORE, old.getString(KEY_COOKIE_STORE, null));
            e.putBoolean(KEY_OPEN_LAST_DETAILS_PAGE, old.getBoolean(KEY_OPEN_LAST_DETAILS_PAGE, false));
            e.putInt(KEY_LAST_DETAILS_PAGE, old.getInt(KEY_LAST_DETAILS_PAGE, 1));
            e.putInt(KEY_DEFAULT_NAVIGATION_TOOL, old.getInt(KEY_DEFAULT_NAVIGATION_TOOL, NavigationAppsEnum.COMPASS.id));
            e.putInt(KEY_DEFAULT_NAVIGATION_TOOL_2, old.getInt(KEY_DEFAULT_NAVIGATION_TOOL_2, NavigationAppsEnum.INTERNAL_MAP.id));
            e.putInt(KEY_LIVE_MAP_STRATEGY, old.getInt(KEY_LIVE_MAP_STRATEGY, Strategy.AUTO.id));
            e.putBoolean(KEY_DEBUG, old.getBoolean(KEY_DEBUG, false));
            e.putBoolean(KEY_HIDE_LIVE_MAP_HINT, old.getInt(KEY_HIDE_LIVE_MAP_HINT, 0) != 0);
            e.putInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, old.getInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, 0));

            e.putInt(KEY_SETTINGS_VERSION, 1); // mark migrated
            e.commit();
        }
    }

    public static void setLanguage(boolean useEnglish) {
        final Configuration config = new Configuration();
        config.locale = useEnglish ? new Locale("en") : Locale.getDefault();
        final Resources resources = cgeoapplication.getInstance().getResources();
        resources.updateConfiguration(config, resources.getDisplayMetrics());
    }

    public static boolean isLogin() {
        final String preUsername = sharedPrefs.getString(KEY_USERNAME, null);
        final String prePassword = sharedPrefs.getString(KEY_PASSWORD, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    /**
     * Get login and password information.
     *
     * @return a pair (login, password) or null if no valid information is stored
     */
    public static ImmutablePair<String, String> getLogin() {
        if (username == null || password == null) {
            final String preUsername = sharedPrefs.getString(KEY_USERNAME, null);
            final String prePassword = sharedPrefs.getString(KEY_PASSWORD, null);

            if (preUsername == null || prePassword == null) {
                return null;
            }

            username = preUsername;
            password = prePassword;
        }
        return new ImmutablePair<String, String>(username, password);
    }

    public static String getUsername() {
        return username != null ? username : sharedPrefs.getString(KEY_USERNAME, null);
    }

    public static boolean setLogin(final String username, final String password) {
        Settings.username = username;
        Settings.password = password;
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
                    // erase username and password
                    edit.remove(KEY_USERNAME);
                    edit.remove(KEY_PASSWORD);
                } else {
                    // save username and password
                    edit.putString(KEY_USERNAME, username);
                    edit.putString(KEY_PASSWORD, password);
                }
            }
        });
    }

    public static boolean isPremiumMember() {
        // Basic Member, Premium Member, ???
        String memberStatus = Settings.getMemberStatus();
        if (memberStatus == null) {
            return false;
        }
        return GCConstants.MEMBER_STATUS_PM.equalsIgnoreCase(memberStatus);
    }

    public static String getMemberStatus() {
        return sharedPrefs.getString(KEY_MEMBER_STATUS, "");
    }

    public static boolean setMemberStatus(final String memberStatus) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(memberStatus)) {
                    edit.remove(KEY_MEMBER_STATUS);
                } else {
                    edit.putString(KEY_MEMBER_STATUS, memberStatus);
                }
            }
        });
    }

    public static boolean isOCConnectorActive() {
        return sharedPrefs.getBoolean(KEY_CONNECTOR_OC_ACTIVE, false);
    }

    public static boolean setOCConnectorActive(final boolean isActive) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_CONNECTOR_OC_ACTIVE, isActive);
            }
        });
    }

    public static String getOCConnectorUserName() {
        String ocConnectorUser = sharedPrefs.getString(KEY_CONNECTOR_OC_USER, null);
        if (StringUtils.isBlank(ocConnectorUser)) {
            return StringUtils.EMPTY;
        }
        return ocConnectorUser;
    }

    public static boolean setOCConnectorUserName(final String userName) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(userName)) {
                    edit.remove(KEY_CONNECTOR_OC_USER);
                } else {
                    edit.putString(KEY_CONNECTOR_OC_USER, userName);
                }
            }
        });
    }

    public static boolean isGCvoteLogin() {
        final String preUsername = sharedPrefs.getString(KEY_USERNAME, null);
        final String prePassword = sharedPrefs.getString(KEY_GCVOTE_PASSWORD, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    public static boolean setGCvoteLogin(final String password) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(password)) {
                    // erase password
                    edit.remove(KEY_GCVOTE_PASSWORD);
                } else {
                    // save password
                    edit.putString(KEY_GCVOTE_PASSWORD, password);
                }
            }
        });
    }

    public static ImmutablePair<String, String> getGCvoteLogin() {
        final String username = sharedPrefs.getString(KEY_USERNAME, null);
        final String password = sharedPrefs.getString(KEY_GCVOTE_PASSWORD, null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return null;
        }

        return new ImmutablePair<String, String>(username, password);
    }

    public static boolean setSignature(final String signature) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(signature)) {
                    // erase signature
                    edit.remove(KEY_SIGNATURE);
                } else {
                    // save signature
                    edit.putString(KEY_SIGNATURE, signature);
                }
            }
        });
    }

    public static String getSignature() {
        return sharedPrefs.getString(KEY_SIGNATURE, null);
    }

    public static boolean setCookieStore(final String cookies) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(final Editor edit) {
                if (StringUtils.isBlank(cookies)) {
                    // erase cookies
                    edit.remove(KEY_COOKIE_STORE);
                } else {
                    // save cookies
                    edit.putString(KEY_COOKIE_STORE, cookies);
                }
            }
        });
    }

    public static String getCookieStore() {
        return sharedPrefs.getString(KEY_COOKIE_STORE, null);
    }

    /**
     * @param cacheType
     *            The cache type used for future filtering
     */
    public static void setCacheType(final CacheType cacheType) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                if (cacheType == null) {
                    edit.remove(KEY_CACHE_TYPE);
                } else {
                    edit.putString(KEY_CACHE_TYPE, cacheType.id);
                }
            }
        });
    }

    public static void setLiveMap(final boolean live) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_MAP_LIVE, live);
            }
        });
    }

    public static int getLastList() {
        return sharedPrefs.getInt(KEY_LAST_USED_LIST, StoredList.STANDARD_LIST_ID);
    }

    public static void saveLastList(final int listId) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_USED_LIST, listId);
            }
        });
    }

    public static void setWebNameCode(final String name, final String code) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {

                edit.putString(KEY_WEBDEVICE_NAME, name);
                edit.putString(KEY_WEB_DEVICE_CODE, code);
            }
        });
    }

    public static MapProvider getMapProvider() {
        if (mapProvider == null) {
            mapProvider = getMapSource().getMapProvider();
        }
        return mapProvider;
    }

    public static String getMapFile() {
        return sharedPrefs.getString(KEY_MAPFILE, null);
    }

    public static boolean setMapFile(final String mapFile) {
        boolean result = editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_MAPFILE, mapFile);
            }
        });
        if (mapFile != null) {
            setMapFileDirectory(new File(mapFile).getParent());
        }
        return result;
    }

    public static String getMapFileDirectory() {
        final String mapDir = sharedPrefs.getString(KEY_MAP_DIRECTORY, null);
        if (mapDir != null) {
            return mapDir;
        }
        final String mapFile = getMapFile();
        if (mapFile != null) {
            return new File(mapFile).getParent();
        }
        return null;
    }

    public static boolean setMapFileDirectory(final String mapFileDirectory) {
        return editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_MAP_DIRECTORY, mapFileDirectory);
                MapsforgeMapProvider.getInstance().updateOfflineMaps();
            }
        });
    }

    public static boolean isValidMapFile() {
        return isValidMapFile(getMapFile());
    }

    public static boolean isValidMapFile(final String mapFileIn) {
        return MapsforgeMapProvider.isValidMapFile(mapFileIn);
    }

    public static coordInputFormatEnum getCoordInputFormat() {
        return coordInputFormatEnum.fromInt(sharedPrefs.getInt(KEY_COORD_INPUT_FORMAT, 0));
    }

    public static void setCoordInputFormat(final coordInputFormatEnum format) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_COORD_INPUT_FORMAT, format.ordinal());
            }
        });
    }

    static void setLogOffline(final boolean offline) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LOG_OFFLINE, offline);
            }
        });
    }

    public static boolean getLogOffline() {
        return sharedPrefs.getBoolean(KEY_LOG_OFFLINE, false);
    }

    static void setLoadDirImg(final boolean value) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LOAD_DIRECTION_IMG, value);
            }
        });
    }

    public static boolean getLoadDirImg() {
        return !isPremiumMember() && sharedPrefs.getBoolean(KEY_LOAD_DIRECTION_IMG, true);
    }

    public static void setGcCustomDate(final String format) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_GC_CUSTOM_DATE, format);
            }
        });
    }

    /**
     * @return User selected date format on GC.com
     * @see Login#gcCustomDateFormats
     */
    public static String getGcCustomDate() {
        return sharedPrefs.getString(KEY_GC_CUSTOM_DATE, null);
    }

    public static boolean isExcludeMyCaches() {
        return sharedPrefs.getBoolean(KEY_EXCLUDE_OWN, false);
    }

    /**
     * edit some settings without knowing how to get the settings editor or how to commit
     *
     * @param runnable
     * @return
     */
    private static boolean editSharedSettings(final PrefRunnable runnable) {
        final SharedPreferences.Editor prefsEdit = sharedPrefs.edit();
        runnable.edit(prefsEdit);
        return prefsEdit.commit();
    }

    public static void setExcludeMine(final boolean exclude) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_EXCLUDE_OWN, exclude);
            }
        });
    }

    public static void setUseEnglish(final boolean english) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_ENGLISH, english);
                setLanguage(english);
            }
        });
    }

    public static boolean isUseEnglish() {
        return sharedPrefs.getBoolean(KEY_USE_ENGLISH, false);
    }

    public static boolean isShowAddress() {
        return sharedPrefs.getBoolean(KEY_SHOW_ADDRESS, true);
    }

    public static void setShowAddress(final boolean showAddress) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SHOW_ADDRESS, showAddress);
            }
        });
    }

    public static boolean isShowCaptcha() {
        return !isPremiumMember() && sharedPrefs.getBoolean(KEY_SHOW_CAPTCHA, false);
    }

    public static void setShowCaptcha(final boolean showCaptcha) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SHOW_CAPTCHA, showCaptcha);
            }
        });
    }

    public static boolean isExcludeDisabledCaches() {
        return sharedPrefs.getBoolean(KEY_EXCLUDE_DISABLED, false);
    }

    public static void setExcludeDisabledCaches(final boolean exclude) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_EXCLUDE_DISABLED, exclude);
            }
        });
    }

    public static boolean isStoreOfflineMaps() {
        return sharedPrefs.getBoolean(KEY_USE_OFFLINEMAPS, true);
    }

    public static void setStoreOfflineMaps(final boolean offlineMaps) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_OFFLINEMAPS, offlineMaps);
            }
        });
    }

    public static boolean isStoreOfflineWpMaps() {
        return sharedPrefs.getBoolean(KEY_USE_OFFLINEWPMAPS, false);
    }

    public static void setStoreOfflineWpMaps(final boolean offlineMaps) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_OFFLINEWPMAPS, offlineMaps);
            }
        });
    }

    public static boolean isStoreLogImages() {
        return sharedPrefs.getBoolean(KEY_STORE_LOG_IMAGES, false);
    }

    public static void setStoreLogImages(final boolean storeLogImages) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_STORE_LOG_IMAGES, storeLogImages);
            }
        });
    }

    public static boolean isAutoLoadDescription() {
        return sharedPrefs.getBoolean(KEY_LOAD_DESCRIPTION, false);
    }

    public static void setAutoLoadDesc(final boolean autoLoad) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LOAD_DESCRIPTION, autoLoad);
            }
        });
    }

    public static boolean isRatingWanted() {
        return sharedPrefs.getBoolean(KEY_RATING_WANTED, true);
    }

    public static void setRatingWanted(final boolean ratingWanted) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_RATING_WANTED, ratingWanted);
            }
        });
    }

    public static boolean isElevationWanted() {
        return sharedPrefs.getBoolean(KEY_ELEVATION_WANTED, true);
    }

    public static void setElevationWanted(final boolean elevationWanted) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_ELEVATION_WANTED, elevationWanted);
            }
        });
    }

    public static boolean isFriendLogsWanted() {
        if (!isLogin()) {
            // don't show a friends log if the user is anonymous
            return false;
        }
        return sharedPrefs.getBoolean(KEY_FRIENDLOGS_WANTED, true);
    }

    public static void setFriendLogsWanted(final boolean friendLogsWanted) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_FRIENDLOGS_WANTED, friendLogsWanted);
            }
        });
    }

    public static boolean isLiveList() {
        return sharedPrefs.getBoolean(KEY_LIVE_LIST, true);
    }

    public static void setLiveList(final boolean liveList) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LIVE_LIST, liveList);
            }
        });
    }

    public static boolean isTrackableAutoVisit() {
        return sharedPrefs.getBoolean(KEY_AUTO_VISIT_TRACKABLES, false);
    }

    public static void setTrackableAutoVisit(final boolean autoVisit) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_AUTO_VISIT_TRACKABLES, autoVisit);
            }
        });
    }

    public static boolean isAutoInsertSignature() {
        return sharedPrefs.getBoolean(KEY_AUTO_INSERT_SIGNATURE, false);
    }

    public static void setAutoInsertSignature(final boolean autoInsert) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_AUTO_INSERT_SIGNATURE, autoInsert);
            }
        });
    }

    public static boolean isUseMetricUnits() {
        return sharedPrefs.getBoolean(KEY_METRIC_UNITS, true);
    }

    public static void setUseMetricUnits(final boolean metric) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_METRIC_UNITS, metric);
            }
        });
    }

    public static boolean isLiveMap() {
        return sharedPrefs.getBoolean(KEY_MAP_LIVE, true);
    }

    public static boolean isMapTrail() {
        return sharedPrefs.getBoolean(KEY_MAP_TRAIL, true);
    }

    public static void setMapTrail(final boolean showTrail) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_MAP_TRAIL, showTrail);
            }
        });
    }

    public static int getMapZoom() {
        return sharedPrefs.getInt(KEY_LAST_MAP_ZOOM, 14);
    }

    public static void setMapZoom(final int mapZoomLevel) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_MAP_ZOOM, mapZoomLevel);
            }
        });
    }

    public static GeoPointImpl getMapCenter() {
        return getMapProvider().getMapItemFactory()
                .getGeoPointBase(new Geopoint(sharedPrefs.getInt(KEY_LAST_MAP_LAT, 0) / 1e6,
                        sharedPrefs.getInt(KEY_LAST_MAP_LON, 0) / 1e6));
    }

    public static void setMapCenter(final GeoPointImpl mapViewCenter) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_MAP_LAT, mapViewCenter.getLatitudeE6());
                edit.putInt(KEY_LAST_MAP_LON, mapViewCenter.getLongitudeE6());
            }
        });
    }

    public static MapSource getMapSource() {
        final int id = getConvertedMapId();
        final MapSource map = MapProviderFactory.getMapSource(id);
        if (map != null) {
            // don't use offline maps if the map file is not valid
            if ((!(map instanceof OfflineMapSource)) || (isValidMapFile())) {
                return map;
            }
        }
        // fallback to first available map
        return MapProviderFactory.getDefaultSource();
    }

    private final static int GOOGLEMAP_BASEID = 30;
    private final static int MAP = 1;
    private final static int SATELLITE = 2;

    private final static int MFMAP_BASEID = 40;
    private final static int MAPNIK = 1;
    private final static int CYCLEMAP = 3;
    private final static int OFFLINE = 4;

    /**
     * convert old preference ids for maps (based on constant values) into new hash based ids
     *
     * @return
     */
    private static int getConvertedMapId() {
        final int id = sharedPrefs.getInt(KEY_MAP_SOURCE, 0);
        switch (id) {
            case GOOGLEMAP_BASEID + MAP:
                return GoogleMapProvider.GOOGLE_MAP_ID.hashCode();
            case GOOGLEMAP_BASEID + SATELLITE:
                return GoogleMapProvider.GOOGLE_SATELLITE_ID.hashCode();
            case MFMAP_BASEID + MAPNIK:
                return MapsforgeMapProvider.MAPSFORGE_MAPNIK_ID.hashCode();
            case MFMAP_BASEID + CYCLEMAP:
                return MapsforgeMapProvider.MAPSFORGE_CYCLEMAP_ID.hashCode();
            case MFMAP_BASEID + OFFLINE: {
                final String mapFile = Settings.getMapFile();
                if (StringUtils.isNotEmpty(mapFile)) {
                    return mapFile.hashCode();
                }
                break;
            }
            default:
                break;
        }
        return id;
    }

    public static void setMapSource(final MapSource newMapSource) {
        if (!MapProviderFactory.isSameActivity(getMapSource(), newMapSource)) {
            mapProvider = null;
        }
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_MAP_SOURCE, newMapSource.getNumericalId());
            }
        });
        if (newMapSource instanceof OfflineMapSource) {
            setMapFile(((OfflineMapSource) newMapSource).getFileName());
        }
    }

    public static void setAnyCoordinates(final Geopoint coords) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (null != coords) {
                    edit.putFloat(KEY_ANYLATITUDE, (float) coords.getLatitude());
                    edit.putFloat(KEY_ANYLONGITUDE, (float) coords.getLongitude());
                } else {
                    edit.remove(KEY_ANYLATITUDE);
                    edit.remove(KEY_ANYLONGITUDE);
                }
            }
        });

    }

    public static Geopoint getAnyCoordinates() {
        if (sharedPrefs.contains(KEY_ANYLATITUDE) && sharedPrefs.contains(KEY_ANYLONGITUDE)) {
            float lat = sharedPrefs.getFloat(KEY_ANYLATITUDE, 0);
            float lon = sharedPrefs.getFloat(KEY_ANYLONGITUDE, 0);
            return new Geopoint(lat, lon);
        }
        return null;
    }

    public static boolean isUseCompass() {
        return sharedPrefs.getBoolean(KEY_USE_COMPASS, true);
    }

    public static void setUseCompass(final boolean useCompass) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_COMPASS, useCompass);
            }
        });
    }

    public static boolean isHelpShown() {
        return sharedPrefs.getBoolean(KEY_HELP_SHOWN, false);
    }

    public static void setHelpShown() {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_HELP_SHOWN, true);
            }
        });
    }

    public static boolean isLightSkin() {
        return sharedPrefs.getBoolean(KEY_SKIN, false);
    }

    public static void setLightSkin(final boolean lightSkin) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SKIN, lightSkin);
            }
        });
    }

    public static String getKeyConsumerPublic() {
        return keyConsumerPublic;
    }

    public static String getKeyConsumerSecret() {
        return keyConsumerSecret;
    }

    public static int getAltCorrection() {
        return sharedPrefs.getInt(KEY_ALTITUDE_CORRECTION, 0);
    }

    public static boolean setAltCorrection(final int altitude) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_ALTITUDE_CORRECTION, altitude);
            }
        });
    }

    public static String getWebDeviceCode() {
        return sharedPrefs.getString(KEY_WEB_DEVICE_CODE, null);
    }

    public static String getWebDeviceName() {
        return sharedPrefs.getString(KEY_WEBDEVICE_NAME, null);
    }

    /**
     * @return The cache type used for filtering or ALL if no filter is active. Returns never null
     */
    public static CacheType getCacheType() {
        return CacheType.getById(sharedPrefs.getString(KEY_CACHE_TYPE, CacheType.ALL.id));
    }

    /**
     * The Threshold for the showing of child waypoints
     *
     * @return
     */

    public static int getWayPointsThreshold() {
        return sharedPrefs.getInt(KEY_SHOW_WAYPOINTS_THRESHOLD, 0);
    }

    public static void setShowWaypointsThreshold(final int threshold) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_SHOW_WAYPOINTS_THRESHOLD, threshold);
            }
        });
    }

    public static boolean isUseTwitter() {
        return sharedPrefs.getBoolean(KEY_USE_TWITTER, false);
    }

    public static void setUseTwitter(final boolean useTwitter) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_TWITTER, useTwitter);
            }
        });
    }

    public static boolean isTwitterLoginValid() {
        return !StringUtils.isBlank(getTokenPublic()) && !StringUtils.isBlank(getTokenSecret());
    }

    public static String getTokenPublic() {
        return sharedPrefs.getString(KEY_TWITTER_TOKEN_PUBLIC, null);
    }

    public static String getTokenSecret() {
        return sharedPrefs.getString(KEY_TWITTER_TOKEN_SECRET, null);

    }

    public static int getVersion() {
        return sharedPrefs.getInt(KEY_VERSION, 0);
    }

    public static void setTwitterTokens(final String tokenPublic, final String tokenSecret, boolean enableTwitter) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_TWITTER_TOKEN_PUBLIC, tokenPublic);
                edit.putString(KEY_TWITTER_TOKEN_SECRET, tokenSecret);
                if (tokenPublic != null) {
                    edit.remove(KEY_TEMP_TOKEN_PUBLIC);
                    edit.remove(KEY_TEMP_TOKEN_SECRET);
                }
            }
        });
        setUseTwitter(enableTwitter);
    }

    public static void setTwitterTempTokens(final String tokenPublic, final String tokenSecret) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_TEMP_TOKEN_PUBLIC, tokenPublic);
                edit.putString(KEY_TEMP_TOKEN_SECRET, tokenSecret);
            }
        });
    }

    public static ImmutablePair<String, String> getTempToken() {
        String tokenPublic = sharedPrefs.getString(KEY_TEMP_TOKEN_PUBLIC, null);
        String tokenSecret = sharedPrefs.getString(KEY_TEMP_TOKEN_SECRET, null);
        return new ImmutablePair<String, String>(tokenPublic, tokenSecret);
    }

    public static void setVersion(final int version) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_VERSION, version);
            }
        });
    }

    public static boolean isOpenLastDetailsPage() {
        return sharedPrefs.getBoolean(KEY_OPEN_LAST_DETAILS_PAGE, false);
    }

    public static void setOpenLastDetailsPage(final boolean openLastPage) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_OPEN_LAST_DETAILS_PAGE, openLastPage);
            }
        });
    }

    public static int getLastDetailsPage() {
        return sharedPrefs.getInt(KEY_LAST_DETAILS_PAGE, 1);
    }

    public static void setLastDetailsPage(final int index) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_DETAILS_PAGE, index);
            }
        });
    }

    public static int getDefaultNavigationTool() {
        return sharedPrefs.getInt(KEY_DEFAULT_NAVIGATION_TOOL, NavigationAppsEnum.COMPASS.id);
    }

    public static void setDefaultNavigationTool(final int defaultNavigationTool) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_DEFAULT_NAVIGATION_TOOL, defaultNavigationTool);
            }
        });
    }

    public static int getDefaultNavigationTool2() {
        return sharedPrefs.getInt(KEY_DEFAULT_NAVIGATION_TOOL_2, NavigationAppsEnum.INTERNAL_MAP.id);
    }

    public static void setDefaultNavigationTool2(final int defaultNavigationTool) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_DEFAULT_NAVIGATION_TOOL_2, defaultNavigationTool);
            }
        });
    }

    public static Strategy getLiveMapStrategy() {
        return Strategy.getById(sharedPrefs.getInt(KEY_LIVE_MAP_STRATEGY, Strategy.AUTO.id));
    }

    public static void setLiveMapStrategy(final Strategy strategy) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LIVE_MAP_STRATEGY, strategy.id);
            }
        });
    }

    public static boolean isDebug() {
        return Log.isDebug();
    }

    public static void setDebug(final boolean debug) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_DEBUG, debug);
            }
        });
        Log.setDebugUnsaved(debug);
    }

    public static boolean getHideLiveMapHint() {
        return sharedPrefs.getBoolean(KEY_HIDE_LIVE_MAP_HINT, false);
    }

    public static void setHideLiveHint(final boolean hide) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_HIDE_LIVE_MAP_HINT, hide);
            }
        });
    }

    public static int getLiveMapHintShowCount() {
        return sharedPrefs.getInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, 0);
    }

    public static void setLiveMapHintShowCount(final int showCount) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, showCount);
            }
        });
    }

    public static boolean isDbOnSDCard() {
        return sharedPrefs.getBoolean(KEY_DB_ON_SDCARD, false);
    }

    public static void setDbOnSDCard(final boolean dbOnSDCard) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_DB_ON_SDCARD, dbOnSDCard);
            }
        });
    }

    public static String getGpxExportDir() {
        return sharedPrefs.getString(KEY_GPX_EXPORT_DIR, Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static void setGpxExportDir(final String gpxExportDir) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_GPX_EXPORT_DIR, gpxExportDir);
            }
        });
    }

    public static String getGpxImportDir() {
        return sharedPrefs.getString(KEY_GPX_IMPORT_DIR, Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static void setGpxImportDir(final String gpxImportDir) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_GPX_IMPORT_DIR, gpxImportDir);
            }
        });
    }

    public static boolean getShareAfterExport() {
        return sharedPrefs.getBoolean(KEY_SHARE_AFTER_EXPORT, true);
    }

    public static void setShareAfterExport(final boolean shareAfterExport) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SHARE_AFTER_EXPORT, shareAfterExport);
            }
        });
    }

    public static int getTrackableAction() {
        return sharedPrefs.getInt(KEY_LAST_TRACKABLE_ACTION, LogType.RETRIEVED_IT.id);
    }

    public static void setTrackableAction(final int trackableAction) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_TRACKABLE_ACTION, trackableAction);
            }
        });
    }

    public static String getCustomRenderThemeBaseFolder() {
        return sharedPrefs.getString(KEY_RENDER_THEME_BASE_FOLDER, "");
    }

    public static boolean setCustomRenderThemeBaseFolder(final String customRenderThemeBaseFolder) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_RENDER_THEME_BASE_FOLDER, customRenderThemeBaseFolder);
            }
        });
    }

    public static String getCustomRenderThemeFilePath() {
        return sharedPrefs.getString(KEY_RENDER_THEME_FILE_PATH, "");
    }

    public static void setCustomRenderThemeFile(final String customRenderThemeFile) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_RENDER_THEME_FILE_PATH, customRenderThemeFile);
            }
        });
    }

    public static File[] getMapThemeFiles() {

        File directory = new File(Settings.getCustomRenderThemeBaseFolder());

        List<File> result = new ArrayList<File>();

        FileUtils.listDir(result, directory, new ExtensionsBasedFileSelector(new String[] { "xml" }), null);

        return result.toArray(new File[result.size()]);
    }

    private static class ExtensionsBasedFileSelector extends FileSelector {

        private final String[] extensions;

        public ExtensionsBasedFileSelector(String[] extensions) {
            this.extensions = extensions;
        }

        @Override
        public boolean isSelected(File file) {
            String filename = file.getName();
            for (String ext : extensions) {
                if (StringUtils.endsWithIgnoreCase(filename, ext)) {
                    return true;
                }
            }
            return false;
        }

        @Override
        public boolean shouldEnd() {
            return false;
        }
    }

    public static String getPreferencesName() {
        // There is currently no Android API to get the file name of the shared preferences. Let's hardcode
        // it without needing a cgeoapplication instance.
        return "cgeo.geocaching_preferences";
    }

    public static boolean getPlainLogs() {
        return sharedPrefs.getBoolean(KEY_PLAIN_LOGS, false);
    }

    public static void setPlainLogs(final boolean plainLogs) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_PLAIN_LOGS, plainLogs);
            }
        });
    }

    public static boolean getUseNativeUa() {
        return sharedPrefs.getBoolean(KEY_NATIVE_UA, false);
    }

    public static void setUseNativeUa(final boolean useNativeUa) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_NATIVE_UA, useNativeUa);
            }
        });
    }
}
!@#$%
20190527_001156,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_a15628
package cgeo.geocaching;

import cgeo.geocaching.apps.cache.navi.NavigationAppFactory.NavigationAppsEnum;
import cgeo.geocaching.connector.gc.GCConstants;
import cgeo.geocaching.connector.gc.Login;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.LiveMapStrategy.Strategy;
import cgeo.geocaching.enumerations.LogType;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.maps.MapProviderFactory;
import cgeo.geocaching.maps.google.GoogleMapProvider;
import cgeo.geocaching.maps.interfaces.GeoPointImpl;
import cgeo.geocaching.maps.interfaces.MapProvider;
import cgeo.geocaching.maps.interfaces.MapSource;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider.OfflineMapSource;
import cgeo.geocaching.utils.CryptUtils;
import cgeo.geocaching.utils.FileUtils;
import cgeo.geocaching.utils.FileUtils.FileSelector;
import cgeo.geocaching.utils.Log;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.os.Environment;
import android.preference.PreferenceManager;

import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

/**
 * General c:geo preferences/settings set by the user
 */
public final class Settings {

    private static final String KEY_TEMP_TOKEN_SECRET = "temp-token-secret";
    private static final String KEY_TEMP_TOKEN_PUBLIC = "temp-token-public";
    private static final String KEY_HELP_SHOWN = "helper";
    private static final String KEY_ANYLONGITUDE = "anylongitude";
    private static final String KEY_ANYLATITUDE = "anylatitude";
    private static final String KEY_USE_OFFLINEMAPS = "offlinemaps";
    private static final String KEY_USE_OFFLINEWPMAPS = "offlinewpmaps";
    private static final String KEY_WEB_DEVICE_CODE = "webDeviceCode";
    private static final String KEY_WEBDEVICE_NAME = "webDeviceName";
    private static final String KEY_MAP_LIVE = "maplive";
    private static final String KEY_MAP_SOURCE = "mapsource";
    private static final String KEY_USE_TWITTER = "twitter";
    private static final String KEY_SHOW_ADDRESS = "showaddress";
    private static final String KEY_SHOW_CAPTCHA = "showcaptcha";
    private static final String KEY_MAP_TRAIL = "maptrail";
    private static final String KEY_LAST_MAP_ZOOM = "mapzoom";
    private static final String KEY_LAST_MAP_LAT = "maplat";
    private static final String KEY_LAST_MAP_LON = "maplon";
    private static final String KEY_LIVE_LIST = "livelist";
    private static final String KEY_METRIC_UNITS = "units";
    private static final String KEY_SKIN = "skin";
    private static final String KEY_LAST_USED_LIST = "lastlist";
    private static final String KEY_CACHE_TYPE = "cachetype";
    private static final String KEY_TWITTER_TOKEN_SECRET = "tokensecret";
    private static final String KEY_TWITTER_TOKEN_PUBLIC = "tokenpublic";
    private static final String KEY_VERSION = "version";
    private static final String KEY_LOAD_DESCRIPTION = "autoloaddesc";
    private static final String KEY_RATING_WANTED = "ratingwanted";
    private static final String KEY_ELEVATION_WANTED = "elevationwanted";
    private static final String KEY_FRIENDLOGS_WANTED = "friendlogswanted";
    private static final String KEY_USE_ENGLISH = "useenglish";
    private static final String KEY_USE_COMPASS = "usecompass";
    private static final String KEY_AUTO_VISIT_TRACKABLES = "trackautovisit";
    private static final String KEY_AUTO_INSERT_SIGNATURE = "sigautoinsert";
    private static final String KEY_ALTITUDE_CORRECTION = "altcorrection";
    private static final String KEY_USE_GOOGLE_NAVIGATION = "usegnav";
    private static final String KEY_STORE_LOG_IMAGES = "logimages";
    private static final String KEY_EXCLUDE_DISABLED = "excludedisabled";
    private static final String KEY_EXCLUDE_OWN = "excludemine";
    private static final String KEY_MAPFILE = "mfmapfile";
    private static final String KEY_SIGNATURE = "signature";
    private static final String KEY_GCVOTE_PASSWORD = "pass-vote";
    private static final String KEY_PASSWORD = "password";
    private static final String KEY_USERNAME = "username";
    private static final String KEY_MEMBER_STATUS = "memberstatus";
    private static final String KEY_COORD_INPUT_FORMAT = "coordinputformat";
    private static final String KEY_LOG_OFFLINE = "log_offline";
    private static final String KEY_LOAD_DIRECTION_IMG = "loaddirectionimg";
    private static final String KEY_GC_CUSTOM_DATE = "gccustomdate";
    private static final String KEY_SHOW_WAYPOINTS_THRESHOLD = "gcshowwaypointsthreshold";
    private static final String KEY_COOKIE_STORE = "cookiestore";
    private static final String KEY_OPEN_LAST_DETAILS_PAGE = "opendetailslastpage";
    private static final String KEY_LAST_DETAILS_PAGE = "lastdetailspage";
    private static final String KEY_DEFAULT_NAVIGATION_TOOL = "defaultNavigationTool";
    private static final String KEY_DEFAULT_NAVIGATION_TOOL_2 = "defaultNavigationTool2";
    private static final String KEY_LIVE_MAP_STRATEGY = "livemapstrategy";
    private static final String KEY_DEBUG = "debug";
    private static final String KEY_HIDE_LIVE_MAP_HINT = "hidelivemaphint";
    private static final String KEY_LIVE_MAP_HINT_SHOW_COUNT = "livemaphintshowcount";
    private static final String KEY_SETTINGS_VERSION = "settingsversion";
    private static final String KEY_DB_ON_SDCARD = "dbonsdcard";
    private static final String KEY_LAST_TRACKABLE_ACTION = "trackableaction";
    private static final String KEY_SHARE_AFTER_EXPORT = "shareafterexport";
    private static final String KEY_GPX_EXPORT_DIR = "gpxExportDir";
    private static final String KEY_RENDER_THEME_BASE_FOLDER = "renderthemepath";
    private static final String KEY_RENDER_THEME_FILE_PATH = "renderthemefile";
    private static final String KEY_GPX_IMPORT_DIR = "gpxImportDir";
    private static final String KEY_PLAIN_LOGS = "plainLogs";
    private static final String KEY_NATIVE_UA = "nativeUa";
    private static final String KEY_MAP_DIRECTORY = "mapDirectory";

    private final static int unitsMetric = 1;

    // twitter api keys
    private final static String keyConsumerPublic = CryptUtils.rot13("ESnsCvAv3kEupF1GCR3jGj");
    private final static String keyConsumerSecret = CryptUtils.rot13("7vQWceACV9umEjJucmlpFe9FCMZSeqIqfkQ2BnhV9x");

    private interface PrefRunnable {
        void edit(final Editor edit);
    }

    public enum coordInputFormatEnum {
        Plain,
        Deg,
        Min,
        Sec;

        static coordInputFormatEnum fromInt(int id) {
            final coordInputFormatEnum[] values = coordInputFormatEnum.values();
            if (id < 0 || id >= values.length) {
                return Min;
            }
            return values[id];
        }
    }

    private static String username = null;
    private static String password = null;

    private static final SharedPreferences sharedPrefs = PreferenceManager.getDefaultSharedPreferences(cgeoapplication.getInstance().getBaseContext());
    static {
        migrateSettings();
        Log.setDebugUnsaved(sharedPrefs.getBoolean(KEY_DEBUG, false));
    }

    // maps
    private static MapProvider mapProvider = null;

    private Settings() {
        // this class is not to be instantiated;
    }

    private static void migrateSettings() {
        // migrate from non standard file location and integer based boolean types
        if (sharedPrefs.getInt(KEY_SETTINGS_VERSION, 0) < 1) {
            final String oldPreferencesName = "cgeo.pref";
            final SharedPreferences old = cgeoapplication.getInstance().getSharedPreferences(oldPreferencesName, Context.MODE_PRIVATE);
            final Editor e = sharedPrefs.edit();

            e.putString(KEY_TEMP_TOKEN_SECRET, old.getString(KEY_TEMP_TOKEN_SECRET, null));
            e.putString(KEY_TEMP_TOKEN_PUBLIC, old.getString(KEY_TEMP_TOKEN_PUBLIC, null));
            e.putBoolean(KEY_HELP_SHOWN, old.getInt(KEY_HELP_SHOWN, 0) != 0);
            e.putFloat(KEY_ANYLONGITUDE, old.getFloat(KEY_ANYLONGITUDE, 0));
            e.putFloat(KEY_ANYLATITUDE, old.getFloat(KEY_ANYLATITUDE, 0));
            e.putBoolean(KEY_USE_OFFLINEMAPS, 0 != old.getInt(KEY_USE_OFFLINEMAPS, 1));
            e.putBoolean(KEY_USE_OFFLINEWPMAPS, 0 != old.getInt(KEY_USE_OFFLINEWPMAPS, 0));
            e.putString(KEY_WEB_DEVICE_CODE, old.getString(KEY_WEB_DEVICE_CODE, null));
            e.putString(KEY_WEBDEVICE_NAME, old.getString(KEY_WEBDEVICE_NAME, null));
            e.putBoolean(KEY_MAP_LIVE, old.getInt(KEY_MAP_LIVE, 1) != 0);
            e.putInt(KEY_MAP_SOURCE, old.getInt(KEY_MAP_SOURCE, 0));
            e.putBoolean(KEY_USE_TWITTER, 0 != old.getInt(KEY_USE_TWITTER, 0));
            e.putBoolean(KEY_SHOW_ADDRESS, 0 != old.getInt(KEY_SHOW_ADDRESS, 1));
            e.putBoolean(KEY_SHOW_CAPTCHA, old.getBoolean(KEY_SHOW_CAPTCHA, false));
            e.putBoolean(KEY_MAP_TRAIL, old.getInt(KEY_MAP_TRAIL, 1) != 0);
            e.putInt(KEY_LAST_MAP_ZOOM, old.getInt(KEY_LAST_MAP_ZOOM, 14));
            e.putBoolean(KEY_LIVE_LIST, 0 != old.getInt(KEY_LIVE_LIST, 1));
            e.putBoolean(KEY_METRIC_UNITS, old.getInt(KEY_METRIC_UNITS, unitsMetric) == unitsMetric);
            e.putBoolean(KEY_SKIN, old.getInt(KEY_SKIN, 0) != 0);
            e.putInt(KEY_LAST_USED_LIST, old.getInt(KEY_LAST_USED_LIST, StoredList.STANDARD_LIST_ID));
            e.putString(KEY_CACHE_TYPE, old.getString(KEY_CACHE_TYPE, CacheType.ALL.id));
            e.putString(KEY_TWITTER_TOKEN_SECRET, old.getString(KEY_TWITTER_TOKEN_SECRET, null));
            e.putString(KEY_TWITTER_TOKEN_PUBLIC, old.getString(KEY_TWITTER_TOKEN_PUBLIC, null));
            e.putInt(KEY_VERSION, old.getInt(KEY_VERSION, 0));
            e.putBoolean(KEY_LOAD_DESCRIPTION, 0 != old.getInt(KEY_LOAD_DESCRIPTION, 0));
            e.putBoolean(KEY_RATING_WANTED, old.getBoolean(KEY_RATING_WANTED, true));
            e.putBoolean(KEY_ELEVATION_WANTED, old.getBoolean(KEY_ELEVATION_WANTED, true));
            e.putBoolean(KEY_FRIENDLOGS_WANTED, old.getBoolean(KEY_FRIENDLOGS_WANTED, true));
            e.putBoolean(KEY_USE_ENGLISH, old.getBoolean(KEY_USE_ENGLISH, false));
            e.putBoolean(KEY_USE_COMPASS, 0 != old.getInt(KEY_USE_COMPASS, 1));
            e.putBoolean(KEY_AUTO_VISIT_TRACKABLES, old.getBoolean(KEY_AUTO_VISIT_TRACKABLES, false));
            e.putBoolean(KEY_AUTO_INSERT_SIGNATURE, old.getBoolean(KEY_AUTO_INSERT_SIGNATURE, false));
            e.putInt(KEY_ALTITUDE_CORRECTION, old.getInt(KEY_ALTITUDE_CORRECTION, 0));
            e.putBoolean(KEY_USE_GOOGLE_NAVIGATION, 0 != old.getInt(KEY_USE_GOOGLE_NAVIGATION, 1));
            e.putBoolean(KEY_STORE_LOG_IMAGES, old.getBoolean(KEY_STORE_LOG_IMAGES, false));
            e.putBoolean(KEY_EXCLUDE_DISABLED, 0 != old.getInt(KEY_EXCLUDE_DISABLED, 0));
            e.putBoolean(KEY_EXCLUDE_OWN, 0 != old.getInt(KEY_EXCLUDE_OWN, 0));
            e.putString(KEY_MAPFILE, old.getString(KEY_MAPFILE, null));
            e.putString(KEY_SIGNATURE, old.getString(KEY_SIGNATURE, null));
            e.putString(KEY_GCVOTE_PASSWORD, old.getString(KEY_GCVOTE_PASSWORD, null));
            e.putString(KEY_PASSWORD, old.getString(KEY_PASSWORD, null));
            e.putString(KEY_USERNAME, old.getString(KEY_USERNAME, null));
            e.putString(KEY_MEMBER_STATUS, old.getString(KEY_MEMBER_STATUS, ""));
            e.putInt(KEY_COORD_INPUT_FORMAT, old.getInt(KEY_COORD_INPUT_FORMAT, 0));
            e.putBoolean(KEY_LOG_OFFLINE, old.getBoolean(KEY_LOG_OFFLINE, false));
            e.putBoolean(KEY_LOAD_DIRECTION_IMG, old.getBoolean(KEY_LOAD_DIRECTION_IMG, true));
            e.putString(KEY_GC_CUSTOM_DATE, old.getString(KEY_GC_CUSTOM_DATE, null));
            e.putInt(KEY_SHOW_WAYPOINTS_THRESHOLD, old.getInt(KEY_SHOW_WAYPOINTS_THRESHOLD, 0));
            e.putString(KEY_COOKIE_STORE, old.getString(KEY_COOKIE_STORE, null));
            e.putBoolean(KEY_OPEN_LAST_DETAILS_PAGE, old.getBoolean(KEY_OPEN_LAST_DETAILS_PAGE, false));
            e.putInt(KEY_LAST_DETAILS_PAGE, old.getInt(KEY_LAST_DETAILS_PAGE, 1));
            e.putInt(KEY_DEFAULT_NAVIGATION_TOOL, old.getInt(KEY_DEFAULT_NAVIGATION_TOOL, NavigationAppsEnum.COMPASS.id));
            e.putInt(KEY_DEFAULT_NAVIGATION_TOOL_2, old.getInt(KEY_DEFAULT_NAVIGATION_TOOL_2, NavigationAppsEnum.INTERNAL_MAP.id));
            e.putInt(KEY_LIVE_MAP_STRATEGY, old.getInt(KEY_LIVE_MAP_STRATEGY, Strategy.AUTO.id));
            e.putBoolean(KEY_DEBUG, old.getBoolean(KEY_DEBUG, false));
            e.putBoolean(KEY_HIDE_LIVE_MAP_HINT, old.getInt(KEY_HIDE_LIVE_MAP_HINT, 0) != 0);
            e.putInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, old.getInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, 0));

            e.putInt(KEY_SETTINGS_VERSION, 1); // mark migrated
            e.commit();
        }
    }

    public static void setLanguage(boolean useEnglish) {
        final Configuration config = new Configuration();
        config.locale = useEnglish ? new Locale("en") : Locale.getDefault();
        final Resources resources = cgeoapplication.getInstance().getResources();
        resources.updateConfiguration(config, resources.getDisplayMetrics());
    }

    public static boolean isLogin() {
        final String preUsername = sharedPrefs.getString(KEY_USERNAME, null);
        final String prePassword = sharedPrefs.getString(KEY_PASSWORD, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    /**
     * Get login and password information.
     *
     * @return a pair (login, password) or null if no valid information is stored
     */
    public static ImmutablePair<String, String> getLogin() {
        if (username == null || password == null) {
            final String preUsername = sharedPrefs.getString(KEY_USERNAME, null);
            final String prePassword = sharedPrefs.getString(KEY_PASSWORD, null);

            if (preUsername == null || prePassword == null) {
                return null;
            }

            username = preUsername;
            password = prePassword;
        }
        return new ImmutablePair<String, String>(username, password);
    }

    public static String getUsername() {
        return username != null ? username : sharedPrefs.getString(KEY_USERNAME, null);
    }

    public static boolean setLogin(final String username, final String password) {
        Settings.username = username;
        Settings.password = password;
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
                    // erase username and password
                    edit.remove(KEY_USERNAME);
                    edit.remove(KEY_PASSWORD);
                } else {
                    // save username and password
                    edit.putString(KEY_USERNAME, username);
                    edit.putString(KEY_PASSWORD, password);
                }
            }
        });
    }

    public static boolean isPremiumMember() {
        // Basic Member, Premium Member, ???
        String memberStatus = Settings.getMemberStatus();
        if (memberStatus == null) {
            return false;
        }
        return GCConstants.MEMBER_STATUS_PM.equalsIgnoreCase(memberStatus);
    }

    public static String getMemberStatus() {
        return sharedPrefs.getString(KEY_MEMBER_STATUS, "");
    }

    public static boolean setMemberStatus(final String memberStatus) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(memberStatus)) {
                    edit.remove(KEY_MEMBER_STATUS);
                } else {
                    edit.putString(KEY_MEMBER_STATUS, memberStatus);
                }
            }
        });
    }

    public static boolean isGCvoteLogin() {
        final String preUsername = sharedPrefs.getString(KEY_USERNAME, null);
        final String prePassword = sharedPrefs.getString(KEY_GCVOTE_PASSWORD, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    public static boolean setGCvoteLogin(final String password) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(password)) {
                    // erase password
                    edit.remove(KEY_GCVOTE_PASSWORD);
                } else {
                    // save password
                    edit.putString(KEY_GCVOTE_PASSWORD, password);
                }
            }
        });
    }

    public static ImmutablePair<String, String> getGCvoteLogin() {
        final String username = sharedPrefs.getString(KEY_USERNAME, null);
        final String password = sharedPrefs.getString(KEY_GCVOTE_PASSWORD, null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return null;
        }

        return new ImmutablePair<String, String>(username, password);
    }

    public static boolean setSignature(final String signature) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(signature)) {
                    // erase signature
                    edit.remove(KEY_SIGNATURE);
                } else {
                    // save signature
                    edit.putString(KEY_SIGNATURE, signature);
                }
            }
        });
    }

    public static String getSignature() {
        return sharedPrefs.getString(KEY_SIGNATURE, null);
    }

    public static boolean setCookieStore(final String cookies) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(final Editor edit) {
                if (StringUtils.isBlank(cookies)) {
                    // erase cookies
                    edit.remove(KEY_COOKIE_STORE);
                } else {
                    // save cookies
                    edit.putString(KEY_COOKIE_STORE, cookies);
                }
            }
        });
    }

    public static String getCookieStore() {
        return sharedPrefs.getString(KEY_COOKIE_STORE, null);
    }

    /**
     * @param cacheType
     *            The cache type used for future filtering
     */
    public static void setCacheType(final CacheType cacheType) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                if (cacheType == null) {
                    edit.remove(KEY_CACHE_TYPE);
                } else {
                    edit.putString(KEY_CACHE_TYPE, cacheType.id);
                }
            }
        });
    }

    public static void setLiveMap(final boolean live) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_MAP_LIVE, live);
            }
        });
    }

    public static int getLastList() {
        return sharedPrefs.getInt(KEY_LAST_USED_LIST, StoredList.STANDARD_LIST_ID);
    }

    public static void saveLastList(final int listId) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_USED_LIST, listId);
            }
        });
    }

    public static void setWebNameCode(final String name, final String code) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {

                edit.putString(KEY_WEBDEVICE_NAME, name);
                edit.putString(KEY_WEB_DEVICE_CODE, code);
            }
        });
    }

    public static MapProvider getMapProvider() {
        if (mapProvider == null) {
            mapProvider = getMapSource().getMapProvider();
        }
        return mapProvider;
    }

    public static String getMapFile() {
        return sharedPrefs.getString(KEY_MAPFILE, null);
    }

    public static boolean setMapFile(final String mapFile) {
        boolean result = editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_MAPFILE, mapFile);
            }
        });
        if (mapFile != null) {
            setMapFileDirectory(new File(mapFile).getParent());
        }
        return result;
    }

    public static String getMapFileDirectory() {
        final String mapDir = sharedPrefs.getString(KEY_MAP_DIRECTORY, null);
        if (mapDir != null) {
            return mapDir;
        }
        final String mapFile = getMapFile();
        if (mapFile != null) {
            return new File(mapFile).getParent();
        }
        return null;
    }

    public static boolean setMapFileDirectory(final String mapFileDirectory) {
        return editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_MAP_DIRECTORY, mapFileDirectory);
                MapsforgeMapProvider.getInstance().updateOfflineMaps();
            }
        });
    }

    public static boolean isValidMapFile() {
        return isValidMapFile(getMapFile());
    }

    public static boolean isValidMapFile(final String mapFileIn) {
        return MapsforgeMapProvider.isValidMapFile(mapFileIn);
    }

    public static coordInputFormatEnum getCoordInputFormat() {
        return coordInputFormatEnum.fromInt(sharedPrefs.getInt(KEY_COORD_INPUT_FORMAT, 0));
    }

    public static void setCoordInputFormat(final coordInputFormatEnum format) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_COORD_INPUT_FORMAT, format.ordinal());
            }
        });
    }

    static void setLogOffline(final boolean offline) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LOG_OFFLINE, offline);
            }
        });
    }

    public static boolean getLogOffline() {
        return sharedPrefs.getBoolean(KEY_LOG_OFFLINE, false);
    }

    static void setLoadDirImg(final boolean value) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LOAD_DIRECTION_IMG, value);
            }
        });
    }

    public static boolean getLoadDirImg() {
        return !isPremiumMember() && sharedPrefs.getBoolean(KEY_LOAD_DIRECTION_IMG, true);
    }

    public static void setGcCustomDate(final String format) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_GC_CUSTOM_DATE, format);
            }
        });
    }

    /**
     * @return User selected date format on GC.com
     * @see Login#gcCustomDateFormats
     */
    public static String getGcCustomDate() {
        return sharedPrefs.getString(KEY_GC_CUSTOM_DATE, null);
    }

    public static boolean isExcludeMyCaches() {
        return sharedPrefs.getBoolean(KEY_EXCLUDE_OWN, false);
    }

    /**
     * edit some settings without knowing how to get the settings editor or how to commit
     *
     * @param runnable
     * @return
     */
    private static boolean editSharedSettings(final PrefRunnable runnable) {
        final SharedPreferences.Editor prefsEdit = sharedPrefs.edit();
        runnable.edit(prefsEdit);
        return prefsEdit.commit();
    }

    public static void setExcludeMine(final boolean exclude) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_EXCLUDE_OWN, exclude);
            }
        });
    }

    public static void setUseEnglish(final boolean english) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_ENGLISH, english);
                setLanguage(english);
            }
        });
    }

    public static boolean isUseEnglish() {
        return sharedPrefs.getBoolean(KEY_USE_ENGLISH, false);
    }

    public static boolean isShowAddress() {
        return sharedPrefs.getBoolean(KEY_SHOW_ADDRESS, true);
    }

    public static void setShowAddress(final boolean showAddress) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SHOW_ADDRESS, showAddress);
            }
        });
    }

    public static boolean isShowCaptcha() {
        return !isPremiumMember() && sharedPrefs.getBoolean(KEY_SHOW_CAPTCHA, false);
    }

    public static void setShowCaptcha(final boolean showCaptcha) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SHOW_CAPTCHA, showCaptcha);
            }
        });
    }

    public static boolean isExcludeDisabledCaches() {
        return sharedPrefs.getBoolean(KEY_EXCLUDE_DISABLED, false);
    }

    public static void setExcludeDisabledCaches(final boolean exclude) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_EXCLUDE_DISABLED, exclude);
            }
        });
    }

    public static boolean isStoreOfflineMaps() {
        return sharedPrefs.getBoolean(KEY_USE_OFFLINEMAPS, true);
    }

    public static void setStoreOfflineMaps(final boolean offlineMaps) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_OFFLINEMAPS, offlineMaps);
            }
        });
    }

    public static boolean isStoreOfflineWpMaps() {
        return sharedPrefs.getBoolean(KEY_USE_OFFLINEWPMAPS, false);
    }

    public static void setStoreOfflineWpMaps(final boolean offlineMaps) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_OFFLINEWPMAPS, offlineMaps);
            }
        });
    }

    public static boolean isStoreLogImages() {
        return sharedPrefs.getBoolean(KEY_STORE_LOG_IMAGES, false);
    }

    public static void setStoreLogImages(final boolean storeLogImages) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_STORE_LOG_IMAGES, storeLogImages);
            }
        });
    }

    public static boolean isUseGoogleNavigation() {
        return sharedPrefs.getBoolean(KEY_USE_GOOGLE_NAVIGATION, true);
    }

    public static void setUseGoogleNavigation(final boolean useGoogleNavigation) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_GOOGLE_NAVIGATION, useGoogleNavigation);
            }
        });
    }

    public static boolean isAutoLoadDescription() {
        return sharedPrefs.getBoolean(KEY_LOAD_DESCRIPTION, false);
    }

    public static void setAutoLoadDesc(final boolean autoLoad) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LOAD_DESCRIPTION, autoLoad);
            }
        });
    }

    public static boolean isRatingWanted() {
        return sharedPrefs.getBoolean(KEY_RATING_WANTED, true);
    }

    public static void setRatingWanted(final boolean ratingWanted) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_RATING_WANTED, ratingWanted);
            }
        });
    }

    public static boolean isElevationWanted() {
        return sharedPrefs.getBoolean(KEY_ELEVATION_WANTED, true);
    }

    public static void setElevationWanted(final boolean elevationWanted) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_ELEVATION_WANTED, elevationWanted);
            }
        });
    }

    public static boolean isFriendLogsWanted() {
        if (!isLogin()) {
            // don't show a friends log if the user is anonymous
            return false;
        }
        return sharedPrefs.getBoolean(KEY_FRIENDLOGS_WANTED, true);
    }

    public static void setFriendLogsWanted(final boolean friendLogsWanted) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_FRIENDLOGS_WANTED, friendLogsWanted);
            }
        });
    }

    public static boolean isLiveList() {
        return sharedPrefs.getBoolean(KEY_LIVE_LIST, true);
    }

    public static void setLiveList(final boolean liveList) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LIVE_LIST, liveList);
            }
        });
    }

    public static boolean isTrackableAutoVisit() {
        return sharedPrefs.getBoolean(KEY_AUTO_VISIT_TRACKABLES, false);
    }

    public static void setTrackableAutoVisit(final boolean autoVisit) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_AUTO_VISIT_TRACKABLES, autoVisit);
            }
        });
    }

    public static boolean isAutoInsertSignature() {
        return sharedPrefs.getBoolean(KEY_AUTO_INSERT_SIGNATURE, false);
    }

    public static void setAutoInsertSignature(final boolean autoInsert) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_AUTO_INSERT_SIGNATURE, autoInsert);
            }
        });
    }

    public static boolean isUseMetricUnits() {
        return sharedPrefs.getBoolean(KEY_METRIC_UNITS, true);
    }

    public static void setUseMetricUnits(final boolean metric) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_METRIC_UNITS, metric);
            }
        });
    }

    public static boolean isLiveMap() {
        return sharedPrefs.getBoolean(KEY_MAP_LIVE, true);
    }

    public static boolean isMapTrail() {
        return sharedPrefs.getBoolean(KEY_MAP_TRAIL, true);
    }

    public static void setMapTrail(final boolean showTrail) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_MAP_TRAIL, showTrail);
            }
        });
    }

    public static int getMapZoom() {
        return sharedPrefs.getInt(KEY_LAST_MAP_ZOOM, 14);
    }

    public static void setMapZoom(final int mapZoomLevel) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_MAP_ZOOM, mapZoomLevel);
            }
        });
    }

    public static GeoPointImpl getMapCenter() {
        return getMapProvider().getMapItemFactory()
                .getGeoPointBase(new Geopoint(sharedPrefs.getInt(KEY_LAST_MAP_LAT, 0) / 1e6,
                        sharedPrefs.getInt(KEY_LAST_MAP_LON, 0) / 1e6));
    }

    public static void setMapCenter(final GeoPointImpl mapViewCenter) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_MAP_LAT, mapViewCenter.getLatitudeE6());
                edit.putInt(KEY_LAST_MAP_LON, mapViewCenter.getLongitudeE6());
            }
        });
    }

    public static MapSource getMapSource() {
        final int id = getConvertedMapId();
        final MapSource map = MapProviderFactory.getMapSource(id);
        if (map != null) {
            // don't use offline maps if the map file is not valid
            if ((!(map instanceof OfflineMapSource)) || (isValidMapFile())) {
                return map;
            }
        }
        // fallback to first available map
        return MapProviderFactory.getDefaultSource();
    }

    private final static int GOOGLEMAP_BASEID = 30;
    private final static int MAP = 1;
    private final static int SATELLITE = 2;

    private final static int MFMAP_BASEID = 40;
    private final static int MAPNIK = 1;
    private final static int CYCLEMAP = 3;
    private final static int OFFLINE = 4;

    /**
     * convert old preference ids for maps (based on constant values) into new hash based ids
     *
     * @return
     */
    private static int getConvertedMapId() {
        final int id = sharedPrefs.getInt(KEY_MAP_SOURCE, 0);
        switch (id) {
            case GOOGLEMAP_BASEID + MAP:
                return GoogleMapProvider.GOOGLE_MAP_ID.hashCode();
            case GOOGLEMAP_BASEID + SATELLITE:
                return GoogleMapProvider.GOOGLE_SATELLITE_ID.hashCode();
            case MFMAP_BASEID + MAPNIK:
                return MapsforgeMapProvider.MAPSFORGE_MAPNIK_ID.hashCode();
            case MFMAP_BASEID + CYCLEMAP:
                return MapsforgeMapProvider.MAPSFORGE_CYCLEMAP_ID.hashCode();
            case MFMAP_BASEID + OFFLINE: {
                final String mapFile = Settings.getMapFile();
                if (StringUtils.isNotEmpty(mapFile)) {
                    return mapFile.hashCode();
                }
                break;
            }
            default:
                break;
        }
        return id;
    }

    public static void setMapSource(final MapSource newMapSource) {
        if (!MapProviderFactory.isSameActivity(getMapSource(), newMapSource)) {
            mapProvider = null;
        }
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_MAP_SOURCE, newMapSource.getNumericalId());
            }
        });
        if (newMapSource instanceof OfflineMapSource) {
            setMapFile(((OfflineMapSource) newMapSource).getFileName());
        }
    }

    public static void setAnyCoordinates(final Geopoint coords) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (null != coords) {
                    edit.putFloat(KEY_ANYLATITUDE, (float) coords.getLatitude());
                    edit.putFloat(KEY_ANYLONGITUDE, (float) coords.getLongitude());
                } else {
                    edit.remove(KEY_ANYLATITUDE);
                    edit.remove(KEY_ANYLONGITUDE);
                }
            }
        });

    }

    public static Geopoint getAnyCoordinates() {
        if (sharedPrefs.contains(KEY_ANYLATITUDE) && sharedPrefs.contains(KEY_ANYLONGITUDE)) {
            float lat = sharedPrefs.getFloat(KEY_ANYLATITUDE, 0);
            float lon = sharedPrefs.getFloat(KEY_ANYLONGITUDE, 0);
            return new Geopoint(lat, lon);
        }
        return null;
    }

    public static boolean isUseCompass() {
        return sharedPrefs.getBoolean(KEY_USE_COMPASS, true);
    }

    public static void setUseCompass(final boolean useCompass) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_COMPASS, useCompass);
            }
        });
    }

    public static boolean isHelpShown() {
        return sharedPrefs.getBoolean(KEY_HELP_SHOWN, false);
    }

    public static void setHelpShown() {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_HELP_SHOWN, true);
            }
        });
    }

    public static boolean isLightSkin() {
        return sharedPrefs.getBoolean(KEY_SKIN, false);
    }

    public static void setLightSkin(final boolean lightSkin) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SKIN, lightSkin);
            }
        });
    }

    public static String getKeyConsumerPublic() {
        return keyConsumerPublic;
    }

    public static String getKeyConsumerSecret() {
        return keyConsumerSecret;
    }

    public static int getAltCorrection() {
        return sharedPrefs.getInt(KEY_ALTITUDE_CORRECTION, 0);
    }

    public static boolean setAltCorrection(final int altitude) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_ALTITUDE_CORRECTION, altitude);
            }
        });
    }

    public static String getWebDeviceCode() {
        return sharedPrefs.getString(KEY_WEB_DEVICE_CODE, null);
    }

    public static String getWebDeviceName() {
        return sharedPrefs.getString(KEY_WEBDEVICE_NAME, null);
    }

    /**
     * @return The cache type used for filtering or ALL if no filter is active. Returns never null
     */
    public static CacheType getCacheType() {
        return CacheType.getById(sharedPrefs.getString(KEY_CACHE_TYPE, CacheType.ALL.id));
    }

    /**
     * The Threshold for the showing of child waypoints
     *
     * @return
     */

    public static int getWayPointsThreshold() {
        return sharedPrefs.getInt(KEY_SHOW_WAYPOINTS_THRESHOLD, 0);
    }

    public static void setShowWaypointsThreshold(final int threshold) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_SHOW_WAYPOINTS_THRESHOLD, threshold);
            }
        });
    }

    public static boolean isUseTwitter() {
        return sharedPrefs.getBoolean(KEY_USE_TWITTER, false);
    }

    public static void setUseTwitter(final boolean useTwitter) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_TWITTER, useTwitter);
            }
        });
    }

    public static boolean isTwitterLoginValid() {
        return !StringUtils.isBlank(getTokenPublic()) && !StringUtils.isBlank(getTokenSecret());
    }

    public static String getTokenPublic() {
        return sharedPrefs.getString(KEY_TWITTER_TOKEN_PUBLIC, null);
    }

    public static String getTokenSecret() {
        return sharedPrefs.getString(KEY_TWITTER_TOKEN_SECRET, null);

    }

    public static int getVersion() {
        return sharedPrefs.getInt(KEY_VERSION, 0);
    }

    public static void setTwitterTokens(final String tokenPublic, final String tokenSecret, boolean enableTwitter) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_TWITTER_TOKEN_PUBLIC, tokenPublic);
                edit.putString(KEY_TWITTER_TOKEN_SECRET, tokenSecret);
                if (tokenPublic != null) {
                    edit.remove(KEY_TEMP_TOKEN_PUBLIC);
                    edit.remove(KEY_TEMP_TOKEN_SECRET);
                }
            }
        });
        setUseTwitter(enableTwitter);
    }

    public static void setTwitterTempTokens(final String tokenPublic, final String tokenSecret) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_TEMP_TOKEN_PUBLIC, tokenPublic);
                edit.putString(KEY_TEMP_TOKEN_SECRET, tokenSecret);
            }
        });
    }

    public static ImmutablePair<String, String> getTempToken() {
        String tokenPublic = sharedPrefs.getString(KEY_TEMP_TOKEN_PUBLIC, null);
        String tokenSecret = sharedPrefs.getString(KEY_TEMP_TOKEN_SECRET, null);
        return new ImmutablePair<String, String>(tokenPublic, tokenSecret);
    }

    public static void setVersion(final int version) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_VERSION, version);
            }
        });
    }

    public static boolean isOpenLastDetailsPage() {
        return sharedPrefs.getBoolean(KEY_OPEN_LAST_DETAILS_PAGE, false);
    }

    public static void setOpenLastDetailsPage(final boolean openLastPage) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_OPEN_LAST_DETAILS_PAGE, openLastPage);
            }
        });
    }

    public static int getLastDetailsPage() {
        return sharedPrefs.getInt(KEY_LAST_DETAILS_PAGE, 1);
    }

    public static void setLastDetailsPage(final int index) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_DETAILS_PAGE, index);
            }
        });
    }

    public static int getDefaultNavigationTool() {
        return sharedPrefs.getInt(KEY_DEFAULT_NAVIGATION_TOOL, NavigationAppsEnum.COMPASS.id);
    }

    public static void setDefaultNavigationTool(final int defaultNavigationTool) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_DEFAULT_NAVIGATION_TOOL, defaultNavigationTool);
            }
        });
    }

    public static int getDefaultNavigationTool2() {
        return sharedPrefs.getInt(KEY_DEFAULT_NAVIGATION_TOOL_2, NavigationAppsEnum.INTERNAL_MAP.id);
    }

    public static void setDefaultNavigationTool2(final int defaultNavigationTool) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_DEFAULT_NAVIGATION_TOOL_2, defaultNavigationTool);
            }
        });
    }

    public static Strategy getLiveMapStrategy() {
        return Strategy.getById(sharedPrefs.getInt(KEY_LIVE_MAP_STRATEGY, Strategy.AUTO.id));
    }

    public static void setLiveMapStrategy(final Strategy strategy) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LIVE_MAP_STRATEGY, strategy.id);
            }
        });
    }

    public static boolean isDebug() {
        return Log.isDebug();
    }

    public static void setDebug(final boolean debug) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_DEBUG, debug);
            }
        });
        Log.setDebugUnsaved(debug);
    }

    public static boolean getHideLiveMapHint() {
        return sharedPrefs.getBoolean(KEY_HIDE_LIVE_MAP_HINT, false);
    }

    public static void setHideLiveHint(final boolean hide) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_HIDE_LIVE_MAP_HINT, hide);
            }
        });
    }

    public static int getLiveMapHintShowCount() {
        return sharedPrefs.getInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, 0);
    }

    public static void setLiveMapHintShowCount(final int showCount) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, showCount);
            }
        });
    }

    public static boolean isDbOnSDCard() {
        return sharedPrefs.getBoolean(KEY_DB_ON_SDCARD, false);
    }

    public static void setDbOnSDCard(final boolean dbOnSDCard) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_DB_ON_SDCARD, dbOnSDCard);
            }
        });
    }

    public static String getGpxExportDir() {
        return sharedPrefs.getString(KEY_GPX_EXPORT_DIR, Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static void setGpxExportDir(final String gpxExportDir) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_GPX_EXPORT_DIR, gpxExportDir);
            }
        });
    }

    public static String getGpxImportDir() {
        return sharedPrefs.getString(KEY_GPX_IMPORT_DIR, Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static void setGpxImportDir(final String gpxImportDir) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_GPX_IMPORT_DIR, gpxImportDir);
            }
        });
    }

    public static boolean getShareAfterExport() {
        return sharedPrefs.getBoolean(KEY_SHARE_AFTER_EXPORT, true);
    }

    public static void setShareAfterExport(final boolean shareAfterExport) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SHARE_AFTER_EXPORT, shareAfterExport);
            }
        });
    }

    public static int getTrackableAction() {
        return sharedPrefs.getInt(KEY_LAST_TRACKABLE_ACTION, LogType.RETRIEVED_IT.id);
    }

    public static void setTrackableAction(final int trackableAction) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_TRACKABLE_ACTION, trackableAction);
            }
        });
    }

    public static String getCustomRenderThemeBaseFolder() {
        return sharedPrefs.getString(KEY_RENDER_THEME_BASE_FOLDER, "");
    }

    public static boolean setCustomRenderThemeBaseFolder(final String customRenderThemeBaseFolder) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_RENDER_THEME_BASE_FOLDER, customRenderThemeBaseFolder);
            }
        });
    }

    public static String getCustomRenderThemeFilePath() {
        return sharedPrefs.getString(KEY_RENDER_THEME_FILE_PATH, "");
    }

    public static void setCustomRenderThemeFile(final String customRenderThemeFile) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_RENDER_THEME_FILE_PATH, customRenderThemeFile);
            }
        });
    }

    public static File[] getMapThemeFiles() {

        File directory = new File(Settings.getCustomRenderThemeBaseFolder());

        List<File> result = new ArrayList<File>();

        FileUtils.listDir(result, directory, new ExtensionsBasedFileSelector(new String[] { "xml" }), null);

        return result.toArray(new File[] {});
    }

    private static class ExtensionsBasedFileSelector extends FileSelector {

        private final String[] extensions;

        public ExtensionsBasedFileSelector(String[] extensions) {
            this.extensions = extensions;
        }

        @Override
        public boolean isSelected(File file) {
            String filename = file.getName();
            for (String ext : extensions) {
                if (StringUtils.endsWithIgnoreCase(filename, ext)) {
                    return true;
                }
            }
            return false;
        }

        @Override
        public boolean shouldEnd() {
            return false;
        }
    }

    public static String getPreferencesName() {
        // There is currently no Android API to get the file name of the shared preferences. Let's hardcode
        // it without needing a cgeoapplication instance.
        return "cgeo.geocaching_preferences";
    }

    public static boolean getPlainLogs() {
        return sharedPrefs.getBoolean(KEY_PLAIN_LOGS, false);
    }

    public static void setPlainLogs(final boolean plainLogs) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_PLAIN_LOGS, plainLogs);
            }
        });
    }

    public static boolean getUseNativeUa() {
        return sharedPrefs.getBoolean(KEY_NATIVE_UA, false);
    }

    public static void setUseNativeUa(final boolean useNativeUa) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_NATIVE_UA, useNativeUa);
            }
        });
    }
}
!@#$%
20190527_001156,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_c15628
package cgeo.geocaching;

import cgeo.geocaching.apps.cache.navi.NavigationAppFactory.NavigationAppsEnum;
import cgeo.geocaching.connector.gc.GCConstants;
import cgeo.geocaching.connector.gc.Login;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.LiveMapStrategy.Strategy;
import cgeo.geocaching.enumerations.LogType;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.maps.MapProviderFactory;
import cgeo.geocaching.maps.google.GoogleMapProvider;
import cgeo.geocaching.maps.interfaces.GeoPointImpl;
import cgeo.geocaching.maps.interfaces.MapProvider;
import cgeo.geocaching.maps.interfaces.MapSource;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider.OfflineMapSource;
import cgeo.geocaching.utils.CryptUtils;
import cgeo.geocaching.utils.FileUtils;
import cgeo.geocaching.utils.FileUtils.FileSelector;
import cgeo.geocaching.utils.Log;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.os.Environment;
import android.preference.PreferenceManager;

import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

/**
 * General c:geo preferences/settings set by the user
 */
public final class Settings {

    private static final String KEY_TEMP_TOKEN_SECRET = "temp-token-secret";
    private static final String KEY_TEMP_TOKEN_PUBLIC = "temp-token-public";
    private static final String KEY_HELP_SHOWN = "helper";
    private static final String KEY_ANYLONGITUDE = "anylongitude";
    private static final String KEY_ANYLATITUDE = "anylatitude";
    private static final String KEY_USE_OFFLINEMAPS = "offlinemaps";
    private static final String KEY_USE_OFFLINEWPMAPS = "offlinewpmaps";
    private static final String KEY_WEB_DEVICE_CODE = "webDeviceCode";
    private static final String KEY_WEBDEVICE_NAME = "webDeviceName";
    private static final String KEY_MAP_LIVE = "maplive";
    private static final String KEY_MAP_SOURCE = "mapsource";
    private static final String KEY_USE_TWITTER = "twitter";
    private static final String KEY_SHOW_ADDRESS = "showaddress";
    private static final String KEY_SHOW_CAPTCHA = "showcaptcha";
    private static final String KEY_MAP_TRAIL = "maptrail";
    private static final String KEY_LAST_MAP_ZOOM = "mapzoom";
    private static final String KEY_LAST_MAP_LAT = "maplat";
    private static final String KEY_LAST_MAP_LON = "maplon";
    private static final String KEY_LIVE_LIST = "livelist";
    private static final String KEY_METRIC_UNITS = "units";
    private static final String KEY_SKIN = "skin";
    private static final String KEY_LAST_USED_LIST = "lastlist";
    private static final String KEY_CACHE_TYPE = "cachetype";
    private static final String KEY_TWITTER_TOKEN_SECRET = "tokensecret";
    private static final String KEY_TWITTER_TOKEN_PUBLIC = "tokenpublic";
    private static final String KEY_VERSION = "version";
    private static final String KEY_LOAD_DESCRIPTION = "autoloaddesc";
    private static final String KEY_RATING_WANTED = "ratingwanted";
    private static final String KEY_ELEVATION_WANTED = "elevationwanted";
    private static final String KEY_FRIENDLOGS_WANTED = "friendlogswanted";
    private static final String KEY_USE_ENGLISH = "useenglish";
    private static final String KEY_USE_COMPASS = "usecompass";
    private static final String KEY_AUTO_VISIT_TRACKABLES = "trackautovisit";
    private static final String KEY_AUTO_INSERT_SIGNATURE = "sigautoinsert";
    private static final String KEY_ALTITUDE_CORRECTION = "altcorrection";
    private static final String KEY_USE_GOOGLE_NAVIGATION = "usegnav";
    private static final String KEY_STORE_LOG_IMAGES = "logimages";
    private static final String KEY_EXCLUDE_DISABLED = "excludedisabled";
    private static final String KEY_EXCLUDE_OWN = "excludemine";
    private static final String KEY_MAPFILE = "mfmapfile";
    private static final String KEY_SIGNATURE = "signature";
    private static final String KEY_GCVOTE_PASSWORD = "pass-vote";
    private static final String KEY_PASSWORD = "password";
    private static final String KEY_USERNAME = "username";
    private static final String KEY_MEMBER_STATUS = "memberstatus";
    private static final String KEY_COORD_INPUT_FORMAT = "coordinputformat";
    private static final String KEY_LOG_OFFLINE = "log_offline";
    private static final String KEY_LOAD_DIRECTION_IMG = "loaddirectionimg";
    private static final String KEY_GC_CUSTOM_DATE = "gccustomdate";
    private static final String KEY_SHOW_WAYPOINTS_THRESHOLD = "gcshowwaypointsthreshold";
    private static final String KEY_COOKIE_STORE = "cookiestore";
    private static final String KEY_OPEN_LAST_DETAILS_PAGE = "opendetailslastpage";
    private static final String KEY_LAST_DETAILS_PAGE = "lastdetailspage";
    private static final String KEY_DEFAULT_NAVIGATION_TOOL = "defaultNavigationTool";
    private static final String KEY_DEFAULT_NAVIGATION_TOOL_2 = "defaultNavigationTool2";
    private static final String KEY_LIVE_MAP_STRATEGY = "livemapstrategy";
    private static final String KEY_DEBUG = "debug";
    private static final String KEY_HIDE_LIVE_MAP_HINT = "hidelivemaphint";
    private static final String KEY_LIVE_MAP_HINT_SHOW_COUNT = "livemaphintshowcount";
    private static final String KEY_SETTINGS_VERSION = "settingsversion";
    private static final String KEY_DB_ON_SDCARD = "dbonsdcard";
    private static final String KEY_LAST_TRACKABLE_ACTION = "trackableaction";
    private static final String KEY_SHARE_AFTER_EXPORT = "shareafterexport";
    private static final String KEY_GPX_EXPORT_DIR = "gpxExportDir";
    private static final String KEY_RENDER_THEME_BASE_FOLDER = "renderthemepath";
    private static final String KEY_RENDER_THEME_FILE_PATH = "renderthemefile";
    private static final String KEY_GPX_IMPORT_DIR = "gpxImportDir";
    private static final String KEY_PLAIN_LOGS = "plainLogs";
    private static final String KEY_NATIVE_UA = "nativeUa";
    private static final String KEY_MAP_DIRECTORY = "mapDirectory";

    private final static int unitsMetric = 1;

    // twitter api keys
    private final static String keyConsumerPublic = CryptUtils.rot13("ESnsCvAv3kEupF1GCR3jGj");
    private final static String keyConsumerSecret = CryptUtils.rot13("7vQWceACV9umEjJucmlpFe9FCMZSeqIqfkQ2BnhV9x");

    private interface PrefRunnable {
        void edit(final Editor edit);
    }

    public enum coordInputFormatEnum {
        Plain,
        Deg,
        Min,
        Sec;

        static coordInputFormatEnum fromInt(int id) {
            final coordInputFormatEnum[] values = coordInputFormatEnum.values();
            if (id < 0 || id >= values.length) {
                return Min;
            }
            return values[id];
        }
    }

    private static String username = null;
    private static String password = null;

    private static final SharedPreferences sharedPrefs = PreferenceManager.getDefaultSharedPreferences(cgeoapplication.getInstance().getBaseContext());
    static {
        migrateSettings();
        Log.setDebugUnsaved(sharedPrefs.getBoolean(KEY_DEBUG, false));
    }

    // maps
    private static MapProvider mapProvider = null;

    private Settings() {
        // this class is not to be instantiated;
    }

    private static void migrateSettings() {
        // migrate from non standard file location and integer based boolean types
        if (sharedPrefs.getInt(KEY_SETTINGS_VERSION, 0) < 1) {
            final String oldPreferencesName = "cgeo.pref";
            final SharedPreferences old = cgeoapplication.getInstance().getSharedPreferences(oldPreferencesName, Context.MODE_PRIVATE);
            final Editor e = sharedPrefs.edit();

            e.putString(KEY_TEMP_TOKEN_SECRET, old.getString(KEY_TEMP_TOKEN_SECRET, null));
            e.putString(KEY_TEMP_TOKEN_PUBLIC, old.getString(KEY_TEMP_TOKEN_PUBLIC, null));
            e.putBoolean(KEY_HELP_SHOWN, old.getInt(KEY_HELP_SHOWN, 0) != 0);
            e.putFloat(KEY_ANYLONGITUDE, old.getFloat(KEY_ANYLONGITUDE, 0));
            e.putFloat(KEY_ANYLATITUDE, old.getFloat(KEY_ANYLATITUDE, 0));
            e.putBoolean(KEY_USE_OFFLINEMAPS, 0 != old.getInt(KEY_USE_OFFLINEMAPS, 1));
            e.putBoolean(KEY_USE_OFFLINEWPMAPS, 0 != old.getInt(KEY_USE_OFFLINEWPMAPS, 0));
            e.putString(KEY_WEB_DEVICE_CODE, old.getString(KEY_WEB_DEVICE_CODE, null));
            e.putString(KEY_WEBDEVICE_NAME, old.getString(KEY_WEBDEVICE_NAME, null));
            e.putBoolean(KEY_MAP_LIVE, old.getInt(KEY_MAP_LIVE, 1) != 0);
            e.putInt(KEY_MAP_SOURCE, old.getInt(KEY_MAP_SOURCE, 0));
            e.putBoolean(KEY_USE_TWITTER, 0 != old.getInt(KEY_USE_TWITTER, 0));
            e.putBoolean(KEY_SHOW_ADDRESS, 0 != old.getInt(KEY_SHOW_ADDRESS, 1));
            e.putBoolean(KEY_SHOW_CAPTCHA, old.getBoolean(KEY_SHOW_CAPTCHA, false));
            e.putBoolean(KEY_MAP_TRAIL, old.getInt(KEY_MAP_TRAIL, 1) != 0);
            e.putInt(KEY_LAST_MAP_ZOOM, old.getInt(KEY_LAST_MAP_ZOOM, 14));
            e.putBoolean(KEY_LIVE_LIST, 0 != old.getInt(KEY_LIVE_LIST, 1));
            e.putBoolean(KEY_METRIC_UNITS, old.getInt(KEY_METRIC_UNITS, unitsMetric) == unitsMetric);
            e.putBoolean(KEY_SKIN, old.getInt(KEY_SKIN, 0) != 0);
            e.putInt(KEY_LAST_USED_LIST, old.getInt(KEY_LAST_USED_LIST, StoredList.STANDARD_LIST_ID));
            e.putString(KEY_CACHE_TYPE, old.getString(KEY_CACHE_TYPE, CacheType.ALL.id));
            e.putString(KEY_TWITTER_TOKEN_SECRET, old.getString(KEY_TWITTER_TOKEN_SECRET, null));
            e.putString(KEY_TWITTER_TOKEN_PUBLIC, old.getString(KEY_TWITTER_TOKEN_PUBLIC, null));
            e.putInt(KEY_VERSION, old.getInt(KEY_VERSION, 0));
            e.putBoolean(KEY_LOAD_DESCRIPTION, 0 != old.getInt(KEY_LOAD_DESCRIPTION, 0));
            e.putBoolean(KEY_RATING_WANTED, old.getBoolean(KEY_RATING_WANTED, true));
            e.putBoolean(KEY_ELEVATION_WANTED, old.getBoolean(KEY_ELEVATION_WANTED, true));
            e.putBoolean(KEY_FRIENDLOGS_WANTED, old.getBoolean(KEY_FRIENDLOGS_WANTED, true));
            e.putBoolean(KEY_USE_ENGLISH, old.getBoolean(KEY_USE_ENGLISH, false));
            e.putBoolean(KEY_USE_COMPASS, 0 != old.getInt(KEY_USE_COMPASS, 1));
            e.putBoolean(KEY_AUTO_VISIT_TRACKABLES, old.getBoolean(KEY_AUTO_VISIT_TRACKABLES, false));
            e.putBoolean(KEY_AUTO_INSERT_SIGNATURE, old.getBoolean(KEY_AUTO_INSERT_SIGNATURE, false));
            e.putInt(KEY_ALTITUDE_CORRECTION, old.getInt(KEY_ALTITUDE_CORRECTION, 0));
            e.putBoolean(KEY_USE_GOOGLE_NAVIGATION, 0 != old.getInt(KEY_USE_GOOGLE_NAVIGATION, 1));
            e.putBoolean(KEY_STORE_LOG_IMAGES, old.getBoolean(KEY_STORE_LOG_IMAGES, false));
            e.putBoolean(KEY_EXCLUDE_DISABLED, 0 != old.getInt(KEY_EXCLUDE_DISABLED, 0));
            e.putBoolean(KEY_EXCLUDE_OWN, 0 != old.getInt(KEY_EXCLUDE_OWN, 0));
            e.putString(KEY_MAPFILE, old.getString(KEY_MAPFILE, null));
            e.putString(KEY_SIGNATURE, old.getString(KEY_SIGNATURE, null));
            e.putString(KEY_GCVOTE_PASSWORD, old.getString(KEY_GCVOTE_PASSWORD, null));
            e.putString(KEY_PASSWORD, old.getString(KEY_PASSWORD, null));
            e.putString(KEY_USERNAME, old.getString(KEY_USERNAME, null));
            e.putString(KEY_MEMBER_STATUS, old.getString(KEY_MEMBER_STATUS, ""));
            e.putInt(KEY_COORD_INPUT_FORMAT, old.getInt(KEY_COORD_INPUT_FORMAT, 0));
            e.putBoolean(KEY_LOG_OFFLINE, old.getBoolean(KEY_LOG_OFFLINE, false));
            e.putBoolean(KEY_LOAD_DIRECTION_IMG, old.getBoolean(KEY_LOAD_DIRECTION_IMG, true));
            e.putString(KEY_GC_CUSTOM_DATE, old.getString(KEY_GC_CUSTOM_DATE, null));
            e.putInt(KEY_SHOW_WAYPOINTS_THRESHOLD, old.getInt(KEY_SHOW_WAYPOINTS_THRESHOLD, 0));
            e.putString(KEY_COOKIE_STORE, old.getString(KEY_COOKIE_STORE, null));
            e.putBoolean(KEY_OPEN_LAST_DETAILS_PAGE, old.getBoolean(KEY_OPEN_LAST_DETAILS_PAGE, false));
            e.putInt(KEY_LAST_DETAILS_PAGE, old.getInt(KEY_LAST_DETAILS_PAGE, 1));
            e.putInt(KEY_DEFAULT_NAVIGATION_TOOL, old.getInt(KEY_DEFAULT_NAVIGATION_TOOL, NavigationAppsEnum.COMPASS.id));
            e.putInt(KEY_DEFAULT_NAVIGATION_TOOL_2, old.getInt(KEY_DEFAULT_NAVIGATION_TOOL_2, NavigationAppsEnum.INTERNAL_MAP.id));
            e.putInt(KEY_LIVE_MAP_STRATEGY, old.getInt(KEY_LIVE_MAP_STRATEGY, Strategy.AUTO.id));
            e.putBoolean(KEY_DEBUG, old.getBoolean(KEY_DEBUG, false));
            e.putBoolean(KEY_HIDE_LIVE_MAP_HINT, old.getInt(KEY_HIDE_LIVE_MAP_HINT, 0) != 0);
            e.putInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, old.getInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, 0));

            e.putInt(KEY_SETTINGS_VERSION, 1); // mark migrated
            e.commit();
        }
    }

    public static void setLanguage(boolean useEnglish) {
        final Configuration config = new Configuration();
        config.locale = useEnglish ? new Locale("en") : Locale.getDefault();
        final Resources resources = cgeoapplication.getInstance().getResources();
        resources.updateConfiguration(config, resources.getDisplayMetrics());
    }

    public static boolean isLogin() {
        final String preUsername = sharedPrefs.getString(KEY_USERNAME, null);
        final String prePassword = sharedPrefs.getString(KEY_PASSWORD, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    /**
     * Get login and password information.
     *
     * @return a pair (login, password) or null if no valid information is stored
     */
    public static ImmutablePair<String, String> getLogin() {
        if (username == null || password == null) {
            final String preUsername = sharedPrefs.getString(KEY_USERNAME, null);
            final String prePassword = sharedPrefs.getString(KEY_PASSWORD, null);

            if (preUsername == null || prePassword == null) {
                return null;
            }

            username = preUsername;
            password = prePassword;
        }
        return new ImmutablePair<String, String>(username, password);
    }

    public static String getUsername() {
        return username != null ? username : sharedPrefs.getString(KEY_USERNAME, null);
    }

    public static boolean setLogin(final String username, final String password) {
        Settings.username = username;
        Settings.password = password;
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
                    // erase username and password
                    edit.remove(KEY_USERNAME);
                    edit.remove(KEY_PASSWORD);
                } else {
                    // save username and password
                    edit.putString(KEY_USERNAME, username);
                    edit.putString(KEY_PASSWORD, password);
                }
            }
        });
    }

    public static boolean isPremiumMember() {
        // Basic Member, Premium Member, ???
        String memberStatus = Settings.getMemberStatus();
        if (memberStatus == null) {
            return false;
        }
        return GCConstants.MEMBER_STATUS_PM.equalsIgnoreCase(memberStatus);
    }

    public static String getMemberStatus() {
        return sharedPrefs.getString(KEY_MEMBER_STATUS, "");
    }

    public static boolean setMemberStatus(final String memberStatus) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(memberStatus)) {
                    edit.remove(KEY_MEMBER_STATUS);
                } else {
                    edit.putString(KEY_MEMBER_STATUS, memberStatus);
                }
            }
        });
    }

    public static boolean isGCvoteLogin() {
        final String preUsername = sharedPrefs.getString(KEY_USERNAME, null);
        final String prePassword = sharedPrefs.getString(KEY_GCVOTE_PASSWORD, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    public static boolean setGCvoteLogin(final String password) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(password)) {
                    // erase password
                    edit.remove(KEY_GCVOTE_PASSWORD);
                } else {
                    // save password
                    edit.putString(KEY_GCVOTE_PASSWORD, password);
                }
            }
        });
    }

    public static ImmutablePair<String, String> getGCvoteLogin() {
        final String username = sharedPrefs.getString(KEY_USERNAME, null);
        final String password = sharedPrefs.getString(KEY_GCVOTE_PASSWORD, null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return null;
        }

        return new ImmutablePair<String, String>(username, password);
    }

    public static boolean setSignature(final String signature) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (StringUtils.isBlank(signature)) {
                    // erase signature
                    edit.remove(KEY_SIGNATURE);
                } else {
                    // save signature
                    edit.putString(KEY_SIGNATURE, signature);
                }
            }
        });
    }

    public static String getSignature() {
        return sharedPrefs.getString(KEY_SIGNATURE, null);
    }

    public static boolean setCookieStore(final String cookies) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(final Editor edit) {
                if (StringUtils.isBlank(cookies)) {
                    // erase cookies
                    edit.remove(KEY_COOKIE_STORE);
                } else {
                    // save cookies
                    edit.putString(KEY_COOKIE_STORE, cookies);
                }
            }
        });
    }

    public static String getCookieStore() {
        return sharedPrefs.getString(KEY_COOKIE_STORE, null);
    }

    /**
     * @param cacheType
     *            The cache type used for future filtering
     */
    public static void setCacheType(final CacheType cacheType) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                if (cacheType == null) {
                    edit.remove(KEY_CACHE_TYPE);
                } else {
                    edit.putString(KEY_CACHE_TYPE, cacheType.id);
                }
            }
        });
    }

    public static void setLiveMap(final boolean live) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_MAP_LIVE, live);
            }
        });
    }

    public static int getLastList() {
        return sharedPrefs.getInt(KEY_LAST_USED_LIST, StoredList.STANDARD_LIST_ID);
    }

    public static void saveLastList(final int listId) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_USED_LIST, listId);
            }
        });
    }

    public static void setWebNameCode(final String name, final String code) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {

                edit.putString(KEY_WEBDEVICE_NAME, name);
                edit.putString(KEY_WEB_DEVICE_CODE, code);
            }
        });
    }

    public static MapProvider getMapProvider() {
        if (mapProvider == null) {
            mapProvider = getMapSource().getMapProvider();
        }
        return mapProvider;
    }

    public static String getMapFile() {
        return sharedPrefs.getString(KEY_MAPFILE, null);
    }

    public static boolean setMapFile(final String mapFile) {
        boolean result = editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_MAPFILE, mapFile);
            }
        });
        if (mapFile != null) {
            setMapFileDirectory(new File(mapFile).getParent());
        }
        return result;
    }

    public static String getMapFileDirectory() {
        final String mapDir = sharedPrefs.getString(KEY_MAP_DIRECTORY, null);
        if (mapDir != null) {
            return mapDir;
        }
        final String mapFile = getMapFile();
        if (mapFile != null) {
            return new File(mapFile).getParent();
        }
        return null;
    }

    public static boolean setMapFileDirectory(final String mapFileDirectory) {
        return editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_MAP_DIRECTORY, mapFileDirectory);
                MapsforgeMapProvider.getInstance().updateOfflineMaps();
            }
        });
    }

    public static boolean isValidMapFile() {
        return isValidMapFile(getMapFile());
    }

    public static boolean isValidMapFile(final String mapFileIn) {
        return MapsforgeMapProvider.isValidMapFile(mapFileIn);
    }

    public static coordInputFormatEnum getCoordInputFormat() {
        return coordInputFormatEnum.fromInt(sharedPrefs.getInt(KEY_COORD_INPUT_FORMAT, 0));
    }

    public static void setCoordInputFormat(final coordInputFormatEnum format) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_COORD_INPUT_FORMAT, format.ordinal());
            }
        });
    }

    static void setLogOffline(final boolean offline) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LOG_OFFLINE, offline);
            }
        });
    }

    public static boolean getLogOffline() {
        return sharedPrefs.getBoolean(KEY_LOG_OFFLINE, false);
    }

    static void setLoadDirImg(final boolean value) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LOAD_DIRECTION_IMG, value);
            }
        });
    }

    public static boolean getLoadDirImg() {
        return !isPremiumMember() && sharedPrefs.getBoolean(KEY_LOAD_DIRECTION_IMG, true);
    }

    public static void setGcCustomDate(final String format) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_GC_CUSTOM_DATE, format);
            }
        });
    }

    /**
     * @return User selected date format on GC.com
     * @see Login#gcCustomDateFormats
     */
    public static String getGcCustomDate() {
        return sharedPrefs.getString(KEY_GC_CUSTOM_DATE, null);
    }

    public static boolean isExcludeMyCaches() {
        return sharedPrefs.getBoolean(KEY_EXCLUDE_OWN, false);
    }

    /**
     * edit some settings without knowing how to get the settings editor or how to commit
     *
     * @param runnable
     * @return
     */
    private static boolean editSharedSettings(final PrefRunnable runnable) {
        final SharedPreferences.Editor prefsEdit = sharedPrefs.edit();
        runnable.edit(prefsEdit);
        return prefsEdit.commit();
    }

    public static void setExcludeMine(final boolean exclude) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_EXCLUDE_OWN, exclude);
            }
        });
    }

    public static void setUseEnglish(final boolean english) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_ENGLISH, english);
                setLanguage(english);
            }
        });
    }

    public static boolean isUseEnglish() {
        return sharedPrefs.getBoolean(KEY_USE_ENGLISH, false);
    }

    public static boolean isShowAddress() {
        return sharedPrefs.getBoolean(KEY_SHOW_ADDRESS, true);
    }

    public static void setShowAddress(final boolean showAddress) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SHOW_ADDRESS, showAddress);
            }
        });
    }

    public static boolean isShowCaptcha() {
        return !isPremiumMember() && sharedPrefs.getBoolean(KEY_SHOW_CAPTCHA, false);
    }

    public static void setShowCaptcha(final boolean showCaptcha) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SHOW_CAPTCHA, showCaptcha);
            }
        });
    }

    public static boolean isExcludeDisabledCaches() {
        return sharedPrefs.getBoolean(KEY_EXCLUDE_DISABLED, false);
    }

    public static void setExcludeDisabledCaches(final boolean exclude) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_EXCLUDE_DISABLED, exclude);
            }
        });
    }

    public static boolean isStoreOfflineMaps() {
        return sharedPrefs.getBoolean(KEY_USE_OFFLINEMAPS, true);
    }

    public static void setStoreOfflineMaps(final boolean offlineMaps) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_OFFLINEMAPS, offlineMaps);
            }
        });
    }

    public static boolean isStoreOfflineWpMaps() {
        return sharedPrefs.getBoolean(KEY_USE_OFFLINEWPMAPS, false);
    }

    public static void setStoreOfflineWpMaps(final boolean offlineMaps) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_OFFLINEWPMAPS, offlineMaps);
            }
        });
    }

    public static boolean isStoreLogImages() {
        return sharedPrefs.getBoolean(KEY_STORE_LOG_IMAGES, false);
    }

    public static void setStoreLogImages(final boolean storeLogImages) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_STORE_LOG_IMAGES, storeLogImages);
            }
        });
    }

    public static boolean isUseGoogleNavigation() {
        return sharedPrefs.getBoolean(KEY_USE_GOOGLE_NAVIGATION, true);
    }

    public static void setUseGoogleNavigation(final boolean useGoogleNavigation) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_GOOGLE_NAVIGATION, useGoogleNavigation);
            }
        });
    }

    public static boolean isAutoLoadDescription() {
        return sharedPrefs.getBoolean(KEY_LOAD_DESCRIPTION, false);
    }

    public static void setAutoLoadDesc(final boolean autoLoad) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LOAD_DESCRIPTION, autoLoad);
            }
        });
    }

    public static boolean isRatingWanted() {
        return sharedPrefs.getBoolean(KEY_RATING_WANTED, true);
    }

    public static void setRatingWanted(final boolean ratingWanted) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_RATING_WANTED, ratingWanted);
            }
        });
    }

    public static boolean isElevationWanted() {
        return sharedPrefs.getBoolean(KEY_ELEVATION_WANTED, true);
    }

    public static void setElevationWanted(final boolean elevationWanted) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_ELEVATION_WANTED, elevationWanted);
            }
        });
    }

    public static boolean isFriendLogsWanted() {
        if (!isLogin()) {
            // don't show a friends log if the user is anonymous
            return false;
        }
        return sharedPrefs.getBoolean(KEY_FRIENDLOGS_WANTED, true);
    }

    public static void setFriendLogsWanted(final boolean friendLogsWanted) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_FRIENDLOGS_WANTED, friendLogsWanted);
            }
        });
    }

    public static boolean isLiveList() {
        return sharedPrefs.getBoolean(KEY_LIVE_LIST, true);
    }

    public static void setLiveList(final boolean liveList) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_LIVE_LIST, liveList);
            }
        });
    }

    public static boolean isTrackableAutoVisit() {
        return sharedPrefs.getBoolean(KEY_AUTO_VISIT_TRACKABLES, false);
    }

    public static void setTrackableAutoVisit(final boolean autoVisit) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_AUTO_VISIT_TRACKABLES, autoVisit);
            }
        });
    }

    public static boolean isAutoInsertSignature() {
        return sharedPrefs.getBoolean(KEY_AUTO_INSERT_SIGNATURE, false);
    }

    public static void setAutoInsertSignature(final boolean autoInsert) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_AUTO_INSERT_SIGNATURE, autoInsert);
            }
        });
    }

    public static boolean isUseMetricUnits() {
        return sharedPrefs.getBoolean(KEY_METRIC_UNITS, true);
    }

    public static void setUseMetricUnits(final boolean metric) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_METRIC_UNITS, metric);
            }
        });
    }

    public static boolean isLiveMap() {
        return sharedPrefs.getBoolean(KEY_MAP_LIVE, true);
    }

    public static boolean isMapTrail() {
        return sharedPrefs.getBoolean(KEY_MAP_TRAIL, true);
    }

    public static void setMapTrail(final boolean showTrail) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_MAP_TRAIL, showTrail);
            }
        });
    }

    public static int getMapZoom() {
        return sharedPrefs.getInt(KEY_LAST_MAP_ZOOM, 14);
    }

    public static void setMapZoom(final int mapZoomLevel) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_MAP_ZOOM, mapZoomLevel);
            }
        });
    }

    public static GeoPointImpl getMapCenter() {
        return getMapProvider().getMapItemFactory()
                .getGeoPointBase(new Geopoint(sharedPrefs.getInt(KEY_LAST_MAP_LAT, 0) / 1e6,
                        sharedPrefs.getInt(KEY_LAST_MAP_LON, 0) / 1e6));
    }

    public static void setMapCenter(final GeoPointImpl mapViewCenter) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_MAP_LAT, mapViewCenter.getLatitudeE6());
                edit.putInt(KEY_LAST_MAP_LON, mapViewCenter.getLongitudeE6());
            }
        });
    }

    public static MapSource getMapSource() {
        final int id = getConvertedMapId();
        final MapSource map = MapProviderFactory.getMapSource(id);
        if (map != null) {
            // don't use offline maps if the map file is not valid
            if ((!(map instanceof OfflineMapSource)) || (isValidMapFile())) {
                return map;
            }
        }
        // fallback to first available map
        return MapProviderFactory.getDefaultSource();
    }

    private final static int GOOGLEMAP_BASEID = 30;
    private final static int MAP = 1;
    private final static int SATELLITE = 2;

    private final static int MFMAP_BASEID = 40;
    private final static int MAPNIK = 1;
    private final static int CYCLEMAP = 3;
    private final static int OFFLINE = 4;

    /**
     * convert old preference ids for maps (based on constant values) into new hash based ids
     *
     * @return
     */
    private static int getConvertedMapId() {
        final int id = sharedPrefs.getInt(KEY_MAP_SOURCE, 0);
        switch (id) {
            case GOOGLEMAP_BASEID + MAP:
                return GoogleMapProvider.GOOGLE_MAP_ID.hashCode();
            case GOOGLEMAP_BASEID + SATELLITE:
                return GoogleMapProvider.GOOGLE_SATELLITE_ID.hashCode();
            case MFMAP_BASEID + MAPNIK:
                return MapsforgeMapProvider.MAPSFORGE_MAPNIK_ID.hashCode();
            case MFMAP_BASEID + CYCLEMAP:
                return MapsforgeMapProvider.MAPSFORGE_CYCLEMAP_ID.hashCode();
            case MFMAP_BASEID + OFFLINE: {
                final String mapFile = Settings.getMapFile();
                if (StringUtils.isNotEmpty(mapFile)) {
                    return mapFile.hashCode();
                }
                break;
            }
            default:
                break;
        }
        return id;
    }

    public static void setMapSource(final MapSource newMapSource) {
        if (!MapProviderFactory.isSameActivity(getMapSource(), newMapSource)) {
            mapProvider = null;
        }
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_MAP_SOURCE, newMapSource.getNumericalId());
            }
        });
        if (newMapSource instanceof OfflineMapSource) {
            setMapFile(((OfflineMapSource) newMapSource).getFileName());
        }
    }

    public static void setAnyCoordinates(final Geopoint coords) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                if (null != coords) {
                    edit.putFloat(KEY_ANYLATITUDE, (float) coords.getLatitude());
                    edit.putFloat(KEY_ANYLONGITUDE, (float) coords.getLongitude());
                } else {
                    edit.remove(KEY_ANYLATITUDE);
                    edit.remove(KEY_ANYLONGITUDE);
                }
            }
        });

    }

    public static Geopoint getAnyCoordinates() {
        if (sharedPrefs.contains(KEY_ANYLATITUDE) && sharedPrefs.contains(KEY_ANYLONGITUDE)) {
            float lat = sharedPrefs.getFloat(KEY_ANYLATITUDE, 0);
            float lon = sharedPrefs.getFloat(KEY_ANYLONGITUDE, 0);
            return new Geopoint(lat, lon);
        }
        return null;
    }

    public static boolean isUseCompass() {
        return sharedPrefs.getBoolean(KEY_USE_COMPASS, true);
    }

    public static void setUseCompass(final boolean useCompass) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_COMPASS, useCompass);
            }
        });
    }

    public static boolean isHelpShown() {
        return sharedPrefs.getBoolean(KEY_HELP_SHOWN, false);
    }

    public static void setHelpShown() {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_HELP_SHOWN, true);
            }
        });
    }

    public static boolean isLightSkin() {
        return sharedPrefs.getBoolean(KEY_SKIN, false);
    }

    public static void setLightSkin(final boolean lightSkin) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SKIN, lightSkin);
            }
        });
    }

    public static String getKeyConsumerPublic() {
        return keyConsumerPublic;
    }

    public static String getKeyConsumerSecret() {
        return keyConsumerSecret;
    }

    public static int getAltCorrection() {
        return sharedPrefs.getInt(KEY_ALTITUDE_CORRECTION, 0);
    }

    public static boolean setAltCorrection(final int altitude) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_ALTITUDE_CORRECTION, altitude);
            }
        });
    }

    public static String getWebDeviceCode() {
        return sharedPrefs.getString(KEY_WEB_DEVICE_CODE, null);
    }

    public static String getWebDeviceName() {
        return sharedPrefs.getString(KEY_WEBDEVICE_NAME, null);
    }

    /**
     * @return The cache type used for filtering or ALL if no filter is active. Returns never null
     */
    public static CacheType getCacheType() {
        return CacheType.getById(sharedPrefs.getString(KEY_CACHE_TYPE, CacheType.ALL.id));
    }

    /**
     * The Threshold for the showing of child waypoints
     *
     * @return
     */

    public static int getWayPointsThreshold() {
        return sharedPrefs.getInt(KEY_SHOW_WAYPOINTS_THRESHOLD, 0);
    }

    public static void setShowWaypointsThreshold(final int threshold) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_SHOW_WAYPOINTS_THRESHOLD, threshold);
            }
        });
    }

    public static boolean isUseTwitter() {
        return sharedPrefs.getBoolean(KEY_USE_TWITTER, false);
    }

    public static void setUseTwitter(final boolean useTwitter) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_USE_TWITTER, useTwitter);
            }
        });
    }

    public static boolean isTwitterLoginValid() {
        return !StringUtils.isBlank(getTokenPublic()) && !StringUtils.isBlank(getTokenSecret());
    }

    public static String getTokenPublic() {
        return sharedPrefs.getString(KEY_TWITTER_TOKEN_PUBLIC, null);
    }

    public static String getTokenSecret() {
        return sharedPrefs.getString(KEY_TWITTER_TOKEN_SECRET, null);

    }

    public static int getVersion() {
        return sharedPrefs.getInt(KEY_VERSION, 0);
    }

    public static void setTwitterTokens(final String tokenPublic, final String tokenSecret, boolean enableTwitter) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_TWITTER_TOKEN_PUBLIC, tokenPublic);
                edit.putString(KEY_TWITTER_TOKEN_SECRET, tokenSecret);
                if (tokenPublic != null) {
                    edit.remove(KEY_TEMP_TOKEN_PUBLIC);
                    edit.remove(KEY_TEMP_TOKEN_SECRET);
                }
            }
        });
        setUseTwitter(enableTwitter);
    }

    public static void setTwitterTempTokens(final String tokenPublic, final String tokenSecret) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_TEMP_TOKEN_PUBLIC, tokenPublic);
                edit.putString(KEY_TEMP_TOKEN_SECRET, tokenSecret);
            }
        });
    }

    public static ImmutablePair<String, String> getTempToken() {
        String tokenPublic = sharedPrefs.getString(KEY_TEMP_TOKEN_PUBLIC, null);
        String tokenSecret = sharedPrefs.getString(KEY_TEMP_TOKEN_SECRET, null);
        return new ImmutablePair<String, String>(tokenPublic, tokenSecret);
    }

    public static void setVersion(final int version) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_VERSION, version);
            }
        });
    }

    public static boolean isOpenLastDetailsPage() {
        return sharedPrefs.getBoolean(KEY_OPEN_LAST_DETAILS_PAGE, false);
    }

    public static void setOpenLastDetailsPage(final boolean openLastPage) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_OPEN_LAST_DETAILS_PAGE, openLastPage);
            }
        });
    }

    public static int getLastDetailsPage() {
        return sharedPrefs.getInt(KEY_LAST_DETAILS_PAGE, 1);
    }

    public static void setLastDetailsPage(final int index) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_DETAILS_PAGE, index);
            }
        });
    }

    public static int getDefaultNavigationTool() {
        return sharedPrefs.getInt(KEY_DEFAULT_NAVIGATION_TOOL, NavigationAppsEnum.COMPASS.id);
    }

    public static void setDefaultNavigationTool(final int defaultNavigationTool) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_DEFAULT_NAVIGATION_TOOL, defaultNavigationTool);
            }
        });
    }

    public static int getDefaultNavigationTool2() {
        return sharedPrefs.getInt(KEY_DEFAULT_NAVIGATION_TOOL_2, NavigationAppsEnum.INTERNAL_MAP.id);
    }

    public static void setDefaultNavigationTool2(final int defaultNavigationTool) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_DEFAULT_NAVIGATION_TOOL_2, defaultNavigationTool);
            }
        });
    }

    public static Strategy getLiveMapStrategy() {
        return Strategy.getById(sharedPrefs.getInt(KEY_LIVE_MAP_STRATEGY, Strategy.AUTO.id));
    }

    public static void setLiveMapStrategy(final Strategy strategy) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LIVE_MAP_STRATEGY, strategy.id);
            }
        });
    }

    public static boolean isDebug() {
        return Log.isDebug();
    }

    public static void setDebug(final boolean debug) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_DEBUG, debug);
            }
        });
        Log.setDebugUnsaved(debug);
    }

    public static boolean getHideLiveMapHint() {
        return sharedPrefs.getBoolean(KEY_HIDE_LIVE_MAP_HINT, false);
    }

    public static void setHideLiveHint(final boolean hide) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_HIDE_LIVE_MAP_HINT, hide);
            }
        });
    }

    public static int getLiveMapHintShowCount() {
        return sharedPrefs.getInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, 0);
    }

    public static void setLiveMapHintShowCount(final int showCount) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LIVE_MAP_HINT_SHOW_COUNT, showCount);
            }
        });
    }

    public static boolean isDbOnSDCard() {
        return sharedPrefs.getBoolean(KEY_DB_ON_SDCARD, false);
    }

    public static void setDbOnSDCard(final boolean dbOnSDCard) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_DB_ON_SDCARD, dbOnSDCard);
            }
        });
    }

    public static String getGpxExportDir() {
        return sharedPrefs.getString(KEY_GPX_EXPORT_DIR, Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static void setGpxExportDir(final String gpxExportDir) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_GPX_EXPORT_DIR, gpxExportDir);
            }
        });
    }

    public static String getGpxImportDir() {
        return sharedPrefs.getString(KEY_GPX_IMPORT_DIR, Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static void setGpxImportDir(final String gpxImportDir) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_GPX_IMPORT_DIR, gpxImportDir);
            }
        });
    }

    public static boolean getShareAfterExport() {
        return sharedPrefs.getBoolean(KEY_SHARE_AFTER_EXPORT, true);
    }

    public static void setShareAfterExport(final boolean shareAfterExport) {
        editSharedSettings(new PrefRunnable() {
            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_SHARE_AFTER_EXPORT, shareAfterExport);
            }
        });
    }

    public static int getTrackableAction() {
        return sharedPrefs.getInt(KEY_LAST_TRACKABLE_ACTION, LogType.RETRIEVED_IT.id);
    }

    public static void setTrackableAction(final int trackableAction) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putInt(KEY_LAST_TRACKABLE_ACTION, trackableAction);
            }
        });
    }

    public static String getCustomRenderThemeBaseFolder() {
        return sharedPrefs.getString(KEY_RENDER_THEME_BASE_FOLDER, "");
    }

    public static boolean setCustomRenderThemeBaseFolder(final String customRenderThemeBaseFolder) {
        return editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_RENDER_THEME_BASE_FOLDER, customRenderThemeBaseFolder);
            }
        });
    }

    public static String getCustomRenderThemeFilePath() {
        return sharedPrefs.getString(KEY_RENDER_THEME_FILE_PATH, "");
    }

    public static void setCustomRenderThemeFile(final String customRenderThemeFile) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putString(KEY_RENDER_THEME_FILE_PATH, customRenderThemeFile);
            }
        });
    }

    public static File[] getMapThemeFiles() {

        File directory = new File(Settings.getCustomRenderThemeBaseFolder());

        List<File> result = new ArrayList<File>();

        FileUtils.listDir(result, directory, new ExtensionsBasedFileSelector(new String[] { "xml" }), null);

        return result.toArray(new File[] {});
    }

    private static class ExtensionsBasedFileSelector extends FileSelector {

        private final String[] extensions;

        public ExtensionsBasedFileSelector(String[] extensions) {
            this.extensions = extensions;
        }

        @Override
        public boolean isSelected(File file) {
            String filename = file.getName();
            for (String ext : extensions) {
                if (StringUtils.endsWithIgnoreCase(filename, ext)) {
                    return true;
                }
            }
            return false;
        }

        @Override
        public boolean shouldEnd() {
            return false;
        }
    }

    public static boolean getPlainLogs() {
        return sharedPrefs.getBoolean(KEY_PLAIN_LOGS, false);
    }

    public static void setPlainLogs(final boolean plainLogs) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_PLAIN_LOGS, plainLogs);
            }
        });
    }

    public static boolean getUseNativeUa() {
        return sharedPrefs.getBoolean(KEY_NATIVE_UA, false);
    }

    public static void setUseNativeUa(final boolean useNativeUa) {
        editSharedSettings(new PrefRunnable() {

            @Override
            public void edit(Editor edit) {
                edit.putBoolean(KEY_NATIVE_UA, useNativeUa);
            }
        });
    }
}
!@#$%
20190527_001409,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_b19172
package cgeo.geocaching.network;

import cgeo.geocaching.Settings;
import cgeo.geocaching.files.LocalStorage;
import cgeo.geocaching.utils.BaseUtils;
import cgeo.geocaching.utils.Log;

import ch.boye.httpclientandroidlib.Header;
import ch.boye.httpclientandroidlib.HeaderElement;
import ch.boye.httpclientandroidlib.HttpEntity;
import ch.boye.httpclientandroidlib.HttpException;
import ch.boye.httpclientandroidlib.HttpRequest;
import ch.boye.httpclientandroidlib.HttpRequestInterceptor;
import ch.boye.httpclientandroidlib.HttpResponse;
import ch.boye.httpclientandroidlib.HttpResponseInterceptor;
import ch.boye.httpclientandroidlib.NameValuePair;
import ch.boye.httpclientandroidlib.ProtocolException;
import ch.boye.httpclientandroidlib.client.HttpClient;
import ch.boye.httpclientandroidlib.client.entity.GzipDecompressingEntity;
import ch.boye.httpclientandroidlib.client.entity.UrlEncodedFormEntity;
import ch.boye.httpclientandroidlib.client.methods.HttpGet;
import ch.boye.httpclientandroidlib.client.methods.HttpPost;
import ch.boye.httpclientandroidlib.client.methods.HttpRequestBase;
import ch.boye.httpclientandroidlib.client.params.ClientPNames;
import ch.boye.httpclientandroidlib.entity.StringEntity;
import ch.boye.httpclientandroidlib.entity.mime.MultipartEntity;
import ch.boye.httpclientandroidlib.entity.mime.content.FileBody;
import ch.boye.httpclientandroidlib.entity.mime.content.StringBody;
import ch.boye.httpclientandroidlib.impl.client.DefaultHttpClient;
import ch.boye.httpclientandroidlib.impl.client.DefaultRedirectStrategy;
import ch.boye.httpclientandroidlib.params.BasicHttpParams;
import ch.boye.httpclientandroidlib.params.CoreConnectionPNames;
import ch.boye.httpclientandroidlib.params.CoreProtocolPNames;
import ch.boye.httpclientandroidlib.params.HttpParams;
import ch.boye.httpclientandroidlib.protocol.HttpContext;
import ch.boye.httpclientandroidlib.util.EntityUtils;

import org.apache.commons.lang3.CharEncoding;
import org.apache.commons.lang3.StringUtils;
import org.json.JSONException;
import org.json.JSONObject;

import android.net.Uri;

import java.io.File;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.net.URLEncoder;

public abstract class Network {

    private static final int NB_DOWNLOAD_RETRIES = 4;

    /** User agent id */
    private final static String PC_USER_AGENT = "Mozilla/5.0 (X11; Linux x86_64; rv:9.0.1) Gecko/20100101 Firefox/9.0.1";
    /** Native user agent, taken from a Android 2.2 Nexus **/
    private final static String NATIVE_USER_AGENT = "Mozilla/5.0 (Linux; U; Android 2.2; en-us; Nexus One Build/FRF91) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1";

    private static final String PATTERN_PASSWORD = "(?<=[\\?&])[Pp]ass(w(or)?d)?=[^&#$]+";

    private final static HttpParams clientParams = new BasicHttpParams();

    static {
        Network.clientParams.setParameter(CoreProtocolPNames.HTTP_CONTENT_CHARSET, CharEncoding.UTF_8);
        Network.clientParams.setParameter(CoreConnectionPNames.CONNECTION_TIMEOUT, 30000);
        Network.clientParams.setParameter(CoreConnectionPNames.SO_TIMEOUT, 30000);
        Network.clientParams.setParameter(ClientPNames.HANDLE_REDIRECTS,  true);
    }

    private static String hidePassword(final String message) {
        return message.replaceAll(Network.PATTERN_PASSWORD, "password=***");
    }

    private static HttpClient getHttpClient() {
        final DefaultHttpClient client = new DefaultHttpClient();
        client.setCookieStore(Cookies.cookieStore);
        client.setParams(clientParams);

        client.setRedirectStrategy(new DefaultRedirectStrategy() {
            @Override
            public boolean isRedirected(HttpRequest request, HttpResponse response, HttpContext context) {
                boolean isRedirect = false;
                try {
                    isRedirect = super.isRedirected(request, response, context);
                } catch (final ProtocolException e) {
                    Log.e("httpclient.isRedirected: unable to check for redirection", e);
                }
                if (!isRedirect) {
                    final int responseCode = response.getStatusLine().getStatusCode();
                    if (responseCode == 301 || responseCode == 302) {
                        return true;
                    }
                }
                return isRedirect;
            }
        });

        client.addRequestInterceptor(new HttpRequestInterceptor() {

            @Override
            public void process(
                    final HttpRequest request,
                    final HttpContext context) throws HttpException, IOException {
                if (!request.containsHeader("Accept-Encoding")) {
                    request.addHeader("Accept-Encoding", "gzip");
                }
            }
        });
        client.addResponseInterceptor(new HttpResponseInterceptor() {

            @Override
            public void process(
                    final HttpResponse response,
                    final HttpContext context) throws HttpException, IOException {
                final HttpEntity entity = response.getEntity();
                if (entity != null) {
                    final Header contentEncoding = entity.getContentEncoding();
                    if (contentEncoding != null) {
                        for (final HeaderElement codec : contentEncoding.getElements()) {
                            if (codec.getName().equalsIgnoreCase("gzip")) {
                                response.setEntity(new GzipDecompressingEntity(response.getEntity()));
                                return;
                            }
                        }
                    }
                }
            }

        });

        return client;
    }

    /**
     * POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @return the HTTP response, or null in case of an encoding error params
     */
    public static HttpResponse postRequest(final String uri, final Parameters params) {
        return request("POST", uri, params, null, null);
    }

    /**
     * POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @params headers the headers to add to the request
     * @return the HTTP response, or null in case of an encoding error params
     */
    public static HttpResponse postRequest(final String uri, final Parameters params, final Parameters headers) {
        return request("POST", uri, params, headers, null);
    }

    /**
     *  POST HTTP request with Json POST DATA
     *
     * @param uri the URI to request
     * @param json the json object to add to the POST request
     * @return the HTTP response, or null in case of an encoding error params
     */
    public static HttpResponse postJsonRequest(final String uri, final JSONObject json) {
        HttpPost request = new HttpPost(uri);
        request.addHeader("Content-Type", "application/json; charset=utf-8");
        if (json != null) {
            try {
                request.setEntity(new StringEntity(json.toString()));
            } catch (UnsupportedEncodingException e) {
                Log.e("postJsonRequest:JSON Entity: UnsupportedEncodingException");
                return null;
            }
        }
        return doRepeatedRequests(request);
    }

    /**
     * Multipart POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @param fileFieldName the name of the file field name
     * @param fileContentType the content-type of the file
     * @param file the file to include in the request
     * @return the HTTP response, or null in case of an encoding error param
     */
    public static HttpResponse postRequest(final String uri, final Parameters params,
                                           final String fileFieldName, final String fileContentType, final File file) {
        final MultipartEntity entity = new MultipartEntity();
        for (final NameValuePair param : params) {
            try {
                entity.addPart(param.getName(), new StringBody(param.getValue()));
            } catch (final UnsupportedEncodingException e) {
                Log.e("Network.postRequest: unsupported encoding for parameter " + param.getName(), e);
                return null;
            }
        }
        entity.addPart(fileFieldName, new FileBody(file, fileContentType));

        final HttpPost request = new HttpPost(uri);
        request.setEntity(entity);

        addHeaders(request, null, null);
        return doRepeatedRequests(request);
    }

    /**
     * Make an HTTP request
     *
     * @param method
     *            the HTTP method to use ("GET" or "POST")
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add to the URI
     * @param headers
     *            the headers to add to the request
     * @param cacheFile
     *            the cache file used to cache this query
     * @return the HTTP response, or null in case of an encoding error in a POST request arguments
     */
    private static HttpResponse request(final String method, final String uri, final Parameters params, final Parameters headers, final File cacheFile) {
        HttpRequestBase request;
        if (method.equals("GET")) {
            final String fullUri = params == null ? uri : Uri.parse(uri).buildUpon().encodedQuery(params.toString()).build().toString();
            request = new HttpGet(fullUri);
        } else {
            request = new HttpPost(uri);
            if (params != null) {
                try {
                    ((HttpPost) request).setEntity(new UrlEncodedFormEntity(params, CharEncoding.UTF_8));
                } catch (final UnsupportedEncodingException e) {
                    Log.e("request", e);
                    return null;
                }
            }
        }

        addHeaders(request, headers, cacheFile);

        return doRepeatedRequests(request);
    }

    /**
     * Add headers to HTTP request.
     * @param request
     *            the request to add headers to
     * @param headers
     *            the headers to add (in addition to the standard headers), can be null
     * @param cacheFile
     *            if non-null, the file to take ETag and If-Modified-Since information from
     */
    private static void addHeaders(final HttpRequestBase request, final Parameters headers, final File cacheFile) {
        for (final NameValuePair header : Parameters.extend(Parameters.merge(headers, cacheHeaders(cacheFile)),
                "Accept-Charset", "utf-8,iso-8859-1;q=0.8,utf-16;q=0.8,*;q=0.7",
                "Accept-Language", "en-US,*;q=0.9",
                "X-Requested-With", "XMLHttpRequest")) {
            request.setHeader(header.getName(), header.getValue());
        }
        request.getParams().setParameter(CoreProtocolPNames.USER_AGENT,
                Settings.getUseNativeUa() ? Network.NATIVE_USER_AGENT : Network.PC_USER_AGENT);
    }

    /**
     * Retry a request for a few times.
     *
     * @param request
     *            the request to try
     * @return
     *            the response, or null if there has been a failure
     */
    private static HttpResponse doRepeatedRequests(final HttpRequestBase request) {
        final String reqLogStr = request.getMethod() + " " + Network.hidePassword(request.getURI().toString());
        Log.d(reqLogStr);

        final HttpClient client = Network.getHttpClient();
        for (int i = 0; i <= Network.NB_DOWNLOAD_RETRIES; i++) {
            final long before = System.currentTimeMillis();
            try {
                final HttpResponse response = client.execute(request);
                int status = response.getStatusLine().getStatusCode();
                if (status == 200) {
                    Log.d(status + Network.formatTimeSpan(before) + reqLogStr);
                } else {
                    Log.w(status + " [" + response.getStatusLine().getReasonPhrase() + "]" + Network.formatTimeSpan(before) + reqLogStr);
                }
                return response;
            } catch (IOException e) {
                final String timeSpan = Network.formatTimeSpan(before);
                final String tries = (i + 1) + "/" + (Network.NB_DOWNLOAD_RETRIES + 1);
                if (i == Network.NB_DOWNLOAD_RETRIES) {
                    Log.e("Failure " + tries + timeSpan + reqLogStr, e);
                } else {
                    Log.e("Failure " + tries + " (" + e.toString() + ")" + timeSpan + "- retrying " + reqLogStr);
                }
            }
        }

        return null;
    }

    private static Parameters cacheHeaders(final File cacheFile) {
        if (cacheFile == null || !cacheFile.exists()) {
            return null;
        }

        final String etag = LocalStorage.getSavedHeader(cacheFile, "etag");
        if (etag != null) {
            return new Parameters("If-None-Match", etag);
        }

        final String lastModified = LocalStorage.getSavedHeader(cacheFile, "last-modified");
        if (lastModified != null) {
            return new Parameters("If-Modified-Since", lastModified);
        }

        return null;
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @param cacheFile
     *            the name of the file storing the cached resource, or null not to use one
     * @return the HTTP response
     */
    public static HttpResponse getRequest(final String uri, final Parameters params, final File cacheFile) {
        return request("GET", uri, params, null, cacheFile);
    }


    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @return the HTTP response
     */
    public static HttpResponse getRequest(final String uri, final Parameters params) {
        return request("GET", uri, params, null, null);
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @param headers
     *            the headers to add to the GET request
     * @return the HTTP response
     */
    public static HttpResponse getRequest(final String uri, final Parameters params, final Parameters headers) {
        return request("GET", uri, params, headers, null);
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @return the HTTP response
     */
    public static HttpResponse getRequest(final String uri) {
        return request("GET", uri, null, null, null);
    }

    private static String formatTimeSpan(final long before) {
        // don't use String.format in a pure logging routine, it has very bad performance
        return " (" + (System.currentTimeMillis() - before) + " ms) ";
    }

    static public boolean isSuccess(final HttpResponse response) {
        return response != null && response.getStatusLine().getStatusCode() == 200;
    }

    /**
     * Get the result of a GET HTTP request returning a JSON body.
     *
     * @param uri the base URI of the GET HTTP request
     * @param params the query parameters, or <code>null</code> if there are none
     * @return a JSON object if the request was successful and the body could be decoded, <code>null</code> otherwise
     */
    public static JSONObject requestJSON(final String uri, final Parameters params) {
        final HttpResponse response = request("GET", uri, params, new Parameters("Accept", "application/json, text/javascript, */*; q=0.01"), null);
        final String responseData = Network.getResponseData(response, false);
        if (responseData != null) {
            try {
                return new JSONObject(responseData);
            } catch (final JSONException e) {
                Log.w("Network.requestJSON", e);
            }
        }

        return null;
    }

    private static String getResponseDataNoError(final HttpResponse response, boolean replaceWhitespace) {
        try {
            String data = EntityUtils.toString(response.getEntity(), CharEncoding.UTF_8);
            return replaceWhitespace ? BaseUtils.replaceWhitespace(data) : data;
        } catch (Exception e) {
            Log.e("getResponseData", e);
            return null;
        }
    }

    /**
     * Get the body of a HTTP response.
     *
     * {@link BaseUtils#replaceWhitespace(String)} will be called on the result
     *
     * @param response a HTTP response, which can be null
     * @return the body if the response comes from a successful HTTP request, <code>null</code> otherwise
     */
    public static String getResponseData(final HttpResponse response) {
        return Network.getResponseData(response, true);
    }

    /**
     * Get the body of a HTTP response.
     *
     * @param response a HTTP response, which can be null
     * @param replaceWhitespace <code>true</code> if {@link BaseUtils#replaceWhitespace(String)}
     *                          should be called on the body
     * @return the body if the response comes from a successful HTTP request, <code>null</code> otherwise
     */
    public static String getResponseData(final HttpResponse response, boolean replaceWhitespace) {
        if (!isSuccess(response)) {
            return null;
        }
        return getResponseDataNoError(response, replaceWhitespace);
    }

    public static String rfc3986URLEncode(String text) {
        return StringUtils.replace(Network.encode(text).replace("+", "%20"), "%7E", "~");
    }

    public static String decode(final String text) {
        try {
            return URLDecoder.decode(text, CharEncoding.UTF_8);
        } catch (UnsupportedEncodingException e) {
            Log.e("Network.decode", e);
        }
        return null;
    }

    public static String encode(final String text) {
        try {
            return URLEncoder.encode(text, CharEncoding.UTF_8);
        } catch (UnsupportedEncodingException e) {
            Log.e("Network.encode", e);
        }
        return null;
    }

}
!@#$%
20190527_001409,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_a19172
package cgeo.geocaching.network;

import cgeo.geocaching.Settings;
import cgeo.geocaching.files.LocalStorage;
import cgeo.geocaching.utils.BaseUtils;
import cgeo.geocaching.utils.Log;

import ch.boye.httpclientandroidlib.Header;
import ch.boye.httpclientandroidlib.HeaderElement;
import ch.boye.httpclientandroidlib.HttpEntity;
import ch.boye.httpclientandroidlib.HttpException;
import ch.boye.httpclientandroidlib.HttpRequest;
import ch.boye.httpclientandroidlib.HttpRequestInterceptor;
import ch.boye.httpclientandroidlib.HttpResponse;
import ch.boye.httpclientandroidlib.HttpResponseInterceptor;
import ch.boye.httpclientandroidlib.NameValuePair;
import ch.boye.httpclientandroidlib.ProtocolException;
import ch.boye.httpclientandroidlib.client.HttpClient;
import ch.boye.httpclientandroidlib.client.entity.GzipDecompressingEntity;
import ch.boye.httpclientandroidlib.client.entity.UrlEncodedFormEntity;
import ch.boye.httpclientandroidlib.client.methods.HttpGet;
import ch.boye.httpclientandroidlib.client.methods.HttpPost;
import ch.boye.httpclientandroidlib.client.methods.HttpRequestBase;
import ch.boye.httpclientandroidlib.client.params.ClientPNames;
import ch.boye.httpclientandroidlib.entity.StringEntity;
import ch.boye.httpclientandroidlib.entity.mime.MultipartEntity;
import ch.boye.httpclientandroidlib.entity.mime.content.FileBody;
import ch.boye.httpclientandroidlib.entity.mime.content.StringBody;
import ch.boye.httpclientandroidlib.impl.client.DefaultHttpClient;
import ch.boye.httpclientandroidlib.impl.client.DefaultRedirectStrategy;
import ch.boye.httpclientandroidlib.params.BasicHttpParams;
import ch.boye.httpclientandroidlib.params.CoreConnectionPNames;
import ch.boye.httpclientandroidlib.params.CoreProtocolPNames;
import ch.boye.httpclientandroidlib.params.HttpParams;
import ch.boye.httpclientandroidlib.protocol.HttpContext;
import ch.boye.httpclientandroidlib.util.EntityUtils;

import org.apache.commons.lang3.CharEncoding;
import org.apache.commons.lang3.StringUtils;
import org.json.JSONException;
import org.json.JSONObject;

import android.net.Uri;

import java.io.File;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.net.URLEncoder;

public abstract class Network {

    private static final int NB_DOWNLOAD_RETRIES = 4;

    /** User agent id */
    private final static String PC_USER_AGENT = "Mozilla/5.0 (X11; Linux x86_64; rv:9.0.1) Gecko/20100101 Firefox/9.0.1";
    /** Native user agent, taken from a Android 2.2 Nexus **/
    private final static String NATIVE_USER_AGENT = "Mozilla/5.0 (Linux; U; Android 2.2; en-us; Nexus One Build/FRF91) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1";

    private static final String PATTERN_PASSWORD = "(?<=[\\?&])[Pp]ass(w(or)?d)?=[^&#$]+";

    private final static HttpParams clientParams = new BasicHttpParams();

    static {
        Network.clientParams.setParameter(CoreProtocolPNames.HTTP_CONTENT_CHARSET, CharEncoding.UTF_8);
        Network.clientParams.setParameter(CoreConnectionPNames.CONNECTION_TIMEOUT, 30000);
        Network.clientParams.setParameter(CoreConnectionPNames.SO_TIMEOUT, 30000);
        Network.clientParams.setParameter(ClientPNames.HANDLE_REDIRECTS,  true);
    }

    private static String hidePassword(final String message) {
        return message.replaceAll(Network.PATTERN_PASSWORD, "password=***");
    }

    private static HttpClient getHttpClient() {
        final DefaultHttpClient client = new DefaultHttpClient();
        client.setCookieStore(Cookies.cookieStore);
        client.setParams(clientParams);

        client.setRedirectStrategy(new DefaultRedirectStrategy() {
            @Override
            public boolean isRedirected(HttpRequest request, HttpResponse response, HttpContext context) {
                boolean isRedirect = false;
                try {
                    isRedirect = super.isRedirected(request, response, context);
                } catch (final ProtocolException e) {
                    Log.e("httpclient.isRedirected: unable to check for redirection", e);
                }
                if (!isRedirect) {
                    final int responseCode = response.getStatusLine().getStatusCode();
                    if (responseCode == 301 || responseCode == 302) {
                        return true;
                    }
                }
                return isRedirect;
            }
        });

        client.addRequestInterceptor(new HttpRequestInterceptor() {

            @Override
            public void process(
                    final HttpRequest request,
                    final HttpContext context) throws HttpException, IOException {
                if (!request.containsHeader("Accept-Encoding")) {
                    request.addHeader("Accept-Encoding", "gzip");
                }
            }
        });
        client.addResponseInterceptor(new HttpResponseInterceptor() {

            @Override
            public void process(
                    final HttpResponse response,
                    final HttpContext context) throws HttpException, IOException {
                final HttpEntity entity = response.getEntity();
                if (entity != null) {
                    final Header contentEncoding = entity.getContentEncoding();
                    if (contentEncoding != null) {
                        for (final HeaderElement codec : contentEncoding.getElements()) {
                            if (codec.getName().equalsIgnoreCase("gzip")) {
                                response.setEntity(new GzipDecompressingEntity(response.getEntity()));
                                return;
                            }
                        }
                    }
                }
            }

        });

        return client;
    }

    /**
     * POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @return the HTTP response, or null in case of an encoding error params
     */
    public static HttpResponse postRequest(final String uri, final Parameters params) {
        return request("POST", uri, params, null, null);
    }

    /**
     * POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @params headers the headers to add to the request
     * @return the HTTP response, or null in case of an encoding error params
     */
    public static HttpResponse postRequest(final String uri, final Parameters params, final Parameters headers) {
        return request("POST", uri, params, headers, null);
    }

    /**
     *  POST HTTP request with Json POST DATA
     *
     * @param uri the URI to request
     * @param json the json object to add to the POST request
     * @return the HTTP response, or null in case of an encoding error params
     */
    public static HttpResponse postJsonRequest(final String uri, final JSONObject json) {
        HttpPost request = new HttpPost(uri);
        request.addHeader("Content-Type", "application/json; charset=utf-8");
        if (json != null) {
            try {
                request.setEntity(new StringEntity(json.toString()));
            } catch (UnsupportedEncodingException e) {
                Log.e("postJsonRequest:JSON Entity: UnsupportedEncodingException");
                return null;
            }
        }
        return doRepeatedRequests(request);
    }

    /**
     * Multipart POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @param fileFieldName the name of the file field name
     * @param fileContentType the content-type of the file
     * @param file the file to include in the request
     * @return the HTTP response, or null in case of an encoding error param
     */
    public static HttpResponse postRequest(final String uri, final Parameters params,
                                           final String fileFieldName, final String fileContentType, final File file) {
        final MultipartEntity entity = new MultipartEntity();
        for (final NameValuePair param : params) {
            try {
                entity.addPart(param.getName(), new StringBody(param.getValue()));
            } catch (final UnsupportedEncodingException e) {
                Log.e("Network.postRequest: unsupported encoding for parameter " + param.getName(), e);
                return null;
            }
        }
        entity.addPart(fileFieldName, new FileBody(file, fileContentType));

        final HttpPost request = new HttpPost(uri);
        request.setEntity(entity);

        addHeaders(request, null, null);
        return doRepeatedRequests(request);
    }

    /**
     * Make an HTTP request
     *
     * @param method
     *            the HTTP method to use ("GET" or "POST")
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add to the URI
     * @param headers
     *            the headers to add to the request
     * @param cacheFile
     *            the cache file used to cache this query
     * @return the HTTP response, or null in case of an encoding error in a POST request arguments
     */
    private static HttpResponse request(final String method, final String uri, final Parameters params, final Parameters headers, final File cacheFile) {
        HttpRequestBase request;
        if (method.equals("GET")) {
            final String fullUri = params == null ? uri : Uri.parse(uri).buildUpon().encodedQuery(params.toString()).build().toString();
            request = new HttpGet(fullUri);
        } else {
            request = new HttpPost(uri);
            if (params != null) {
                try {
                    ((HttpPost) request).setEntity(new UrlEncodedFormEntity(params, CharEncoding.UTF_8));
                } catch (final UnsupportedEncodingException e) {
                    Log.e("request", e);
                    return null;
                }
            }
        }

        addHeaders(request, headers, cacheFile);

        return doRepeatedRequests(request);
    }

    /**
     * Add headers to HTTP request.
     * @param request
     *            the request to add headers to
     * @param headers
     *            the headers to add (in addition to the standard headers), can be null
     * @param cacheFile
     *            if non-null, the file to take ETag and If-Modified-Since information from
     */
    private static void addHeaders(final HttpRequestBase request, final Parameters headers, final File cacheFile) {
        for (final NameValuePair header : Parameters.extend(Parameters.merge(headers, cacheHeaders(cacheFile)),
                "Accept-Charset", "utf-8,iso-8859-1;q=0.8,utf-16;q=0.8,*;q=0.7",
                "Accept-Language", "en-US,*;q=0.9",
                "X-Requested-With", "XMLHttpRequest")) {
            request.setHeader(header.getName(), header.getValue());
        }
        request.getParams().setParameter(CoreProtocolPNames.USER_AGENT,
                Settings.getUseNativeUa() ? Network.NATIVE_USER_AGENT : Network.PC_USER_AGENT);
    }

    /**
     * Retry a request for a few times.
     *
     * @param request
     *            the request to try
     * @return
     *            the response, or null if there has been a failure
     */
    private static HttpResponse doRepeatedRequests(final HttpRequestBase request) {
        final String reqLogStr = request.getMethod() + " " + Network.hidePassword(request.getURI().toString());
        Log.d(reqLogStr);

        final HttpClient client = Network.getHttpClient();
        for (int i = 0; i <= Network.NB_DOWNLOAD_RETRIES; i++) {
            final long before = System.currentTimeMillis();
            try {
                final HttpResponse response = client.execute(request);
                int status = response.getStatusLine().getStatusCode();
                if (status == 200) {
                    Log.d(status + Network.formatTimeSpan(before) + reqLogStr);
                } else {
                    Log.w(status + " [" + response.getStatusLine().getReasonPhrase() + "]" + Network.formatTimeSpan(before) + reqLogStr);
                }
                return response;
            } catch (IOException e) {
                final String timeSpan = Network.formatTimeSpan(before);
                final String tries = (i + 1) + "/" + (Network.NB_DOWNLOAD_RETRIES + 1);
                if (i == Network.NB_DOWNLOAD_RETRIES) {
                    Log.e("Failure " + tries + timeSpan + reqLogStr, e);
                } else {
                    Log.e("Failure " + tries + " (" + e.toString() + ")" + timeSpan + "- retrying " + reqLogStr);
                }
            }
        }

        return null;
    }

    private static Parameters cacheHeaders(final File cacheFile) {
        if (cacheFile == null || !cacheFile.exists()) {
            return null;
        }

        final String etag = LocalStorage.getSavedHeader(cacheFile, "etag");
        if (etag != null) {
            return new Parameters("If-None-Match", etag);
        }

        final String lastModified = LocalStorage.getSavedHeader(cacheFile, "last-modified");
        if (lastModified != null) {
            return new Parameters("If-Modified-Since", lastModified);
        }

        return null;
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @param cacheFile
     *            the name of the file storing the cached resource, or null not to use one
     * @return the HTTP response
     */
    public static HttpResponse getRequest(final String uri, final Parameters params, final File cacheFile) {
        return request("GET", uri, params, null, cacheFile);
    }


    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @return the HTTP response
     */
    public static HttpResponse getRequest(final String uri, final Parameters params) {
        return request("GET", uri, params, null, null);
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @param headers
     *            the headers to add to the GET request
     * @return the HTTP response
     */
    public static HttpResponse getRequest(final String uri, final Parameters params, final Parameters headers) {
        return request("GET", uri, params, headers, null);
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @return the HTTP response
     */
    public static HttpResponse getRequest(final String uri) {
        return request("GET", uri, null, null, null);
    }

    private static String formatTimeSpan(final long before) {
        // don't use String.format in a pure logging routine, it has very bad performance
        return " (" + (System.currentTimeMillis() - before) + " ms) ";
    }

    static public boolean isSuccess(final HttpResponse response) {
        return response != null && response.getStatusLine().getStatusCode() == 200;
    }

    public static JSONObject requestJSON(final String uri, final Parameters params) {
        final HttpResponse response = request("GET", uri, params, new Parameters("Accept", "application/json, text/javascript, */*; q=0.01"), null);
        if (isSuccess(response)) {
            try {
                return new JSONObject(Network.getResponseData(response));
            } catch (final JSONException e) {
                Log.e("Network.requestJSON", e);
            }
        }

        return null;
    }

    private static String getResponseDataNoError(final HttpResponse response, boolean replaceWhitespace) {
        try {
            String data = EntityUtils.toString(response.getEntity(), CharEncoding.UTF_8);
            return replaceWhitespace ? BaseUtils.replaceWhitespace(data) : data;
        } catch (Exception e) {
            Log.e("getResponseData", e);
            return null;
        }
    }

    public static String getResponseData(final HttpResponse response) {
        return Network.getResponseData(response, true);
    }

    public static String getResponseData(final HttpResponse response, boolean replaceWhitespace) {
        if (!isSuccess(response)) {
            return null;
        }
        return getResponseDataNoError(response, replaceWhitespace);
    }

    public static String rfc3986URLEncode(String text) {
        return StringUtils.replace(Network.encode(text).replace("+", "%20"), "%7E", "~");
    }

    public static String decode(final String text) {
        try {
            return URLDecoder.decode(text, CharEncoding.UTF_8);
        } catch (UnsupportedEncodingException e) {
            Log.e("Network.decode", e);
        }
        return null;
    }

    public static String encode(final String text) {
        try {
            return URLEncoder.encode(text, CharEncoding.UTF_8);
        } catch (UnsupportedEncodingException e) {
            Log.e("Network.encode", e);
        }
        return null;
    }

}
!@#$%
20190527_001409,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_c19172
package cgeo.geocaching.network;

import cgeo.geocaching.Settings;
import cgeo.geocaching.files.LocalStorage;
import cgeo.geocaching.utils.BaseUtils;
import cgeo.geocaching.utils.Log;

import ch.boye.httpclientandroidlib.Header;
import ch.boye.httpclientandroidlib.HeaderElement;
import ch.boye.httpclientandroidlib.HttpEntity;
import ch.boye.httpclientandroidlib.HttpException;
import ch.boye.httpclientandroidlib.HttpRequest;
import ch.boye.httpclientandroidlib.HttpRequestInterceptor;
import ch.boye.httpclientandroidlib.HttpResponse;
import ch.boye.httpclientandroidlib.HttpResponseInterceptor;
import ch.boye.httpclientandroidlib.NameValuePair;
import ch.boye.httpclientandroidlib.ProtocolException;
import ch.boye.httpclientandroidlib.client.HttpClient;
import ch.boye.httpclientandroidlib.client.entity.GzipDecompressingEntity;
import ch.boye.httpclientandroidlib.client.entity.UrlEncodedFormEntity;
import ch.boye.httpclientandroidlib.client.methods.HttpGet;
import ch.boye.httpclientandroidlib.client.methods.HttpPost;
import ch.boye.httpclientandroidlib.client.methods.HttpRequestBase;
import ch.boye.httpclientandroidlib.client.params.ClientPNames;
import ch.boye.httpclientandroidlib.entity.StringEntity;
import ch.boye.httpclientandroidlib.entity.mime.MultipartEntity;
import ch.boye.httpclientandroidlib.entity.mime.content.FileBody;
import ch.boye.httpclientandroidlib.entity.mime.content.StringBody;
import ch.boye.httpclientandroidlib.impl.client.DefaultHttpClient;
import ch.boye.httpclientandroidlib.impl.client.DefaultRedirectStrategy;
import ch.boye.httpclientandroidlib.params.BasicHttpParams;
import ch.boye.httpclientandroidlib.params.CoreConnectionPNames;
import ch.boye.httpclientandroidlib.params.CoreProtocolPNames;
import ch.boye.httpclientandroidlib.params.HttpParams;
import ch.boye.httpclientandroidlib.protocol.HttpContext;
import ch.boye.httpclientandroidlib.util.EntityUtils;

import org.apache.commons.lang3.CharEncoding;
import org.apache.commons.lang3.StringUtils;
import org.json.JSONException;
import org.json.JSONObject;

import android.net.Uri;

import java.io.File;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.net.URLEncoder;

public abstract class Network {

    private static final int NB_DOWNLOAD_RETRIES = 4;

    /** User agent id */
    private final static String PC_USER_AGENT = "Mozilla/5.0 (X11; Linux x86_64; rv:9.0.1) Gecko/20100101 Firefox/9.0.1";
    /** Native user agent, taken from a Android 2.2 Nexus **/
    private final static String NATIVE_USER_AGENT = "Mozilla/5.0 (Linux; U; Android 2.2; en-us; Nexus One Build/FRF91) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1";

    private static final String PATTERN_PASSWORD = "(?<=[\\?&])[Pp]ass(w(or)?d)?=[^&#$]+";

    private final static HttpParams clientParams = new BasicHttpParams();

    static {
        Network.clientParams.setParameter(CoreProtocolPNames.HTTP_CONTENT_CHARSET, CharEncoding.UTF_8);
        Network.clientParams.setParameter(CoreConnectionPNames.CONNECTION_TIMEOUT, 30000);
        Network.clientParams.setParameter(CoreConnectionPNames.SO_TIMEOUT, 30000);
        Network.clientParams.setParameter(ClientPNames.HANDLE_REDIRECTS,  true);
    }

    private static String hidePassword(final String message) {
        return message.replaceAll(Network.PATTERN_PASSWORD, "password=***");
    }

    private static HttpClient getHttpClient() {
        final DefaultHttpClient client = new DefaultHttpClient();
        client.setCookieStore(Cookies.cookieStore);
        client.setParams(clientParams);

        client.setRedirectStrategy(new DefaultRedirectStrategy() {
            @Override
            public boolean isRedirected(HttpRequest request, HttpResponse response, HttpContext context) {
                boolean isRedirect = false;
                try {
                    isRedirect = super.isRedirected(request, response, context);
                } catch (final ProtocolException e) {
                    Log.e("httpclient.isRedirected: unable to check for redirection", e);
                }
                if (!isRedirect) {
                    final int responseCode = response.getStatusLine().getStatusCode();
                    if (responseCode == 301 || responseCode == 302) {
                        return true;
                    }
                }
                return isRedirect;
            }
        });

        client.addRequestInterceptor(new HttpRequestInterceptor() {

            @Override
            public void process(
                    final HttpRequest request,
                    final HttpContext context) throws HttpException, IOException {
                if (!request.containsHeader("Accept-Encoding")) {
                    request.addHeader("Accept-Encoding", "gzip");
                }
            }
        });
        client.addResponseInterceptor(new HttpResponseInterceptor() {

            @Override
            public void process(
                    final HttpResponse response,
                    final HttpContext context) throws HttpException, IOException {
                final HttpEntity entity = response.getEntity();
                if (entity != null) {
                    final Header contentEncoding = entity.getContentEncoding();
                    if (contentEncoding != null) {
                        for (final HeaderElement codec : contentEncoding.getElements()) {
                            if (codec.getName().equalsIgnoreCase("gzip")) {
                                response.setEntity(new GzipDecompressingEntity(response.getEntity()));
                                return;
                            }
                        }
                    }
                }
            }

        });

        return client;
    }

    /**
     * POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @return the HTTP response, or null in case of an encoding error params
     */
    public static HttpResponse postRequest(final String uri, final Parameters params) {
        return request("POST", uri, params, null, null);
    }

    /**
     * POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @params headers the headers to add to the request
     * @return the HTTP response, or null in case of an encoding error params
     */
    public static HttpResponse postRequest(final String uri, final Parameters params, final Parameters headers) {
        return request("POST", uri, params, headers, null);
    }

    /**
     *  POST HTTP request with Json POST DATA
     *
     * @param uri the URI to request
     * @param json the json object to add to the POST request
     * @return the HTTP response, or null in case of an encoding error params
     */
    public static HttpResponse postJsonRequest(final String uri, final JSONObject json) {
        HttpPost request = new HttpPost(uri);
        request.addHeader("Content-Type", "application/json; charset=utf-8");
        if (json != null) {
            try {
                request.setEntity(new StringEntity(json.toString()));
            } catch (UnsupportedEncodingException e) {
                Log.e("postJsonRequest:JSON Entity: UnsupportedEncodingException");
                return null;
            }
        }
        return doRepeatedRequests(request);
    }

    /**
     * Multipart POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @param fileFieldName the name of the file field name
     * @param fileContentType the content-type of the file
     * @param file the file to include in the request
     * @return the HTTP response, or null in case of an encoding error param
     */
    public static HttpResponse postRequest(final String uri, final Parameters params,
                                           final String fileFieldName, final String fileContentType, final File file) {
        final MultipartEntity entity = new MultipartEntity();
        for (final NameValuePair param : params) {
            try {
                entity.addPart(param.getName(), new StringBody(param.getValue()));
            } catch (final UnsupportedEncodingException e) {
                Log.e("Network.postRequest: unsupported encoding for parameter " + param.getName(), e);
                return null;
            }
        }
        entity.addPart(fileFieldName, new FileBody(file, fileContentType));

        final HttpPost request = new HttpPost(uri);
        request.setEntity(entity);

        addHeaders(request, null, null);
        return doRepeatedRequests(request);
    }

    /**
     * Make an HTTP request
     *
     * @param method
     *            the HTTP method to use ("GET" or "POST")
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add to the URI
     * @param headers
     *            the headers to add to the request
     * @param cacheFile
     *            the cache file used to cache this query
     * @return the HTTP response, or null in case of an encoding error in a POST request arguments
     */
    private static HttpResponse request(final String method, final String uri, final Parameters params, final Parameters headers, final File cacheFile) {
        HttpRequestBase request;
        if (method.equals("GET")) {
            final String fullUri = params == null ? uri : Uri.parse(uri).buildUpon().encodedQuery(params.toString()).build().toString();
            request = new HttpGet(fullUri);
        } else {
            request = new HttpPost(uri);
            if (params != null) {
                try {
                    ((HttpPost) request).setEntity(new UrlEncodedFormEntity(params, CharEncoding.UTF_8));
                } catch (final UnsupportedEncodingException e) {
                    Log.e("request", e);
                    return null;
                }
            }
        }

        addHeaders(request, headers, cacheFile);

        return doRepeatedRequests(request);
    }

    /**
     * Add headers to HTTP request.
     * @param request
     *            the request to add headers to
     * @param headers
     *            the headers to add (in addition to the standard headers), can be null
     * @param cacheFile
     *            if non-null, the file to take ETag and If-Modified-Since information from
     */
    private static void addHeaders(final HttpRequestBase request, final Parameters headers, final File cacheFile) {
        for (final NameValuePair header : Parameters.extend(Parameters.merge(headers, cacheHeaders(cacheFile)),
                "Accept-Charset", "utf-8,iso-8859-1;q=0.8,utf-16;q=0.8,*;q=0.7",
                "Accept-Language", "en-US,*;q=0.9",
                "X-Requested-With", "XMLHttpRequest")) {
            request.setHeader(header.getName(), header.getValue());
        }
        request.getParams().setParameter(CoreProtocolPNames.USER_AGENT,
                Settings.getUseNativeUa() ? Network.NATIVE_USER_AGENT : Network.PC_USER_AGENT);
    }

    /**
     * Retry a request for a few times.
     *
     * @param request
     *            the request to try
     * @return
     *            the response, or null if there has been a failure
     */
    private static HttpResponse doRepeatedRequests(final HttpRequestBase request) {
        final String reqLogStr = request.getMethod() + " " + Network.hidePassword(request.getURI().toString());
        Log.d(reqLogStr);

        final HttpClient client = Network.getHttpClient();
        for (int i = 0; i <= Network.NB_DOWNLOAD_RETRIES; i++) {
            final long before = System.currentTimeMillis();
            try {
                final HttpResponse response = client.execute(request);
                int status = response.getStatusLine().getStatusCode();
                if (status == 200) {
                    Log.d(status + Network.formatTimeSpan(before) + reqLogStr);
                } else {
                    Log.w(status + " [" + response.getStatusLine().getReasonPhrase() + "]" + Network.formatTimeSpan(before) + reqLogStr);
                }
                return response;
            } catch (IOException e) {
                final String timeSpan = Network.formatTimeSpan(before);
                final String tries = (i + 1) + "/" + (Network.NB_DOWNLOAD_RETRIES + 1);
                if (i == Network.NB_DOWNLOAD_RETRIES) {
                    Log.w("Failure " + tries + timeSpan + reqLogStr + " (" + e.toString() + ")");
                } else {
                    Log.w("Failure " + tries + " (" + e.toString() + ")" + timeSpan + "- retrying " + reqLogStr);
                }
            }
        }

        return null;
    }

    private static Parameters cacheHeaders(final File cacheFile) {
        if (cacheFile == null || !cacheFile.exists()) {
            return null;
        }

        final String etag = LocalStorage.getSavedHeader(cacheFile, "etag");
        if (etag != null) {
            return new Parameters("If-None-Match", etag);
        }

        final String lastModified = LocalStorage.getSavedHeader(cacheFile, "last-modified");
        if (lastModified != null) {
            return new Parameters("If-Modified-Since", lastModified);
        }

        return null;
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @param cacheFile
     *            the name of the file storing the cached resource, or null not to use one
     * @return the HTTP response
     */
    public static HttpResponse getRequest(final String uri, final Parameters params, final File cacheFile) {
        return request("GET", uri, params, null, cacheFile);
    }


    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @return the HTTP response
     */
    public static HttpResponse getRequest(final String uri, final Parameters params) {
        return request("GET", uri, params, null, null);
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @param headers
     *            the headers to add to the GET request
     * @return the HTTP response
     */
    public static HttpResponse getRequest(final String uri, final Parameters params, final Parameters headers) {
        return request("GET", uri, params, headers, null);
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @return the HTTP response
     */
    public static HttpResponse getRequest(final String uri) {
        return request("GET", uri, null, null, null);
    }

    private static String formatTimeSpan(final long before) {
        // don't use String.format in a pure logging routine, it has very bad performance
        return " (" + (System.currentTimeMillis() - before) + " ms) ";
    }

    static public boolean isSuccess(final HttpResponse response) {
        return response != null && response.getStatusLine().getStatusCode() == 200;
    }

    public static JSONObject requestJSON(final String uri, final Parameters params) {
        final HttpResponse response = request("GET", uri, params, new Parameters("Accept", "application/json, text/javascript, */*; q=0.01"), null);
        if (isSuccess(response)) {
            try {
                return new JSONObject(Network.getResponseData(response));
            } catch (final JSONException e) {
                Log.e("Network.requestJSON", e);
            }
        }

        return null;
    }

    private static String getResponseDataNoError(final HttpResponse response, boolean replaceWhitespace) {
        try {
            String data = EntityUtils.toString(response.getEntity(), CharEncoding.UTF_8);
            return replaceWhitespace ? BaseUtils.replaceWhitespace(data) : data;
        } catch (Exception e) {
            Log.e("getResponseData", e);
            return null;
        }
    }

    public static String getResponseData(final HttpResponse response) {
        return Network.getResponseData(response, true);
    }

    public static String getResponseData(final HttpResponse response, boolean replaceWhitespace) {
        if (!isSuccess(response)) {
            return null;
        }
        return getResponseDataNoError(response, replaceWhitespace);
    }

    public static String rfc3986URLEncode(String text) {
        return StringUtils.replace(Network.encode(text).replace("+", "%20"), "%7E", "~");
    }

    public static String decode(final String text) {
        try {
            return URLDecoder.decode(text, CharEncoding.UTF_8);
        } catch (UnsupportedEncodingException e) {
            Log.e("Network.decode", e);
        }
        return null;
    }

    public static String encode(final String text) {
        try {
            return URLEncoder.encode(text, CharEncoding.UTF_8);
        } catch (UnsupportedEncodingException e) {
            Log.e("Network.encode", e);
        }
        return null;
    }

}
!@#$%
20190527_001907,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_b18560
package cgeo.geocaching.ui;

import cgeo.geocaching.CacheDetailActivity;
import cgeo.geocaching.Geocache;
import cgeo.geocaching.IGeoData;
import cgeo.geocaching.R;
import cgeo.geocaching.Settings;
import cgeo.geocaching.cgeoapplication;
import cgeo.geocaching.enumerations.CacheListType;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.filter.IFilter;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.sorting.CacheComparator;
import cgeo.geocaching.sorting.DistanceComparator;
import cgeo.geocaching.sorting.InverseComparator;
import cgeo.geocaching.sorting.VisitComparator;
import cgeo.geocaching.utils.AngleUtils;
import cgeo.geocaching.utils.Log;

import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang3.builder.HashCodeBuilder;

import android.app.Activity;
import android.content.res.Resources;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.drawable.Drawable;
import android.graphics.drawable.LayerDrawable;
import android.text.Spannable;
import android.text.Spanned;
import android.text.style.ForegroundColorSpan;
import android.text.style.StrikethroughSpan;
import android.util.SparseArray;
import android.view.GestureDetector;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ArrayAdapter;
import android.widget.CheckBox;
import android.widget.ImageView;
import android.widget.RelativeLayout;
import android.widget.TextView;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;

public class CacheListAdapter extends ArrayAdapter<Geocache> {

    private LayoutInflater inflater = null;
    private CacheComparator cacheComparator = null;
    private Geopoint coords;
    private float azimuth = 0;
    private long lastSort = 0L;
    private boolean selectMode = false;
    private IFilter currentFilter = null;
    private List<Geocache> originalList = null;

    final private Set<CompassMiniView> compasses = new LinkedHashSet<CompassMiniView>();
    final private Set<DistanceView> distances = new LinkedHashSet<DistanceView>();
    final private CacheListType cacheListType;
    final private Resources res;
    /** Resulting list of caches */
    final private List<Geocache> list;
    private boolean inverseSort = false;

    private static final int SWIPE_MIN_DISTANCE = 60;
    private static final int SWIPE_MAX_OFF_PATH = 100;
    private static final SparseArray<Drawable> gcIconDrawables = new SparseArray<Drawable>();
    /**
     * time in milliseconds after which the list may be resorted due to position updates
     */
    private static final int PAUSE_BETWEEN_LIST_SORT = 1000;

    private static final int[] RATING_BACKGROUND = new int[3];
    static {
        if (Settings.isLightSkin()) {
            RATING_BACKGROUND[0] = R.drawable.favorite_background_red_light;
            RATING_BACKGROUND[1] = R.drawable.favorite_background_orange_light;
            RATING_BACKGROUND[2] = R.drawable.favorite_background_green_light;
        } else {
            RATING_BACKGROUND[0] = R.drawable.favorite_background_red_dark;
            RATING_BACKGROUND[1] = R.drawable.favorite_background_orange_dark;
            RATING_BACKGROUND[2] = R.drawable.favorite_background_green_dark;
        }
    }

    /**
     * view holder for the cache list adapter
     *
     */
    private static class ViewHolder {
        CheckBox checkbox;
        ImageView logStatusMark;
        TextView text;
        TextView favorite;
        TextView info;
        ImageView inventory;
        RelativeLayout directionLayout;
        DistanceView distance;
        CompassMiniView direction;
        RelativeLayout dirImgLayout;
        ImageView dirImg;
    }

    public CacheListAdapter(final Activity activity, final List<Geocache> list, CacheListType cacheListType) {
        super(activity, 0, list);
        final IGeoData currentGeo = cgeoapplication.getInstance().currentGeo();
        if (currentGeo != null) {
            coords = currentGeo.getCoords();
        }
        this.res = activity.getResources();
        this.list = list;
        this.cacheListType = cacheListType;
        if (cacheListType == CacheListType.HISTORY) {
            cacheComparator = new VisitComparator();
        }

        final Drawable modifiedCoordinatesMarker = activity.getResources().getDrawable(R.drawable.marker_usermodifiedcoords);
        for (final CacheType cacheType : CacheType.values()) {
            // unmodified icon
            int hashCode = getIconHashCode(cacheType, false);
            gcIconDrawables.put(hashCode, activity.getResources().getDrawable(cacheType.markerId));
            // icon with flag for user modified coordinates
            hashCode = getIconHashCode(cacheType, true);
            Drawable[] layers = new Drawable[2];
            layers[0] = activity.getResources().getDrawable(cacheType.markerId);
            layers[1] = modifiedCoordinatesMarker;
            LayerDrawable ld = new LayerDrawable(layers);
            ld.setLayerInset(1,
                    layers[0].getIntrinsicWidth() - layers[1].getIntrinsicWidth(),
                    layers[0].getIntrinsicHeight() - layers[1].getIntrinsicHeight(),
                    0, 0);
            gcIconDrawables.put(hashCode, ld);
        }
    }

    private static int getIconHashCode(final CacheType cacheType, final boolean userModifiedOrFinal) {
        return new HashCodeBuilder()
                .append(cacheType)
                .append(userModifiedOrFinal)
                .toHashCode();
    }

    /**
     * change the sort order
     *
     * @param comparator
     */
    public void setComparator(final CacheComparator comparator) {
        cacheComparator = comparator;
        forceSort();
    }

    public void resetInverseSort() {
        inverseSort = false;
    }

    public void toggleInverseSort() {
        inverseSort = !inverseSort;
    }

    public CacheComparator getCacheComparator() {
        return cacheComparator;
    }

    public Geocache findCacheByGeocode(String geocode) {
        for (int i = 0; i < getCount(); i++) {
            if (getItem(i).getGeocode().equalsIgnoreCase(geocode)) {
                return getItem(i);
            }
        }

        return null;
    }
    /**
     * Called when a new page of caches was loaded.
     */
    public void reFilter() {
        if (currentFilter != null) {
            // Back up the list again
            originalList = new ArrayList<Geocache>(list);

            currentFilter.filter(list);
        }
    }

    /**
     * Called after a user action on the filter menu.
     */
    public void setFilter(final IFilter filter) {
        // Backup current caches list if it isn't backed up yet
        if (originalList == null) {
            originalList = new ArrayList<Geocache>(list);
        }

        // If there is already a filter in place, this is a request to change or clear the filter, so we have to
        // replace the original cache list
        if (currentFilter != null) {
            list.clear();
            list.addAll(originalList);
        }

        // Do the filtering or clear it
        if (filter != null) {
            filter.filter(list);
        }
        currentFilter = filter;

        notifyDataSetChanged();
    }

    public boolean isFiltered() {
        return currentFilter != null;
    }

    public String getFilterName() {
        return currentFilter.getName();
    }

    public int getCheckedCount() {
        int checked = 0;
        for (Geocache cache : list) {
            if (cache.isStatusChecked()) {
                checked++;
            }
        }
        return checked;
    }

    public void setSelectMode(final boolean selectMode) {
        this.selectMode = selectMode;

        if (!selectMode) {
            for (final Geocache cache : list) {
                cache.setStatusChecked(false);
            }
        }
        notifyDataSetChanged();
    }

    public boolean isSelectMode() {
        return selectMode;
    }

    public void switchSelectMode() {
        setSelectMode(!isSelectMode());
    }

    public void invertSelection() {
        for (Geocache cache : list) {
            cache.setStatusChecked(!cache.isStatusChecked());
        }
        notifyDataSetChanged();
    }

    public void forceSort() {
        if (CollectionUtils.isEmpty(list) || selectMode) {
            return;
        }

        if (isSortedByDistance()) {
            lastSort = 0;
            updateSortByDistance();
        }
        else {
            Collections.sort(list, getPotentialInversion(cacheComparator));
        }

        notifyDataSetChanged();
    }

    public void setActualCoordinates(final Geopoint coords) {
        this.coords = coords;
        updateSortByDistance();

        for (final DistanceView distance : distances) {
            distance.update(coords);
        }
        for (final CompassMiniView compass : compasses) {
            compass.updateCurrentCoords(coords);
        }
    }

    private void updateSortByDistance() {
        if (CollectionUtils.isEmpty(list)) {
            return;
        }
        if (selectMode) {
            return;
        }
        if ((System.currentTimeMillis() - lastSort) <= PAUSE_BETWEEN_LIST_SORT) {
            return;
        }
        if (!isSortedByDistance()) {
            return;
        }
        if (coords == null) {
            return;
        }
        final ArrayList<Geocache> oldList = new ArrayList<Geocache>(list);
        Collections.sort(list, getPotentialInversion(new DistanceComparator(coords, list)));

        // avoid an update if the list has not changed due to location update
        if (list.equals(oldList)) {
            return;
        }
        notifyDataSetChanged();
        lastSort = System.currentTimeMillis();
    }

    private Comparator<? super Geocache> getPotentialInversion(final CacheComparator comparator) {
        if (inverseSort) {
            return new InverseComparator(comparator);
        }
        return comparator;
    }

    private boolean isSortedByDistance() {
        return cacheComparator == null || cacheComparator instanceof DistanceComparator;
    }

    public void setActualHeading(final float direction) {
        if (Math.abs(AngleUtils.difference(azimuth, direction)) < 10) {
            return;
        }

        azimuth = direction;
        for (final CompassMiniView compass : compasses) {
            compass.updateAzimuth(azimuth);
        }
    }

    @Override
    public View getView(final int position, final View rowView, final ViewGroup parent) {
        if (inflater == null) {
            inflater = ((Activity) getContext()).getLayoutInflater();
        }

        if (position > getCount()) {
            Log.w("CacheListAdapter.getView: Attempt to access missing item #" + position);
            return null;
        }

        final Geocache cache = getItem(position);

        View v = rowView;

        final ViewHolder holder;
        if (v == null) {
            v = inflater.inflate(R.layout.caches_item, null);

            holder = new ViewHolder();
            holder.checkbox = (CheckBox) v.findViewById(R.id.checkbox);
            holder.logStatusMark = (ImageView) v.findViewById(R.id.log_status_mark);
            holder.text = (TextView) v.findViewById(R.id.text);
            holder.directionLayout = (RelativeLayout) v.findViewById(R.id.direction_layout);
            holder.distance = (DistanceView) v.findViewById(R.id.distance);
            holder.direction = (CompassMiniView) v.findViewById(R.id.direction);
            holder.dirImgLayout = (RelativeLayout) v.findViewById(R.id.dirimg_layout);
            holder.dirImg = (ImageView) v.findViewById(R.id.dirimg);
            holder.inventory = (ImageView) v.findViewById(R.id.inventory);
            holder.favorite = (TextView) v.findViewById(R.id.favorite);
            holder.info = (TextView) v.findViewById(R.id.info);

            v.setTag(holder);
        } else {
            holder = (ViewHolder) v.getTag();
        }

        final boolean lightSkin = Settings.isLightSkin();

        final TouchListener touchLst = new TouchListener(cache);
        v.setOnClickListener(touchLst);
        v.setOnLongClickListener(touchLst);
        v.setOnTouchListener(touchLst);
        v.setLongClickable(true);

        if (selectMode) {
            holder.checkbox.setVisibility(View.VISIBLE);
        }
        else {
            holder.checkbox.setVisibility(View.GONE);
        }

        holder.checkbox.setChecked(cache.isStatusChecked());
        holder.checkbox.setOnClickListener(new SelectionCheckBoxListener(cache));

        distances.add(holder.distance);
        holder.distance.setContent(cache.getCoords());
        compasses.add(holder.direction);
        holder.direction.setTargetCoords(cache.getCoords());

        if (cache.isFound() && cache.isLogOffline()) {
            holder.logStatusMark.setImageResource(R.drawable.mark_green_orange);
            holder.logStatusMark.setVisibility(View.VISIBLE);
        } else if (cache.isFound()) {
            holder.logStatusMark.setImageResource(R.drawable.mark_green_more);
            holder.logStatusMark.setVisibility(View.VISIBLE);
        } else if (cache.isLogOffline()) {
            holder.logStatusMark.setImageResource(R.drawable.mark_orange);
            holder.logStatusMark.setVisibility(View.VISIBLE);
        } else {
            holder.logStatusMark.setVisibility(View.GONE);
        }

        Spannable spannable = null;
        if (cache.isDisabled() || cache.isArchived()) { // strike
            spannable = Spannable.Factory.getInstance().newSpannable(cache.getName());
            spannable.setSpan(new StrikethroughSpan(), 0, spannable.toString().length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        }
        if (cache.isArchived()) { // red color
            if (spannable == null) {
                spannable = Spannable.Factory.getInstance().newSpannable(cache.getName());
            }
            spannable.setSpan(new ForegroundColorSpan(res.getColor(R.color.archived_cache_color)), 0, spannable.toString().length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        }

        if (spannable != null) {
            holder.text.setText(spannable, TextView.BufferType.SPANNABLE);
        }
        else {
            holder.text.setText(cache.getName());
        }
        holder.text.setCompoundDrawablesWithIntrinsicBounds(getCacheIcon(cache), null, null, null);

        if (cache.getInventoryItems() > 0) {
            holder.inventory.setVisibility(View.VISIBLE);
        } else {
            holder.inventory.setVisibility(View.GONE);
        }

        boolean setDiDi = false;
        if (cache.getCoords() != null) {
            holder.direction.setVisibility(View.VISIBLE);
            holder.direction.updateAzimuth(azimuth);
            if (coords != null) {
                holder.distance.update(coords);
                holder.direction.updateCurrentCoords(coords);
            }
            setDiDi = true;
        } else {
            if (cache.getDistance() != null) {
                holder.distance.setDistance(cache.getDistance());
                setDiDi = true;
            }
            if (cache.getDirection() != null) {
                holder.direction.setVisibility(View.VISIBLE);
                holder.direction.updateAzimuth(azimuth);
                holder.direction.updateHeading(cache.getDirection());
                setDiDi = true;
            }
        }

        if (setDiDi) {
            holder.directionLayout.setVisibility(View.VISIBLE);
            holder.dirImgLayout.setVisibility(View.GONE);
        } else {
            holder.directionLayout.setVisibility(View.GONE);
            holder.distance.clear();

            final Bitmap dirImgPre = BitmapFactory.decodeFile(DirectionImage.getDirectionFile(cache.getGeocode(), false).getPath());
            final Bitmap dirImg;
            if (dirImgPre != null) { // null happens for invalid caches (not yet released)
                dirImg = dirImgPre.copy(Bitmap.Config.ARGB_8888, true);
                dirImgPre.recycle();
            }
            else {
                dirImg = null;
            }

            if (dirImg != null) {
                if (!lightSkin) {
                    final int length = dirImg.getWidth() * dirImg.getHeight();
                    final int[] pixels = new int[length];
                    dirImg.getPixels(pixels, 0, dirImg.getWidth(), 0, 0, dirImg.getWidth(), dirImg.getHeight());
                    for (int i = 0; i < length; i++) {
                        if (pixels[i] == 0xff000000) { // replace black with white
                            pixels[i] = 0xffffffff;
                        }
                    }
                    dirImg.setPixels(pixels, 0, dirImg.getWidth(), 0, 0, dirImg.getWidth(), dirImg.getHeight());
                }

                holder.dirImg.setImageBitmap(dirImg);
                holder.dirImgLayout.setVisibility(View.VISIBLE);
            } else {
                holder.dirImg.setImageBitmap(null);
                holder.dirImgLayout.setVisibility(View.GONE);
            }
        }

        holder.favorite.setText(Integer.toString(cache.getFavoritePoints()));

        int favoriteBack;
        // set default background, neither vote nor rating may be available
        if (lightSkin) {
            favoriteBack = R.drawable.favorite_background_light;
        } else {
            favoriteBack = R.drawable.favorite_background_dark;
        }
        final float myVote = cache.getMyVote();
        if (myVote > 0) { // use my own rating for display, if I have voted
            if (myVote >= 4) {
                favoriteBack = RATING_BACKGROUND[2];
            } else if (myVote >= 3) {
                favoriteBack = RATING_BACKGROUND[1];
            } else if (myVote > 0) {
                favoriteBack = RATING_BACKGROUND[0];
            }
        } else {
            final float rating = cache.getRating();
            if (rating >= 3.5) {
                favoriteBack = RATING_BACKGROUND[2];
            } else if (rating >= 2.1) {
                favoriteBack = RATING_BACKGROUND[1];
            } else if (rating > 0.0) {
                favoriteBack = RATING_BACKGROUND[0];
            }
        }
        holder.favorite.setBackgroundResource(favoriteBack);

        if (cacheListType == CacheListType.HISTORY && cache.getVisitedDate() > 0) {
            holder.info.setText(Formatter.formatCacheInfoHistory(cache));
        } else {
            holder.info.setText(Formatter.formatCacheInfoLong(cache, cacheListType));
        }

        return v;
    }

    private static Drawable getCacheIcon(Geocache cache) {
        int hashCode = getIconHashCode(cache.getType(), cache.hasUserModifiedCoords() || cache.hasFinalDefined());
        final Drawable drawable = gcIconDrawables.get(hashCode);
        if (drawable != null) {
            return drawable;
        }

        // fallback to mystery icon
        hashCode = getIconHashCode(CacheType.MYSTERY, cache.hasUserModifiedCoords() || cache.hasFinalDefined());
        return gcIconDrawables.get(hashCode);
    }

    @Override
    public void notifyDataSetChanged() {
        super.notifyDataSetChanged();
        distances.clear();
        compasses.clear();
    }

    private static class SelectionCheckBoxListener implements View.OnClickListener {

        private final Geocache cache;

        public SelectionCheckBoxListener(Geocache cache) {
            this.cache = cache;
        }

        @Override
        public void onClick(View view) {
            final boolean checkNow = ((CheckBox) view).isChecked();
            cache.setStatusChecked(checkNow);
        }
    }

    private class TouchListener implements View.OnLongClickListener, View.OnClickListener, View.OnTouchListener {

        private boolean touch = true;
        private final GestureDetector gestureDetector;
        private final Geocache cache;

        public TouchListener(final Geocache cache) {
            this.cache = cache;
            final FlingGesture dGesture = new FlingGesture(cache);
            gestureDetector = new GestureDetector(getContext(), dGesture);
        }

        // tap on item
        @Override
        public void onClick(View view) {
            if (!touch) {
                touch = true;
                return;
            }

            if (isSelectMode()) {
                cache.setStatusChecked(!cache.isStatusChecked());
                notifyDataSetChanged();
                return;
            }

            // load cache details
            CacheDetailActivity.startActivity(getContext(), cache.getGeocode(), cache.getName());
        }

        // long tap on item
        @Override
        public boolean onLongClick(View view) {
            if (!touch) {
                touch = true;
                return true;
            }

            return view.showContextMenu();
        }

        // swipe on item
        @Override
        public boolean onTouch(View view, MotionEvent event) {
            if (gestureDetector.onTouchEvent(event)) {
                touch = false;
                return true;
            }

            return false;
        }
    }

    private class FlingGesture extends GestureDetector.SimpleOnGestureListener {

        private final Geocache cache;

        public FlingGesture(Geocache cache) {
            this.cache = cache;
        }

        @Override
        public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
            try {
                if (Math.abs(e1.getY() - e2.getY()) > SWIPE_MAX_OFF_PATH) {
                    return false;
                }

                // left to right swipe
                if ((e2.getX() - e1.getX()) > SWIPE_MIN_DISTANCE && Math.abs(velocityX) > Math.abs(velocityY)) {
                    if (!selectMode) {
                        switchSelectMode();
                        cache.setStatusChecked(true);
                    }
                    return true;
                }

                // right to left swipe
                if ((e1.getX() - e2.getX()) > SWIPE_MIN_DISTANCE && Math.abs(velocityX) > Math.abs(velocityY)) {
                    if (selectMode) {
                        switchSelectMode();
                    }
                    return true;
                }
            } catch (Exception e) {
                Log.w("CacheListAdapter.FlingGesture.onFling", e);
            }

            return false;
        }
    }

    public List<Geocache> getFilteredList() {
        return list;
    }

    public List<Geocache> getCheckedCaches() {
        final ArrayList<Geocache> result = new ArrayList<Geocache>();
        for (Geocache cache : list) {
            if (cache.isStatusChecked()) {
                result.add(cache);
            }
        }
        return result;
    }

    public List<Geocache> getCheckedOrAllCaches() {
        final List<Geocache> result = getCheckedCaches();
        if (!result.isEmpty()) {
            return result;
        }
        return new ArrayList<Geocache>(list);
    }

    public int getCheckedOrAllCount() {
        final int checked = getCheckedCount();
        if (checked > 0) {
            return checked;
        }
        return list.size();
    }
}
!@#$%
20190527_001907,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_a18560
package cgeo.geocaching.ui;

import cgeo.geocaching.CacheDetailActivity;
import cgeo.geocaching.Geocache;
import cgeo.geocaching.IGeoData;
import cgeo.geocaching.R;
import cgeo.geocaching.Settings;
import cgeo.geocaching.cgeoapplication;
import cgeo.geocaching.enumerations.CacheListType;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.filter.IFilter;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.sorting.CacheComparator;
import cgeo.geocaching.sorting.DistanceComparator;
import cgeo.geocaching.sorting.InverseComparator;
import cgeo.geocaching.sorting.VisitComparator;
import cgeo.geocaching.utils.AngleUtils;
import cgeo.geocaching.utils.Log;

import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang3.builder.HashCodeBuilder;

import android.app.Activity;
import android.content.res.Resources;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.drawable.Drawable;
import android.graphics.drawable.LayerDrawable;
import android.text.Spannable;
import android.text.Spanned;
import android.text.style.ForegroundColorSpan;
import android.text.style.StrikethroughSpan;
import android.util.SparseArray;
import android.view.GestureDetector;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ArrayAdapter;
import android.widget.CheckBox;
import android.widget.ImageView;
import android.widget.RelativeLayout;
import android.widget.TextView;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;

public class CacheListAdapter extends ArrayAdapter<Geocache> {

    private LayoutInflater inflater = null;
    private CacheComparator cacheComparator = null;
    private Geopoint coords;
    private float azimuth = 0;
    private long lastSort = 0L;
    private boolean selectMode = false;
    private IFilter currentFilter = null;
    private List<Geocache> originalList = null;

    final private Set<CompassMiniView> compasses = new LinkedHashSet<CompassMiniView>();
    final private Set<DistanceView> distances = new LinkedHashSet<DistanceView>();
    final private CacheListType cacheListType;
    final private Resources res;
    /** Resulting list of caches */
    final private List<Geocache> list;
    private boolean inverseSort = false;

    private static final int SWIPE_MIN_DISTANCE = 60;
    private static final int SWIPE_MAX_OFF_PATH = 100;
    private static final SparseArray<Drawable> gcIconDrawables = new SparseArray<Drawable>();
    /**
     * time in milliseconds after which the list may be resorted due to position updates
     */
    private static final int PAUSE_BETWEEN_LIST_SORT = 1000;

    private static final int[] RATING_BACKGROUND = new int[3];
    static {
        if (Settings.isLightSkin()) {
            RATING_BACKGROUND[0] = R.drawable.favourite_background_red_light;
            RATING_BACKGROUND[1] = R.drawable.favourite_background_orange_light;
            RATING_BACKGROUND[2] = R.drawable.favourite_background_green_light;
        } else {
            RATING_BACKGROUND[0] = R.drawable.favourite_background_red_dark;
            RATING_BACKGROUND[1] = R.drawable.favourite_background_orange_dark;
            RATING_BACKGROUND[2] = R.drawable.favourite_background_green_dark;
        }
    }

    /**
     * view holder for the cache list adapter
     *
     */
    private static class ViewHolder {
        CheckBox checkbox;
        ImageView logStatusMark;
        TextView text;
        TextView favourite;
        TextView info;
        ImageView inventory;
        RelativeLayout directionLayout;
        DistanceView distance;
        CompassMiniView direction;
        RelativeLayout dirImgLayout;
        ImageView dirImg;
    }

    public CacheListAdapter(final Activity activity, final List<Geocache> list, CacheListType cacheListType) {
        super(activity, 0, list);
        final IGeoData currentGeo = cgeoapplication.getInstance().currentGeo();
        if (currentGeo != null) {
            coords = currentGeo.getCoords();
        }
        this.res = activity.getResources();
        this.list = list;
        this.cacheListType = cacheListType;
        if (cacheListType == CacheListType.HISTORY) {
            cacheComparator = new VisitComparator();
        }

        final Drawable modifiedCoordinatesMarker = activity.getResources().getDrawable(R.drawable.marker_usermodifiedcoords);
        for (final CacheType cacheType : CacheType.values()) {
            // unmodified icon
            int hashCode = getIconHashCode(cacheType, false);
            gcIconDrawables.put(hashCode, activity.getResources().getDrawable(cacheType.markerId));
            // icon with flag for user modified coordinates
            hashCode = getIconHashCode(cacheType, true);
            Drawable[] layers = new Drawable[2];
            layers[0] = activity.getResources().getDrawable(cacheType.markerId);
            layers[1] = modifiedCoordinatesMarker;
            LayerDrawable ld = new LayerDrawable(layers);
            ld.setLayerInset(1,
                    layers[0].getIntrinsicWidth() - layers[1].getIntrinsicWidth(),
                    layers[0].getIntrinsicHeight() - layers[1].getIntrinsicHeight(),
                    0, 0);
            gcIconDrawables.put(hashCode, ld);
        }
    }

    private static int getIconHashCode(final CacheType cacheType, final boolean userModifiedOrFinal) {
        return new HashCodeBuilder()
                .append(cacheType)
                .append(userModifiedOrFinal)
                .toHashCode();
    }

    /**
     * change the sort order
     *
     * @param comparator
     */
    public void setComparator(final CacheComparator comparator) {
        cacheComparator = comparator;
        forceSort();
    }

    public void resetInverseSort() {
        inverseSort = false;
    }

    public void toggleInverseSort() {
        inverseSort = !inverseSort;
    }

    public CacheComparator getCacheComparator() {
        return cacheComparator;
    }

    public Geocache findCacheByGeocode(String geocode) {
        for (int i = 0; i < getCount(); i++) {
            if (getItem(i).getGeocode().equalsIgnoreCase(geocode)) {
                return getItem(i);
            }
        }

        return null;
    }
    /**
     * Called when a new page of caches was loaded.
     */
    public void reFilter() {
        if (currentFilter != null) {
            // Back up the list again
            originalList = new ArrayList<Geocache>(list);

            currentFilter.filter(list);
        }
    }

    /**
     * Called after a user action on the filter menu.
     */
    public void setFilter(final IFilter filter) {
        // Backup current caches list if it isn't backed up yet
        if (originalList == null) {
            originalList = new ArrayList<Geocache>(list);
        }

        // If there is already a filter in place, this is a request to change or clear the filter, so we have to
        // replace the original cache list
        if (currentFilter != null) {
            list.clear();
            list.addAll(originalList);
        }

        // Do the filtering or clear it
        if (filter != null) {
            filter.filter(list);
        }
        currentFilter = filter;

        notifyDataSetChanged();
    }

    public boolean isFiltered() {
        return currentFilter != null;
    }

    public String getFilterName() {
        return currentFilter.getName();
    }

    public int getCheckedCount() {
        int checked = 0;
        for (Geocache cache : list) {
            if (cache.isStatusChecked()) {
                checked++;
            }
        }
        return checked;
    }

    public void setSelectMode(final boolean selectMode) {
        this.selectMode = selectMode;

        if (!selectMode) {
            for (final Geocache cache : list) {
                cache.setStatusChecked(false);
            }
        }
        notifyDataSetChanged();
    }

    public boolean isSelectMode() {
        return selectMode;
    }

    public void switchSelectMode() {
        setSelectMode(!isSelectMode());
    }

    public void invertSelection() {
        for (Geocache cache : list) {
            cache.setStatusChecked(!cache.isStatusChecked());
        }
        notifyDataSetChanged();
    }

    public void forceSort() {
        if (CollectionUtils.isEmpty(list) || selectMode) {
            return;
        }

        if (isSortedByDistance()) {
            lastSort = 0;
            updateSortByDistance();
        }
        else {
            Collections.sort(list, getPotentialInversion(cacheComparator));
        }

        notifyDataSetChanged();
    }

    public void setActualCoordinates(final Geopoint coords) {
        this.coords = coords;
        updateSortByDistance();

        for (final DistanceView distance : distances) {
            distance.update(coords);
        }
        for (final CompassMiniView compass : compasses) {
            compass.updateCurrentCoords(coords);
        }
    }

    private void updateSortByDistance() {
        if (CollectionUtils.isEmpty(list)) {
            return;
        }
        if (selectMode) {
            return;
        }
        if ((System.currentTimeMillis() - lastSort) <= PAUSE_BETWEEN_LIST_SORT) {
            return;
        }
        if (!isSortedByDistance()) {
            return;
        }
        if (coords == null) {
            return;
        }
        final ArrayList<Geocache> oldList = new ArrayList<Geocache>(list);
        Collections.sort(list, getPotentialInversion(new DistanceComparator(coords, list)));

        // avoid an update if the list has not changed due to location update
        if (list.equals(oldList)) {
            return;
        }
        notifyDataSetChanged();
        lastSort = System.currentTimeMillis();
    }

    private Comparator<? super Geocache> getPotentialInversion(final CacheComparator comparator) {
        if (inverseSort) {
            return new InverseComparator(comparator);
        }
        return comparator;
    }

    private boolean isSortedByDistance() {
        return cacheComparator == null || cacheComparator instanceof DistanceComparator;
    }

    public void setActualHeading(final float direction) {
        if (Math.abs(AngleUtils.difference(azimuth, direction)) < 10) {
            return;
        }

        azimuth = direction;
        for (final CompassMiniView compass : compasses) {
            compass.updateAzimuth(azimuth);
        }
    }

    @Override
    public View getView(final int position, final View rowView, final ViewGroup parent) {
        if (inflater == null) {
            inflater = ((Activity) getContext()).getLayoutInflater();
        }

        if (position > getCount()) {
            Log.w("CacheListAdapter.getView: Attempt to access missing item #" + position);
            return null;
        }

        final Geocache cache = getItem(position);

        View v = rowView;

        final ViewHolder holder;
        if (v == null) {
            v = inflater.inflate(R.layout.caches_item, null);

            holder = new ViewHolder();
            holder.checkbox = (CheckBox) v.findViewById(R.id.checkbox);
            holder.logStatusMark = (ImageView) v.findViewById(R.id.log_status_mark);
            holder.text = (TextView) v.findViewById(R.id.text);
            holder.directionLayout = (RelativeLayout) v.findViewById(R.id.direction_layout);
            holder.distance = (DistanceView) v.findViewById(R.id.distance);
            holder.direction = (CompassMiniView) v.findViewById(R.id.direction);
            holder.dirImgLayout = (RelativeLayout) v.findViewById(R.id.dirimg_layout);
            holder.dirImg = (ImageView) v.findViewById(R.id.dirimg);
            holder.inventory = (ImageView) v.findViewById(R.id.inventory);
            holder.favourite = (TextView) v.findViewById(R.id.favourite);
            holder.info = (TextView) v.findViewById(R.id.info);

            v.setTag(holder);
        } else {
            holder = (ViewHolder) v.getTag();
        }

        final boolean lightSkin = Settings.isLightSkin();

        final TouchListener touchLst = new TouchListener(cache);
        v.setOnClickListener(touchLst);
        v.setOnLongClickListener(touchLst);
        v.setOnTouchListener(touchLst);
        v.setLongClickable(true);

        if (selectMode) {
            holder.checkbox.setVisibility(View.VISIBLE);
        }
        else {
            holder.checkbox.setVisibility(View.GONE);
        }

        holder.checkbox.setChecked(cache.isStatusChecked());
        holder.checkbox.setOnClickListener(new SelectionCheckBoxListener(cache));

        distances.add(holder.distance);
        holder.distance.setContent(cache.getCoords());
        compasses.add(holder.direction);
        holder.direction.setTargetCoords(cache.getCoords());

        if (cache.isFound() && cache.isLogOffline()) {
            holder.logStatusMark.setImageResource(R.drawable.mark_green_orange);
            holder.logStatusMark.setVisibility(View.VISIBLE);
        } else if (cache.isFound()) {
            holder.logStatusMark.setImageResource(R.drawable.mark_green_more);
            holder.logStatusMark.setVisibility(View.VISIBLE);
        } else if (cache.isLogOffline()) {
            holder.logStatusMark.setImageResource(R.drawable.mark_orange);
            holder.logStatusMark.setVisibility(View.VISIBLE);
        } else {
            holder.logStatusMark.setVisibility(View.GONE);
        }

        Spannable spannable = null;
        if (cache.isDisabled() || cache.isArchived()) { // strike
            spannable = Spannable.Factory.getInstance().newSpannable(cache.getName());
            spannable.setSpan(new StrikethroughSpan(), 0, spannable.toString().length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        }
        if (cache.isArchived()) { // red color
            if (spannable == null) {
                spannable = Spannable.Factory.getInstance().newSpannable(cache.getName());
            }
            spannable.setSpan(new ForegroundColorSpan(res.getColor(R.color.archived_cache_color)), 0, spannable.toString().length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        }

        if (spannable != null) {
            holder.text.setText(spannable, TextView.BufferType.SPANNABLE);
        }
        else {
            holder.text.setText(cache.getName());
        }
        holder.text.setCompoundDrawablesWithIntrinsicBounds(getCacheIcon(cache), null, null, null);

        if (cache.getInventoryItems() > 0) {
            holder.inventory.setVisibility(View.VISIBLE);
        } else {
            holder.inventory.setVisibility(View.GONE);
        }

        boolean setDiDi = false;
        if (cache.getCoords() != null) {
            holder.direction.setVisibility(View.VISIBLE);
            holder.direction.updateAzimuth(azimuth);
            if (coords != null) {
                holder.distance.update(coords);
                holder.direction.updateCurrentCoords(coords);
            }
            setDiDi = true;
        } else {
            if (cache.getDistance() != null) {
                holder.distance.setDistance(cache.getDistance());
                setDiDi = true;
            }
            if (cache.getDirection() != null) {
                holder.direction.setVisibility(View.VISIBLE);
                holder.direction.updateAzimuth(azimuth);
                holder.direction.updateHeading(cache.getDirection());
                setDiDi = true;
            }
        }

        if (setDiDi) {
            holder.directionLayout.setVisibility(View.VISIBLE);
            holder.dirImgLayout.setVisibility(View.GONE);
        } else {
            holder.directionLayout.setVisibility(View.GONE);
            holder.distance.clear();

            final Bitmap dirImgPre = BitmapFactory.decodeFile(DirectionImage.getDirectionFile(cache.getGeocode(), false).getPath());
            final Bitmap dirImg;
            if (dirImgPre != null) { // null happens for invalid caches (not yet released)
                dirImg = dirImgPre.copy(Bitmap.Config.ARGB_8888, true);
                dirImgPre.recycle();
            }
            else {
                dirImg = null;
            }

            if (dirImg != null) {
                if (!lightSkin) {
                    final int length = dirImg.getWidth() * dirImg.getHeight();
                    final int[] pixels = new int[length];
                    dirImg.getPixels(pixels, 0, dirImg.getWidth(), 0, 0, dirImg.getWidth(), dirImg.getHeight());
                    for (int i = 0; i < length; i++) {
                        if (pixels[i] == 0xff000000) { // replace black with white
                            pixels[i] = 0xffffffff;
                        }
                    }
                    dirImg.setPixels(pixels, 0, dirImg.getWidth(), 0, 0, dirImg.getWidth(), dirImg.getHeight());
                }

                holder.dirImg.setImageBitmap(dirImg);
                holder.dirImgLayout.setVisibility(View.VISIBLE);
            } else {
                holder.dirImg.setImageBitmap(null);
                holder.dirImgLayout.setVisibility(View.GONE);
            }
        }

        holder.favourite.setText(Integer.toString(cache.getFavoritePoints()));

        int favoriteBack;
        // set default background, neither vote nor rating may be available
        if (lightSkin) {
            favoriteBack = R.drawable.favourite_background_light;
        } else {
            favoriteBack = R.drawable.favourite_background_dark;
        }
        final float myVote = cache.getMyVote();
        if (myVote > 0) { // use my own rating for display, if I have voted
            if (myVote >= 4) {
                favoriteBack = RATING_BACKGROUND[2];
            } else if (myVote >= 3) {
                favoriteBack = RATING_BACKGROUND[1];
            } else if (myVote > 0) {
                favoriteBack = RATING_BACKGROUND[0];
            }
        } else {
            final float rating = cache.getRating();
            if (rating >= 3.5) {
                favoriteBack = RATING_BACKGROUND[2];
            } else if (rating >= 2.1) {
                favoriteBack = RATING_BACKGROUND[1];
            } else if (rating > 0.0) {
                favoriteBack = RATING_BACKGROUND[0];
            }
        }
        holder.favourite.setBackgroundResource(favoriteBack);

        if (cacheListType == CacheListType.HISTORY && cache.getVisitedDate() > 0) {
            holder.info.setText(Formatter.formatCacheInfoHistory(cache));
        } else {
            holder.info.setText(Formatter.formatCacheInfoLong(cache, cacheListType));
        }

        return v;
    }

    private static Drawable getCacheIcon(Geocache cache) {
        int hashCode = getIconHashCode(cache.getType(), cache.hasUserModifiedCoords() || cache.hasFinalDefined());
        final Drawable drawable = gcIconDrawables.get(hashCode);
        if (drawable != null) {
            return drawable;
        }

        // fallback to mystery icon
        hashCode = getIconHashCode(CacheType.MYSTERY, cache.hasUserModifiedCoords() || cache.hasFinalDefined());
        return gcIconDrawables.get(hashCode);
    }

    @Override
    public void notifyDataSetChanged() {
        super.notifyDataSetChanged();
        distances.clear();
        compasses.clear();
    }

    private static class SelectionCheckBoxListener implements View.OnClickListener {

        private final Geocache cache;

        public SelectionCheckBoxListener(Geocache cache) {
            this.cache = cache;
        }

        @Override
        public void onClick(View view) {
            final boolean checkNow = ((CheckBox) view).isChecked();
            cache.setStatusChecked(checkNow);
        }
    }

    private class TouchListener implements View.OnLongClickListener, View.OnClickListener, View.OnTouchListener {

        private boolean touch = true;
        private final GestureDetector gestureDetector;
        private final Geocache cache;

        public TouchListener(final Geocache cache) {
            this.cache = cache;
            final FlingGesture dGesture = new FlingGesture(cache);
            gestureDetector = new GestureDetector(getContext(), dGesture);
        }

        // tap on item
        @Override
        public void onClick(View view) {
            if (!touch) {
                touch = true;
                return;
            }

            if (isSelectMode()) {
                cache.setStatusChecked(!cache.isStatusChecked());
                notifyDataSetChanged();
                return;
            }

            // load cache details
            CacheDetailActivity.startActivity(getContext(), cache.getGeocode(), cache.getName());
        }

        // long tap on item
        @Override
        public boolean onLongClick(View view) {
            if (!touch) {
                touch = true;
                return true;
            }

            return view.showContextMenu();
        }

        // swipe on item
        @Override
        public boolean onTouch(View view, MotionEvent event) {
            if (gestureDetector.onTouchEvent(event)) {
                touch = false;
                return true;
            }

            return false;
        }
    }

    private class FlingGesture extends GestureDetector.SimpleOnGestureListener {

        private final Geocache cache;

        public FlingGesture(Geocache cache) {
            this.cache = cache;
        }

        @Override
        public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
            try {
                if (Math.abs(e1.getY() - e2.getY()) > SWIPE_MAX_OFF_PATH) {
                    return false;
                }

                // left to right swipe
                if ((e2.getX() - e1.getX()) > SWIPE_MIN_DISTANCE && Math.abs(velocityX) > Math.abs(velocityY)) {
                    if (!selectMode) {
                        switchSelectMode();
                        cache.setStatusChecked(true);
                    }
                    return true;
                }

                // right to left swipe
                if ((e1.getX() - e2.getX()) > SWIPE_MIN_DISTANCE && Math.abs(velocityX) > Math.abs(velocityY)) {
                    if (selectMode) {
                        switchSelectMode();
                    }
                    return true;
                }
            } catch (Exception e) {
                Log.w("CacheListAdapter.FlingGesture.onFling", e);
            }

            return false;
        }
    }

    public List<Geocache> getFilteredList() {
        return list;
    }

    public List<Geocache> getCheckedCaches() {
        final ArrayList<Geocache> result = new ArrayList<Geocache>();
        for (Geocache cache : list) {
            if (cache.isStatusChecked()) {
                result.add(cache);
            }
        }
        return result;
    }

    public List<Geocache> getCheckedOrAllCaches() {
        final List<Geocache> result = getCheckedCaches();
        if (!result.isEmpty()) {
            return result;
        }
        return new ArrayList<Geocache>(list);
    }

    public int getCheckedOrAllCount() {
        final int checked = getCheckedCount();
        if (checked > 0) {
            return checked;
        }
        return list.size();
    }
}
!@#$%
20190527_001907,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_c18560
package cgeo.geocaching.ui;

import cgeo.geocaching.CacheDetailActivity;
import cgeo.geocaching.Geocache;
import cgeo.geocaching.IGeoData;
import cgeo.geocaching.R;
import cgeo.geocaching.Settings;
import cgeo.geocaching.cgeoapplication;
import cgeo.geocaching.enumerations.CacheListType;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.filter.IFilter;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.sorting.CacheComparator;
import cgeo.geocaching.sorting.DistanceComparator;
import cgeo.geocaching.sorting.InverseComparator;
import cgeo.geocaching.sorting.VisitComparator;
import cgeo.geocaching.utils.AngleUtils;
import cgeo.geocaching.utils.Log;

import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang3.builder.HashCodeBuilder;

import android.app.Activity;
import android.content.res.Resources;
import android.graphics.drawable.Drawable;
import android.graphics.drawable.LayerDrawable;
import android.text.Spannable;
import android.text.Spanned;
import android.text.style.ForegroundColorSpan;
import android.text.style.StrikethroughSpan;
import android.util.SparseArray;
import android.view.GestureDetector;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ArrayAdapter;
import android.widget.CheckBox;
import android.widget.ImageView;
import android.widget.TextView;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;

public class CacheListAdapter extends ArrayAdapter<Geocache> {

    private LayoutInflater inflater = null;
    private CacheComparator cacheComparator = null;
    private Geopoint coords;
    private float azimuth = 0;
    private long lastSort = 0L;
    private boolean selectMode = false;
    private IFilter currentFilter = null;
    private List<Geocache> originalList = null;

    final private Set<CompassMiniView> compasses = new LinkedHashSet<CompassMiniView>();
    final private Set<DistanceView> distances = new LinkedHashSet<DistanceView>();
    final private CacheListType cacheListType;
    final private Resources res;
    /** Resulting list of caches */
    final private List<Geocache> list;
    private boolean inverseSort = false;

    private static final int SWIPE_MIN_DISTANCE = 60;
    private static final int SWIPE_MAX_OFF_PATH = 100;
    private static final SparseArray<Drawable> gcIconDrawables = new SparseArray<Drawable>();
    /**
     * time in milliseconds after which the list may be resorted due to position updates
     */
    private static final int PAUSE_BETWEEN_LIST_SORT = 1000;

    private static final int[] RATING_BACKGROUND = new int[3];
    static {
        if (Settings.isLightSkin()) {
            RATING_BACKGROUND[0] = R.drawable.favourite_background_red_light;
            RATING_BACKGROUND[1] = R.drawable.favourite_background_orange_light;
            RATING_BACKGROUND[2] = R.drawable.favourite_background_green_light;
        } else {
            RATING_BACKGROUND[0] = R.drawable.favourite_background_red_dark;
            RATING_BACKGROUND[1] = R.drawable.favourite_background_orange_dark;
            RATING_BACKGROUND[2] = R.drawable.favourite_background_green_dark;
        }
    }

    /**
     * view holder for the cache list adapter
     *
     */
    private static class ViewHolder {
        CheckBox checkbox;
        ImageView logStatusMark;
        TextView text;
        TextView favourite;
        TextView info;
        ImageView inventory;
        DistanceView distance;
        CompassMiniView direction;
        ImageView dirImg;
    }

    public CacheListAdapter(final Activity activity, final List<Geocache> list, CacheListType cacheListType) {
        super(activity, 0, list);
        final IGeoData currentGeo = cgeoapplication.getInstance().currentGeo();
        if (currentGeo != null) {
            coords = currentGeo.getCoords();
        }
        this.res = activity.getResources();
        this.list = list;
        this.cacheListType = cacheListType;
        if (cacheListType == CacheListType.HISTORY) {
            cacheComparator = new VisitComparator();
        }

        final Drawable modifiedCoordinatesMarker = activity.getResources().getDrawable(R.drawable.marker_usermodifiedcoords);
        for (final CacheType cacheType : CacheType.values()) {
            // unmodified icon
            int hashCode = getIconHashCode(cacheType, false);
            gcIconDrawables.put(hashCode, activity.getResources().getDrawable(cacheType.markerId));
            // icon with flag for user modified coordinates
            hashCode = getIconHashCode(cacheType, true);
            Drawable[] layers = new Drawable[2];
            layers[0] = activity.getResources().getDrawable(cacheType.markerId);
            layers[1] = modifiedCoordinatesMarker;
            LayerDrawable ld = new LayerDrawable(layers);
            ld.setLayerInset(1,
                    layers[0].getIntrinsicWidth() - layers[1].getIntrinsicWidth(),
                    layers[0].getIntrinsicHeight() - layers[1].getIntrinsicHeight(),
                    0, 0);
            gcIconDrawables.put(hashCode, ld);
        }
    }

    private static int getIconHashCode(final CacheType cacheType, final boolean userModifiedOrFinal) {
        return new HashCodeBuilder()
                .append(cacheType)
                .append(userModifiedOrFinal)
                .toHashCode();
    }

    /**
     * change the sort order
     *
     * @param comparator
     */
    public void setComparator(final CacheComparator comparator) {
        cacheComparator = comparator;
        forceSort();
    }

    public void resetInverseSort() {
        inverseSort = false;
    }

    public void toggleInverseSort() {
        inverseSort = !inverseSort;
    }

    public CacheComparator getCacheComparator() {
        return cacheComparator;
    }

    public Geocache findCacheByGeocode(String geocode) {
        for (int i = 0; i < getCount(); i++) {
            if (getItem(i).getGeocode().equalsIgnoreCase(geocode)) {
                return getItem(i);
            }
        }

        return null;
    }
    /**
     * Called when a new page of caches was loaded.
     */
    public void reFilter() {
        if (currentFilter != null) {
            // Back up the list again
            originalList = new ArrayList<Geocache>(list);

            currentFilter.filter(list);
        }
    }

    /**
     * Called after a user action on the filter menu.
     */
    public void setFilter(final IFilter filter) {
        // Backup current caches list if it isn't backed up yet
        if (originalList == null) {
            originalList = new ArrayList<Geocache>(list);
        }

        // If there is already a filter in place, this is a request to change or clear the filter, so we have to
        // replace the original cache list
        if (currentFilter != null) {
            list.clear();
            list.addAll(originalList);
        }

        // Do the filtering or clear it
        if (filter != null) {
            filter.filter(list);
        }
        currentFilter = filter;

        notifyDataSetChanged();
    }

    public boolean isFiltered() {
        return currentFilter != null;
    }

    public String getFilterName() {
        return currentFilter.getName();
    }

    public int getCheckedCount() {
        int checked = 0;
        for (Geocache cache : list) {
            if (cache.isStatusChecked()) {
                checked++;
            }
        }
        return checked;
    }

    public void setSelectMode(final boolean selectMode) {
        this.selectMode = selectMode;

        if (!selectMode) {
            for (final Geocache cache : list) {
                cache.setStatusChecked(false);
            }
        }
        notifyDataSetChanged();
    }

    public boolean isSelectMode() {
        return selectMode;
    }

    public void switchSelectMode() {
        setSelectMode(!isSelectMode());
    }

    public void invertSelection() {
        for (Geocache cache : list) {
            cache.setStatusChecked(!cache.isStatusChecked());
        }
        notifyDataSetChanged();
    }

    public void forceSort() {
        if (CollectionUtils.isEmpty(list) || selectMode) {
            return;
        }

        if (isSortedByDistance()) {
            lastSort = 0;
            updateSortByDistance();
        }
        else {
            Collections.sort(list, getPotentialInversion(cacheComparator));
        }

        notifyDataSetChanged();
    }

    public void setActualCoordinates(final Geopoint coords) {
        this.coords = coords;
        updateSortByDistance();

        for (final DistanceView distance : distances) {
            distance.update(coords);
        }
        for (final CompassMiniView compass : compasses) {
            compass.updateCurrentCoords(coords);
        }
    }

    private void updateSortByDistance() {
        if (CollectionUtils.isEmpty(list)) {
            return;
        }
        if (selectMode) {
            return;
        }
        if ((System.currentTimeMillis() - lastSort) <= PAUSE_BETWEEN_LIST_SORT) {
            return;
        }
        if (!isSortedByDistance()) {
            return;
        }
        if (coords == null) {
            return;
        }
        final ArrayList<Geocache> oldList = new ArrayList<Geocache>(list);
        Collections.sort(list, getPotentialInversion(new DistanceComparator(coords, list)));

        // avoid an update if the list has not changed due to location update
        if (list.equals(oldList)) {
            return;
        }
        notifyDataSetChanged();
        lastSort = System.currentTimeMillis();
    }

    private Comparator<? super Geocache> getPotentialInversion(final CacheComparator comparator) {
        if (inverseSort) {
            return new InverseComparator(comparator);
        }
        return comparator;
    }

    private boolean isSortedByDistance() {
        return cacheComparator == null || cacheComparator instanceof DistanceComparator;
    }

    public void setActualHeading(final float direction) {
        if (Math.abs(AngleUtils.difference(azimuth, direction)) < 10) {
            return;
        }

        azimuth = direction;
        for (final CompassMiniView compass : compasses) {
            compass.updateAzimuth(azimuth);
        }
    }

    @Override
    public View getView(final int position, final View rowView, final ViewGroup parent) {
        if (inflater == null) {
            inflater = ((Activity) getContext()).getLayoutInflater();
        }

        if (position > getCount()) {
            Log.w("CacheListAdapter.getView: Attempt to access missing item #" + position);
            return null;
        }

        final Geocache cache = getItem(position);

        View v = rowView;

        final ViewHolder holder;
        if (v == null) {
            v = inflater.inflate(R.layout.caches_item, null);

            holder = new ViewHolder();
            holder.checkbox = (CheckBox) v.findViewById(R.id.checkbox);
            holder.logStatusMark = (ImageView) v.findViewById(R.id.log_status_mark);
            holder.text = (TextView) v.findViewById(R.id.text);
            holder.distance = (DistanceView) v.findViewById(R.id.distance);
            holder.direction = (CompassMiniView) v.findViewById(R.id.direction);
            holder.dirImg = (ImageView) v.findViewById(R.id.dirimg);
            holder.inventory = (ImageView) v.findViewById(R.id.inventory);
            holder.favourite = (TextView) v.findViewById(R.id.favourite);
            holder.info = (TextView) v.findViewById(R.id.info);

            v.setTag(holder);
        } else {
            holder = (ViewHolder) v.getTag();
        }

        final boolean lightSkin = Settings.isLightSkin();

        final TouchListener touchLst = new TouchListener(cache);
        v.setOnClickListener(touchLst);
        v.setOnLongClickListener(touchLst);
        v.setOnTouchListener(touchLst);
        v.setLongClickable(true);

        if (selectMode) {
            holder.checkbox.setVisibility(View.VISIBLE);
        }
        else {
            holder.checkbox.setVisibility(View.GONE);
        }

        holder.checkbox.setChecked(cache.isStatusChecked());
        holder.checkbox.setOnClickListener(new SelectionCheckBoxListener(cache));

        distances.add(holder.distance);
        holder.distance.setContent(cache.getCoords());
        compasses.add(holder.direction);
        holder.direction.setTargetCoords(cache.getCoords());

        if (cache.isFound() && cache.isLogOffline()) {
            holder.logStatusMark.setImageResource(R.drawable.mark_green_orange);
            holder.logStatusMark.setVisibility(View.VISIBLE);
        } else if (cache.isFound()) {
            holder.logStatusMark.setImageResource(R.drawable.mark_green_more);
            holder.logStatusMark.setVisibility(View.VISIBLE);
        } else if (cache.isLogOffline()) {
            holder.logStatusMark.setImageResource(R.drawable.mark_orange);
            holder.logStatusMark.setVisibility(View.VISIBLE);
        } else {
            holder.logStatusMark.setVisibility(View.GONE);
        }

        Spannable spannable = null;
        if (cache.isDisabled() || cache.isArchived()) { // strike
            spannable = Spannable.Factory.getInstance().newSpannable(cache.getName());
            spannable.setSpan(new StrikethroughSpan(), 0, spannable.toString().length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        }
        if (cache.isArchived()) { // red color
            if (spannable == null) {
                spannable = Spannable.Factory.getInstance().newSpannable(cache.getName());
            }
            spannable.setSpan(new ForegroundColorSpan(res.getColor(R.color.archived_cache_color)), 0, spannable.toString().length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        }

        if (spannable != null) {
            holder.text.setText(spannable, TextView.BufferType.SPANNABLE);
        }
        else {
            holder.text.setText(cache.getName());
        }
        holder.text.setCompoundDrawablesWithIntrinsicBounds(getCacheIcon(cache), null, null, null);

        if (cache.getInventoryItems() > 0) {
            holder.inventory.setVisibility(View.VISIBLE);
        } else {
            holder.inventory.setVisibility(View.GONE);
        }

        if (cache.getDistance() != null) {
            holder.distance.setDistance(cache.getDistance());
        }
        if (cache.getCoords() != null) {
            holder.direction.setVisibility(View.VISIBLE);
            holder.dirImg.setVisibility(View.GONE);
            holder.direction.updateAzimuth(azimuth);
            if (coords != null) {
                holder.distance.update(coords);
                holder.direction.updateCurrentCoords(coords);
            }
        } else if (cache.getDirection() != null) {
            holder.direction.setVisibility(View.VISIBLE);
            holder.dirImg.setVisibility(View.GONE);
            holder.direction.updateAzimuth(azimuth);
            holder.direction.updateHeading(cache.getDirection());
        } else {
            holder.dirImg.setImageDrawable(DirectionImage.getDrawable(cache.getDirectionImg()));
            holder.dirImg.setVisibility(View.VISIBLE);
            holder.direction.setVisibility(View.GONE);
        }

        holder.favourite.setText(Integer.toString(cache.getFavoritePoints()));

        int favoriteBack;
        // set default background, neither vote nor rating may be available
        if (lightSkin) {
            favoriteBack = R.drawable.favourite_background_light;
        } else {
            favoriteBack = R.drawable.favourite_background_dark;
        }
        final float myVote = cache.getMyVote();
        if (myVote > 0) { // use my own rating for display, if I have voted
            if (myVote >= 4) {
                favoriteBack = RATING_BACKGROUND[2];
            } else if (myVote >= 3) {
                favoriteBack = RATING_BACKGROUND[1];
            } else if (myVote > 0) {
                favoriteBack = RATING_BACKGROUND[0];
            }
        } else {
            final float rating = cache.getRating();
            if (rating >= 3.5) {
                favoriteBack = RATING_BACKGROUND[2];
            } else if (rating >= 2.1) {
                favoriteBack = RATING_BACKGROUND[1];
            } else if (rating > 0.0) {
                favoriteBack = RATING_BACKGROUND[0];
            }
        }
        holder.favourite.setBackgroundResource(favoriteBack);

        if (cacheListType == CacheListType.HISTORY && cache.getVisitedDate() > 0) {
            holder.info.setText(Formatter.formatCacheInfoHistory(cache));
        } else {
            holder.info.setText(Formatter.formatCacheInfoLong(cache, cacheListType));
        }

        return v;
    }

    private static Drawable getCacheIcon(Geocache cache) {
        int hashCode = getIconHashCode(cache.getType(), cache.hasUserModifiedCoords() || cache.hasFinalDefined());
        final Drawable drawable = gcIconDrawables.get(hashCode);
        if (drawable != null) {
            return drawable;
        }

        // fallback to mystery icon
        hashCode = getIconHashCode(CacheType.MYSTERY, cache.hasUserModifiedCoords() || cache.hasFinalDefined());
        return gcIconDrawables.get(hashCode);
    }

    @Override
    public void notifyDataSetChanged() {
        super.notifyDataSetChanged();
        distances.clear();
        compasses.clear();
    }

    private static class SelectionCheckBoxListener implements View.OnClickListener {

        private final Geocache cache;

        public SelectionCheckBoxListener(Geocache cache) {
            this.cache = cache;
        }

        @Override
        public void onClick(View view) {
            final boolean checkNow = ((CheckBox) view).isChecked();
            cache.setStatusChecked(checkNow);
        }
    }

    private class TouchListener implements View.OnLongClickListener, View.OnClickListener, View.OnTouchListener {

        private boolean touch = true;
        private final GestureDetector gestureDetector;
        private final Geocache cache;

        public TouchListener(final Geocache cache) {
            this.cache = cache;
            final FlingGesture dGesture = new FlingGesture(cache);
            gestureDetector = new GestureDetector(getContext(), dGesture);
        }

        // tap on item
        @Override
        public void onClick(View view) {
            if (!touch) {
                touch = true;
                return;
            }

            if (isSelectMode()) {
                cache.setStatusChecked(!cache.isStatusChecked());
                notifyDataSetChanged();
                return;
            }

            // load cache details
            CacheDetailActivity.startActivity(getContext(), cache.getGeocode(), cache.getName());
        }

        // long tap on item
        @Override
        public boolean onLongClick(View view) {
            if (!touch) {
                touch = true;
                return true;
            }

            return view.showContextMenu();
        }

        // swipe on item
        @Override
        public boolean onTouch(View view, MotionEvent event) {
            if (gestureDetector.onTouchEvent(event)) {
                touch = false;
                return true;
            }

            return false;
        }
    }

    private class FlingGesture extends GestureDetector.SimpleOnGestureListener {

        private final Geocache cache;

        public FlingGesture(Geocache cache) {
            this.cache = cache;
        }

        @Override
        public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
            try {
                if (Math.abs(e1.getY() - e2.getY()) > SWIPE_MAX_OFF_PATH) {
                    return false;
                }

                // left to right swipe
                if ((e2.getX() - e1.getX()) > SWIPE_MIN_DISTANCE && Math.abs(velocityX) > Math.abs(velocityY)) {
                    if (!selectMode) {
                        switchSelectMode();
                        cache.setStatusChecked(true);
                    }
                    return true;
                }

                // right to left swipe
                if ((e1.getX() - e2.getX()) > SWIPE_MIN_DISTANCE && Math.abs(velocityX) > Math.abs(velocityY)) {
                    if (selectMode) {
                        switchSelectMode();
                    }
                    return true;
                }
            } catch (Exception e) {
                Log.w("CacheListAdapter.FlingGesture.onFling", e);
            }

            return false;
        }
    }

    public List<Geocache> getFilteredList() {
        return list;
    }

    public List<Geocache> getCheckedCaches() {
        final ArrayList<Geocache> result = new ArrayList<Geocache>();
        for (Geocache cache : list) {
            if (cache.isStatusChecked()) {
                result.add(cache);
            }
        }
        return result;
    }

    public List<Geocache> getCheckedOrAllCaches() {
        final List<Geocache> result = getCheckedCaches();
        if (!result.isEmpty()) {
            return result;
        }
        return new ArrayList<Geocache>(list);
    }

    public int getCheckedOrAllCount() {
        final int checked = getCheckedCount();
        if (checked > 0) {
            return checked;
        }
        return list.size();
    }
}
!@#$%
20190527_002047,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_b16768
package cgeo.geocaching.ui;

import cgeo.geocaching.CacheDetailActivity;
import cgeo.geocaching.Geocache;
import cgeo.geocaching.IGeoData;
import cgeo.geocaching.R;
import cgeo.geocaching.Settings;
import cgeo.geocaching.cgeoapplication;
import cgeo.geocaching.enumerations.CacheListType;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.filter.IFilter;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.sorting.CacheComparator;
import cgeo.geocaching.sorting.DistanceComparator;
import cgeo.geocaching.sorting.InverseComparator;
import cgeo.geocaching.sorting.VisitComparator;
import cgeo.geocaching.utils.AngleUtils;
import cgeo.geocaching.utils.Log;

import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang3.builder.HashCodeBuilder;

import android.app.Activity;
import android.content.res.Resources;
import android.graphics.drawable.Drawable;
import android.graphics.drawable.LayerDrawable;
import android.text.Spannable;
import android.text.Spanned;
import android.text.style.ForegroundColorSpan;
import android.text.style.StrikethroughSpan;
import android.util.SparseArray;
import android.view.GestureDetector;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ArrayAdapter;
import android.widget.CheckBox;
import android.widget.ImageView;
import android.widget.TextView;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;

public class CacheListAdapter extends ArrayAdapter<Geocache> {

    private LayoutInflater inflater = null;
    private CacheComparator cacheComparator = null;
    private Geopoint coords;
    private float azimuth = 0;
    private long lastSort = 0L;
    private boolean selectMode = false;
    private IFilter currentFilter = null;
    private List<Geocache> originalList = null;

    final private Set<CompassMiniView> compasses = new LinkedHashSet<CompassMiniView>();
    final private Set<DistanceView> distances = new LinkedHashSet<DistanceView>();
    final private CacheListType cacheListType;
    final private Resources res;
    /** Resulting list of caches */
    final private List<Geocache> list;
    private boolean inverseSort = false;

    private static final int SWIPE_MIN_DISTANCE = 60;
    private static final int SWIPE_MAX_OFF_PATH = 100;
    private static final SparseArray<Drawable> gcIconDrawables = new SparseArray<Drawable>();
    /**
     * time in milliseconds after which the list may be resorted due to position updates
     */
    private static final int PAUSE_BETWEEN_LIST_SORT = 1000;

    private static final int[] RATING_BACKGROUND = new int[3];
    static {
        if (Settings.isLightSkin()) {
            RATING_BACKGROUND[0] = R.drawable.favorite_background_red_light;
            RATING_BACKGROUND[1] = R.drawable.favorite_background_orange_light;
            RATING_BACKGROUND[2] = R.drawable.favorite_background_green_light;
        } else {
            RATING_BACKGROUND[0] = R.drawable.favorite_background_red_dark;
            RATING_BACKGROUND[1] = R.drawable.favorite_background_orange_dark;
            RATING_BACKGROUND[2] = R.drawable.favorite_background_green_dark;
        }
    }

    /**
     * view holder for the cache list adapter
     *
     */
    private static class ViewHolder {
        CheckBox checkbox;
        ImageView logStatusMark;
        TextView text;
        TextView favorite;
        TextView info;
        ImageView inventory;
        DistanceView distance;
        CompassMiniView direction;
        ImageView dirImg;
    }

    public CacheListAdapter(final Activity activity, final List<Geocache> list, CacheListType cacheListType) {
        super(activity, 0, list);
        final IGeoData currentGeo = cgeoapplication.getInstance().currentGeo();
        if (currentGeo != null) {
            coords = currentGeo.getCoords();
        }
        this.res = activity.getResources();
        this.list = list;
        this.cacheListType = cacheListType;
        if (cacheListType == CacheListType.HISTORY) {
            cacheComparator = new VisitComparator();
        }

        final Drawable modifiedCoordinatesMarker = activity.getResources().getDrawable(R.drawable.marker_usermodifiedcoords);
        for (final CacheType cacheType : CacheType.values()) {
            // unmodified icon
            int hashCode = getIconHashCode(cacheType, false);
            gcIconDrawables.put(hashCode, activity.getResources().getDrawable(cacheType.markerId));
            // icon with flag for user modified coordinates
            hashCode = getIconHashCode(cacheType, true);
            Drawable[] layers = new Drawable[2];
            layers[0] = activity.getResources().getDrawable(cacheType.markerId);
            layers[1] = modifiedCoordinatesMarker;
            LayerDrawable ld = new LayerDrawable(layers);
            ld.setLayerInset(1,
                    layers[0].getIntrinsicWidth() - layers[1].getIntrinsicWidth(),
                    layers[0].getIntrinsicHeight() - layers[1].getIntrinsicHeight(),
                    0, 0);
            gcIconDrawables.put(hashCode, ld);
        }
    }

    private static int getIconHashCode(final CacheType cacheType, final boolean userModifiedOrFinal) {
        return new HashCodeBuilder()
                .append(cacheType)
                .append(userModifiedOrFinal)
                .toHashCode();
    }

    /**
     * change the sort order
     *
     * @param comparator
     */
    public void setComparator(final CacheComparator comparator) {
        cacheComparator = comparator;
        forceSort();
    }

    public void resetInverseSort() {
        inverseSort = false;
    }

    public void toggleInverseSort() {
        inverseSort = !inverseSort;
    }

    public CacheComparator getCacheComparator() {
        return cacheComparator;
    }

    public Geocache findCacheByGeocode(String geocode) {
        for (int i = 0; i < getCount(); i++) {
            if (getItem(i).getGeocode().equalsIgnoreCase(geocode)) {
                return getItem(i);
            }
        }

        return null;
    }
    /**
     * Called when a new page of caches was loaded.
     */
    public void reFilter() {
        if (currentFilter != null) {
            // Back up the list again
            originalList = new ArrayList<Geocache>(list);

            currentFilter.filter(list);
        }
    }

    /**
     * Called after a user action on the filter menu.
     */
    public void setFilter(final IFilter filter) {
        // Backup current caches list if it isn't backed up yet
        if (originalList == null) {
            originalList = new ArrayList<Geocache>(list);
        }

        // If there is already a filter in place, this is a request to change or clear the filter, so we have to
        // replace the original cache list
        if (currentFilter != null) {
            list.clear();
            list.addAll(originalList);
        }

        // Do the filtering or clear it
        if (filter != null) {
            filter.filter(list);
        }
        currentFilter = filter;

        notifyDataSetChanged();
    }

    public boolean isFiltered() {
        return currentFilter != null;
    }

    public String getFilterName() {
        return currentFilter.getName();
    }

    public int getCheckedCount() {
        int checked = 0;
        for (Geocache cache : list) {
            if (cache.isStatusChecked()) {
                checked++;
            }
        }
        return checked;
    }

    public void setSelectMode(final boolean selectMode) {
        this.selectMode = selectMode;

        if (!selectMode) {
            for (final Geocache cache : list) {
                cache.setStatusChecked(false);
            }
        }
        notifyDataSetChanged();
    }

    public boolean isSelectMode() {
        return selectMode;
    }

    public void switchSelectMode() {
        setSelectMode(!isSelectMode());
    }

    public void invertSelection() {
        for (Geocache cache : list) {
            cache.setStatusChecked(!cache.isStatusChecked());
        }
        notifyDataSetChanged();
    }

    public void forceSort() {
        if (CollectionUtils.isEmpty(list) || selectMode) {
            return;
        }

        if (isSortedByDistance()) {
            lastSort = 0;
            updateSortByDistance();
        }
        else {
            Collections.sort(list, getPotentialInversion(cacheComparator));
        }

        notifyDataSetChanged();
    }

    public void setActualCoordinates(final Geopoint coords) {
        this.coords = coords;
        updateSortByDistance();

        for (final DistanceView distance : distances) {
            distance.update(coords);
        }
        for (final CompassMiniView compass : compasses) {
            compass.updateCurrentCoords(coords);
        }
    }

    private void updateSortByDistance() {
        if (CollectionUtils.isEmpty(list)) {
            return;
        }
        if (selectMode) {
            return;
        }
        if ((System.currentTimeMillis() - lastSort) <= PAUSE_BETWEEN_LIST_SORT) {
            return;
        }
        if (!isSortedByDistance()) {
            return;
        }
        if (coords == null) {
            return;
        }
        final ArrayList<Geocache> oldList = new ArrayList<Geocache>(list);
        Collections.sort(list, getPotentialInversion(new DistanceComparator(coords, list)));

        // avoid an update if the list has not changed due to location update
        if (list.equals(oldList)) {
            return;
        }
        notifyDataSetChanged();
        lastSort = System.currentTimeMillis();
    }

    private Comparator<? super Geocache> getPotentialInversion(final CacheComparator comparator) {
        if (inverseSort) {
            return new InverseComparator(comparator);
        }
        return comparator;
    }

    private boolean isSortedByDistance() {
        return cacheComparator == null || cacheComparator instanceof DistanceComparator;
    }

    public void setActualHeading(final float direction) {
        if (Math.abs(AngleUtils.difference(azimuth, direction)) < 10) {
            return;
        }

        azimuth = direction;
        for (final CompassMiniView compass : compasses) {
            compass.updateAzimuth(azimuth);
        }
    }

    @Override
    public View getView(final int position, final View rowView, final ViewGroup parent) {
        if (inflater == null) {
            inflater = ((Activity) getContext()).getLayoutInflater();
        }

        if (position > getCount()) {
            Log.w("CacheListAdapter.getView: Attempt to access missing item #" + position);
            return null;
        }

        final Geocache cache = getItem(position);

        View v = rowView;

        final ViewHolder holder;
        if (v == null) {
            v = inflater.inflate(R.layout.caches_item, null);

            holder = new ViewHolder();
            holder.checkbox = (CheckBox) v.findViewById(R.id.checkbox);
            holder.logStatusMark = (ImageView) v.findViewById(R.id.log_status_mark);
            holder.text = (TextView) v.findViewById(R.id.text);
            holder.distance = (DistanceView) v.findViewById(R.id.distance);
            holder.direction = (CompassMiniView) v.findViewById(R.id.direction);
            holder.dirImg = (ImageView) v.findViewById(R.id.dirimg);
            holder.inventory = (ImageView) v.findViewById(R.id.inventory);
            holder.favorite = (TextView) v.findViewById(R.id.favorite);
            holder.info = (TextView) v.findViewById(R.id.info);

            v.setTag(holder);
        } else {
            holder = (ViewHolder) v.getTag();
        }

        final boolean lightSkin = Settings.isLightSkin();

        final TouchListener touchLst = new TouchListener(cache);
        v.setOnClickListener(touchLst);
        v.setOnLongClickListener(touchLst);
        v.setOnTouchListener(touchLst);
        v.setLongClickable(true);

        if (selectMode) {
            holder.checkbox.setVisibility(View.VISIBLE);
        }
        else {
            holder.checkbox.setVisibility(View.GONE);
        }

        holder.checkbox.setChecked(cache.isStatusChecked());
        holder.checkbox.setOnClickListener(new SelectionCheckBoxListener(cache));

        distances.add(holder.distance);
        holder.distance.setContent(cache.getCoords());
        compasses.add(holder.direction);
        holder.direction.setTargetCoords(cache.getCoords());

        if (cache.isFound() && cache.isLogOffline()) {
            holder.logStatusMark.setImageResource(R.drawable.mark_green_orange);
            holder.logStatusMark.setVisibility(View.VISIBLE);
        } else if (cache.isFound()) {
            holder.logStatusMark.setImageResource(R.drawable.mark_green_more);
            holder.logStatusMark.setVisibility(View.VISIBLE);
        } else if (cache.isLogOffline()) {
            holder.logStatusMark.setImageResource(R.drawable.mark_orange);
            holder.logStatusMark.setVisibility(View.VISIBLE);
        } else {
            holder.logStatusMark.setVisibility(View.GONE);
        }

        Spannable spannable = null;
        if (cache.isDisabled() || cache.isArchived()) { // strike
            spannable = Spannable.Factory.getInstance().newSpannable(cache.getName());
            spannable.setSpan(new StrikethroughSpan(), 0, spannable.toString().length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        }
        if (cache.isArchived()) { // red color
            if (spannable == null) {
                spannable = Spannable.Factory.getInstance().newSpannable(cache.getName());
            }
            spannable.setSpan(new ForegroundColorSpan(res.getColor(R.color.archived_cache_color)), 0, spannable.toString().length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        }

        if (spannable != null) {
            holder.text.setText(spannable, TextView.BufferType.SPANNABLE);
        }
        else {
            holder.text.setText(cache.getName());
        }
        holder.text.setCompoundDrawablesWithIntrinsicBounds(getCacheIcon(cache), null, null, null);

        if (cache.getInventoryItems() > 0) {
            holder.inventory.setVisibility(View.VISIBLE);
        } else {
            holder.inventory.setVisibility(View.GONE);
        }

        if (cache.getDistance() != null) {
            holder.distance.setDistance(cache.getDistance());
        }
        if (cache.getCoords() != null) {
            holder.direction.setVisibility(View.VISIBLE);
            holder.dirImg.setVisibility(View.GONE);
            holder.direction.updateAzimuth(azimuth);
            if (coords != null) {
                holder.distance.update(coords);
                holder.direction.updateCurrentCoords(coords);
            }
        } else if (cache.getDirection() != null) {
            holder.direction.setVisibility(View.VISIBLE);
            holder.dirImg.setVisibility(View.GONE);
            holder.direction.updateAzimuth(azimuth);
            holder.direction.updateHeading(cache.getDirection());
        } else {
            holder.dirImg.setImageDrawable(DirectionImage.getDrawable(cache.getDirectionImg()));
            holder.dirImg.setVisibility(View.VISIBLE);
            holder.direction.setVisibility(View.GONE);
        }

        holder.favorite.setText(Integer.toString(cache.getFavoritePoints()));

        int favoriteBack;
        // set default background, neither vote nor rating may be available
        if (lightSkin) {
            favoriteBack = R.drawable.favorite_background_light;
        } else {
            favoriteBack = R.drawable.favorite_background_dark;
        }
        final float myVote = cache.getMyVote();
        if (myVote > 0) { // use my own rating for display, if I have voted
            if (myVote >= 4) {
                favoriteBack = RATING_BACKGROUND[2];
            } else if (myVote >= 3) {
                favoriteBack = RATING_BACKGROUND[1];
            } else if (myVote > 0) {
                favoriteBack = RATING_BACKGROUND[0];
            }
        } else {
            final float rating = cache.getRating();
            if (rating >= 3.5) {
                favoriteBack = RATING_BACKGROUND[2];
            } else if (rating >= 2.1) {
                favoriteBack = RATING_BACKGROUND[1];
            } else if (rating > 0.0) {
                favoriteBack = RATING_BACKGROUND[0];
            }
        }
        holder.favorite.setBackgroundResource(favoriteBack);

        if (cacheListType == CacheListType.HISTORY && cache.getVisitedDate() > 0) {
            holder.info.setText(Formatter.formatCacheInfoHistory(cache));
        } else {
            holder.info.setText(Formatter.formatCacheInfoLong(cache, cacheListType));
        }

        return v;
    }

    private static Drawable getCacheIcon(Geocache cache) {
        int hashCode = getIconHashCode(cache.getType(), cache.hasUserModifiedCoords() || cache.hasFinalDefined());
        final Drawable drawable = gcIconDrawables.get(hashCode);
        if (drawable != null) {
            return drawable;
        }

        // fallback to mystery icon
        hashCode = getIconHashCode(CacheType.MYSTERY, cache.hasUserModifiedCoords() || cache.hasFinalDefined());
        return gcIconDrawables.get(hashCode);
    }

    @Override
    public void notifyDataSetChanged() {
        super.notifyDataSetChanged();
        distances.clear();
        compasses.clear();
    }

    private static class SelectionCheckBoxListener implements View.OnClickListener {

        private final Geocache cache;

        public SelectionCheckBoxListener(Geocache cache) {
            this.cache = cache;
        }

        @Override
        public void onClick(View view) {
            final boolean checkNow = ((CheckBox) view).isChecked();
            cache.setStatusChecked(checkNow);
        }
    }

    private class TouchListener implements View.OnLongClickListener, View.OnClickListener, View.OnTouchListener {

        private boolean touch = true;
        private final GestureDetector gestureDetector;
        private final Geocache cache;

        public TouchListener(final Geocache cache) {
            this.cache = cache;
            final FlingGesture dGesture = new FlingGesture(cache);
            gestureDetector = new GestureDetector(getContext(), dGesture);
        }

        // tap on item
        @Override
        public void onClick(View view) {
            if (!touch) {
                touch = true;
                return;
            }

            if (isSelectMode()) {
                cache.setStatusChecked(!cache.isStatusChecked());
                notifyDataSetChanged();
                return;
            }

            // load cache details
            CacheDetailActivity.startActivity(getContext(), cache.getGeocode(), cache.getName());
        }

        // long tap on item
        @Override
        public boolean onLongClick(View view) {
            if (!touch) {
                touch = true;
                return true;
            }

            return view.showContextMenu();
        }

        // swipe on item
        @Override
        public boolean onTouch(View view, MotionEvent event) {
            if (gestureDetector.onTouchEvent(event)) {
                touch = false;
                return true;
            }

            return false;
        }
    }

    private class FlingGesture extends GestureDetector.SimpleOnGestureListener {

        private final Geocache cache;

        public FlingGesture(Geocache cache) {
            this.cache = cache;
        }

        @Override
        public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
            try {
                if (Math.abs(e1.getY() - e2.getY()) > SWIPE_MAX_OFF_PATH) {
                    return false;
                }

                // left to right swipe
                if ((e2.getX() - e1.getX()) > SWIPE_MIN_DISTANCE && Math.abs(velocityX) > Math.abs(velocityY)) {
                    if (!selectMode) {
                        switchSelectMode();
                        cache.setStatusChecked(true);
                    }
                    return true;
                }

                // right to left swipe
                if ((e1.getX() - e2.getX()) > SWIPE_MIN_DISTANCE && Math.abs(velocityX) > Math.abs(velocityY)) {
                    if (selectMode) {
                        switchSelectMode();
                    }
                    return true;
                }
            } catch (Exception e) {
                Log.w("CacheListAdapter.FlingGesture.onFling", e);
            }

            return false;
        }
    }

    public List<Geocache> getFilteredList() {
        return list;
    }

    public List<Geocache> getCheckedCaches() {
        final ArrayList<Geocache> result = new ArrayList<Geocache>();
        for (Geocache cache : list) {
            if (cache.isStatusChecked()) {
                result.add(cache);
            }
        }
        return result;
    }

    public List<Geocache> getCheckedOrAllCaches() {
        final List<Geocache> result = getCheckedCaches();
        if (!result.isEmpty()) {
            return result;
        }
        return new ArrayList<Geocache>(list);
    }

    public int getCheckedOrAllCount() {
        final int checked = getCheckedCount();
        if (checked > 0) {
            return checked;
        }
        return list.size();
    }
}
!@#$%
20190527_002047,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_a16768
package cgeo.geocaching.ui;

import cgeo.geocaching.CacheDetailActivity;
import cgeo.geocaching.Geocache;
import cgeo.geocaching.IGeoData;
import cgeo.geocaching.R;
import cgeo.geocaching.Settings;
import cgeo.geocaching.cgeoapplication;
import cgeo.geocaching.enumerations.CacheListType;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.filter.IFilter;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.sorting.CacheComparator;
import cgeo.geocaching.sorting.DistanceComparator;
import cgeo.geocaching.sorting.InverseComparator;
import cgeo.geocaching.sorting.VisitComparator;
import cgeo.geocaching.utils.AngleUtils;
import cgeo.geocaching.utils.Log;

import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang3.builder.HashCodeBuilder;

import android.app.Activity;
import android.content.res.Resources;
import android.graphics.drawable.Drawable;
import android.graphics.drawable.LayerDrawable;
import android.text.Spannable;
import android.text.Spanned;
import android.text.style.ForegroundColorSpan;
import android.text.style.StrikethroughSpan;
import android.util.SparseArray;
import android.view.GestureDetector;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ArrayAdapter;
import android.widget.CheckBox;
import android.widget.ImageView;
import android.widget.TextView;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;

public class CacheListAdapter extends ArrayAdapter<Geocache> {

    private LayoutInflater inflater = null;
    private CacheComparator cacheComparator = null;
    private Geopoint coords;
    private float azimuth = 0;
    private long lastSort = 0L;
    private boolean selectMode = false;
    private IFilter currentFilter = null;
    private List<Geocache> originalList = null;

    final private Set<CompassMiniView> compasses = new LinkedHashSet<CompassMiniView>();
    final private Set<DistanceView> distances = new LinkedHashSet<DistanceView>();
    final private CacheListType cacheListType;
    final private Resources res;
    /** Resulting list of caches */
    final private List<Geocache> list;
    private boolean inverseSort = false;

    private static final int SWIPE_MIN_DISTANCE = 60;
    private static final int SWIPE_MAX_OFF_PATH = 100;
    private static final SparseArray<Drawable> gcIconDrawables = new SparseArray<Drawable>();
    /**
     * time in milliseconds after which the list may be resorted due to position updates
     */
    private static final int PAUSE_BETWEEN_LIST_SORT = 1000;

    private static final int[] RATING_BACKGROUND = new int[3];
    static {
        if (Settings.isLightSkin()) {
            RATING_BACKGROUND[0] = R.drawable.favourite_background_red_light;
            RATING_BACKGROUND[1] = R.drawable.favourite_background_orange_light;
            RATING_BACKGROUND[2] = R.drawable.favourite_background_green_light;
        } else {
            RATING_BACKGROUND[0] = R.drawable.favourite_background_red_dark;
            RATING_BACKGROUND[1] = R.drawable.favourite_background_orange_dark;
            RATING_BACKGROUND[2] = R.drawable.favourite_background_green_dark;
        }
    }

    /**
     * view holder for the cache list adapter
     *
     */
    private static class ViewHolder {
        CheckBox checkbox;
        ImageView logStatusMark;
        TextView text;
        TextView favourite;
        TextView info;
        ImageView inventory;
        DistanceView distance;
        CompassMiniView direction;
        ImageView dirImg;
    }

    public CacheListAdapter(final Activity activity, final List<Geocache> list, CacheListType cacheListType) {
        super(activity, 0, list);
        final IGeoData currentGeo = cgeoapplication.getInstance().currentGeo();
        if (currentGeo != null) {
            coords = currentGeo.getCoords();
        }
        this.res = activity.getResources();
        this.list = list;
        this.cacheListType = cacheListType;
        if (cacheListType == CacheListType.HISTORY) {
            cacheComparator = new VisitComparator();
        }

        final Drawable modifiedCoordinatesMarker = activity.getResources().getDrawable(R.drawable.marker_usermodifiedcoords);
        for (final CacheType cacheType : CacheType.values()) {
            // unmodified icon
            int hashCode = getIconHashCode(cacheType, false);
            gcIconDrawables.put(hashCode, activity.getResources().getDrawable(cacheType.markerId));
            // icon with flag for user modified coordinates
            hashCode = getIconHashCode(cacheType, true);
            Drawable[] layers = new Drawable[2];
            layers[0] = activity.getResources().getDrawable(cacheType.markerId);
            layers[1] = modifiedCoordinatesMarker;
            LayerDrawable ld = new LayerDrawable(layers);
            ld.setLayerInset(1,
                    layers[0].getIntrinsicWidth() - layers[1].getIntrinsicWidth(),
                    layers[0].getIntrinsicHeight() - layers[1].getIntrinsicHeight(),
                    0, 0);
            gcIconDrawables.put(hashCode, ld);
        }
    }

    private static int getIconHashCode(final CacheType cacheType, final boolean userModifiedOrFinal) {
        return new HashCodeBuilder()
                .append(cacheType)
                .append(userModifiedOrFinal)
                .toHashCode();
    }

    /**
     * change the sort order
     *
     * @param comparator
     */
    public void setComparator(final CacheComparator comparator) {
        cacheComparator = comparator;
        forceSort();
    }

    public void resetInverseSort() {
        inverseSort = false;
    }

    public void toggleInverseSort() {
        inverseSort = !inverseSort;
    }

    public CacheComparator getCacheComparator() {
        return cacheComparator;
    }

    public Geocache findCacheByGeocode(String geocode) {
        for (int i = 0; i < getCount(); i++) {
            if (getItem(i).getGeocode().equalsIgnoreCase(geocode)) {
                return getItem(i);
            }
        }

        return null;
    }
    /**
     * Called when a new page of caches was loaded.
     */
    public void reFilter() {
        if (currentFilter != null) {
            // Back up the list again
            originalList = new ArrayList<Geocache>(list);

            currentFilter.filter(list);
        }
    }

    /**
     * Called after a user action on the filter menu.
     */
    public void setFilter(final IFilter filter) {
        // Backup current caches list if it isn't backed up yet
        if (originalList == null) {
            originalList = new ArrayList<Geocache>(list);
        }

        // If there is already a filter in place, this is a request to change or clear the filter, so we have to
        // replace the original cache list
        if (currentFilter != null) {
            list.clear();
            list.addAll(originalList);
        }

        // Do the filtering or clear it
        if (filter != null) {
            filter.filter(list);
        }
        currentFilter = filter;

        notifyDataSetChanged();
    }

    public boolean isFiltered() {
        return currentFilter != null;
    }

    public String getFilterName() {
        return currentFilter.getName();
    }

    public int getCheckedCount() {
        int checked = 0;
        for (Geocache cache : list) {
            if (cache.isStatusChecked()) {
                checked++;
            }
        }
        return checked;
    }

    public void setSelectMode(final boolean selectMode) {
        this.selectMode = selectMode;

        if (!selectMode) {
            for (final Geocache cache : list) {
                cache.setStatusChecked(false);
            }
        }
        notifyDataSetChanged();
    }

    public boolean isSelectMode() {
        return selectMode;
    }

    public void switchSelectMode() {
        setSelectMode(!isSelectMode());
    }

    public void invertSelection() {
        for (Geocache cache : list) {
            cache.setStatusChecked(!cache.isStatusChecked());
        }
        notifyDataSetChanged();
    }

    public void forceSort() {
        if (CollectionUtils.isEmpty(list) || selectMode) {
            return;
        }

        if (isSortedByDistance()) {
            lastSort = 0;
            updateSortByDistance();
        }
        else {
            Collections.sort(list, getPotentialInversion(cacheComparator));
        }

        notifyDataSetChanged();
    }

    public void setActualCoordinates(final Geopoint coords) {
        this.coords = coords;
        updateSortByDistance();

        for (final DistanceView distance : distances) {
            distance.update(coords);
        }
        for (final CompassMiniView compass : compasses) {
            compass.updateCurrentCoords(coords);
        }
    }

    private void updateSortByDistance() {
        if (CollectionUtils.isEmpty(list)) {
            return;
        }
        if (selectMode) {
            return;
        }
        if ((System.currentTimeMillis() - lastSort) <= PAUSE_BETWEEN_LIST_SORT) {
            return;
        }
        if (!isSortedByDistance()) {
            return;
        }
        if (coords == null) {
            return;
        }
        final ArrayList<Geocache> oldList = new ArrayList<Geocache>(list);
        Collections.sort(list, getPotentialInversion(new DistanceComparator(coords, list)));

        // avoid an update if the list has not changed due to location update
        if (list.equals(oldList)) {
            return;
        }
        notifyDataSetChanged();
        lastSort = System.currentTimeMillis();
    }

    private Comparator<? super Geocache> getPotentialInversion(final CacheComparator comparator) {
        if (inverseSort) {
            return new InverseComparator(comparator);
        }
        return comparator;
    }

    private boolean isSortedByDistance() {
        return cacheComparator == null || cacheComparator instanceof DistanceComparator;
    }

    public void setActualHeading(final float direction) {
        if (Math.abs(AngleUtils.difference(azimuth, direction)) < 10) {
            return;
        }

        azimuth = direction;
        for (final CompassMiniView compass : compasses) {
            compass.updateAzimuth(azimuth);
        }
    }

    @Override
    public View getView(final int position, final View rowView, final ViewGroup parent) {
        if (inflater == null) {
            inflater = ((Activity) getContext()).getLayoutInflater();
        }

        if (position > getCount()) {
            Log.w("CacheListAdapter.getView: Attempt to access missing item #" + position);
            return null;
        }

        final Geocache cache = getItem(position);

        View v = rowView;

        final ViewHolder holder;
        if (v == null) {
            v = inflater.inflate(R.layout.caches_item, null);

            holder = new ViewHolder();
            holder.checkbox = (CheckBox) v.findViewById(R.id.checkbox);
            holder.logStatusMark = (ImageView) v.findViewById(R.id.log_status_mark);
            holder.text = (TextView) v.findViewById(R.id.text);
            holder.distance = (DistanceView) v.findViewById(R.id.distance);
            holder.direction = (CompassMiniView) v.findViewById(R.id.direction);
            holder.dirImg = (ImageView) v.findViewById(R.id.dirimg);
            holder.inventory = (ImageView) v.findViewById(R.id.inventory);
            holder.favourite = (TextView) v.findViewById(R.id.favourite);
            holder.info = (TextView) v.findViewById(R.id.info);

            v.setTag(holder);
        } else {
            holder = (ViewHolder) v.getTag();
        }

        final boolean lightSkin = Settings.isLightSkin();

        final TouchListener touchLst = new TouchListener(cache);
        v.setOnClickListener(touchLst);
        v.setOnLongClickListener(touchLst);
        v.setOnTouchListener(touchLst);
        v.setLongClickable(true);

        if (selectMode) {
            holder.checkbox.setVisibility(View.VISIBLE);
        }
        else {
            holder.checkbox.setVisibility(View.GONE);
        }

        holder.checkbox.setChecked(cache.isStatusChecked());
        holder.checkbox.setOnClickListener(new SelectionCheckBoxListener(cache));

        distances.add(holder.distance);
        holder.distance.setContent(cache.getCoords());
        compasses.add(holder.direction);
        holder.direction.setTargetCoords(cache.getCoords());

        if (cache.isFound() && cache.isLogOffline()) {
            holder.logStatusMark.setImageResource(R.drawable.mark_green_orange);
            holder.logStatusMark.setVisibility(View.VISIBLE);
        } else if (cache.isFound()) {
            holder.logStatusMark.setImageResource(R.drawable.mark_green_more);
            holder.logStatusMark.setVisibility(View.VISIBLE);
        } else if (cache.isLogOffline()) {
            holder.logStatusMark.setImageResource(R.drawable.mark_orange);
            holder.logStatusMark.setVisibility(View.VISIBLE);
        } else {
            holder.logStatusMark.setVisibility(View.GONE);
        }

        Spannable spannable = null;
        if (cache.isDisabled() || cache.isArchived()) { // strike
            spannable = Spannable.Factory.getInstance().newSpannable(cache.getName());
            spannable.setSpan(new StrikethroughSpan(), 0, spannable.toString().length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        }
        if (cache.isArchived()) { // red color
            if (spannable == null) {
                spannable = Spannable.Factory.getInstance().newSpannable(cache.getName());
            }
            spannable.setSpan(new ForegroundColorSpan(res.getColor(R.color.archived_cache_color)), 0, spannable.toString().length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        }

        if (spannable != null) {
            holder.text.setText(spannable, TextView.BufferType.SPANNABLE);
        }
        else {
            holder.text.setText(cache.getName());
        }
        holder.text.setCompoundDrawablesWithIntrinsicBounds(getCacheIcon(cache), null, null, null);

        if (cache.getInventoryItems() > 0) {
            holder.inventory.setVisibility(View.VISIBLE);
        } else {
            holder.inventory.setVisibility(View.GONE);
        }

        if (cache.getDistance() != null) {
            holder.distance.setDistance(cache.getDistance());
        }
        if (cache.getCoords() != null) {
            holder.direction.setVisibility(View.VISIBLE);
            holder.dirImg.setVisibility(View.GONE);
            holder.direction.updateAzimuth(azimuth);
            if (coords != null) {
                holder.distance.update(coords);
                holder.direction.updateCurrentCoords(coords);
            }
        } else if (cache.getDirection() != null) {
            holder.direction.setVisibility(View.VISIBLE);
            holder.dirImg.setVisibility(View.GONE);
            holder.direction.updateAzimuth(azimuth);
            holder.direction.updateHeading(cache.getDirection());
        } else {
            holder.dirImg.setImageDrawable(DirectionImage.getDrawable(cache.getDirectionImg()));
            holder.dirImg.setVisibility(View.VISIBLE);
            holder.direction.setVisibility(View.GONE);
        }

        holder.favourite.setText(Integer.toString(cache.getFavoritePoints()));

        int favoriteBack;
        // set default background, neither vote nor rating may be available
        if (lightSkin) {
            favoriteBack = R.drawable.favourite_background_light;
        } else {
            favoriteBack = R.drawable.favourite_background_dark;
        }
        final float myVote = cache.getMyVote();
        if (myVote > 0) { // use my own rating for display, if I have voted
            if (myVote >= 4) {
                favoriteBack = RATING_BACKGROUND[2];
            } else if (myVote >= 3) {
                favoriteBack = RATING_BACKGROUND[1];
            } else if (myVote > 0) {
                favoriteBack = RATING_BACKGROUND[0];
            }
        } else {
            final float rating = cache.getRating();
            if (rating >= 3.5) {
                favoriteBack = RATING_BACKGROUND[2];
            } else if (rating >= 2.1) {
                favoriteBack = RATING_BACKGROUND[1];
            } else if (rating > 0.0) {
                favoriteBack = RATING_BACKGROUND[0];
            }
        }
        holder.favourite.setBackgroundResource(favoriteBack);

        if (cacheListType == CacheListType.HISTORY && cache.getVisitedDate() > 0) {
            holder.info.setText(Formatter.formatCacheInfoHistory(cache));
        } else {
            holder.info.setText(Formatter.formatCacheInfoLong(cache, cacheListType));
        }

        return v;
    }

    private static Drawable getCacheIcon(Geocache cache) {
        int hashCode = getIconHashCode(cache.getType(), cache.hasUserModifiedCoords() || cache.hasFinalDefined());
        final Drawable drawable = gcIconDrawables.get(hashCode);
        if (drawable != null) {
            return drawable;
        }

        // fallback to mystery icon
        hashCode = getIconHashCode(CacheType.MYSTERY, cache.hasUserModifiedCoords() || cache.hasFinalDefined());
        return gcIconDrawables.get(hashCode);
    }

    @Override
    public void notifyDataSetChanged() {
        super.notifyDataSetChanged();
        distances.clear();
        compasses.clear();
    }

    private static class SelectionCheckBoxListener implements View.OnClickListener {

        private final Geocache cache;

        public SelectionCheckBoxListener(Geocache cache) {
            this.cache = cache;
        }

        @Override
        public void onClick(View view) {
            final boolean checkNow = ((CheckBox) view).isChecked();
            cache.setStatusChecked(checkNow);
        }
    }

    private class TouchListener implements View.OnLongClickListener, View.OnClickListener, View.OnTouchListener {

        private boolean touch = true;
        private final GestureDetector gestureDetector;
        private final Geocache cache;

        public TouchListener(final Geocache cache) {
            this.cache = cache;
            final FlingGesture dGesture = new FlingGesture(cache);
            gestureDetector = new GestureDetector(getContext(), dGesture);
        }

        // tap on item
        @Override
        public void onClick(View view) {
            if (!touch) {
                touch = true;
                return;
            }

            if (isSelectMode()) {
                cache.setStatusChecked(!cache.isStatusChecked());
                notifyDataSetChanged();
                return;
            }

            // load cache details
            CacheDetailActivity.startActivity(getContext(), cache.getGeocode(), cache.getName());
        }

        // long tap on item
        @Override
        public boolean onLongClick(View view) {
            if (!touch) {
                touch = true;
                return true;
            }

            return view.showContextMenu();
        }

        // swipe on item
        @Override
        public boolean onTouch(View view, MotionEvent event) {
            if (gestureDetector.onTouchEvent(event)) {
                touch = false;
                return true;
            }

            return false;
        }
    }

    private class FlingGesture extends GestureDetector.SimpleOnGestureListener {

        private final Geocache cache;

        public FlingGesture(Geocache cache) {
            this.cache = cache;
        }

        @Override
        public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
            try {
                if (Math.abs(e1.getY() - e2.getY()) > SWIPE_MAX_OFF_PATH) {
                    return false;
                }

                // left to right swipe
                if ((e2.getX() - e1.getX()) > SWIPE_MIN_DISTANCE && Math.abs(velocityX) > Math.abs(velocityY)) {
                    if (!selectMode) {
                        switchSelectMode();
                        cache.setStatusChecked(true);
                    }
                    return true;
                }

                // right to left swipe
                if ((e1.getX() - e2.getX()) > SWIPE_MIN_DISTANCE && Math.abs(velocityX) > Math.abs(velocityY)) {
                    if (selectMode) {
                        switchSelectMode();
                    }
                    return true;
                }
            } catch (Exception e) {
                Log.w("CacheListAdapter.FlingGesture.onFling", e);
            }

            return false;
        }
    }

    public List<Geocache> getFilteredList() {
        return list;
    }

    public List<Geocache> getCheckedCaches() {
        final ArrayList<Geocache> result = new ArrayList<Geocache>();
        for (Geocache cache : list) {
            if (cache.isStatusChecked()) {
                result.add(cache);
            }
        }
        return result;
    }

    public List<Geocache> getCheckedOrAllCaches() {
        final List<Geocache> result = getCheckedCaches();
        if (!result.isEmpty()) {
            return result;
        }
        return new ArrayList<Geocache>(list);
    }

    public int getCheckedOrAllCount() {
        final int checked = getCheckedCount();
        if (checked > 0) {
            return checked;
        }
        return list.size();
    }
}
!@#$%
20190527_002047,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_c16768
package cgeo.geocaching.ui;

import cgeo.geocaching.CacheDetailActivity;
import cgeo.geocaching.Geocache;
import cgeo.geocaching.IGeoData;
import cgeo.geocaching.R;
import cgeo.geocaching.Settings;
import cgeo.geocaching.cgeoapplication;
import cgeo.geocaching.enumerations.CacheListType;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.filter.IFilter;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.sorting.CacheComparator;
import cgeo.geocaching.sorting.DistanceComparator;
import cgeo.geocaching.sorting.InverseComparator;
import cgeo.geocaching.sorting.VisitComparator;
import cgeo.geocaching.utils.AngleUtils;
import cgeo.geocaching.utils.Log;

import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.builder.HashCodeBuilder;

import android.app.Activity;
import android.content.res.Resources;
import android.graphics.drawable.Drawable;
import android.graphics.drawable.LayerDrawable;
import android.text.Spannable;
import android.text.Spanned;
import android.text.style.ForegroundColorSpan;
import android.text.style.StrikethroughSpan;
import android.util.SparseArray;
import android.view.GestureDetector;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ArrayAdapter;
import android.widget.CheckBox;
import android.widget.ImageView;
import android.widget.TextView;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;

public class CacheListAdapter extends ArrayAdapter<Geocache> {

    private LayoutInflater inflater = null;
    private CacheComparator cacheComparator = null;
    private Geopoint coords;
    private float azimuth = 0;
    private long lastSort = 0L;
    private boolean selectMode = false;
    private IFilter currentFilter = null;
    private List<Geocache> originalList = null;

    final private Set<CompassMiniView> compasses = new LinkedHashSet<CompassMiniView>();
    final private Set<DistanceView> distances = new LinkedHashSet<DistanceView>();
    final private CacheListType cacheListType;
    final private Resources res;
    /** Resulting list of caches */
    final private List<Geocache> list;
    private boolean inverseSort = false;

    private static final int SWIPE_MIN_DISTANCE = 60;
    private static final int SWIPE_MAX_OFF_PATH = 100;
    private static final SparseArray<Drawable> gcIconDrawables = new SparseArray<Drawable>();
    /**
     * time in milliseconds after which the list may be resorted due to position updates
     */
    private static final int PAUSE_BETWEEN_LIST_SORT = 1000;

    private static final int[] RATING_BACKGROUND = new int[3];
    static {
        if (Settings.isLightSkin()) {
            RATING_BACKGROUND[0] = R.drawable.favourite_background_red_light;
            RATING_BACKGROUND[1] = R.drawable.favourite_background_orange_light;
            RATING_BACKGROUND[2] = R.drawable.favourite_background_green_light;
        } else {
            RATING_BACKGROUND[0] = R.drawable.favourite_background_red_dark;
            RATING_BACKGROUND[1] = R.drawable.favourite_background_orange_dark;
            RATING_BACKGROUND[2] = R.drawable.favourite_background_green_dark;
        }
    }

    /**
     * view holder for the cache list adapter
     *
     */
    private static class ViewHolder {
        CheckBox checkbox;
        ImageView logStatusMark;
        TextView text;
        TextView favourite;
        TextView info;
        ImageView inventory;
        DistanceView distance;
        CompassMiniView direction;
        ImageView dirImg;
    }

    public CacheListAdapter(final Activity activity, final List<Geocache> list, CacheListType cacheListType) {
        super(activity, 0, list);
        final IGeoData currentGeo = cgeoapplication.getInstance().currentGeo();
        if (currentGeo != null) {
            coords = currentGeo.getCoords();
        }
        this.res = activity.getResources();
        this.list = list;
        this.cacheListType = cacheListType;
        if (cacheListType == CacheListType.HISTORY) {
            cacheComparator = new VisitComparator();
        }

        final Drawable modifiedCoordinatesMarker = activity.getResources().getDrawable(R.drawable.marker_usermodifiedcoords);
        for (final CacheType cacheType : CacheType.values()) {
            // unmodified icon
            int hashCode = getIconHashCode(cacheType, false);
            gcIconDrawables.put(hashCode, activity.getResources().getDrawable(cacheType.markerId));
            // icon with flag for user modified coordinates
            hashCode = getIconHashCode(cacheType, true);
            Drawable[] layers = new Drawable[2];
            layers[0] = activity.getResources().getDrawable(cacheType.markerId);
            layers[1] = modifiedCoordinatesMarker;
            LayerDrawable ld = new LayerDrawable(layers);
            ld.setLayerInset(1,
                    layers[0].getIntrinsicWidth() - layers[1].getIntrinsicWidth(),
                    layers[0].getIntrinsicHeight() - layers[1].getIntrinsicHeight(),
                    0, 0);
            gcIconDrawables.put(hashCode, ld);
        }
    }

    private static int getIconHashCode(final CacheType cacheType, final boolean userModifiedOrFinal) {
        return new HashCodeBuilder()
                .append(cacheType)
                .append(userModifiedOrFinal)
                .toHashCode();
    }

    /**
     * change the sort order
     *
     * @param comparator
     */
    public void setComparator(final CacheComparator comparator) {
        cacheComparator = comparator;
        forceSort();
    }

    public void resetInverseSort() {
        inverseSort = false;
    }

    public void toggleInverseSort() {
        inverseSort = !inverseSort;
    }

    public CacheComparator getCacheComparator() {
        return cacheComparator;
    }

    public Geocache findCacheByGeocode(String geocode) {
        for (int i = 0; i < getCount(); i++) {
            if (getItem(i).getGeocode().equalsIgnoreCase(geocode)) {
                return getItem(i);
            }
        }

        return null;
    }
    /**
     * Called when a new page of caches was loaded.
     */
    public void reFilter() {
        if (currentFilter != null) {
            // Back up the list again
            originalList = new ArrayList<Geocache>(list);

            currentFilter.filter(list);
        }
    }

    /**
     * Called after a user action on the filter menu.
     */
    public void setFilter(final IFilter filter) {
        // Backup current caches list if it isn't backed up yet
        if (originalList == null) {
            originalList = new ArrayList<Geocache>(list);
        }

        // If there is already a filter in place, this is a request to change or clear the filter, so we have to
        // replace the original cache list
        if (currentFilter != null) {
            list.clear();
            list.addAll(originalList);
        }

        // Do the filtering or clear it
        if (filter != null) {
            filter.filter(list);
        }
        currentFilter = filter;

        notifyDataSetChanged();
    }

    public boolean isFiltered() {
        return currentFilter != null;
    }

    public String getFilterName() {
        return currentFilter.getName();
    }

    public int getCheckedCount() {
        int checked = 0;
        for (Geocache cache : list) {
            if (cache.isStatusChecked()) {
                checked++;
            }
        }
        return checked;
    }

    public void setSelectMode(final boolean selectMode) {
        this.selectMode = selectMode;

        if (!selectMode) {
            for (final Geocache cache : list) {
                cache.setStatusChecked(false);
            }
        }
        notifyDataSetChanged();
    }

    public boolean isSelectMode() {
        return selectMode;
    }

    public void switchSelectMode() {
        setSelectMode(!isSelectMode());
    }

    public void invertSelection() {
        for (Geocache cache : list) {
            cache.setStatusChecked(!cache.isStatusChecked());
        }
        notifyDataSetChanged();
    }

    public void forceSort() {
        if (CollectionUtils.isEmpty(list) || selectMode) {
            return;
        }

        if (isSortedByDistance()) {
            lastSort = 0;
            updateSortByDistance();
        }
        else {
            Collections.sort(list, getPotentialInversion(cacheComparator));
        }

        notifyDataSetChanged();
    }

    public void setActualCoordinates(final Geopoint coords) {
        this.coords = coords;
        updateSortByDistance();

        for (final DistanceView distance : distances) {
            distance.update(coords);
        }
        for (final CompassMiniView compass : compasses) {
            compass.updateCurrentCoords(coords);
        }
    }

    private void updateSortByDistance() {
        if (CollectionUtils.isEmpty(list)) {
            return;
        }
        if (selectMode) {
            return;
        }
        if ((System.currentTimeMillis() - lastSort) <= PAUSE_BETWEEN_LIST_SORT) {
            return;
        }
        if (!isSortedByDistance()) {
            return;
        }
        if (coords == null) {
            return;
        }
        final ArrayList<Geocache> oldList = new ArrayList<Geocache>(list);
        Collections.sort(list, getPotentialInversion(new DistanceComparator(coords, list)));

        // avoid an update if the list has not changed due to location update
        if (list.equals(oldList)) {
            return;
        }
        notifyDataSetChanged();
        lastSort = System.currentTimeMillis();
    }

    private Comparator<? super Geocache> getPotentialInversion(final CacheComparator comparator) {
        if (inverseSort) {
            return new InverseComparator(comparator);
        }
        return comparator;
    }

    private boolean isSortedByDistance() {
        return cacheComparator == null || cacheComparator instanceof DistanceComparator;
    }

    public void setActualHeading(final float direction) {
        if (Math.abs(AngleUtils.difference(azimuth, direction)) < 10) {
            return;
        }

        azimuth = direction;
        for (final CompassMiniView compass : compasses) {
            compass.updateAzimuth(azimuth);
        }
    }

    @Override
    public View getView(final int position, final View rowView, final ViewGroup parent) {
        if (inflater == null) {
            inflater = ((Activity) getContext()).getLayoutInflater();
        }

        if (position > getCount()) {
            Log.w("CacheListAdapter.getView: Attempt to access missing item #" + position);
            return null;
        }

        final Geocache cache = getItem(position);

        View v = rowView;

        final ViewHolder holder;
        if (v == null) {
            v = inflater.inflate(R.layout.caches_item, null);

            holder = new ViewHolder();
            holder.checkbox = (CheckBox) v.findViewById(R.id.checkbox);
            holder.logStatusMark = (ImageView) v.findViewById(R.id.log_status_mark);
            holder.text = (TextView) v.findViewById(R.id.text);
            holder.distance = (DistanceView) v.findViewById(R.id.distance);
            holder.direction = (CompassMiniView) v.findViewById(R.id.direction);
            holder.dirImg = (ImageView) v.findViewById(R.id.dirimg);
            holder.inventory = (ImageView) v.findViewById(R.id.inventory);
            holder.favourite = (TextView) v.findViewById(R.id.favourite);
            holder.info = (TextView) v.findViewById(R.id.info);

            v.setTag(holder);
        } else {
            holder = (ViewHolder) v.getTag();
        }

        final boolean lightSkin = Settings.isLightSkin();

        final TouchListener touchLst = new TouchListener(cache);
        v.setOnClickListener(touchLst);
        v.setOnLongClickListener(touchLst);
        v.setOnTouchListener(touchLst);
        v.setLongClickable(true);

        if (selectMode) {
            holder.checkbox.setVisibility(View.VISIBLE);
        }
        else {
            holder.checkbox.setVisibility(View.GONE);
        }

        holder.checkbox.setChecked(cache.isStatusChecked());
        holder.checkbox.setOnClickListener(new SelectionCheckBoxListener(cache));

        distances.add(holder.distance);
        holder.distance.setContent(cache.getCoords());
        compasses.add(holder.direction);
        holder.direction.setTargetCoords(cache.getCoords());

        if (cache.isFound() && cache.isLogOffline()) {
            holder.logStatusMark.setImageResource(R.drawable.mark_green_orange);
            holder.logStatusMark.setVisibility(View.VISIBLE);
        } else if (cache.isFound()) {
            holder.logStatusMark.setImageResource(R.drawable.mark_green_more);
            holder.logStatusMark.setVisibility(View.VISIBLE);
        } else if (cache.isLogOffline()) {
            holder.logStatusMark.setImageResource(R.drawable.mark_orange);
            holder.logStatusMark.setVisibility(View.VISIBLE);
        } else {
            holder.logStatusMark.setVisibility(View.GONE);
        }

        Spannable spannable = null;
        if (cache.isDisabled() || cache.isArchived()) { // strike
            spannable = Spannable.Factory.getInstance().newSpannable(cache.getName());
            spannable.setSpan(new StrikethroughSpan(), 0, spannable.toString().length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        }
        if (cache.isArchived()) { // red color
            if (spannable == null) {
                spannable = Spannable.Factory.getInstance().newSpannable(cache.getName());
            }
            spannable.setSpan(new ForegroundColorSpan(res.getColor(R.color.archived_cache_color)), 0, spannable.toString().length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        }

        if (spannable != null) {
            holder.text.setText(spannable, TextView.BufferType.SPANNABLE);
        }
        else {
            holder.text.setText(cache.getName());
        }
        holder.text.setCompoundDrawablesWithIntrinsicBounds(getCacheIcon(cache), null, null, null);

        if (cache.getInventoryItems() > 0) {
            holder.inventory.setVisibility(View.VISIBLE);
        } else {
            holder.inventory.setVisibility(View.GONE);
        }

        if (cache.getDistance() != null) {
            holder.distance.setDistance(cache.getDistance());
        }
        if (cache.getCoords() != null) {
            holder.direction.setVisibility(View.VISIBLE);
            holder.dirImg.setVisibility(View.GONE);
            holder.direction.updateAzimuth(azimuth);
            if (coords != null) {
                holder.distance.update(coords);
                holder.direction.updateCurrentCoords(coords);
            }
        } else if (cache.getDirection() != null) {
            holder.direction.setVisibility(View.VISIBLE);
            holder.dirImg.setVisibility(View.GONE);
            holder.direction.updateAzimuth(azimuth);
            holder.direction.updateHeading(cache.getDirection());
        } else if (StringUtils.isNotBlank(cache.getDirectionImg())) {
            holder.dirImg.setImageDrawable(DirectionImage.getDrawable(cache.getDirectionImg()));
            holder.dirImg.setVisibility(View.VISIBLE);
            holder.direction.setVisibility(View.GONE);
        } else {
            holder.dirImg.setVisibility(View.GONE);
            holder.direction.setVisibility(View.GONE);
        }

        holder.favourite.setText(Integer.toString(cache.getFavoritePoints()));

        int favoriteBack;
        // set default background, neither vote nor rating may be available
        if (lightSkin) {
            favoriteBack = R.drawable.favourite_background_light;
        } else {
            favoriteBack = R.drawable.favourite_background_dark;
        }
        final float myVote = cache.getMyVote();
        if (myVote > 0) { // use my own rating for display, if I have voted
            if (myVote >= 4) {
                favoriteBack = RATING_BACKGROUND[2];
            } else if (myVote >= 3) {
                favoriteBack = RATING_BACKGROUND[1];
            } else if (myVote > 0) {
                favoriteBack = RATING_BACKGROUND[0];
            }
        } else {
            final float rating = cache.getRating();
            if (rating >= 3.5) {
                favoriteBack = RATING_BACKGROUND[2];
            } else if (rating >= 2.1) {
                favoriteBack = RATING_BACKGROUND[1];
            } else if (rating > 0.0) {
                favoriteBack = RATING_BACKGROUND[0];
            }
        }
        holder.favourite.setBackgroundResource(favoriteBack);

        if (cacheListType == CacheListType.HISTORY && cache.getVisitedDate() > 0) {
            holder.info.setText(Formatter.formatCacheInfoHistory(cache));
        } else {
            holder.info.setText(Formatter.formatCacheInfoLong(cache, cacheListType));
        }

        return v;
    }

    private static Drawable getCacheIcon(Geocache cache) {
        int hashCode = getIconHashCode(cache.getType(), cache.hasUserModifiedCoords() || cache.hasFinalDefined());
        final Drawable drawable = gcIconDrawables.get(hashCode);
        if (drawable != null) {
            return drawable;
        }

        // fallback to mystery icon
        hashCode = getIconHashCode(CacheType.MYSTERY, cache.hasUserModifiedCoords() || cache.hasFinalDefined());
        return gcIconDrawables.get(hashCode);
    }

    @Override
    public void notifyDataSetChanged() {
        super.notifyDataSetChanged();
        distances.clear();
        compasses.clear();
    }

    private static class SelectionCheckBoxListener implements View.OnClickListener {

        private final Geocache cache;

        public SelectionCheckBoxListener(Geocache cache) {
            this.cache = cache;
        }

        @Override
        public void onClick(View view) {
            final boolean checkNow = ((CheckBox) view).isChecked();
            cache.setStatusChecked(checkNow);
        }
    }

    private class TouchListener implements View.OnLongClickListener, View.OnClickListener, View.OnTouchListener {

        private boolean touch = true;
        private final GestureDetector gestureDetector;
        private final Geocache cache;

        public TouchListener(final Geocache cache) {
            this.cache = cache;
            final FlingGesture dGesture = new FlingGesture(cache);
            gestureDetector = new GestureDetector(getContext(), dGesture);
        }

        // tap on item
        @Override
        public void onClick(View view) {
            if (!touch) {
                touch = true;
                return;
            }

            if (isSelectMode()) {
                cache.setStatusChecked(!cache.isStatusChecked());
                notifyDataSetChanged();
                return;
            }

            // load cache details
            CacheDetailActivity.startActivity(getContext(), cache.getGeocode(), cache.getName());
        }

        // long tap on item
        @Override
        public boolean onLongClick(View view) {
            if (!touch) {
                touch = true;
                return true;
            }

            return view.showContextMenu();
        }

        // swipe on item
        @Override
        public boolean onTouch(View view, MotionEvent event) {
            if (gestureDetector.onTouchEvent(event)) {
                touch = false;
                return true;
            }

            return false;
        }
    }

    private class FlingGesture extends GestureDetector.SimpleOnGestureListener {

        private final Geocache cache;

        public FlingGesture(Geocache cache) {
            this.cache = cache;
        }

        @Override
        public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
            try {
                if (Math.abs(e1.getY() - e2.getY()) > SWIPE_MAX_OFF_PATH) {
                    return false;
                }

                // left to right swipe
                if ((e2.getX() - e1.getX()) > SWIPE_MIN_DISTANCE && Math.abs(velocityX) > Math.abs(velocityY)) {
                    if (!selectMode) {
                        switchSelectMode();
                        cache.setStatusChecked(true);
                    }
                    return true;
                }

                // right to left swipe
                if ((e1.getX() - e2.getX()) > SWIPE_MIN_DISTANCE && Math.abs(velocityX) > Math.abs(velocityY)) {
                    if (selectMode) {
                        switchSelectMode();
                    }
                    return true;
                }
            } catch (Exception e) {
                Log.w("CacheListAdapter.FlingGesture.onFling", e);
            }

            return false;
        }
    }

    public List<Geocache> getFilteredList() {
        return list;
    }

    public List<Geocache> getCheckedCaches() {
        final ArrayList<Geocache> result = new ArrayList<Geocache>();
        for (Geocache cache : list) {
            if (cache.isStatusChecked()) {
                result.add(cache);
            }
        }
        return result;
    }

    public List<Geocache> getCheckedOrAllCaches() {
        final List<Geocache> result = getCheckedCaches();
        if (!result.isEmpty()) {
            return result;
        }
        return new ArrayList<Geocache>(list);
    }

    public int getCheckedOrAllCount() {
        final int checked = getCheckedCount();
        if (checked > 0) {
            return checked;
        }
        return list.size();
    }
}
!@#$%
20190527_002208,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_b04972
package cgeo.geocaching.connector.oc;

import cgeo.geocaching.Geocache;
import cgeo.geocaching.Image;
import cgeo.geocaching.LogEntry;
import cgeo.geocaching.R;
import cgeo.geocaching.Settings;
import cgeo.geocaching.Waypoint;
import cgeo.geocaching.cgData;
import cgeo.geocaching.cgeoapplication;
import cgeo.geocaching.connector.ConnectorFactory;
import cgeo.geocaching.connector.IConnector;
import cgeo.geocaching.connector.LogResult;
import cgeo.geocaching.connector.gc.GCConnector;
import cgeo.geocaching.connector.oc.OCApiConnector.ApiSupport;
import cgeo.geocaching.connector.oc.OCApiConnector.OAuthLevel;
import cgeo.geocaching.enumerations.CacheAttribute;
import cgeo.geocaching.enumerations.CacheSize;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.LoadFlags.SaveFlag;
import cgeo.geocaching.enumerations.LogType;
import cgeo.geocaching.enumerations.StatusCode;
import cgeo.geocaching.enumerations.WaypointType;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.geopoint.GeopointFormatter;
import cgeo.geocaching.geopoint.Viewport;
import cgeo.geocaching.network.Network;
import cgeo.geocaching.network.OAuth;
import cgeo.geocaching.network.Parameters;
import cgeo.geocaching.utils.Log;

import org.apache.commons.lang3.StringUtils;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import android.net.Uri;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Date;
import java.util.EnumSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.TimeZone;

final public class OkapiClient {

    private static final char SEPARATOR = '|';
    private static final String SEPARATOR_STRING = Character.toString(SEPARATOR);
    private static final SimpleDateFormat logDateFormat;

    static {
        logDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSSZ", Locale.US);
        logDateFormat.setTimeZone(TimeZone.getTimeZone("UTC"));
    }

    private static final String CACHE_ATTRNAMES = "attrnames";
    private static final String WPT_LOCATION = "location";
    private static final String WPT_DESCRIPTION = "description";
    private static final String WPT_TYPE = "type";
    private static final String WPT_NAME = "name";
    private static final String CACHE_IS_WATCHED = "is_watched";
    private static final String CACHE_WPTS = "alt_wpts";
    private static final String CACHE_STATUS_ARCHIVED = "Archived";
    private static final String CACHE_STATUS_DISABLED = "Temporarily unavailable";
    private static final String CACHE_IS_FOUND = "is_found";
    private static final String CACHE_SIZE = "size";
    private static final String CACHE_VOTES = "rating_votes";
    private static final String CACHE_NOTFOUNDS = "notfounds";
    private static final String CACHE_FOUNDS = "founds";
    private static final String CACHE_HIDDEN = "date_hidden";
    private static final String CACHE_LATEST_LOGS = "latest_logs";
    private static final String CACHE_IMAGE_URL = "url";
    private static final String CACHE_IMAGE_CAPTION = "caption";
    private static final String CACHE_IMAGE_IS_SPOILER = "is_spoiler";
    private static final String CACHE_IMAGES = "images";
    private static final String CACHE_HINT = "hint";
    private static final String CACHE_DESCRIPTION = "description";
    private static final String CACHE_RECOMMENDATIONS = "recommendations";
    private static final String CACHE_RATING = "rating";
    private static final String CACHE_TERRAIN = "terrain";
    private static final String CACHE_DIFFICULTY = "difficulty";
    private static final String CACHE_OWNER = "owner";
    private static final String CACHE_STATUS = "status";
    private static final String CACHE_TYPE = "type";
    private static final String CACHE_LOCATION = "location";
    private static final String CACHE_NAME = "name";
    private static final String CACHE_CODE = "code";

    private static final String LOG_TYPE = "type";
    private static final String LOG_COMMENT = "comment";
    private static final String LOG_DATE = "date";
    private static final String LOG_USER = "user";

    private static final String USER_USERNAME = "username";

    // the several realms of possible fields for cache retrieval:
    // Core: for livemap requests (L3 - only with level 3 auth)
    // Additional: additional fields for full cache (L3 - only for level 3 auth, current - only for connectors with current api)
    private static final String SERVICE_CACHE_CORE_FIELDS = "code|name|location|type|status|difficulty|terrain|size";
    private static final String SERVICE_CACHE_CORE_L3_FIELDS = "is_found";
    private static final String SERVICE_CACHE_ADDITIONAL_FIELDS = "owner|founds|notfounds|rating|rating_votes|recommendations|description|hint|images|latest_logs|date_hidden|alt_wpts|attrnames";
    private static final String SERVICE_CACHE_ADDITIONAL_CURRENT_FIELDS = "gc_code|attribution_note";
    private static final String SERVICE_CACHE_ADDITIONAL_L3_FIELDS = "is_watched";

    private static final String METHOD_SEARCH_NEAREST = "services/caches/search/nearest";
    private static final String METHOD_SEARCH_BBOX = "services/caches/search/bbox";
    private static final String METHOD_RETRIEVE_CACHES = "services/caches/geocaches";

    public static Geocache getCache(final String geoCode) {
        final Parameters params = new Parameters("cache_code", geoCode);
        IConnector connector = ConnectorFactory.getConnector(geoCode);
        if (!(connector instanceof OCApiConnector)) {
            return null;
        }

        OCApiConnector ocapiConn = (OCApiConnector) connector;

        params.add("fields", getFullFields(ocapiConn));
        params.add("attribution_append", "none");

        final JSONObject data = request(ocapiConn, OkapiService.SERVICE_CACHE, params);

        if (data == null) {
            return null;
        }

        return parseCache(data);
    }

    // Assumes level 3 OAuth
    public static List<Geocache> getCachesAround(final Geopoint center, OCApiConnector connector) {
        String centerString = GeopointFormatter.format(GeopointFormatter.Format.LAT_DECDEGREE_RAW, center) + SEPARATOR + GeopointFormatter.format(GeopointFormatter.Format.LON_DECDEGREE_RAW, center);
        final Parameters params = new Parameters("search_method", METHOD_SEARCH_NEAREST);
        final Map<String, String> valueMap = new LinkedHashMap<String, String>();
        valueMap.put("center", centerString);
        valueMap.put("limit", "20");

        if (connector.getSupportedAuthLevel() != OAuthLevel.Level3) {
            Log.e("Calling OkapiClient.getCachesAround with wrong connector");
            return Collections.emptyList();
        }

        addFilterParams(valueMap);

        params.add("search_params", new JSONObject(valueMap).toString());

        addRetrieveParams(params, connector);

        final JSONObject data = request(connector, OkapiService.SERVICE_SEARCH_AND_RETRIEVE, params);

        if (data == null) {
            return Collections.emptyList();
        }

        return parseCaches(data);
    }

    // Assumes level 3 OAuth
    public static List<Geocache> getCachesBBox(final Viewport viewport, OCApiConnector connector) {

        if (viewport.getLatitudeSpan() == 0 || viewport.getLongitudeSpan() == 0) {
            return Collections.emptyList();
        }

        String bboxString = GeopointFormatter.format(GeopointFormatter.Format.LAT_DECDEGREE_RAW, viewport.bottomLeft)
                + SEPARATOR + GeopointFormatter.format(GeopointFormatter.Format.LON_DECDEGREE_RAW, viewport.bottomLeft)
                + SEPARATOR + GeopointFormatter.format(GeopointFormatter.Format.LAT_DECDEGREE_RAW, viewport.topRight)
                + SEPARATOR + GeopointFormatter.format(GeopointFormatter.Format.LON_DECDEGREE_RAW, viewport.topRight);
        final Parameters params = new Parameters("search_method", METHOD_SEARCH_BBOX);
        final Map<String, String> valueMap = new LinkedHashMap<String, String>();
        valueMap.put("bbox", bboxString);

        // FIXME Why is this testing level 3? The to be used service is level 1 only.
        if (connector.getSupportedAuthLevel() != OAuthLevel.Level3) {
            Log.e("Calling OkapiClient.getCachesBBox with wrong connector");
            return Collections.emptyList();
        }

        addFilterParams(valueMap);

        params.add("search_params", new JSONObject(valueMap).toString());

        addRetrieveParams(params, connector);

        final JSONObject data = request(connector, OkapiService.SERVICE_SEARCH_AND_RETRIEVE, params);

        if (data == null) {
            return Collections.emptyList();
        }

        return parseCaches(data);
    }

    public static boolean setWatchState(final Geocache cache, final boolean watched, OCApiConnector connector) {
        final Parameters params = new Parameters("cache_code", cache.getGeocode());
        params.add("watched", watched ? "true" : "false");

        final JSONObject data = request(connector, OkapiService.SERVICE_MARK_CACHE, params);

        if (data == null) {
            return false;
        }

        cache.setOnWatchlist(watched);

        return true;
    }

    public static LogResult postLog(final Geocache cache, LogType logType, Calendar date, String log, OCApiConnector connector) {
        final Parameters params = new Parameters("cache_code", cache.getGeocode());
        params.add("logtype", logType.oc_type);
        params.add("comment", log);
        params.add("comment_format", "plaintext");
        params.add("when", logDateFormat.format(date.getTime()));
        if (logType.equals(LogType.NEEDS_MAINTENANCE)) {
            params.add("needs_maintenance", "true");
        }

        final JSONObject data = request(connector, OkapiService.SERVICE_SUBMIT_LOG, params);

        if (data == null) {
            return new LogResult(StatusCode.LOG_POST_ERROR, "");
        }

        try {
            if (data.getBoolean("success")) {
                return new LogResult(StatusCode.NO_ERROR, data.getString("log_uuid"));
            }

            return new LogResult(StatusCode.LOG_POST_ERROR, "");
        } catch (JSONException e) {
            Log.e("OkapiClient.postLog", e);
        }
        return new LogResult(StatusCode.LOG_POST_ERROR, "");
    }

    private static List<Geocache> parseCaches(final JSONObject response) {
        try {
            // Check for empty result
            final String result = response.getString("results");
            if (StringUtils.isBlank(result) || StringUtils.equals(result, "[]")) {
                return Collections.emptyList();
            }

            // Get and iterate result list
            final JSONObject cachesResponse = response.getJSONObject("results");
            if (cachesResponse != null) {
                List<Geocache> caches = new ArrayList<Geocache>(cachesResponse.length());
                @SuppressWarnings("unchecked")
                Iterator<String> keys = cachesResponse.keys();
                while (keys.hasNext()) {
                    String key = keys.next();
                    Geocache cache = parseSmallCache(cachesResponse.getJSONObject(key));
                    if (cache != null) {
                        caches.add(cache);
                    }
                }
                return caches;
            }
        } catch (JSONException e) {
            Log.e("OkapiClient.parseCachesResult", e);
        }
        return Collections.emptyList();
    }

    private static Geocache parseSmallCache(final JSONObject response) {
        final Geocache cache = new Geocache();
        cache.setReliableLatLon(true);
        try {

            parseCoreCache(response, cache);

            cgData.saveCache(cache, EnumSet.of(SaveFlag.SAVE_CACHE));
        } catch (JSONException e) {
            Log.e("OkapiClient.parseSmallCache", e);
        }
        return cache;
    }

    private static Geocache parseCache(final JSONObject response) {
        final Geocache cache = new Geocache();
        cache.setReliableLatLon(true);
        try {

            parseCoreCache(response, cache);

            // not used: url
            final JSONObject owner = response.getJSONObject(CACHE_OWNER);
            cache.setOwnerDisplayName(parseUser(owner));

            cache.getLogCounts().put(LogType.FOUND_IT, response.getInt(CACHE_FOUNDS));
            cache.getLogCounts().put(LogType.DIDNT_FIND_IT, response.getInt(CACHE_NOTFOUNDS));

            if (!response.isNull(CACHE_RATING)) {
                cache.setRating((float) response.getDouble(CACHE_RATING));
            }
            cache.setVotes(response.getInt(CACHE_VOTES));

            cache.setFavoritePoints(response.getInt(CACHE_RECOMMENDATIONS));
            // not used: req_password
            // Prepend gc-link to description if available
            StringBuilder description = new StringBuilder(500);
            if (!response.isNull("gc_code")) {
                String gccode = response.getString("gc_code");
                description.append(cgeoapplication.getInstance().getResources()
                        .getString(R.string.cache_listed_on, GCConnector.getInstance().getName()))
                        .append(": <a href=\"http://coord.info/")
                        .append(gccode)
                        .append("\">")
                        .append(gccode)
                        .append("</a><br /><br />");
            }
            description.append(response.getString(CACHE_DESCRIPTION));
            cache.setDescription(description.toString());

            // currently the hint is delivered as HTML (contrary to OKAPI documentation), so we can store it directly
            cache.setHint(response.getString(CACHE_HINT));
            // not used: hints

            final JSONArray images = response.getJSONArray(CACHE_IMAGES);
            if (images != null) {
                for (int i = 0; i < images.length(); i++) {
                    JSONObject imageResponse = images.getJSONObject(i);
                    if (imageResponse.getBoolean(CACHE_IMAGE_IS_SPOILER)) {
                        final String title = imageResponse.getString(CACHE_IMAGE_CAPTION);
                        final String url = absoluteUrl(imageResponse.getString(CACHE_IMAGE_URL), cache.getGeocode());
                        cache.addSpoiler(new Image(url, title));
                    }
                }
            }

            cache.setAttributes(parseAttributes(response.getJSONArray(CACHE_ATTRNAMES)));
            cache.setLogs(parseLogs(response.getJSONArray(CACHE_LATEST_LOGS)));
            cache.setHidden(parseDate(response.getString(CACHE_HIDDEN)));
            //TODO: Store license per cache
            //cache.setLicense(response.getString("attribution_note"));
            cache.setWaypoints(parseWaypoints(response.getJSONArray(CACHE_WPTS)), false);
            if (!response.isNull(CACHE_IS_WATCHED)) {
                cache.setOnWatchlist(response.getBoolean(CACHE_IS_WATCHED));
            }

            cache.setDetailedUpdatedNow();
            // save full detailed caches
            cgData.saveCache(cache, EnumSet.of(SaveFlag.SAVE_DB));
        } catch (JSONException e) {
            Log.e("OkapiClient.parseCache", e);
        }
        return cache;
    }

    private static void parseCoreCache(final JSONObject response, final Geocache cache) throws JSONException {
        cache.setGeocode(response.getString(CACHE_CODE));
        cache.setName(response.getString(CACHE_NAME));
        // not used: names
        setLocation(cache, response.getString(CACHE_LOCATION));
        cache.setType(getCacheType(response.getString(CACHE_TYPE)));

        final String status = response.getString(CACHE_STATUS);
        cache.setDisabled(status.equalsIgnoreCase(CACHE_STATUS_DISABLED));
        cache.setArchived(status.equalsIgnoreCase(CACHE_STATUS_ARCHIVED));

        cache.setSize(getCacheSize(response));
        cache.setDifficulty((float) response.getDouble(CACHE_DIFFICULTY));
        cache.setTerrain((float) response.getDouble(CACHE_TERRAIN));

        if (!response.isNull(CACHE_IS_FOUND)) {
            cache.setFound(response.getBoolean(CACHE_IS_FOUND));
        }
    }

    private static String absoluteUrl(String url, String geocode) {
        final Uri uri = Uri.parse(url);

        if (!uri.isAbsolute()) {
            final IConnector connector = ConnectorFactory.getConnector(geocode);
            final String host = connector.getHost();
            if (StringUtils.isNotBlank(host)) {
                return "http://" + host + "/" + url;
            }
        }
        return url;
    }

    private static String parseUser(JSONObject user) throws JSONException {
        return user.getString(USER_USERNAME);
    }

    private static List<LogEntry> parseLogs(JSONArray logsJSON) {
        List<LogEntry> result = null;
        for (int i = 0; i < logsJSON.length(); i++) {
            try {
                JSONObject logResponse = logsJSON.getJSONObject(i);
                LogEntry log = new LogEntry(
                        parseUser(logResponse.getJSONObject(LOG_USER)),
                        parseDate(logResponse.getString(LOG_DATE)).getTime(),
                        parseLogType(logResponse.getString(LOG_TYPE)),
                        logResponse.getString(LOG_COMMENT).trim());
                if (result == null) {
                    result = new ArrayList<LogEntry>();
                }
                result.add(log);
            } catch (JSONException e) {
                Log.e("OkapiClient.parseLogs", e);
            }
        }
        return result;
    }

    private static List<Waypoint> parseWaypoints(JSONArray wptsJson) {
        List<Waypoint> result = null;
        for (int i = 0; i < wptsJson.length(); i++) {
            try {
                JSONObject wptResponse = wptsJson.getJSONObject(i);
                Waypoint wpt = new Waypoint(wptResponse.getString(WPT_NAME),
                        parseWptType(wptResponse.getString(WPT_TYPE)),
                        false);
                wpt.setNote(wptResponse.getString(WPT_DESCRIPTION));
                Geopoint pt = parseCoords(wptResponse.getString(WPT_LOCATION));
                if (pt != null) {
                    wpt.setCoords(pt);
                }
                if (result == null) {
                    result = new ArrayList<Waypoint>();
                }
                result.add(wpt);
            } catch (JSONException e) {
                Log.e("OkapiClient.parseWaypoints", e);
            }
        }
        return result;
    }

    private static LogType parseLogType(String logType) {
        if ("Found it".equalsIgnoreCase(logType)) {
            return LogType.FOUND_IT;
        }
        if ("Didn't find it".equalsIgnoreCase(logType)) {
            return LogType.DIDNT_FIND_IT;
        }
        return LogType.NOTE;
    }

    private static WaypointType parseWptType(String wptType) {
        if ("parking".equalsIgnoreCase(wptType)) {
            return WaypointType.PARKING;
        }
        if ("path".equalsIgnoreCase(wptType)) {
            return WaypointType.TRAILHEAD;
        }
        if ("stage".equalsIgnoreCase(wptType)) {
            return WaypointType.STAGE;
        }
        if ("physical-stage".equalsIgnoreCase(wptType)) {
            return WaypointType.STAGE;
        }
        if ("virtual-stage".equalsIgnoreCase(wptType)) {
            return WaypointType.PUZZLE;
        }
        if ("final".equalsIgnoreCase(wptType)) {
            return WaypointType.FINAL;
        }
        if ("poi".equalsIgnoreCase(wptType)) {
            return WaypointType.TRAILHEAD;
        }
        return WaypointType.WAYPOINT;
    }

    private static Date parseDate(final String date) {
        final SimpleDateFormat ISO8601DATEFORMAT = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ", Locale.getDefault());
        final String strippedDate = date.replaceAll("\\+0([0-9]){1}\\:00", "+0$100");
        try {
            return ISO8601DATEFORMAT.parse(strippedDate);
        } catch (ParseException e) {
            Log.e("OkapiClient.parseDate", e);
        }
        return null;
    }

    private static Geopoint parseCoords(final String location) {
        final String latitude = StringUtils.substringBefore(location, SEPARATOR_STRING);
        final String longitude = StringUtils.substringAfter(location, SEPARATOR_STRING);
        if (StringUtils.isNotBlank(latitude) && StringUtils.isNotBlank(longitude)) {
            return new Geopoint(latitude, longitude);
        }

        return null;
    }

    private static List<String> parseAttributes(JSONArray nameList) {

        List<String> result = new ArrayList<String>();

        for (int i = 0; i < nameList.length(); i++) {
            try {
                String name = nameList.getString(i);
                CacheAttribute attr = CacheAttribute.getByOcId(AttributeParser.getOcDeId(name));

                if (attr != null) {
                    result.add(attr.rawName);
                }
            } catch (JSONException e) {
                Log.e("OkapiClient.parseAttributes", e);
            }
        }

        return result;
    }

    private static void setLocation(final Geocache cache, final String location) {
        final String latitude = StringUtils.substringBefore(location, SEPARATOR_STRING);
        final String longitude = StringUtils.substringAfter(location, SEPARATOR_STRING);
        cache.setCoords(new Geopoint(latitude, longitude));
    }

    private static CacheSize getCacheSize(final JSONObject response) {
        if (response.isNull(CACHE_SIZE)) {
            return CacheSize.NOT_CHOSEN;
        }
        double size = 0;
        try {
            size = response.getDouble(CACHE_SIZE);
        } catch (JSONException e) {
            Log.e("OkapiClient.getCacheSize", e);
        }
        switch ((int) Math.round(size)) {
            case 1:
                return CacheSize.MICRO;
            case 2:
                return CacheSize.SMALL;
            case 3:
                return CacheSize.REGULAR;
            case 4:
                return CacheSize.LARGE;
            case 5:
                return CacheSize.LARGE;
            default:
                break;
        }
        return CacheSize.NOT_CHOSEN;
    }

    private static CacheType getCacheType(final String cacheType) {
        if (cacheType.equalsIgnoreCase("Traditional")) {
            return CacheType.TRADITIONAL;
        }
        if (cacheType.equalsIgnoreCase("Multi")) {
            return CacheType.MULTI;
        }
        if (cacheType.equalsIgnoreCase("Quiz")) {
            return CacheType.MYSTERY;
        }
        if (cacheType.equalsIgnoreCase("Virtual")) {
            return CacheType.VIRTUAL;
        }
        if (cacheType.equalsIgnoreCase("Event")) {
            return CacheType.EVENT;
        }
        if (cacheType.equalsIgnoreCase("Webcam")) {
            return CacheType.WEBCAM;
        }
        if (cacheType.equalsIgnoreCase("Math/Physics")) {
            return CacheType.MYSTERY;
        }
        if (cacheType.equalsIgnoreCase("Drive-In")) {
            return CacheType.TRADITIONAL;
        }
        return CacheType.UNKNOWN;
    }

    private static String getCoreFields(OCApiConnector connector) {
        if (connector == null) {
            Log.e("OkapiClient.getCoreFields called with invalid connector");
            return StringUtils.EMPTY;
        }

        if (connector.getSupportedAuthLevel() == OAuthLevel.Level3) {
            return SERVICE_CACHE_CORE_FIELDS + SEPARATOR + SERVICE_CACHE_CORE_L3_FIELDS;
        }

        return SERVICE_CACHE_CORE_FIELDS;
    }

    private static String getFullFields(OCApiConnector connector) {
        if (connector == null) {
            Log.e("OkapiClient.getFullFields called with invalid connector");
            return StringUtils.EMPTY;
        }

        StringBuilder res = new StringBuilder(500);

        res.append(SERVICE_CACHE_CORE_FIELDS);
        res.append(SEPARATOR).append(SERVICE_CACHE_ADDITIONAL_FIELDS);
        if (connector.getSupportedAuthLevel() == OAuthLevel.Level3) {
            res.append(SEPARATOR).append(SERVICE_CACHE_CORE_L3_FIELDS);
            res.append(SEPARATOR).append(SERVICE_CACHE_ADDITIONAL_L3_FIELDS);
        }
        if (connector.getApiSupport() == ApiSupport.current) {
            res.append(SEPARATOR).append(SERVICE_CACHE_ADDITIONAL_CURRENT_FIELDS);
        }

        return res.toString();
    }

    private static JSONObject request(final OCApiConnector connector, final OkapiService service, final Parameters params) {
        if (connector == null) {
            return null;
        }

        final String host = connector.getHost();
        if (StringUtils.isBlank(host)) {
            return null;
        }

        params.add("langpref", getPreferredLanguage());

        if (connector.getSupportedAuthLevel() == OAuthLevel.Level3) {
            OAuth.signOAuth(host, service.methodName, "GET", false, params, Settings.getOCDETokenPublic(), Settings.getOCDETokenSecret(), connector.getCK(), connector.getCS());
        } else {
            connector.addAuthentication(params);
        }

        final String uri = "http://" + host + service.methodName;
        return Network.requestJSON(uri, params);
    }

    private static String getPreferredLanguage() {
        final String code = Locale.getDefault().getCountry();
        if (StringUtils.isNotBlank(code)) {
            return StringUtils.lowerCase(code) + "|en";
        }
        return "en";
    }

    // assumes level 3 oauth
    private static void addFilterParams(final Map<String, String> valueMap) {
        if (!Settings.isExcludeDisabledCaches()) {
            valueMap.put("status", "Available|Temporarily unavailable");
        }
        if (Settings.isExcludeMyCaches()) {
            valueMap.put("exclude_my_own", "true");
            valueMap.put("found_status", "notfound_only");
        }
        if (Settings.getCacheType() != CacheType.ALL) {
            valueMap.put("type", getFilterFromType(Settings.getCacheType()));
        }
    }

    private static void addRetrieveParams(final Parameters params, OCApiConnector connector) {
        params.add("retr_method", METHOD_RETRIEVE_CACHES);
        params.add("retr_params", "{\"fields\": \"" + getCoreFields(connector) + "\"}");
        params.add("wrap", "true");
    }

    private static String getFilterFromType(CacheType cacheType) {
        switch (cacheType) {
            case EVENT:
                return "Event";
            case MULTI:
                return "Multi";
            case MYSTERY:
                return "Quiz";
            case TRADITIONAL:
                return "Traditional";
            case VIRTUAL:
                return "Virtual";
            case WEBCAM:
                return "Webcam";
            default:
                return "";
        }
    }

}
!@#$%
20190527_002208,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_a04972
package cgeo.geocaching.connector.oc;

import cgeo.geocaching.Geocache;
import cgeo.geocaching.Image;
import cgeo.geocaching.LogEntry;
import cgeo.geocaching.R;
import cgeo.geocaching.Settings;
import cgeo.geocaching.Waypoint;
import cgeo.geocaching.cgData;
import cgeo.geocaching.cgeoapplication;
import cgeo.geocaching.connector.ConnectorFactory;
import cgeo.geocaching.connector.IConnector;
import cgeo.geocaching.connector.LogResult;
import cgeo.geocaching.connector.gc.GCConnector;
import cgeo.geocaching.connector.oc.OCApiConnector.ApiSupport;
import cgeo.geocaching.connector.oc.OCApiConnector.OAuthLevel;
import cgeo.geocaching.enumerations.CacheAttribute;
import cgeo.geocaching.enumerations.CacheSize;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.LoadFlags.SaveFlag;
import cgeo.geocaching.enumerations.LogType;
import cgeo.geocaching.enumerations.StatusCode;
import cgeo.geocaching.enumerations.WaypointType;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.geopoint.GeopointFormatter;
import cgeo.geocaching.geopoint.Viewport;
import cgeo.geocaching.network.Network;
import cgeo.geocaching.network.OAuth;
import cgeo.geocaching.network.Parameters;
import cgeo.geocaching.utils.Log;

import org.apache.commons.lang3.StringUtils;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import android.net.Uri;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Date;
import java.util.EnumSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.TimeZone;

final public class OkapiClient {

    private static final char SEPARATOR = '|';
    private static final String SEPARATOR_STRING = Character.toString(SEPARATOR);
    private static final SimpleDateFormat logDateFormat;

    static {
        logDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSSZ", Locale.US);
        logDateFormat.setTimeZone(TimeZone.getTimeZone("UTC"));
    }

    private static final String CACHE_ATTRNAMES = "attrnames";
    private static final String WPT_LOCATION = "location";
    private static final String WPT_DESCRIPTION = "description";
    private static final String WPT_TYPE = "type";
    private static final String WPT_NAME = "name";
    private static final String CACHE_IS_WATCHED = "is_watched";
    private static final String CACHE_WPTS = "alt_wpts";
    private static final String CACHE_STATUS_ARCHIVED = "Archived";
    private static final String CACHE_STATUS_DISABLED = "Temporarily unavailable";
    private static final String CACHE_IS_FOUND = "is_found";
    private static final String CACHE_SIZE = "size";
    private static final String CACHE_VOTES = "rating_votes";
    private static final String CACHE_NOTFOUNDS = "notfounds";
    private static final String CACHE_FOUNDS = "founds";
    private static final String CACHE_HIDDEN = "date_hidden";
    private static final String CACHE_LATEST_LOGS = "latest_logs";
    private static final String CACHE_IMAGE_URL = "url";
    private static final String CACHE_IMAGE_CAPTION = "caption";
    private static final String CACHE_IMAGE_IS_SPOILER = "is_spoiler";
    private static final String CACHE_IMAGES = "images";
    private static final String CACHE_HINT = "hint";
    private static final String CACHE_DESCRIPTION = "description";
    private static final String CACHE_RECOMMENDATIONS = "recommendations";
    private static final String CACHE_RATING = "rating";
    private static final String CACHE_TERRAIN = "terrain";
    private static final String CACHE_DIFFICULTY = "difficulty";
    private static final String CACHE_OWNER = "owner";
    private static final String CACHE_STATUS = "status";
    private static final String CACHE_TYPE = "type";
    private static final String CACHE_LOCATION = "location";
    private static final String CACHE_NAME = "name";
    private static final String CACHE_CODE = "code";

    private static final String LOG_TYPE = "type";
    private static final String LOG_COMMENT = "comment";
    private static final String LOG_DATE = "date";
    private static final String LOG_USER = "user";

    private static final String USER_USERNAME = "username";

    // the several realms of possible fields for cache retrieval:
    // Core: for livemap requests (L3 - only with level 3 auth)
    // Additional: additional fields for full cache (L3 - only for level 3 auth, current - only for connectors with current api)
    private static final String SERVICE_CACHE_CORE_FIELDS = "code|name|location|type|status|difficulty|terrain|size";
    private static final String SERVICE_CACHE_CORE_L3_FIELDS = "is_found";
    private static final String SERVICE_CACHE_ADDITIONAL_FIELDS = "owner|founds|notfounds|rating|rating_votes|recommendations|description|hint|images|latest_logs|date_hidden|alt_wpts|attrnames";
    private static final String SERVICE_CACHE_ADDITIONAL_CURRENT_FIELDS = "gc_code|attribution_note";
    private static final String SERVICE_CACHE_ADDITIONAL_L3_FIELDS = "is_watched";

    private static final String METHOD_SEARCH_NEAREST = "services/caches/search/nearest";
    private static final String METHOD_SEARCH_BBOX = "services/caches/search/bbox";
    private static final String METHOD_RETRIEVE_CACHES = "services/caches/geocaches";

    public static Geocache getCache(final String geoCode) {
        final Parameters params = new Parameters("cache_code", geoCode);
        IConnector connector = ConnectorFactory.getConnector(geoCode);
        if (!(connector instanceof OCApiConnector)) {
            return null;
        }

        OCApiConnector ocapiConn = (OCApiConnector) connector;

        params.add("fields", getFullFields(ocapiConn));
        params.add("attribution_append", "none");

        final JSONObject data = request(ocapiConn, OkapiService.SERVICE_CACHE, params);

        if (data == null) {
            return null;
        }

        return parseCache(data);
    }

    // Assumes level 3 OAuth
    public static List<Geocache> getCachesAround(final Geopoint center, OCApiConnector connector) {
        String centerString = GeopointFormatter.format(GeopointFormatter.Format.LAT_DECDEGREE_RAW, center) + SEPARATOR + GeopointFormatter.format(GeopointFormatter.Format.LON_DECDEGREE_RAW, center);
        final Parameters params = new Parameters("search_method", METHOD_SEARCH_NEAREST);
        final Map<String, String> valueMap = new LinkedHashMap<String, String>();
        valueMap.put("center", centerString);
        valueMap.put("limit", "20");

        if (connector.getSupportedAuthLevel() != OAuthLevel.Level3) {
            Log.e("Calling OkapiClient.getCachesAround with wrong connector");
            return Collections.emptyList();
        }

        addFilterParams(valueMap);

        params.add("search_params", new JSONObject(valueMap).toString());

        addRetrieveParams(params, connector);

        final JSONObject data = request(connector, OkapiService.SERVICE_SEARCH_AND_RETRIEVE, params);

        if (data == null) {
            return Collections.emptyList();
        }

        return parseCaches(data);
    }

    // Assumes level 3 OAuth
    public static List<Geocache> getCachesBBox(final Viewport viewport, OCApiConnector connector) {

        if (viewport.getLatitudeSpan() == 0 || viewport.getLongitudeSpan() == 0) {
            return Collections.emptyList();
        }

        String bboxString = GeopointFormatter.format(GeopointFormatter.Format.LAT_DECDEGREE_RAW, viewport.bottomLeft)
                + SEPARATOR + GeopointFormatter.format(GeopointFormatter.Format.LON_DECDEGREE_RAW, viewport.bottomLeft)
                + SEPARATOR + GeopointFormatter.format(GeopointFormatter.Format.LAT_DECDEGREE_RAW, viewport.topRight)
                + SEPARATOR + GeopointFormatter.format(GeopointFormatter.Format.LON_DECDEGREE_RAW, viewport.topRight);
        final Parameters params = new Parameters("search_method", METHOD_SEARCH_BBOX);
        final Map<String, String> valueMap = new LinkedHashMap<String, String>();
        valueMap.put("bbox", bboxString);

        // FIXME Why is this testing level 3? The to be used service is level 1 only.
        if (connector.getSupportedAuthLevel() != OAuthLevel.Level3) {
            Log.e("Calling OkapiClient.getCachesBBox with wrong connector");
            return Collections.emptyList();
        }

        addFilterParams(valueMap);

        params.add("search_params", new JSONObject(valueMap).toString());

        addRetrieveParams(params, connector);

        final JSONObject data = request(connector, OkapiService.SERVICE_SEARCH_AND_RETRIEVE, params);

        if (data == null) {
            return Collections.emptyList();
        }

        return parseCaches(data);
    }

    public static boolean setWatchState(final Geocache cache, final boolean watched, OCApiConnector connector) {
        final Parameters params = new Parameters("cache_code", cache.getGeocode());
        params.add("watched", watched ? "true" : "false");

        final JSONObject data = request(connector, OkapiService.SERVICE_MARK_CACHE, params);

        if (data == null) {
            return false;
        }

        cache.setOnWatchlist(watched);

        return true;
    }

    public static LogResult postLog(final Geocache cache, LogType logType, Calendar date, String log, OCApiConnector connector) {
        final Parameters params = new Parameters("cache_code", cache.getGeocode());
        params.add("logtype", logType.oc_type);
        params.add("comment", log);
        params.add("comment_format", "plaintext");
        params.add("when", logDateFormat.format(date.getTime()));
        if (logType.equals(LogType.NEEDS_MAINTENANCE)) {
            params.add("needs_maintenance", "true");
        }

        final JSONObject data = request(connector, OkapiService.SERVICE_SUBMIT_LOG, params);

        if (data == null) {
            return new LogResult(StatusCode.LOG_POST_ERROR, "");
        }

        try {
            if (data.getBoolean("success")) {
                return new LogResult(StatusCode.NO_ERROR, data.getString("log_uuid"));
            }

            return new LogResult(StatusCode.LOG_POST_ERROR, "");
        } catch (JSONException e) {
            Log.e("OkapiClient.postLog", e);
        }
        return new LogResult(StatusCode.LOG_POST_ERROR, "");
    }

    private static List<Geocache> parseCaches(final JSONObject response) {
        try {
            // Check for empty result
            final String result = response.getString("results");
            if (StringUtils.isBlank(result) || StringUtils.equals(result, "[]")) {
                return Collections.emptyList();
            }

            // Get and iterate result list
            final JSONObject cachesResponse = response.getJSONObject("results");
            if (cachesResponse != null) {
                List<Geocache> caches = new ArrayList<Geocache>(cachesResponse.length());
                @SuppressWarnings("unchecked")
                Iterator<String> keys = cachesResponse.keys();
                while (keys.hasNext()) {
                    String key = keys.next();
                    Geocache cache = parseSmallCache(cachesResponse.getJSONObject(key));
                    if (cache != null) {
                        caches.add(cache);
                    }
                }
                return caches;
            }
        } catch (JSONException e) {
            Log.e("OkapiClient.parseCachesResult", e);
        }
        return Collections.emptyList();
    }

    private static Geocache parseSmallCache(final JSONObject response) {
        final Geocache cache = new Geocache();
        cache.setReliableLatLon(true);
        try {

            parseCoreCache(response, cache);

            cgData.saveCache(cache, EnumSet.of(SaveFlag.SAVE_CACHE));
        } catch (JSONException e) {
            Log.e("OkapiClient.parseSmallCache", e);
        }
        return cache;
    }

    private static Geocache parseCache(final JSONObject response) {
        final Geocache cache = new Geocache();
        cache.setReliableLatLon(true);
        try {

            parseCoreCache(response, cache);

            // not used: url
            final JSONObject owner = response.getJSONObject(CACHE_OWNER);
            cache.setOwnerDisplayName(parseUser(owner));

            cache.getLogCounts().put(LogType.FOUND_IT, response.getInt(CACHE_FOUNDS));
            cache.getLogCounts().put(LogType.DIDNT_FIND_IT, response.getInt(CACHE_NOTFOUNDS));

            if (!response.isNull(CACHE_RATING)) {
                cache.setRating((float) response.getDouble(CACHE_RATING));
            }
            cache.setVotes(response.getInt(CACHE_VOTES));

            cache.setFavoritePoints(response.getInt(CACHE_RECOMMENDATIONS));
            // not used: req_password
            // Prepend gc-link to description if available
            StringBuilder description = new StringBuilder(500);
            if (!response.isNull("gc_code")) {
                String gccode = response.getString("gc_code");
                description.append(cgeoapplication.getInstance().getResources()
                        .getString(R.string.cache_listed_on, GCConnector.getInstance().getName()))
                        .append(": <a href=\"http://coord.info/")
                        .append(gccode)
                        .append("\">")
                        .append(gccode)
                        .append("</a><br /><br />");
            }
            description.append(response.getString(CACHE_DESCRIPTION));
            cache.setDescription(description.toString());

            cache.setHint(response.getString(CACHE_HINT));
            // not used: hints

            final JSONArray images = response.getJSONArray(CACHE_IMAGES);
            if (images != null) {
                for (int i = 0; i < images.length(); i++) {
                    JSONObject imageResponse = images.getJSONObject(i);
                    if (imageResponse.getBoolean(CACHE_IMAGE_IS_SPOILER)) {
                        final String title = imageResponse.getString(CACHE_IMAGE_CAPTION);
                        final String url = absoluteUrl(imageResponse.getString(CACHE_IMAGE_URL), cache.getGeocode());
                        cache.addSpoiler(new Image(url, title));
                    }
                }
            }

            cache.setAttributes(parseAttributes(response.getJSONArray(CACHE_ATTRNAMES)));
            cache.setLogs(parseLogs(response.getJSONArray(CACHE_LATEST_LOGS)));
            cache.setHidden(parseDate(response.getString(CACHE_HIDDEN)));
            //TODO: Store license per cache
            //cache.setLicense(response.getString("attribution_note"));
            cache.setWaypoints(parseWaypoints(response.getJSONArray(CACHE_WPTS)), false);
            if (!response.isNull(CACHE_IS_WATCHED)) {
                cache.setOnWatchlist(response.getBoolean(CACHE_IS_WATCHED));
            }

            cache.setDetailedUpdatedNow();
            // save full detailed caches
            cgData.saveCache(cache, EnumSet.of(SaveFlag.SAVE_DB));
        } catch (JSONException e) {
            Log.e("OkapiClient.parseCache", e);
        }
        return cache;
    }

    private static void parseCoreCache(final JSONObject response, final Geocache cache) throws JSONException {
        cache.setGeocode(response.getString(CACHE_CODE));
        cache.setName(response.getString(CACHE_NAME));
        // not used: names
        setLocation(cache, response.getString(CACHE_LOCATION));
        cache.setType(getCacheType(response.getString(CACHE_TYPE)));

        final String status = response.getString(CACHE_STATUS);
        cache.setDisabled(status.equalsIgnoreCase(CACHE_STATUS_DISABLED));
        cache.setArchived(status.equalsIgnoreCase(CACHE_STATUS_ARCHIVED));

        cache.setSize(getCacheSize(response));
        cache.setDifficulty((float) response.getDouble(CACHE_DIFFICULTY));
        cache.setTerrain((float) response.getDouble(CACHE_TERRAIN));

        if (!response.isNull(CACHE_IS_FOUND)) {
            cache.setFound(response.getBoolean(CACHE_IS_FOUND));
        }
    }

    private static String absoluteUrl(String url, String geocode) {
        final Uri uri = Uri.parse(url);

        if (!uri.isAbsolute()) {
            final IConnector connector = ConnectorFactory.getConnector(geocode);
            final String host = connector.getHost();
            if (StringUtils.isNotBlank(host)) {
                return "http://" + host + "/" + url;
            }
        }
        return url;
    }

    private static String parseUser(JSONObject user) throws JSONException {
        return user.getString(USER_USERNAME);
    }

    private static List<LogEntry> parseLogs(JSONArray logsJSON) {
        List<LogEntry> result = null;
        for (int i = 0; i < logsJSON.length(); i++) {
            try {
                JSONObject logResponse = logsJSON.getJSONObject(i);
                LogEntry log = new LogEntry(
                        parseUser(logResponse.getJSONObject(LOG_USER)),
                        parseDate(logResponse.getString(LOG_DATE)).getTime(),
                        parseLogType(logResponse.getString(LOG_TYPE)),
                        logResponse.getString(LOG_COMMENT).trim());
                if (result == null) {
                    result = new ArrayList<LogEntry>();
                }
                result.add(log);
            } catch (JSONException e) {
                Log.e("OkapiClient.parseLogs", e);
            }
        }
        return result;
    }

    private static List<Waypoint> parseWaypoints(JSONArray wptsJson) {
        List<Waypoint> result = null;
        for (int i = 0; i < wptsJson.length(); i++) {
            try {
                JSONObject wptResponse = wptsJson.getJSONObject(i);
                Waypoint wpt = new Waypoint(wptResponse.getString(WPT_NAME),
                        parseWptType(wptResponse.getString(WPT_TYPE)),
                        false);
                wpt.setNote(wptResponse.getString(WPT_DESCRIPTION));
                Geopoint pt = parseCoords(wptResponse.getString(WPT_LOCATION));
                if (pt != null) {
                    wpt.setCoords(pt);
                }
                if (result == null) {
                    result = new ArrayList<Waypoint>();
                }
                result.add(wpt);
            } catch (JSONException e) {
                Log.e("OkapiClient.parseWaypoints", e);
            }
        }
        return result;
    }

    private static LogType parseLogType(String logType) {
        if ("Found it".equalsIgnoreCase(logType)) {
            return LogType.FOUND_IT;
        }
        if ("Didn't find it".equalsIgnoreCase(logType)) {
            return LogType.DIDNT_FIND_IT;
        }
        return LogType.NOTE;
    }

    private static WaypointType parseWptType(String wptType) {
        if ("parking".equalsIgnoreCase(wptType)) {
            return WaypointType.PARKING;
        }
        if ("path".equalsIgnoreCase(wptType)) {
            return WaypointType.TRAILHEAD;
        }
        if ("stage".equalsIgnoreCase(wptType)) {
            return WaypointType.STAGE;
        }
        if ("physical-stage".equalsIgnoreCase(wptType)) {
            return WaypointType.STAGE;
        }
        if ("virtual-stage".equalsIgnoreCase(wptType)) {
            return WaypointType.PUZZLE;
        }
        if ("final".equalsIgnoreCase(wptType)) {
            return WaypointType.FINAL;
        }
        if ("poi".equalsIgnoreCase(wptType)) {
            return WaypointType.TRAILHEAD;
        }
        return WaypointType.WAYPOINT;
    }

    private static Date parseDate(final String date) {
        final SimpleDateFormat ISO8601DATEFORMAT = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ", Locale.getDefault());
        final String strippedDate = date.replaceAll("\\+0([0-9]){1}\\:00", "+0$100");
        try {
            return ISO8601DATEFORMAT.parse(strippedDate);
        } catch (ParseException e) {
            Log.e("OkapiClient.parseDate", e);
        }
        return null;
    }

    private static Geopoint parseCoords(final String location) {
        final String latitude = StringUtils.substringBefore(location, SEPARATOR_STRING);
        final String longitude = StringUtils.substringAfter(location, SEPARATOR_STRING);
        if (StringUtils.isNotBlank(latitude) && StringUtils.isNotBlank(longitude)) {
            return new Geopoint(latitude, longitude);
        }

        return null;
    }

    private static List<String> parseAttributes(JSONArray nameList) {

        List<String> result = new ArrayList<String>();

        for (int i = 0; i < nameList.length(); i++) {
            try {
                String name = nameList.getString(i);
                CacheAttribute attr = CacheAttribute.getByOcId(AttributeParser.getOcDeId(name));

                if (attr != null) {
                    result.add(attr.rawName);
                }
            } catch (JSONException e) {
                Log.e("OkapiClient.parseAttributes", e);
            }
        }

        return result;
    }

    private static void setLocation(final Geocache cache, final String location) {
        final String latitude = StringUtils.substringBefore(location, SEPARATOR_STRING);
        final String longitude = StringUtils.substringAfter(location, SEPARATOR_STRING);
        cache.setCoords(new Geopoint(latitude, longitude));
    }

    private static CacheSize getCacheSize(final JSONObject response) {
        if (response.isNull(CACHE_SIZE)) {
            return CacheSize.NOT_CHOSEN;
        }
        double size = 0;
        try {
            size = response.getDouble(CACHE_SIZE);
        } catch (JSONException e) {
            Log.e("OkapiClient.getCacheSize", e);
        }
        switch ((int) Math.round(size)) {
            case 1:
                return CacheSize.MICRO;
            case 2:
                return CacheSize.SMALL;
            case 3:
                return CacheSize.REGULAR;
            case 4:
                return CacheSize.LARGE;
            case 5:
                return CacheSize.LARGE;
            default:
                break;
        }
        return CacheSize.NOT_CHOSEN;
    }

    private static CacheType getCacheType(final String cacheType) {
        if (cacheType.equalsIgnoreCase("Traditional")) {
            return CacheType.TRADITIONAL;
        }
        if (cacheType.equalsIgnoreCase("Multi")) {
            return CacheType.MULTI;
        }
        if (cacheType.equalsIgnoreCase("Quiz")) {
            return CacheType.MYSTERY;
        }
        if (cacheType.equalsIgnoreCase("Virtual")) {
            return CacheType.VIRTUAL;
        }
        if (cacheType.equalsIgnoreCase("Event")) {
            return CacheType.EVENT;
        }
        if (cacheType.equalsIgnoreCase("Webcam")) {
            return CacheType.WEBCAM;
        }
        if (cacheType.equalsIgnoreCase("Math/Physics")) {
            return CacheType.MYSTERY;
        }
        if (cacheType.equalsIgnoreCase("Drive-In")) {
            return CacheType.TRADITIONAL;
        }
        return CacheType.UNKNOWN;
    }

    private static String getCoreFields(OCApiConnector connector) {
        if (connector == null) {
            Log.e("OkapiClient.getCoreFields called with invalid connector");
            return StringUtils.EMPTY;
        }

        if (connector.getSupportedAuthLevel() == OAuthLevel.Level3) {
            return SERVICE_CACHE_CORE_FIELDS + SEPARATOR + SERVICE_CACHE_CORE_L3_FIELDS;
        }

        return SERVICE_CACHE_CORE_FIELDS;
    }

    private static String getFullFields(OCApiConnector connector) {
        if (connector == null) {
            Log.e("OkapiClient.getFullFields called with invalid connector");
            return StringUtils.EMPTY;
        }

        StringBuilder res = new StringBuilder(500);

        res.append(SERVICE_CACHE_CORE_FIELDS);
        res.append(SEPARATOR).append(SERVICE_CACHE_ADDITIONAL_FIELDS);
        if (connector.getSupportedAuthLevel() == OAuthLevel.Level3) {
            res.append(SEPARATOR).append(SERVICE_CACHE_CORE_L3_FIELDS);
            res.append(SEPARATOR).append(SERVICE_CACHE_ADDITIONAL_L3_FIELDS);
        }
        if (connector.getApiSupport() == ApiSupport.current) {
            res.append(SEPARATOR).append(SERVICE_CACHE_ADDITIONAL_CURRENT_FIELDS);
        }

        return res.toString();
    }

    private static JSONObject request(final OCApiConnector connector, final OkapiService service, final Parameters params) {
        if (connector == null) {
            return null;
        }

        final String host = connector.getHost();
        if (StringUtils.isBlank(host)) {
            return null;
        }

        params.add("langpref", getPreferredLanguage());

        if (connector.getSupportedAuthLevel() == OAuthLevel.Level3) {
            OAuth.signOAuth(host, service.methodName, "GET", false, params, Settings.getOCDETokenPublic(), Settings.getOCDETokenSecret(), connector.getCK(), connector.getCS());
        } else {
            connector.addAuthentication(params);
        }

        final String uri = "http://" + host + service.methodName;
        return Network.requestJSON(uri, params);
    }

    private static String getPreferredLanguage() {
        final String code = Locale.getDefault().getCountry();
        if (StringUtils.isNotBlank(code)) {
            return StringUtils.lowerCase(code) + "|en";
        }
        return "en";
    }

    // assumes level 3 oauth
    private static void addFilterParams(final Map<String, String> valueMap) {
        if (!Settings.isExcludeDisabledCaches()) {
            valueMap.put("status", "Available|Temporarily unavailable");
        }
        if (Settings.isExcludeMyCaches()) {
            valueMap.put("exclude_my_own", "true");
            valueMap.put("found_status", "notfound_only");
        }
        if (Settings.getCacheType() != CacheType.ALL) {
            valueMap.put("type", getFilterFromType(Settings.getCacheType()));
        }
    }

    private static void addRetrieveParams(final Parameters params, OCApiConnector connector) {
        params.add("retr_method", METHOD_RETRIEVE_CACHES);
        params.add("retr_params", "{\"fields\": \"" + getCoreFields(connector) + "\"}");
        params.add("wrap", "true");
    }

    private static String getFilterFromType(CacheType cacheType) {
        switch (cacheType) {
            case EVENT:
                return "Event";
            case MULTI:
                return "Multi";
            case MYSTERY:
                return "Quiz";
            case TRADITIONAL:
                return "Traditional";
            case VIRTUAL:
                return "Virtual";
            case WEBCAM:
                return "Webcam";
            default:
                return "";
        }
    }

}
!@#$%
20190527_002208,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_c04972
package cgeo.geocaching.connector.oc;

import cgeo.geocaching.Geocache;
import cgeo.geocaching.Image;
import cgeo.geocaching.LogEntry;
import cgeo.geocaching.R;
import cgeo.geocaching.Settings;
import cgeo.geocaching.Waypoint;
import cgeo.geocaching.cgData;
import cgeo.geocaching.cgeoapplication;
import cgeo.geocaching.connector.ConnectorFactory;
import cgeo.geocaching.connector.IConnector;
import cgeo.geocaching.connector.LogResult;
import cgeo.geocaching.connector.gc.GCConnector;
import cgeo.geocaching.connector.oc.OCApiConnector.ApiSupport;
import cgeo.geocaching.connector.oc.OCApiConnector.OAuthLevel;
import cgeo.geocaching.enumerations.CacheAttribute;
import cgeo.geocaching.enumerations.CacheSize;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.LoadFlags.SaveFlag;
import cgeo.geocaching.enumerations.LogType;
import cgeo.geocaching.enumerations.StatusCode;
import cgeo.geocaching.enumerations.WaypointType;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.geopoint.GeopointFormatter;
import cgeo.geocaching.geopoint.Viewport;
import cgeo.geocaching.network.Network;
import cgeo.geocaching.network.OAuth;
import cgeo.geocaching.network.Parameters;
import cgeo.geocaching.utils.Log;

import org.apache.commons.lang3.StringUtils;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import android.net.Uri;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Date;
import java.util.EnumSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.TimeZone;

final public class OkapiClient {

    private static final char SEPARATOR = '|';
    private static final String SEPARATOR_STRING = Character.toString(SEPARATOR);
    private static final SimpleDateFormat logDateFormat;

    static {
        logDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSSZ", Locale.US);
        logDateFormat.setTimeZone(TimeZone.getTimeZone("UTC"));
    }

    private static final String CACHE_ATTRNAMES = "attrnames";
    private static final String WPT_LOCATION = "location";
    private static final String WPT_DESCRIPTION = "description";
    private static final String WPT_TYPE = "type";
    private static final String WPT_NAME = "name";
    private static final String CACHE_IS_WATCHED = "is_watched";
    private static final String CACHE_WPTS = "alt_wpts";
    private static final String CACHE_STATUS_ARCHIVED = "Archived";
    private static final String CACHE_STATUS_DISABLED = "Temporarily unavailable";
    private static final String CACHE_IS_FOUND = "is_found";
    private static final String CACHE_SIZE = "size";
    private static final String CACHE_VOTES = "rating_votes";
    private static final String CACHE_NOTFOUNDS = "notfounds";
    private static final String CACHE_FOUNDS = "founds";
    private static final String CACHE_HIDDEN = "date_hidden";
    private static final String CACHE_LATEST_LOGS = "latest_logs";
    private static final String CACHE_IMAGE_URL = "url";
    private static final String CACHE_IMAGE_CAPTION = "caption";
    private static final String CACHE_IMAGE_IS_SPOILER = "is_spoiler";
    private static final String CACHE_IMAGES = "images";
    private static final String CACHE_HINT = "hint";
    private static final String CACHE_DESCRIPTION = "description";
    private static final String CACHE_RECOMMENDATIONS = "recommendations";
    private static final String CACHE_RATING = "rating";
    private static final String CACHE_TERRAIN = "terrain";
    private static final String CACHE_DIFFICULTY = "difficulty";
    private static final String CACHE_OWNER = "owner";
    private static final String CACHE_STATUS = "status";
    private static final String CACHE_TYPE = "type";
    private static final String CACHE_LOCATION = "location";
    private static final String CACHE_NAME = "name";
    private static final String CACHE_CODE = "code";

    private static final String LOG_TYPE = "type";
    private static final String LOG_COMMENT = "comment";
    private static final String LOG_DATE = "date";
    private static final String LOG_USER = "user";

    private static final String USER_USERNAME = "username";
    private static final String USER_CACHES_FOUND = "caches_found";
    private static final String USER_INFO_FIELDS = "username|caches_found";

    // the several realms of possible fields for cache retrieval:
    // Core: for livemap requests (L3 - only with level 3 auth)
    // Additional: additional fields for full cache (L3 - only for level 3 auth, current - only for connectors with current api)
    private static final String SERVICE_CACHE_CORE_FIELDS = "code|name|location|type|status|difficulty|terrain|size";
    private static final String SERVICE_CACHE_CORE_L3_FIELDS = "is_found";
    private static final String SERVICE_CACHE_ADDITIONAL_FIELDS = "owner|founds|notfounds|rating|rating_votes|recommendations|description|hint|images|latest_logs|date_hidden|alt_wpts|attrnames";
    private static final String SERVICE_CACHE_ADDITIONAL_CURRENT_FIELDS = "gc_code|attribution_note";
    private static final String SERVICE_CACHE_ADDITIONAL_L3_FIELDS = "is_watched";

    private static final String METHOD_SEARCH_NEAREST = "services/caches/search/nearest";
    private static final String METHOD_SEARCH_BBOX = "services/caches/search/bbox";
    private static final String METHOD_RETRIEVE_CACHES = "services/caches/geocaches";

    public static Geocache getCache(final String geoCode) {
        final Parameters params = new Parameters("cache_code", geoCode);
        IConnector connector = ConnectorFactory.getConnector(geoCode);
        if (!(connector instanceof OCApiConnector)) {
            return null;
        }

        OCApiConnector ocapiConn = (OCApiConnector) connector;

        params.add("fields", getFullFields(ocapiConn));
        params.add("attribution_append", "none");

        final JSONObject data = request(ocapiConn, OkapiService.SERVICE_CACHE, params);

        if (data == null) {
            return null;
        }

        return parseCache(data);
    }

    // Assumes level 3 OAuth
    public static List<Geocache> getCachesAround(final Geopoint center, OCApiConnector connector) {
        String centerString = GeopointFormatter.format(GeopointFormatter.Format.LAT_DECDEGREE_RAW, center) + SEPARATOR + GeopointFormatter.format(GeopointFormatter.Format.LON_DECDEGREE_RAW, center);
        final Parameters params = new Parameters("search_method", METHOD_SEARCH_NEAREST);
        final Map<String, String> valueMap = new LinkedHashMap<String, String>();
        valueMap.put("center", centerString);
        valueMap.put("limit", "20");

        if (connector.getSupportedAuthLevel() != OAuthLevel.Level3) {
            Log.e("Calling OkapiClient.getCachesAround with wrong connector");
            return Collections.emptyList();
        }

        addFilterParams(valueMap);

        params.add("search_params", new JSONObject(valueMap).toString());

        addRetrieveParams(params, connector);

        final JSONObject data = request(connector, OkapiService.SERVICE_SEARCH_AND_RETRIEVE, params);

        if (data == null) {
            return Collections.emptyList();
        }

        return parseCaches(data);
    }

    // Assumes level 3 OAuth
    public static List<Geocache> getCachesBBox(final Viewport viewport, OCApiConnector connector) {

        if (viewport.getLatitudeSpan() == 0 || viewport.getLongitudeSpan() == 0) {
            return Collections.emptyList();
        }

        String bboxString = GeopointFormatter.format(GeopointFormatter.Format.LAT_DECDEGREE_RAW, viewport.bottomLeft)
                + SEPARATOR + GeopointFormatter.format(GeopointFormatter.Format.LON_DECDEGREE_RAW, viewport.bottomLeft)
                + SEPARATOR + GeopointFormatter.format(GeopointFormatter.Format.LAT_DECDEGREE_RAW, viewport.topRight)
                + SEPARATOR + GeopointFormatter.format(GeopointFormatter.Format.LON_DECDEGREE_RAW, viewport.topRight);
        final Parameters params = new Parameters("search_method", METHOD_SEARCH_BBOX);
        final Map<String, String> valueMap = new LinkedHashMap<String, String>();
        valueMap.put("bbox", bboxString);

        // FIXME Why is this testing level 3? The to be used service is level 1 only.
        if (connector.getSupportedAuthLevel() != OAuthLevel.Level3) {
            Log.e("Calling OkapiClient.getCachesBBox with wrong connector");
            return Collections.emptyList();
        }

        addFilterParams(valueMap);

        params.add("search_params", new JSONObject(valueMap).toString());

        addRetrieveParams(params, connector);

        final JSONObject data = request(connector, OkapiService.SERVICE_SEARCH_AND_RETRIEVE, params);

        if (data == null) {
            return Collections.emptyList();
        }

        return parseCaches(data);
    }

    public static boolean setWatchState(final Geocache cache, final boolean watched, OCApiConnector connector) {
        final Parameters params = new Parameters("cache_code", cache.getGeocode());
        params.add("watched", watched ? "true" : "false");

        final JSONObject data = request(connector, OkapiService.SERVICE_MARK_CACHE, params);

        if (data == null) {
            return false;
        }

        cache.setOnWatchlist(watched);

        return true;
    }

    public static LogResult postLog(final Geocache cache, LogType logType, Calendar date, String log, OCApiConnector connector) {
        final Parameters params = new Parameters("cache_code", cache.getGeocode());
        params.add("logtype", logType.oc_type);
        params.add("comment", log);
        params.add("comment_format", "plaintext");
        params.add("when", logDateFormat.format(date.getTime()));
        if (logType.equals(LogType.NEEDS_MAINTENANCE)) {
            params.add("needs_maintenance", "true");
        }

        final JSONObject data = request(connector, OkapiService.SERVICE_SUBMIT_LOG, params);

        if (data == null) {
            return new LogResult(StatusCode.LOG_POST_ERROR, "");
        }

        try {
            if (data.getBoolean("success")) {
                return new LogResult(StatusCode.NO_ERROR, data.getString("log_uuid"));
            }

            return new LogResult(StatusCode.LOG_POST_ERROR, "");
        } catch (JSONException e) {
            Log.e("OkapiClient.postLog", e);
        }
        return new LogResult(StatusCode.LOG_POST_ERROR, "");
    }

    private static List<Geocache> parseCaches(final JSONObject response) {
        try {
            // Check for empty result
            final String result = response.getString("results");
            if (StringUtils.isBlank(result) || StringUtils.equals(result, "[]")) {
                return Collections.emptyList();
            }

            // Get and iterate result list
            final JSONObject cachesResponse = response.getJSONObject("results");
            if (cachesResponse != null) {
                List<Geocache> caches = new ArrayList<Geocache>(cachesResponse.length());
                @SuppressWarnings("unchecked")
                Iterator<String> keys = cachesResponse.keys();
                while (keys.hasNext()) {
                    String key = keys.next();
                    Geocache cache = parseSmallCache(cachesResponse.getJSONObject(key));
                    if (cache != null) {
                        caches.add(cache);
                    }
                }
                return caches;
            }
        } catch (JSONException e) {
            Log.e("OkapiClient.parseCachesResult", e);
        }
        return Collections.emptyList();
    }

    private static Geocache parseSmallCache(final JSONObject response) {
        final Geocache cache = new Geocache();
        cache.setReliableLatLon(true);
        try {

            parseCoreCache(response, cache);

            cgData.saveCache(cache, EnumSet.of(SaveFlag.SAVE_CACHE));
        } catch (JSONException e) {
            Log.e("OkapiClient.parseSmallCache", e);
        }
        return cache;
    }

    private static Geocache parseCache(final JSONObject response) {
        final Geocache cache = new Geocache();
        cache.setReliableLatLon(true);
        try {

            parseCoreCache(response, cache);

            // not used: url
            final JSONObject owner = response.getJSONObject(CACHE_OWNER);
            cache.setOwnerDisplayName(parseUser(owner));

            cache.getLogCounts().put(LogType.FOUND_IT, response.getInt(CACHE_FOUNDS));
            cache.getLogCounts().put(LogType.DIDNT_FIND_IT, response.getInt(CACHE_NOTFOUNDS));

            if (!response.isNull(CACHE_RATING)) {
                cache.setRating((float) response.getDouble(CACHE_RATING));
            }
            cache.setVotes(response.getInt(CACHE_VOTES));

            cache.setFavoritePoints(response.getInt(CACHE_RECOMMENDATIONS));
            // not used: req_password
            // Prepend gc-link to description if available
            StringBuilder description = new StringBuilder(500);
            if (!response.isNull("gc_code")) {
                String gccode = response.getString("gc_code");
                description.append(cgeoapplication.getInstance().getResources()
                        .getString(R.string.cache_listed_on, GCConnector.getInstance().getName()))
                        .append(": <a href=\"http://coord.info/")
                        .append(gccode)
                        .append("\">")
                        .append(gccode)
                        .append("</a><br /><br />");
            }
            description.append(response.getString(CACHE_DESCRIPTION));
            cache.setDescription(description.toString());

            cache.setHint(response.getString(CACHE_HINT));
            // not used: hints

            final JSONArray images = response.getJSONArray(CACHE_IMAGES);
            if (images != null) {
                for (int i = 0; i < images.length(); i++) {
                    JSONObject imageResponse = images.getJSONObject(i);
                    if (imageResponse.getBoolean(CACHE_IMAGE_IS_SPOILER)) {
                        final String title = imageResponse.getString(CACHE_IMAGE_CAPTION);
                        final String url = absoluteUrl(imageResponse.getString(CACHE_IMAGE_URL), cache.getGeocode());
                        cache.addSpoiler(new Image(url, title));
                    }
                }
            }

            cache.setAttributes(parseAttributes(response.getJSONArray(CACHE_ATTRNAMES)));
            cache.setLogs(parseLogs(response.getJSONArray(CACHE_LATEST_LOGS)));
            cache.setHidden(parseDate(response.getString(CACHE_HIDDEN)));
            //TODO: Store license per cache
            //cache.setLicense(response.getString("attribution_note"));
            cache.setWaypoints(parseWaypoints(response.getJSONArray(CACHE_WPTS)), false);
            if (!response.isNull(CACHE_IS_WATCHED)) {
                cache.setOnWatchlist(response.getBoolean(CACHE_IS_WATCHED));
            }

            cache.setDetailedUpdatedNow();
            // save full detailed caches
            cgData.saveCache(cache, EnumSet.of(SaveFlag.SAVE_DB));
        } catch (JSONException e) {
            Log.e("OkapiClient.parseCache", e);
        }
        return cache;
    }

    private static void parseCoreCache(final JSONObject response, final Geocache cache) throws JSONException {
        cache.setGeocode(response.getString(CACHE_CODE));
        cache.setName(response.getString(CACHE_NAME));
        // not used: names
        setLocation(cache, response.getString(CACHE_LOCATION));
        cache.setType(getCacheType(response.getString(CACHE_TYPE)));

        final String status = response.getString(CACHE_STATUS);
        cache.setDisabled(status.equalsIgnoreCase(CACHE_STATUS_DISABLED));
        cache.setArchived(status.equalsIgnoreCase(CACHE_STATUS_ARCHIVED));

        cache.setSize(getCacheSize(response));
        cache.setDifficulty((float) response.getDouble(CACHE_DIFFICULTY));
        cache.setTerrain((float) response.getDouble(CACHE_TERRAIN));

        if (!response.isNull(CACHE_IS_FOUND)) {
            cache.setFound(response.getBoolean(CACHE_IS_FOUND));
        }
    }

    private static String absoluteUrl(String url, String geocode) {
        final Uri uri = Uri.parse(url);

        if (!uri.isAbsolute()) {
            final IConnector connector = ConnectorFactory.getConnector(geocode);
            final String host = connector.getHost();
            if (StringUtils.isNotBlank(host)) {
                return "http://" + host + "/" + url;
            }
        }
        return url;
    }

    private static String parseUser(JSONObject user) throws JSONException {
        return user.getString(USER_USERNAME);
    }

    private static List<LogEntry> parseLogs(JSONArray logsJSON) {
        List<LogEntry> result = null;
        for (int i = 0; i < logsJSON.length(); i++) {
            try {
                JSONObject logResponse = logsJSON.getJSONObject(i);
                LogEntry log = new LogEntry(
                        parseUser(logResponse.getJSONObject(LOG_USER)),
                        parseDate(logResponse.getString(LOG_DATE)).getTime(),
                        parseLogType(logResponse.getString(LOG_TYPE)),
                        logResponse.getString(LOG_COMMENT).trim());
                if (result == null) {
                    result = new ArrayList<LogEntry>();
                }
                result.add(log);
            } catch (JSONException e) {
                Log.e("OkapiClient.parseLogs", e);
            }
        }
        return result;
    }

    private static List<Waypoint> parseWaypoints(JSONArray wptsJson) {
        List<Waypoint> result = null;
        for (int i = 0; i < wptsJson.length(); i++) {
            try {
                JSONObject wptResponse = wptsJson.getJSONObject(i);
                Waypoint wpt = new Waypoint(wptResponse.getString(WPT_NAME),
                        parseWptType(wptResponse.getString(WPT_TYPE)),
                        false);
                wpt.setNote(wptResponse.getString(WPT_DESCRIPTION));
                Geopoint pt = parseCoords(wptResponse.getString(WPT_LOCATION));
                if (pt != null) {
                    wpt.setCoords(pt);
                }
                if (result == null) {
                    result = new ArrayList<Waypoint>();
                }
                result.add(wpt);
            } catch (JSONException e) {
                Log.e("OkapiClient.parseWaypoints", e);
            }
        }
        return result;
    }

    private static LogType parseLogType(String logType) {
        if ("Found it".equalsIgnoreCase(logType)) {
            return LogType.FOUND_IT;
        }
        if ("Didn't find it".equalsIgnoreCase(logType)) {
            return LogType.DIDNT_FIND_IT;
        }
        return LogType.NOTE;
    }

    private static WaypointType parseWptType(String wptType) {
        if ("parking".equalsIgnoreCase(wptType)) {
            return WaypointType.PARKING;
        }
        if ("path".equalsIgnoreCase(wptType)) {
            return WaypointType.TRAILHEAD;
        }
        if ("stage".equalsIgnoreCase(wptType)) {
            return WaypointType.STAGE;
        }
        if ("physical-stage".equalsIgnoreCase(wptType)) {
            return WaypointType.STAGE;
        }
        if ("virtual-stage".equalsIgnoreCase(wptType)) {
            return WaypointType.PUZZLE;
        }
        if ("final".equalsIgnoreCase(wptType)) {
            return WaypointType.FINAL;
        }
        if ("poi".equalsIgnoreCase(wptType)) {
            return WaypointType.TRAILHEAD;
        }
        return WaypointType.WAYPOINT;
    }

    private static Date parseDate(final String date) {
        final SimpleDateFormat ISO8601DATEFORMAT = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ", Locale.getDefault());
        final String strippedDate = date.replaceAll("\\+0([0-9]){1}\\:00", "+0$100");
        try {
            return ISO8601DATEFORMAT.parse(strippedDate);
        } catch (ParseException e) {
            Log.e("OkapiClient.parseDate", e);
        }
        return null;
    }

    private static Geopoint parseCoords(final String location) {
        final String latitude = StringUtils.substringBefore(location, SEPARATOR_STRING);
        final String longitude = StringUtils.substringAfter(location, SEPARATOR_STRING);
        if (StringUtils.isNotBlank(latitude) && StringUtils.isNotBlank(longitude)) {
            return new Geopoint(latitude, longitude);
        }

        return null;
    }

    private static List<String> parseAttributes(JSONArray nameList) {

        List<String> result = new ArrayList<String>();

        for (int i = 0; i < nameList.length(); i++) {
            try {
                String name = nameList.getString(i);
                CacheAttribute attr = CacheAttribute.getByOcId(AttributeParser.getOcDeId(name));

                if (attr != null) {
                    result.add(attr.rawName);
                }
            } catch (JSONException e) {
                Log.e("OkapiClient.parseAttributes", e);
            }
        }

        return result;
    }

    private static void setLocation(final Geocache cache, final String location) {
        final String latitude = StringUtils.substringBefore(location, SEPARATOR_STRING);
        final String longitude = StringUtils.substringAfter(location, SEPARATOR_STRING);
        cache.setCoords(new Geopoint(latitude, longitude));
    }

    private static CacheSize getCacheSize(final JSONObject response) {
        if (response.isNull(CACHE_SIZE)) {
            return CacheSize.NOT_CHOSEN;
        }
        double size = 0;
        try {
            size = response.getDouble(CACHE_SIZE);
        } catch (JSONException e) {
            Log.e("OkapiClient.getCacheSize", e);
        }
        switch ((int) Math.round(size)) {
            case 1:
                return CacheSize.MICRO;
            case 2:
                return CacheSize.SMALL;
            case 3:
                return CacheSize.REGULAR;
            case 4:
                return CacheSize.LARGE;
            case 5:
                return CacheSize.LARGE;
            default:
                break;
        }
        return CacheSize.NOT_CHOSEN;
    }

    private static CacheType getCacheType(final String cacheType) {
        if (cacheType.equalsIgnoreCase("Traditional")) {
            return CacheType.TRADITIONAL;
        }
        if (cacheType.equalsIgnoreCase("Multi")) {
            return CacheType.MULTI;
        }
        if (cacheType.equalsIgnoreCase("Quiz")) {
            return CacheType.MYSTERY;
        }
        if (cacheType.equalsIgnoreCase("Virtual")) {
            return CacheType.VIRTUAL;
        }
        if (cacheType.equalsIgnoreCase("Event")) {
            return CacheType.EVENT;
        }
        if (cacheType.equalsIgnoreCase("Webcam")) {
            return CacheType.WEBCAM;
        }
        if (cacheType.equalsIgnoreCase("Math/Physics")) {
            return CacheType.MYSTERY;
        }
        if (cacheType.equalsIgnoreCase("Drive-In")) {
            return CacheType.TRADITIONAL;
        }
        return CacheType.UNKNOWN;
    }

    private static String getCoreFields(OCApiConnector connector) {
        if (connector == null) {
            Log.e("OkapiClient.getCoreFields called with invalid connector");
            return StringUtils.EMPTY;
        }

        if (connector.getSupportedAuthLevel() == OAuthLevel.Level3) {
            return SERVICE_CACHE_CORE_FIELDS + SEPARATOR + SERVICE_CACHE_CORE_L3_FIELDS;
        }

        return SERVICE_CACHE_CORE_FIELDS;
    }

    private static String getFullFields(OCApiConnector connector) {
        if (connector == null) {
            Log.e("OkapiClient.getFullFields called with invalid connector");
            return StringUtils.EMPTY;
        }

        StringBuilder res = new StringBuilder(500);

        res.append(SERVICE_CACHE_CORE_FIELDS);
        res.append(SEPARATOR).append(SERVICE_CACHE_ADDITIONAL_FIELDS);
        if (connector.getSupportedAuthLevel() == OAuthLevel.Level3) {
            res.append(SEPARATOR).append(SERVICE_CACHE_CORE_L3_FIELDS);
            res.append(SEPARATOR).append(SERVICE_CACHE_ADDITIONAL_L3_FIELDS);
        }
        if (connector.getApiSupport() == ApiSupport.current) {
            res.append(SEPARATOR).append(SERVICE_CACHE_ADDITIONAL_CURRENT_FIELDS);
        }

        return res.toString();
    }

    private static JSONObject request(final OCApiConnector connector, final OkapiService service, final Parameters params) {
        if (connector == null) {
            return null;
        }

        final String host = connector.getHost();
        if (StringUtils.isBlank(host)) {
            return null;
        }

        params.add("langpref", getPreferredLanguage());

        if (connector.getSupportedAuthLevel() == OAuthLevel.Level3) {
            OAuth.signOAuth(host, service.methodName, "GET", false, params, Settings.getOCDETokenPublic(), Settings.getOCDETokenSecret(), connector.getCK(), connector.getCS());
        } else {
            connector.addAuthentication(params);
        }

        final String uri = "http://" + host + service.methodName;
        return Network.requestJSON(uri, params);
    }

    private static String getPreferredLanguage() {
        final String code = Locale.getDefault().getCountry();
        if (StringUtils.isNotBlank(code)) {
            return StringUtils.lowerCase(code) + "|en";
        }
        return "en";
    }

    // assumes level 3 oauth
    private static void addFilterParams(final Map<String, String> valueMap) {
        if (!Settings.isExcludeDisabledCaches()) {
            valueMap.put("status", "Available|Temporarily unavailable");
        }
        if (Settings.isExcludeMyCaches()) {
            valueMap.put("exclude_my_own", "true");
            valueMap.put("found_status", "notfound_only");
        }
        if (Settings.getCacheType() != CacheType.ALL) {
            valueMap.put("type", getFilterFromType(Settings.getCacheType()));
        }
    }

    private static void addRetrieveParams(final Parameters params, OCApiConnector connector) {
        params.add("retr_method", METHOD_RETRIEVE_CACHES);
        params.add("retr_params", "{\"fields\": \"" + getCoreFields(connector) + "\"}");
        params.add("wrap", "true");
    }

    private static String getFilterFromType(CacheType cacheType) {
        switch (cacheType) {
            case EVENT:
                return "Event";
            case MULTI:
                return "Multi";
            case MYSTERY:
                return "Quiz";
            case TRADITIONAL:
                return "Traditional";
            case VIRTUAL:
                return "Virtual";
            case WEBCAM:
                return "Webcam";
            default:
                return "";
        }
    }

    public static UserInfo getUserInfo(OCApiLiveConnector connector) {
        final Parameters params = new Parameters("fields", USER_INFO_FIELDS);

        final JSONObject data = request(connector, OkapiService.SERVICE_USER, params);

        if (data == null) {
            return new UserInfo(StringUtils.EMPTY, 0, false);
        }

        String name = StringUtils.EMPTY;
        int finds = 0;
        boolean success = true;

        if (!data.isNull(USER_USERNAME)) {
            try {
                name = data.getString(USER_USERNAME);
            } catch (JSONException e) {
                Log.e("OkapiClient.getUserInfo - name", e);
                success = false;
            }
        } else {
            success = false;
        }

        if (!data.isNull(USER_CACHES_FOUND)) {
            try {
                finds = data.getInt(USER_CACHES_FOUND);
            } catch (JSONException e) {
                Log.e("OkapiClient.getUserInfo - finds", e);
                success = false;
            }
        } else {
            success = false;
        }

        return new UserInfo(name, finds, success);
    }

    public static class UserInfo {

        private final String name;
        private final int finds;
        private final boolean retrieveSuccessful;

        UserInfo(String name, int finds, boolean retrieveSuccessful) {
            this.name = name;
            this.finds = finds;
            this.retrieveSuccessful = retrieveSuccessful;
        }

        public String getName() {
            return name;
        }

        public int getFinds() {
            return finds;
        }

        public boolean isRetrieveSuccessful() {
            return retrieveSuccessful;
        }
    }

}
!@#$%
20190527_002501,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_b20648
package cgeo.geocaching.settings;

import cgeo.geocaching.R;
import cgeo.geocaching.StoredList;
import cgeo.geocaching.cgeoapplication;
import cgeo.geocaching.apps.cache.navi.NavigationAppFactory.NavigationAppsEnum;
import cgeo.geocaching.connector.gc.GCConstants;
import cgeo.geocaching.connector.gc.Login;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.LiveMapStrategy.Strategy;
import cgeo.geocaching.enumerations.LogType;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.maps.MapProviderFactory;
import cgeo.geocaching.maps.google.GoogleMapProvider;
import cgeo.geocaching.maps.interfaces.GeoPointImpl;
import cgeo.geocaching.maps.interfaces.MapProvider;
import cgeo.geocaching.maps.interfaces.MapSource;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider.OfflineMapSource;
import cgeo.geocaching.utils.CryptUtils;
import cgeo.geocaching.utils.FileUtils;
import cgeo.geocaching.utils.FileUtils.FileSelector;
import cgeo.geocaching.utils.Log;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.os.Environment;
import android.preference.PreferenceManager;

import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

/**
 * General c:geo preferences/settings set by the user
 */
public final class Settings {

    public static final int SHOW_WP_THRESHOLD_DEFAULT = 10;
    public static final int SHOW_WP_THRESHOLD_MAX = 50;
    private static final int MAP_SOURCE_DEFAULT = GoogleMapProvider.GOOGLE_MAP_ID.hashCode();

    private final static int unitsMetric = 1;

    // twitter api keys
    private final static String keyConsumerPublic = CryptUtils.rot13("ESnsCvAv3kEupF1GCR3jGj");
    private final static String keyConsumerSecret = CryptUtils.rot13("7vQWceACV9umEjJucmlpFe9FCMZSeqIqfkQ2BnhV9x");

    public enum CoordInputFormatEnum {
        Plain,
        Deg,
        Min,
        Sec;

        public static CoordInputFormatEnum fromInt(int id) {
            final CoordInputFormatEnum[] values = CoordInputFormatEnum.values();
            if (id < 0 || id >= values.length) {
                return Min;
            }
            return values[id];
        }
    }

    private static final SharedPreferences sharedPrefs = PreferenceManager
            .getDefaultSharedPreferences(cgeoapplication.getInstance().getBaseContext());
    static {
        migrateSettings();
        Log.setDebug(sharedPrefs.getBoolean(getKey(R.string.pref_debug), false));
    }

    /**
     * Cache the mapsource locally. If that is an offline map source, each request would potentially access the
     * underlying map file, leading to delays.
     */
    private static MapSource mapSource;

    private Settings() {
        // this class is not to be instantiated;
    }

    private static void migrateSettings() {
        // migrate from non standard file location and integer based boolean types
        int oldVersion = getInt(R.string.pref_settingsversion, 0);
        if (oldVersion < 1) {
            final String oldPreferencesName = "cgeo.pref";
            final SharedPreferences old = cgeoapplication.getInstance().getSharedPreferences(oldPreferencesName, Context.MODE_PRIVATE);
            final Editor e = sharedPrefs.edit();

            e.putString(getKey(R.string.pref_temp_twitter_token_secret), old.getString(getKey(R.string.pref_temp_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_temp_twitter_token_public), old.getString(getKey(R.string.pref_temp_twitter_token_public), null));
            e.putBoolean(getKey(R.string.pref_help_shown), old.getInt(getKey(R.string.pref_help_shown), 0) != 0);
            e.putFloat(getKey(R.string.pref_anylongitude), old.getFloat(getKey(R.string.pref_anylongitude), 0));
            e.putFloat(getKey(R.string.pref_anylatitude), old.getFloat(getKey(R.string.pref_anylatitude), 0));
            e.putBoolean(getKey(R.string.pref_offlinemaps), 0 != old.getInt(getKey(R.string.pref_offlinemaps), 1));
            e.putBoolean(getKey(R.string.pref_offlinewpmaps), 0 != old.getInt(getKey(R.string.pref_offlinewpmaps), 0));
            e.putString(getKey(R.string.pref_webDeviceCode), old.getString(getKey(R.string.pref_webDeviceCode), null));
            e.putString(getKey(R.string.pref_webDeviceName), old.getString(getKey(R.string.pref_webDeviceName), null));
            e.putBoolean(getKey(R.string.pref_maplive), old.getInt(getKey(R.string.pref_maplive), 1) != 0);
            e.putInt(getKey(R.string.pref_mapsource), old.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT));
            e.putBoolean(getKey(R.string.pref_twitter), 0 != old.getInt(getKey(R.string.pref_twitter), 0));
            e.putBoolean(getKey(R.string.pref_showaddress), 0 != old.getInt(getKey(R.string.pref_showaddress), 1));
            e.putBoolean(getKey(R.string.pref_showcaptcha), old.getBoolean(getKey(R.string.pref_showcaptcha), false));
            e.putBoolean(getKey(R.string.pref_maptrail), old.getInt(getKey(R.string.pref_maptrail), 1) != 0);
            e.putInt(getKey(R.string.pref_lastmapzoom), old.getInt(getKey(R.string.pref_lastmapzoom), 14));
            e.putBoolean(getKey(R.string.pref_livelist), 0 != old.getInt(getKey(R.string.pref_livelist), 1));
            e.putBoolean(getKey(R.string.pref_units), old.getInt(getKey(R.string.pref_units), unitsMetric) == unitsMetric);
            e.putBoolean(getKey(R.string.pref_skin), old.getInt(getKey(R.string.pref_skin), 0) != 0);
            e.putInt(getKey(R.string.pref_lastusedlist), old.getInt(getKey(R.string.pref_lastusedlist), StoredList.STANDARD_LIST_ID));
            e.putString(getKey(R.string.pref_cachetype), old.getString(getKey(R.string.pref_cachetype), CacheType.ALL.id));
            e.putString(getKey(R.string.pref_twitter_token_secret), old.getString(getKey(R.string.pref_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_twitter_token_public), old.getString(getKey(R.string.pref_twitter_token_public), null));
            e.putInt(getKey(R.string.pref_version), old.getInt(getKey(R.string.pref_version), 0));
            e.putBoolean(getKey(R.string.pref_autoloaddesc), 0 != old.getInt(getKey(R.string.pref_autoloaddesc), 1));
            e.putBoolean(getKey(R.string.pref_ratingwanted), old.getBoolean(getKey(R.string.pref_ratingwanted), true));
            e.putBoolean(getKey(R.string.pref_friendlogswanted), old.getBoolean(getKey(R.string.pref_friendlogswanted), true));
            e.putBoolean(getKey(R.string.pref_useenglish), old.getBoolean(getKey(R.string.pref_useenglish), false));
            e.putBoolean(getKey(R.string.pref_usecompass), 0 != old.getInt(getKey(R.string.pref_usecompass), 1));
            e.putBoolean(getKey(R.string.pref_trackautovisit), old.getBoolean(getKey(R.string.pref_trackautovisit), false));
            e.putBoolean(getKey(R.string.pref_sigautoinsert), old.getBoolean(getKey(R.string.pref_sigautoinsert), false));
            e.putBoolean(getKey(R.string.pref_logimages), old.getBoolean(getKey(R.string.pref_logimages), false));
            e.putBoolean(getKey(R.string.pref_excludedisabled), 0 != old.getInt(getKey(R.string.pref_excludedisabled), 0));
            e.putBoolean(getKey(R.string.pref_excludemine), 0 != old.getInt(getKey(R.string.pref_excludemine), 0));
            e.putString(getKey(R.string.pref_mapfile), old.getString(getKey(R.string.pref_mapfile), null));
            e.putString(getKey(R.string.pref_signature), old.getString(getKey(R.string.pref_signature), null));
            e.putString(getKey(R.string.pref_pass_vote), old.getString(getKey(R.string.pref_pass_vote), null));
            e.putString(getKey(R.string.pref_password), old.getString(getKey(R.string.pref_password), null));
            e.putString(getKey(R.string.pref_username), old.getString(getKey(R.string.pref_username), null));
            e.putString(getKey(R.string.pref_memberstatus), old.getString(getKey(R.string.pref_memberstatus), ""));
            e.putInt(getKey(R.string.pref_coordinputformat), old.getInt(getKey(R.string.pref_coordinputformat), 0));
            e.putBoolean(getKey(R.string.pref_log_offline), old.getBoolean(getKey(R.string.pref_log_offline), false));
            e.putBoolean(getKey(R.string.pref_choose_list), old.getBoolean(getKey(R.string.pref_choose_list), true));
            e.putBoolean(getKey(R.string.pref_loaddirectionimg), old.getBoolean(getKey(R.string.pref_loaddirectionimg), true));
            e.putString(getKey(R.string.pref_gccustomdate), old.getString(getKey(R.string.pref_gccustomdate), null));
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), old.getInt(getKey(R.string.pref_showwaypointsthreshold), SHOW_WP_THRESHOLD_DEFAULT));
            e.putString(getKey(R.string.pref_cookiestore), old.getString(getKey(R.string.pref_cookiestore), null));
            e.putBoolean(getKey(R.string.pref_opendetailslastpage), old.getBoolean(getKey(R.string.pref_opendetailslastpage), false));
            e.putInt(getKey(R.string.pref_lastdetailspage), old.getInt(getKey(R.string.pref_lastdetailspage), 1));
            e.putInt(getKey(R.string.pref_defaultNavigationTool), old.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id));
            e.putInt(getKey(R.string.pref_defaultNavigationTool2), old.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id));
            e.putInt(getKey(R.string.pref_livemapstrategy), old.getInt(getKey(R.string.pref_livemapstrategy), Strategy.AUTO.id));
            e.putBoolean(getKey(R.string.pref_debug), old.getBoolean(getKey(R.string.pref_debug), false));
            e.putBoolean(getKey(R.string.pref_hidelivemaphint), old.getInt(getKey(R.string.pref_hidelivemaphint), 0) != 0);
            e.putInt(getKey(R.string.pref_livemaphintshowcount), old.getInt(getKey(R.string.pref_livemaphintshowcount), 0));

            e.putInt(getKey(R.string.pref_settingsversion), 1); // mark migrated
            e.commit();
        }

        // changes for new settings dialog
        if (oldVersion < 2) {
            final Editor e = sharedPrefs.edit();

            e.putBoolean(getKey(R.string.pref_units), !isUseImperialUnits());

            // show waypoints threshold now as a slider
            int wpThreshold = getWayPointsThreshold();
            if (wpThreshold < 0) {
                wpThreshold = 0;
            } else if (wpThreshold > SHOW_WP_THRESHOLD_MAX) {
                wpThreshold = SHOW_WP_THRESHOLD_MAX;
            }
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), wpThreshold);

            // KEY_MAP_SOURCE must be string, because it is the key for a ListPreference now
            int ms = sharedPrefs.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT);
            e.remove(getKey(R.string.pref_mapsource));
            e.putString(getKey(R.string.pref_mapsource), String.valueOf(ms));

            // navigation tool ids must be string, because ListPreference uses strings as keys
            int dnt1 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id);
            int dnt2 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id);
            e.remove(getKey(R.string.pref_defaultNavigationTool));
            e.remove(getKey(R.string.pref_defaultNavigationTool2));
            e.putString(getKey(R.string.pref_defaultNavigationTool), String.valueOf(dnt1));
            e.putString(getKey(R.string.pref_defaultNavigationTool2), String.valueOf(dnt2));

            // defaults for gpx directories
            e.putString(getKey(R.string.pref_gpxImportDir), getGpxImportDir());
            e.putString(getKey(R.string.pref_gpxExportDir), getGpxExportDir());

            e.putInt(getKey(R.string.pref_settingsversion), 2); // mark migrated
            e.commit();
        }
    }

    private static String getKey(final int prefKeyId) {
        return cgeoapplication.getInstance().getString(prefKeyId);
    }

    static String getString(final int prefKeyId, final String defaultValue) {
        return sharedPrefs.getString(getKey(prefKeyId), defaultValue);
    }

    private static int getInt(final int prefKeyId, final int defaultValue) {
        return sharedPrefs.getInt(getKey(prefKeyId), defaultValue);
    }

    private static long getLong(final int prefKeyId, final long defaultValue) {
        return sharedPrefs.getLong(getKey(prefKeyId), defaultValue);
    }

    private static boolean getBoolean(final int prefKeyId, final boolean defaultValue) {
        return sharedPrefs.getBoolean(getKey(prefKeyId), defaultValue);
    }

    private static float getFloat(final int prefKeyId, final float defaultValue) {
        return sharedPrefs.getFloat(getKey(prefKeyId), defaultValue);
    }

    static boolean putString(final int prefKeyId, final String value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putString(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putBoolean(final int prefKeyId, final boolean value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putBoolean(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putInt(final int prefKeyId, final int value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putInt(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putLong(final int prefKeyId, final long value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putLong(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putFloat(final int prefKeyId, final float value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putFloat(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean remove(final int prefKeyId) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.remove(getKey(prefKeyId));
        return edit.commit();
    }

    private static boolean contains(final int prefKeyId) {
        return sharedPrefs.contains(getKey(prefKeyId));
    }

    public static void setLanguage(boolean useEnglish) {
        final Configuration config = new Configuration();
        config.locale = useEnglish ? Locale.ENGLISH : Locale.getDefault();
        final Resources resources = cgeoapplication.getInstance().getResources();
        resources.updateConfiguration(config, resources.getDisplayMetrics());
    }

    public static boolean isLogin() {
        final String preUsername = getString(R.string.pref_username, null);
        final String prePassword = getString(R.string.pref_password, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    /**
     * Get login and password information.
     *
     * @return a pair either with (login, password) or (empty, empty) if no valid information is stored
     */
    public static ImmutablePair<String, String> getGcLogin() {

        final String username = getString(R.string.pref_username, null);
        final String password = getString(R.string.pref_password, null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return new ImmutablePair<String, String>(StringUtils.EMPTY, StringUtils.EMPTY);
        }

        return new ImmutablePair<String, String>(username, password);
    }

    public static String getUsername() {
        return getString(R.string.pref_username, null);
    }

    public static boolean isGCConnectorActive() {
        return getBoolean(R.string.pref_connectorGCActive, true);
    }

    public static boolean isPremiumMember() {
        // Basic Member, Premium Member, ???
        String memberStatus = Settings.getMemberStatus();
        if (memberStatus == null) {
            return false;
        }
        return GCConstants.MEMBER_STATUS_PM.equalsIgnoreCase(memberStatus);
    }

    public static String getMemberStatus() {
        return getString(R.string.pref_memberstatus, "");
    }

    public static boolean setMemberStatus(final String memberStatus) {
        if (StringUtils.isBlank(memberStatus)) {
            return remove(R.string.pref_memberstatus);
        }
        return putString(R.string.pref_memberstatus, memberStatus);
    }

    public static boolean isOCConnectorActive() {
        return getBoolean(R.string.pref_connectorOCActive, false);
    }

    public static boolean setOCConnectorActive(final boolean isActive) {
        return putBoolean(R.string.pref_connectorOCActive, isActive);
    }

    public static String getOCDETokenPublic() {
        return getString(R.string.pref_ocde_tokenpublic, "");
    }

    public static String getOCDETokenSecret() {
        return getString(R.string.pref_ocde_tokensecret, "");
    }

    public static boolean hasOCDEAuthorization() {
        return StringUtils.isNotBlank(getOCDETokenPublic())
                && StringUtils.isNotBlank(getOCDETokenSecret());
    }

    public static void setOCDETokens(final String tokenPublic,
            final String tokenSecret, boolean enableOcDe) {
        putString(R.string.pref_ocde_tokenpublic, tokenPublic);
        putString(R.string.pref_ocde_tokensecret, tokenSecret);
        if (tokenPublic != null) {
            remove(R.string.pref_temp_ocde_token_public);
            remove(R.string.pref_temp_ocde_token_secret);
        }
        setOCConnectorActive(enableOcDe);
    }

    public static void setOCDETempTokens(final String tokenPublic, final String tokenSecret) {
        putString(R.string.pref_temp_ocde_token_public, tokenPublic);
        putString(R.string.pref_temp_ocde_token_secret, tokenSecret);
    }

    public static ImmutablePair<String, String> getTempOCDEToken() {
        String tokenPublic = getString(R.string.pref_temp_ocde_token_public, null);
        String tokenSecret = getString(R.string.pref_temp_ocde_token_secret, null);
        return new ImmutablePair<String, String>(tokenPublic, tokenSecret);
    }

    public static boolean isGCvoteLogin() {
        final String preUsername = getString(R.string.pref_username, null);
        final String prePassword = getString(R.string.pref_pass_vote, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    public static ImmutablePair<String, String> getGCvoteLogin() {
        final String username = getString(R.string.pref_username, null);
        final String password = getString(R.string.pref_pass_vote, null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return null;
        }

        return new ImmutablePair<String, String>(username, password);
    }

    public static String getSignature() {
        return getString(R.string.pref_signature, null);
    }

    public static boolean setCookieStore(final String cookies) {
        if (StringUtils.isBlank(cookies)) {
            // erase cookies
            return remove(R.string.pref_cookiestore);
        }
        // save cookies
        return putString(R.string.pref_cookiestore, cookies);
    }

    public static String getCookieStore() {
        return getString(R.string.pref_cookiestore, null);
    }

    /**
     * @param cacheType
     *            The cache type used for future filtering
     */
    public static void setCacheType(final CacheType cacheType) {
        if (cacheType == null) {
            remove(R.string.pref_cachetype);
        } else {
            putString(R.string.pref_cachetype, cacheType.id);
        }
    }

    public static int getLastList() {
        return getInt(R.string.pref_lastusedlist, StoredList.STANDARD_LIST_ID);
    }

    public static void saveLastList(final int listId) {
        putInt(R.string.pref_lastusedlist, listId);
    }

    public static void setWebNameCode(final String name, final String code) {
        putString(R.string.pref_webDeviceName, name);
        putString(R.string.pref_webDeviceCode, code);
    }

    public static MapProvider getMapProvider() {
        return getMapSource().getMapProvider();
    }

    public static String getMapFile() {
        return getString(R.string.pref_mapfile, null);
    }

    public static boolean setMapFile(final String mapFile) {
        boolean result = putString(R.string.pref_mapfile, mapFile);
        if (mapFile != null) {
            setMapFileDirectory(new File(mapFile).getParent());
        }
        return result;
    }

    public static String getMapFileDirectory() {
        final String mapDir = getString(R.string.pref_mapDirectory, null);
        if (mapDir != null) {
            return mapDir;
        }
        final String mapFile = getMapFile();
        if (mapFile != null) {
            return new File(mapFile).getParent();
        }
        return null;
    }

    public static boolean setMapFileDirectory(final String mapFileDirectory) {
        boolean result = putString(R.string.pref_mapDirectory, mapFileDirectory);
        MapsforgeMapProvider.getInstance().updateOfflineMaps();
        return result;
    }

    public static boolean isValidMapFile() {
        return isValidMapFile(getMapFile());
    }

    public static boolean isValidMapFile(final String mapFileIn) {
        return MapsforgeMapProvider.isValidMapFile(mapFileIn);
    }

    public static CoordInputFormatEnum getCoordInputFormat() {
        return CoordInputFormatEnum.fromInt(getInt(R.string.pref_coordinputformat, 0));
    }

    public static void setCoordInputFormat(final CoordInputFormatEnum format) {
        putInt(R.string.pref_coordinputformat, format.ordinal());
    }

    static void setLogOffline(final boolean offline) {
        putBoolean(R.string.pref_log_offline, offline);
    }

    public static boolean getLogOffline() {
        return getBoolean(R.string.pref_log_offline, false);
    }

    public static boolean getChooseList() {
        return getBoolean(R.string.pref_choose_list, false);
    }

    public static boolean getLoadDirImg() {
        return !isPremiumMember() && getBoolean(R.string.pref_loaddirectionimg, true);
    }

    public static void setGcCustomDate(final String format) {
        putString(R.string.pref_gccustomdate, format);
    }

    /**
     * @return User selected date format on GC.com
     * @see Login#gcCustomDateFormats
     */
    public static String getGcCustomDate() {
        return getString(R.string.pref_gccustomdate, null);
    }

    public static boolean isExcludeMyCaches() {
        return getBoolean(R.string.pref_excludemine, false);
    }

    public static void setUseEnglish(final boolean english) {
        putBoolean(R.string.pref_useenglish, english);
        setLanguage(english);
    }

    public static boolean isUseEnglish() {
        return getBoolean(R.string.pref_useenglish, false);
    }

    public static boolean isShowAddress() {
        return getBoolean(R.string.pref_showaddress, true);
    }

    public static boolean isShowCaptcha() {
        return !isPremiumMember() && getBoolean(R.string.pref_showcaptcha, false);
    }

    public static boolean isExcludeDisabledCaches() {
        return getBoolean(R.string.pref_excludedisabled, false);
    }

    public static boolean isStoreOfflineMaps() {
        return getBoolean(R.string.pref_offlinemaps, true);
    }

    public static boolean isStoreOfflineWpMaps() {
        return getBoolean(R.string.pref_offlinewpmaps, false);
    }

    public static boolean isStoreLogImages() {
        return getBoolean(R.string.pref_logimages, false);
    }

    public static boolean isAutoLoadDescription() {
        return getBoolean(R.string.pref_autoloaddesc, true);
    }

    public static boolean isRatingWanted() {
        return getBoolean(R.string.pref_ratingwanted, true);
    }

    public static boolean isFriendLogsWanted() {
        if (!isLogin()) {
            // don't show a friends log if the user is anonymous
            return false;
        }
        return getBoolean(R.string.pref_friendlogswanted, true);
    }

    public static boolean isLiveList() {
        return getBoolean(R.string.pref_livelist, true);
    }

    public static boolean isTrackableAutoVisit() {
        return getBoolean(R.string.pref_trackautovisit, false);
    }

    public static boolean isAutoInsertSignature() {
        return getBoolean(R.string.pref_sigautoinsert, false);
    }

    public static boolean isUseImperialUnits() {
        return getBoolean(R.string.pref_units, getImperialUnitsDefault());
    }

    static boolean getImperialUnitsDefault() {
        final String countryCode = Locale.getDefault().getCountry();
        if ("US".equals(countryCode)) {
            return true; // USA
        }
        if ("LR".equals(countryCode)) {
            return true; // Liberia
        }
        if ("MM".equals(countryCode)) {
            return true; // Burma
        }
        return false;
    }

    public static boolean isLiveMap() {
        return getBoolean(R.string.pref_maplive, true);
    }

    public static void setLiveMap(final boolean live) {
        putBoolean(R.string.pref_maplive, live);
    }

    public static boolean isMapTrail() {
        return getBoolean(R.string.pref_maptrail, true);
    }

    public static void setMapTrail(final boolean showTrail) {
        putBoolean(R.string.pref_maptrail, showTrail);
    }

    public static int getMapZoom() {
        return getInt(R.string.pref_lastmapzoom, 14);
    }

    public static void setMapZoom(final int mapZoomLevel) {
        putInt(R.string.pref_lastmapzoom, mapZoomLevel);
    }

    public static GeoPointImpl getMapCenter() {
        return getMapProvider().getMapItemFactory()
                .getGeoPointBase(new Geopoint(getInt(R.string.pref_lastmaplat, 0) / 1e6,
                        getInt(R.string.pref_lastmaplon, 0) / 1e6));
    }

    public static void setMapCenter(final GeoPointImpl mapViewCenter) {
        putInt(R.string.pref_lastmaplat, mapViewCenter.getLatitudeE6());
        putInt(R.string.pref_lastmaplon, mapViewCenter.getLongitudeE6());
    }

    public static MapSource getMapSource() {
        if (mapSource != null) {
            return mapSource;
        }
        final int id = getConvertedMapId();
        mapSource = MapProviderFactory.getMapSource(id);
        if (mapSource != null) {
            // don't use offline maps if the map file is not valid
            if ((!(mapSource instanceof OfflineMapSource)) || (isValidMapFile())) {
                return mapSource;
            }
        }
        // fallback to first available map
        return MapProviderFactory.getDefaultSource();
    }

    private final static int GOOGLEMAP_BASEID = 30;
    private final static int MAP = 1;
    private final static int SATELLITE = 2;

    private final static int MFMAP_BASEID = 40;
    private final static int MAPNIK = 1;
    private final static int CYCLEMAP = 3;
    private final static int OFFLINE = 4;

    /**
     * convert old preference ids for maps (based on constant values) into new hash based ids
     *
     * @return
     */
    private static int getConvertedMapId() {
        // what the heck is happening here?? hashCodes of Strings?
        // why not strings?
        final int id = Integer.parseInt(getString(R.string.pref_mapsource,
                String.valueOf(MAP_SOURCE_DEFAULT)));
        switch (id) {
            case GOOGLEMAP_BASEID + MAP:
                return GoogleMapProvider.GOOGLE_MAP_ID.hashCode();
            case GOOGLEMAP_BASEID + SATELLITE:
                return GoogleMapProvider.GOOGLE_SATELLITE_ID.hashCode();
            case MFMAP_BASEID + MAPNIK:
                return MapsforgeMapProvider.MAPSFORGE_MAPNIK_ID.hashCode();
            case MFMAP_BASEID + CYCLEMAP:
                return MapsforgeMapProvider.MAPSFORGE_CYCLEMAP_ID.hashCode();
            case MFMAP_BASEID + OFFLINE: {
                final String mapFile = Settings.getMapFile();
                if (StringUtils.isNotEmpty(mapFile)) {
                    return mapFile.hashCode();
                }
                break;
            }
            default:
                break;
        }
        return id;
    }

    public static void setMapSource(final MapSource newMapSource) {
        putString(R.string.pref_mapsource, String.valueOf(newMapSource.getNumericalId()));
        if (newMapSource instanceof OfflineMapSource) {
            setMapFile(((OfflineMapSource) newMapSource).getFileName());
        }
        // cache the value
        mapSource = newMapSource;
    }

    public static void setAnyCoordinates(final Geopoint coords) {
        if (null != coords) {
            putFloat(R.string.pref_anylatitude, (float) coords.getLatitude());
            putFloat(R.string.pref_anylatitude, (float) coords.getLongitude());
        } else {
            remove(R.string.pref_anylatitude);
            remove(R.string.pref_anylongitude);
        }
    }

    public static Geopoint getAnyCoordinates() {
        if (contains(R.string.pref_anylatitude) && contains(R.string.pref_anylongitude)) {
            float lat = getFloat(R.string.pref_anylatitude, 0);
            float lon = getFloat(R.string.pref_anylongitude, 0);
            return new Geopoint(lat, lon);
        }
        return null;
    }

    public static boolean isUseCompass() {
        return getBoolean(R.string.pref_usecompass, true);
    }

    public static void setUseCompass(final boolean useCompass) {
        putBoolean(R.string.pref_usecompass, useCompass);
    }

    public static boolean isLightSkin() {
        return getBoolean(R.string.pref_skin, false);
    }

    public static String getKeyConsumerPublic() {
        return keyConsumerPublic;
    }

    public static String getKeyConsumerSecret() {
        return keyConsumerSecret;
    }

    public static String getWebDeviceCode() {
        return getString(R.string.pref_webDeviceCode, null);
    }

    public static String getWebDeviceName() {
        return getString(R.string.pref_webDeviceName, android.os.Build.MODEL);
    }

    /**
     * @return The cache type used for filtering or ALL if no filter is active.
     *         Returns never null
     */
    public static CacheType getCacheType() {
        return CacheType.getById(getString(R.string.pref_cachetype, CacheType.ALL.id));
    }

    /**
     * The Threshold for the showing of child waypoints
     */
    public static int getWayPointsThreshold() {
        return getInt(R.string.pref_showwaypointsthreshold, SHOW_WP_THRESHOLD_DEFAULT);
    }

    public static void setShowWaypointsThreshold(final int threshold) {
        putInt(R.string.pref_showwaypointsthreshold, threshold);
    }

    public static boolean isUseTwitter() {
        return getBoolean(R.string.pref_twitter, false);
    }

    public static void setUseTwitter(final boolean useTwitter) {
        putBoolean(R.string.pref_twitter, useTwitter);
    }

    public static boolean isTwitterLoginValid() {
        return !StringUtils.isBlank(getTokenPublic())
                && !StringUtils.isBlank(getTokenSecret());
    }

    public static String getTokenPublic() {
        return getString(R.string.pref_twitter_token_public, null);
    }

    public static String getTokenSecret() {
        return getString(R.string.pref_twitter_token_secret, null);

    }

    public static boolean hasTwitterAuthorization() {
        return StringUtils.isNotBlank(getTokenPublic())
                && StringUtils.isNotBlank(getTokenSecret());
    }

    public static void setTwitterTokens(final String tokenPublic,
            final String tokenSecret, boolean enableTwitter) {
        putString(R.string.pref_twitter_token_public, tokenPublic);
        putString(R.string.pref_twitter_token_secret, tokenSecret);
        if (tokenPublic != null) {
            remove(R.string.pref_temp_twitter_token_public);
            remove(R.string.pref_temp_twitter_token_secret);
        }
        setUseTwitter(enableTwitter);
    }

    public static void setTwitterTempTokens(final String tokenPublic,
            final String tokenSecret) {
        putString(R.string.pref_temp_twitter_token_public, tokenPublic);
        putString(R.string.pref_temp_twitter_token_secret, tokenSecret);
    }

    public static ImmutablePair<String, String> getTempToken() {
        String tokenPublic = getString(R.string.pref_temp_twitter_token_public, null);
        String tokenSecret = getString(R.string.pref_temp_twitter_token_secret, null);
        return new ImmutablePair<String, String>(tokenPublic, tokenSecret);
    }

    public static int getVersion() {
        return getInt(R.string.pref_version, 0);
    }

    public static void setVersion(final int version) {
        putInt(R.string.pref_version, version);
    }

    public static boolean isOpenLastDetailsPage() {
        return getBoolean(R.string.pref_opendetailslastpage, false);
    }

    public static int getLastDetailsPage() {
        return getInt(R.string.pref_lastdetailspage, 1);
    }

    public static void setLastDetailsPage(final int index) {
        putInt(R.string.pref_lastdetailspage, index);
    }

    public static int getDefaultNavigationTool() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool,
                String.valueOf(NavigationAppsEnum.COMPASS.id)));
    }

    public static void setDefaultNavigationTool(final int defaultNavigationTool) {
        putString(R.string.pref_defaultNavigationTool,
                String.valueOf(defaultNavigationTool));
    }

    public static int getDefaultNavigationTool2() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool2,
                String.valueOf(NavigationAppsEnum.INTERNAL_MAP.id)));
    }

    public static void setDefaultNavigationTool2(final int defaultNavigationTool) {
        putString(R.string.pref_defaultNavigationTool2,
                String.valueOf(defaultNavigationTool));
    }

    public static Strategy getLiveMapStrategy() {
        return Strategy.getById(getInt(R.string.pref_livemapstrategy, Strategy.AUTO.id));
    }

    public static void setLiveMapStrategy(final Strategy strategy) {
        putInt(R.string.pref_livemapstrategy, strategy.id);
    }

    public static boolean isDebug() {
        return Log.isDebug();
    }

    public static boolean getHideLiveMapHint() {
        return getBoolean(R.string.pref_hidelivemaphint, false);
    }

    public static void setHideLiveHint(final boolean hide) {
        putBoolean(R.string.pref_hidelivemaphint, hide);
    }

    public static int getLiveMapHintShowCount() {
        return getInt(R.string.pref_livemaphintshowcount, 0);
    }

    public static void setLiveMapHintShowCount(final int showCount) {
        putInt(R.string.pref_livemaphintshowcount, showCount);
    }

    public static boolean isDbOnSDCard() {
        return getBoolean(R.string.pref_dbonsdcard, false);
    }

    public static void setDbOnSDCard(final boolean dbOnSDCard) {
        putBoolean(R.string.pref_dbonsdcard, dbOnSDCard);
    }

    public static String getGpxExportDir() {
        return getString(R.string.pref_gpxExportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static String getGpxImportDir() {
        return getString(R.string.pref_gpxImportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static boolean getShareAfterExport() {
        return getBoolean(R.string.pref_shareafterexport, true);
    }

    public static void setShareAfterExport(final boolean shareAfterExport) {
        putBoolean(R.string.pref_shareafterexport, shareAfterExport);
    }

    public static int getTrackableAction() {
        return getInt(R.string.pref_trackableaction, LogType.RETRIEVED_IT.id);
    }

    public static void setTrackableAction(final int trackableAction) {
        putInt(R.string.pref_trackableaction, trackableAction);
    }

    public static String getCustomRenderThemeBaseFolder() {
        return getString(R.string.pref_renderthemepath, "");
    }

    public static String getCustomRenderThemeFilePath() {
        return getString(R.string.pref_renderthemefile, "");
    }

    public static void setCustomRenderThemeFile(final String customRenderThemeFile) {
        putString(R.string.pref_renderthemefile, customRenderThemeFile);
    }

    public static File[] getMapThemeFiles() {
        File directory = new File(Settings.getCustomRenderThemeBaseFolder());
        List<File> result = new ArrayList<File>();
        FileUtils.listDir(result, directory, new ExtensionsBasedFileSelector(new String[] { "xml" }), null);

        return result.toArray(new File[result.size()]);
    }

    private static class ExtensionsBasedFileSelector extends FileSelector {
        private final String[] extensions;
        public ExtensionsBasedFileSelector(String[] extensions) {
            this.extensions = extensions;
        }
        @Override
        public boolean isSelected(File file) {
            String filename = file.getName();
            for (String ext : extensions) {
                if (StringUtils.endsWithIgnoreCase(filename, ext)) {
                    return true;
                }
            }
            return false;
        }
        @Override
        public boolean shouldEnd() {
            return false;
        }
    }

    public static boolean getPlainLogs() {
        return getBoolean(R.string.pref_plainLogs, false);
    }

    public static boolean getUseNativeUa() {
        return getBoolean(R.string.pref_nativeUa, false);
    }

    public static String getCacheTwitterMessage() {
        // TODO make customizable from UI
        return "I found [NAME] ([URL])";
    }

    public static String getTrackableTwitterMessage() {
        // TODO make customizable from UI
        return "I touched [NAME] ([URL])!";
    }

    public static int getLogImageScale() {
        return getInt(R.string.pref_logImageScale, -1);
    }

    public static void setLogImageScale(final int scale) {
        putInt(R.string.pref_logImageScale, scale);
    }

    // Only for tests!
    static void setExcludeDisabledCaches(final boolean exclude) {
        putBoolean(R.string.pref_excludedisabled, exclude);
    }

    public static void setExcludeMine(final boolean exclude) {
        putBoolean(R.string.pref_excludemine, exclude);
    }

    static boolean setLogin(final String username, final String password) {

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            // erase username and password
            boolean a = remove(R.string.pref_username);
            boolean b = remove(R.string.pref_password);
            return a && b;
        }
        // save username and password
        boolean a = putString(R.string.pref_username, username);
        boolean b = putString(R.string.pref_password, password);
        return a && b;
    }

    static void setStoreOfflineMaps(final boolean offlineMaps) {
        putBoolean(R.string.pref_offlinemaps, offlineMaps);
    }

    static void setStoreOfflineWpMaps(final boolean offlineWpMaps) {
        putBoolean(R.string.pref_offlinewpmaps, offlineWpMaps);
    }

    static void setUseImperialUnits(final boolean imperial) {
        putBoolean(R.string.pref_units, imperial);
    }

    public static long getFieldnoteExportDate() {
        return getLong(R.string.pref_fieldnoteExportDate, 0);
    }

    public static void setFieldnoteExportDate(final long date) {
        putLong(R.string.pref_fieldnoteExportDate, date);
    }

    public static boolean isUseNavigationApp(NavigationAppsEnum navApp) {
        return getBoolean(navApp.preferenceKey, true);
    }

}
!@#$%
20190527_002501,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_a20648
package cgeo.geocaching.settings;

import cgeo.geocaching.R;
import cgeo.geocaching.StoredList;
import cgeo.geocaching.cgeoapplication;
import cgeo.geocaching.apps.cache.navi.NavigationAppFactory.NavigationAppsEnum;
import cgeo.geocaching.connector.gc.GCConstants;
import cgeo.geocaching.connector.gc.Login;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.LiveMapStrategy.Strategy;
import cgeo.geocaching.enumerations.LogType;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.maps.MapProviderFactory;
import cgeo.geocaching.maps.google.GoogleMapProvider;
import cgeo.geocaching.maps.interfaces.GeoPointImpl;
import cgeo.geocaching.maps.interfaces.MapProvider;
import cgeo.geocaching.maps.interfaces.MapSource;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider.OfflineMapSource;
import cgeo.geocaching.utils.CryptUtils;
import cgeo.geocaching.utils.FileUtils;
import cgeo.geocaching.utils.FileUtils.FileSelector;
import cgeo.geocaching.utils.Log;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.os.Environment;
import android.preference.PreferenceManager;

import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

/**
 * General c:geo preferences/settings set by the user
 */
public final class Settings {

    public static final int SHOW_WP_THRESHOLD_DEFAULT = 5;
    public static final int SHOW_WP_THRESHOLD_MAX = 50;
    private static final int MAP_SOURCE_DEFAULT = GoogleMapProvider.GOOGLE_MAP_ID.hashCode();

    private final static int unitsMetric = 1;

    // twitter api keys
    private final static String keyConsumerPublic = CryptUtils.rot13("ESnsCvAv3kEupF1GCR3jGj");
    private final static String keyConsumerSecret = CryptUtils.rot13("7vQWceACV9umEjJucmlpFe9FCMZSeqIqfkQ2BnhV9x");

    public enum coordInputFormatEnum {
        Plain,
        Deg,
        Min,
        Sec;

        public static coordInputFormatEnum fromInt(int id) {
            final coordInputFormatEnum[] values = coordInputFormatEnum.values();
            if (id < 0 || id >= values.length) {
                return Min;
            }
            return values[id];
        }
    }

    private static final SharedPreferences sharedPrefs = PreferenceManager
            .getDefaultSharedPreferences(cgeoapplication.getInstance().getBaseContext());
    static {
        migrateSettings();
        Log.setDebug(sharedPrefs.getBoolean(getKey(R.string.pref_debug), false));
    }

    // maps
    private static MapProvider mapProvider = null;

    private Settings() {
        // this class is not to be instantiated;
    }

    private static void migrateSettings() {
        // migrate from non standard file location and integer based boolean types
        int oldVersion = getInt(R.string.pref_settingsversion, 0);
        if (oldVersion < 1) {
            final String oldPreferencesName = "cgeo.pref";
            final SharedPreferences old = cgeoapplication.getInstance().getSharedPreferences(oldPreferencesName, Context.MODE_PRIVATE);
            final Editor e = sharedPrefs.edit();

            e.putString(getKey(R.string.pref_temp_twitter_token_secret), old.getString(getKey(R.string.pref_temp_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_temp_twitter_token_public), old.getString(getKey(R.string.pref_temp_twitter_token_public), null));
            e.putBoolean(getKey(R.string.pref_help_shown), old.getInt(getKey(R.string.pref_help_shown), 0) != 0);
            e.putFloat(getKey(R.string.pref_anylongitude), old.getFloat(getKey(R.string.pref_anylongitude), 0));
            e.putFloat(getKey(R.string.pref_anylatitude), old.getFloat(getKey(R.string.pref_anylatitude), 0));
            e.putBoolean(getKey(R.string.pref_offlinemaps), 0 != old.getInt(getKey(R.string.pref_offlinemaps), 1));
            e.putBoolean(getKey(R.string.pref_offlinewpmaps), 0 != old.getInt(getKey(R.string.pref_offlinewpmaps), 0));
            e.putString(getKey(R.string.pref_webDeviceCode), old.getString(getKey(R.string.pref_webDeviceCode), null));
            e.putString(getKey(R.string.pref_webDeviceName), old.getString(getKey(R.string.pref_webDeviceName), null));
            e.putBoolean(getKey(R.string.pref_maplive), old.getInt(getKey(R.string.pref_maplive), 1) != 0);
            e.putInt(getKey(R.string.pref_mapsource), old.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT));
            e.putBoolean(getKey(R.string.pref_twitter), 0 != old.getInt(getKey(R.string.pref_twitter), 0));
            e.putBoolean(getKey(R.string.pref_showaddress), 0 != old.getInt(getKey(R.string.pref_showaddress), 1));
            e.putBoolean(getKey(R.string.pref_showcaptcha), old.getBoolean(getKey(R.string.pref_showcaptcha), false));
            e.putBoolean(getKey(R.string.pref_maptrail), old.getInt(getKey(R.string.pref_maptrail), 1) != 0);
            e.putInt(getKey(R.string.pref_lastmapzoom), old.getInt(getKey(R.string.pref_lastmapzoom), 14));
            e.putBoolean(getKey(R.string.pref_livelist), 0 != old.getInt(getKey(R.string.pref_livelist), 1));
            e.putBoolean(getKey(R.string.pref_units), old.getInt(getKey(R.string.pref_units), unitsMetric) == unitsMetric);
            e.putBoolean(getKey(R.string.pref_skin), old.getInt(getKey(R.string.pref_skin), 0) != 0);
            e.putInt(getKey(R.string.pref_lastusedlist), old.getInt(getKey(R.string.pref_lastusedlist), StoredList.STANDARD_LIST_ID));
            e.putString(getKey(R.string.pref_cachetype), old.getString(getKey(R.string.pref_cachetype), CacheType.ALL.id));
            e.putString(getKey(R.string.pref_twitter_token_secret), old.getString(getKey(R.string.pref_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_twitter_token_public), old.getString(getKey(R.string.pref_twitter_token_public), null));
            e.putInt(getKey(R.string.pref_version), old.getInt(getKey(R.string.pref_version), 0));
            e.putBoolean(getKey(R.string.pref_autoloaddesc), 0 != old.getInt(getKey(R.string.pref_autoloaddesc), 1));
            e.putBoolean(getKey(R.string.pref_ratingwanted), old.getBoolean(getKey(R.string.pref_ratingwanted), true));
            e.putBoolean(getKey(R.string.pref_friendlogswanted), old.getBoolean(getKey(R.string.pref_friendlogswanted), true));
            e.putBoolean(getKey(R.string.pref_useenglish), old.getBoolean(getKey(R.string.pref_useenglish), false));
            e.putBoolean(getKey(R.string.pref_usecompass), 0 != old.getInt(getKey(R.string.pref_usecompass), 1));
            e.putBoolean(getKey(R.string.pref_trackautovisit), old.getBoolean(getKey(R.string.pref_trackautovisit), false));
            e.putBoolean(getKey(R.string.pref_sigautoinsert), old.getBoolean(getKey(R.string.pref_sigautoinsert), false));
            e.putBoolean(getKey(R.string.pref_logimages), old.getBoolean(getKey(R.string.pref_logimages), false));
            e.putBoolean(getKey(R.string.pref_excludedisabled), 0 != old.getInt(getKey(R.string.pref_excludedisabled), 0));
            e.putBoolean(getKey(R.string.pref_excludemine), 0 != old.getInt(getKey(R.string.pref_excludemine), 0));
            e.putString(getKey(R.string.pref_mapfile), old.getString(getKey(R.string.pref_mapfile), null));
            e.putString(getKey(R.string.pref_signature), old.getString(getKey(R.string.pref_signature), null));
            e.putString(getKey(R.string.pref_pass_vote), old.getString(getKey(R.string.pref_pass_vote), null));
            e.putString(getKey(R.string.pref_password), old.getString(getKey(R.string.pref_password), null));
            e.putString(getKey(R.string.pref_username), old.getString(getKey(R.string.pref_username), null));
            e.putString(getKey(R.string.pref_memberstatus), old.getString(getKey(R.string.pref_memberstatus), ""));
            e.putInt(getKey(R.string.pref_coordinputformat), old.getInt(getKey(R.string.pref_coordinputformat), 0));
            e.putBoolean(getKey(R.string.pref_log_offline), old.getBoolean(getKey(R.string.pref_log_offline), false));
            e.putBoolean(getKey(R.string.pref_choose_list), old.getBoolean(getKey(R.string.pref_choose_list), false));
            e.putBoolean(getKey(R.string.pref_loaddirectionimg), old.getBoolean(getKey(R.string.pref_loaddirectionimg), true));
            e.putString(getKey(R.string.pref_gccustomdate), old.getString(getKey(R.string.pref_gccustomdate), null));
            e.putInt(getKey(R.string.pref_gcshowwaypointsthreshold), old.getInt(getKey(R.string.pref_gcshowwaypointsthreshold), 0));
            e.putString(getKey(R.string.pref_cookiestore), old.getString(getKey(R.string.pref_cookiestore), null));
            e.putBoolean(getKey(R.string.pref_opendetailslastpage), old.getBoolean(getKey(R.string.pref_opendetailslastpage), false));
            e.putInt(getKey(R.string.pref_lastdetailspage), old.getInt(getKey(R.string.pref_lastdetailspage), 1));
            e.putInt(getKey(R.string.pref_defaultNavigationTool), old.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id));
            e.putInt(getKey(R.string.pref_defaultNavigationTool2), old.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id));
            e.putInt(getKey(R.string.pref_livemapstrategy), old.getInt(getKey(R.string.pref_livemapstrategy), Strategy.AUTO.id));
            e.putBoolean(getKey(R.string.pref_debug), old.getBoolean(getKey(R.string.pref_debug), false));
            e.putBoolean(getKey(R.string.pref_hidelivemaphint), old.getInt(getKey(R.string.pref_hidelivemaphint), 0) != 0);
            e.putInt(getKey(R.string.pref_livemaphintshowcount), old.getInt(getKey(R.string.pref_livemaphintshowcount), 0));

            e.putInt(getKey(R.string.pref_settingsversion), 1); // mark migrated
            e.commit();
        }

        // changes for new settings dialog
        if (oldVersion < 2) {
            final Editor e = sharedPrefs.edit();

            e.putBoolean(getKey(R.string.pref_units), !isUseImperialUnits());

            // show waypoints threshold now as a slider
            int wpThreshold = getWayPointsThreshold();
            if (wpThreshold < 0) {
                wpThreshold = 0;
            } else if (wpThreshold > SHOW_WP_THRESHOLD_MAX) {
                wpThreshold = SHOW_WP_THRESHOLD_MAX;
            }
            e.putInt(getKey(R.string.pref_gcshowwaypointsthreshold), wpThreshold);

            // KEY_MAP_SOURCE must be string, because it is the key for a ListPreference now
            int ms = sharedPrefs.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT);
            e.remove(getKey(R.string.pref_mapsource));
            e.putString(getKey(R.string.pref_mapsource), String.valueOf(ms));

            // navigation tool ids must be string, because ListPreference uses strings as keys
            int dnt1 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id);
            int dnt2 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id);
            e.remove(getKey(R.string.pref_defaultNavigationTool));
            e.remove(getKey(R.string.pref_defaultNavigationTool2));
            e.putString(getKey(R.string.pref_defaultNavigationTool), String.valueOf(dnt1));
            e.putString(getKey(R.string.pref_defaultNavigationTool2), String.valueOf(dnt2));

            // defaults for gpx directories
            e.putString(getKey(R.string.pref_gpxImportDir), getGpxImportDir());
            e.putString(getKey(R.string.pref_gpxExportDir), getGpxExportDir());

            e.putInt(getKey(R.string.pref_settingsversion), 2); // mark migrated
            e.commit();
        }
    }

    private static String getKey(final int prefKeyId) {
        return cgeoapplication.getInstance().getString(prefKeyId);
    }

    static String getString(final int prefKeyId, final String defaultValue) {
        return sharedPrefs.getString(getKey(prefKeyId), defaultValue);
    }

    private static int getInt(final int prefKeyId, final int defaultValue) {
        return sharedPrefs.getInt(getKey(prefKeyId), defaultValue);
    }

    private static long getLong(final int prefKeyId, final long defaultValue) {
        return sharedPrefs.getLong(getKey(prefKeyId), defaultValue);
    }

    private static boolean getBoolean(final int prefKeyId, final boolean defaultValue) {
        return sharedPrefs.getBoolean(getKey(prefKeyId), defaultValue);
    }

    private static float getFloat(final int prefKeyId, final float defaultValue) {
        return sharedPrefs.getFloat(getKey(prefKeyId), defaultValue);
    }

    static boolean putString(final int prefKeyId, final String value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putString(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putBoolean(final int prefKeyId, final boolean value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putBoolean(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putInt(final int prefKeyId, final int value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putInt(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putLong(final int prefKeyId, final long value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putLong(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putFloat(final int prefKeyId, final float value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putFloat(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean remove(final int prefKeyId) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.remove(getKey(prefKeyId));
        return edit.commit();
    }

    private static boolean contains(final int prefKeyId) {
        return sharedPrefs.contains(getKey(prefKeyId));
    }

    public static void setLanguage(boolean useEnglish) {
        final Configuration config = new Configuration();
        config.locale = useEnglish ? Locale.ENGLISH : Locale.getDefault();
        final Resources resources = cgeoapplication.getInstance().getResources();
        resources.updateConfiguration(config, resources.getDisplayMetrics());
    }

    public static boolean isLogin() {
        final String preUsername = getString(R.string.pref_username, null);
        final String prePassword = getString(R.string.pref_password, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    /**
     * Get login and password information.
     * 
     * @return a pair either with (login, password) or (empty, empty) if no valid information is stored
     */
    public static ImmutablePair<String, String> getGcLogin() {

        final String username = getString(R.string.pref_username, null);
        final String password = getString(R.string.pref_password, null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return new ImmutablePair<String, String>(StringUtils.EMPTY, StringUtils.EMPTY);
        }

        return new ImmutablePair<String, String>(username, password);
    }

    public static String getUsername() {
        return getString(R.string.pref_username, null);
    }

    public static boolean isGCConnectorActive() {
        return getBoolean(R.string.pref_connectorGCActive, true);
    }

    public static boolean isPremiumMember() {
        // Basic Member, Premium Member, ???
        String memberStatus = Settings.getMemberStatus();
        if (memberStatus == null) {
            return false;
        }
        return GCConstants.MEMBER_STATUS_PM.equalsIgnoreCase(memberStatus);
    }

    public static String getMemberStatus() {
        return getString(R.string.pref_memberstatus, "");
    }

    public static boolean setMemberStatus(final String memberStatus) {
        if (StringUtils.isBlank(memberStatus)) {
            return remove(R.string.pref_memberstatus);
        }
        return putString(R.string.pref_memberstatus, memberStatus);
    }

    public static boolean isOCConnectorActive() {
        return getBoolean(R.string.pref_connectorOCActive, false);
    }

    public static boolean setOCConnectorActive(final boolean isActive) {
        return putBoolean(R.string.pref_connectorOCActive, isActive);
    }

    public static String getOCDETokenPublic() {
        return getString(R.string.pref_ocde_tokenpublic, "");
    }

    public static String getOCDETokenSecret() {
        return getString(R.string.pref_ocde_tokensecret, "");
    }

    public static boolean hasOCDEAuthorization() {
        return StringUtils.isNotBlank(getOCDETokenPublic())
                && StringUtils.isNotBlank(getOCDETokenSecret());
    }

    public static void setOCDETokens(final String tokenPublic,
            final String tokenSecret, boolean enableOcDe) {
        putString(R.string.pref_ocde_tokenpublic, tokenPublic);
        putString(R.string.pref_ocde_tokensecret, tokenSecret);
        if (tokenPublic != null) {
            remove(R.string.pref_temp_ocde_token_public);
            remove(R.string.pref_temp_ocde_token_secret);
        }
        setOCConnectorActive(enableOcDe);
    }

    public static void setOCDETempTokens(final String tokenPublic, final String tokenSecret) {
        putString(R.string.pref_temp_ocde_token_public, tokenPublic);
        putString(R.string.pref_temp_ocde_token_secret, tokenSecret);
    }

    public static ImmutablePair<String, String> getTempOCDEToken() {
        String tokenPublic = getString(R.string.pref_temp_ocde_token_public, null);
        String tokenSecret = getString(R.string.pref_temp_ocde_token_secret, null);
        return new ImmutablePair<String, String>(tokenPublic, tokenSecret);
    }

    public static boolean isGCvoteLogin() {
        final String preUsername = getString(R.string.pref_username, null);
        final String prePassword = getString(R.string.pref_pass_vote, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    public static ImmutablePair<String, String> getGCvoteLogin() {
        final String username = getString(R.string.pref_username, null);
        final String password = getString(R.string.pref_pass_vote, null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return null;
        }

        return new ImmutablePair<String, String>(username, password);
    }

    public static String getSignature() {
        return getString(R.string.pref_signature, null);
    }

    public static boolean setCookieStore(final String cookies) {
        if (StringUtils.isBlank(cookies)) {
            // erase cookies
            return remove(R.string.pref_cookiestore);
        }
        // save cookies
        return putString(R.string.pref_cookiestore, cookies);
    }

    public static String getCookieStore() {
        return getString(R.string.pref_cookiestore, null);
    }

    /**
     * @param cacheType
     *            The cache type used for future filtering
     */
    public static void setCacheType(final CacheType cacheType) {
        if (cacheType == null) {
            remove(R.string.pref_cachetype);
        } else {
            putString(R.string.pref_cachetype, cacheType.id);
        }
    }

    public static int getLastList() {
        return getInt(R.string.pref_lastusedlist, StoredList.STANDARD_LIST_ID);
    }

    public static void saveLastList(final int listId) {
        putInt(R.string.pref_lastusedlist, listId);
    }

    public static void setWebNameCode(final String name, final String code) {
        putString(R.string.pref_webDeviceName, name);
        putString(R.string.pref_webDeviceCode, code);
    }

    public static MapProvider getMapProvider() {
        if (mapProvider == null) {
            mapProvider = getMapSource().getMapProvider();
        }
        return mapProvider;
    }

    public static String getMapFile() {
        return getString(R.string.pref_mapfile, null);
    }

    public static boolean setMapFile(final String mapFile) {
        boolean result = putString(R.string.pref_mapfile, mapFile);
        if (mapFile != null) {
            setMapFileDirectory(new File(mapFile).getParent());
        }
        return result;
    }

    public static String getMapFileDirectory() {
        final String mapDir = getString(R.string.pref_mapDirectory, null);
        if (mapDir != null) {
            return mapDir;
        }
        final String mapFile = getMapFile();
        if (mapFile != null) {
            return new File(mapFile).getParent();
        }
        return null;
    }

    public static boolean setMapFileDirectory(final String mapFileDirectory) {
        boolean result = putString(R.string.pref_mapDirectory, mapFileDirectory);
        MapsforgeMapProvider.getInstance().updateOfflineMaps();
        return result;
    }

    public static boolean isValidMapFile() {
        return isValidMapFile(getMapFile());
    }

    public static boolean isValidMapFile(final String mapFileIn) {
        return MapsforgeMapProvider.isValidMapFile(mapFileIn);
    }

    public static coordInputFormatEnum getCoordInputFormat() {
        return coordInputFormatEnum.fromInt(getInt(R.string.pref_coordinputformat, 0));
    }

    public static void setCoordInputFormat(final coordInputFormatEnum format) {
        putInt(R.string.pref_coordinputformat, format.ordinal());
    }

    static void setLogOffline(final boolean offline) {
        putBoolean(R.string.pref_log_offline, offline);
    }

    public static boolean getLogOffline() {
        return getBoolean(R.string.pref_log_offline, false);
    }

    public static boolean getChooseList() {
        return getBoolean(R.string.pref_choose_list, false);
    }

    public static boolean getLoadDirImg() {
        return !isPremiumMember() && getBoolean(R.string.pref_loaddirectionimg, true);
    }

    public static void setGcCustomDate(final String format) {
        putString(R.string.pref_gccustomdate, format);
    }

    /**
     * @return User selected date format on GC.com
     * @see Login#gcCustomDateFormats
     */
    public static String getGcCustomDate() {
        return getString(R.string.pref_gccustomdate, null);
    }

    public static boolean isExcludeMyCaches() {
        return getBoolean(R.string.pref_excludemine, false);
    }

    public static void setUseEnglish(final boolean english) {
        putBoolean(R.string.pref_useenglish, english);
        setLanguage(english);
    }

    public static boolean isUseEnglish() {
        return getBoolean(R.string.pref_useenglish, false);
    }

    public static boolean isShowAddress() {
        return getBoolean(R.string.pref_showaddress, true);
    }

    public static boolean isShowCaptcha() {
        return !isPremiumMember() && getBoolean(R.string.pref_showcaptcha, false);
    }

    public static boolean isExcludeDisabledCaches() {
        return getBoolean(R.string.pref_excludedisabled, false);
    }

    public static boolean isStoreOfflineMaps() {
        return getBoolean(R.string.pref_offlinemaps, true);
    }

    public static boolean isStoreOfflineWpMaps() {
        return getBoolean(R.string.pref_offlinewpmaps, false);
    }

    public static boolean isStoreLogImages() {
        return getBoolean(R.string.pref_logimages, false);
    }

    public static boolean isAutoLoadDescription() {
        return getBoolean(R.string.pref_autoloaddesc, true);
    }

    public static boolean isRatingWanted() {
        return getBoolean(R.string.pref_ratingwanted, true);
    }

    public static boolean isFriendLogsWanted() {
        if (!isLogin()) {
            // don't show a friends log if the user is anonymous
            return false;
        }
        return getBoolean(R.string.pref_friendlogswanted, true);
    }

    public static boolean isLiveList() {
        return getBoolean(R.string.pref_livelist, true);
    }

    public static boolean isTrackableAutoVisit() {
        return getBoolean(R.string.pref_trackautovisit, false);
    }

    public static boolean isAutoInsertSignature() {
        return getBoolean(R.string.pref_sigautoinsert, false);
    }

    public static boolean isUseImperialUnits() {
        return getBoolean(R.string.pref_units, false);
    }

    public static boolean isLiveMap() {
        return getBoolean(R.string.pref_maplive, true);
    }

    public static void setLiveMap(final boolean live) {
        putBoolean(R.string.pref_maplive, live);
    }

    public static boolean isMapTrail() {
        return getBoolean(R.string.pref_maptrail, true);
    }

    public static void setMapTrail(final boolean showTrail) {
        putBoolean(R.string.pref_maptrail, showTrail);
    }

    public static int getMapZoom() {
        return getInt(R.string.pref_lastmapzoom, 14);
    }

    public static void setMapZoom(final int mapZoomLevel) {
        putInt(R.string.pref_lastmapzoom, mapZoomLevel);
    }

    public static GeoPointImpl getMapCenter() {
        return getMapProvider().getMapItemFactory()
                .getGeoPointBase(new Geopoint(getInt(R.string.pref_lastmaplat, 0) / 1e6,
                        getInt(R.string.pref_lastmaplon, 0) / 1e6));
    }

    public static void setMapCenter(final GeoPointImpl mapViewCenter) {
        putInt(R.string.pref_lastmaplat, mapViewCenter.getLatitudeE6());
        putInt(R.string.pref_lastmaplon, mapViewCenter.getLongitudeE6());
    }

    public static MapSource getMapSource() {
        final int id = getConvertedMapId();
        final MapSource map = MapProviderFactory.getMapSource(id);
        if (map != null) {
            // don't use offline maps if the map file is not valid
            if ((!(map instanceof OfflineMapSource)) || (isValidMapFile())) {
                return map;
            }
        }
        // fallback to first available map
        return MapProviderFactory.getDefaultSource();
    }

    private final static int GOOGLEMAP_BASEID = 30;
    private final static int MAP = 1;
    private final static int SATELLITE = 2;

    private final static int MFMAP_BASEID = 40;
    private final static int MAPNIK = 1;
    private final static int CYCLEMAP = 3;
    private final static int OFFLINE = 4;

    /**
     * convert old preference ids for maps (based on constant values) into new hash based ids
     *
     * @return
     */
    private static int getConvertedMapId() {
        // what the heck is happening here?? hashCodes of Strings?
        // why not strings?
        final int id = Integer.parseInt(getString(R.string.pref_mapsource,
                String.valueOf(MAP_SOURCE_DEFAULT)));
        switch (id) {
            case GOOGLEMAP_BASEID + MAP:
                return GoogleMapProvider.GOOGLE_MAP_ID.hashCode();
            case GOOGLEMAP_BASEID + SATELLITE:
                return GoogleMapProvider.GOOGLE_SATELLITE_ID.hashCode();
            case MFMAP_BASEID + MAPNIK:
                return MapsforgeMapProvider.MAPSFORGE_MAPNIK_ID.hashCode();
            case MFMAP_BASEID + CYCLEMAP:
                return MapsforgeMapProvider.MAPSFORGE_CYCLEMAP_ID.hashCode();
            case MFMAP_BASEID + OFFLINE: {
                final String mapFile = Settings.getMapFile();
                if (StringUtils.isNotEmpty(mapFile)) {
                    return mapFile.hashCode();
                }
                break;
            }
            default:
                break;
        }
        return id;
    }

    public static void setMapSource(final MapSource newMapSource) {
        if (!MapProviderFactory.isSameActivity(getMapSource(), newMapSource)) {
            mapProvider = null;
        }
        putString(R.string.pref_mapsource, String.valueOf(newMapSource.getNumericalId()));
        if (newMapSource instanceof OfflineMapSource) {
            setMapFile(((OfflineMapSource) newMapSource).getFileName());
        }
    }

    public static void setAnyCoordinates(final Geopoint coords) {
        if (null != coords) {
            putFloat(R.string.pref_anylatitude, (float) coords.getLatitude());
            putFloat(R.string.pref_anylatitude, (float) coords.getLongitude());
        } else {
            remove(R.string.pref_anylatitude);
            remove(R.string.pref_anylongitude);
        }
    }

    public static Geopoint getAnyCoordinates() {
        if (contains(R.string.pref_anylatitude) && contains(R.string.pref_anylongitude)) {
            float lat = getFloat(R.string.pref_anylatitude, 0);
            float lon = getFloat(R.string.pref_anylongitude, 0);
            return new Geopoint(lat, lon);
        }
        return null;
    }

    public static boolean isUseCompass() {
        return getBoolean(R.string.pref_usecompass, true);
    }

    public static void setUseCompass(final boolean useCompass) {
        putBoolean(R.string.pref_usecompass, useCompass);
    }

    public static boolean isLightSkin() {
        return getBoolean(R.string.pref_skin, false);
    }

    public static String getKeyConsumerPublic() {
        return keyConsumerPublic;
    }

    public static String getKeyConsumerSecret() {
        return keyConsumerSecret;
    }

    public static String getWebDeviceCode() {
        return getString(R.string.pref_webDeviceCode, null);
    }

    public static String getWebDeviceName() {
        return getString(R.string.pref_webDeviceName, android.os.Build.MODEL);
    }

    /**
     * @return The cache type used for filtering or ALL if no filter is active.
     *         Returns never null
     */
    public static CacheType getCacheType() {
        return CacheType.getById(getString(R.string.pref_cachetype, CacheType.ALL.id));
    }

    /**
     * The Threshold for the showing of child waypoints
     */
    public static int getWayPointsThreshold() {
        return getInt(R.string.pref_gcshowwaypointsthreshold, SHOW_WP_THRESHOLD_DEFAULT);
    }

    public static void setShowWaypointsThreshold(final int threshold) {
        putInt(R.string.pref_gcshowwaypointsthreshold, threshold);
    }

    public static boolean isUseTwitter() {
        return getBoolean(R.string.pref_twitter, false);
    }

    public static void setUseTwitter(final boolean useTwitter) {
        putBoolean(R.string.pref_twitter, useTwitter);
    }

    public static boolean isTwitterLoginValid() {
        return !StringUtils.isBlank(getTokenPublic())
                && !StringUtils.isBlank(getTokenSecret());
    }

    public static String getTokenPublic() {
        return getString(R.string.pref_twitter_token_public, null);
    }

    public static String getTokenSecret() {
        return getString(R.string.pref_twitter_token_secret, null);

    }

    public static boolean hasTwitterAuthorization() {
        return StringUtils.isNotBlank(getTokenPublic())
                && StringUtils.isNotBlank(getTokenSecret());
    }

    public static void setTwitterTokens(final String tokenPublic,
            final String tokenSecret, boolean enableTwitter) {
        putString(R.string.pref_twitter_token_public, tokenPublic);
        putString(R.string.pref_twitter_token_secret, tokenSecret);
        if (tokenPublic != null) {
            remove(R.string.pref_temp_twitter_token_public);
            remove(R.string.pref_temp_twitter_token_secret);
        }
        setUseTwitter(enableTwitter);
    }

    public static void setTwitterTempTokens(final String tokenPublic,
            final String tokenSecret) {
        putString(R.string.pref_temp_twitter_token_public, tokenPublic);
        putString(R.string.pref_temp_twitter_token_secret, tokenSecret);
    }

    public static ImmutablePair<String, String> getTempToken() {
        String tokenPublic = getString(R.string.pref_temp_twitter_token_public, null);
        String tokenSecret = getString(R.string.pref_temp_twitter_token_secret, null);
        return new ImmutablePair<String, String>(tokenPublic, tokenSecret);
    }

    public static int getVersion() {
        return getInt(R.string.pref_version, 0);
    }

    public static void setVersion(final int version) {
        putInt(R.string.pref_version, version);
    }

    public static boolean isOpenLastDetailsPage() {
        return getBoolean(R.string.pref_opendetailslastpage, false);
    }

    public static int getLastDetailsPage() {
        return getInt(R.string.pref_lastdetailspage, 1);
    }

    public static void setLastDetailsPage(final int index) {
        putInt(R.string.pref_lastdetailspage, index);
    }

    public static int getDefaultNavigationTool() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool,
                String.valueOf(NavigationAppsEnum.COMPASS.id)));
    }

    public static void setDefaultNavigationTool(final int defaultNavigationTool) {
        putString(R.string.pref_defaultNavigationTool,
                String.valueOf(defaultNavigationTool));
    }

    public static int getDefaultNavigationTool2() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool2,
                String.valueOf(NavigationAppsEnum.INTERNAL_MAP.id)));
    }

    public static void setDefaultNavigationTool2(final int defaultNavigationTool) {
        putString(R.string.pref_defaultNavigationTool2,
                String.valueOf(defaultNavigationTool));
    }

    public static Strategy getLiveMapStrategy() {
        return Strategy.getById(getInt(R.string.pref_livemapstrategy, Strategy.AUTO.id));
    }

    public static void setLiveMapStrategy(final Strategy strategy) {
        putInt(R.string.pref_livemapstrategy, strategy.id);
    }

    public static boolean isDebug() {
        return Log.isDebug();
    }

    public static boolean getHideLiveMapHint() {
        return getBoolean(R.string.pref_hidelivemaphint, false);
    }

    public static void setHideLiveHint(final boolean hide) {
        putBoolean(R.string.pref_hidelivemaphint, hide);
    }

    public static int getLiveMapHintShowCount() {
        return getInt(R.string.pref_livemaphintshowcount, 0);
    }

    public static void setLiveMapHintShowCount(final int showCount) {
        putInt(R.string.pref_livemaphintshowcount, showCount);
    }

    public static boolean isDbOnSDCard() {
        return getBoolean(R.string.pref_dbonsdcard, false);
    }

    public static void setDbOnSDCard(final boolean dbOnSDCard) {
        putBoolean(R.string.pref_dbonsdcard, dbOnSDCard);
    }

    public static String getGpxExportDir() {
        return getString(R.string.pref_gpxExportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static String getGpxImportDir() {
        return getString(R.string.pref_gpxImportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static boolean getShareAfterExport() {
        return getBoolean(R.string.pref_shareafterexport, true);
    }

    public static void setShareAfterExport(final boolean shareAfterExport) {
        putBoolean(R.string.pref_shareafterexport, shareAfterExport);
    }

    public static int getTrackableAction() {
        return getInt(R.string.pref_trackableaction, LogType.RETRIEVED_IT.id);
    }

    public static void setTrackableAction(final int trackableAction) {
        putInt(R.string.pref_trackableaction, trackableAction);
    }

    public static String getCustomRenderThemeBaseFolder() {
        return getString(R.string.pref_renderthemepath, "");
    }

    public static String getCustomRenderThemeFilePath() {
        return getString(R.string.pref_renderthemefile, "");
    }

    public static void setCustomRenderThemeFile(final String customRenderThemeFile) {
        putString(R.string.pref_renderthemefile, customRenderThemeFile);
    }

    public static File[] getMapThemeFiles() {
        File directory = new File(Settings.getCustomRenderThemeBaseFolder());
        List<File> result = new ArrayList<File>();
        FileUtils.listDir(result, directory, new ExtensionsBasedFileSelector(new String[] { "xml" }), null);

        return result.toArray(new File[result.size()]);
    }

    private static class ExtensionsBasedFileSelector extends FileSelector {
        private final String[] extensions;
        public ExtensionsBasedFileSelector(String[] extensions) {
            this.extensions = extensions;
        }
        @Override
        public boolean isSelected(File file) {
            String filename = file.getName();
            for (String ext : extensions) {
                if (StringUtils.endsWithIgnoreCase(filename, ext)) {
                    return true;
                }
            }
            return false;
        }
        @Override
        public boolean shouldEnd() {
            return false;
        }
    }

    public static boolean getPlainLogs() {
        return getBoolean(R.string.pref_plainLogs, false);
    }

    public static boolean getUseNativeUa() {
        return getBoolean(R.string.pref_nativeUa, false);
    }

    public static String getCacheTwitterMessage() {
        // TODO make customizable from UI
        return "I found [NAME] ([URL])";
    }

    public static String getTrackableTwitterMessage() {
        // TODO make customizable from UI
        return "I touched [NAME] ([URL])!";
    }

    public static int getLogImageScale() {
        return getInt(R.string.pref_logImageScale, -1);
    }

    public static void setLogImageScale(final int scale) {
        putInt(R.string.pref_logImageScale, scale);
    }

    // Only for tests!
    static void setExcludeDisabledCaches(final boolean exclude) {
        putBoolean(R.string.pref_excludedisabled, exclude);
    }

    public static void setExcludeMine(final boolean exclude) {
        putBoolean(R.string.pref_excludemine, exclude);
    }

    static boolean setLogin(final String username, final String password) {

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            // erase username and password
            boolean a = remove(R.string.pref_username);
            boolean b = remove(R.string.pref_password);
            return a && b;
        }
        // save username and password
        boolean a = putString(R.string.pref_username, username);
        boolean b = putString(R.string.pref_password, password);
        return a && b;
    }

    static void setStoreOfflineMaps(final boolean offlineMaps) {
        putBoolean(R.string.pref_offlinemaps, offlineMaps);
    }

    static void setStoreOfflineWpMaps(final boolean offlineWpMaps) {
        putBoolean(R.string.pref_offlinewpmaps, offlineWpMaps);
    }

    static void setUseImperialUnits(final boolean imperial) {
        putBoolean(R.string.pref_units, imperial);
    }

    public static long getFieldnoteExportDate() {
        return getLong(R.string.pref_fieldnoteExportDate, 0);
    }

    public static void setFieldnoteExportDate(final long date) {
        putLong(R.string.pref_fieldnoteExportDate, date);
    }

}
!@#$%
20190527_002501,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_c20648
package cgeo.geocaching.settings;

import cgeo.geocaching.R;
import cgeo.geocaching.StoredList;
import cgeo.geocaching.cgeoapplication;
import cgeo.geocaching.apps.cache.navi.NavigationAppFactory.NavigationAppsEnum;
import cgeo.geocaching.connector.gc.GCConstants;
import cgeo.geocaching.connector.gc.Login;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.LiveMapStrategy.Strategy;
import cgeo.geocaching.enumerations.LogType;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.maps.MapProviderFactory;
import cgeo.geocaching.maps.google.GoogleMapProvider;
import cgeo.geocaching.maps.interfaces.GeoPointImpl;
import cgeo.geocaching.maps.interfaces.MapProvider;
import cgeo.geocaching.maps.interfaces.MapSource;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider.OfflineMapSource;
import cgeo.geocaching.utils.CryptUtils;
import cgeo.geocaching.utils.FileUtils;
import cgeo.geocaching.utils.FileUtils.FileSelector;
import cgeo.geocaching.utils.Log;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.os.Environment;
import android.preference.PreferenceManager;

import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

/**
 * General c:geo preferences/settings set by the user
 */
public final class Settings {

    public static final int SHOW_WP_THRESHOLD_DEFAULT = 5;
    public static final int SHOW_WP_THRESHOLD_MAX = 50;
    private static final int MAP_SOURCE_DEFAULT = GoogleMapProvider.GOOGLE_MAP_ID.hashCode();

    private final static int unitsMetric = 1;

    // twitter api keys
    private final static String keyConsumerPublic = CryptUtils.rot13("ESnsCvAv3kEupF1GCR3jGj");
    private final static String keyConsumerSecret = CryptUtils.rot13("7vQWceACV9umEjJucmlpFe9FCMZSeqIqfkQ2BnhV9x");

    public enum coordInputFormatEnum {
        Plain,
        Deg,
        Min,
        Sec;

        public static coordInputFormatEnum fromInt(int id) {
            final coordInputFormatEnum[] values = coordInputFormatEnum.values();
            if (id < 0 || id >= values.length) {
                return Min;
            }
            return values[id];
        }
    }

    private static final SharedPreferences sharedPrefs = PreferenceManager
            .getDefaultSharedPreferences(cgeoapplication.getInstance().getBaseContext());
    static {
        migrateSettings();
        Log.setDebug(sharedPrefs.getBoolean(getKey(R.string.pref_debug), false));
    }

    // maps
    private static MapProvider mapProvider = null;

    private Settings() {
        // this class is not to be instantiated;
    }

    private static void migrateSettings() {
        // migrate from non standard file location and integer based boolean types
        int oldVersion = getInt(R.string.pref_settingsversion, 0);
        if (oldVersion < 1) {
            final String oldPreferencesName = "cgeo.pref";
            final SharedPreferences old = cgeoapplication.getInstance().getSharedPreferences(oldPreferencesName, Context.MODE_PRIVATE);
            final Editor e = sharedPrefs.edit();

            e.putString(getKey(R.string.pref_temp_twitter_token_secret), old.getString(getKey(R.string.pref_temp_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_temp_twitter_token_public), old.getString(getKey(R.string.pref_temp_twitter_token_public), null));
            e.putBoolean(getKey(R.string.pref_help_shown), old.getInt(getKey(R.string.pref_help_shown), 0) != 0);
            e.putFloat(getKey(R.string.pref_anylongitude), old.getFloat(getKey(R.string.pref_anylongitude), 0));
            e.putFloat(getKey(R.string.pref_anylatitude), old.getFloat(getKey(R.string.pref_anylatitude), 0));
            e.putBoolean(getKey(R.string.pref_offlinemaps), 0 != old.getInt(getKey(R.string.pref_offlinemaps), 1));
            e.putBoolean(getKey(R.string.pref_offlinewpmaps), 0 != old.getInt(getKey(R.string.pref_offlinewpmaps), 0));
            e.putString(getKey(R.string.pref_webDeviceCode), old.getString(getKey(R.string.pref_webDeviceCode), null));
            e.putString(getKey(R.string.pref_webDeviceName), old.getString(getKey(R.string.pref_webDeviceName), null));
            e.putBoolean(getKey(R.string.pref_maplive), old.getInt(getKey(R.string.pref_maplive), 1) != 0);
            e.putInt(getKey(R.string.pref_mapsource), old.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT));
            e.putBoolean(getKey(R.string.pref_twitter), 0 != old.getInt(getKey(R.string.pref_twitter), 0));
            e.putBoolean(getKey(R.string.pref_showaddress), 0 != old.getInt(getKey(R.string.pref_showaddress), 1));
            e.putBoolean(getKey(R.string.pref_showcaptcha), old.getBoolean(getKey(R.string.pref_showcaptcha), false));
            e.putBoolean(getKey(R.string.pref_maptrail), old.getInt(getKey(R.string.pref_maptrail), 1) != 0);
            e.putInt(getKey(R.string.pref_lastmapzoom), old.getInt(getKey(R.string.pref_lastmapzoom), 14));
            e.putBoolean(getKey(R.string.pref_livelist), 0 != old.getInt(getKey(R.string.pref_livelist), 1));
            e.putBoolean(getKey(R.string.pref_units), old.getInt(getKey(R.string.pref_units), unitsMetric) == unitsMetric);
            e.putBoolean(getKey(R.string.pref_skin), old.getInt(getKey(R.string.pref_skin), 0) != 0);
            e.putInt(getKey(R.string.pref_lastusedlist), old.getInt(getKey(R.string.pref_lastusedlist), StoredList.STANDARD_LIST_ID));
            e.putString(getKey(R.string.pref_cachetype), old.getString(getKey(R.string.pref_cachetype), CacheType.ALL.id));
            e.putString(getKey(R.string.pref_twitter_token_secret), old.getString(getKey(R.string.pref_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_twitter_token_public), old.getString(getKey(R.string.pref_twitter_token_public), null));
            e.putInt(getKey(R.string.pref_version), old.getInt(getKey(R.string.pref_version), 0));
            e.putBoolean(getKey(R.string.pref_autoloaddesc), 0 != old.getInt(getKey(R.string.pref_autoloaddesc), 1));
            e.putBoolean(getKey(R.string.pref_ratingwanted), old.getBoolean(getKey(R.string.pref_ratingwanted), true));
            e.putBoolean(getKey(R.string.pref_friendlogswanted), old.getBoolean(getKey(R.string.pref_friendlogswanted), true));
            e.putBoolean(getKey(R.string.pref_useenglish), old.getBoolean(getKey(R.string.pref_useenglish), false));
            e.putBoolean(getKey(R.string.pref_usecompass), 0 != old.getInt(getKey(R.string.pref_usecompass), 1));
            e.putBoolean(getKey(R.string.pref_trackautovisit), old.getBoolean(getKey(R.string.pref_trackautovisit), false));
            e.putBoolean(getKey(R.string.pref_sigautoinsert), old.getBoolean(getKey(R.string.pref_sigautoinsert), false));
            e.putBoolean(getKey(R.string.pref_logimages), old.getBoolean(getKey(R.string.pref_logimages), false));
            e.putBoolean(getKey(R.string.pref_excludedisabled), 0 != old.getInt(getKey(R.string.pref_excludedisabled), 0));
            e.putBoolean(getKey(R.string.pref_excludemine), 0 != old.getInt(getKey(R.string.pref_excludemine), 0));
            e.putString(getKey(R.string.pref_mapfile), old.getString(getKey(R.string.pref_mapfile), null));
            e.putString(getKey(R.string.pref_signature), old.getString(getKey(R.string.pref_signature), null));
            e.putString(getKey(R.string.pref_pass_vote), old.getString(getKey(R.string.pref_pass_vote), null));
            e.putString(getKey(R.string.pref_password), old.getString(getKey(R.string.pref_password), null));
            e.putString(getKey(R.string.pref_username), old.getString(getKey(R.string.pref_username), null));
            e.putString(getKey(R.string.pref_memberstatus), old.getString(getKey(R.string.pref_memberstatus), ""));
            e.putInt(getKey(R.string.pref_coordinputformat), old.getInt(getKey(R.string.pref_coordinputformat), 0));
            e.putBoolean(getKey(R.string.pref_log_offline), old.getBoolean(getKey(R.string.pref_log_offline), false));
            e.putBoolean(getKey(R.string.pref_choose_list), old.getBoolean(getKey(R.string.pref_choose_list), false));
            e.putBoolean(getKey(R.string.pref_loaddirectionimg), old.getBoolean(getKey(R.string.pref_loaddirectionimg), true));
            e.putString(getKey(R.string.pref_gccustomdate), old.getString(getKey(R.string.pref_gccustomdate), null));
            e.putInt(getKey(R.string.pref_gcshowwaypointsthreshold), old.getInt(getKey(R.string.pref_gcshowwaypointsthreshold), 0));
            e.putString(getKey(R.string.pref_cookiestore), old.getString(getKey(R.string.pref_cookiestore), null));
            e.putBoolean(getKey(R.string.pref_opendetailslastpage), old.getBoolean(getKey(R.string.pref_opendetailslastpage), false));
            e.putInt(getKey(R.string.pref_lastdetailspage), old.getInt(getKey(R.string.pref_lastdetailspage), 1));
            e.putInt(getKey(R.string.pref_defaultNavigationTool), old.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id));
            e.putInt(getKey(R.string.pref_defaultNavigationTool2), old.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id));
            e.putInt(getKey(R.string.pref_livemapstrategy), old.getInt(getKey(R.string.pref_livemapstrategy), Strategy.AUTO.id));
            e.putBoolean(getKey(R.string.pref_debug), old.getBoolean(getKey(R.string.pref_debug), false));
            e.putBoolean(getKey(R.string.pref_hidelivemaphint), old.getInt(getKey(R.string.pref_hidelivemaphint), 0) != 0);
            e.putInt(getKey(R.string.pref_livemaphintshowcount), old.getInt(getKey(R.string.pref_livemaphintshowcount), 0));

            e.putInt(getKey(R.string.pref_settingsversion), 1); // mark migrated
            e.commit();
        }

        // changes for new settings dialog
        if (oldVersion < 2) {
            final Editor e = sharedPrefs.edit();

            e.putBoolean(getKey(R.string.pref_units), !isUseImperialUnits());

            // show waypoints threshold now as a slider
            int wpThreshold = getWayPointsThreshold();
            if (wpThreshold < 0) {
                wpThreshold = 0;
            } else if (wpThreshold > SHOW_WP_THRESHOLD_MAX) {
                wpThreshold = SHOW_WP_THRESHOLD_MAX;
            }
            e.putInt(getKey(R.string.pref_gcshowwaypointsthreshold), wpThreshold);

            // KEY_MAP_SOURCE must be string, because it is the key for a ListPreference now
            int ms = sharedPrefs.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT);
            e.remove(getKey(R.string.pref_mapsource));
            e.putString(getKey(R.string.pref_mapsource), String.valueOf(ms));

            // navigation tool ids must be string, because ListPreference uses strings as keys
            int dnt1 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id);
            int dnt2 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id);
            e.remove(getKey(R.string.pref_defaultNavigationTool));
            e.remove(getKey(R.string.pref_defaultNavigationTool2));
            e.putString(getKey(R.string.pref_defaultNavigationTool), String.valueOf(dnt1));
            e.putString(getKey(R.string.pref_defaultNavigationTool2), String.valueOf(dnt2));

            // defaults for gpx directories
            e.putString(getKey(R.string.pref_gpxImportDir), getGpxImportDir());
            e.putString(getKey(R.string.pref_gpxExportDir), getGpxExportDir());

            e.putInt(getKey(R.string.pref_settingsversion), 2); // mark migrated
            e.commit();
        }
    }

    private static String getKey(final int prefKeyId) {
        return cgeoapplication.getInstance().getString(prefKeyId);
    }

    static String getString(final int prefKeyId, final String defaultValue) {
        return sharedPrefs.getString(getKey(prefKeyId), defaultValue);
    }

    private static int getInt(final int prefKeyId, final int defaultValue) {
        return sharedPrefs.getInt(getKey(prefKeyId), defaultValue);
    }

    private static long getLong(final int prefKeyId, final long defaultValue) {
        return sharedPrefs.getLong(getKey(prefKeyId), defaultValue);
    }

    private static boolean getBoolean(final int prefKeyId, final boolean defaultValue) {
        return sharedPrefs.getBoolean(getKey(prefKeyId), defaultValue);
    }

    private static float getFloat(final int prefKeyId, final float defaultValue) {
        return sharedPrefs.getFloat(getKey(prefKeyId), defaultValue);
    }

    static boolean putString(final int prefKeyId, final String value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putString(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putBoolean(final int prefKeyId, final boolean value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putBoolean(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putInt(final int prefKeyId, final int value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putInt(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putLong(final int prefKeyId, final long value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putLong(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putFloat(final int prefKeyId, final float value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putFloat(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean remove(final int prefKeyId) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.remove(getKey(prefKeyId));
        return edit.commit();
    }

    private static boolean contains(final int prefKeyId) {
        return sharedPrefs.contains(getKey(prefKeyId));
    }

    public static void setLanguage(boolean useEnglish) {
        final Configuration config = new Configuration();
        config.locale = useEnglish ? Locale.ENGLISH : Locale.getDefault();
        final Resources resources = cgeoapplication.getInstance().getResources();
        resources.updateConfiguration(config, resources.getDisplayMetrics());
    }

    public static boolean isLogin() {
        final String preUsername = getString(R.string.pref_username, null);
        final String prePassword = getString(R.string.pref_password, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    /**
     * Get login and password information.
     *
     * @return a pair either with (login, password) or (empty, empty) if no valid information is stored
     */
    public static ImmutablePair<String, String> getGcLogin() {

        final String username = getString(R.string.pref_username, null);
        final String password = getString(R.string.pref_password, null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return new ImmutablePair<String, String>(StringUtils.EMPTY, StringUtils.EMPTY);
        }

        return new ImmutablePair<String, String>(username, password);
    }

    public static String getUsername() {
        return getString(R.string.pref_username, null);
    }

    public static boolean isGCConnectorActive() {
        return getBoolean(R.string.pref_connectorGCActive, true);
    }

    public static boolean isPremiumMember() {
        // Basic Member, Premium Member, ???
        String memberStatus = Settings.getMemberStatus();
        if (memberStatus == null) {
            return false;
        }
        return GCConstants.MEMBER_STATUS_PM.equalsIgnoreCase(memberStatus);
    }

    public static String getMemberStatus() {
        return getString(R.string.pref_memberstatus, "");
    }

    public static boolean setMemberStatus(final String memberStatus) {
        if (StringUtils.isBlank(memberStatus)) {
            return remove(R.string.pref_memberstatus);
        }
        return putString(R.string.pref_memberstatus, memberStatus);
    }

    public static ImmutablePair<String, String> getTokenPair(final int tokenPublicPrefKey, final int tokenSecretPrefKey) {
        return new ImmutablePair<String, String>(getString(tokenPublicPrefKey, null), getString(tokenSecretPrefKey, null));
    }

    public static void setTokens(final int tokenPublicPrefKey, final String tokenPublic, final int tokenSecretPrefKey, final String tokenSecret) {
        if (tokenPublic == null) {
            remove(tokenPublicPrefKey);
        } else {
            putString(tokenPublicPrefKey, tokenPublic);
        }
        if (tokenSecret == null) {
            remove(tokenSecretPrefKey);
        } else {
            putString(tokenSecretPrefKey, tokenSecret);
        }
    }

    public static boolean isOCConnectorActive(int isActivePrefKeyId) {
        return getBoolean(isActivePrefKeyId, false);
    }

    public static boolean hasOCAuthorization(int tokenPublicPrefKeyId, int tokenSecretPrefKeyId) {
        return StringUtils.isNotBlank(getString(tokenPublicPrefKeyId, ""))
                && StringUtils.isNotBlank(getString(tokenSecretPrefKeyId, ""));
    }

    public static boolean isGCvoteLogin() {
        final String preUsername = getString(R.string.pref_username, null);
        final String prePassword = getString(R.string.pref_pass_vote, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    public static ImmutablePair<String, String> getGCvoteLogin() {
        final String username = getString(R.string.pref_username, null);
        final String password = getString(R.string.pref_pass_vote, null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return null;
        }

        return new ImmutablePair<String, String>(username, password);
    }

    public static String getSignature() {
        return getString(R.string.pref_signature, null);
    }

    public static boolean setCookieStore(final String cookies) {
        if (StringUtils.isBlank(cookies)) {
            // erase cookies
            return remove(R.string.pref_cookiestore);
        }
        // save cookies
        return putString(R.string.pref_cookiestore, cookies);
    }

    public static String getCookieStore() {
        return getString(R.string.pref_cookiestore, null);
    }

    /**
     * @param cacheType
     *            The cache type used for future filtering
     */
    public static void setCacheType(final CacheType cacheType) {
        if (cacheType == null) {
            remove(R.string.pref_cachetype);
        } else {
            putString(R.string.pref_cachetype, cacheType.id);
        }
    }

    public static int getLastList() {
        return getInt(R.string.pref_lastusedlist, StoredList.STANDARD_LIST_ID);
    }

    public static void saveLastList(final int listId) {
        putInt(R.string.pref_lastusedlist, listId);
    }

    public static void setWebNameCode(final String name, final String code) {
        putString(R.string.pref_webDeviceName, name);
        putString(R.string.pref_webDeviceCode, code);
    }

    public static MapProvider getMapProvider() {
        if (mapProvider == null) {
            mapProvider = getMapSource().getMapProvider();
        }
        return mapProvider;
    }

    public static String getMapFile() {
        return getString(R.string.pref_mapfile, null);
    }

    public static boolean setMapFile(final String mapFile) {
        boolean result = putString(R.string.pref_mapfile, mapFile);
        if (mapFile != null) {
            setMapFileDirectory(new File(mapFile).getParent());
        }
        return result;
    }

    public static String getMapFileDirectory() {
        final String mapDir = getString(R.string.pref_mapDirectory, null);
        if (mapDir != null) {
            return mapDir;
        }
        final String mapFile = getMapFile();
        if (mapFile != null) {
            return new File(mapFile).getParent();
        }
        return null;
    }

    public static boolean setMapFileDirectory(final String mapFileDirectory) {
        boolean result = putString(R.string.pref_mapDirectory, mapFileDirectory);
        MapsforgeMapProvider.getInstance().updateOfflineMaps();
        return result;
    }

    public static boolean isValidMapFile() {
        return isValidMapFile(getMapFile());
    }

    public static boolean isValidMapFile(final String mapFileIn) {
        return MapsforgeMapProvider.isValidMapFile(mapFileIn);
    }

    public static coordInputFormatEnum getCoordInputFormat() {
        return coordInputFormatEnum.fromInt(getInt(R.string.pref_coordinputformat, 0));
    }

    public static void setCoordInputFormat(final coordInputFormatEnum format) {
        putInt(R.string.pref_coordinputformat, format.ordinal());
    }

    static void setLogOffline(final boolean offline) {
        putBoolean(R.string.pref_log_offline, offline);
    }

    public static boolean getLogOffline() {
        return getBoolean(R.string.pref_log_offline, false);
    }

    public static boolean getChooseList() {
        return getBoolean(R.string.pref_choose_list, false);
    }

    public static boolean getLoadDirImg() {
        return !isPremiumMember() && getBoolean(R.string.pref_loaddirectionimg, true);
    }

    public static void setGcCustomDate(final String format) {
        putString(R.string.pref_gccustomdate, format);
    }

    /**
     * @return User selected date format on GC.com
     * @see Login#gcCustomDateFormats
     */
    public static String getGcCustomDate() {
        return getString(R.string.pref_gccustomdate, null);
    }

    public static boolean isExcludeMyCaches() {
        return getBoolean(R.string.pref_excludemine, false);
    }

    public static void setUseEnglish(final boolean english) {
        putBoolean(R.string.pref_useenglish, english);
        setLanguage(english);
    }

    public static boolean isUseEnglish() {
        return getBoolean(R.string.pref_useenglish, false);
    }

    public static boolean isShowAddress() {
        return getBoolean(R.string.pref_showaddress, true);
    }

    public static boolean isShowCaptcha() {
        return !isPremiumMember() && getBoolean(R.string.pref_showcaptcha, false);
    }

    public static boolean isExcludeDisabledCaches() {
        return getBoolean(R.string.pref_excludedisabled, false);
    }

    public static boolean isStoreOfflineMaps() {
        return getBoolean(R.string.pref_offlinemaps, true);
    }

    public static boolean isStoreOfflineWpMaps() {
        return getBoolean(R.string.pref_offlinewpmaps, false);
    }

    public static boolean isStoreLogImages() {
        return getBoolean(R.string.pref_logimages, false);
    }

    public static boolean isAutoLoadDescription() {
        return getBoolean(R.string.pref_autoloaddesc, true);
    }

    public static boolean isRatingWanted() {
        return getBoolean(R.string.pref_ratingwanted, true);
    }

    public static boolean isFriendLogsWanted() {
        if (!isLogin()) {
            // don't show a friends log if the user is anonymous
            return false;
        }
        return getBoolean(R.string.pref_friendlogswanted, true);
    }

    public static boolean isLiveList() {
        return getBoolean(R.string.pref_livelist, true);
    }

    public static boolean isTrackableAutoVisit() {
        return getBoolean(R.string.pref_trackautovisit, false);
    }

    public static boolean isAutoInsertSignature() {
        return getBoolean(R.string.pref_sigautoinsert, false);
    }

    public static boolean isUseImperialUnits() {
        return getBoolean(R.string.pref_units, false);
    }

    public static boolean isLiveMap() {
        return getBoolean(R.string.pref_maplive, true);
    }

    public static void setLiveMap(final boolean live) {
        putBoolean(R.string.pref_maplive, live);
    }

    public static boolean isMapTrail() {
        return getBoolean(R.string.pref_maptrail, true);
    }

    public static void setMapTrail(final boolean showTrail) {
        putBoolean(R.string.pref_maptrail, showTrail);
    }

    public static int getMapZoom() {
        return getInt(R.string.pref_lastmapzoom, 14);
    }

    public static void setMapZoom(final int mapZoomLevel) {
        putInt(R.string.pref_lastmapzoom, mapZoomLevel);
    }

    public static GeoPointImpl getMapCenter() {
        return getMapProvider().getMapItemFactory()
                .getGeoPointBase(new Geopoint(getInt(R.string.pref_lastmaplat, 0) / 1e6,
                        getInt(R.string.pref_lastmaplon, 0) / 1e6));
    }

    public static void setMapCenter(final GeoPointImpl mapViewCenter) {
        putInt(R.string.pref_lastmaplat, mapViewCenter.getLatitudeE6());
        putInt(R.string.pref_lastmaplon, mapViewCenter.getLongitudeE6());
    }

    public static MapSource getMapSource() {
        final int id = getConvertedMapId();
        final MapSource map = MapProviderFactory.getMapSource(id);
        if (map != null) {
            // don't use offline maps if the map file is not valid
            if ((!(map instanceof OfflineMapSource)) || (isValidMapFile())) {
                return map;
            }
        }
        // fallback to first available map
        return MapProviderFactory.getDefaultSource();
    }

    private final static int GOOGLEMAP_BASEID = 30;
    private final static int MAP = 1;
    private final static int SATELLITE = 2;

    private final static int MFMAP_BASEID = 40;
    private final static int MAPNIK = 1;
    private final static int CYCLEMAP = 3;
    private final static int OFFLINE = 4;

    /**
     * convert old preference ids for maps (based on constant values) into new hash based ids
     *
     * @return
     */
    private static int getConvertedMapId() {
        // what the heck is happening here?? hashCodes of Strings?
        // why not strings?
        final int id = Integer.parseInt(getString(R.string.pref_mapsource,
                String.valueOf(MAP_SOURCE_DEFAULT)));
        switch (id) {
            case GOOGLEMAP_BASEID + MAP:
                return GoogleMapProvider.GOOGLE_MAP_ID.hashCode();
            case GOOGLEMAP_BASEID + SATELLITE:
                return GoogleMapProvider.GOOGLE_SATELLITE_ID.hashCode();
            case MFMAP_BASEID + MAPNIK:
                return MapsforgeMapProvider.MAPSFORGE_MAPNIK_ID.hashCode();
            case MFMAP_BASEID + CYCLEMAP:
                return MapsforgeMapProvider.MAPSFORGE_CYCLEMAP_ID.hashCode();
            case MFMAP_BASEID + OFFLINE: {
                final String mapFile = Settings.getMapFile();
                if (StringUtils.isNotEmpty(mapFile)) {
                    return mapFile.hashCode();
                }
                break;
            }
            default:
                break;
        }
        return id;
    }

    public static void setMapSource(final MapSource newMapSource) {
        if (!MapProviderFactory.isSameActivity(getMapSource(), newMapSource)) {
            mapProvider = null;
        }
        putString(R.string.pref_mapsource, String.valueOf(newMapSource.getNumericalId()));
        if (newMapSource instanceof OfflineMapSource) {
            setMapFile(((OfflineMapSource) newMapSource).getFileName());
        }
    }

    public static void setAnyCoordinates(final Geopoint coords) {
        if (null != coords) {
            putFloat(R.string.pref_anylatitude, (float) coords.getLatitude());
            putFloat(R.string.pref_anylatitude, (float) coords.getLongitude());
        } else {
            remove(R.string.pref_anylatitude);
            remove(R.string.pref_anylongitude);
        }
    }

    public static Geopoint getAnyCoordinates() {
        if (contains(R.string.pref_anylatitude) && contains(R.string.pref_anylongitude)) {
            float lat = getFloat(R.string.pref_anylatitude, 0);
            float lon = getFloat(R.string.pref_anylongitude, 0);
            return new Geopoint(lat, lon);
        }
        return null;
    }

    public static boolean isUseCompass() {
        return getBoolean(R.string.pref_usecompass, true);
    }

    public static void setUseCompass(final boolean useCompass) {
        putBoolean(R.string.pref_usecompass, useCompass);
    }

    public static boolean isLightSkin() {
        return getBoolean(R.string.pref_skin, false);
    }

    public static String getKeyConsumerPublic() {
        return keyConsumerPublic;
    }

    public static String getKeyConsumerSecret() {
        return keyConsumerSecret;
    }

    public static String getWebDeviceCode() {
        return getString(R.string.pref_webDeviceCode, null);
    }

    public static String getWebDeviceName() {
        return getString(R.string.pref_webDeviceName, android.os.Build.MODEL);
    }

    /**
     * @return The cache type used for filtering or ALL if no filter is active.
     *         Returns never null
     */
    public static CacheType getCacheType() {
        return CacheType.getById(getString(R.string.pref_cachetype, CacheType.ALL.id));
    }

    /**
     * The Threshold for the showing of child waypoints
     */
    public static int getWayPointsThreshold() {
        return getInt(R.string.pref_gcshowwaypointsthreshold, SHOW_WP_THRESHOLD_DEFAULT);
    }

    public static void setShowWaypointsThreshold(final int threshold) {
        putInt(R.string.pref_gcshowwaypointsthreshold, threshold);
    }

    public static boolean isUseTwitter() {
        return getBoolean(R.string.pref_twitter, false);
    }

    public static void setUseTwitter(final boolean useTwitter) {
        putBoolean(R.string.pref_twitter, useTwitter);
    }

    public static boolean isTwitterLoginValid() {
        return !StringUtils.isBlank(getTokenPublic())
                && !StringUtils.isBlank(getTokenSecret());
    }

    public static String getTokenPublic() {
        return getString(R.string.pref_twitter_token_public, null);
    }

    public static String getTokenSecret() {
        return getString(R.string.pref_twitter_token_secret, null);

    }

    public static boolean hasTwitterAuthorization() {
        return StringUtils.isNotBlank(getTokenPublic())
                && StringUtils.isNotBlank(getTokenSecret());
    }

    public static void setTwitterTokens(final String tokenPublic,
            final String tokenSecret, boolean enableTwitter) {
        putString(R.string.pref_twitter_token_public, tokenPublic);
        putString(R.string.pref_twitter_token_secret, tokenSecret);
        if (tokenPublic != null) {
            remove(R.string.pref_temp_twitter_token_public);
            remove(R.string.pref_temp_twitter_token_secret);
        }
        setUseTwitter(enableTwitter);
    }

    public static void setTwitterTempTokens(final String tokenPublic,
            final String tokenSecret) {
        putString(R.string.pref_temp_twitter_token_public, tokenPublic);
        putString(R.string.pref_temp_twitter_token_secret, tokenSecret);
    }

    public static ImmutablePair<String, String> getTempToken() {
        String tokenPublic = getString(R.string.pref_temp_twitter_token_public, null);
        String tokenSecret = getString(R.string.pref_temp_twitter_token_secret, null);
        return new ImmutablePair<String, String>(tokenPublic, tokenSecret);
    }

    public static int getVersion() {
        return getInt(R.string.pref_version, 0);
    }

    public static void setVersion(final int version) {
        putInt(R.string.pref_version, version);
    }

    public static boolean isOpenLastDetailsPage() {
        return getBoolean(R.string.pref_opendetailslastpage, false);
    }

    public static int getLastDetailsPage() {
        return getInt(R.string.pref_lastdetailspage, 1);
    }

    public static void setLastDetailsPage(final int index) {
        putInt(R.string.pref_lastdetailspage, index);
    }

    public static int getDefaultNavigationTool() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool,
                String.valueOf(NavigationAppsEnum.COMPASS.id)));
    }

    public static void setDefaultNavigationTool(final int defaultNavigationTool) {
        putString(R.string.pref_defaultNavigationTool,
                String.valueOf(defaultNavigationTool));
    }

    public static int getDefaultNavigationTool2() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool2,
                String.valueOf(NavigationAppsEnum.INTERNAL_MAP.id)));
    }

    public static void setDefaultNavigationTool2(final int defaultNavigationTool) {
        putString(R.string.pref_defaultNavigationTool2,
                String.valueOf(defaultNavigationTool));
    }

    public static Strategy getLiveMapStrategy() {
        return Strategy.getById(getInt(R.string.pref_livemapstrategy, Strategy.AUTO.id));
    }

    public static void setLiveMapStrategy(final Strategy strategy) {
        putInt(R.string.pref_livemapstrategy, strategy.id);
    }

    public static boolean isDebug() {
        return Log.isDebug();
    }

    public static boolean getHideLiveMapHint() {
        return getBoolean(R.string.pref_hidelivemaphint, false);
    }

    public static void setHideLiveHint(final boolean hide) {
        putBoolean(R.string.pref_hidelivemaphint, hide);
    }

    public static int getLiveMapHintShowCount() {
        return getInt(R.string.pref_livemaphintshowcount, 0);
    }

    public static void setLiveMapHintShowCount(final int showCount) {
        putInt(R.string.pref_livemaphintshowcount, showCount);
    }

    public static boolean isDbOnSDCard() {
        return getBoolean(R.string.pref_dbonsdcard, false);
    }

    public static void setDbOnSDCard(final boolean dbOnSDCard) {
        putBoolean(R.string.pref_dbonsdcard, dbOnSDCard);
    }

    public static String getGpxExportDir() {
        return getString(R.string.pref_gpxExportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static String getGpxImportDir() {
        return getString(R.string.pref_gpxImportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static boolean getShareAfterExport() {
        return getBoolean(R.string.pref_shareafterexport, true);
    }

    public static void setShareAfterExport(final boolean shareAfterExport) {
        putBoolean(R.string.pref_shareafterexport, shareAfterExport);
    }

    public static int getTrackableAction() {
        return getInt(R.string.pref_trackableaction, LogType.RETRIEVED_IT.id);
    }

    public static void setTrackableAction(final int trackableAction) {
        putInt(R.string.pref_trackableaction, trackableAction);
    }

    public static String getCustomRenderThemeBaseFolder() {
        return getString(R.string.pref_renderthemepath, "");
    }

    public static String getCustomRenderThemeFilePath() {
        return getString(R.string.pref_renderthemefile, "");
    }

    public static void setCustomRenderThemeFile(final String customRenderThemeFile) {
        putString(R.string.pref_renderthemefile, customRenderThemeFile);
    }

    public static File[] getMapThemeFiles() {
        File directory = new File(Settings.getCustomRenderThemeBaseFolder());
        List<File> result = new ArrayList<File>();
        FileUtils.listDir(result, directory, new ExtensionsBasedFileSelector(new String[] { "xml" }), null);

        return result.toArray(new File[result.size()]);
    }

    private static class ExtensionsBasedFileSelector extends FileSelector {
        private final String[] extensions;
        public ExtensionsBasedFileSelector(String[] extensions) {
            this.extensions = extensions;
        }
        @Override
        public boolean isSelected(File file) {
            String filename = file.getName();
            for (String ext : extensions) {
                if (StringUtils.endsWithIgnoreCase(filename, ext)) {
                    return true;
                }
            }
            return false;
        }
        @Override
        public boolean shouldEnd() {
            return false;
        }
    }

    public static boolean getPlainLogs() {
        return getBoolean(R.string.pref_plainLogs, false);
    }

    public static boolean getUseNativeUa() {
        return getBoolean(R.string.pref_nativeUa, false);
    }

    public static String getCacheTwitterMessage() {
        // TODO make customizable from UI
        return "I found [NAME] ([URL])";
    }

    public static String getTrackableTwitterMessage() {
        // TODO make customizable from UI
        return "I touched [NAME] ([URL])!";
    }

    public static int getLogImageScale() {
        return getInt(R.string.pref_logImageScale, -1);
    }

    public static void setLogImageScale(final int scale) {
        putInt(R.string.pref_logImageScale, scale);
    }

    // Only for tests!
    static void setExcludeDisabledCaches(final boolean exclude) {
        putBoolean(R.string.pref_excludedisabled, exclude);
    }

    public static void setExcludeMine(final boolean exclude) {
        putBoolean(R.string.pref_excludemine, exclude);
    }

    static boolean setLogin(final String username, final String password) {

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            // erase username and password
            boolean a = remove(R.string.pref_username);
            boolean b = remove(R.string.pref_password);
            return a && b;
        }
        // save username and password
        boolean a = putString(R.string.pref_username, username);
        boolean b = putString(R.string.pref_password, password);
        return a && b;
    }

    static void setStoreOfflineMaps(final boolean offlineMaps) {
        putBoolean(R.string.pref_offlinemaps, offlineMaps);
    }

    static void setStoreOfflineWpMaps(final boolean offlineWpMaps) {
        putBoolean(R.string.pref_offlinewpmaps, offlineWpMaps);
    }

    static void setUseImperialUnits(final boolean imperial) {
        putBoolean(R.string.pref_units, imperial);
    }

    public static long getFieldnoteExportDate() {
        return getLong(R.string.pref_fieldnoteExportDate, 0);
    }

    public static void setFieldnoteExportDate(final long date) {
        putLong(R.string.pref_fieldnoteExportDate, date);
    }
}
!@#$%
20190527_002508,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_b20648
package cgeo.geocaching.connector.oc;

import cgeo.geocaching.Geocache;
import cgeo.geocaching.Image;
import cgeo.geocaching.LogEntry;
import cgeo.geocaching.R;
import cgeo.geocaching.Waypoint;
import cgeo.geocaching.cgData;
import cgeo.geocaching.cgeoapplication;
import cgeo.geocaching.connector.ConnectorFactory;
import cgeo.geocaching.connector.IConnector;
import cgeo.geocaching.connector.LogResult;
import cgeo.geocaching.connector.gc.GCConnector;
import cgeo.geocaching.connector.oc.OCApiConnector.ApiSupport;
import cgeo.geocaching.connector.oc.OCApiConnector.OAuthLevel;
import cgeo.geocaching.connector.oc.UserInfo.UserInfoStatus;
import cgeo.geocaching.enumerations.CacheAttribute;
import cgeo.geocaching.enumerations.CacheSize;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.LoadFlags.SaveFlag;
import cgeo.geocaching.enumerations.LogType;
import cgeo.geocaching.enumerations.StatusCode;
import cgeo.geocaching.enumerations.WaypointType;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.geopoint.GeopointFormatter;
import cgeo.geocaching.geopoint.Viewport;
import cgeo.geocaching.network.Network;
import cgeo.geocaching.network.OAuth;
import cgeo.geocaching.network.Parameters;
import cgeo.geocaching.settings.Settings;
import cgeo.geocaching.utils.Log;

import org.apache.commons.lang3.StringUtils;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import android.net.Uri;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Date;
import java.util.EnumSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.TimeZone;

final class OkapiClient {

    private static final char SEPARATOR = '|';
    private static final String SEPARATOR_STRING = Character.toString(SEPARATOR);
    private static final SimpleDateFormat LOG_DATE_FORMAT;
    static {
        LOG_DATE_FORMAT = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSSZ", Locale.US);
        LOG_DATE_FORMAT.setTimeZone(TimeZone.getTimeZone("UTC"));
    }
    private static final SimpleDateFormat ISO8601DATEFORMAT = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ", Locale.getDefault());

    private static final String CACHE_ATTRNAMES = "attrnames";
    private static final String WPT_LOCATION = "location";
    private static final String WPT_DESCRIPTION = "description";
    private static final String WPT_TYPE = "type";
    private static final String WPT_NAME = "name";
    private static final String CACHE_IS_WATCHED = "is_watched";
    private static final String CACHE_WPTS = "alt_wpts";
    private static final String CACHE_STATUS_ARCHIVED = "Archived";
    private static final String CACHE_STATUS_DISABLED = "Temporarily unavailable";
    private static final String CACHE_IS_FOUND = "is_found";
    private static final String CACHE_SIZE = "size";
    private static final String CACHE_VOTES = "rating_votes";
    private static final String CACHE_NOTFOUNDS = "notfounds";
    private static final String CACHE_FOUNDS = "founds";
    private static final String CACHE_HIDDEN = "date_hidden";
    private static final String CACHE_LATEST_LOGS = "latest_logs";
    private static final String CACHE_IMAGE_URL = "url";
    private static final String CACHE_IMAGE_CAPTION = "caption";
    private static final String CACHE_IMAGE_IS_SPOILER = "is_spoiler";
    private static final String CACHE_IMAGES = "images";
    private static final String CACHE_HINT = "hint";
    private static final String CACHE_DESCRIPTION = "description";
    private static final String CACHE_RECOMMENDATIONS = "recommendations";
    private static final String CACHE_RATING = "rating";
    private static final String CACHE_TERRAIN = "terrain";
    private static final String CACHE_DIFFICULTY = "difficulty";
    private static final String CACHE_OWNER = "owner";
    private static final String CACHE_STATUS = "status";
    private static final String CACHE_TYPE = "type";
    private static final String CACHE_LOCATION = "location";
    private static final String CACHE_NAME = "name";
    private static final String CACHE_CODE = "code";
    private static final String CACHE_REQ_PASSWORD = "req_passwd";
    private static final String CACHE_MY_NOTES = "my_notes";

    private static final String LOG_TYPE = "type";
    private static final String LOG_COMMENT = "comment";
    private static final String LOG_DATE = "date";
    private static final String LOG_USER = "user";

    private static final String USER_USERNAME = "username";
    private static final String USER_CACHES_FOUND = "caches_found";
    private static final String USER_INFO_FIELDS = "username|caches_found";

    // the several realms of possible fields for cache retrieval:
    // Core: for livemap requests (L3 - only with level 3 auth)
    // Additional: additional fields for full cache (L3 - only for level 3 auth, current - only for connectors with current api)
    private static final String SERVICE_CACHE_CORE_FIELDS = "code|name|location|type|status|difficulty|terrain|size";
    private static final String SERVICE_CACHE_CORE_L3_FIELDS = "is_found";
    private static final String SERVICE_CACHE_ADDITIONAL_FIELDS = "owner|founds|notfounds|rating|rating_votes|recommendations|description|hint|images|latest_logs|date_hidden|alt_wpts|attrnames|req_passwd";
    private static final String SERVICE_CACHE_ADDITIONAL_CURRENT_FIELDS = "gc_code|attribution_note";
    private static final String SERVICE_CACHE_ADDITIONAL_L3_FIELDS = "is_watched|my_notes";

    private static final String METHOD_SEARCH_NEAREST = "services/caches/search/nearest";
    private static final String METHOD_SEARCH_BBOX = "services/caches/search/bbox";
    private static final String METHOD_RETRIEVE_CACHES = "services/caches/geocaches";

    public static Geocache getCache(final String geoCode) {
        final Parameters params = new Parameters("cache_code", geoCode);
        final IConnector connector = ConnectorFactory.getConnector(geoCode);
        if (!(connector instanceof OCApiConnector)) {
            return null;
        }

        final OCApiConnector ocapiConn = (OCApiConnector) connector;

        params.add("fields", getFullFields(ocapiConn));
        params.add("attribution_append", "none");

        final JSONObject data = request(ocapiConn, OkapiService.SERVICE_CACHE, params);

        if (data == null) {
            return null;
        }

        return parseCache(data);
    }

    public static List<Geocache> getCachesAround(final Geopoint center, final OCApiConnector connector) {
        final String centerString = GeopointFormatter.format(GeopointFormatter.Format.LAT_DECDEGREE_RAW, center) + SEPARATOR + GeopointFormatter.format(GeopointFormatter.Format.LON_DECDEGREE_RAW, center);
        final Parameters params = new Parameters("search_method", METHOD_SEARCH_NEAREST);
        final Map<String, String> valueMap = new LinkedHashMap<String, String>();
        valueMap.put("center", centerString);
        valueMap.put("limit", "20");

        return requestCaches(connector, params, valueMap);
    }

    private static List<Geocache> requestCaches(final OCApiConnector connector, final Parameters params, final Map<String, String> valueMap) {
        addFilterParams(valueMap, connector);
        params.add("search_params", new JSONObject(valueMap).toString());
        addRetrieveParams(params, connector);

        final JSONObject data = request(connector, OkapiService.SERVICE_SEARCH_AND_RETRIEVE, params);

        if (data == null) {
            return Collections.emptyList();
        }

        return parseCaches(data);
    }

    // Assumes level 3 OAuth
    public static List<Geocache> getCachesBBox(final Viewport viewport, final OCApiConnector connector) {

        if (viewport.getLatitudeSpan() == 0 || viewport.getLongitudeSpan() == 0) {
            return Collections.emptyList();
        }

        final String bboxString = GeopointFormatter.format(GeopointFormatter.Format.LAT_DECDEGREE_RAW, viewport.bottomLeft)
                + SEPARATOR + GeopointFormatter.format(GeopointFormatter.Format.LON_DECDEGREE_RAW, viewport.bottomLeft)
                + SEPARATOR + GeopointFormatter.format(GeopointFormatter.Format.LAT_DECDEGREE_RAW, viewport.topRight)
                + SEPARATOR + GeopointFormatter.format(GeopointFormatter.Format.LON_DECDEGREE_RAW, viewport.topRight);
        final Parameters params = new Parameters("search_method", METHOD_SEARCH_BBOX);
        final Map<String, String> valueMap = new LinkedHashMap<String, String>();
        valueMap.put("bbox", bboxString);

        return requestCaches(connector, params, valueMap);
    }

    public static boolean setWatchState(final Geocache cache, final boolean watched, final OCApiConnector connector) {
        final Parameters params = new Parameters("cache_code", cache.getGeocode());
        params.add("watched", watched ? "true" : "false");

        final JSONObject data = request(connector, OkapiService.SERVICE_MARK_CACHE, params);

        if (data == null) {
            return false;
        }

        cache.setOnWatchlist(watched);

        return true;
    }

    public static LogResult postLog(final Geocache cache, final LogType logType, final Calendar date, final String log, final String logPassword, final OCApiConnector connector) {
        final Parameters params = new Parameters("cache_code", cache.getGeocode());
        params.add("logtype", logType.oc_type);
        params.add("comment", log);
        params.add("comment_format", "plaintext");
        params.add("when", LOG_DATE_FORMAT.format(date.getTime()));
        if (logType.equals(LogType.NEEDS_MAINTENANCE)) {
            params.add("needs_maintenance", "true");
        }
        if (logPassword != null) {
            params.add("password", logPassword);
        }

        final JSONObject data = request(connector, OkapiService.SERVICE_SUBMIT_LOG, params);

        if (data == null) {
            return new LogResult(StatusCode.LOG_POST_ERROR, "");
        }

        try {
            if (data.getBoolean("success")) {
                return new LogResult(StatusCode.NO_ERROR, data.getString("log_uuid"));
            }

            return new LogResult(StatusCode.LOG_POST_ERROR, "");
        } catch (final JSONException e) {
            Log.e("OkapiClient.postLog", e);
        }
        return new LogResult(StatusCode.LOG_POST_ERROR, "");
    }

    private static List<Geocache> parseCaches(final JSONObject response) {
        try {
            // Check for empty result
            final String result = response.getString("results");
            if (StringUtils.isBlank(result) || StringUtils.equals(result, "[]")) {
                return Collections.emptyList();
            }

            // Get and iterate result list
            final JSONObject cachesResponse = response.getJSONObject("results");
            if (cachesResponse != null) {
                final List<Geocache> caches = new ArrayList<Geocache>(cachesResponse.length());
                @SuppressWarnings("unchecked")
                final
                Iterator<String> keys = cachesResponse.keys();
                while (keys.hasNext()) {
                    final String key = keys.next();
                    final Geocache cache = parseSmallCache(cachesResponse.getJSONObject(key));
                    caches.add(cache);
                }
                return caches;
            }
        } catch (final JSONException e) {
            Log.e("OkapiClient.parseCachesResult", e);
        }
        return Collections.emptyList();
    }

    private static Geocache parseSmallCache(final JSONObject response) {
        final Geocache cache = new Geocache();
        cache.setReliableLatLon(true);
        try {

            parseCoreCache(response, cache);

            cgData.saveCache(cache, EnumSet.of(SaveFlag.SAVE_CACHE));
        } catch (final JSONException e) {
            Log.e("OkapiClient.parseSmallCache", e);
        }
        return cache;
    }

    private static Geocache parseCache(final JSONObject response) {
        final Geocache cache = new Geocache();
        cache.setReliableLatLon(true);
        try {

            parseCoreCache(response, cache);

            // not used: url
            final JSONObject owner = response.getJSONObject(CACHE_OWNER);
            cache.setOwnerDisplayName(parseUser(owner));

            cache.getLogCounts().put(LogType.FOUND_IT, response.getInt(CACHE_FOUNDS));
            cache.getLogCounts().put(LogType.DIDNT_FIND_IT, response.getInt(CACHE_NOTFOUNDS));

            if (!response.isNull(CACHE_RATING)) {
                cache.setRating((float) response.getDouble(CACHE_RATING));
            }
            cache.setVotes(response.getInt(CACHE_VOTES));

            cache.setFavoritePoints(response.getInt(CACHE_RECOMMENDATIONS));
            // not used: req_password
            // Prepend gc-link to description if available
            final StringBuilder description = new StringBuilder(500);
            if (!response.isNull("gc_code")) {
                final String gccode = response.getString("gc_code");
                description.append(cgeoapplication.getInstance().getResources()
                        .getString(R.string.cache_listed_on, GCConnector.getInstance().getName()))
                        .append(": <a href=\"http://coord.info/")
                        .append(gccode)
                        .append("\">")
                        .append(gccode)
                        .append("</a><br /><br />");
            }
            description.append(response.getString(CACHE_DESCRIPTION));
            cache.setDescription(description.toString());

            // currently the hint is delivered as HTML (contrary to OKAPI documentation), so we can store it directly
            cache.setHint(response.getString(CACHE_HINT));
            // not used: hints

            final JSONArray images = response.getJSONArray(CACHE_IMAGES);
            if (images != null) {
                for (int i = 0; i < images.length(); i++) {
                    final JSONObject imageResponse = images.getJSONObject(i);
                    if (imageResponse.getBoolean(CACHE_IMAGE_IS_SPOILER)) {
                        final String title = imageResponse.getString(CACHE_IMAGE_CAPTION);
                        final String url = absoluteUrl(imageResponse.getString(CACHE_IMAGE_URL), cache.getGeocode());
                        cache.addSpoiler(new Image(url, title));
                    }
                }
            }

            cache.setAttributes(parseAttributes(response.getJSONArray(CACHE_ATTRNAMES)));
            cache.setLogs(parseLogs(response.getJSONArray(CACHE_LATEST_LOGS)));
            cache.setHidden(parseDate(response.getString(CACHE_HIDDEN)));
            //TODO: Store license per cache
            //cache.setLicense(response.getString("attribution_note"));
            cache.setWaypoints(parseWaypoints(response.getJSONArray(CACHE_WPTS)), false);
            if (!response.isNull(CACHE_IS_WATCHED)) {
                cache.setOnWatchlist(response.getBoolean(CACHE_IS_WATCHED));
            }
            if (!response.isNull(CACHE_MY_NOTES)) {
                cache.setPersonalNote(response.getString(CACHE_MY_NOTES));
            }
            cache.setLogPasswordRequired(response.getBoolean(CACHE_REQ_PASSWORD));

            cache.setDetailedUpdatedNow();
            // save full detailed caches
            cgData.saveCache(cache, EnumSet.of(SaveFlag.SAVE_DB));
        } catch (final JSONException e) {
            Log.e("OkapiClient.parseCache", e);
        }
        return cache;
    }

    private static void parseCoreCache(final JSONObject response, final Geocache cache) throws JSONException {
        cache.setGeocode(response.getString(CACHE_CODE));
        cache.setName(response.getString(CACHE_NAME));
        // not used: names
        setLocation(cache, response.getString(CACHE_LOCATION));
        cache.setType(getCacheType(response.getString(CACHE_TYPE)));

        final String status = response.getString(CACHE_STATUS);
        cache.setDisabled(status.equalsIgnoreCase(CACHE_STATUS_DISABLED));
        cache.setArchived(status.equalsIgnoreCase(CACHE_STATUS_ARCHIVED));

        cache.setSize(getCacheSize(response));
        cache.setDifficulty((float) response.getDouble(CACHE_DIFFICULTY));
        cache.setTerrain((float) response.getDouble(CACHE_TERRAIN));

        if (!response.isNull(CACHE_IS_FOUND)) {
            cache.setFound(response.getBoolean(CACHE_IS_FOUND));
        }
    }

    private static String absoluteUrl(final String url, final String geocode) {
        final Uri uri = Uri.parse(url);

        if (!uri.isAbsolute()) {
            final IConnector connector = ConnectorFactory.getConnector(geocode);
            final String host = connector.getHost();
            if (StringUtils.isNotBlank(host)) {
                return "http://" + host + "/" + url;
            }
        }
        return url;
    }

    private static String parseUser(final JSONObject user) throws JSONException {
        return user.getString(USER_USERNAME);
    }

    private static List<LogEntry> parseLogs(final JSONArray logsJSON) {
        List<LogEntry> result = null;
        for (int i = 0; i < logsJSON.length(); i++) {
            try {
                final JSONObject logResponse = logsJSON.getJSONObject(i);
                final LogEntry log = new LogEntry(
                        parseUser(logResponse.getJSONObject(LOG_USER)),
                        parseDate(logResponse.getString(LOG_DATE)).getTime(),
                        parseLogType(logResponse.getString(LOG_TYPE)),
                        logResponse.getString(LOG_COMMENT).trim());
                if (result == null) {
                    result = new ArrayList<LogEntry>();
                }
                result.add(log);
            } catch (final JSONException e) {
                Log.e("OkapiClient.parseLogs", e);
            }
        }
        return result;
    }

    private static List<Waypoint> parseWaypoints(final JSONArray wptsJson) {
        List<Waypoint> result = null;
        for (int i = 0; i < wptsJson.length(); i++) {
            try {
                final JSONObject wptResponse = wptsJson.getJSONObject(i);
                final Waypoint wpt = new Waypoint(wptResponse.getString(WPT_NAME),
                        parseWptType(wptResponse.getString(WPT_TYPE)),
                        false);
                wpt.setNote(wptResponse.getString(WPT_DESCRIPTION));
                final Geopoint pt = parseCoords(wptResponse.getString(WPT_LOCATION));
                if (pt != null) {
                    wpt.setCoords(pt);
                }
                if (result == null) {
                    result = new ArrayList<Waypoint>();
                }
                result.add(wpt);
            } catch (final JSONException e) {
                Log.e("OkapiClient.parseWaypoints", e);
            }
        }
        return result;
    }

    private static LogType parseLogType(final String logType) {
        if ("Found it".equalsIgnoreCase(logType)) {
            return LogType.FOUND_IT;
        }
        if ("Didn't find it".equalsIgnoreCase(logType)) {
            return LogType.DIDNT_FIND_IT;
        }
        return LogType.NOTE;
    }

    private static WaypointType parseWptType(final String wptType) {
        if ("parking".equalsIgnoreCase(wptType)) {
            return WaypointType.PARKING;
        }
        if ("path".equalsIgnoreCase(wptType)) {
            return WaypointType.TRAILHEAD;
        }
        if ("stage".equalsIgnoreCase(wptType)) {
            return WaypointType.STAGE;
        }
        if ("physical-stage".equalsIgnoreCase(wptType)) {
            return WaypointType.STAGE;
        }
        if ("virtual-stage".equalsIgnoreCase(wptType)) {
            return WaypointType.PUZZLE;
        }
        if ("final".equalsIgnoreCase(wptType)) {
            return WaypointType.FINAL;
        }
        if ("poi".equalsIgnoreCase(wptType)) {
            return WaypointType.TRAILHEAD;
        }
        return WaypointType.WAYPOINT;
    }

    private static Date parseDate(final String date) {
        final String strippedDate = date.replaceAll("\\+0([0-9]){1}\\:00", "+0$100");
        try {
            return ISO8601DATEFORMAT.parse(strippedDate);
        } catch (final ParseException e) {
            Log.e("OkapiClient.parseDate", e);
        }
        return null;
    }

    private static Geopoint parseCoords(final String location) {
        final String latitude = StringUtils.substringBefore(location, SEPARATOR_STRING);
        final String longitude = StringUtils.substringAfter(location, SEPARATOR_STRING);
        if (StringUtils.isNotBlank(latitude) && StringUtils.isNotBlank(longitude)) {
            return new Geopoint(latitude, longitude);
        }

        return null;
    }

    private static List<String> parseAttributes(final JSONArray nameList) {

        final List<String> result = new ArrayList<String>();

        for (int i = 0; i < nameList.length(); i++) {
            try {
                final String name = nameList.getString(i);
                final CacheAttribute attr = CacheAttribute.getByOcId(AttributeParser.getOcDeId(name));

                if (attr != null) {
                    result.add(attr.rawName);
                }
            } catch (final JSONException e) {
                Log.e("OkapiClient.parseAttributes", e);
            }
        }

        return result;
    }

    private static void setLocation(final Geocache cache, final String location) {
        final String latitude = StringUtils.substringBefore(location, SEPARATOR_STRING);
        final String longitude = StringUtils.substringAfter(location, SEPARATOR_STRING);
        cache.setCoords(new Geopoint(latitude, longitude));
    }

    private static CacheSize getCacheSize(final JSONObject response) {
        if (response.isNull(CACHE_SIZE)) {
            return CacheSize.NOT_CHOSEN;
        }
        double size = 0;
        try {
            size = response.getDouble(CACHE_SIZE);
        } catch (final JSONException e) {
            Log.e("OkapiClient.getCacheSize", e);
        }
        switch ((int) Math.round(size)) {
            case 1:
                return CacheSize.MICRO;
            case 2:
                return CacheSize.SMALL;
            case 3:
                return CacheSize.REGULAR;
            case 4:
                return CacheSize.LARGE;
            case 5:
                return CacheSize.LARGE;
            default:
                break;
        }
        return CacheSize.NOT_CHOSEN;
    }

    private static CacheType getCacheType(final String cacheType) {
        if (cacheType.equalsIgnoreCase("Traditional")) {
            return CacheType.TRADITIONAL;
        }
        if (cacheType.equalsIgnoreCase("Multi")) {
            return CacheType.MULTI;
        }
        if (cacheType.equalsIgnoreCase("Quiz")) {
            return CacheType.MYSTERY;
        }
        if (cacheType.equalsIgnoreCase("Virtual")) {
            return CacheType.VIRTUAL;
        }
        if (cacheType.equalsIgnoreCase("Event")) {
            return CacheType.EVENT;
        }
        if (cacheType.equalsIgnoreCase("Webcam")) {
            return CacheType.WEBCAM;
        }
        if (cacheType.equalsIgnoreCase("Math/Physics")) {
            return CacheType.MYSTERY;
        }
        if (cacheType.equalsIgnoreCase("Drive-In")) {
            return CacheType.TRADITIONAL;
        }
        return CacheType.UNKNOWN;
    }

    private static String getCoreFields(final OCApiConnector connector) {
        if (connector == null) {
            Log.e("OkapiClient.getCoreFields called with invalid connector");
            return StringUtils.EMPTY;
        }

        if (connector.getSupportedAuthLevel() == OAuthLevel.Level3) {
            return SERVICE_CACHE_CORE_FIELDS + SEPARATOR + SERVICE_CACHE_CORE_L3_FIELDS;
        }

        return SERVICE_CACHE_CORE_FIELDS;
    }

    private static String getFullFields(final OCApiConnector connector) {
        if (connector == null) {
            Log.e("OkapiClient.getFullFields called with invalid connector");
            return StringUtils.EMPTY;
        }

        final StringBuilder res = new StringBuilder(500);

        res.append(SERVICE_CACHE_CORE_FIELDS);
        res.append(SEPARATOR).append(SERVICE_CACHE_ADDITIONAL_FIELDS);
        if (connector.getSupportedAuthLevel() == OAuthLevel.Level3) {
            res.append(SEPARATOR).append(SERVICE_CACHE_CORE_L3_FIELDS);
            res.append(SEPARATOR).append(SERVICE_CACHE_ADDITIONAL_L3_FIELDS);
        }
        if (connector.getApiSupport() == ApiSupport.current) {
            res.append(SEPARATOR).append(SERVICE_CACHE_ADDITIONAL_CURRENT_FIELDS);
        }

        return res.toString();
    }

    private static JSONObject request(final OCApiConnector connector, final OkapiService service, final Parameters params) {
        if (connector == null) {
            return null;
        }

        final String host = connector.getHost();
        if (StringUtils.isBlank(host)) {
            return null;
        }

        params.add("langpref", getPreferredLanguage());

        if (connector.getSupportedAuthLevel() == OAuthLevel.Level3) {
            OAuth.signOAuth(host, service.methodName, "GET", false, params, Settings.getOCDETokenPublic(), Settings.getOCDETokenSecret(), connector.getCK(), connector.getCS());
        } else {
            connector.addAuthentication(params);
        }

        final String uri = "http://" + host + service.methodName;
        return Network.requestJSON(uri, params);
    }

    private static String getPreferredLanguage() {
        final String code = Locale.getDefault().getCountry();
        if (StringUtils.isNotBlank(code)) {
            return StringUtils.lowerCase(code) + "|en";
        }
        return "en";
    }

    private static void addFilterParams(final Map<String, String> valueMap, final OCApiConnector connector) {
        if (!Settings.isExcludeDisabledCaches()) {
            valueMap.put("status", "Available|Temporarily unavailable");
        }
        if (Settings.isExcludeMyCaches() && connector.getSupportedAuthLevel() == OAuthLevel.Level3) {
            valueMap.put("exclude_my_own", "true");
            valueMap.put("found_status", "notfound_only");
        }
        if (Settings.getCacheType() != CacheType.ALL) {
            valueMap.put("type", getFilterFromType(Settings.getCacheType()));
        }
    }

    private static void addRetrieveParams(final Parameters params, final OCApiConnector connector) {
        params.add("retr_method", METHOD_RETRIEVE_CACHES);
        params.add("retr_params", "{\"fields\": \"" + getCoreFields(connector) + "\"}");
        params.add("wrap", "true");
    }

    private static String getFilterFromType(final CacheType cacheType) {
        switch (cacheType) {
            case EVENT:
                return "Event";
            case MULTI:
                return "Multi";
            case MYSTERY:
                return "Quiz";
            case TRADITIONAL:
                return "Traditional";
            case VIRTUAL:
                return "Virtual";
            case WEBCAM:
                return "Webcam";
            default:
                return "";
        }
    }

    public static UserInfo getUserInfo(final OCApiLiveConnector connector) {
        final Parameters params = new Parameters("fields", USER_INFO_FIELDS);

        final JSONObject data = request(connector, OkapiService.SERVICE_USER, params);

        if (data == null) {
            return new UserInfo(StringUtils.EMPTY, 0, UserInfoStatus.FAILED);
        }

        String name = StringUtils.EMPTY;
        boolean successUserName = false;

        if (!data.isNull(USER_USERNAME)) {
            try {
                name = data.getString(USER_USERNAME);
                successUserName = true;
            } catch (final JSONException e) {
                Log.e("OkapiClient.getUserInfo - name", e);
            }
        }

        int finds = 0;
        boolean successFinds = false;

        if (!data.isNull(USER_CACHES_FOUND)) {
            try {
                finds = data.getInt(USER_CACHES_FOUND);
                successFinds = true;
            } catch (final JSONException e) {
                Log.e("OkapiClient.getUserInfo - finds", e);
            }
        }

        return new UserInfo(name, finds, successUserName && successFinds ? UserInfoStatus.SUCCESSFUL : UserInfoStatus.FAILED);
    }

}
!@#$%
20190527_002508,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_a20648
package cgeo.geocaching.connector.oc;

import cgeo.geocaching.Geocache;
import cgeo.geocaching.Image;
import cgeo.geocaching.LogEntry;
import cgeo.geocaching.R;
import cgeo.geocaching.Waypoint;
import cgeo.geocaching.cgData;
import cgeo.geocaching.cgeoapplication;
import cgeo.geocaching.connector.ConnectorFactory;
import cgeo.geocaching.connector.IConnector;
import cgeo.geocaching.connector.LogResult;
import cgeo.geocaching.connector.gc.GCConnector;
import cgeo.geocaching.connector.oc.OCApiConnector.ApiSupport;
import cgeo.geocaching.connector.oc.OCApiConnector.OAuthLevel;
import cgeo.geocaching.connector.oc.UserInfo.UserInfoStatus;
import cgeo.geocaching.enumerations.CacheAttribute;
import cgeo.geocaching.enumerations.CacheSize;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.LoadFlags.SaveFlag;
import cgeo.geocaching.enumerations.LogType;
import cgeo.geocaching.enumerations.StatusCode;
import cgeo.geocaching.enumerations.WaypointType;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.geopoint.GeopointFormatter;
import cgeo.geocaching.geopoint.Viewport;
import cgeo.geocaching.network.Network;
import cgeo.geocaching.network.OAuth;
import cgeo.geocaching.network.Parameters;
import cgeo.geocaching.settings.Settings;
import cgeo.geocaching.utils.Log;

import org.apache.commons.lang3.StringUtils;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import android.net.Uri;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Date;
import java.util.EnumSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.TimeZone;

final class OkapiClient {

    private static final char SEPARATOR = '|';
    private static final String SEPARATOR_STRING = Character.toString(SEPARATOR);
    private static final SimpleDateFormat LOG_DATE_FORMAT;
    static {
        LOG_DATE_FORMAT = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSSZ", Locale.US);
        LOG_DATE_FORMAT.setTimeZone(TimeZone.getTimeZone("UTC"));
    }
    private static final SimpleDateFormat ISO8601DATEFORMAT = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ", Locale.getDefault());

    private static final String CACHE_ATTRNAMES = "attrnames";
    private static final String WPT_LOCATION = "location";
    private static final String WPT_DESCRIPTION = "description";
    private static final String WPT_TYPE = "type";
    private static final String WPT_NAME = "name";
    private static final String CACHE_IS_WATCHED = "is_watched";
    private static final String CACHE_WPTS = "alt_wpts";
    private static final String CACHE_STATUS_ARCHIVED = "Archived";
    private static final String CACHE_STATUS_DISABLED = "Temporarily unavailable";
    private static final String CACHE_IS_FOUND = "is_found";
    private static final String CACHE_SIZE = "size";
    private static final String CACHE_VOTES = "rating_votes";
    private static final String CACHE_NOTFOUNDS = "notfounds";
    private static final String CACHE_FOUNDS = "founds";
    private static final String CACHE_HIDDEN = "date_hidden";
    private static final String CACHE_LATEST_LOGS = "latest_logs";
    private static final String CACHE_IMAGE_URL = "url";
    private static final String CACHE_IMAGE_CAPTION = "caption";
    private static final String CACHE_IMAGE_IS_SPOILER = "is_spoiler";
    private static final String CACHE_IMAGES = "images";
    private static final String CACHE_HINT = "hint";
    private static final String CACHE_DESCRIPTION = "description";
    private static final String CACHE_RECOMMENDATIONS = "recommendations";
    private static final String CACHE_RATING = "rating";
    private static final String CACHE_TERRAIN = "terrain";
    private static final String CACHE_DIFFICULTY = "difficulty";
    private static final String CACHE_OWNER = "owner";
    private static final String CACHE_STATUS = "status";
    private static final String CACHE_TYPE = "type";
    private static final String CACHE_LOCATION = "location";
    private static final String CACHE_NAME = "name";
    private static final String CACHE_CODE = "code";
    private static final String CACHE_REQ_PASSWORD = "req_passwd";
    private static final String CACHE_MY_NOTES = "my_notes";

    private static final String LOG_TYPE = "type";
    private static final String LOG_COMMENT = "comment";
    private static final String LOG_DATE = "date";
    private static final String LOG_USER = "user";

    private static final String USER_USERNAME = "username";
    private static final String USER_CACHES_FOUND = "caches_found";
    private static final String USER_INFO_FIELDS = "username|caches_found";

    // the several realms of possible fields for cache retrieval:
    // Core: for livemap requests (L3 - only with level 3 auth)
    // Additional: additional fields for full cache (L3 - only for level 3 auth, current - only for connectors with current api)
    private static final String SERVICE_CACHE_CORE_FIELDS = "code|name|location|type|status|difficulty|terrain|size";
    private static final String SERVICE_CACHE_CORE_L3_FIELDS = "is_found";
    private static final String SERVICE_CACHE_ADDITIONAL_FIELDS = "owner|founds|notfounds|rating|rating_votes|recommendations|description|hint|images|latest_logs|date_hidden|alt_wpts|attrnames|req_passwd";
    private static final String SERVICE_CACHE_ADDITIONAL_CURRENT_FIELDS = "gc_code|attribution_note";
    private static final String SERVICE_CACHE_ADDITIONAL_L3_FIELDS = "is_watched|my_notes";

    private static final String METHOD_SEARCH_NEAREST = "services/caches/search/nearest";
    private static final String METHOD_SEARCH_BBOX = "services/caches/search/bbox";
    private static final String METHOD_RETRIEVE_CACHES = "services/caches/geocaches";

    public static Geocache getCache(final String geoCode) {
        final Parameters params = new Parameters("cache_code", geoCode);
        final IConnector connector = ConnectorFactory.getConnector(geoCode);
        if (!(connector instanceof OCApiConnector)) {
            return null;
        }

        final OCApiConnector ocapiConn = (OCApiConnector) connector;

        params.add("fields", getFullFields(ocapiConn));
        params.add("attribution_append", "none");

        final JSONObject data = request(ocapiConn, OkapiService.SERVICE_CACHE, params);

        if (data == null) {
            return null;
        }

        return parseCache(data);
    }

    public static List<Geocache> getCachesAround(final Geopoint center, final OCApiConnector connector) {
        final String centerString = GeopointFormatter.format(GeopointFormatter.Format.LAT_DECDEGREE_RAW, center) + SEPARATOR + GeopointFormatter.format(GeopointFormatter.Format.LON_DECDEGREE_RAW, center);
        final Parameters params = new Parameters("search_method", METHOD_SEARCH_NEAREST);
        final Map<String, String> valueMap = new LinkedHashMap<String, String>();
        valueMap.put("center", centerString);
        valueMap.put("limit", "20");

        return requestCaches(connector, params, valueMap);
    }

    private static List<Geocache> requestCaches(final OCApiConnector connector, final Parameters params, final Map<String, String> valueMap) {
        addFilterParams(valueMap, connector);
        params.add("search_params", new JSONObject(valueMap).toString());
        addRetrieveParams(params, connector);

        final JSONObject data = request(connector, OkapiService.SERVICE_SEARCH_AND_RETRIEVE, params);

        if (data == null) {
            return Collections.emptyList();
        }

        return parseCaches(data);
    }

    // Assumes level 3 OAuth
    public static List<Geocache> getCachesBBox(final Viewport viewport, final OCApiConnector connector) {

        if (viewport.getLatitudeSpan() == 0 || viewport.getLongitudeSpan() == 0) {
            return Collections.emptyList();
        }

        final String bboxString = GeopointFormatter.format(GeopointFormatter.Format.LAT_DECDEGREE_RAW, viewport.bottomLeft)
                + SEPARATOR + GeopointFormatter.format(GeopointFormatter.Format.LON_DECDEGREE_RAW, viewport.bottomLeft)
                + SEPARATOR + GeopointFormatter.format(GeopointFormatter.Format.LAT_DECDEGREE_RAW, viewport.topRight)
                + SEPARATOR + GeopointFormatter.format(GeopointFormatter.Format.LON_DECDEGREE_RAW, viewport.topRight);
        final Parameters params = new Parameters("search_method", METHOD_SEARCH_BBOX);
        final Map<String, String> valueMap = new LinkedHashMap<String, String>();
        valueMap.put("bbox", bboxString);

        return requestCaches(connector, params, valueMap);
    }

    public static boolean setWatchState(final Geocache cache, final boolean watched, final OCApiConnector connector) {
        final Parameters params = new Parameters("cache_code", cache.getGeocode());
        params.add("watched", watched ? "true" : "false");

        final JSONObject data = request(connector, OkapiService.SERVICE_MARK_CACHE, params);

        if (data == null) {
            return false;
        }

        cache.setOnWatchlist(watched);

        return true;
    }

    public static LogResult postLog(final Geocache cache, final LogType logType, final Calendar date, final String log, final String logPassword, final OCApiConnector connector) {
        final Parameters params = new Parameters("cache_code", cache.getGeocode());
        params.add("logtype", logType.oc_type);
        params.add("comment", log);
        params.add("comment_format", "plaintext");
        params.add("when", LOG_DATE_FORMAT.format(date.getTime()));
        if (logType.equals(LogType.NEEDS_MAINTENANCE)) {
            params.add("needs_maintenance", "true");
        }
        if (logPassword != null) {
            params.add("password", logPassword);
        }

        final JSONObject data = request(connector, OkapiService.SERVICE_SUBMIT_LOG, params);

        if (data == null) {
            return new LogResult(StatusCode.LOG_POST_ERROR, "");
        }

        try {
            if (data.getBoolean("success")) {
                return new LogResult(StatusCode.NO_ERROR, data.getString("log_uuid"));
            }

            return new LogResult(StatusCode.LOG_POST_ERROR, "");
        } catch (final JSONException e) {
            Log.e("OkapiClient.postLog", e);
        }
        return new LogResult(StatusCode.LOG_POST_ERROR, "");
    }

    private static List<Geocache> parseCaches(final JSONObject response) {
        try {
            // Check for empty result
            final String result = response.getString("results");
            if (StringUtils.isBlank(result) || StringUtils.equals(result, "[]")) {
                return Collections.emptyList();
            }

            // Get and iterate result list
            final JSONObject cachesResponse = response.getJSONObject("results");
            if (cachesResponse != null) {
                final List<Geocache> caches = new ArrayList<Geocache>(cachesResponse.length());
                @SuppressWarnings("unchecked")
                final
                Iterator<String> keys = cachesResponse.keys();
                while (keys.hasNext()) {
                    final String key = keys.next();
                    final Geocache cache = parseSmallCache(cachesResponse.getJSONObject(key));
                    if (cache != null) {
                        caches.add(cache);
                    }
                }
                return caches;
            }
        } catch (final JSONException e) {
            Log.e("OkapiClient.parseCachesResult", e);
        }
        return Collections.emptyList();
    }

    private static Geocache parseSmallCache(final JSONObject response) {
        final Geocache cache = new Geocache();
        cache.setReliableLatLon(true);
        try {

            parseCoreCache(response, cache);

            cgData.saveCache(cache, EnumSet.of(SaveFlag.SAVE_CACHE));
        } catch (final JSONException e) {
            Log.e("OkapiClient.parseSmallCache", e);
        }
        return cache;
    }

    private static Geocache parseCache(final JSONObject response) {
        final Geocache cache = new Geocache();
        cache.setReliableLatLon(true);
        try {

            parseCoreCache(response, cache);

            // not used: url
            final JSONObject owner = response.getJSONObject(CACHE_OWNER);
            cache.setOwnerDisplayName(parseUser(owner));

            cache.getLogCounts().put(LogType.FOUND_IT, response.getInt(CACHE_FOUNDS));
            cache.getLogCounts().put(LogType.DIDNT_FIND_IT, response.getInt(CACHE_NOTFOUNDS));

            if (!response.isNull(CACHE_RATING)) {
                cache.setRating((float) response.getDouble(CACHE_RATING));
            }
            cache.setVotes(response.getInt(CACHE_VOTES));

            cache.setFavoritePoints(response.getInt(CACHE_RECOMMENDATIONS));
            // not used: req_password
            // Prepend gc-link to description if available
            final StringBuilder description = new StringBuilder(500);
            if (!response.isNull("gc_code")) {
                final String gccode = response.getString("gc_code");
                description.append(cgeoapplication.getInstance().getResources()
                        .getString(R.string.cache_listed_on, GCConnector.getInstance().getName()))
                        .append(": <a href=\"http://coord.info/")
                        .append(gccode)
                        .append("\">")
                        .append(gccode)
                        .append("</a><br /><br />");
            }
            description.append(response.getString(CACHE_DESCRIPTION));
            cache.setDescription(description.toString());

            // currently the hint is delivered as HTML (contrary to OKAPI documentation), so we can store it directly
            cache.setHint(response.getString(CACHE_HINT));
            // not used: hints

            final JSONArray images = response.getJSONArray(CACHE_IMAGES);
            if (images != null) {
                for (int i = 0; i < images.length(); i++) {
                    final JSONObject imageResponse = images.getJSONObject(i);
                    if (imageResponse.getBoolean(CACHE_IMAGE_IS_SPOILER)) {
                        final String title = imageResponse.getString(CACHE_IMAGE_CAPTION);
                        final String url = absoluteUrl(imageResponse.getString(CACHE_IMAGE_URL), cache.getGeocode());
                        cache.addSpoiler(new Image(url, title));
                    }
                }
            }

            cache.setAttributes(parseAttributes(response.getJSONArray(CACHE_ATTRNAMES)));
            cache.setLogs(parseLogs(response.getJSONArray(CACHE_LATEST_LOGS)));
            cache.setHidden(parseDate(response.getString(CACHE_HIDDEN)));
            //TODO: Store license per cache
            //cache.setLicense(response.getString("attribution_note"));
            cache.setWaypoints(parseWaypoints(response.getJSONArray(CACHE_WPTS)), false);
            if (!response.isNull(CACHE_IS_WATCHED)) {
                cache.setOnWatchlist(response.getBoolean(CACHE_IS_WATCHED));
            }
            if (!response.isNull(CACHE_MY_NOTES)) {
                cache.setPersonalNote(response.getString(CACHE_MY_NOTES));
            }
            cache.setLogPasswordRequired(response.getBoolean(CACHE_REQ_PASSWORD));

            cache.setDetailedUpdatedNow();
            // save full detailed caches
            cgData.saveCache(cache, EnumSet.of(SaveFlag.SAVE_DB));
        } catch (final JSONException e) {
            Log.e("OkapiClient.parseCache", e);
        }
        return cache;
    }

    private static void parseCoreCache(final JSONObject response, final Geocache cache) throws JSONException {
        cache.setGeocode(response.getString(CACHE_CODE));
        cache.setName(response.getString(CACHE_NAME));
        // not used: names
        setLocation(cache, response.getString(CACHE_LOCATION));
        cache.setType(getCacheType(response.getString(CACHE_TYPE)));

        final String status = response.getString(CACHE_STATUS);
        cache.setDisabled(status.equalsIgnoreCase(CACHE_STATUS_DISABLED));
        cache.setArchived(status.equalsIgnoreCase(CACHE_STATUS_ARCHIVED));

        cache.setSize(getCacheSize(response));
        cache.setDifficulty((float) response.getDouble(CACHE_DIFFICULTY));
        cache.setTerrain((float) response.getDouble(CACHE_TERRAIN));

        if (!response.isNull(CACHE_IS_FOUND)) {
            cache.setFound(response.getBoolean(CACHE_IS_FOUND));
        }
    }

    private static String absoluteUrl(final String url, final String geocode) {
        final Uri uri = Uri.parse(url);

        if (!uri.isAbsolute()) {
            final IConnector connector = ConnectorFactory.getConnector(geocode);
            final String host = connector.getHost();
            if (StringUtils.isNotBlank(host)) {
                return "http://" + host + "/" + url;
            }
        }
        return url;
    }

    private static String parseUser(final JSONObject user) throws JSONException {
        return user.getString(USER_USERNAME);
    }

    private static List<LogEntry> parseLogs(final JSONArray logsJSON) {
        List<LogEntry> result = null;
        for (int i = 0; i < logsJSON.length(); i++) {
            try {
                final JSONObject logResponse = logsJSON.getJSONObject(i);
                final LogEntry log = new LogEntry(
                        parseUser(logResponse.getJSONObject(LOG_USER)),
                        parseDate(logResponse.getString(LOG_DATE)).getTime(),
                        parseLogType(logResponse.getString(LOG_TYPE)),
                        logResponse.getString(LOG_COMMENT).trim());
                if (result == null) {
                    result = new ArrayList<LogEntry>();
                }
                result.add(log);
            } catch (final JSONException e) {
                Log.e("OkapiClient.parseLogs", e);
            }
        }
        return result;
    }

    private static List<Waypoint> parseWaypoints(final JSONArray wptsJson) {
        List<Waypoint> result = null;
        for (int i = 0; i < wptsJson.length(); i++) {
            try {
                final JSONObject wptResponse = wptsJson.getJSONObject(i);
                final Waypoint wpt = new Waypoint(wptResponse.getString(WPT_NAME),
                        parseWptType(wptResponse.getString(WPT_TYPE)),
                        false);
                wpt.setNote(wptResponse.getString(WPT_DESCRIPTION));
                final Geopoint pt = parseCoords(wptResponse.getString(WPT_LOCATION));
                if (pt != null) {
                    wpt.setCoords(pt);
                }
                if (result == null) {
                    result = new ArrayList<Waypoint>();
                }
                result.add(wpt);
            } catch (final JSONException e) {
                Log.e("OkapiClient.parseWaypoints", e);
            }
        }
        return result;
    }

    private static LogType parseLogType(final String logType) {
        if ("Found it".equalsIgnoreCase(logType)) {
            return LogType.FOUND_IT;
        }
        if ("Didn't find it".equalsIgnoreCase(logType)) {
            return LogType.DIDNT_FIND_IT;
        }
        return LogType.NOTE;
    }

    private static WaypointType parseWptType(final String wptType) {
        if ("parking".equalsIgnoreCase(wptType)) {
            return WaypointType.PARKING;
        }
        if ("path".equalsIgnoreCase(wptType)) {
            return WaypointType.TRAILHEAD;
        }
        if ("stage".equalsIgnoreCase(wptType)) {
            return WaypointType.STAGE;
        }
        if ("physical-stage".equalsIgnoreCase(wptType)) {
            return WaypointType.STAGE;
        }
        if ("virtual-stage".equalsIgnoreCase(wptType)) {
            return WaypointType.PUZZLE;
        }
        if ("final".equalsIgnoreCase(wptType)) {
            return WaypointType.FINAL;
        }
        if ("poi".equalsIgnoreCase(wptType)) {
            return WaypointType.TRAILHEAD;
        }
        return WaypointType.WAYPOINT;
    }

    private static Date parseDate(final String date) {
        final String strippedDate = date.replaceAll("\\+0([0-9]){1}\\:00", "+0$100");
        try {
            return ISO8601DATEFORMAT.parse(strippedDate);
        } catch (final ParseException e) {
            Log.e("OkapiClient.parseDate", e);
        }
        return null;
    }

    private static Geopoint parseCoords(final String location) {
        final String latitude = StringUtils.substringBefore(location, SEPARATOR_STRING);
        final String longitude = StringUtils.substringAfter(location, SEPARATOR_STRING);
        if (StringUtils.isNotBlank(latitude) && StringUtils.isNotBlank(longitude)) {
            return new Geopoint(latitude, longitude);
        }

        return null;
    }

    private static List<String> parseAttributes(final JSONArray nameList) {

        final List<String> result = new ArrayList<String>();

        for (int i = 0; i < nameList.length(); i++) {
            try {
                final String name = nameList.getString(i);
                final CacheAttribute attr = CacheAttribute.getByOcId(AttributeParser.getOcDeId(name));

                if (attr != null) {
                    result.add(attr.rawName);
                }
            } catch (final JSONException e) {
                Log.e("OkapiClient.parseAttributes", e);
            }
        }

        return result;
    }

    private static void setLocation(final Geocache cache, final String location) {
        final String latitude = StringUtils.substringBefore(location, SEPARATOR_STRING);
        final String longitude = StringUtils.substringAfter(location, SEPARATOR_STRING);
        cache.setCoords(new Geopoint(latitude, longitude));
    }

    private static CacheSize getCacheSize(final JSONObject response) {
        if (response.isNull(CACHE_SIZE)) {
            return CacheSize.NOT_CHOSEN;
        }
        double size = 0;
        try {
            size = response.getDouble(CACHE_SIZE);
        } catch (final JSONException e) {
            Log.e("OkapiClient.getCacheSize", e);
        }
        switch ((int) Math.round(size)) {
            case 1:
                return CacheSize.MICRO;
            case 2:
                return CacheSize.SMALL;
            case 3:
                return CacheSize.REGULAR;
            case 4:
                return CacheSize.LARGE;
            case 5:
                return CacheSize.LARGE;
            default:
                break;
        }
        return CacheSize.NOT_CHOSEN;
    }

    private static CacheType getCacheType(final String cacheType) {
        if (cacheType.equalsIgnoreCase("Traditional")) {
            return CacheType.TRADITIONAL;
        }
        if (cacheType.equalsIgnoreCase("Multi")) {
            return CacheType.MULTI;
        }
        if (cacheType.equalsIgnoreCase("Quiz")) {
            return CacheType.MYSTERY;
        }
        if (cacheType.equalsIgnoreCase("Virtual")) {
            return CacheType.VIRTUAL;
        }
        if (cacheType.equalsIgnoreCase("Event")) {
            return CacheType.EVENT;
        }
        if (cacheType.equalsIgnoreCase("Webcam")) {
            return CacheType.WEBCAM;
        }
        if (cacheType.equalsIgnoreCase("Math/Physics")) {
            return CacheType.MYSTERY;
        }
        if (cacheType.equalsIgnoreCase("Drive-In")) {
            return CacheType.TRADITIONAL;
        }
        return CacheType.UNKNOWN;
    }

    private static String getCoreFields(final OCApiConnector connector) {
        if (connector == null) {
            Log.e("OkapiClient.getCoreFields called with invalid connector");
            return StringUtils.EMPTY;
        }

        if (connector.getSupportedAuthLevel() == OAuthLevel.Level3) {
            return SERVICE_CACHE_CORE_FIELDS + SEPARATOR + SERVICE_CACHE_CORE_L3_FIELDS;
        }

        return SERVICE_CACHE_CORE_FIELDS;
    }

    private static String getFullFields(final OCApiConnector connector) {
        if (connector == null) {
            Log.e("OkapiClient.getFullFields called with invalid connector");
            return StringUtils.EMPTY;
        }

        final StringBuilder res = new StringBuilder(500);

        res.append(SERVICE_CACHE_CORE_FIELDS);
        res.append(SEPARATOR).append(SERVICE_CACHE_ADDITIONAL_FIELDS);
        if (connector.getSupportedAuthLevel() == OAuthLevel.Level3) {
            res.append(SEPARATOR).append(SERVICE_CACHE_CORE_L3_FIELDS);
            res.append(SEPARATOR).append(SERVICE_CACHE_ADDITIONAL_L3_FIELDS);
        }
        if (connector.getApiSupport() == ApiSupport.current) {
            res.append(SEPARATOR).append(SERVICE_CACHE_ADDITIONAL_CURRENT_FIELDS);
        }

        return res.toString();
    }

    private static JSONObject request(final OCApiConnector connector, final OkapiService service, final Parameters params) {
        if (connector == null) {
            return null;
        }

        final String host = connector.getHost();
        if (StringUtils.isBlank(host)) {
            return null;
        }

        params.add("langpref", getPreferredLanguage());

        if (connector.getSupportedAuthLevel() == OAuthLevel.Level3) {
            OAuth.signOAuth(host, service.methodName, "GET", false, params, Settings.getOCDETokenPublic(), Settings.getOCDETokenSecret(), connector.getCK(), connector.getCS());
        } else {
            connector.addAuthentication(params);
        }

        final String uri = "http://" + host + service.methodName;
        return Network.requestJSON(uri, params);
    }

    private static String getPreferredLanguage() {
        final String code = Locale.getDefault().getCountry();
        if (StringUtils.isNotBlank(code)) {
            return StringUtils.lowerCase(code) + "|en";
        }
        return "en";
    }

    private static void addFilterParams(final Map<String, String> valueMap, final OCApiConnector connector) {
        if (!Settings.isExcludeDisabledCaches()) {
            valueMap.put("status", "Available|Temporarily unavailable");
        }
        if (Settings.isExcludeMyCaches() && connector.getSupportedAuthLevel() == OAuthLevel.Level3) {
            valueMap.put("exclude_my_own", "true");
            valueMap.put("found_status", "notfound_only");
        }
        if (Settings.getCacheType() != CacheType.ALL) {
            valueMap.put("type", getFilterFromType(Settings.getCacheType()));
        }
    }

    private static void addRetrieveParams(final Parameters params, final OCApiConnector connector) {
        params.add("retr_method", METHOD_RETRIEVE_CACHES);
        params.add("retr_params", "{\"fields\": \"" + getCoreFields(connector) + "\"}");
        params.add("wrap", "true");
    }

    private static String getFilterFromType(final CacheType cacheType) {
        switch (cacheType) {
            case EVENT:
                return "Event";
            case MULTI:
                return "Multi";
            case MYSTERY:
                return "Quiz";
            case TRADITIONAL:
                return "Traditional";
            case VIRTUAL:
                return "Virtual";
            case WEBCAM:
                return "Webcam";
            default:
                return "";
        }
    }

    public static UserInfo getUserInfo(final OCApiLiveConnector connector) {
        final Parameters params = new Parameters("fields", USER_INFO_FIELDS);

        final JSONObject data = request(connector, OkapiService.SERVICE_USER, params);

        if (data == null) {
            return new UserInfo(StringUtils.EMPTY, 0, UserInfoStatus.FAILED);
        }

        String name = StringUtils.EMPTY;
        boolean successUserName = false;

        if (!data.isNull(USER_USERNAME)) {
            try {
                name = data.getString(USER_USERNAME);
                successUserName = true;
            } catch (final JSONException e) {
                Log.e("OkapiClient.getUserInfo - name", e);
            }
        }

        int finds = 0;
        boolean successFinds = false;

        if (!data.isNull(USER_CACHES_FOUND)) {
            try {
                finds = data.getInt(USER_CACHES_FOUND);
                successFinds = true;
            } catch (final JSONException e) {
                Log.e("OkapiClient.getUserInfo - finds", e);
            }
        }

        return new UserInfo(name, finds, successUserName && successFinds ? UserInfoStatus.SUCCESSFUL : UserInfoStatus.FAILED);
    }

}
!@#$%
20190527_002508,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_c20648
package cgeo.geocaching.connector.oc;

import cgeo.geocaching.Geocache;
import cgeo.geocaching.Image;
import cgeo.geocaching.LogEntry;
import cgeo.geocaching.R;
import cgeo.geocaching.Waypoint;
import cgeo.geocaching.cgData;
import cgeo.geocaching.cgeoapplication;
import cgeo.geocaching.connector.ConnectorFactory;
import cgeo.geocaching.connector.IConnector;
import cgeo.geocaching.connector.LogResult;
import cgeo.geocaching.connector.gc.GCConnector;
import cgeo.geocaching.connector.oc.OCApiConnector.ApiSupport;
import cgeo.geocaching.connector.oc.OCApiConnector.OAuthLevel;
import cgeo.geocaching.connector.oc.UserInfo.UserInfoStatus;
import cgeo.geocaching.enumerations.CacheAttribute;
import cgeo.geocaching.enumerations.CacheSize;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.LoadFlags.SaveFlag;
import cgeo.geocaching.enumerations.LogType;
import cgeo.geocaching.enumerations.StatusCode;
import cgeo.geocaching.enumerations.WaypointType;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.geopoint.GeopointFormatter;
import cgeo.geocaching.geopoint.Viewport;
import cgeo.geocaching.network.Network;
import cgeo.geocaching.network.OAuth;
import cgeo.geocaching.network.Parameters;
import cgeo.geocaching.settings.Settings;
import cgeo.geocaching.utils.Log;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import android.net.Uri;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Date;
import java.util.EnumSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.TimeZone;

final class OkapiClient {

    private static final char SEPARATOR = '|';
    private static final String SEPARATOR_STRING = Character.toString(SEPARATOR);
    private static final SimpleDateFormat LOG_DATE_FORMAT;
    static {
        LOG_DATE_FORMAT = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSSZ", Locale.US);
        LOG_DATE_FORMAT.setTimeZone(TimeZone.getTimeZone("UTC"));
    }
    private static final SimpleDateFormat ISO8601DATEFORMAT = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ", Locale.getDefault());

    private static final String CACHE_ATTRNAMES = "attrnames";
    private static final String WPT_LOCATION = "location";
    private static final String WPT_DESCRIPTION = "description";
    private static final String WPT_TYPE = "type";
    private static final String WPT_NAME = "name";
    private static final String CACHE_IS_WATCHED = "is_watched";
    private static final String CACHE_WPTS = "alt_wpts";
    private static final String CACHE_STATUS_ARCHIVED = "Archived";
    private static final String CACHE_STATUS_DISABLED = "Temporarily unavailable";
    private static final String CACHE_IS_FOUND = "is_found";
    private static final String CACHE_SIZE = "size";
    private static final String CACHE_VOTES = "rating_votes";
    private static final String CACHE_NOTFOUNDS = "notfounds";
    private static final String CACHE_FOUNDS = "founds";
    private static final String CACHE_HIDDEN = "date_hidden";
    private static final String CACHE_LATEST_LOGS = "latest_logs";
    private static final String CACHE_IMAGE_URL = "url";
    private static final String CACHE_IMAGE_CAPTION = "caption";
    private static final String CACHE_IMAGE_IS_SPOILER = "is_spoiler";
    private static final String CACHE_IMAGES = "images";
    private static final String CACHE_HINT = "hint";
    private static final String CACHE_DESCRIPTION = "description";
    private static final String CACHE_RECOMMENDATIONS = "recommendations";
    private static final String CACHE_RATING = "rating";
    private static final String CACHE_TERRAIN = "terrain";
    private static final String CACHE_DIFFICULTY = "difficulty";
    private static final String CACHE_OWNER = "owner";
    private static final String CACHE_STATUS = "status";
    private static final String CACHE_TYPE = "type";
    private static final String CACHE_LOCATION = "location";
    private static final String CACHE_NAME = "name";
    private static final String CACHE_CODE = "code";
    private static final String CACHE_REQ_PASSWORD = "req_passwd";
    private static final String CACHE_MY_NOTES = "my_notes";

    private static final String LOG_TYPE = "type";
    private static final String LOG_COMMENT = "comment";
    private static final String LOG_DATE = "date";
    private static final String LOG_USER = "user";

    private static final String USER_USERNAME = "username";
    private static final String USER_CACHES_FOUND = "caches_found";
    private static final String USER_INFO_FIELDS = "username|caches_found";

    // the several realms of possible fields for cache retrieval:
    // Core: for livemap requests (L3 - only with level 3 auth)
    // Additional: additional fields for full cache (L3 - only for level 3 auth, current - only for connectors with current api)
    private static final String SERVICE_CACHE_CORE_FIELDS = "code|name|location|type|status|difficulty|terrain|size";
    private static final String SERVICE_CACHE_CORE_L3_FIELDS = "is_found";
    private static final String SERVICE_CACHE_ADDITIONAL_FIELDS = "owner|founds|notfounds|rating|rating_votes|recommendations|description|hint|images|latest_logs|date_hidden|alt_wpts|attrnames|req_passwd";
    private static final String SERVICE_CACHE_ADDITIONAL_CURRENT_FIELDS = "gc_code|attribution_note";
    private static final String SERVICE_CACHE_ADDITIONAL_L3_FIELDS = "is_watched|my_notes";

    private static final String METHOD_SEARCH_NEAREST = "services/caches/search/nearest";
    private static final String METHOD_SEARCH_BBOX = "services/caches/search/bbox";
    private static final String METHOD_RETRIEVE_CACHES = "services/caches/geocaches";

    public static Geocache getCache(final String geoCode) {
        final Parameters params = new Parameters("cache_code", geoCode);
        final IConnector connector = ConnectorFactory.getConnector(geoCode);
        if (!(connector instanceof OCApiConnector)) {
            return null;
        }

        final OCApiConnector ocapiConn = (OCApiConnector) connector;

        params.add("fields", getFullFields(ocapiConn));
        params.add("attribution_append", "none");

        final JSONObject data = request(ocapiConn, OkapiService.SERVICE_CACHE, params);

        if (data == null) {
            return null;
        }

        return parseCache(data);
    }

    public static List<Geocache> getCachesAround(final Geopoint center, final OCApiConnector connector) {
        final String centerString = GeopointFormatter.format(GeopointFormatter.Format.LAT_DECDEGREE_RAW, center) + SEPARATOR + GeopointFormatter.format(GeopointFormatter.Format.LON_DECDEGREE_RAW, center);
        final Parameters params = new Parameters("search_method", METHOD_SEARCH_NEAREST);
        final Map<String, String> valueMap = new LinkedHashMap<String, String>();
        valueMap.put("center", centerString);
        valueMap.put("limit", "20");

        return requestCaches(connector, params, valueMap);
    }

    private static List<Geocache> requestCaches(final OCApiConnector connector, final Parameters params, final Map<String, String> valueMap) {
        addFilterParams(valueMap, connector);
        params.add("search_params", new JSONObject(valueMap).toString());
        addRetrieveParams(params, connector);

        final JSONObject data = request(connector, OkapiService.SERVICE_SEARCH_AND_RETRIEVE, params);

        if (data == null) {
            return Collections.emptyList();
        }

        return parseCaches(data);
    }

    // Assumes level 3 OAuth
    public static List<Geocache> getCachesBBox(final Viewport viewport, final OCApiConnector connector) {

        if (viewport.getLatitudeSpan() == 0 || viewport.getLongitudeSpan() == 0) {
            return Collections.emptyList();
        }

        final String bboxString = GeopointFormatter.format(GeopointFormatter.Format.LAT_DECDEGREE_RAW, viewport.bottomLeft)
                + SEPARATOR + GeopointFormatter.format(GeopointFormatter.Format.LON_DECDEGREE_RAW, viewport.bottomLeft)
                + SEPARATOR + GeopointFormatter.format(GeopointFormatter.Format.LAT_DECDEGREE_RAW, viewport.topRight)
                + SEPARATOR + GeopointFormatter.format(GeopointFormatter.Format.LON_DECDEGREE_RAW, viewport.topRight);
        final Parameters params = new Parameters("search_method", METHOD_SEARCH_BBOX);
        final Map<String, String> valueMap = new LinkedHashMap<String, String>();
        valueMap.put("bbox", bboxString);

        return requestCaches(connector, params, valueMap);
    }

    public static boolean setWatchState(final Geocache cache, final boolean watched, final OCApiConnector connector) {
        final Parameters params = new Parameters("cache_code", cache.getGeocode());
        params.add("watched", watched ? "true" : "false");

        final JSONObject data = request(connector, OkapiService.SERVICE_MARK_CACHE, params);

        if (data == null) {
            return false;
        }

        cache.setOnWatchlist(watched);

        return true;
    }

    public static LogResult postLog(final Geocache cache, final LogType logType, final Calendar date, final String log, final String logPassword, final OCApiConnector connector) {
        final Parameters params = new Parameters("cache_code", cache.getGeocode());
        params.add("logtype", logType.oc_type);
        params.add("comment", log);
        params.add("comment_format", "plaintext");
        params.add("when", LOG_DATE_FORMAT.format(date.getTime()));
        if (logType.equals(LogType.NEEDS_MAINTENANCE)) {
            params.add("needs_maintenance", "true");
        }
        if (logPassword != null) {
            params.add("password", logPassword);
        }

        final JSONObject data = request(connector, OkapiService.SERVICE_SUBMIT_LOG, params);

        if (data == null) {
            return new LogResult(StatusCode.LOG_POST_ERROR, "");
        }

        try {
            if (data.getBoolean("success")) {
                return new LogResult(StatusCode.NO_ERROR, data.getString("log_uuid"));
            }

            return new LogResult(StatusCode.LOG_POST_ERROR, "");
        } catch (final JSONException e) {
            Log.e("OkapiClient.postLog", e);
        }
        return new LogResult(StatusCode.LOG_POST_ERROR, "");
    }

    private static List<Geocache> parseCaches(final JSONObject response) {
        try {
            // Check for empty result
            final String result = response.getString("results");
            if (StringUtils.isBlank(result) || StringUtils.equals(result, "[]")) {
                return Collections.emptyList();
            }

            // Get and iterate result list
            final JSONObject cachesResponse = response.getJSONObject("results");
            if (cachesResponse != null) {
                final List<Geocache> caches = new ArrayList<Geocache>(cachesResponse.length());
                @SuppressWarnings("unchecked")
                final
                Iterator<String> keys = cachesResponse.keys();
                while (keys.hasNext()) {
                    final String key = keys.next();
                    final Geocache cache = parseSmallCache(cachesResponse.getJSONObject(key));
                    if (cache != null) {
                        caches.add(cache);
                    }
                }
                return caches;
            }
        } catch (final JSONException e) {
            Log.e("OkapiClient.parseCachesResult", e);
        }
        return Collections.emptyList();
    }

    private static Geocache parseSmallCache(final JSONObject response) {
        final Geocache cache = new Geocache();
        cache.setReliableLatLon(true);
        try {

            parseCoreCache(response, cache);

            cgData.saveCache(cache, EnumSet.of(SaveFlag.SAVE_CACHE));
        } catch (final JSONException e) {
            Log.e("OkapiClient.parseSmallCache", e);
        }
        return cache;
    }

    private static Geocache parseCache(final JSONObject response) {
        final Geocache cache = new Geocache();
        cache.setReliableLatLon(true);
        try {

            parseCoreCache(response, cache);

            // not used: url
            final JSONObject owner = response.getJSONObject(CACHE_OWNER);
            cache.setOwnerDisplayName(parseUser(owner));

            cache.getLogCounts().put(LogType.FOUND_IT, response.getInt(CACHE_FOUNDS));
            cache.getLogCounts().put(LogType.DIDNT_FIND_IT, response.getInt(CACHE_NOTFOUNDS));

            if (!response.isNull(CACHE_RATING)) {
                cache.setRating((float) response.getDouble(CACHE_RATING));
            }
            cache.setVotes(response.getInt(CACHE_VOTES));

            cache.setFavoritePoints(response.getInt(CACHE_RECOMMENDATIONS));
            // not used: req_password
            // Prepend gc-link to description if available
            final StringBuilder description = new StringBuilder(500);
            if (!response.isNull("gc_code")) {
                final String gccode = response.getString("gc_code");
                description.append(cgeoapplication.getInstance().getResources()
                        .getString(R.string.cache_listed_on, GCConnector.getInstance().getName()))
                        .append(": <a href=\"http://coord.info/")
                        .append(gccode)
                        .append("\">")
                        .append(gccode)
                        .append("</a><br /><br />");
            }
            description.append(response.getString(CACHE_DESCRIPTION));
            cache.setDescription(description.toString());

            // currently the hint is delivered as HTML (contrary to OKAPI documentation), so we can store it directly
            cache.setHint(response.getString(CACHE_HINT));
            // not used: hints

            final JSONArray images = response.getJSONArray(CACHE_IMAGES);
            if (images != null) {
                for (int i = 0; i < images.length(); i++) {
                    final JSONObject imageResponse = images.getJSONObject(i);
                    if (imageResponse.getBoolean(CACHE_IMAGE_IS_SPOILER)) {
                        final String title = imageResponse.getString(CACHE_IMAGE_CAPTION);
                        final String url = absoluteUrl(imageResponse.getString(CACHE_IMAGE_URL), cache.getGeocode());
                        cache.addSpoiler(new Image(url, title));
                    }
                }
            }

            cache.setAttributes(parseAttributes(response.getJSONArray(CACHE_ATTRNAMES)));
            cache.setLogs(parseLogs(response.getJSONArray(CACHE_LATEST_LOGS)));
            cache.setHidden(parseDate(response.getString(CACHE_HIDDEN)));
            //TODO: Store license per cache
            //cache.setLicense(response.getString("attribution_note"));
            cache.setWaypoints(parseWaypoints(response.getJSONArray(CACHE_WPTS)), false);
            if (!response.isNull(CACHE_IS_WATCHED)) {
                cache.setOnWatchlist(response.getBoolean(CACHE_IS_WATCHED));
            }
            if (!response.isNull(CACHE_MY_NOTES)) {
                cache.setPersonalNote(response.getString(CACHE_MY_NOTES));
            }
            cache.setLogPasswordRequired(response.getBoolean(CACHE_REQ_PASSWORD));

            cache.setDetailedUpdatedNow();
            // save full detailed caches
            cgData.saveCache(cache, EnumSet.of(SaveFlag.SAVE_DB));
        } catch (final JSONException e) {
            Log.e("OkapiClient.parseCache", e);
        }
        return cache;
    }

    private static void parseCoreCache(final JSONObject response, final Geocache cache) throws JSONException {
        cache.setGeocode(response.getString(CACHE_CODE));
        cache.setName(response.getString(CACHE_NAME));
        // not used: names
        setLocation(cache, response.getString(CACHE_LOCATION));
        cache.setType(getCacheType(response.getString(CACHE_TYPE)));

        final String status = response.getString(CACHE_STATUS);
        cache.setDisabled(status.equalsIgnoreCase(CACHE_STATUS_DISABLED));
        cache.setArchived(status.equalsIgnoreCase(CACHE_STATUS_ARCHIVED));

        cache.setSize(getCacheSize(response));
        cache.setDifficulty((float) response.getDouble(CACHE_DIFFICULTY));
        cache.setTerrain((float) response.getDouble(CACHE_TERRAIN));

        if (!response.isNull(CACHE_IS_FOUND)) {
            cache.setFound(response.getBoolean(CACHE_IS_FOUND));
        }
    }

    private static String absoluteUrl(final String url, final String geocode) {
        final Uri uri = Uri.parse(url);

        if (!uri.isAbsolute()) {
            final IConnector connector = ConnectorFactory.getConnector(geocode);
            final String host = connector.getHost();
            if (StringUtils.isNotBlank(host)) {
                return "http://" + host + "/" + url;
            }
        }
        return url;
    }

    private static String parseUser(final JSONObject user) throws JSONException {
        return user.getString(USER_USERNAME);
    }

    private static List<LogEntry> parseLogs(final JSONArray logsJSON) {
        List<LogEntry> result = null;
        for (int i = 0; i < logsJSON.length(); i++) {
            try {
                final JSONObject logResponse = logsJSON.getJSONObject(i);
                final LogEntry log = new LogEntry(
                        parseUser(logResponse.getJSONObject(LOG_USER)),
                        parseDate(logResponse.getString(LOG_DATE)).getTime(),
                        parseLogType(logResponse.getString(LOG_TYPE)),
                        logResponse.getString(LOG_COMMENT).trim());
                if (result == null) {
                    result = new ArrayList<LogEntry>();
                }
                result.add(log);
            } catch (final JSONException e) {
                Log.e("OkapiClient.parseLogs", e);
            }
        }
        return result;
    }

    private static List<Waypoint> parseWaypoints(final JSONArray wptsJson) {
        List<Waypoint> result = null;
        for (int i = 0; i < wptsJson.length(); i++) {
            try {
                final JSONObject wptResponse = wptsJson.getJSONObject(i);
                final Waypoint wpt = new Waypoint(wptResponse.getString(WPT_NAME),
                        parseWptType(wptResponse.getString(WPT_TYPE)),
                        false);
                wpt.setNote(wptResponse.getString(WPT_DESCRIPTION));
                final Geopoint pt = parseCoords(wptResponse.getString(WPT_LOCATION));
                if (pt != null) {
                    wpt.setCoords(pt);
                }
                if (result == null) {
                    result = new ArrayList<Waypoint>();
                }
                result.add(wpt);
            } catch (final JSONException e) {
                Log.e("OkapiClient.parseWaypoints", e);
            }
        }
        return result;
    }

    private static LogType parseLogType(final String logType) {
        if ("Found it".equalsIgnoreCase(logType)) {
            return LogType.FOUND_IT;
        }
        if ("Didn't find it".equalsIgnoreCase(logType)) {
            return LogType.DIDNT_FIND_IT;
        }
        return LogType.NOTE;
    }

    private static WaypointType parseWptType(final String wptType) {
        if ("parking".equalsIgnoreCase(wptType)) {
            return WaypointType.PARKING;
        }
        if ("path".equalsIgnoreCase(wptType)) {
            return WaypointType.TRAILHEAD;
        }
        if ("stage".equalsIgnoreCase(wptType)) {
            return WaypointType.STAGE;
        }
        if ("physical-stage".equalsIgnoreCase(wptType)) {
            return WaypointType.STAGE;
        }
        if ("virtual-stage".equalsIgnoreCase(wptType)) {
            return WaypointType.PUZZLE;
        }
        if ("final".equalsIgnoreCase(wptType)) {
            return WaypointType.FINAL;
        }
        if ("poi".equalsIgnoreCase(wptType)) {
            return WaypointType.TRAILHEAD;
        }
        return WaypointType.WAYPOINT;
    }

    private static Date parseDate(final String date) {
        final String strippedDate = date.replaceAll("\\+0([0-9]){1}\\:00", "+0$100");
        try {
            return ISO8601DATEFORMAT.parse(strippedDate);
        } catch (final ParseException e) {
            Log.e("OkapiClient.parseDate", e);
        }
        return null;
    }

    private static Geopoint parseCoords(final String location) {
        final String latitude = StringUtils.substringBefore(location, SEPARATOR_STRING);
        final String longitude = StringUtils.substringAfter(location, SEPARATOR_STRING);
        if (StringUtils.isNotBlank(latitude) && StringUtils.isNotBlank(longitude)) {
            return new Geopoint(latitude, longitude);
        }

        return null;
    }

    private static List<String> parseAttributes(final JSONArray nameList) {

        final List<String> result = new ArrayList<String>();

        for (int i = 0; i < nameList.length(); i++) {
            try {
                final String name = nameList.getString(i);
                final CacheAttribute attr = CacheAttribute.getByOcId(AttributeParser.getOcDeId(name));

                if (attr != null) {
                    result.add(attr.rawName);
                }
            } catch (final JSONException e) {
                Log.e("OkapiClient.parseAttributes", e);
            }
        }

        return result;
    }

    private static void setLocation(final Geocache cache, final String location) {
        final String latitude = StringUtils.substringBefore(location, SEPARATOR_STRING);
        final String longitude = StringUtils.substringAfter(location, SEPARATOR_STRING);
        cache.setCoords(new Geopoint(latitude, longitude));
    }

    private static CacheSize getCacheSize(final JSONObject response) {
        if (response.isNull(CACHE_SIZE)) {
            return CacheSize.NOT_CHOSEN;
        }
        double size = 0;
        try {
            size = response.getDouble(CACHE_SIZE);
        } catch (final JSONException e) {
            Log.e("OkapiClient.getCacheSize", e);
        }
        switch ((int) Math.round(size)) {
            case 1:
                return CacheSize.MICRO;
            case 2:
                return CacheSize.SMALL;
            case 3:
                return CacheSize.REGULAR;
            case 4:
                return CacheSize.LARGE;
            case 5:
                return CacheSize.LARGE;
            default:
                break;
        }
        return CacheSize.NOT_CHOSEN;
    }

    private static CacheType getCacheType(final String cacheType) {
        if (cacheType.equalsIgnoreCase("Traditional")) {
            return CacheType.TRADITIONAL;
        }
        if (cacheType.equalsIgnoreCase("Multi")) {
            return CacheType.MULTI;
        }
        if (cacheType.equalsIgnoreCase("Quiz")) {
            return CacheType.MYSTERY;
        }
        if (cacheType.equalsIgnoreCase("Virtual")) {
            return CacheType.VIRTUAL;
        }
        if (cacheType.equalsIgnoreCase("Event")) {
            return CacheType.EVENT;
        }
        if (cacheType.equalsIgnoreCase("Webcam")) {
            return CacheType.WEBCAM;
        }
        if (cacheType.equalsIgnoreCase("Math/Physics")) {
            return CacheType.MYSTERY;
        }
        if (cacheType.equalsIgnoreCase("Drive-In")) {
            return CacheType.TRADITIONAL;
        }
        return CacheType.UNKNOWN;
    }

    private static String getCoreFields(final OCApiConnector connector) {
        if (connector == null) {
            Log.e("OkapiClient.getCoreFields called with invalid connector");
            return StringUtils.EMPTY;
        }

        if (connector.getSupportedAuthLevel() == OAuthLevel.Level3) {
            return SERVICE_CACHE_CORE_FIELDS + SEPARATOR + SERVICE_CACHE_CORE_L3_FIELDS;
        }

        return SERVICE_CACHE_CORE_FIELDS;
    }

    private static String getFullFields(final OCApiConnector connector) {
        if (connector == null) {
            Log.e("OkapiClient.getFullFields called with invalid connector");
            return StringUtils.EMPTY;
        }

        final StringBuilder res = new StringBuilder(500);

        res.append(SERVICE_CACHE_CORE_FIELDS);
        res.append(SEPARATOR).append(SERVICE_CACHE_ADDITIONAL_FIELDS);
        if (connector.getSupportedAuthLevel() == OAuthLevel.Level3) {
            res.append(SEPARATOR).append(SERVICE_CACHE_CORE_L3_FIELDS);
            res.append(SEPARATOR).append(SERVICE_CACHE_ADDITIONAL_L3_FIELDS);
        }
        if (connector.getApiSupport() == ApiSupport.current) {
            res.append(SEPARATOR).append(SERVICE_CACHE_ADDITIONAL_CURRENT_FIELDS);
        }

        return res.toString();
    }

    private static JSONObject request(final OCApiConnector connector, final OkapiService service, final Parameters params) {
        if (connector == null) {
            return null;
        }

        final String host = connector.getHost();
        if (StringUtils.isBlank(host)) {
            return null;
        }

        params.add("langpref", getPreferredLanguage());

        if (connector.getSupportedAuthLevel() == OAuthLevel.Level3) {
            ImmutablePair<String, String> tokens = Settings.getTokenPair(connector.getTokenPublicPrefKeyId(), connector.getTokenSecretPrefKeyId());
            OAuth.signOAuth(host, service.methodName, "GET", false, params, tokens.left, tokens.right, connector.getCK(), connector.getCS());
        } else {
            connector.addAuthentication(params);
        }

        final String uri = "http://" + host + service.methodName;
        return Network.requestJSON(uri, params);
    }

    private static String getPreferredLanguage() {
        final String code = Locale.getDefault().getCountry();
        if (StringUtils.isNotBlank(code)) {
            return StringUtils.lowerCase(code) + "|en";
        }
        return "en";
    }

    private static void addFilterParams(final Map<String, String> valueMap, final OCApiConnector connector) {
        if (!Settings.isExcludeDisabledCaches()) {
            valueMap.put("status", "Available|Temporarily unavailable");
        }
        if (Settings.isExcludeMyCaches() && connector.getSupportedAuthLevel() == OAuthLevel.Level3) {
            valueMap.put("exclude_my_own", "true");
            valueMap.put("found_status", "notfound_only");
        }
        if (Settings.getCacheType() != CacheType.ALL) {
            valueMap.put("type", getFilterFromType(Settings.getCacheType()));
        }
    }

    private static void addRetrieveParams(final Parameters params, final OCApiConnector connector) {
        params.add("retr_method", METHOD_RETRIEVE_CACHES);
        params.add("retr_params", "{\"fields\": \"" + getCoreFields(connector) + "\"}");
        params.add("wrap", "true");
    }

    private static String getFilterFromType(final CacheType cacheType) {
        switch (cacheType) {
            case EVENT:
                return "Event";
            case MULTI:
                return "Multi";
            case MYSTERY:
                return "Quiz";
            case TRADITIONAL:
                return "Traditional";
            case VIRTUAL:
                return "Virtual";
            case WEBCAM:
                return "Webcam";
            default:
                return "";
        }
    }

    public static UserInfo getUserInfo(final OCApiLiveConnector connector) {
        final Parameters params = new Parameters("fields", USER_INFO_FIELDS);

        final JSONObject data = request(connector, OkapiService.SERVICE_USER, params);

        if (data == null) {
            return new UserInfo(StringUtils.EMPTY, 0, UserInfoStatus.FAILED);
        }

        String name = StringUtils.EMPTY;
        boolean successUserName = false;

        if (!data.isNull(USER_USERNAME)) {
            try {
                name = data.getString(USER_USERNAME);
                successUserName = true;
            } catch (final JSONException e) {
                Log.e("OkapiClient.getUserInfo - name", e);
            }
        }

        int finds = 0;
        boolean successFinds = false;

        if (!data.isNull(USER_CACHES_FOUND)) {
            try {
                finds = data.getInt(USER_CACHES_FOUND);
                successFinds = true;
            } catch (final JSONException e) {
                Log.e("OkapiClient.getUserInfo - finds", e);
            }
        }

        return new UserInfo(name, finds, successUserName && successFinds ? UserInfoStatus.SUCCESSFUL : UserInfoStatus.FAILED);
    }

}
!@#$%
20190527_002643,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_b20948
package cgeo.geocaching.settings;

import cgeo.geocaching.R;
import cgeo.geocaching.StoredList;
import cgeo.geocaching.cgeoapplication;
import cgeo.geocaching.apps.cache.navi.NavigationAppFactory.NavigationAppsEnum;
import cgeo.geocaching.connector.gc.GCConstants;
import cgeo.geocaching.connector.gc.Login;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.LiveMapStrategy.Strategy;
import cgeo.geocaching.enumerations.LogType;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.maps.MapProviderFactory;
import cgeo.geocaching.maps.google.GoogleMapProvider;
import cgeo.geocaching.maps.interfaces.GeoPointImpl;
import cgeo.geocaching.maps.interfaces.MapProvider;
import cgeo.geocaching.maps.interfaces.MapSource;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider.OfflineMapSource;
import cgeo.geocaching.utils.CryptUtils;
import cgeo.geocaching.utils.FileUtils;
import cgeo.geocaching.utils.FileUtils.FileSelector;
import cgeo.geocaching.utils.Log;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.os.Environment;
import android.preference.PreferenceManager;

import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

/**
 * General c:geo preferences/settings set by the user
 */
public final class Settings {

    public static final int SHOW_WP_THRESHOLD_DEFAULT = 10;
    public static final int SHOW_WP_THRESHOLD_MAX = 50;
    private static final int MAP_SOURCE_DEFAULT = GoogleMapProvider.GOOGLE_MAP_ID.hashCode();

    private final static int unitsMetric = 1;

    // twitter api keys
    private final static String keyConsumerPublic = CryptUtils.rot13("ESnsCvAv3kEupF1GCR3jGj");
    private final static String keyConsumerSecret = CryptUtils.rot13("7vQWceACV9umEjJucmlpFe9FCMZSeqIqfkQ2BnhV9x");

    public enum CoordInputFormatEnum {
        Plain,
        Deg,
        Min,
        Sec;

        public static CoordInputFormatEnum fromInt(int id) {
            final CoordInputFormatEnum[] values = CoordInputFormatEnum.values();
            if (id < 0 || id >= values.length) {
                return Min;
            }
            return values[id];
        }
    }

    private static final SharedPreferences sharedPrefs = PreferenceManager
            .getDefaultSharedPreferences(cgeoapplication.getInstance().getBaseContext());
    static {
        migrateSettings();
        Log.setDebug(sharedPrefs.getBoolean(getKey(R.string.pref_debug), false));
    }

    /**
     * Cache the mapsource locally. If that is an offline map source, each request would potentially access the
     * underlying map file, leading to delays.
     */
    private static MapSource mapSource;

    private Settings() {
        // this class is not to be instantiated;
    }

    private static void migrateSettings() {
        // migrate from non standard file location and integer based boolean types
        int oldVersion = getInt(R.string.pref_settingsversion, 0);
        if (oldVersion < 1) {
            final String oldPreferencesName = "cgeo.pref";
            final SharedPreferences old = cgeoapplication.getInstance().getSharedPreferences(oldPreferencesName, Context.MODE_PRIVATE);
            final Editor e = sharedPrefs.edit();

            e.putString(getKey(R.string.pref_temp_twitter_token_secret), old.getString(getKey(R.string.pref_temp_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_temp_twitter_token_public), old.getString(getKey(R.string.pref_temp_twitter_token_public), null));
            e.putBoolean(getKey(R.string.pref_help_shown), old.getInt(getKey(R.string.pref_help_shown), 0) != 0);
            e.putFloat(getKey(R.string.pref_anylongitude), old.getFloat(getKey(R.string.pref_anylongitude), 0));
            e.putFloat(getKey(R.string.pref_anylatitude), old.getFloat(getKey(R.string.pref_anylatitude), 0));
            e.putBoolean(getKey(R.string.pref_offlinemaps), 0 != old.getInt(getKey(R.string.pref_offlinemaps), 1));
            e.putBoolean(getKey(R.string.pref_offlinewpmaps), 0 != old.getInt(getKey(R.string.pref_offlinewpmaps), 0));
            e.putString(getKey(R.string.pref_webDeviceCode), old.getString(getKey(R.string.pref_webDeviceCode), null));
            e.putString(getKey(R.string.pref_webDeviceName), old.getString(getKey(R.string.pref_webDeviceName), null));
            e.putBoolean(getKey(R.string.pref_maplive), old.getInt(getKey(R.string.pref_maplive), 1) != 0);
            e.putInt(getKey(R.string.pref_mapsource), old.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT));
            e.putBoolean(getKey(R.string.pref_twitter), 0 != old.getInt(getKey(R.string.pref_twitter), 0));
            e.putBoolean(getKey(R.string.pref_showaddress), 0 != old.getInt(getKey(R.string.pref_showaddress), 1));
            e.putBoolean(getKey(R.string.pref_showcaptcha), old.getBoolean(getKey(R.string.pref_showcaptcha), false));
            e.putBoolean(getKey(R.string.pref_maptrail), old.getInt(getKey(R.string.pref_maptrail), 1) != 0);
            e.putInt(getKey(R.string.pref_lastmapzoom), old.getInt(getKey(R.string.pref_lastmapzoom), 14));
            e.putBoolean(getKey(R.string.pref_livelist), 0 != old.getInt(getKey(R.string.pref_livelist), 1));
            e.putBoolean(getKey(R.string.pref_units), old.getInt(getKey(R.string.pref_units), unitsMetric) == unitsMetric);
            e.putBoolean(getKey(R.string.pref_skin), old.getInt(getKey(R.string.pref_skin), 0) != 0);
            e.putInt(getKey(R.string.pref_lastusedlist), old.getInt(getKey(R.string.pref_lastusedlist), StoredList.STANDARD_LIST_ID));
            e.putString(getKey(R.string.pref_cachetype), old.getString(getKey(R.string.pref_cachetype), CacheType.ALL.id));
            e.putString(getKey(R.string.pref_twitter_token_secret), old.getString(getKey(R.string.pref_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_twitter_token_public), old.getString(getKey(R.string.pref_twitter_token_public), null));
            e.putInt(getKey(R.string.pref_version), old.getInt(getKey(R.string.pref_version), 0));
            e.putBoolean(getKey(R.string.pref_autoloaddesc), 0 != old.getInt(getKey(R.string.pref_autoloaddesc), 1));
            e.putBoolean(getKey(R.string.pref_ratingwanted), old.getBoolean(getKey(R.string.pref_ratingwanted), true));
            e.putBoolean(getKey(R.string.pref_friendlogswanted), old.getBoolean(getKey(R.string.pref_friendlogswanted), true));
            e.putBoolean(getKey(R.string.pref_useenglish), old.getBoolean(getKey(R.string.pref_useenglish), false));
            e.putBoolean(getKey(R.string.pref_usecompass), 0 != old.getInt(getKey(R.string.pref_usecompass), 1));
            e.putBoolean(getKey(R.string.pref_trackautovisit), old.getBoolean(getKey(R.string.pref_trackautovisit), false));
            e.putBoolean(getKey(R.string.pref_sigautoinsert), old.getBoolean(getKey(R.string.pref_sigautoinsert), false));
            e.putBoolean(getKey(R.string.pref_logimages), old.getBoolean(getKey(R.string.pref_logimages), false));
            e.putBoolean(getKey(R.string.pref_excludedisabled), 0 != old.getInt(getKey(R.string.pref_excludedisabled), 0));
            e.putBoolean(getKey(R.string.pref_excludemine), 0 != old.getInt(getKey(R.string.pref_excludemine), 0));
            e.putString(getKey(R.string.pref_mapfile), old.getString(getKey(R.string.pref_mapfile), null));
            e.putString(getKey(R.string.pref_signature), old.getString(getKey(R.string.pref_signature), null));
            e.putString(getKey(R.string.pref_pass_vote), old.getString(getKey(R.string.pref_pass_vote), null));
            e.putString(getKey(R.string.pref_password), old.getString(getKey(R.string.pref_password), null));
            e.putString(getKey(R.string.pref_username), old.getString(getKey(R.string.pref_username), null));
            e.putString(getKey(R.string.pref_memberstatus), old.getString(getKey(R.string.pref_memberstatus), ""));
            e.putInt(getKey(R.string.pref_coordinputformat), old.getInt(getKey(R.string.pref_coordinputformat), 0));
            e.putBoolean(getKey(R.string.pref_log_offline), old.getBoolean(getKey(R.string.pref_log_offline), false));
            e.putBoolean(getKey(R.string.pref_choose_list), old.getBoolean(getKey(R.string.pref_choose_list), true));
            e.putBoolean(getKey(R.string.pref_loaddirectionimg), old.getBoolean(getKey(R.string.pref_loaddirectionimg), true));
            e.putString(getKey(R.string.pref_gccustomdate), old.getString(getKey(R.string.pref_gccustomdate), null));
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), old.getInt(getKey(R.string.pref_showwaypointsthreshold), SHOW_WP_THRESHOLD_DEFAULT));
            e.putString(getKey(R.string.pref_cookiestore), old.getString(getKey(R.string.pref_cookiestore), null));
            e.putBoolean(getKey(R.string.pref_opendetailslastpage), old.getBoolean(getKey(R.string.pref_opendetailslastpage), false));
            e.putInt(getKey(R.string.pref_lastdetailspage), old.getInt(getKey(R.string.pref_lastdetailspage), 1));
            e.putInt(getKey(R.string.pref_defaultNavigationTool), old.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id));
            e.putInt(getKey(R.string.pref_defaultNavigationTool2), old.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id));
            e.putInt(getKey(R.string.pref_livemapstrategy), old.getInt(getKey(R.string.pref_livemapstrategy), Strategy.AUTO.id));
            e.putBoolean(getKey(R.string.pref_debug), old.getBoolean(getKey(R.string.pref_debug), false));
            e.putBoolean(getKey(R.string.pref_hidelivemaphint), old.getInt(getKey(R.string.pref_hidelivemaphint), 0) != 0);
            e.putInt(getKey(R.string.pref_livemaphintshowcount), old.getInt(getKey(R.string.pref_livemaphintshowcount), 0));

            e.putInt(getKey(R.string.pref_settingsversion), 1); // mark migrated
            e.commit();
        }

        // changes for new settings dialog
        if (oldVersion < 2) {
            final Editor e = sharedPrefs.edit();

            e.putBoolean(getKey(R.string.pref_units), !isUseImperialUnits());

            // show waypoints threshold now as a slider
            int wpThreshold = getWayPointsThreshold();
            if (wpThreshold < 0) {
                wpThreshold = 0;
            } else if (wpThreshold > SHOW_WP_THRESHOLD_MAX) {
                wpThreshold = SHOW_WP_THRESHOLD_MAX;
            }
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), wpThreshold);

            // KEY_MAP_SOURCE must be string, because it is the key for a ListPreference now
            int ms = sharedPrefs.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT);
            e.remove(getKey(R.string.pref_mapsource));
            e.putString(getKey(R.string.pref_mapsource), String.valueOf(ms));

            // navigation tool ids must be string, because ListPreference uses strings as keys
            int dnt1 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id);
            int dnt2 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id);
            e.remove(getKey(R.string.pref_defaultNavigationTool));
            e.remove(getKey(R.string.pref_defaultNavigationTool2));
            e.putString(getKey(R.string.pref_defaultNavigationTool), String.valueOf(dnt1));
            e.putString(getKey(R.string.pref_defaultNavigationTool2), String.valueOf(dnt2));

            // defaults for gpx directories
            e.putString(getKey(R.string.pref_gpxImportDir), getGpxImportDir());
            e.putString(getKey(R.string.pref_gpxExportDir), getGpxExportDir());

            e.putInt(getKey(R.string.pref_settingsversion), 2); // mark migrated
            e.commit();
        }
    }

    private static String getKey(final int prefKeyId) {
        return cgeoapplication.getInstance().getString(prefKeyId);
    }

    static String getString(final int prefKeyId, final String defaultValue) {
        return sharedPrefs.getString(getKey(prefKeyId), defaultValue);
    }

    private static int getInt(final int prefKeyId, final int defaultValue) {
        return sharedPrefs.getInt(getKey(prefKeyId), defaultValue);
    }

    private static long getLong(final int prefKeyId, final long defaultValue) {
        return sharedPrefs.getLong(getKey(prefKeyId), defaultValue);
    }

    private static boolean getBoolean(final int prefKeyId, final boolean defaultValue) {
        return sharedPrefs.getBoolean(getKey(prefKeyId), defaultValue);
    }

    private static float getFloat(final int prefKeyId, final float defaultValue) {
        return sharedPrefs.getFloat(getKey(prefKeyId), defaultValue);
    }

    static boolean putString(final int prefKeyId, final String value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putString(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putBoolean(final int prefKeyId, final boolean value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putBoolean(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putInt(final int prefKeyId, final int value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putInt(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putLong(final int prefKeyId, final long value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putLong(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putFloat(final int prefKeyId, final float value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putFloat(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean remove(final int prefKeyId) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.remove(getKey(prefKeyId));
        return edit.commit();
    }

    private static boolean contains(final int prefKeyId) {
        return sharedPrefs.contains(getKey(prefKeyId));
    }

    public static void setLanguage(boolean useEnglish) {
        final Configuration config = new Configuration();
        config.locale = useEnglish ? Locale.ENGLISH : Locale.getDefault();
        final Resources resources = cgeoapplication.getInstance().getResources();
        resources.updateConfiguration(config, resources.getDisplayMetrics());
    }

    public static boolean isLogin() {
        final String preUsername = getString(R.string.pref_username, null);
        final String prePassword = getString(R.string.pref_password, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    /**
     * Get login and password information.
     *
     * @return a pair either with (login, password) or (empty, empty) if no valid information is stored
     */
    public static ImmutablePair<String, String> getGcLogin() {

        final String username = getString(R.string.pref_username, null);
        final String password = getString(R.string.pref_password, null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return new ImmutablePair<String, String>(StringUtils.EMPTY, StringUtils.EMPTY);
        }

        return new ImmutablePair<String, String>(username, password);
    }

    public static String getUsername() {
        return getString(R.string.pref_username, null);
    }

    public static boolean isGCConnectorActive() {
        return getBoolean(R.string.pref_connectorGCActive, true);
    }

    public static boolean isPremiumMember() {
        // Basic Member, Premium Member, ???
        String memberStatus = Settings.getMemberStatus();
        if (memberStatus == null) {
            return false;
        }
        return GCConstants.MEMBER_STATUS_PM.equalsIgnoreCase(memberStatus);
    }

    public static String getMemberStatus() {
        return getString(R.string.pref_memberstatus, "");
    }

    public static boolean setMemberStatus(final String memberStatus) {
        if (StringUtils.isBlank(memberStatus)) {
            return remove(R.string.pref_memberstatus);
        }
        return putString(R.string.pref_memberstatus, memberStatus);
    }

    public static ImmutablePair<String, String> getTokenPair(final int tokenPublicPrefKey, final int tokenSecretPrefKey) {
        return new ImmutablePair<String, String>(getString(tokenPublicPrefKey, null), getString(tokenSecretPrefKey, null));
    }

    public static void setTokens(final int tokenPublicPrefKey, final String tokenPublic, final int tokenSecretPrefKey, final String tokenSecret) {
        if (tokenPublic == null) {
            remove(tokenPublicPrefKey);
        } else {
            putString(tokenPublicPrefKey, tokenPublic);
        }
        if (tokenSecret == null) {
            remove(tokenSecretPrefKey);
        } else {
            putString(tokenSecretPrefKey, tokenSecret);
        }
    }

    public static boolean isOCConnectorActive(int isActivePrefKeyId) {
        return getBoolean(isActivePrefKeyId, false);
    }

    public static boolean hasOCAuthorization(int tokenPublicPrefKeyId, int tokenSecretPrefKeyId) {
        return StringUtils.isNotBlank(getString(tokenPublicPrefKeyId, ""))
                && StringUtils.isNotBlank(getString(tokenSecretPrefKeyId, ""));
    }

    public static boolean isGCvoteLogin() {
        final String preUsername = getString(R.string.pref_username, null);
        final String prePassword = getString(R.string.pref_pass_vote, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    public static ImmutablePair<String, String> getGCvoteLogin() {
        final String username = getString(R.string.pref_username, null);
        final String password = getString(R.string.pref_pass_vote, null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return null;
        }

        return new ImmutablePair<String, String>(username, password);
    }

    public static String getSignature() {
        return getString(R.string.pref_signature, null);
    }

    public static boolean setCookieStore(final String cookies) {
        if (StringUtils.isBlank(cookies)) {
            // erase cookies
            return remove(R.string.pref_cookiestore);
        }
        // save cookies
        return putString(R.string.pref_cookiestore, cookies);
    }

    public static String getCookieStore() {
        return getString(R.string.pref_cookiestore, null);
    }

    /**
     * @param cacheType
     *            The cache type used for future filtering
     */
    public static void setCacheType(final CacheType cacheType) {
        if (cacheType == null) {
            remove(R.string.pref_cachetype);
        } else {
            putString(R.string.pref_cachetype, cacheType.id);
        }
    }

    public static int getLastList() {
        return getInt(R.string.pref_lastusedlist, StoredList.STANDARD_LIST_ID);
    }

    public static void saveLastList(final int listId) {
        putInt(R.string.pref_lastusedlist, listId);
    }

    public static void setWebNameCode(final String name, final String code) {
        putString(R.string.pref_webDeviceName, name);
        putString(R.string.pref_webDeviceCode, code);
    }

    public static MapProvider getMapProvider() {
        return getMapSource().getMapProvider();
    }

    public static String getMapFile() {
        return getString(R.string.pref_mapfile, null);
    }

    public static boolean setMapFile(final String mapFile) {
        boolean result = putString(R.string.pref_mapfile, mapFile);
        if (mapFile != null) {
            setMapFileDirectory(new File(mapFile).getParent());
        }
        return result;
    }

    public static String getMapFileDirectory() {
        final String mapDir = getString(R.string.pref_mapDirectory, null);
        if (mapDir != null) {
            return mapDir;
        }
        final String mapFile = getMapFile();
        if (mapFile != null) {
            return new File(mapFile).getParent();
        }
        return null;
    }

    public static boolean setMapFileDirectory(final String mapFileDirectory) {
        boolean result = putString(R.string.pref_mapDirectory, mapFileDirectory);
        MapsforgeMapProvider.getInstance().updateOfflineMaps();
        return result;
    }

    public static boolean isValidMapFile() {
        return isValidMapFile(getMapFile());
    }

    public static boolean isValidMapFile(final String mapFileIn) {
        return MapsforgeMapProvider.isValidMapFile(mapFileIn);
    }

    public static CoordInputFormatEnum getCoordInputFormat() {
        return CoordInputFormatEnum.fromInt(getInt(R.string.pref_coordinputformat, 0));
    }

    public static void setCoordInputFormat(final CoordInputFormatEnum format) {
        putInt(R.string.pref_coordinputformat, format.ordinal());
    }

    static void setLogOffline(final boolean offline) {
        putBoolean(R.string.pref_log_offline, offline);
    }

    public static boolean getLogOffline() {
        return getBoolean(R.string.pref_log_offline, false);
    }

    public static boolean getChooseList() {
        return getBoolean(R.string.pref_choose_list, false);
    }

    public static boolean getLoadDirImg() {
        return !isPremiumMember() && getBoolean(R.string.pref_loaddirectionimg, true);
    }

    public static void setGcCustomDate(final String format) {
        putString(R.string.pref_gccustomdate, format);
    }

    /**
     * @return User selected date format on GC.com
     * @see Login#GC_CUSTOM_DATE_FORMATS
     */
    public static String getGcCustomDate() {
        return getString(R.string.pref_gccustomdate, null);
    }

    public static boolean isExcludeMyCaches() {
        return getBoolean(R.string.pref_excludemine, false);
    }

    public static void setUseEnglish(final boolean english) {
        putBoolean(R.string.pref_useenglish, english);
        setLanguage(english);
    }

    public static boolean isUseEnglish() {
        return getBoolean(R.string.pref_useenglish, false);
    }

    public static boolean isShowAddress() {
        return getBoolean(R.string.pref_showaddress, true);
    }

    public static boolean isShowCaptcha() {
        return !isPremiumMember() && getBoolean(R.string.pref_showcaptcha, false);
    }

    public static boolean isExcludeDisabledCaches() {
        return getBoolean(R.string.pref_excludedisabled, false);
    }

    public static boolean isStoreOfflineMaps() {
        return getBoolean(R.string.pref_offlinemaps, true);
    }

    public static boolean isStoreOfflineWpMaps() {
        return getBoolean(R.string.pref_offlinewpmaps, false);
    }

    public static boolean isStoreLogImages() {
        return getBoolean(R.string.pref_logimages, false);
    }

    public static boolean isAutoLoadDescription() {
        return getBoolean(R.string.pref_autoloaddesc, true);
    }

    public static boolean isRatingWanted() {
        return getBoolean(R.string.pref_ratingwanted, true);
    }

    public static boolean isFriendLogsWanted() {
        if (!isLogin()) {
            // don't show a friends log if the user is anonymous
            return false;
        }
        return getBoolean(R.string.pref_friendlogswanted, true);
    }

    public static boolean isLiveList() {
        return getBoolean(R.string.pref_livelist, true);
    }

    public static boolean isTrackableAutoVisit() {
        return getBoolean(R.string.pref_trackautovisit, false);
    }

    public static boolean isAutoInsertSignature() {
        return getBoolean(R.string.pref_sigautoinsert, false);
    }

    public static boolean isUseImperialUnits() {
        return getBoolean(R.string.pref_units, getImperialUnitsDefault());
    }

    static boolean getImperialUnitsDefault() {
        final String countryCode = Locale.getDefault().getCountry();
        return "US".equals(countryCode)  // USA
            || "LR".equals(countryCode)  // Liberia
            || "MM".equals(countryCode); // Burma
    }

    public static boolean isLiveMap() {
        return getBoolean(R.string.pref_maplive, true);
    }

    public static void setLiveMap(final boolean live) {
        putBoolean(R.string.pref_maplive, live);
    }

    public static boolean isMapTrail() {
        return getBoolean(R.string.pref_maptrail, true);
    }

    public static void setMapTrail(final boolean showTrail) {
        putBoolean(R.string.pref_maptrail, showTrail);
    }

    public static int getMapZoom() {
        return getInt(R.string.pref_lastmapzoom, 14);
    }

    public static void setMapZoom(final int mapZoomLevel) {
        putInt(R.string.pref_lastmapzoom, mapZoomLevel);
    }

    public static GeoPointImpl getMapCenter() {
        return getMapProvider().getMapItemFactory()
                .getGeoPointBase(new Geopoint(getInt(R.string.pref_lastmaplat, 0) / 1e6,
                        getInt(R.string.pref_lastmaplon, 0) / 1e6));
    }

    public static void setMapCenter(final GeoPointImpl mapViewCenter) {
        putInt(R.string.pref_lastmaplat, mapViewCenter.getLatitudeE6());
        putInt(R.string.pref_lastmaplon, mapViewCenter.getLongitudeE6());
    }

    public static MapSource getMapSource() {
        if (mapSource != null) {
            return mapSource;
        }
        final int id = getConvertedMapId();
        mapSource = MapProviderFactory.getMapSource(id);
        if (mapSource != null) {
            // don't use offline maps if the map file is not valid
            if ((!(mapSource instanceof OfflineMapSource)) || (isValidMapFile())) {
                return mapSource;
            }
        }
        // fallback to first available map
        return MapProviderFactory.getDefaultSource();
    }

    private final static int GOOGLEMAP_BASEID = 30;
    private final static int MAP = 1;
    private final static int SATELLITE = 2;

    private final static int MFMAP_BASEID = 40;
    private final static int MAPNIK = 1;
    private final static int CYCLEMAP = 3;
    private final static int OFFLINE = 4;

    /**
     * convert old preference ids for maps (based on constant values) into new hash based ids
     *
     * @return
     */
    private static int getConvertedMapId() {
        // what the heck is happening here?? hashCodes of Strings?
        // why not strings?
        final int id = Integer.parseInt(getString(R.string.pref_mapsource,
                String.valueOf(MAP_SOURCE_DEFAULT)));
        switch (id) {
            case GOOGLEMAP_BASEID + MAP:
                return GoogleMapProvider.GOOGLE_MAP_ID.hashCode();
            case GOOGLEMAP_BASEID + SATELLITE:
                return GoogleMapProvider.GOOGLE_SATELLITE_ID.hashCode();
            case MFMAP_BASEID + MAPNIK:
                return MapsforgeMapProvider.MAPSFORGE_MAPNIK_ID.hashCode();
            case MFMAP_BASEID + CYCLEMAP:
                return MapsforgeMapProvider.MAPSFORGE_CYCLEMAP_ID.hashCode();
            case MFMAP_BASEID + OFFLINE: {
                final String mapFile = Settings.getMapFile();
                if (StringUtils.isNotEmpty(mapFile)) {
                    return mapFile.hashCode();
                }
                break;
            }
            default:
                break;
        }
        return id;
    }

    public static void setMapSource(final MapSource newMapSource) {
        putString(R.string.pref_mapsource, String.valueOf(newMapSource.getNumericalId()));
        if (newMapSource instanceof OfflineMapSource) {
            setMapFile(((OfflineMapSource) newMapSource).getFileName());
        }
        // cache the value
        mapSource = newMapSource;
    }

    public static void setAnyCoordinates(final Geopoint coords) {
        if (null != coords) {
            putFloat(R.string.pref_anylatitude, (float) coords.getLatitude());
            putFloat(R.string.pref_anylatitude, (float) coords.getLongitude());
        } else {
            remove(R.string.pref_anylatitude);
            remove(R.string.pref_anylongitude);
        }
    }

    public static Geopoint getAnyCoordinates() {
        if (contains(R.string.pref_anylatitude) && contains(R.string.pref_anylongitude)) {
            float lat = getFloat(R.string.pref_anylatitude, 0);
            float lon = getFloat(R.string.pref_anylongitude, 0);
            return new Geopoint(lat, lon);
        }
        return null;
    }

    public static boolean isUseCompass() {
        return getBoolean(R.string.pref_usecompass, true);
    }

    public static void setUseCompass(final boolean useCompass) {
        putBoolean(R.string.pref_usecompass, useCompass);
    }

    public static boolean isLightSkin() {
        return getBoolean(R.string.pref_skin, false);
    }

    public static String getKeyConsumerPublic() {
        return keyConsumerPublic;
    }

    public static String getKeyConsumerSecret() {
        return keyConsumerSecret;
    }

    public static String getWebDeviceCode() {
        return getString(R.string.pref_webDeviceCode, null);
    }

    public static String getWebDeviceName() {
        return getString(R.string.pref_webDeviceName, android.os.Build.MODEL);
    }

    /**
     * @return The cache type used for filtering or ALL if no filter is active.
     *         Returns never null
     */
    public static CacheType getCacheType() {
        return CacheType.getById(getString(R.string.pref_cachetype, CacheType.ALL.id));
    }

    /**
     * The Threshold for the showing of child waypoints
     */
    public static int getWayPointsThreshold() {
        return getInt(R.string.pref_showwaypointsthreshold, SHOW_WP_THRESHOLD_DEFAULT);
    }

    public static void setShowWaypointsThreshold(final int threshold) {
        putInt(R.string.pref_showwaypointsthreshold, threshold);
    }

    public static boolean isUseTwitter() {
        return getBoolean(R.string.pref_twitter, false);
    }

    public static void setUseTwitter(final boolean useTwitter) {
        putBoolean(R.string.pref_twitter, useTwitter);
    }

    public static boolean isTwitterLoginValid() {
        return !StringUtils.isBlank(getTokenPublic())
                && !StringUtils.isBlank(getTokenSecret());
    }

    public static String getTokenPublic() {
        return getString(R.string.pref_twitter_token_public, null);
    }

    public static String getTokenSecret() {
        return getString(R.string.pref_twitter_token_secret, null);

    }

    public static boolean hasTwitterAuthorization() {
        return StringUtils.isNotBlank(getTokenPublic())
                && StringUtils.isNotBlank(getTokenSecret());
    }

    public static void setTwitterTokens(final String tokenPublic,
            final String tokenSecret, boolean enableTwitter) {
        putString(R.string.pref_twitter_token_public, tokenPublic);
        putString(R.string.pref_twitter_token_secret, tokenSecret);
        if (tokenPublic != null) {
            remove(R.string.pref_temp_twitter_token_public);
            remove(R.string.pref_temp_twitter_token_secret);
        }
        setUseTwitter(enableTwitter);
    }

    public static void setTwitterTempTokens(final String tokenPublic,
            final String tokenSecret) {
        putString(R.string.pref_temp_twitter_token_public, tokenPublic);
        putString(R.string.pref_temp_twitter_token_secret, tokenSecret);
    }

    public static ImmutablePair<String, String> getTempToken() {
        String tokenPublic = getString(R.string.pref_temp_twitter_token_public, null);
        String tokenSecret = getString(R.string.pref_temp_twitter_token_secret, null);
        return new ImmutablePair<String, String>(tokenPublic, tokenSecret);
    }

    public static int getVersion() {
        return getInt(R.string.pref_version, 0);
    }

    public static void setVersion(final int version) {
        putInt(R.string.pref_version, version);
    }

    public static boolean isOpenLastDetailsPage() {
        return getBoolean(R.string.pref_opendetailslastpage, false);
    }

    public static int getLastDetailsPage() {
        return getInt(R.string.pref_lastdetailspage, 1);
    }

    public static void setLastDetailsPage(final int index) {
        putInt(R.string.pref_lastdetailspage, index);
    }

    public static int getDefaultNavigationTool() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool,
                String.valueOf(NavigationAppsEnum.COMPASS.id)));
    }

    public static void setDefaultNavigationTool(final int defaultNavigationTool) {
        putString(R.string.pref_defaultNavigationTool,
                String.valueOf(defaultNavigationTool));
    }

    public static int getDefaultNavigationTool2() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool2,
                String.valueOf(NavigationAppsEnum.INTERNAL_MAP.id)));
    }

    public static void setDefaultNavigationTool2(final int defaultNavigationTool) {
        putString(R.string.pref_defaultNavigationTool2,
                String.valueOf(defaultNavigationTool));
    }

    public static Strategy getLiveMapStrategy() {
        return Strategy.getById(getInt(R.string.pref_livemapstrategy, Strategy.AUTO.id));
    }

    public static void setLiveMapStrategy(final Strategy strategy) {
        putInt(R.string.pref_livemapstrategy, strategy.id);
    }

    public static boolean isDebug() {
        return Log.isDebug();
    }

    public static boolean getHideLiveMapHint() {
        return getBoolean(R.string.pref_hidelivemaphint, false);
    }

    public static void setHideLiveHint(final boolean hide) {
        putBoolean(R.string.pref_hidelivemaphint, hide);
    }

    public static int getLiveMapHintShowCount() {
        return getInt(R.string.pref_livemaphintshowcount, 0);
    }

    public static void setLiveMapHintShowCount(final int showCount) {
        putInt(R.string.pref_livemaphintshowcount, showCount);
    }

    public static boolean isDbOnSDCard() {
        return getBoolean(R.string.pref_dbonsdcard, false);
    }

    public static void setDbOnSDCard(final boolean dbOnSDCard) {
        putBoolean(R.string.pref_dbonsdcard, dbOnSDCard);
    }

    public static String getGpxExportDir() {
        return getString(R.string.pref_gpxExportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static String getGpxImportDir() {
        return getString(R.string.pref_gpxImportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static boolean getShareAfterExport() {
        return getBoolean(R.string.pref_shareafterexport, true);
    }

    public static void setShareAfterExport(final boolean shareAfterExport) {
        putBoolean(R.string.pref_shareafterexport, shareAfterExport);
    }

    public static int getTrackableAction() {
        return getInt(R.string.pref_trackableaction, LogType.RETRIEVED_IT.id);
    }

    public static void setTrackableAction(final int trackableAction) {
        putInt(R.string.pref_trackableaction, trackableAction);
    }

    public static String getCustomRenderThemeBaseFolder() {
        return getString(R.string.pref_renderthemepath, "");
    }

    public static String getCustomRenderThemeFilePath() {
        return getString(R.string.pref_renderthemefile, "");
    }

    public static void setCustomRenderThemeFile(final String customRenderThemeFile) {
        putString(R.string.pref_renderthemefile, customRenderThemeFile);
    }

    public static File[] getMapThemeFiles() {
        File directory = new File(Settings.getCustomRenderThemeBaseFolder());
        List<File> result = new ArrayList<File>();
        FileUtils.listDir(result, directory, new ExtensionsBasedFileSelector(new String[] { "xml" }), null);

        return result.toArray(new File[result.size()]);
    }

    private static class ExtensionsBasedFileSelector extends FileSelector {
        private final String[] extensions;
        public ExtensionsBasedFileSelector(String[] extensions) {
            this.extensions = extensions;
        }
        @Override
        public boolean isSelected(File file) {
            String filename = file.getName();
            for (String ext : extensions) {
                if (StringUtils.endsWithIgnoreCase(filename, ext)) {
                    return true;
                }
            }
            return false;
        }
        @Override
        public boolean shouldEnd() {
            return false;
        }
    }

    public static boolean getPlainLogs() {
        return getBoolean(R.string.pref_plainLogs, false);
    }

    public static boolean getUseNativeUa() {
        return getBoolean(R.string.pref_nativeUa, false);
    }

    public static String getCacheTwitterMessage() {
        // TODO make customizable from UI
        return "I found [NAME] ([URL])";
    }

    public static String getTrackableTwitterMessage() {
        // TODO make customizable from UI
        return "I touched [NAME] ([URL])!";
    }

    public static int getLogImageScale() {
        return getInt(R.string.pref_logImageScale, -1);
    }

    public static void setLogImageScale(final int scale) {
        putInt(R.string.pref_logImageScale, scale);
    }

    // Only for tests!
    static void setExcludeDisabledCaches(final boolean exclude) {
        putBoolean(R.string.pref_excludedisabled, exclude);
    }

    public static void setExcludeMine(final boolean exclude) {
        putBoolean(R.string.pref_excludemine, exclude);
    }

    static boolean setLogin(final String username, final String password) {

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            // erase username and password
            boolean a = remove(R.string.pref_username);
            boolean b = remove(R.string.pref_password);
            return a && b;
        }
        // save username and password
        boolean a = putString(R.string.pref_username, username);
        boolean b = putString(R.string.pref_password, password);
        return a && b;
    }

    static void setStoreOfflineMaps(final boolean offlineMaps) {
        putBoolean(R.string.pref_offlinemaps, offlineMaps);
    }

    static void setStoreOfflineWpMaps(final boolean offlineWpMaps) {
        putBoolean(R.string.pref_offlinewpmaps, offlineWpMaps);
    }

    static void setUseImperialUnits(final boolean imperial) {
        putBoolean(R.string.pref_units, imperial);
    }

    public static long getFieldnoteExportDate() {
        return getLong(R.string.pref_fieldnoteExportDate, 0);
    }

    public static void setFieldnoteExportDate(final long date) {
        putLong(R.string.pref_fieldnoteExportDate, date);
    }

    public static boolean isUseNavigationApp(NavigationAppsEnum navApp) {
        return getBoolean(navApp.preferenceKey, true);
    }

}
!@#$%
20190527_002643,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_a20948
package cgeo.geocaching.settings;

import cgeo.geocaching.R;
import cgeo.geocaching.StoredList;
import cgeo.geocaching.cgeoapplication;
import cgeo.geocaching.apps.cache.navi.NavigationAppFactory.NavigationAppsEnum;
import cgeo.geocaching.connector.gc.GCConstants;
import cgeo.geocaching.connector.gc.Login;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.LiveMapStrategy.Strategy;
import cgeo.geocaching.enumerations.LogType;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.maps.MapProviderFactory;
import cgeo.geocaching.maps.google.GoogleMapProvider;
import cgeo.geocaching.maps.interfaces.GeoPointImpl;
import cgeo.geocaching.maps.interfaces.MapProvider;
import cgeo.geocaching.maps.interfaces.MapSource;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider.OfflineMapSource;
import cgeo.geocaching.utils.CryptUtils;
import cgeo.geocaching.utils.FileUtils;
import cgeo.geocaching.utils.FileUtils.FileSelector;
import cgeo.geocaching.utils.Log;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.os.Environment;
import android.preference.PreferenceManager;

import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

/**
 * General c:geo preferences/settings set by the user
 */
public final class Settings {

    public static final int SHOW_WP_THRESHOLD_DEFAULT = 10;
    public static final int SHOW_WP_THRESHOLD_MAX = 50;
    private static final int MAP_SOURCE_DEFAULT = GoogleMapProvider.GOOGLE_MAP_ID.hashCode();

    private final static int unitsMetric = 1;

    // twitter api keys
    private final static String keyConsumerPublic = CryptUtils.rot13("ESnsCvAv3kEupF1GCR3jGj");
    private final static String keyConsumerSecret = CryptUtils.rot13("7vQWceACV9umEjJucmlpFe9FCMZSeqIqfkQ2BnhV9x");

    public enum CoordInputFormatEnum {
        Plain,
        Deg,
        Min,
        Sec;

        public static CoordInputFormatEnum fromInt(int id) {
            final CoordInputFormatEnum[] values = CoordInputFormatEnum.values();
            if (id < 0 || id >= values.length) {
                return Min;
            }
            return values[id];
        }
    }

    private static final SharedPreferences sharedPrefs = PreferenceManager
            .getDefaultSharedPreferences(cgeoapplication.getInstance().getBaseContext());
    static {
        migrateSettings();
        Log.setDebug(sharedPrefs.getBoolean(getKey(R.string.pref_debug), false));
    }

    /**
     * Cache the mapsource locally. If that is an offline map source, each request would potentially access the
     * underlying map file, leading to delays.
     */
    private static MapSource mapSource;

    private Settings() {
        // this class is not to be instantiated;
    }

    private static void migrateSettings() {
        // migrate from non standard file location and integer based boolean types
        int oldVersion = getInt(R.string.pref_settingsversion, 0);
        if (oldVersion < 1) {
            final String oldPreferencesName = "cgeo.pref";
            final SharedPreferences old = cgeoapplication.getInstance().getSharedPreferences(oldPreferencesName, Context.MODE_PRIVATE);
            final Editor e = sharedPrefs.edit();

            e.putString(getKey(R.string.pref_temp_twitter_token_secret), old.getString(getKey(R.string.pref_temp_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_temp_twitter_token_public), old.getString(getKey(R.string.pref_temp_twitter_token_public), null));
            e.putBoolean(getKey(R.string.pref_help_shown), old.getInt(getKey(R.string.pref_help_shown), 0) != 0);
            e.putFloat(getKey(R.string.pref_anylongitude), old.getFloat(getKey(R.string.pref_anylongitude), 0));
            e.putFloat(getKey(R.string.pref_anylatitude), old.getFloat(getKey(R.string.pref_anylatitude), 0));
            e.putBoolean(getKey(R.string.pref_offlinemaps), 0 != old.getInt(getKey(R.string.pref_offlinemaps), 1));
            e.putBoolean(getKey(R.string.pref_offlinewpmaps), 0 != old.getInt(getKey(R.string.pref_offlinewpmaps), 0));
            e.putString(getKey(R.string.pref_webDeviceCode), old.getString(getKey(R.string.pref_webDeviceCode), null));
            e.putString(getKey(R.string.pref_webDeviceName), old.getString(getKey(R.string.pref_webDeviceName), null));
            e.putBoolean(getKey(R.string.pref_maplive), old.getInt(getKey(R.string.pref_maplive), 1) != 0);
            e.putInt(getKey(R.string.pref_mapsource), old.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT));
            e.putBoolean(getKey(R.string.pref_twitter), 0 != old.getInt(getKey(R.string.pref_twitter), 0));
            e.putBoolean(getKey(R.string.pref_showaddress), 0 != old.getInt(getKey(R.string.pref_showaddress), 1));
            e.putBoolean(getKey(R.string.pref_showcaptcha), old.getBoolean(getKey(R.string.pref_showcaptcha), false));
            e.putBoolean(getKey(R.string.pref_maptrail), old.getInt(getKey(R.string.pref_maptrail), 1) != 0);
            e.putInt(getKey(R.string.pref_lastmapzoom), old.getInt(getKey(R.string.pref_lastmapzoom), 14));
            e.putBoolean(getKey(R.string.pref_livelist), 0 != old.getInt(getKey(R.string.pref_livelist), 1));
            e.putBoolean(getKey(R.string.pref_units), old.getInt(getKey(R.string.pref_units), unitsMetric) == unitsMetric);
            e.putBoolean(getKey(R.string.pref_skin), old.getInt(getKey(R.string.pref_skin), 0) != 0);
            e.putInt(getKey(R.string.pref_lastusedlist), old.getInt(getKey(R.string.pref_lastusedlist), StoredList.STANDARD_LIST_ID));
            e.putString(getKey(R.string.pref_cachetype), old.getString(getKey(R.string.pref_cachetype), CacheType.ALL.id));
            e.putString(getKey(R.string.pref_twitter_token_secret), old.getString(getKey(R.string.pref_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_twitter_token_public), old.getString(getKey(R.string.pref_twitter_token_public), null));
            e.putInt(getKey(R.string.pref_version), old.getInt(getKey(R.string.pref_version), 0));
            e.putBoolean(getKey(R.string.pref_autoloaddesc), 0 != old.getInt(getKey(R.string.pref_autoloaddesc), 1));
            e.putBoolean(getKey(R.string.pref_ratingwanted), old.getBoolean(getKey(R.string.pref_ratingwanted), true));
            e.putBoolean(getKey(R.string.pref_friendlogswanted), old.getBoolean(getKey(R.string.pref_friendlogswanted), true));
            e.putBoolean(getKey(R.string.pref_useenglish), old.getBoolean(getKey(R.string.pref_useenglish), false));
            e.putBoolean(getKey(R.string.pref_usecompass), 0 != old.getInt(getKey(R.string.pref_usecompass), 1));
            e.putBoolean(getKey(R.string.pref_trackautovisit), old.getBoolean(getKey(R.string.pref_trackautovisit), false));
            e.putBoolean(getKey(R.string.pref_sigautoinsert), old.getBoolean(getKey(R.string.pref_sigautoinsert), false));
            e.putBoolean(getKey(R.string.pref_logimages), old.getBoolean(getKey(R.string.pref_logimages), false));
            e.putBoolean(getKey(R.string.pref_excludedisabled), 0 != old.getInt(getKey(R.string.pref_excludedisabled), 0));
            e.putBoolean(getKey(R.string.pref_excludemine), 0 != old.getInt(getKey(R.string.pref_excludemine), 0));
            e.putString(getKey(R.string.pref_mapfile), old.getString(getKey(R.string.pref_mapfile), null));
            e.putString(getKey(R.string.pref_signature), old.getString(getKey(R.string.pref_signature), null));
            e.putString(getKey(R.string.pref_pass_vote), old.getString(getKey(R.string.pref_pass_vote), null));
            e.putString(getKey(R.string.pref_password), old.getString(getKey(R.string.pref_password), null));
            e.putString(getKey(R.string.pref_username), old.getString(getKey(R.string.pref_username), null));
            e.putString(getKey(R.string.pref_memberstatus), old.getString(getKey(R.string.pref_memberstatus), ""));
            e.putInt(getKey(R.string.pref_coordinputformat), old.getInt(getKey(R.string.pref_coordinputformat), 0));
            e.putBoolean(getKey(R.string.pref_log_offline), old.getBoolean(getKey(R.string.pref_log_offline), false));
            e.putBoolean(getKey(R.string.pref_choose_list), old.getBoolean(getKey(R.string.pref_choose_list), true));
            e.putBoolean(getKey(R.string.pref_loaddirectionimg), old.getBoolean(getKey(R.string.pref_loaddirectionimg), true));
            e.putString(getKey(R.string.pref_gccustomdate), old.getString(getKey(R.string.pref_gccustomdate), null));
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), old.getInt(getKey(R.string.pref_showwaypointsthreshold), SHOW_WP_THRESHOLD_DEFAULT));
            e.putString(getKey(R.string.pref_cookiestore), old.getString(getKey(R.string.pref_cookiestore), null));
            e.putBoolean(getKey(R.string.pref_opendetailslastpage), old.getBoolean(getKey(R.string.pref_opendetailslastpage), false));
            e.putInt(getKey(R.string.pref_lastdetailspage), old.getInt(getKey(R.string.pref_lastdetailspage), 1));
            e.putInt(getKey(R.string.pref_defaultNavigationTool), old.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id));
            e.putInt(getKey(R.string.pref_defaultNavigationTool2), old.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id));
            e.putInt(getKey(R.string.pref_livemapstrategy), old.getInt(getKey(R.string.pref_livemapstrategy), Strategy.AUTO.id));
            e.putBoolean(getKey(R.string.pref_debug), old.getBoolean(getKey(R.string.pref_debug), false));
            e.putBoolean(getKey(R.string.pref_hidelivemaphint), old.getInt(getKey(R.string.pref_hidelivemaphint), 0) != 0);
            e.putInt(getKey(R.string.pref_livemaphintshowcount), old.getInt(getKey(R.string.pref_livemaphintshowcount), 0));

            e.putInt(getKey(R.string.pref_settingsversion), 1); // mark migrated
            e.commit();
        }

        // changes for new settings dialog
        if (oldVersion < 2) {
            final Editor e = sharedPrefs.edit();

            e.putBoolean(getKey(R.string.pref_units), !isUseImperialUnits());

            // show waypoints threshold now as a slider
            int wpThreshold = getWayPointsThreshold();
            if (wpThreshold < 0) {
                wpThreshold = 0;
            } else if (wpThreshold > SHOW_WP_THRESHOLD_MAX) {
                wpThreshold = SHOW_WP_THRESHOLD_MAX;
            }
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), wpThreshold);

            // KEY_MAP_SOURCE must be string, because it is the key for a ListPreference now
            int ms = sharedPrefs.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT);
            e.remove(getKey(R.string.pref_mapsource));
            e.putString(getKey(R.string.pref_mapsource), String.valueOf(ms));

            // navigation tool ids must be string, because ListPreference uses strings as keys
            int dnt1 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id);
            int dnt2 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id);
            e.remove(getKey(R.string.pref_defaultNavigationTool));
            e.remove(getKey(R.string.pref_defaultNavigationTool2));
            e.putString(getKey(R.string.pref_defaultNavigationTool), String.valueOf(dnt1));
            e.putString(getKey(R.string.pref_defaultNavigationTool2), String.valueOf(dnt2));

            // defaults for gpx directories
            e.putString(getKey(R.string.pref_gpxImportDir), getGpxImportDir());
            e.putString(getKey(R.string.pref_gpxExportDir), getGpxExportDir());

            e.putInt(getKey(R.string.pref_settingsversion), 2); // mark migrated
            e.commit();
        }
    }

    private static String getKey(final int prefKeyId) {
        return cgeoapplication.getInstance().getString(prefKeyId);
    }

    static String getString(final int prefKeyId, final String defaultValue) {
        return sharedPrefs.getString(getKey(prefKeyId), defaultValue);
    }

    private static int getInt(final int prefKeyId, final int defaultValue) {
        return sharedPrefs.getInt(getKey(prefKeyId), defaultValue);
    }

    private static long getLong(final int prefKeyId, final long defaultValue) {
        return sharedPrefs.getLong(getKey(prefKeyId), defaultValue);
    }

    private static boolean getBoolean(final int prefKeyId, final boolean defaultValue) {
        return sharedPrefs.getBoolean(getKey(prefKeyId), defaultValue);
    }

    private static float getFloat(final int prefKeyId, final float defaultValue) {
        return sharedPrefs.getFloat(getKey(prefKeyId), defaultValue);
    }

    static boolean putString(final int prefKeyId, final String value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putString(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putBoolean(final int prefKeyId, final boolean value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putBoolean(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putInt(final int prefKeyId, final int value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putInt(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putLong(final int prefKeyId, final long value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putLong(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putFloat(final int prefKeyId, final float value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putFloat(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean remove(final int prefKeyId) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.remove(getKey(prefKeyId));
        return edit.commit();
    }

    private static boolean contains(final int prefKeyId) {
        return sharedPrefs.contains(getKey(prefKeyId));
    }

    public static void setLanguage(boolean useEnglish) {
        final Configuration config = new Configuration();
        config.locale = useEnglish ? Locale.ENGLISH : Locale.getDefault();
        final Resources resources = cgeoapplication.getInstance().getResources();
        resources.updateConfiguration(config, resources.getDisplayMetrics());
    }

    public static boolean isLogin() {
        final String preUsername = getString(R.string.pref_username, null);
        final String prePassword = getString(R.string.pref_password, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    /**
     * Get login and password information.
     *
     * @return a pair either with (login, password) or (empty, empty) if no valid information is stored
     */
    public static ImmutablePair<String, String> getGcLogin() {

        final String username = getString(R.string.pref_username, null);
        final String password = getString(R.string.pref_password, null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return new ImmutablePair<String, String>(StringUtils.EMPTY, StringUtils.EMPTY);
        }

        return new ImmutablePair<String, String>(username, password);
    }

    public static String getUsername() {
        return getString(R.string.pref_username, null);
    }

    public static boolean isGCConnectorActive() {
        return getBoolean(R.string.pref_connectorGCActive, true);
    }

    public static boolean isPremiumMember() {
        // Basic Member, Premium Member, ???
        String memberStatus = Settings.getMemberStatus();
        if (memberStatus == null) {
            return false;
        }
        return GCConstants.MEMBER_STATUS_PM.equalsIgnoreCase(memberStatus);
    }

    public static String getMemberStatus() {
        return getString(R.string.pref_memberstatus, "");
    }

    public static boolean setMemberStatus(final String memberStatus) {
        if (StringUtils.isBlank(memberStatus)) {
            return remove(R.string.pref_memberstatus);
        }
        return putString(R.string.pref_memberstatus, memberStatus);
    }

    public static ImmutablePair<String, String> getTokenPair(final int tokenPublicPrefKey, final int tokenSecretPrefKey) {
        return new ImmutablePair<String, String>(getString(tokenPublicPrefKey, null), getString(tokenSecretPrefKey, null));
    }

    public static void setTokens(final int tokenPublicPrefKey, final String tokenPublic, final int tokenSecretPrefKey, final String tokenSecret) {
        if (tokenPublic == null) {
            remove(tokenPublicPrefKey);
        } else {
            putString(tokenPublicPrefKey, tokenPublic);
        }
        if (tokenSecret == null) {
            remove(tokenSecretPrefKey);
        } else {
            putString(tokenSecretPrefKey, tokenSecret);
        }
    }

    public static boolean isOCConnectorActive(int isActivePrefKeyId) {
        return getBoolean(isActivePrefKeyId, false);
    }

    public static boolean hasOCAuthorization(int tokenPublicPrefKeyId, int tokenSecretPrefKeyId) {
        return StringUtils.isNotBlank(getString(tokenPublicPrefKeyId, ""))
                && StringUtils.isNotBlank(getString(tokenSecretPrefKeyId, ""));
    }

    public static boolean isGCvoteLogin() {
        final String preUsername = getString(R.string.pref_username, null);
        final String prePassword = getString(R.string.pref_pass_vote, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    public static ImmutablePair<String, String> getGCvoteLogin() {
        final String username = getString(R.string.pref_username, null);
        final String password = getString(R.string.pref_pass_vote, null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return null;
        }

        return new ImmutablePair<String, String>(username, password);
    }

    public static String getSignature() {
        return getString(R.string.pref_signature, null);
    }

    public static boolean setCookieStore(final String cookies) {
        if (StringUtils.isBlank(cookies)) {
            // erase cookies
            return remove(R.string.pref_cookiestore);
        }
        // save cookies
        return putString(R.string.pref_cookiestore, cookies);
    }

    public static String getCookieStore() {
        return getString(R.string.pref_cookiestore, null);
    }

    /**
     * @param cacheType
     *            The cache type used for future filtering
     */
    public static void setCacheType(final CacheType cacheType) {
        if (cacheType == null) {
            remove(R.string.pref_cachetype);
        } else {
            putString(R.string.pref_cachetype, cacheType.id);
        }
    }

    public static int getLastList() {
        return getInt(R.string.pref_lastusedlist, StoredList.STANDARD_LIST_ID);
    }

    public static void saveLastList(final int listId) {
        putInt(R.string.pref_lastusedlist, listId);
    }

    public static void setWebNameCode(final String name, final String code) {
        putString(R.string.pref_webDeviceName, name);
        putString(R.string.pref_webDeviceCode, code);
    }

    public static MapProvider getMapProvider() {
        return getMapSource().getMapProvider();
    }

    public static String getMapFile() {
        return getString(R.string.pref_mapfile, null);
    }

    public static boolean setMapFile(final String mapFile) {
        boolean result = putString(R.string.pref_mapfile, mapFile);
        if (mapFile != null) {
            setMapFileDirectory(new File(mapFile).getParent());
        }
        return result;
    }

    public static String getMapFileDirectory() {
        final String mapDir = getString(R.string.pref_mapDirectory, null);
        if (mapDir != null) {
            return mapDir;
        }
        final String mapFile = getMapFile();
        if (mapFile != null) {
            return new File(mapFile).getParent();
        }
        return null;
    }

    public static boolean setMapFileDirectory(final String mapFileDirectory) {
        boolean result = putString(R.string.pref_mapDirectory, mapFileDirectory);
        MapsforgeMapProvider.getInstance().updateOfflineMaps();
        return result;
    }

    public static boolean isValidMapFile() {
        return isValidMapFile(getMapFile());
    }

    public static boolean isValidMapFile(final String mapFileIn) {
        return MapsforgeMapProvider.isValidMapFile(mapFileIn);
    }

    public static CoordInputFormatEnum getCoordInputFormat() {
        return CoordInputFormatEnum.fromInt(getInt(R.string.pref_coordinputformat, 0));
    }

    public static void setCoordInputFormat(final CoordInputFormatEnum format) {
        putInt(R.string.pref_coordinputformat, format.ordinal());
    }

    static void setLogOffline(final boolean offline) {
        putBoolean(R.string.pref_log_offline, offline);
    }

    public static boolean getLogOffline() {
        return getBoolean(R.string.pref_log_offline, false);
    }

    public static boolean getChooseList() {
        return getBoolean(R.string.pref_choose_list, false);
    }

    public static boolean getLoadDirImg() {
        return !isPremiumMember() && getBoolean(R.string.pref_loaddirectionimg, true);
    }

    public static void setGcCustomDate(final String format) {
        putString(R.string.pref_gccustomdate, format);
    }

    /**
     * @return User selected date format on GC.com
     * @see Login#gcCustomDateFormats
     */
    public static String getGcCustomDate() {
        return getString(R.string.pref_gccustomdate, null);
    }

    public static boolean isExcludeMyCaches() {
        return getBoolean(R.string.pref_excludemine, false);
    }

    public static void setUseEnglish(final boolean english) {
        putBoolean(R.string.pref_useenglish, english);
        setLanguage(english);
    }

    public static boolean isUseEnglish() {
        return getBoolean(R.string.pref_useenglish, false);
    }

    public static boolean isShowAddress() {
        return getBoolean(R.string.pref_showaddress, true);
    }

    public static boolean isShowCaptcha() {
        return !isPremiumMember() && getBoolean(R.string.pref_showcaptcha, false);
    }

    public static boolean isExcludeDisabledCaches() {
        return getBoolean(R.string.pref_excludedisabled, false);
    }

    public static boolean isStoreOfflineMaps() {
        return getBoolean(R.string.pref_offlinemaps, true);
    }

    public static boolean isStoreOfflineWpMaps() {
        return getBoolean(R.string.pref_offlinewpmaps, false);
    }

    public static boolean isStoreLogImages() {
        return getBoolean(R.string.pref_logimages, false);
    }

    public static boolean isAutoLoadDescription() {
        return getBoolean(R.string.pref_autoloaddesc, true);
    }

    public static boolean isRatingWanted() {
        return getBoolean(R.string.pref_ratingwanted, true);
    }

    public static boolean isFriendLogsWanted() {
        if (!isLogin()) {
            // don't show a friends log if the user is anonymous
            return false;
        }
        return getBoolean(R.string.pref_friendlogswanted, true);
    }

    public static boolean isLiveList() {
        return getBoolean(R.string.pref_livelist, true);
    }

    public static boolean isTrackableAutoVisit() {
        return getBoolean(R.string.pref_trackautovisit, false);
    }

    public static boolean isAutoInsertSignature() {
        return getBoolean(R.string.pref_sigautoinsert, false);
    }

    public static boolean isUseImperialUnits() {
        return getBoolean(R.string.pref_units, getImperialUnitsDefault());
    }

    static boolean getImperialUnitsDefault() {
        final String countryCode = Locale.getDefault().getCountry();
        if ("US".equals(countryCode)) {
            return true; // USA
        }
        if ("LR".equals(countryCode)) {
            return true; // Liberia
        }
        if ("MM".equals(countryCode)) {
            return true; // Burma
        }
        return false;
    }

    public static boolean isLiveMap() {
        return getBoolean(R.string.pref_maplive, true);
    }

    public static void setLiveMap(final boolean live) {
        putBoolean(R.string.pref_maplive, live);
    }

    public static boolean isMapTrail() {
        return getBoolean(R.string.pref_maptrail, true);
    }

    public static void setMapTrail(final boolean showTrail) {
        putBoolean(R.string.pref_maptrail, showTrail);
    }

    public static int getMapZoom() {
        return getInt(R.string.pref_lastmapzoom, 14);
    }

    public static void setMapZoom(final int mapZoomLevel) {
        putInt(R.string.pref_lastmapzoom, mapZoomLevel);
    }

    public static GeoPointImpl getMapCenter() {
        return getMapProvider().getMapItemFactory()
                .getGeoPointBase(new Geopoint(getInt(R.string.pref_lastmaplat, 0) / 1e6,
                        getInt(R.string.pref_lastmaplon, 0) / 1e6));
    }

    public static void setMapCenter(final GeoPointImpl mapViewCenter) {
        putInt(R.string.pref_lastmaplat, mapViewCenter.getLatitudeE6());
        putInt(R.string.pref_lastmaplon, mapViewCenter.getLongitudeE6());
    }

    public static MapSource getMapSource() {
        if (mapSource != null) {
            return mapSource;
        }
        final int id = getConvertedMapId();
        mapSource = MapProviderFactory.getMapSource(id);
        if (mapSource != null) {
            // don't use offline maps if the map file is not valid
            if ((!(mapSource instanceof OfflineMapSource)) || (isValidMapFile())) {
                return mapSource;
            }
        }
        // fallback to first available map
        return MapProviderFactory.getDefaultSource();
    }

    private final static int GOOGLEMAP_BASEID = 30;
    private final static int MAP = 1;
    private final static int SATELLITE = 2;

    private final static int MFMAP_BASEID = 40;
    private final static int MAPNIK = 1;
    private final static int CYCLEMAP = 3;
    private final static int OFFLINE = 4;

    /**
     * convert old preference ids for maps (based on constant values) into new hash based ids
     *
     * @return
     */
    private static int getConvertedMapId() {
        // what the heck is happening here?? hashCodes of Strings?
        // why not strings?
        final int id = Integer.parseInt(getString(R.string.pref_mapsource,
                String.valueOf(MAP_SOURCE_DEFAULT)));
        switch (id) {
            case GOOGLEMAP_BASEID + MAP:
                return GoogleMapProvider.GOOGLE_MAP_ID.hashCode();
            case GOOGLEMAP_BASEID + SATELLITE:
                return GoogleMapProvider.GOOGLE_SATELLITE_ID.hashCode();
            case MFMAP_BASEID + MAPNIK:
                return MapsforgeMapProvider.MAPSFORGE_MAPNIK_ID.hashCode();
            case MFMAP_BASEID + CYCLEMAP:
                return MapsforgeMapProvider.MAPSFORGE_CYCLEMAP_ID.hashCode();
            case MFMAP_BASEID + OFFLINE: {
                final String mapFile = Settings.getMapFile();
                if (StringUtils.isNotEmpty(mapFile)) {
                    return mapFile.hashCode();
                }
                break;
            }
            default:
                break;
        }
        return id;
    }

    public static void setMapSource(final MapSource newMapSource) {
        putString(R.string.pref_mapsource, String.valueOf(newMapSource.getNumericalId()));
        if (newMapSource instanceof OfflineMapSource) {
            setMapFile(((OfflineMapSource) newMapSource).getFileName());
        }
        // cache the value
        mapSource = newMapSource;
    }

    public static void setAnyCoordinates(final Geopoint coords) {
        if (null != coords) {
            putFloat(R.string.pref_anylatitude, (float) coords.getLatitude());
            putFloat(R.string.pref_anylatitude, (float) coords.getLongitude());
        } else {
            remove(R.string.pref_anylatitude);
            remove(R.string.pref_anylongitude);
        }
    }

    public static Geopoint getAnyCoordinates() {
        if (contains(R.string.pref_anylatitude) && contains(R.string.pref_anylongitude)) {
            float lat = getFloat(R.string.pref_anylatitude, 0);
            float lon = getFloat(R.string.pref_anylongitude, 0);
            return new Geopoint(lat, lon);
        }
        return null;
    }

    public static boolean isUseCompass() {
        return getBoolean(R.string.pref_usecompass, true);
    }

    public static void setUseCompass(final boolean useCompass) {
        putBoolean(R.string.pref_usecompass, useCompass);
    }

    public static boolean isLightSkin() {
        return getBoolean(R.string.pref_skin, false);
    }

    public static String getKeyConsumerPublic() {
        return keyConsumerPublic;
    }

    public static String getKeyConsumerSecret() {
        return keyConsumerSecret;
    }

    public static String getWebDeviceCode() {
        return getString(R.string.pref_webDeviceCode, null);
    }

    public static String getWebDeviceName() {
        return getString(R.string.pref_webDeviceName, android.os.Build.MODEL);
    }

    /**
     * @return The cache type used for filtering or ALL if no filter is active.
     *         Returns never null
     */
    public static CacheType getCacheType() {
        return CacheType.getById(getString(R.string.pref_cachetype, CacheType.ALL.id));
    }

    /**
     * The Threshold for the showing of child waypoints
     */
    public static int getWayPointsThreshold() {
        return getInt(R.string.pref_showwaypointsthreshold, SHOW_WP_THRESHOLD_DEFAULT);
    }

    public static void setShowWaypointsThreshold(final int threshold) {
        putInt(R.string.pref_showwaypointsthreshold, threshold);
    }

    public static boolean isUseTwitter() {
        return getBoolean(R.string.pref_twitter, false);
    }

    public static void setUseTwitter(final boolean useTwitter) {
        putBoolean(R.string.pref_twitter, useTwitter);
    }

    public static boolean isTwitterLoginValid() {
        return !StringUtils.isBlank(getTokenPublic())
                && !StringUtils.isBlank(getTokenSecret());
    }

    public static String getTokenPublic() {
        return getString(R.string.pref_twitter_token_public, null);
    }

    public static String getTokenSecret() {
        return getString(R.string.pref_twitter_token_secret, null);

    }

    public static boolean hasTwitterAuthorization() {
        return StringUtils.isNotBlank(getTokenPublic())
                && StringUtils.isNotBlank(getTokenSecret());
    }

    public static void setTwitterTokens(final String tokenPublic,
            final String tokenSecret, boolean enableTwitter) {
        putString(R.string.pref_twitter_token_public, tokenPublic);
        putString(R.string.pref_twitter_token_secret, tokenSecret);
        if (tokenPublic != null) {
            remove(R.string.pref_temp_twitter_token_public);
            remove(R.string.pref_temp_twitter_token_secret);
        }
        setUseTwitter(enableTwitter);
    }

    public static void setTwitterTempTokens(final String tokenPublic,
            final String tokenSecret) {
        putString(R.string.pref_temp_twitter_token_public, tokenPublic);
        putString(R.string.pref_temp_twitter_token_secret, tokenSecret);
    }

    public static ImmutablePair<String, String> getTempToken() {
        String tokenPublic = getString(R.string.pref_temp_twitter_token_public, null);
        String tokenSecret = getString(R.string.pref_temp_twitter_token_secret, null);
        return new ImmutablePair<String, String>(tokenPublic, tokenSecret);
    }

    public static int getVersion() {
        return getInt(R.string.pref_version, 0);
    }

    public static void setVersion(final int version) {
        putInt(R.string.pref_version, version);
    }

    public static boolean isOpenLastDetailsPage() {
        return getBoolean(R.string.pref_opendetailslastpage, false);
    }

    public static int getLastDetailsPage() {
        return getInt(R.string.pref_lastdetailspage, 1);
    }

    public static void setLastDetailsPage(final int index) {
        putInt(R.string.pref_lastdetailspage, index);
    }

    public static int getDefaultNavigationTool() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool,
                String.valueOf(NavigationAppsEnum.COMPASS.id)));
    }

    public static void setDefaultNavigationTool(final int defaultNavigationTool) {
        putString(R.string.pref_defaultNavigationTool,
                String.valueOf(defaultNavigationTool));
    }

    public static int getDefaultNavigationTool2() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool2,
                String.valueOf(NavigationAppsEnum.INTERNAL_MAP.id)));
    }

    public static void setDefaultNavigationTool2(final int defaultNavigationTool) {
        putString(R.string.pref_defaultNavigationTool2,
                String.valueOf(defaultNavigationTool));
    }

    public static Strategy getLiveMapStrategy() {
        return Strategy.getById(getInt(R.string.pref_livemapstrategy, Strategy.AUTO.id));
    }

    public static void setLiveMapStrategy(final Strategy strategy) {
        putInt(R.string.pref_livemapstrategy, strategy.id);
    }

    public static boolean isDebug() {
        return Log.isDebug();
    }

    public static boolean getHideLiveMapHint() {
        return getBoolean(R.string.pref_hidelivemaphint, false);
    }

    public static void setHideLiveHint(final boolean hide) {
        putBoolean(R.string.pref_hidelivemaphint, hide);
    }

    public static int getLiveMapHintShowCount() {
        return getInt(R.string.pref_livemaphintshowcount, 0);
    }

    public static void setLiveMapHintShowCount(final int showCount) {
        putInt(R.string.pref_livemaphintshowcount, showCount);
    }

    public static boolean isDbOnSDCard() {
        return getBoolean(R.string.pref_dbonsdcard, false);
    }

    public static void setDbOnSDCard(final boolean dbOnSDCard) {
        putBoolean(R.string.pref_dbonsdcard, dbOnSDCard);
    }

    public static String getGpxExportDir() {
        return getString(R.string.pref_gpxExportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static String getGpxImportDir() {
        return getString(R.string.pref_gpxImportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static boolean getShareAfterExport() {
        return getBoolean(R.string.pref_shareafterexport, true);
    }

    public static void setShareAfterExport(final boolean shareAfterExport) {
        putBoolean(R.string.pref_shareafterexport, shareAfterExport);
    }

    public static int getTrackableAction() {
        return getInt(R.string.pref_trackableaction, LogType.RETRIEVED_IT.id);
    }

    public static void setTrackableAction(final int trackableAction) {
        putInt(R.string.pref_trackableaction, trackableAction);
    }

    public static String getCustomRenderThemeBaseFolder() {
        return getString(R.string.pref_renderthemepath, "");
    }

    public static String getCustomRenderThemeFilePath() {
        return getString(R.string.pref_renderthemefile, "");
    }

    public static void setCustomRenderThemeFile(final String customRenderThemeFile) {
        putString(R.string.pref_renderthemefile, customRenderThemeFile);
    }

    public static File[] getMapThemeFiles() {
        File directory = new File(Settings.getCustomRenderThemeBaseFolder());
        List<File> result = new ArrayList<File>();
        FileUtils.listDir(result, directory, new ExtensionsBasedFileSelector(new String[] { "xml" }), null);

        return result.toArray(new File[result.size()]);
    }

    private static class ExtensionsBasedFileSelector extends FileSelector {
        private final String[] extensions;
        public ExtensionsBasedFileSelector(String[] extensions) {
            this.extensions = extensions;
        }
        @Override
        public boolean isSelected(File file) {
            String filename = file.getName();
            for (String ext : extensions) {
                if (StringUtils.endsWithIgnoreCase(filename, ext)) {
                    return true;
                }
            }
            return false;
        }
        @Override
        public boolean shouldEnd() {
            return false;
        }
    }

    public static boolean getPlainLogs() {
        return getBoolean(R.string.pref_plainLogs, false);
    }

    public static boolean getUseNativeUa() {
        return getBoolean(R.string.pref_nativeUa, false);
    }

    public static String getCacheTwitterMessage() {
        // TODO make customizable from UI
        return "I found [NAME] ([URL])";
    }

    public static String getTrackableTwitterMessage() {
        // TODO make customizable from UI
        return "I touched [NAME] ([URL])!";
    }

    public static int getLogImageScale() {
        return getInt(R.string.pref_logImageScale, -1);
    }

    public static void setLogImageScale(final int scale) {
        putInt(R.string.pref_logImageScale, scale);
    }

    // Only for tests!
    static void setExcludeDisabledCaches(final boolean exclude) {
        putBoolean(R.string.pref_excludedisabled, exclude);
    }

    public static void setExcludeMine(final boolean exclude) {
        putBoolean(R.string.pref_excludemine, exclude);
    }

    static boolean setLogin(final String username, final String password) {

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            // erase username and password
            boolean a = remove(R.string.pref_username);
            boolean b = remove(R.string.pref_password);
            return a && b;
        }
        // save username and password
        boolean a = putString(R.string.pref_username, username);
        boolean b = putString(R.string.pref_password, password);
        return a && b;
    }

    static void setStoreOfflineMaps(final boolean offlineMaps) {
        putBoolean(R.string.pref_offlinemaps, offlineMaps);
    }

    static void setStoreOfflineWpMaps(final boolean offlineWpMaps) {
        putBoolean(R.string.pref_offlinewpmaps, offlineWpMaps);
    }

    static void setUseImperialUnits(final boolean imperial) {
        putBoolean(R.string.pref_units, imperial);
    }

    public static long getFieldnoteExportDate() {
        return getLong(R.string.pref_fieldnoteExportDate, 0);
    }

    public static void setFieldnoteExportDate(final long date) {
        putLong(R.string.pref_fieldnoteExportDate, date);
    }

    public static boolean isUseNavigationApp(NavigationAppsEnum navApp) {
        return getBoolean(navApp.preferenceKey, true);
    }

}
!@#$%
20190527_002643,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_c20948
package cgeo.geocaching.settings;

import cgeo.geocaching.R;
import cgeo.geocaching.StoredList;
import cgeo.geocaching.cgeoapplication;
import cgeo.geocaching.apps.cache.navi.NavigationAppFactory.NavigationAppsEnum;
import cgeo.geocaching.connector.gc.GCConstants;
import cgeo.geocaching.connector.gc.Login;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.LiveMapStrategy.Strategy;
import cgeo.geocaching.enumerations.LogType;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.maps.MapProviderFactory;
import cgeo.geocaching.maps.google.GoogleMapProvider;
import cgeo.geocaching.maps.interfaces.GeoPointImpl;
import cgeo.geocaching.maps.interfaces.MapProvider;
import cgeo.geocaching.maps.interfaces.MapSource;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider.OfflineMapSource;
import cgeo.geocaching.utils.CryptUtils;
import cgeo.geocaching.utils.FileUtils;
import cgeo.geocaching.utils.FileUtils.FileSelector;
import cgeo.geocaching.utils.Log;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.os.Environment;
import android.preference.PreferenceManager;

import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

/**
 * General c:geo preferences/settings set by the user
 */
public final class Settings {

    public static final int SHOW_WP_THRESHOLD_DEFAULT = 10;
    public static final int SHOW_WP_THRESHOLD_MAX = 50;
    private static final int MAP_SOURCE_DEFAULT = GoogleMapProvider.GOOGLE_MAP_ID.hashCode();

    private final static int unitsMetric = 1;

    // twitter api keys
    private final static String keyConsumerPublic = CryptUtils.rot13("ESnsCvAv3kEupF1GCR3jGj");
    private final static String keyConsumerSecret = CryptUtils.rot13("7vQWceACV9umEjJucmlpFe9FCMZSeqIqfkQ2BnhV9x");

    public enum CoordInputFormatEnum {
        Plain,
        Deg,
        Min,
        Sec;

        public static CoordInputFormatEnum fromInt(int id) {
            final CoordInputFormatEnum[] values = CoordInputFormatEnum.values();
            if (id < 0 || id >= values.length) {
                return Min;
            }
            return values[id];
        }
    }

    private static final SharedPreferences sharedPrefs = PreferenceManager
            .getDefaultSharedPreferences(cgeoapplication.getInstance().getBaseContext());
    static {
        migrateSettings();
        Log.setDebug(sharedPrefs.getBoolean(getKey(R.string.pref_debug), false));
    }

    /**
     * Cache the mapsource locally. If that is an offline map source, each request would potentially access the
     * underlying map file, leading to delays.
     */
    private static MapSource mapSource;

    private Settings() {
        // this class is not to be instantiated;
    }

    private static void migrateSettings() {
        // migrate from non standard file location and integer based boolean types
        int oldVersion = getInt(R.string.pref_settingsversion, 0);
        if (oldVersion < 1) {
            final String oldPreferencesName = "cgeo.pref";
            final SharedPreferences old = cgeoapplication.getInstance().getSharedPreferences(oldPreferencesName, Context.MODE_PRIVATE);
            final Editor e = sharedPrefs.edit();

            e.putString(getKey(R.string.pref_temp_twitter_token_secret), old.getString(getKey(R.string.pref_temp_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_temp_twitter_token_public), old.getString(getKey(R.string.pref_temp_twitter_token_public), null));
            e.putBoolean(getKey(R.string.pref_help_shown), old.getInt(getKey(R.string.pref_help_shown), 0) != 0);
            e.putFloat(getKey(R.string.pref_anylongitude), old.getFloat(getKey(R.string.pref_anylongitude), 0));
            e.putFloat(getKey(R.string.pref_anylatitude), old.getFloat(getKey(R.string.pref_anylatitude), 0));
            e.putBoolean(getKey(R.string.pref_offlinemaps), 0 != old.getInt(getKey(R.string.pref_offlinemaps), 1));
            e.putBoolean(getKey(R.string.pref_offlinewpmaps), 0 != old.getInt(getKey(R.string.pref_offlinewpmaps), 0));
            e.putString(getKey(R.string.pref_webDeviceCode), old.getString(getKey(R.string.pref_webDeviceCode), null));
            e.putString(getKey(R.string.pref_webDeviceName), old.getString(getKey(R.string.pref_webDeviceName), null));
            e.putBoolean(getKey(R.string.pref_maplive), old.getInt(getKey(R.string.pref_maplive), 1) != 0);
            e.putInt(getKey(R.string.pref_mapsource), old.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT));
            e.putBoolean(getKey(R.string.pref_twitter), 0 != old.getInt(getKey(R.string.pref_twitter), 0));
            e.putBoolean(getKey(R.string.pref_showaddress), 0 != old.getInt(getKey(R.string.pref_showaddress), 1));
            e.putBoolean(getKey(R.string.pref_showcaptcha), old.getBoolean(getKey(R.string.pref_showcaptcha), false));
            e.putBoolean(getKey(R.string.pref_maptrail), old.getInt(getKey(R.string.pref_maptrail), 1) != 0);
            e.putInt(getKey(R.string.pref_lastmapzoom), old.getInt(getKey(R.string.pref_lastmapzoom), 14));
            e.putBoolean(getKey(R.string.pref_livelist), 0 != old.getInt(getKey(R.string.pref_livelist), 1));
            e.putBoolean(getKey(R.string.pref_units), old.getInt(getKey(R.string.pref_units), unitsMetric) == unitsMetric);
            e.putBoolean(getKey(R.string.pref_skin), old.getInt(getKey(R.string.pref_skin), 0) != 0);
            e.putInt(getKey(R.string.pref_lastusedlist), old.getInt(getKey(R.string.pref_lastusedlist), StoredList.STANDARD_LIST_ID));
            e.putString(getKey(R.string.pref_cachetype), old.getString(getKey(R.string.pref_cachetype), CacheType.ALL.id));
            e.putString(getKey(R.string.pref_twitter_token_secret), old.getString(getKey(R.string.pref_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_twitter_token_public), old.getString(getKey(R.string.pref_twitter_token_public), null));
            e.putInt(getKey(R.string.pref_version), old.getInt(getKey(R.string.pref_version), 0));
            e.putBoolean(getKey(R.string.pref_autoloaddesc), 0 != old.getInt(getKey(R.string.pref_autoloaddesc), 1));
            e.putBoolean(getKey(R.string.pref_ratingwanted), old.getBoolean(getKey(R.string.pref_ratingwanted), true));
            e.putBoolean(getKey(R.string.pref_friendlogswanted), old.getBoolean(getKey(R.string.pref_friendlogswanted), true));
            e.putBoolean(getKey(R.string.pref_useenglish), old.getBoolean(getKey(R.string.pref_useenglish), false));
            e.putBoolean(getKey(R.string.pref_usecompass), 0 != old.getInt(getKey(R.string.pref_usecompass), 1));
            e.putBoolean(getKey(R.string.pref_trackautovisit), old.getBoolean(getKey(R.string.pref_trackautovisit), false));
            e.putBoolean(getKey(R.string.pref_sigautoinsert), old.getBoolean(getKey(R.string.pref_sigautoinsert), false));
            e.putBoolean(getKey(R.string.pref_logimages), old.getBoolean(getKey(R.string.pref_logimages), false));
            e.putBoolean(getKey(R.string.pref_excludedisabled), 0 != old.getInt(getKey(R.string.pref_excludedisabled), 0));
            e.putBoolean(getKey(R.string.pref_excludemine), 0 != old.getInt(getKey(R.string.pref_excludemine), 0));
            e.putString(getKey(R.string.pref_mapfile), old.getString(getKey(R.string.pref_mapfile), null));
            e.putString(getKey(R.string.pref_signature), old.getString(getKey(R.string.pref_signature), null));
            e.putString(getKey(R.string.pref_pass_vote), old.getString(getKey(R.string.pref_pass_vote), null));
            e.putString(getKey(R.string.pref_password), old.getString(getKey(R.string.pref_password), null));
            e.putString(getKey(R.string.pref_username), old.getString(getKey(R.string.pref_username), null));
            e.putString(getKey(R.string.pref_memberstatus), old.getString(getKey(R.string.pref_memberstatus), ""));
            e.putInt(getKey(R.string.pref_coordinputformat), old.getInt(getKey(R.string.pref_coordinputformat), 0));
            e.putBoolean(getKey(R.string.pref_log_offline), old.getBoolean(getKey(R.string.pref_log_offline), false));
            e.putBoolean(getKey(R.string.pref_choose_list), old.getBoolean(getKey(R.string.pref_choose_list), true));
            e.putBoolean(getKey(R.string.pref_loaddirectionimg), old.getBoolean(getKey(R.string.pref_loaddirectionimg), true));
            e.putString(getKey(R.string.pref_gccustomdate), old.getString(getKey(R.string.pref_gccustomdate), null));
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), old.getInt(getKey(R.string.pref_showwaypointsthreshold), SHOW_WP_THRESHOLD_DEFAULT));
            e.putString(getKey(R.string.pref_cookiestore), old.getString(getKey(R.string.pref_cookiestore), null));
            e.putBoolean(getKey(R.string.pref_opendetailslastpage), old.getBoolean(getKey(R.string.pref_opendetailslastpage), false));
            e.putInt(getKey(R.string.pref_lastdetailspage), old.getInt(getKey(R.string.pref_lastdetailspage), 1));
            e.putInt(getKey(R.string.pref_defaultNavigationTool), old.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id));
            e.putInt(getKey(R.string.pref_defaultNavigationTool2), old.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id));
            e.putInt(getKey(R.string.pref_livemapstrategy), old.getInt(getKey(R.string.pref_livemapstrategy), Strategy.AUTO.id));
            e.putBoolean(getKey(R.string.pref_debug), old.getBoolean(getKey(R.string.pref_debug), false));
            e.putBoolean(getKey(R.string.pref_hidelivemaphint), old.getInt(getKey(R.string.pref_hidelivemaphint), 0) != 0);
            e.putInt(getKey(R.string.pref_livemaphintshowcount), old.getInt(getKey(R.string.pref_livemaphintshowcount), 0));

            e.putInt(getKey(R.string.pref_settingsversion), 1); // mark migrated
            e.commit();
        }

        // changes for new settings dialog
        if (oldVersion < 2) {
            final Editor e = sharedPrefs.edit();

            e.putBoolean(getKey(R.string.pref_units), !isUseImperialUnits());

            // show waypoints threshold now as a slider
            int wpThreshold = getWayPointsThreshold();
            if (wpThreshold < 0) {
                wpThreshold = 0;
            } else if (wpThreshold > SHOW_WP_THRESHOLD_MAX) {
                wpThreshold = SHOW_WP_THRESHOLD_MAX;
            }
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), wpThreshold);

            // KEY_MAP_SOURCE must be string, because it is the key for a ListPreference now
            int ms = sharedPrefs.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT);
            e.remove(getKey(R.string.pref_mapsource));
            e.putString(getKey(R.string.pref_mapsource), String.valueOf(ms));

            // navigation tool ids must be string, because ListPreference uses strings as keys
            int dnt1 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id);
            int dnt2 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id);
            e.remove(getKey(R.string.pref_defaultNavigationTool));
            e.remove(getKey(R.string.pref_defaultNavigationTool2));
            e.putString(getKey(R.string.pref_defaultNavigationTool), String.valueOf(dnt1));
            e.putString(getKey(R.string.pref_defaultNavigationTool2), String.valueOf(dnt2));

            // defaults for gpx directories
            e.putString(getKey(R.string.pref_gpxImportDir), getGpxImportDir());
            e.putString(getKey(R.string.pref_gpxExportDir), getGpxExportDir());

            e.putInt(getKey(R.string.pref_settingsversion), 2); // mark migrated
            e.commit();
        }
    }

    private static String getKey(final int prefKeyId) {
        return cgeoapplication.getInstance().getString(prefKeyId);
    }

    static String getString(final int prefKeyId, final String defaultValue) {
        return sharedPrefs.getString(getKey(prefKeyId), defaultValue);
    }

    private static int getInt(final int prefKeyId, final int defaultValue) {
        return sharedPrefs.getInt(getKey(prefKeyId), defaultValue);
    }

    private static long getLong(final int prefKeyId, final long defaultValue) {
        return sharedPrefs.getLong(getKey(prefKeyId), defaultValue);
    }

    private static boolean getBoolean(final int prefKeyId, final boolean defaultValue) {
        return sharedPrefs.getBoolean(getKey(prefKeyId), defaultValue);
    }

    private static float getFloat(final int prefKeyId, final float defaultValue) {
        return sharedPrefs.getFloat(getKey(prefKeyId), defaultValue);
    }

    static boolean putString(final int prefKeyId, final String value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putString(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putBoolean(final int prefKeyId, final boolean value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putBoolean(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putInt(final int prefKeyId, final int value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putInt(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putLong(final int prefKeyId, final long value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putLong(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putFloat(final int prefKeyId, final float value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putFloat(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean remove(final int prefKeyId) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.remove(getKey(prefKeyId));
        return edit.commit();
    }

    private static boolean contains(final int prefKeyId) {
        return sharedPrefs.contains(getKey(prefKeyId));
    }

    public static void setLanguage(boolean useEnglish) {
        final Configuration config = new Configuration();
        config.locale = useEnglish ? Locale.ENGLISH : Locale.getDefault();
        final Resources resources = cgeoapplication.getInstance().getResources();
        resources.updateConfiguration(config, resources.getDisplayMetrics());
    }

    public static boolean isLogin() {
        final String preUsername = getString(R.string.pref_username, null);
        final String prePassword = getString(R.string.pref_password, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    /**
     * Get login and password information.
     *
     * @return a pair either with (login, password) or (empty, empty) if no valid information is stored
     */
    public static ImmutablePair<String, String> getGcLogin() {

        final String username = getString(R.string.pref_username, null);
        final String password = getString(R.string.pref_password, null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return new ImmutablePair<String, String>(StringUtils.EMPTY, StringUtils.EMPTY);
        }

        return new ImmutablePair<String, String>(username, password);
    }

    public static String getUsername() {
        return getString(R.string.pref_username, null);
    }

    public static boolean isGCConnectorActive() {
        return getBoolean(R.string.pref_connectorGCActive, true);
    }

    public static boolean isPremiumMember() {
        // Basic Member, Premium Member, ???
        String memberStatus = Settings.getMemberStatus();
        if (memberStatus == null) {
            return false;
        }
        return GCConstants.MEMBER_STATUS_PM.equalsIgnoreCase(memberStatus);
    }

    public static String getMemberStatus() {
        return getString(R.string.pref_memberstatus, "");
    }

    public static boolean setMemberStatus(final String memberStatus) {
        if (StringUtils.isBlank(memberStatus)) {
            return remove(R.string.pref_memberstatus);
        }
        return putString(R.string.pref_memberstatus, memberStatus);
    }

    public static ImmutablePair<String, String> getTokenPair(final int tokenPublicPrefKey, final int tokenSecretPrefKey) {
        return new ImmutablePair<String, String>(getString(tokenPublicPrefKey, null), getString(tokenSecretPrefKey, null));
    }

    public static void setTokens(final int tokenPublicPrefKey, final String tokenPublic, final int tokenSecretPrefKey, final String tokenSecret) {
        if (tokenPublic == null) {
            remove(tokenPublicPrefKey);
        } else {
            putString(tokenPublicPrefKey, tokenPublic);
        }
        if (tokenSecret == null) {
            remove(tokenSecretPrefKey);
        } else {
            putString(tokenSecretPrefKey, tokenSecret);
        }
    }

    public static boolean isOCConnectorActive(int isActivePrefKeyId) {
        return getBoolean(isActivePrefKeyId, false);
    }

    public static boolean hasOCAuthorization(int tokenPublicPrefKeyId, int tokenSecretPrefKeyId) {
        return StringUtils.isNotBlank(getString(tokenPublicPrefKeyId, ""))
                && StringUtils.isNotBlank(getString(tokenSecretPrefKeyId, ""));
    }

    public static boolean isGCvoteLogin() {
        final String preUsername = getString(R.string.pref_username, null);
        final String prePassword = getString(R.string.pref_pass_vote, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    public static ImmutablePair<String, String> getGCvoteLogin() {
        final String username = getString(R.string.pref_username, null);
        final String password = getString(R.string.pref_pass_vote, null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return null;
        }

        return new ImmutablePair<String, String>(username, password);
    }

    public static String getSignature() {
        return getString(R.string.pref_signature, null);
    }

    public static boolean setCookieStore(final String cookies) {
        if (StringUtils.isBlank(cookies)) {
            // erase cookies
            return remove(R.string.pref_cookiestore);
        }
        // save cookies
        return putString(R.string.pref_cookiestore, cookies);
    }

    public static String getCookieStore() {
        return getString(R.string.pref_cookiestore, null);
    }

    /**
     * @param cacheType
     *            The cache type used for future filtering
     */
    public static void setCacheType(final CacheType cacheType) {
        if (cacheType == null) {
            remove(R.string.pref_cachetype);
        } else {
            putString(R.string.pref_cachetype, cacheType.id);
        }
    }

    public static int getLastList() {
        return getInt(R.string.pref_lastusedlist, StoredList.STANDARD_LIST_ID);
    }

    public static void saveLastList(final int listId) {
        putInt(R.string.pref_lastusedlist, listId);
    }

    public static void setWebNameCode(final String name, final String code) {
        putString(R.string.pref_webDeviceName, name);
        putString(R.string.pref_webDeviceCode, code);
    }

    public static MapProvider getMapProvider() {
        return getMapSource().getMapProvider();
    }

    public static String getMapFile() {
        return getString(R.string.pref_mapfile, null);
    }

    public static boolean setMapFile(final String mapFile) {
        boolean result = putString(R.string.pref_mapfile, mapFile);
        if (mapFile != null) {
            setMapFileDirectory(new File(mapFile).getParent());
        }
        return result;
    }

    public static String getMapFileDirectory() {
        final String mapDir = getString(R.string.pref_mapDirectory, null);
        if (mapDir != null) {
            return mapDir;
        }
        final String mapFile = getMapFile();
        if (mapFile != null) {
            return new File(mapFile).getParent();
        }
        return null;
    }

    public static boolean setMapFileDirectory(final String mapFileDirectory) {
        boolean result = putString(R.string.pref_mapDirectory, mapFileDirectory);
        MapsforgeMapProvider.getInstance().updateOfflineMaps();
        return result;
    }

    public static boolean isValidMapFile() {
        return isValidMapFile(getMapFile());
    }

    public static boolean isValidMapFile(final String mapFileIn) {
        return MapsforgeMapProvider.isValidMapFile(mapFileIn);
    }

    public static CoordInputFormatEnum getCoordInputFormat() {
        return CoordInputFormatEnum.fromInt(getInt(R.string.pref_coordinputformat, 0));
    }

    public static void setCoordInputFormat(final CoordInputFormatEnum format) {
        putInt(R.string.pref_coordinputformat, format.ordinal());
    }

    static void setLogOffline(final boolean offline) {
        putBoolean(R.string.pref_log_offline, offline);
    }

    public static boolean getLogOffline() {
        return getBoolean(R.string.pref_log_offline, false);
    }

    public static boolean getChooseList() {
        return getBoolean(R.string.pref_choose_list, false);
    }

    public static boolean getLoadDirImg() {
        return !isPremiumMember() && getBoolean(R.string.pref_loaddirectionimg, true);
    }

    public static void setGcCustomDate(final String format) {
        putString(R.string.pref_gccustomdate, format);
    }

    /**
     * @return User selected date format on GC.com
     * @see Login#gcCustomDateFormats
     */
    public static String getGcCustomDate() {
        return getString(R.string.pref_gccustomdate, null);
    }

    public static boolean isExcludeMyCaches() {
        return getBoolean(R.string.pref_excludemine, false);
    }

    public static void setUseEnglish(final boolean english) {
        putBoolean(R.string.pref_useenglish, english);
        setLanguage(english);
    }

    public static boolean isUseEnglish() {
        return getBoolean(R.string.pref_useenglish, false);
    }

    public static boolean isShowAddress() {
        return getBoolean(R.string.pref_showaddress, true);
    }

    public static boolean isShowCaptcha() {
        return !isPremiumMember() && getBoolean(R.string.pref_showcaptcha, false);
    }

    public static boolean isExcludeDisabledCaches() {
        return getBoolean(R.string.pref_excludedisabled, false);
    }

    public static boolean isStoreOfflineMaps() {
        return getBoolean(R.string.pref_offlinemaps, true);
    }

    public static boolean isStoreOfflineWpMaps() {
        return getBoolean(R.string.pref_offlinewpmaps, false);
    }

    public static boolean isStoreLogImages() {
        return getBoolean(R.string.pref_logimages, false);
    }

    public static boolean isAutoLoadDescription() {
        return getBoolean(R.string.pref_autoloaddesc, true);
    }

    public static boolean isRatingWanted() {
        return getBoolean(R.string.pref_ratingwanted, true);
    }

    public static boolean isFriendLogsWanted() {
        if (!isLogin()) {
            // don't show a friends log if the user is anonymous
            return false;
        }
        return getBoolean(R.string.pref_friendlogswanted, true);
    }

    public static boolean isLiveList() {
        return getBoolean(R.string.pref_livelist, true);
    }

    public static boolean isTrackableAutoVisit() {
        return getBoolean(R.string.pref_trackautovisit, false);
    }

    public static boolean isAutoInsertSignature() {
        return getBoolean(R.string.pref_sigautoinsert, false);
    }

    public static boolean isUseImperialUnits() {
        return getBoolean(R.string.pref_units, getImperialUnitsDefault());
    }

    static boolean getImperialUnitsDefault() {
        final String countryCode = Locale.getDefault().getCountry();
        if ("US".equals(countryCode)) {
            return true; // USA
        }
        if ("LR".equals(countryCode)) {
            return true; // Liberia
        }
        if ("MM".equals(countryCode)) {
            return true; // Burma
        }
        return false;
    }

    public static boolean isLiveMap() {
        return getBoolean(R.string.pref_maplive, true);
    }

    public static void setLiveMap(final boolean live) {
        putBoolean(R.string.pref_maplive, live);
    }

    public static boolean isMapTrail() {
        return getBoolean(R.string.pref_maptrail, true);
    }

    public static void setMapTrail(final boolean showTrail) {
        putBoolean(R.string.pref_maptrail, showTrail);
    }

    public static int getMapZoom() {
        return getInt(R.string.pref_lastmapzoom, 14);
    }

    public static void setMapZoom(final int mapZoomLevel) {
        putInt(R.string.pref_lastmapzoom, mapZoomLevel);
    }

    public static GeoPointImpl getMapCenter() {
        return getMapProvider().getMapItemFactory()
                .getGeoPointBase(new Geopoint(getInt(R.string.pref_lastmaplat, 0) / 1e6,
                        getInt(R.string.pref_lastmaplon, 0) / 1e6));
    }

    public static void setMapCenter(final GeoPointImpl mapViewCenter) {
        putInt(R.string.pref_lastmaplat, mapViewCenter.getLatitudeE6());
        putInt(R.string.pref_lastmaplon, mapViewCenter.getLongitudeE6());
    }

    public static MapSource getMapSource() {
        if (mapSource != null) {
            return mapSource;
        }
        final int id = getConvertedMapId();
        mapSource = MapProviderFactory.getMapSource(id);
        if (mapSource != null) {
            // don't use offline maps if the map file is not valid
            if ((!(mapSource instanceof OfflineMapSource)) || (isValidMapFile())) {
                return mapSource;
            }
        }
        // fallback to first available map
        return MapProviderFactory.getDefaultSource();
    }

    private final static int GOOGLEMAP_BASEID = 30;
    private final static int MAP = 1;
    private final static int SATELLITE = 2;

    private final static int MFMAP_BASEID = 40;
    private final static int MAPNIK = 1;
    private final static int CYCLEMAP = 3;
    private final static int OFFLINE = 4;

    /**
     * convert old preference ids for maps (based on constant values) into new hash based ids
     *
     * @return
     */
    private static int getConvertedMapId() {
        // what the heck is happening here?? hashCodes of Strings?
        // why not strings?
        final int id = Integer.parseInt(getString(R.string.pref_mapsource,
                String.valueOf(MAP_SOURCE_DEFAULT)));
        switch (id) {
            case GOOGLEMAP_BASEID + MAP:
                return GoogleMapProvider.GOOGLE_MAP_ID.hashCode();
            case GOOGLEMAP_BASEID + SATELLITE:
                return GoogleMapProvider.GOOGLE_SATELLITE_ID.hashCode();
            case MFMAP_BASEID + MAPNIK:
                return MapsforgeMapProvider.MAPSFORGE_MAPNIK_ID.hashCode();
            case MFMAP_BASEID + CYCLEMAP:
                return MapsforgeMapProvider.MAPSFORGE_CYCLEMAP_ID.hashCode();
            case MFMAP_BASEID + OFFLINE: {
                final String mapFile = Settings.getMapFile();
                if (StringUtils.isNotEmpty(mapFile)) {
                    return mapFile.hashCode();
                }
                break;
            }
            default:
                break;
        }
        return id;
    }

    public static void setMapSource(final MapSource newMapSource) {
        putString(R.string.pref_mapsource, String.valueOf(newMapSource.getNumericalId()));
        if (newMapSource instanceof OfflineMapSource) {
            setMapFile(((OfflineMapSource) newMapSource).getFileName());
        }
        // cache the value
        mapSource = newMapSource;
    }

    public static void setAnyCoordinates(final Geopoint coords) {
        if (null != coords) {
            putFloat(R.string.pref_anylatitude, (float) coords.getLatitude());
            putFloat(R.string.pref_anylongitude, (float) coords.getLongitude());
        } else {
            remove(R.string.pref_anylatitude);
            remove(R.string.pref_anylongitude);
        }
    }

    public static Geopoint getAnyCoordinates() {
        if (contains(R.string.pref_anylatitude) && contains(R.string.pref_anylongitude)) {
            float lat = getFloat(R.string.pref_anylatitude, 0);
            float lon = getFloat(R.string.pref_anylongitude, 0);
            return new Geopoint(lat, lon);
        }
        return null;
    }

    public static boolean isUseCompass() {
        return getBoolean(R.string.pref_usecompass, true);
    }

    public static void setUseCompass(final boolean useCompass) {
        putBoolean(R.string.pref_usecompass, useCompass);
    }

    public static boolean isLightSkin() {
        return getBoolean(R.string.pref_skin, false);
    }

    public static String getKeyConsumerPublic() {
        return keyConsumerPublic;
    }

    public static String getKeyConsumerSecret() {
        return keyConsumerSecret;
    }

    public static String getWebDeviceCode() {
        return getString(R.string.pref_webDeviceCode, null);
    }

    public static String getWebDeviceName() {
        return getString(R.string.pref_webDeviceName, android.os.Build.MODEL);
    }

    /**
     * @return The cache type used for filtering or ALL if no filter is active.
     *         Returns never null
     */
    public static CacheType getCacheType() {
        return CacheType.getById(getString(R.string.pref_cachetype, CacheType.ALL.id));
    }

    /**
     * The Threshold for the showing of child waypoints
     */
    public static int getWayPointsThreshold() {
        return getInt(R.string.pref_showwaypointsthreshold, SHOW_WP_THRESHOLD_DEFAULT);
    }

    public static void setShowWaypointsThreshold(final int threshold) {
        putInt(R.string.pref_showwaypointsthreshold, threshold);
    }

    public static boolean isUseTwitter() {
        return getBoolean(R.string.pref_twitter, false);
    }

    public static void setUseTwitter(final boolean useTwitter) {
        putBoolean(R.string.pref_twitter, useTwitter);
    }

    public static boolean isTwitterLoginValid() {
        return !StringUtils.isBlank(getTokenPublic())
                && !StringUtils.isBlank(getTokenSecret());
    }

    public static String getTokenPublic() {
        return getString(R.string.pref_twitter_token_public, null);
    }

    public static String getTokenSecret() {
        return getString(R.string.pref_twitter_token_secret, null);

    }

    public static boolean hasTwitterAuthorization() {
        return StringUtils.isNotBlank(getTokenPublic())
                && StringUtils.isNotBlank(getTokenSecret());
    }

    public static void setTwitterTokens(final String tokenPublic,
            final String tokenSecret, boolean enableTwitter) {
        putString(R.string.pref_twitter_token_public, tokenPublic);
        putString(R.string.pref_twitter_token_secret, tokenSecret);
        if (tokenPublic != null) {
            remove(R.string.pref_temp_twitter_token_public);
            remove(R.string.pref_temp_twitter_token_secret);
        }
        setUseTwitter(enableTwitter);
    }

    public static void setTwitterTempTokens(final String tokenPublic,
            final String tokenSecret) {
        putString(R.string.pref_temp_twitter_token_public, tokenPublic);
        putString(R.string.pref_temp_twitter_token_secret, tokenSecret);
    }

    public static ImmutablePair<String, String> getTempToken() {
        String tokenPublic = getString(R.string.pref_temp_twitter_token_public, null);
        String tokenSecret = getString(R.string.pref_temp_twitter_token_secret, null);
        return new ImmutablePair<String, String>(tokenPublic, tokenSecret);
    }

    public static int getVersion() {
        return getInt(R.string.pref_version, 0);
    }

    public static void setVersion(final int version) {
        putInt(R.string.pref_version, version);
    }

    public static boolean isOpenLastDetailsPage() {
        return getBoolean(R.string.pref_opendetailslastpage, false);
    }

    public static int getLastDetailsPage() {
        return getInt(R.string.pref_lastdetailspage, 1);
    }

    public static void setLastDetailsPage(final int index) {
        putInt(R.string.pref_lastdetailspage, index);
    }

    public static int getDefaultNavigationTool() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool,
                String.valueOf(NavigationAppsEnum.COMPASS.id)));
    }

    public static void setDefaultNavigationTool(final int defaultNavigationTool) {
        putString(R.string.pref_defaultNavigationTool,
                String.valueOf(defaultNavigationTool));
    }

    public static int getDefaultNavigationTool2() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool2,
                String.valueOf(NavigationAppsEnum.INTERNAL_MAP.id)));
    }

    public static void setDefaultNavigationTool2(final int defaultNavigationTool) {
        putString(R.string.pref_defaultNavigationTool2,
                String.valueOf(defaultNavigationTool));
    }

    public static Strategy getLiveMapStrategy() {
        return Strategy.getById(getInt(R.string.pref_livemapstrategy, Strategy.AUTO.id));
    }

    public static void setLiveMapStrategy(final Strategy strategy) {
        putInt(R.string.pref_livemapstrategy, strategy.id);
    }

    public static boolean isDebug() {
        return Log.isDebug();
    }

    public static boolean getHideLiveMapHint() {
        return getBoolean(R.string.pref_hidelivemaphint, false);
    }

    public static void setHideLiveHint(final boolean hide) {
        putBoolean(R.string.pref_hidelivemaphint, hide);
    }

    public static int getLiveMapHintShowCount() {
        return getInt(R.string.pref_livemaphintshowcount, 0);
    }

    public static void setLiveMapHintShowCount(final int showCount) {
        putInt(R.string.pref_livemaphintshowcount, showCount);
    }

    public static boolean isDbOnSDCard() {
        return getBoolean(R.string.pref_dbonsdcard, false);
    }

    public static void setDbOnSDCard(final boolean dbOnSDCard) {
        putBoolean(R.string.pref_dbonsdcard, dbOnSDCard);
    }

    public static String getGpxExportDir() {
        return getString(R.string.pref_gpxExportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static String getGpxImportDir() {
        return getString(R.string.pref_gpxImportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static boolean getShareAfterExport() {
        return getBoolean(R.string.pref_shareafterexport, true);
    }

    public static void setShareAfterExport(final boolean shareAfterExport) {
        putBoolean(R.string.pref_shareafterexport, shareAfterExport);
    }

    public static int getTrackableAction() {
        return getInt(R.string.pref_trackableaction, LogType.RETRIEVED_IT.id);
    }

    public static void setTrackableAction(final int trackableAction) {
        putInt(R.string.pref_trackableaction, trackableAction);
    }

    public static String getCustomRenderThemeBaseFolder() {
        return getString(R.string.pref_renderthemepath, "");
    }

    public static String getCustomRenderThemeFilePath() {
        return getString(R.string.pref_renderthemefile, "");
    }

    public static void setCustomRenderThemeFile(final String customRenderThemeFile) {
        putString(R.string.pref_renderthemefile, customRenderThemeFile);
    }

    public static File[] getMapThemeFiles() {
        File directory = new File(Settings.getCustomRenderThemeBaseFolder());
        List<File> result = new ArrayList<File>();
        FileUtils.listDir(result, directory, new ExtensionsBasedFileSelector(new String[] { "xml" }), null);

        return result.toArray(new File[result.size()]);
    }

    private static class ExtensionsBasedFileSelector extends FileSelector {
        private final String[] extensions;
        public ExtensionsBasedFileSelector(String[] extensions) {
            this.extensions = extensions;
        }
        @Override
        public boolean isSelected(File file) {
            String filename = file.getName();
            for (String ext : extensions) {
                if (StringUtils.endsWithIgnoreCase(filename, ext)) {
                    return true;
                }
            }
            return false;
        }
        @Override
        public boolean shouldEnd() {
            return false;
        }
    }

    public static boolean getPlainLogs() {
        return getBoolean(R.string.pref_plainLogs, false);
    }

    public static boolean getUseNativeUa() {
        return getBoolean(R.string.pref_nativeUa, false);
    }

    public static String getCacheTwitterMessage() {
        // TODO make customizable from UI
        return "I found [NAME] ([URL])";
    }

    public static String getTrackableTwitterMessage() {
        // TODO make customizable from UI
        return "I touched [NAME] ([URL])!";
    }

    public static int getLogImageScale() {
        return getInt(R.string.pref_logImageScale, -1);
    }

    public static void setLogImageScale(final int scale) {
        putInt(R.string.pref_logImageScale, scale);
    }

    // Only for tests!
    static void setExcludeDisabledCaches(final boolean exclude) {
        putBoolean(R.string.pref_excludedisabled, exclude);
    }

    public static void setExcludeMine(final boolean exclude) {
        putBoolean(R.string.pref_excludemine, exclude);
    }

    static boolean setLogin(final String username, final String password) {

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            // erase username and password
            boolean a = remove(R.string.pref_username);
            boolean b = remove(R.string.pref_password);
            return a && b;
        }
        // save username and password
        boolean a = putString(R.string.pref_username, username);
        boolean b = putString(R.string.pref_password, password);
        return a && b;
    }

    static void setStoreOfflineMaps(final boolean offlineMaps) {
        putBoolean(R.string.pref_offlinemaps, offlineMaps);
    }

    static void setStoreOfflineWpMaps(final boolean offlineWpMaps) {
        putBoolean(R.string.pref_offlinewpmaps, offlineWpMaps);
    }

    static void setUseImperialUnits(final boolean imperial) {
        putBoolean(R.string.pref_units, imperial);
    }

    public static long getFieldnoteExportDate() {
        return getLong(R.string.pref_fieldnoteExportDate, 0);
    }

    public static void setFieldnoteExportDate(final long date) {
        putLong(R.string.pref_fieldnoteExportDate, date);
    }

    public static boolean isUseNavigationApp(NavigationAppsEnum navApp) {
        return getBoolean(navApp.preferenceKey, true);
    }

}
!@#$%
20190527_002730,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_b03092
package cgeo.geocaching.settings;

import cgeo.geocaching.R;
import cgeo.geocaching.StoredList;
import cgeo.geocaching.cgeoapplication;
import cgeo.geocaching.apps.cache.navi.NavigationAppFactory.NavigationAppsEnum;
import cgeo.geocaching.connector.gc.GCConstants;
import cgeo.geocaching.connector.gc.Login;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.LiveMapStrategy.Strategy;
import cgeo.geocaching.enumerations.LogType;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.maps.MapProviderFactory;
import cgeo.geocaching.maps.google.GoogleMapProvider;
import cgeo.geocaching.maps.interfaces.GeoPointImpl;
import cgeo.geocaching.maps.interfaces.MapProvider;
import cgeo.geocaching.maps.interfaces.MapSource;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider.OfflineMapSource;
import cgeo.geocaching.utils.CryptUtils;
import cgeo.geocaching.utils.FileUtils;
import cgeo.geocaching.utils.FileUtils.FileSelector;
import cgeo.geocaching.utils.Log;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.os.Environment;
import android.preference.PreferenceManager;

import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

/**
 * General c:geo preferences/settings set by the user
 */
public final class Settings {

    public static final int SHOW_WP_THRESHOLD_DEFAULT = 10;
    public static final int SHOW_WP_THRESHOLD_MAX = 50;
    private static final int MAP_SOURCE_DEFAULT = GoogleMapProvider.GOOGLE_MAP_ID.hashCode();

    private final static int unitsMetric = 1;

    // twitter api keys
    private final static String keyConsumerPublic = CryptUtils.rot13("ESnsCvAv3kEupF1GCR3jGj");
    private final static String keyConsumerSecret = CryptUtils.rot13("7vQWceACV9umEjJucmlpFe9FCMZSeqIqfkQ2BnhV9x");

    public enum CoordInputFormatEnum {
        Plain,
        Deg,
        Min,
        Sec;

        public static CoordInputFormatEnum fromInt(int id) {
            final CoordInputFormatEnum[] values = CoordInputFormatEnum.values();
            if (id < 0 || id >= values.length) {
                return Min;
            }
            return values[id];
        }
    }

    private static final SharedPreferences sharedPrefs = PreferenceManager
            .getDefaultSharedPreferences(cgeoapplication.getInstance().getBaseContext());
    static {
        migrateSettings();
        Log.setDebug(sharedPrefs.getBoolean(getKey(R.string.pref_debug), false));
    }

    /**
     * Cache the mapsource locally. If that is an offline map source, each request would potentially access the
     * underlying map file, leading to delays.
     */
    private static MapSource mapSource;

    private Settings() {
        // this class is not to be instantiated;
    }

    private static void migrateSettings() {
        // migrate from non standard file location and integer based boolean types
        int oldVersion = getInt(R.string.pref_settingsversion, 0);
        if (oldVersion < 1) {
            final String oldPreferencesName = "cgeo.pref";
            final SharedPreferences old = cgeoapplication.getInstance().getSharedPreferences(oldPreferencesName, Context.MODE_PRIVATE);
            final Editor e = sharedPrefs.edit();

            e.putString(getKey(R.string.pref_temp_twitter_token_secret), old.getString(getKey(R.string.pref_temp_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_temp_twitter_token_public), old.getString(getKey(R.string.pref_temp_twitter_token_public), null));
            e.putBoolean(getKey(R.string.pref_help_shown), old.getInt(getKey(R.string.pref_help_shown), 0) != 0);
            e.putFloat(getKey(R.string.pref_anylongitude), old.getFloat(getKey(R.string.pref_anylongitude), 0));
            e.putFloat(getKey(R.string.pref_anylatitude), old.getFloat(getKey(R.string.pref_anylatitude), 0));
            e.putBoolean(getKey(R.string.pref_offlinemaps), 0 != old.getInt(getKey(R.string.pref_offlinemaps), 1));
            e.putBoolean(getKey(R.string.pref_offlinewpmaps), 0 != old.getInt(getKey(R.string.pref_offlinewpmaps), 0));
            e.putString(getKey(R.string.pref_webDeviceCode), old.getString(getKey(R.string.pref_webDeviceCode), null));
            e.putString(getKey(R.string.pref_webDeviceName), old.getString(getKey(R.string.pref_webDeviceName), null));
            e.putBoolean(getKey(R.string.pref_maplive), old.getInt(getKey(R.string.pref_maplive), 1) != 0);
            e.putInt(getKey(R.string.pref_mapsource), old.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT));
            e.putBoolean(getKey(R.string.pref_twitter), 0 != old.getInt(getKey(R.string.pref_twitter), 0));
            e.putBoolean(getKey(R.string.pref_showaddress), 0 != old.getInt(getKey(R.string.pref_showaddress), 1));
            e.putBoolean(getKey(R.string.pref_showcaptcha), old.getBoolean(getKey(R.string.pref_showcaptcha), false));
            e.putBoolean(getKey(R.string.pref_maptrail), old.getInt(getKey(R.string.pref_maptrail), 1) != 0);
            e.putInt(getKey(R.string.pref_lastmapzoom), old.getInt(getKey(R.string.pref_lastmapzoom), 14));
            e.putBoolean(getKey(R.string.pref_livelist), 0 != old.getInt(getKey(R.string.pref_livelist), 1));
            e.putBoolean(getKey(R.string.pref_units), old.getInt(getKey(R.string.pref_units), unitsMetric) == unitsMetric);
            e.putBoolean(getKey(R.string.pref_skin), old.getInt(getKey(R.string.pref_skin), 0) != 0);
            e.putInt(getKey(R.string.pref_lastusedlist), old.getInt(getKey(R.string.pref_lastusedlist), StoredList.STANDARD_LIST_ID));
            e.putString(getKey(R.string.pref_cachetype), old.getString(getKey(R.string.pref_cachetype), CacheType.ALL.id));
            e.putString(getKey(R.string.pref_twitter_token_secret), old.getString(getKey(R.string.pref_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_twitter_token_public), old.getString(getKey(R.string.pref_twitter_token_public), null));
            e.putInt(getKey(R.string.pref_version), old.getInt(getKey(R.string.pref_version), 0));
            e.putBoolean(getKey(R.string.pref_autoloaddesc), 0 != old.getInt(getKey(R.string.pref_autoloaddesc), 1));
            e.putBoolean(getKey(R.string.pref_ratingwanted), old.getBoolean(getKey(R.string.pref_ratingwanted), true));
            e.putBoolean(getKey(R.string.pref_friendlogswanted), old.getBoolean(getKey(R.string.pref_friendlogswanted), true));
            e.putBoolean(getKey(R.string.pref_useenglish), old.getBoolean(getKey(R.string.pref_useenglish), false));
            e.putBoolean(getKey(R.string.pref_usecompass), 0 != old.getInt(getKey(R.string.pref_usecompass), 1));
            e.putBoolean(getKey(R.string.pref_trackautovisit), old.getBoolean(getKey(R.string.pref_trackautovisit), false));
            e.putBoolean(getKey(R.string.pref_sigautoinsert), old.getBoolean(getKey(R.string.pref_sigautoinsert), false));
            e.putBoolean(getKey(R.string.pref_logimages), old.getBoolean(getKey(R.string.pref_logimages), false));
            e.putBoolean(getKey(R.string.pref_excludedisabled), 0 != old.getInt(getKey(R.string.pref_excludedisabled), 0));
            e.putBoolean(getKey(R.string.pref_excludemine), 0 != old.getInt(getKey(R.string.pref_excludemine), 0));
            e.putString(getKey(R.string.pref_mapfile), old.getString(getKey(R.string.pref_mapfile), null));
            e.putString(getKey(R.string.pref_signature), old.getString(getKey(R.string.pref_signature), null));
            e.putString(getKey(R.string.pref_pass_vote), old.getString(getKey(R.string.pref_pass_vote), null));
            e.putString(getKey(R.string.pref_password), old.getString(getKey(R.string.pref_password), null));
            e.putString(getKey(R.string.pref_username), old.getString(getKey(R.string.pref_username), null));
            e.putString(getKey(R.string.pref_memberstatus), old.getString(getKey(R.string.pref_memberstatus), ""));
            e.putInt(getKey(R.string.pref_coordinputformat), old.getInt(getKey(R.string.pref_coordinputformat), 0));
            e.putBoolean(getKey(R.string.pref_log_offline), old.getBoolean(getKey(R.string.pref_log_offline), false));
            e.putBoolean(getKey(R.string.pref_choose_list), old.getBoolean(getKey(R.string.pref_choose_list), true));
            e.putBoolean(getKey(R.string.pref_loaddirectionimg), old.getBoolean(getKey(R.string.pref_loaddirectionimg), true));
            e.putString(getKey(R.string.pref_gccustomdate), old.getString(getKey(R.string.pref_gccustomdate), null));
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), old.getInt(getKey(R.string.pref_showwaypointsthreshold), SHOW_WP_THRESHOLD_DEFAULT));
            e.putString(getKey(R.string.pref_cookiestore), old.getString(getKey(R.string.pref_cookiestore), null));
            e.putBoolean(getKey(R.string.pref_opendetailslastpage), old.getBoolean(getKey(R.string.pref_opendetailslastpage), false));
            e.putInt(getKey(R.string.pref_lastdetailspage), old.getInt(getKey(R.string.pref_lastdetailspage), 1));
            e.putInt(getKey(R.string.pref_defaultNavigationTool), old.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id));
            e.putInt(getKey(R.string.pref_defaultNavigationTool2), old.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id));
            e.putInt(getKey(R.string.pref_livemapstrategy), old.getInt(getKey(R.string.pref_livemapstrategy), Strategy.AUTO.id));
            e.putBoolean(getKey(R.string.pref_debug), old.getBoolean(getKey(R.string.pref_debug), false));
            e.putBoolean(getKey(R.string.pref_hidelivemaphint), old.getInt(getKey(R.string.pref_hidelivemaphint), 0) != 0);
            e.putInt(getKey(R.string.pref_livemaphintshowcount), old.getInt(getKey(R.string.pref_livemaphintshowcount), 0));

            e.putInt(getKey(R.string.pref_settingsversion), 1); // mark migrated
            e.commit();
        }

        // changes for new settings dialog
        if (oldVersion < 2) {
            final Editor e = sharedPrefs.edit();

            e.putBoolean(getKey(R.string.pref_units), !isUseImperialUnits());

            // show waypoints threshold now as a slider
            int wpThreshold = getWayPointsThreshold();
            if (wpThreshold < 0) {
                wpThreshold = 0;
            } else if (wpThreshold > SHOW_WP_THRESHOLD_MAX) {
                wpThreshold = SHOW_WP_THRESHOLD_MAX;
            }
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), wpThreshold);

            // KEY_MAP_SOURCE must be string, because it is the key for a ListPreference now
            int ms = sharedPrefs.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT);
            e.remove(getKey(R.string.pref_mapsource));
            e.putString(getKey(R.string.pref_mapsource), String.valueOf(ms));

            // navigation tool ids must be string, because ListPreference uses strings as keys
            int dnt1 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id);
            int dnt2 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id);
            e.remove(getKey(R.string.pref_defaultNavigationTool));
            e.remove(getKey(R.string.pref_defaultNavigationTool2));
            e.putString(getKey(R.string.pref_defaultNavigationTool), String.valueOf(dnt1));
            e.putString(getKey(R.string.pref_defaultNavigationTool2), String.valueOf(dnt2));

            // defaults for gpx directories
            e.putString(getKey(R.string.pref_gpxImportDir), getGpxImportDir());
            e.putString(getKey(R.string.pref_gpxExportDir), getGpxExportDir());

            e.putInt(getKey(R.string.pref_settingsversion), 2); // mark migrated
            e.commit();
        }
    }

    private static String getKey(final int prefKeyId) {
        return cgeoapplication.getInstance().getString(prefKeyId);
    }

    static String getString(final int prefKeyId, final String defaultValue) {
        return sharedPrefs.getString(getKey(prefKeyId), defaultValue);
    }

    private static int getInt(final int prefKeyId, final int defaultValue) {
        return sharedPrefs.getInt(getKey(prefKeyId), defaultValue);
    }

    private static long getLong(final int prefKeyId, final long defaultValue) {
        return sharedPrefs.getLong(getKey(prefKeyId), defaultValue);
    }

    private static boolean getBoolean(final int prefKeyId, final boolean defaultValue) {
        return sharedPrefs.getBoolean(getKey(prefKeyId), defaultValue);
    }

    private static float getFloat(final int prefKeyId, final float defaultValue) {
        return sharedPrefs.getFloat(getKey(prefKeyId), defaultValue);
    }

    static boolean putString(final int prefKeyId, final String value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putString(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putBoolean(final int prefKeyId, final boolean value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putBoolean(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putInt(final int prefKeyId, final int value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putInt(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putLong(final int prefKeyId, final long value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putLong(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putFloat(final int prefKeyId, final float value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putFloat(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean remove(final int prefKeyId) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.remove(getKey(prefKeyId));
        return edit.commit();
    }

    private static boolean contains(final int prefKeyId) {
        return sharedPrefs.contains(getKey(prefKeyId));
    }

    public static void setLanguage(boolean useEnglish) {
        final Configuration config = new Configuration();
        config.locale = useEnglish ? Locale.ENGLISH : Locale.getDefault();
        final Resources resources = cgeoapplication.getInstance().getResources();
        resources.updateConfiguration(config, resources.getDisplayMetrics());
    }

    public static boolean isLogin() {
        final String preUsername = getString(R.string.pref_username, null);
        final String prePassword = getString(R.string.pref_password, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    /**
     * Get login and password information.
     *
     * @return a pair either with (login, password) or (empty, empty) if no valid information is stored
     */
    public static ImmutablePair<String, String> getGcLogin() {

        final String username = getString(R.string.pref_username, null);
        final String password = getString(R.string.pref_password, null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return new ImmutablePair<String, String>(StringUtils.EMPTY, StringUtils.EMPTY);
        }

        return new ImmutablePair<String, String>(username, password);
    }

    public static String getUsername() {
        return getString(R.string.pref_username, null);
    }

    public static boolean isGCConnectorActive() {
        return getBoolean(R.string.pref_connectorGCActive, true);
    }

    public static boolean isPremiumMember() {
        // Basic Member, Premium Member, ???
        String memberStatus = Settings.getMemberStatus();
        if (memberStatus == null) {
            return false;
        }
        return GCConstants.MEMBER_STATUS_PM.equalsIgnoreCase(memberStatus);
    }

    public static String getMemberStatus() {
        return getString(R.string.pref_memberstatus, "");
    }

    public static boolean setMemberStatus(final String memberStatus) {
        if (StringUtils.isBlank(memberStatus)) {
            return remove(R.string.pref_memberstatus);
        }
        return putString(R.string.pref_memberstatus, memberStatus);
    }

    public static ImmutablePair<String, String> getTokenPair(final int tokenPublicPrefKey, final int tokenSecretPrefKey) {
        return new ImmutablePair<String, String>(getString(tokenPublicPrefKey, null), getString(tokenSecretPrefKey, null));
    }

    public static void setTokens(final int tokenPublicPrefKey, final String tokenPublic, final int tokenSecretPrefKey, final String tokenSecret) {
        if (tokenPublic == null) {
            remove(tokenPublicPrefKey);
        } else {
            putString(tokenPublicPrefKey, tokenPublic);
        }
        if (tokenSecret == null) {
            remove(tokenSecretPrefKey);
        } else {
            putString(tokenSecretPrefKey, tokenSecret);
        }
    }

    public static boolean isOCConnectorActive(int isActivePrefKeyId) {
        return getBoolean(isActivePrefKeyId, false);
    }

    public static boolean hasOCAuthorization(int tokenPublicPrefKeyId, int tokenSecretPrefKeyId) {
        return StringUtils.isNotBlank(getString(tokenPublicPrefKeyId, ""))
                && StringUtils.isNotBlank(getString(tokenSecretPrefKeyId, ""));
    }

    public static boolean isGCvoteLogin() {
        final String preUsername = getString(R.string.pref_username, null);
        final String prePassword = getString(R.string.pref_pass_vote, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    public static ImmutablePair<String, String> getGCvoteLogin() {
        final String username = getString(R.string.pref_username, null);
        final String password = getString(R.string.pref_pass_vote, null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return null;
        }

        return new ImmutablePair<String, String>(username, password);
    }

    public static String getSignature() {
        return getString(R.string.pref_signature, null);
    }

    public static boolean setCookieStore(final String cookies) {
        if (StringUtils.isBlank(cookies)) {
            // erase cookies
            return remove(R.string.pref_cookiestore);
        }
        // save cookies
        return putString(R.string.pref_cookiestore, cookies);
    }

    public static String getCookieStore() {
        return getString(R.string.pref_cookiestore, null);
    }

    /**
     * @param cacheType
     *            The cache type used for future filtering
     */
    public static void setCacheType(final CacheType cacheType) {
        if (cacheType == null) {
            remove(R.string.pref_cachetype);
        } else {
            putString(R.string.pref_cachetype, cacheType.id);
        }
    }

    public static int getLastList() {
        return getInt(R.string.pref_lastusedlist, StoredList.STANDARD_LIST_ID);
    }

    public static void saveLastList(final int listId) {
        putInt(R.string.pref_lastusedlist, listId);
    }

    public static void setWebNameCode(final String name, final String code) {
        putString(R.string.pref_webDeviceName, name);
        putString(R.string.pref_webDeviceCode, code);
    }

    public static MapProvider getMapProvider() {
        return getMapSource().getMapProvider();
    }

    public static String getMapFile() {
        return getString(R.string.pref_mapfile, null);
    }

    public static boolean setMapFile(final String mapFile) {
        boolean result = putString(R.string.pref_mapfile, mapFile);
        if (mapFile != null) {
            setMapFileDirectory(new File(mapFile).getParent());
        }
        return result;
    }

    public static String getMapFileDirectory() {
        final String mapDir = getString(R.string.pref_mapDirectory, null);
        if (mapDir != null) {
            return mapDir;
        }
        final String mapFile = getMapFile();
        if (mapFile != null) {
            return new File(mapFile).getParent();
        }
        return null;
    }

    public static boolean setMapFileDirectory(final String mapFileDirectory) {
        boolean result = putString(R.string.pref_mapDirectory, mapFileDirectory);
        MapsforgeMapProvider.getInstance().updateOfflineMaps();
        return result;
    }

    public static boolean isValidMapFile() {
        return isValidMapFile(getMapFile());
    }

    public static boolean isValidMapFile(final String mapFileIn) {
        return MapsforgeMapProvider.isValidMapFile(mapFileIn);
    }

    public static CoordInputFormatEnum getCoordInputFormat() {
        return CoordInputFormatEnum.fromInt(getInt(R.string.pref_coordinputformat, 0));
    }

    public static void setCoordInputFormat(final CoordInputFormatEnum format) {
        putInt(R.string.pref_coordinputformat, format.ordinal());
    }

    static void setLogOffline(final boolean offline) {
        putBoolean(R.string.pref_log_offline, offline);
    }

    public static boolean getLogOffline() {
        return getBoolean(R.string.pref_log_offline, false);
    }

    public static boolean getChooseList() {
        return getBoolean(R.string.pref_choose_list, false);
    }

    public static boolean getLoadDirImg() {
        return !isPremiumMember() && getBoolean(R.string.pref_loaddirectionimg, true);
    }

    public static void setGcCustomDate(final String format) {
        putString(R.string.pref_gccustomdate, format);
    }

    /**
     * @return User selected date format on GC.com
     * @see Login#GC_CUSTOM_DATE_FORMATS
     */
    public static String getGcCustomDate() {
        return getString(R.string.pref_gccustomdate, null);
    }

    public static boolean isExcludeMyCaches() {
        return getBoolean(R.string.pref_excludemine, false);
    }

    public static void setUseEnglish(final boolean english) {
        putBoolean(R.string.pref_useenglish, english);
        setLanguage(english);
    }

    public static boolean isUseEnglish() {
        return getBoolean(R.string.pref_useenglish, false);
    }

    public static boolean isShowAddress() {
        return getBoolean(R.string.pref_showaddress, true);
    }

    public static boolean isShowCaptcha() {
        return !isPremiumMember() && getBoolean(R.string.pref_showcaptcha, false);
    }

    public static boolean isExcludeDisabledCaches() {
        return getBoolean(R.string.pref_excludedisabled, false);
    }

    public static boolean isStoreOfflineMaps() {
        return getBoolean(R.string.pref_offlinemaps, true);
    }

    public static boolean isStoreOfflineWpMaps() {
        return getBoolean(R.string.pref_offlinewpmaps, false);
    }

    public static boolean isStoreLogImages() {
        return getBoolean(R.string.pref_logimages, false);
    }

    public static boolean isAutoLoadDescription() {
        return getBoolean(R.string.pref_autoloaddesc, true);
    }

    public static boolean isRatingWanted() {
        return getBoolean(R.string.pref_ratingwanted, true);
    }

    public static boolean isFriendLogsWanted() {
        if (!isLogin()) {
            // don't show a friends log if the user is anonymous
            return false;
        }
        return getBoolean(R.string.pref_friendlogswanted, true);
    }

    public static boolean isLiveList() {
        return getBoolean(R.string.pref_livelist, true);
    }

    public static boolean isTrackableAutoVisit() {
        return getBoolean(R.string.pref_trackautovisit, false);
    }

    public static boolean isAutoInsertSignature() {
        return getBoolean(R.string.pref_sigautoinsert, false);
    }

    public static boolean isUseImperialUnits() {
        return getBoolean(R.string.pref_units, getImperialUnitsDefault());
    }

    static boolean getImperialUnitsDefault() {
        final String countryCode = Locale.getDefault().getCountry();
        return "US".equals(countryCode)  // USA
            || "LR".equals(countryCode)  // Liberia
            || "MM".equals(countryCode); // Burma
    }

    public static boolean isLiveMap() {
        return getBoolean(R.string.pref_maplive, true);
    }

    public static void setLiveMap(final boolean live) {
        putBoolean(R.string.pref_maplive, live);
    }

    public static boolean isMapTrail() {
        return getBoolean(R.string.pref_maptrail, true);
    }

    public static void setMapTrail(final boolean showTrail) {
        putBoolean(R.string.pref_maptrail, showTrail);
    }

    public static int getMapZoom() {
        return getInt(R.string.pref_lastmapzoom, 14);
    }

    public static void setMapZoom(final int mapZoomLevel) {
        putInt(R.string.pref_lastmapzoom, mapZoomLevel);
    }

    public static GeoPointImpl getMapCenter() {
        return getMapProvider().getMapItemFactory()
                .getGeoPointBase(new Geopoint(getInt(R.string.pref_lastmaplat, 0) / 1e6,
                        getInt(R.string.pref_lastmaplon, 0) / 1e6));
    }

    public static void setMapCenter(final GeoPointImpl mapViewCenter) {
        putInt(R.string.pref_lastmaplat, mapViewCenter.getLatitudeE6());
        putInt(R.string.pref_lastmaplon, mapViewCenter.getLongitudeE6());
    }

    public static MapSource getMapSource() {
        if (mapSource != null) {
            return mapSource;
        }
        final int id = getConvertedMapId();
        mapSource = MapProviderFactory.getMapSource(id);
        if (mapSource != null) {
            // don't use offline maps if the map file is not valid
            if ((!(mapSource instanceof OfflineMapSource)) || (isValidMapFile())) {
                return mapSource;
            }
        }
        // fallback to first available map
        return MapProviderFactory.getDefaultSource();
    }

    private final static int GOOGLEMAP_BASEID = 30;
    private final static int MAP = 1;
    private final static int SATELLITE = 2;

    private final static int MFMAP_BASEID = 40;
    private final static int MAPNIK = 1;
    private final static int CYCLEMAP = 3;
    private final static int OFFLINE = 4;

    /**
     * convert old preference ids for maps (based on constant values) into new hash based ids
     *
     * @return
     */
    private static int getConvertedMapId() {
        // what the heck is happening here?? hashCodes of Strings?
        // why not strings?
        final int id = Integer.parseInt(getString(R.string.pref_mapsource,
                String.valueOf(MAP_SOURCE_DEFAULT)));
        switch (id) {
            case GOOGLEMAP_BASEID + MAP:
                return GoogleMapProvider.GOOGLE_MAP_ID.hashCode();
            case GOOGLEMAP_BASEID + SATELLITE:
                return GoogleMapProvider.GOOGLE_SATELLITE_ID.hashCode();
            case MFMAP_BASEID + MAPNIK:
                return MapsforgeMapProvider.MAPSFORGE_MAPNIK_ID.hashCode();
            case MFMAP_BASEID + CYCLEMAP:
                return MapsforgeMapProvider.MAPSFORGE_CYCLEMAP_ID.hashCode();
            case MFMAP_BASEID + OFFLINE: {
                final String mapFile = Settings.getMapFile();
                if (StringUtils.isNotEmpty(mapFile)) {
                    return mapFile.hashCode();
                }
                break;
            }
            default:
                break;
        }
        return id;
    }

    public static void setMapSource(final MapSource newMapSource) {
        putString(R.string.pref_mapsource, String.valueOf(newMapSource.getNumericalId()));
        if (newMapSource instanceof OfflineMapSource) {
            setMapFile(((OfflineMapSource) newMapSource).getFileName());
        }
        // cache the value
        mapSource = newMapSource;
    }

    public static void setAnyCoordinates(final Geopoint coords) {
        if (null != coords) {
            putFloat(R.string.pref_anylatitude, (float) coords.getLatitude());
            putFloat(R.string.pref_anylongitude, (float) coords.getLongitude());
        } else {
            remove(R.string.pref_anylatitude);
            remove(R.string.pref_anylongitude);
        }
    }

    public static Geopoint getAnyCoordinates() {
        if (contains(R.string.pref_anylatitude) && contains(R.string.pref_anylongitude)) {
            float lat = getFloat(R.string.pref_anylatitude, 0);
            float lon = getFloat(R.string.pref_anylongitude, 0);
            return new Geopoint(lat, lon);
        }
        return null;
    }

    public static boolean isUseCompass() {
        return getBoolean(R.string.pref_usecompass, true);
    }

    public static void setUseCompass(final boolean useCompass) {
        putBoolean(R.string.pref_usecompass, useCompass);
    }

    public static boolean isLightSkin() {
        return getBoolean(R.string.pref_skin, false);
    }

    public static String getKeyConsumerPublic() {
        return keyConsumerPublic;
    }

    public static String getKeyConsumerSecret() {
        return keyConsumerSecret;
    }

    public static String getWebDeviceCode() {
        return getString(R.string.pref_webDeviceCode, null);
    }

    public static String getWebDeviceName() {
        return getString(R.string.pref_webDeviceName, android.os.Build.MODEL);
    }

    /**
     * @return The cache type used for filtering or ALL if no filter is active.
     *         Returns never null
     */
    public static CacheType getCacheType() {
        return CacheType.getById(getString(R.string.pref_cachetype, CacheType.ALL.id));
    }

    /**
     * The Threshold for the showing of child waypoints
     */
    public static int getWayPointsThreshold() {
        return getInt(R.string.pref_showwaypointsthreshold, SHOW_WP_THRESHOLD_DEFAULT);
    }

    public static void setShowWaypointsThreshold(final int threshold) {
        putInt(R.string.pref_showwaypointsthreshold, threshold);
    }

    public static boolean isUseTwitter() {
        return getBoolean(R.string.pref_twitter, false);
    }

    public static void setUseTwitter(final boolean useTwitter) {
        putBoolean(R.string.pref_twitter, useTwitter);
    }

    public static boolean isTwitterLoginValid() {
        return !StringUtils.isBlank(getTokenPublic())
                && !StringUtils.isBlank(getTokenSecret());
    }

    public static String getTokenPublic() {
        return getString(R.string.pref_twitter_token_public, null);
    }

    public static String getTokenSecret() {
        return getString(R.string.pref_twitter_token_secret, null);

    }

    public static boolean hasTwitterAuthorization() {
        return StringUtils.isNotBlank(getTokenPublic())
                && StringUtils.isNotBlank(getTokenSecret());
    }

    public static void setTwitterTokens(final String tokenPublic,
            final String tokenSecret, boolean enableTwitter) {
        putString(R.string.pref_twitter_token_public, tokenPublic);
        putString(R.string.pref_twitter_token_secret, tokenSecret);
        if (tokenPublic != null) {
            remove(R.string.pref_temp_twitter_token_public);
            remove(R.string.pref_temp_twitter_token_secret);
        }
        setUseTwitter(enableTwitter);
    }

    public static void setTwitterTempTokens(final String tokenPublic,
            final String tokenSecret) {
        putString(R.string.pref_temp_twitter_token_public, tokenPublic);
        putString(R.string.pref_temp_twitter_token_secret, tokenSecret);
    }

    public static ImmutablePair<String, String> getTempToken() {
        String tokenPublic = getString(R.string.pref_temp_twitter_token_public, null);
        String tokenSecret = getString(R.string.pref_temp_twitter_token_secret, null);
        return new ImmutablePair<String, String>(tokenPublic, tokenSecret);
    }

    public static int getVersion() {
        return getInt(R.string.pref_version, 0);
    }

    public static void setVersion(final int version) {
        putInt(R.string.pref_version, version);
    }

    public static boolean isOpenLastDetailsPage() {
        return getBoolean(R.string.pref_opendetailslastpage, false);
    }

    public static int getLastDetailsPage() {
        return getInt(R.string.pref_lastdetailspage, 1);
    }

    public static void setLastDetailsPage(final int index) {
        putInt(R.string.pref_lastdetailspage, index);
    }

    public static int getDefaultNavigationTool() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool,
                String.valueOf(NavigationAppsEnum.COMPASS.id)));
    }

    public static void setDefaultNavigationTool(final int defaultNavigationTool) {
        putString(R.string.pref_defaultNavigationTool,
                String.valueOf(defaultNavigationTool));
    }

    public static int getDefaultNavigationTool2() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool2,
                String.valueOf(NavigationAppsEnum.INTERNAL_MAP.id)));
    }

    public static void setDefaultNavigationTool2(final int defaultNavigationTool) {
        putString(R.string.pref_defaultNavigationTool2,
                String.valueOf(defaultNavigationTool));
    }

    public static Strategy getLiveMapStrategy() {
        return Strategy.getById(getInt(R.string.pref_livemapstrategy, Strategy.AUTO.id));
    }

    public static void setLiveMapStrategy(final Strategy strategy) {
        putInt(R.string.pref_livemapstrategy, strategy.id);
    }

    public static boolean isDebug() {
        return Log.isDebug();
    }

    public static boolean getHideLiveMapHint() {
        return getBoolean(R.string.pref_hidelivemaphint, false);
    }

    public static void setHideLiveHint(final boolean hide) {
        putBoolean(R.string.pref_hidelivemaphint, hide);
    }

    public static int getLiveMapHintShowCount() {
        return getInt(R.string.pref_livemaphintshowcount, 0);
    }

    public static void setLiveMapHintShowCount(final int showCount) {
        putInt(R.string.pref_livemaphintshowcount, showCount);
    }

    public static boolean isDbOnSDCard() {
        return getBoolean(R.string.pref_dbonsdcard, false);
    }

    public static void setDbOnSDCard(final boolean dbOnSDCard) {
        putBoolean(R.string.pref_dbonsdcard, dbOnSDCard);
    }

    public static String getGpxExportDir() {
        return getString(R.string.pref_gpxExportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static String getGpxImportDir() {
        return getString(R.string.pref_gpxImportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static boolean getShareAfterExport() {
        return getBoolean(R.string.pref_shareafterexport, true);
    }

    public static void setShareAfterExport(final boolean shareAfterExport) {
        putBoolean(R.string.pref_shareafterexport, shareAfterExport);
    }

    public static int getTrackableAction() {
        return getInt(R.string.pref_trackableaction, LogType.RETRIEVED_IT.id);
    }

    public static void setTrackableAction(final int trackableAction) {
        putInt(R.string.pref_trackableaction, trackableAction);
    }

    public static String getCustomRenderThemeBaseFolder() {
        return getString(R.string.pref_renderthemepath, "");
    }

    public static String getCustomRenderThemeFilePath() {
        return getString(R.string.pref_renderthemefile, "");
    }

    public static void setCustomRenderThemeFile(final String customRenderThemeFile) {
        putString(R.string.pref_renderthemefile, customRenderThemeFile);
    }

    public static File[] getMapThemeFiles() {
        File directory = new File(Settings.getCustomRenderThemeBaseFolder());
        List<File> result = new ArrayList<File>();
        FileUtils.listDir(result, directory, new ExtensionsBasedFileSelector(new String[] { "xml" }), null);

        return result.toArray(new File[result.size()]);
    }

    private static class ExtensionsBasedFileSelector extends FileSelector {
        private final String[] extensions;
        public ExtensionsBasedFileSelector(String[] extensions) {
            this.extensions = extensions;
        }
        @Override
        public boolean isSelected(File file) {
            String filename = file.getName();
            for (String ext : extensions) {
                if (StringUtils.endsWithIgnoreCase(filename, ext)) {
                    return true;
                }
            }
            return false;
        }
        @Override
        public boolean shouldEnd() {
            return false;
        }
    }

    public static boolean getPlainLogs() {
        return getBoolean(R.string.pref_plainLogs, false);
    }

    public static boolean getUseNativeUa() {
        return getBoolean(R.string.pref_nativeUa, false);
    }

    public static String getCacheTwitterMessage() {
        // TODO make customizable from UI
        return "I found [NAME] ([URL])";
    }

    public static String getTrackableTwitterMessage() {
        // TODO make customizable from UI
        return "I touched [NAME] ([URL])!";
    }

    public static int getLogImageScale() {
        return getInt(R.string.pref_logImageScale, -1);
    }

    public static void setLogImageScale(final int scale) {
        putInt(R.string.pref_logImageScale, scale);
    }

    // Only for tests!
    static void setExcludeDisabledCaches(final boolean exclude) {
        putBoolean(R.string.pref_excludedisabled, exclude);
    }

    public static void setExcludeMine(final boolean exclude) {
        putBoolean(R.string.pref_excludemine, exclude);
    }

    static boolean setLogin(final String username, final String password) {

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            // erase username and password
            boolean a = remove(R.string.pref_username);
            boolean b = remove(R.string.pref_password);
            return a && b;
        }
        // save username and password
        boolean a = putString(R.string.pref_username, username);
        boolean b = putString(R.string.pref_password, password);
        return a && b;
    }

    static void setStoreOfflineMaps(final boolean offlineMaps) {
        putBoolean(R.string.pref_offlinemaps, offlineMaps);
    }

    static void setStoreOfflineWpMaps(final boolean offlineWpMaps) {
        putBoolean(R.string.pref_offlinewpmaps, offlineWpMaps);
    }

    static void setUseImperialUnits(final boolean imperial) {
        putBoolean(R.string.pref_units, imperial);
    }

    public static long getFieldnoteExportDate() {
        return getLong(R.string.pref_fieldnoteExportDate, 0);
    }

    public static void setFieldnoteExportDate(final long date) {
        putLong(R.string.pref_fieldnoteExportDate, date);
    }

    public static boolean isUseNavigationApp(NavigationAppsEnum navApp) {
        return getBoolean(navApp.preferenceKey, true);
    }

}
!@#$%
20190527_002730,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_a03092
package cgeo.geocaching.settings;

import cgeo.geocaching.R;
import cgeo.geocaching.StoredList;
import cgeo.geocaching.cgeoapplication;
import cgeo.geocaching.apps.cache.navi.NavigationAppFactory.NavigationAppsEnum;
import cgeo.geocaching.connector.gc.GCConstants;
import cgeo.geocaching.connector.gc.Login;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.LiveMapStrategy.Strategy;
import cgeo.geocaching.enumerations.LogType;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.maps.MapProviderFactory;
import cgeo.geocaching.maps.google.GoogleMapProvider;
import cgeo.geocaching.maps.interfaces.GeoPointImpl;
import cgeo.geocaching.maps.interfaces.MapProvider;
import cgeo.geocaching.maps.interfaces.MapSource;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider.OfflineMapSource;
import cgeo.geocaching.utils.CryptUtils;
import cgeo.geocaching.utils.FileUtils;
import cgeo.geocaching.utils.FileUtils.FileSelector;
import cgeo.geocaching.utils.Log;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.os.Environment;
import android.preference.PreferenceManager;

import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

/**
 * General c:geo preferences/settings set by the user
 */
public final class Settings {

    public static final int SHOW_WP_THRESHOLD_DEFAULT = 10;
    public static final int SHOW_WP_THRESHOLD_MAX = 50;
    private static final int MAP_SOURCE_DEFAULT = GoogleMapProvider.GOOGLE_MAP_ID.hashCode();

    private final static int unitsMetric = 1;

    // twitter api keys
    private final static String keyConsumerPublic = CryptUtils.rot13("ESnsCvAv3kEupF1GCR3jGj");
    private final static String keyConsumerSecret = CryptUtils.rot13("7vQWceACV9umEjJucmlpFe9FCMZSeqIqfkQ2BnhV9x");

    public enum CoordInputFormatEnum {
        Plain,
        Deg,
        Min,
        Sec;

        public static CoordInputFormatEnum fromInt(int id) {
            final CoordInputFormatEnum[] values = CoordInputFormatEnum.values();
            if (id < 0 || id >= values.length) {
                return Min;
            }
            return values[id];
        }
    }

    private static final SharedPreferences sharedPrefs = PreferenceManager
            .getDefaultSharedPreferences(cgeoapplication.getInstance().getBaseContext());
    static {
        migrateSettings();
        Log.setDebug(sharedPrefs.getBoolean(getKey(R.string.pref_debug), false));
    }

    /**
     * Cache the mapsource locally. If that is an offline map source, each request would potentially access the
     * underlying map file, leading to delays.
     */
    private static MapSource mapSource;

    private Settings() {
        // this class is not to be instantiated;
    }

    private static void migrateSettings() {
        // migrate from non standard file location and integer based boolean types
        int oldVersion = getInt(R.string.pref_settingsversion, 0);
        if (oldVersion < 1) {
            final String oldPreferencesName = "cgeo.pref";
            final SharedPreferences old = cgeoapplication.getInstance().getSharedPreferences(oldPreferencesName, Context.MODE_PRIVATE);
            final Editor e = sharedPrefs.edit();

            e.putString(getKey(R.string.pref_temp_twitter_token_secret), old.getString(getKey(R.string.pref_temp_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_temp_twitter_token_public), old.getString(getKey(R.string.pref_temp_twitter_token_public), null));
            e.putBoolean(getKey(R.string.pref_help_shown), old.getInt(getKey(R.string.pref_help_shown), 0) != 0);
            e.putFloat(getKey(R.string.pref_anylongitude), old.getFloat(getKey(R.string.pref_anylongitude), 0));
            e.putFloat(getKey(R.string.pref_anylatitude), old.getFloat(getKey(R.string.pref_anylatitude), 0));
            e.putBoolean(getKey(R.string.pref_offlinemaps), 0 != old.getInt(getKey(R.string.pref_offlinemaps), 1));
            e.putBoolean(getKey(R.string.pref_offlinewpmaps), 0 != old.getInt(getKey(R.string.pref_offlinewpmaps), 0));
            e.putString(getKey(R.string.pref_webDeviceCode), old.getString(getKey(R.string.pref_webDeviceCode), null));
            e.putString(getKey(R.string.pref_webDeviceName), old.getString(getKey(R.string.pref_webDeviceName), null));
            e.putBoolean(getKey(R.string.pref_maplive), old.getInt(getKey(R.string.pref_maplive), 1) != 0);
            e.putInt(getKey(R.string.pref_mapsource), old.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT));
            e.putBoolean(getKey(R.string.pref_twitter), 0 != old.getInt(getKey(R.string.pref_twitter), 0));
            e.putBoolean(getKey(R.string.pref_showaddress), 0 != old.getInt(getKey(R.string.pref_showaddress), 1));
            e.putBoolean(getKey(R.string.pref_showcaptcha), old.getBoolean(getKey(R.string.pref_showcaptcha), false));
            e.putBoolean(getKey(R.string.pref_maptrail), old.getInt(getKey(R.string.pref_maptrail), 1) != 0);
            e.putInt(getKey(R.string.pref_lastmapzoom), old.getInt(getKey(R.string.pref_lastmapzoom), 14));
            e.putBoolean(getKey(R.string.pref_livelist), 0 != old.getInt(getKey(R.string.pref_livelist), 1));
            e.putBoolean(getKey(R.string.pref_units), old.getInt(getKey(R.string.pref_units), unitsMetric) == unitsMetric);
            e.putBoolean(getKey(R.string.pref_skin), old.getInt(getKey(R.string.pref_skin), 0) != 0);
            e.putInt(getKey(R.string.pref_lastusedlist), old.getInt(getKey(R.string.pref_lastusedlist), StoredList.STANDARD_LIST_ID));
            e.putString(getKey(R.string.pref_cachetype), old.getString(getKey(R.string.pref_cachetype), CacheType.ALL.id));
            e.putString(getKey(R.string.pref_twitter_token_secret), old.getString(getKey(R.string.pref_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_twitter_token_public), old.getString(getKey(R.string.pref_twitter_token_public), null));
            e.putInt(getKey(R.string.pref_version), old.getInt(getKey(R.string.pref_version), 0));
            e.putBoolean(getKey(R.string.pref_autoloaddesc), 0 != old.getInt(getKey(R.string.pref_autoloaddesc), 1));
            e.putBoolean(getKey(R.string.pref_ratingwanted), old.getBoolean(getKey(R.string.pref_ratingwanted), true));
            e.putBoolean(getKey(R.string.pref_friendlogswanted), old.getBoolean(getKey(R.string.pref_friendlogswanted), true));
            e.putBoolean(getKey(R.string.pref_useenglish), old.getBoolean(getKey(R.string.pref_useenglish), false));
            e.putBoolean(getKey(R.string.pref_usecompass), 0 != old.getInt(getKey(R.string.pref_usecompass), 1));
            e.putBoolean(getKey(R.string.pref_trackautovisit), old.getBoolean(getKey(R.string.pref_trackautovisit), false));
            e.putBoolean(getKey(R.string.pref_sigautoinsert), old.getBoolean(getKey(R.string.pref_sigautoinsert), false));
            e.putBoolean(getKey(R.string.pref_logimages), old.getBoolean(getKey(R.string.pref_logimages), false));
            e.putBoolean(getKey(R.string.pref_excludedisabled), 0 != old.getInt(getKey(R.string.pref_excludedisabled), 0));
            e.putBoolean(getKey(R.string.pref_excludemine), 0 != old.getInt(getKey(R.string.pref_excludemine), 0));
            e.putString(getKey(R.string.pref_mapfile), old.getString(getKey(R.string.pref_mapfile), null));
            e.putString(getKey(R.string.pref_signature), old.getString(getKey(R.string.pref_signature), null));
            e.putString(getKey(R.string.pref_pass_vote), old.getString(getKey(R.string.pref_pass_vote), null));
            e.putString(getKey(R.string.pref_password), old.getString(getKey(R.string.pref_password), null));
            e.putString(getKey(R.string.pref_username), old.getString(getKey(R.string.pref_username), null));
            e.putString(getKey(R.string.pref_memberstatus), old.getString(getKey(R.string.pref_memberstatus), ""));
            e.putInt(getKey(R.string.pref_coordinputformat), old.getInt(getKey(R.string.pref_coordinputformat), 0));
            e.putBoolean(getKey(R.string.pref_log_offline), old.getBoolean(getKey(R.string.pref_log_offline), false));
            e.putBoolean(getKey(R.string.pref_choose_list), old.getBoolean(getKey(R.string.pref_choose_list), true));
            e.putBoolean(getKey(R.string.pref_loaddirectionimg), old.getBoolean(getKey(R.string.pref_loaddirectionimg), true));
            e.putString(getKey(R.string.pref_gccustomdate), old.getString(getKey(R.string.pref_gccustomdate), null));
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), old.getInt(getKey(R.string.pref_showwaypointsthreshold), SHOW_WP_THRESHOLD_DEFAULT));
            e.putString(getKey(R.string.pref_cookiestore), old.getString(getKey(R.string.pref_cookiestore), null));
            e.putBoolean(getKey(R.string.pref_opendetailslastpage), old.getBoolean(getKey(R.string.pref_opendetailslastpage), false));
            e.putInt(getKey(R.string.pref_lastdetailspage), old.getInt(getKey(R.string.pref_lastdetailspage), 1));
            e.putInt(getKey(R.string.pref_defaultNavigationTool), old.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id));
            e.putInt(getKey(R.string.pref_defaultNavigationTool2), old.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id));
            e.putInt(getKey(R.string.pref_livemapstrategy), old.getInt(getKey(R.string.pref_livemapstrategy), Strategy.AUTO.id));
            e.putBoolean(getKey(R.string.pref_debug), old.getBoolean(getKey(R.string.pref_debug), false));
            e.putBoolean(getKey(R.string.pref_hidelivemaphint), old.getInt(getKey(R.string.pref_hidelivemaphint), 0) != 0);
            e.putInt(getKey(R.string.pref_livemaphintshowcount), old.getInt(getKey(R.string.pref_livemaphintshowcount), 0));

            e.putInt(getKey(R.string.pref_settingsversion), 1); // mark migrated
            e.commit();
        }

        // changes for new settings dialog
        if (oldVersion < 2) {
            final Editor e = sharedPrefs.edit();

            e.putBoolean(getKey(R.string.pref_units), !isUseImperialUnits());

            // show waypoints threshold now as a slider
            int wpThreshold = getWayPointsThreshold();
            if (wpThreshold < 0) {
                wpThreshold = 0;
            } else if (wpThreshold > SHOW_WP_THRESHOLD_MAX) {
                wpThreshold = SHOW_WP_THRESHOLD_MAX;
            }
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), wpThreshold);

            // KEY_MAP_SOURCE must be string, because it is the key for a ListPreference now
            int ms = sharedPrefs.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT);
            e.remove(getKey(R.string.pref_mapsource));
            e.putString(getKey(R.string.pref_mapsource), String.valueOf(ms));

            // navigation tool ids must be string, because ListPreference uses strings as keys
            int dnt1 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id);
            int dnt2 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id);
            e.remove(getKey(R.string.pref_defaultNavigationTool));
            e.remove(getKey(R.string.pref_defaultNavigationTool2));
            e.putString(getKey(R.string.pref_defaultNavigationTool), String.valueOf(dnt1));
            e.putString(getKey(R.string.pref_defaultNavigationTool2), String.valueOf(dnt2));

            // defaults for gpx directories
            e.putString(getKey(R.string.pref_gpxImportDir), getGpxImportDir());
            e.putString(getKey(R.string.pref_gpxExportDir), getGpxExportDir());

            e.putInt(getKey(R.string.pref_settingsversion), 2); // mark migrated
            e.commit();
        }
    }

    private static String getKey(final int prefKeyId) {
        return cgeoapplication.getInstance().getString(prefKeyId);
    }

    static String getString(final int prefKeyId, final String defaultValue) {
        return sharedPrefs.getString(getKey(prefKeyId), defaultValue);
    }

    private static int getInt(final int prefKeyId, final int defaultValue) {
        return sharedPrefs.getInt(getKey(prefKeyId), defaultValue);
    }

    private static long getLong(final int prefKeyId, final long defaultValue) {
        return sharedPrefs.getLong(getKey(prefKeyId), defaultValue);
    }

    private static boolean getBoolean(final int prefKeyId, final boolean defaultValue) {
        return sharedPrefs.getBoolean(getKey(prefKeyId), defaultValue);
    }

    private static float getFloat(final int prefKeyId, final float defaultValue) {
        return sharedPrefs.getFloat(getKey(prefKeyId), defaultValue);
    }

    static boolean putString(final int prefKeyId, final String value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putString(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putBoolean(final int prefKeyId, final boolean value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putBoolean(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putInt(final int prefKeyId, final int value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putInt(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putLong(final int prefKeyId, final long value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putLong(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putFloat(final int prefKeyId, final float value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putFloat(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean remove(final int prefKeyId) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.remove(getKey(prefKeyId));
        return edit.commit();
    }

    private static boolean contains(final int prefKeyId) {
        return sharedPrefs.contains(getKey(prefKeyId));
    }

    public static void setLanguage(boolean useEnglish) {
        final Configuration config = new Configuration();
        config.locale = useEnglish ? Locale.ENGLISH : Locale.getDefault();
        final Resources resources = cgeoapplication.getInstance().getResources();
        resources.updateConfiguration(config, resources.getDisplayMetrics());
    }

    public static boolean isLogin() {
        final String preUsername = getString(R.string.pref_username, null);
        final String prePassword = getString(R.string.pref_password, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    /**
     * Get login and password information.
     *
     * @return a pair either with (login, password) or (empty, empty) if no valid information is stored
     */
    public static ImmutablePair<String, String> getGcLogin() {

        final String username = getString(R.string.pref_username, null);
        final String password = getString(R.string.pref_password, null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return new ImmutablePair<String, String>(StringUtils.EMPTY, StringUtils.EMPTY);
        }

        return new ImmutablePair<String, String>(username, password);
    }

    public static String getUsername() {
        return getString(R.string.pref_username, null);
    }

    public static boolean isGCConnectorActive() {
        return getBoolean(R.string.pref_connectorGCActive, true);
    }

    public static boolean isPremiumMember() {
        // Basic Member, Premium Member, ???
        String memberStatus = Settings.getMemberStatus();
        if (memberStatus == null) {
            return false;
        }
        return GCConstants.MEMBER_STATUS_PM.equalsIgnoreCase(memberStatus);
    }

    public static String getMemberStatus() {
        return getString(R.string.pref_memberstatus, "");
    }

    public static boolean setMemberStatus(final String memberStatus) {
        if (StringUtils.isBlank(memberStatus)) {
            return remove(R.string.pref_memberstatus);
        }
        return putString(R.string.pref_memberstatus, memberStatus);
    }

    public static ImmutablePair<String, String> getTokenPair(final int tokenPublicPrefKey, final int tokenSecretPrefKey) {
        return new ImmutablePair<String, String>(getString(tokenPublicPrefKey, null), getString(tokenSecretPrefKey, null));
    }

    public static void setTokens(final int tokenPublicPrefKey, final String tokenPublic, final int tokenSecretPrefKey, final String tokenSecret) {
        if (tokenPublic == null) {
            remove(tokenPublicPrefKey);
        } else {
            putString(tokenPublicPrefKey, tokenPublic);
        }
        if (tokenSecret == null) {
            remove(tokenSecretPrefKey);
        } else {
            putString(tokenSecretPrefKey, tokenSecret);
        }
    }

    public static boolean isOCConnectorActive(int isActivePrefKeyId) {
        return getBoolean(isActivePrefKeyId, false);
    }

    public static boolean hasOCAuthorization(int tokenPublicPrefKeyId, int tokenSecretPrefKeyId) {
        return StringUtils.isNotBlank(getString(tokenPublicPrefKeyId, ""))
                && StringUtils.isNotBlank(getString(tokenSecretPrefKeyId, ""));
    }

    public static boolean isGCvoteLogin() {
        final String preUsername = getString(R.string.pref_username, null);
        final String prePassword = getString(R.string.pref_pass_vote, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    public static ImmutablePair<String, String> getGCvoteLogin() {
        final String username = getString(R.string.pref_username, null);
        final String password = getString(R.string.pref_pass_vote, null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return null;
        }

        return new ImmutablePair<String, String>(username, password);
    }

    public static String getSignature() {
        return getString(R.string.pref_signature, null);
    }

    public static boolean setCookieStore(final String cookies) {
        if (StringUtils.isBlank(cookies)) {
            // erase cookies
            return remove(R.string.pref_cookiestore);
        }
        // save cookies
        return putString(R.string.pref_cookiestore, cookies);
    }

    public static String getCookieStore() {
        return getString(R.string.pref_cookiestore, null);
    }

    /**
     * @param cacheType
     *            The cache type used for future filtering
     */
    public static void setCacheType(final CacheType cacheType) {
        if (cacheType == null) {
            remove(R.string.pref_cachetype);
        } else {
            putString(R.string.pref_cachetype, cacheType.id);
        }
    }

    public static int getLastList() {
        return getInt(R.string.pref_lastusedlist, StoredList.STANDARD_LIST_ID);
    }

    public static void saveLastList(final int listId) {
        putInt(R.string.pref_lastusedlist, listId);
    }

    public static void setWebNameCode(final String name, final String code) {
        putString(R.string.pref_webDeviceName, name);
        putString(R.string.pref_webDeviceCode, code);
    }

    public static MapProvider getMapProvider() {
        return getMapSource().getMapProvider();
    }

    public static String getMapFile() {
        return getString(R.string.pref_mapfile, null);
    }

    public static boolean setMapFile(final String mapFile) {
        boolean result = putString(R.string.pref_mapfile, mapFile);
        if (mapFile != null) {
            setMapFileDirectory(new File(mapFile).getParent());
        }
        return result;
    }

    public static String getMapFileDirectory() {
        final String mapDir = getString(R.string.pref_mapDirectory, null);
        if (mapDir != null) {
            return mapDir;
        }
        final String mapFile = getMapFile();
        if (mapFile != null) {
            return new File(mapFile).getParent();
        }
        return null;
    }

    public static boolean setMapFileDirectory(final String mapFileDirectory) {
        boolean result = putString(R.string.pref_mapDirectory, mapFileDirectory);
        MapsforgeMapProvider.getInstance().updateOfflineMaps();
        return result;
    }

    public static boolean isValidMapFile() {
        return isValidMapFile(getMapFile());
    }

    public static boolean isValidMapFile(final String mapFileIn) {
        return MapsforgeMapProvider.isValidMapFile(mapFileIn);
    }

    public static CoordInputFormatEnum getCoordInputFormat() {
        return CoordInputFormatEnum.fromInt(getInt(R.string.pref_coordinputformat, 0));
    }

    public static void setCoordInputFormat(final CoordInputFormatEnum format) {
        putInt(R.string.pref_coordinputformat, format.ordinal());
    }

    static void setLogOffline(final boolean offline) {
        putBoolean(R.string.pref_log_offline, offline);
    }

    public static boolean getLogOffline() {
        return getBoolean(R.string.pref_log_offline, false);
    }

    public static boolean getChooseList() {
        return getBoolean(R.string.pref_choose_list, false);
    }

    public static boolean getLoadDirImg() {
        return !isPremiumMember() && getBoolean(R.string.pref_loaddirectionimg, true);
    }

    public static void setGcCustomDate(final String format) {
        putString(R.string.pref_gccustomdate, format);
    }

    /**
     * @return User selected date format on GC.com
     * @see Login#gcCustomDateFormats
     */
    public static String getGcCustomDate() {
        return getString(R.string.pref_gccustomdate, null);
    }

    public static boolean isExcludeMyCaches() {
        return getBoolean(R.string.pref_excludemine, false);
    }

    public static void setUseEnglish(final boolean english) {
        putBoolean(R.string.pref_useenglish, english);
        setLanguage(english);
    }

    public static boolean isUseEnglish() {
        return getBoolean(R.string.pref_useenglish, false);
    }

    public static boolean isShowAddress() {
        return getBoolean(R.string.pref_showaddress, true);
    }

    public static boolean isShowCaptcha() {
        return !isPremiumMember() && getBoolean(R.string.pref_showcaptcha, false);
    }

    public static boolean isExcludeDisabledCaches() {
        return getBoolean(R.string.pref_excludedisabled, false);
    }

    public static boolean isStoreOfflineMaps() {
        return getBoolean(R.string.pref_offlinemaps, true);
    }

    public static boolean isStoreOfflineWpMaps() {
        return getBoolean(R.string.pref_offlinewpmaps, false);
    }

    public static boolean isStoreLogImages() {
        return getBoolean(R.string.pref_logimages, false);
    }

    public static boolean isAutoLoadDescription() {
        return getBoolean(R.string.pref_autoloaddesc, true);
    }

    public static boolean isRatingWanted() {
        return getBoolean(R.string.pref_ratingwanted, true);
    }

    public static boolean isFriendLogsWanted() {
        if (!isLogin()) {
            // don't show a friends log if the user is anonymous
            return false;
        }
        return getBoolean(R.string.pref_friendlogswanted, true);
    }

    public static boolean isLiveList() {
        return getBoolean(R.string.pref_livelist, true);
    }

    public static boolean isTrackableAutoVisit() {
        return getBoolean(R.string.pref_trackautovisit, false);
    }

    public static boolean isAutoInsertSignature() {
        return getBoolean(R.string.pref_sigautoinsert, false);
    }

    public static boolean isUseImperialUnits() {
        return getBoolean(R.string.pref_units, getImperialUnitsDefault());
    }

    static boolean getImperialUnitsDefault() {
        final String countryCode = Locale.getDefault().getCountry();
        if ("US".equals(countryCode)) {
            return true; // USA
        }
        if ("LR".equals(countryCode)) {
            return true; // Liberia
        }
        if ("MM".equals(countryCode)) {
            return true; // Burma
        }
        return false;
    }

    public static boolean isLiveMap() {
        return getBoolean(R.string.pref_maplive, true);
    }

    public static void setLiveMap(final boolean live) {
        putBoolean(R.string.pref_maplive, live);
    }

    public static boolean isMapTrail() {
        return getBoolean(R.string.pref_maptrail, true);
    }

    public static void setMapTrail(final boolean showTrail) {
        putBoolean(R.string.pref_maptrail, showTrail);
    }

    public static int getMapZoom() {
        return getInt(R.string.pref_lastmapzoom, 14);
    }

    public static void setMapZoom(final int mapZoomLevel) {
        putInt(R.string.pref_lastmapzoom, mapZoomLevel);
    }

    public static GeoPointImpl getMapCenter() {
        return getMapProvider().getMapItemFactory()
                .getGeoPointBase(new Geopoint(getInt(R.string.pref_lastmaplat, 0) / 1e6,
                        getInt(R.string.pref_lastmaplon, 0) / 1e6));
    }

    public static void setMapCenter(final GeoPointImpl mapViewCenter) {
        putInt(R.string.pref_lastmaplat, mapViewCenter.getLatitudeE6());
        putInt(R.string.pref_lastmaplon, mapViewCenter.getLongitudeE6());
    }

    public static MapSource getMapSource() {
        if (mapSource != null) {
            return mapSource;
        }
        final int id = getConvertedMapId();
        mapSource = MapProviderFactory.getMapSource(id);
        if (mapSource != null) {
            // don't use offline maps if the map file is not valid
            if ((!(mapSource instanceof OfflineMapSource)) || (isValidMapFile())) {
                return mapSource;
            }
        }
        // fallback to first available map
        return MapProviderFactory.getDefaultSource();
    }

    private final static int GOOGLEMAP_BASEID = 30;
    private final static int MAP = 1;
    private final static int SATELLITE = 2;

    private final static int MFMAP_BASEID = 40;
    private final static int MAPNIK = 1;
    private final static int CYCLEMAP = 3;
    private final static int OFFLINE = 4;

    /**
     * convert old preference ids for maps (based on constant values) into new hash based ids
     *
     * @return
     */
    private static int getConvertedMapId() {
        // what the heck is happening here?? hashCodes of Strings?
        // why not strings?
        final int id = Integer.parseInt(getString(R.string.pref_mapsource,
                String.valueOf(MAP_SOURCE_DEFAULT)));
        switch (id) {
            case GOOGLEMAP_BASEID + MAP:
                return GoogleMapProvider.GOOGLE_MAP_ID.hashCode();
            case GOOGLEMAP_BASEID + SATELLITE:
                return GoogleMapProvider.GOOGLE_SATELLITE_ID.hashCode();
            case MFMAP_BASEID + MAPNIK:
                return MapsforgeMapProvider.MAPSFORGE_MAPNIK_ID.hashCode();
            case MFMAP_BASEID + CYCLEMAP:
                return MapsforgeMapProvider.MAPSFORGE_CYCLEMAP_ID.hashCode();
            case MFMAP_BASEID + OFFLINE: {
                final String mapFile = Settings.getMapFile();
                if (StringUtils.isNotEmpty(mapFile)) {
                    return mapFile.hashCode();
                }
                break;
            }
            default:
                break;
        }
        return id;
    }

    public static void setMapSource(final MapSource newMapSource) {
        putString(R.string.pref_mapsource, String.valueOf(newMapSource.getNumericalId()));
        if (newMapSource instanceof OfflineMapSource) {
            setMapFile(((OfflineMapSource) newMapSource).getFileName());
        }
        // cache the value
        mapSource = newMapSource;
    }

    public static void setAnyCoordinates(final Geopoint coords) {
        if (null != coords) {
            putFloat(R.string.pref_anylatitude, (float) coords.getLatitude());
            putFloat(R.string.pref_anylongitude, (float) coords.getLongitude());
        } else {
            remove(R.string.pref_anylatitude);
            remove(R.string.pref_anylongitude);
        }
    }

    public static Geopoint getAnyCoordinates() {
        if (contains(R.string.pref_anylatitude) && contains(R.string.pref_anylongitude)) {
            float lat = getFloat(R.string.pref_anylatitude, 0);
            float lon = getFloat(R.string.pref_anylongitude, 0);
            return new Geopoint(lat, lon);
        }
        return null;
    }

    public static boolean isUseCompass() {
        return getBoolean(R.string.pref_usecompass, true);
    }

    public static void setUseCompass(final boolean useCompass) {
        putBoolean(R.string.pref_usecompass, useCompass);
    }

    public static boolean isLightSkin() {
        return getBoolean(R.string.pref_skin, false);
    }

    public static String getKeyConsumerPublic() {
        return keyConsumerPublic;
    }

    public static String getKeyConsumerSecret() {
        return keyConsumerSecret;
    }

    public static String getWebDeviceCode() {
        return getString(R.string.pref_webDeviceCode, null);
    }

    public static String getWebDeviceName() {
        return getString(R.string.pref_webDeviceName, android.os.Build.MODEL);
    }

    /**
     * @return The cache type used for filtering or ALL if no filter is active.
     *         Returns never null
     */
    public static CacheType getCacheType() {
        return CacheType.getById(getString(R.string.pref_cachetype, CacheType.ALL.id));
    }

    /**
     * The Threshold for the showing of child waypoints
     */
    public static int getWayPointsThreshold() {
        return getInt(R.string.pref_showwaypointsthreshold, SHOW_WP_THRESHOLD_DEFAULT);
    }

    public static void setShowWaypointsThreshold(final int threshold) {
        putInt(R.string.pref_showwaypointsthreshold, threshold);
    }

    public static boolean isUseTwitter() {
        return getBoolean(R.string.pref_twitter, false);
    }

    public static void setUseTwitter(final boolean useTwitter) {
        putBoolean(R.string.pref_twitter, useTwitter);
    }

    public static boolean isTwitterLoginValid() {
        return !StringUtils.isBlank(getTokenPublic())
                && !StringUtils.isBlank(getTokenSecret());
    }

    public static String getTokenPublic() {
        return getString(R.string.pref_twitter_token_public, null);
    }

    public static String getTokenSecret() {
        return getString(R.string.pref_twitter_token_secret, null);

    }

    public static boolean hasTwitterAuthorization() {
        return StringUtils.isNotBlank(getTokenPublic())
                && StringUtils.isNotBlank(getTokenSecret());
    }

    public static void setTwitterTokens(final String tokenPublic,
            final String tokenSecret, boolean enableTwitter) {
        putString(R.string.pref_twitter_token_public, tokenPublic);
        putString(R.string.pref_twitter_token_secret, tokenSecret);
        if (tokenPublic != null) {
            remove(R.string.pref_temp_twitter_token_public);
            remove(R.string.pref_temp_twitter_token_secret);
        }
        setUseTwitter(enableTwitter);
    }

    public static void setTwitterTempTokens(final String tokenPublic,
            final String tokenSecret) {
        putString(R.string.pref_temp_twitter_token_public, tokenPublic);
        putString(R.string.pref_temp_twitter_token_secret, tokenSecret);
    }

    public static ImmutablePair<String, String> getTempToken() {
        String tokenPublic = getString(R.string.pref_temp_twitter_token_public, null);
        String tokenSecret = getString(R.string.pref_temp_twitter_token_secret, null);
        return new ImmutablePair<String, String>(tokenPublic, tokenSecret);
    }

    public static int getVersion() {
        return getInt(R.string.pref_version, 0);
    }

    public static void setVersion(final int version) {
        putInt(R.string.pref_version, version);
    }

    public static boolean isOpenLastDetailsPage() {
        return getBoolean(R.string.pref_opendetailslastpage, false);
    }

    public static int getLastDetailsPage() {
        return getInt(R.string.pref_lastdetailspage, 1);
    }

    public static void setLastDetailsPage(final int index) {
        putInt(R.string.pref_lastdetailspage, index);
    }

    public static int getDefaultNavigationTool() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool,
                String.valueOf(NavigationAppsEnum.COMPASS.id)));
    }

    public static void setDefaultNavigationTool(final int defaultNavigationTool) {
        putString(R.string.pref_defaultNavigationTool,
                String.valueOf(defaultNavigationTool));
    }

    public static int getDefaultNavigationTool2() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool2,
                String.valueOf(NavigationAppsEnum.INTERNAL_MAP.id)));
    }

    public static void setDefaultNavigationTool2(final int defaultNavigationTool) {
        putString(R.string.pref_defaultNavigationTool2,
                String.valueOf(defaultNavigationTool));
    }

    public static Strategy getLiveMapStrategy() {
        return Strategy.getById(getInt(R.string.pref_livemapstrategy, Strategy.AUTO.id));
    }

    public static void setLiveMapStrategy(final Strategy strategy) {
        putInt(R.string.pref_livemapstrategy, strategy.id);
    }

    public static boolean isDebug() {
        return Log.isDebug();
    }

    public static boolean getHideLiveMapHint() {
        return getBoolean(R.string.pref_hidelivemaphint, false);
    }

    public static void setHideLiveHint(final boolean hide) {
        putBoolean(R.string.pref_hidelivemaphint, hide);
    }

    public static int getLiveMapHintShowCount() {
        return getInt(R.string.pref_livemaphintshowcount, 0);
    }

    public static void setLiveMapHintShowCount(final int showCount) {
        putInt(R.string.pref_livemaphintshowcount, showCount);
    }

    public static boolean isDbOnSDCard() {
        return getBoolean(R.string.pref_dbonsdcard, false);
    }

    public static void setDbOnSDCard(final boolean dbOnSDCard) {
        putBoolean(R.string.pref_dbonsdcard, dbOnSDCard);
    }

    public static String getGpxExportDir() {
        return getString(R.string.pref_gpxExportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static String getGpxImportDir() {
        return getString(R.string.pref_gpxImportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static boolean getShareAfterExport() {
        return getBoolean(R.string.pref_shareafterexport, true);
    }

    public static void setShareAfterExport(final boolean shareAfterExport) {
        putBoolean(R.string.pref_shareafterexport, shareAfterExport);
    }

    public static int getTrackableAction() {
        return getInt(R.string.pref_trackableaction, LogType.RETRIEVED_IT.id);
    }

    public static void setTrackableAction(final int trackableAction) {
        putInt(R.string.pref_trackableaction, trackableAction);
    }

    public static String getCustomRenderThemeBaseFolder() {
        return getString(R.string.pref_renderthemepath, "");
    }

    public static String getCustomRenderThemeFilePath() {
        return getString(R.string.pref_renderthemefile, "");
    }

    public static void setCustomRenderThemeFile(final String customRenderThemeFile) {
        putString(R.string.pref_renderthemefile, customRenderThemeFile);
    }

    public static File[] getMapThemeFiles() {
        File directory = new File(Settings.getCustomRenderThemeBaseFolder());
        List<File> result = new ArrayList<File>();
        FileUtils.listDir(result, directory, new ExtensionsBasedFileSelector(new String[] { "xml" }), null);

        return result.toArray(new File[result.size()]);
    }

    private static class ExtensionsBasedFileSelector extends FileSelector {
        private final String[] extensions;
        public ExtensionsBasedFileSelector(String[] extensions) {
            this.extensions = extensions;
        }
        @Override
        public boolean isSelected(File file) {
            String filename = file.getName();
            for (String ext : extensions) {
                if (StringUtils.endsWithIgnoreCase(filename, ext)) {
                    return true;
                }
            }
            return false;
        }
        @Override
        public boolean shouldEnd() {
            return false;
        }
    }

    public static boolean getPlainLogs() {
        return getBoolean(R.string.pref_plainLogs, false);
    }

    public static boolean getUseNativeUa() {
        return getBoolean(R.string.pref_nativeUa, false);
    }

    public static String getCacheTwitterMessage() {
        // TODO make customizable from UI
        return "I found [NAME] ([URL])";
    }

    public static String getTrackableTwitterMessage() {
        // TODO make customizable from UI
        return "I touched [NAME] ([URL])!";
    }

    public static int getLogImageScale() {
        return getInt(R.string.pref_logImageScale, -1);
    }

    public static void setLogImageScale(final int scale) {
        putInt(R.string.pref_logImageScale, scale);
    }

    // Only for tests!
    static void setExcludeDisabledCaches(final boolean exclude) {
        putBoolean(R.string.pref_excludedisabled, exclude);
    }

    public static void setExcludeMine(final boolean exclude) {
        putBoolean(R.string.pref_excludemine, exclude);
    }

    static boolean setLogin(final String username, final String password) {

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            // erase username and password
            boolean a = remove(R.string.pref_username);
            boolean b = remove(R.string.pref_password);
            return a && b;
        }
        // save username and password
        boolean a = putString(R.string.pref_username, username);
        boolean b = putString(R.string.pref_password, password);
        return a && b;
    }

    static void setStoreOfflineMaps(final boolean offlineMaps) {
        putBoolean(R.string.pref_offlinemaps, offlineMaps);
    }

    static void setStoreOfflineWpMaps(final boolean offlineWpMaps) {
        putBoolean(R.string.pref_offlinewpmaps, offlineWpMaps);
    }

    static void setUseImperialUnits(final boolean imperial) {
        putBoolean(R.string.pref_units, imperial);
    }

    public static long getFieldnoteExportDate() {
        return getLong(R.string.pref_fieldnoteExportDate, 0);
    }

    public static void setFieldnoteExportDate(final long date) {
        putLong(R.string.pref_fieldnoteExportDate, date);
    }

    public static boolean isUseNavigationApp(NavigationAppsEnum navApp) {
        return getBoolean(navApp.preferenceKey, true);
    }

}
!@#$%
20190527_002730,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_c03092
package cgeo.geocaching.settings;

import cgeo.geocaching.R;
import cgeo.geocaching.StoredList;
import cgeo.geocaching.cgeoapplication;
import cgeo.geocaching.apps.cache.navi.NavigationAppFactory.NavigationAppsEnum;
import cgeo.geocaching.connector.gc.GCConstants;
import cgeo.geocaching.connector.gc.Login;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.LiveMapStrategy.Strategy;
import cgeo.geocaching.enumerations.LogType;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.maps.MapProviderFactory;
import cgeo.geocaching.maps.google.GoogleMapProvider;
import cgeo.geocaching.maps.interfaces.GeoPointImpl;
import cgeo.geocaching.maps.interfaces.MapProvider;
import cgeo.geocaching.maps.interfaces.MapSource;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider.OfflineMapSource;
import cgeo.geocaching.utils.CryptUtils;
import cgeo.geocaching.utils.FileUtils;
import cgeo.geocaching.utils.FileUtils.FileSelector;
import cgeo.geocaching.utils.Log;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.os.Environment;
import android.preference.PreferenceManager;

import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

/**
 * General c:geo preferences/settings set by the user
 */
public final class Settings {

    public static final int SHOW_WP_THRESHOLD_DEFAULT = 10;
    public static final int SHOW_WP_THRESHOLD_MAX = 50;
    private static final int MAP_SOURCE_DEFAULT = GoogleMapProvider.GOOGLE_MAP_ID.hashCode();

    private final static int unitsMetric = 1;

    // twitter api keys
    private final static String keyConsumerPublic = CryptUtils.rot13("ESnsCvAv3kEupF1GCR3jGj");
    private final static String keyConsumerSecret = CryptUtils.rot13("7vQWceACV9umEjJucmlpFe9FCMZSeqIqfkQ2BnhV9x");

    public enum CoordInputFormatEnum {
        Plain,
        Deg,
        Min,
        Sec;

        public static CoordInputFormatEnum fromInt(int id) {
            final CoordInputFormatEnum[] values = CoordInputFormatEnum.values();
            if (id < 0 || id >= values.length) {
                return Min;
            }
            return values[id];
        }
    }

    private static final SharedPreferences sharedPrefs = PreferenceManager
            .getDefaultSharedPreferences(cgeoapplication.getInstance().getBaseContext());
    static {
        migrateSettings();
        Log.setDebug(sharedPrefs.getBoolean(getKey(R.string.pref_debug), false));
    }

    /**
     * Cache the mapsource locally. If that is an offline map source, each request would potentially access the
     * underlying map file, leading to delays.
     */
    private static MapSource mapSource;

    private Settings() {
        // this class is not to be instantiated;
    }

    private static void migrateSettings() {
        // migrate from non standard file location and integer based boolean types
        int oldVersion = getInt(R.string.pref_settingsversion, 0);
        if (oldVersion < 1) {
            final String oldPreferencesName = "cgeo.pref";
            final SharedPreferences old = cgeoapplication.getInstance().getSharedPreferences(oldPreferencesName, Context.MODE_PRIVATE);
            final Editor e = sharedPrefs.edit();

            e.putString(getKey(R.string.pref_temp_twitter_token_secret), old.getString(getKey(R.string.pref_temp_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_temp_twitter_token_public), old.getString(getKey(R.string.pref_temp_twitter_token_public), null));
            e.putBoolean(getKey(R.string.pref_help_shown), old.getInt(getKey(R.string.pref_help_shown), 0) != 0);
            e.putFloat(getKey(R.string.pref_anylongitude), old.getFloat(getKey(R.string.pref_anylongitude), 0));
            e.putFloat(getKey(R.string.pref_anylatitude), old.getFloat(getKey(R.string.pref_anylatitude), 0));
            e.putBoolean(getKey(R.string.pref_offlinemaps), 0 != old.getInt(getKey(R.string.pref_offlinemaps), 1));
            e.putBoolean(getKey(R.string.pref_offlinewpmaps), 0 != old.getInt(getKey(R.string.pref_offlinewpmaps), 0));
            e.putString(getKey(R.string.pref_webDeviceCode), old.getString(getKey(R.string.pref_webDeviceCode), null));
            e.putString(getKey(R.string.pref_webDeviceName), old.getString(getKey(R.string.pref_webDeviceName), null));
            e.putBoolean(getKey(R.string.pref_maplive), old.getInt(getKey(R.string.pref_maplive), 1) != 0);
            e.putInt(getKey(R.string.pref_mapsource), old.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT));
            e.putBoolean(getKey(R.string.pref_twitter), 0 != old.getInt(getKey(R.string.pref_twitter), 0));
            e.putBoolean(getKey(R.string.pref_showaddress), 0 != old.getInt(getKey(R.string.pref_showaddress), 1));
            e.putBoolean(getKey(R.string.pref_showcaptcha), old.getBoolean(getKey(R.string.pref_showcaptcha), false));
            e.putBoolean(getKey(R.string.pref_maptrail), old.getInt(getKey(R.string.pref_maptrail), 1) != 0);
            e.putInt(getKey(R.string.pref_lastmapzoom), old.getInt(getKey(R.string.pref_lastmapzoom), 14));
            e.putBoolean(getKey(R.string.pref_livelist), 0 != old.getInt(getKey(R.string.pref_livelist), 1));
            e.putBoolean(getKey(R.string.pref_units), old.getInt(getKey(R.string.pref_units), unitsMetric) == unitsMetric);
            e.putBoolean(getKey(R.string.pref_skin), old.getInt(getKey(R.string.pref_skin), 0) != 0);
            e.putInt(getKey(R.string.pref_lastusedlist), old.getInt(getKey(R.string.pref_lastusedlist), StoredList.STANDARD_LIST_ID));
            e.putString(getKey(R.string.pref_cachetype), old.getString(getKey(R.string.pref_cachetype), CacheType.ALL.id));
            e.putString(getKey(R.string.pref_twitter_token_secret), old.getString(getKey(R.string.pref_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_twitter_token_public), old.getString(getKey(R.string.pref_twitter_token_public), null));
            e.putInt(getKey(R.string.pref_version), old.getInt(getKey(R.string.pref_version), 0));
            e.putBoolean(getKey(R.string.pref_autoloaddesc), 0 != old.getInt(getKey(R.string.pref_autoloaddesc), 1));
            e.putBoolean(getKey(R.string.pref_ratingwanted), old.getBoolean(getKey(R.string.pref_ratingwanted), true));
            e.putBoolean(getKey(R.string.pref_friendlogswanted), old.getBoolean(getKey(R.string.pref_friendlogswanted), true));
            e.putBoolean(getKey(R.string.pref_useenglish), old.getBoolean(getKey(R.string.pref_useenglish), false));
            e.putBoolean(getKey(R.string.pref_usecompass), 0 != old.getInt(getKey(R.string.pref_usecompass), 1));
            e.putBoolean(getKey(R.string.pref_trackautovisit), old.getBoolean(getKey(R.string.pref_trackautovisit), false));
            e.putBoolean(getKey(R.string.pref_sigautoinsert), old.getBoolean(getKey(R.string.pref_sigautoinsert), false));
            e.putBoolean(getKey(R.string.pref_logimages), old.getBoolean(getKey(R.string.pref_logimages), false));
            e.putBoolean(getKey(R.string.pref_excludedisabled), 0 != old.getInt(getKey(R.string.pref_excludedisabled), 0));
            e.putBoolean(getKey(R.string.pref_excludemine), 0 != old.getInt(getKey(R.string.pref_excludemine), 0));
            e.putString(getKey(R.string.pref_mapfile), old.getString(getKey(R.string.pref_mapfile), null));
            e.putString(getKey(R.string.pref_signature), old.getString(getKey(R.string.pref_signature), null));
            e.putString(getKey(R.string.pref_pass_vote), old.getString(getKey(R.string.pref_pass_vote), null));
            e.putString(getKey(R.string.pref_password), old.getString(getKey(R.string.pref_password), null));
            e.putString(getKey(R.string.pref_username), old.getString(getKey(R.string.pref_username), null));
            e.putString(getKey(R.string.pref_memberstatus), old.getString(getKey(R.string.pref_memberstatus), ""));
            e.putInt(getKey(R.string.pref_coordinputformat), old.getInt(getKey(R.string.pref_coordinputformat), 0));
            e.putBoolean(getKey(R.string.pref_log_offline), old.getBoolean(getKey(R.string.pref_log_offline), false));
            e.putBoolean(getKey(R.string.pref_choose_list), old.getBoolean(getKey(R.string.pref_choose_list), true));
            e.putBoolean(getKey(R.string.pref_loaddirectionimg), old.getBoolean(getKey(R.string.pref_loaddirectionimg), true));
            e.putString(getKey(R.string.pref_gccustomdate), old.getString(getKey(R.string.pref_gccustomdate), null));
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), old.getInt(getKey(R.string.pref_showwaypointsthreshold), SHOW_WP_THRESHOLD_DEFAULT));
            e.putString(getKey(R.string.pref_cookiestore), old.getString(getKey(R.string.pref_cookiestore), null));
            e.putBoolean(getKey(R.string.pref_opendetailslastpage), old.getBoolean(getKey(R.string.pref_opendetailslastpage), false));
            e.putInt(getKey(R.string.pref_lastdetailspage), old.getInt(getKey(R.string.pref_lastdetailspage), 1));
            e.putInt(getKey(R.string.pref_defaultNavigationTool), old.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id));
            e.putInt(getKey(R.string.pref_defaultNavigationTool2), old.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id));
            e.putInt(getKey(R.string.pref_livemapstrategy), old.getInt(getKey(R.string.pref_livemapstrategy), Strategy.AUTO.id));
            e.putBoolean(getKey(R.string.pref_debug), old.getBoolean(getKey(R.string.pref_debug), false));
            e.putBoolean(getKey(R.string.pref_hidelivemaphint), old.getInt(getKey(R.string.pref_hidelivemaphint), 0) != 0);
            e.putInt(getKey(R.string.pref_livemaphintshowcount), old.getInt(getKey(R.string.pref_livemaphintshowcount), 0));

            e.putInt(getKey(R.string.pref_settingsversion), 1); // mark migrated
            e.commit();
        }

        // changes for new settings dialog
        if (oldVersion < 2) {
            final Editor e = sharedPrefs.edit();

            e.putBoolean(getKey(R.string.pref_units), !isUseImperialUnits());

            // show waypoints threshold now as a slider
            int wpThreshold = getWayPointsThreshold();
            if (wpThreshold < 0) {
                wpThreshold = 0;
            } else if (wpThreshold > SHOW_WP_THRESHOLD_MAX) {
                wpThreshold = SHOW_WP_THRESHOLD_MAX;
            }
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), wpThreshold);

            // KEY_MAP_SOURCE must be string, because it is the key for a ListPreference now
            int ms = sharedPrefs.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT);
            e.remove(getKey(R.string.pref_mapsource));
            e.putString(getKey(R.string.pref_mapsource), String.valueOf(ms));

            // navigation tool ids must be string, because ListPreference uses strings as keys
            int dnt1 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id);
            int dnt2 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id);
            e.remove(getKey(R.string.pref_defaultNavigationTool));
            e.remove(getKey(R.string.pref_defaultNavigationTool2));
            e.putString(getKey(R.string.pref_defaultNavigationTool), String.valueOf(dnt1));
            e.putString(getKey(R.string.pref_defaultNavigationTool2), String.valueOf(dnt2));

            // defaults for gpx directories
            e.putString(getKey(R.string.pref_gpxImportDir), getGpxImportDir());
            e.putString(getKey(R.string.pref_gpxExportDir), getGpxExportDir());

            e.putInt(getKey(R.string.pref_settingsversion), 2); // mark migrated
            e.commit();
        }
    }

    private static String getKey(final int prefKeyId) {
        return cgeoapplication.getInstance().getString(prefKeyId);
    }

    static String getString(final int prefKeyId, final String defaultValue) {
        return sharedPrefs.getString(getKey(prefKeyId), defaultValue);
    }

    private static int getInt(final int prefKeyId, final int defaultValue) {
        return sharedPrefs.getInt(getKey(prefKeyId), defaultValue);
    }

    private static long getLong(final int prefKeyId, final long defaultValue) {
        return sharedPrefs.getLong(getKey(prefKeyId), defaultValue);
    }

    private static boolean getBoolean(final int prefKeyId, final boolean defaultValue) {
        return sharedPrefs.getBoolean(getKey(prefKeyId), defaultValue);
    }

    private static float getFloat(final int prefKeyId, final float defaultValue) {
        return sharedPrefs.getFloat(getKey(prefKeyId), defaultValue);
    }

    static boolean putString(final int prefKeyId, final String value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putString(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putBoolean(final int prefKeyId, final boolean value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putBoolean(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putInt(final int prefKeyId, final int value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putInt(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putLong(final int prefKeyId, final long value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putLong(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putFloat(final int prefKeyId, final float value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putFloat(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean remove(final int prefKeyId) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.remove(getKey(prefKeyId));
        return edit.commit();
    }

    private static boolean contains(final int prefKeyId) {
        return sharedPrefs.contains(getKey(prefKeyId));
    }

    public static void setLanguage(boolean useEnglish) {
        final Configuration config = new Configuration();
        config.locale = useEnglish ? Locale.ENGLISH : Locale.getDefault();
        final Resources resources = cgeoapplication.getInstance().getResources();
        resources.updateConfiguration(config, resources.getDisplayMetrics());
    }

    public static boolean isLogin() {
        final String preUsername = getString(R.string.pref_username, null);
        final String prePassword = getString(R.string.pref_password, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    /**
     * Get login and password information.
     *
     * @return a pair either with (login, password) or (empty, empty) if no valid information is stored
     */
    public static ImmutablePair<String, String> getGcLogin() {

        final String username = getString(R.string.pref_username, null);
        final String password = getString(R.string.pref_password, null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return new ImmutablePair<String, String>(StringUtils.EMPTY, StringUtils.EMPTY);
        }

        return new ImmutablePair<String, String>(username, password);
    }

    public static String getUsername() {
        return getString(R.string.pref_username, null);
    }

    public static boolean isGCConnectorActive() {
        return getBoolean(R.string.pref_connectorGCActive, true);
    }

    public static boolean isPremiumMember() {
        // Basic Member, Premium Member, ???
        String memberStatus = Settings.getMemberStatus();
        if (memberStatus == null) {
            return false;
        }
        return GCConstants.MEMBER_STATUS_PM.equalsIgnoreCase(memberStatus);
    }

    public static String getMemberStatus() {
        return getString(R.string.pref_memberstatus, "");
    }

    public static boolean setMemberStatus(final String memberStatus) {
        if (StringUtils.isBlank(memberStatus)) {
            return remove(R.string.pref_memberstatus);
        }
        return putString(R.string.pref_memberstatus, memberStatus);
    }

    public static ImmutablePair<String, String> getTokenPair(final int tokenPublicPrefKey, final int tokenSecretPrefKey) {
        return new ImmutablePair<String, String>(getString(tokenPublicPrefKey, null), getString(tokenSecretPrefKey, null));
    }

    public static void setTokens(final int tokenPublicPrefKey, final String tokenPublic, final int tokenSecretPrefKey, final String tokenSecret) {
        if (tokenPublic == null) {
            remove(tokenPublicPrefKey);
        } else {
            putString(tokenPublicPrefKey, tokenPublic);
        }
        if (tokenSecret == null) {
            remove(tokenSecretPrefKey);
        } else {
            putString(tokenSecretPrefKey, tokenSecret);
        }
    }

    public static boolean isOCConnectorActive(int isActivePrefKeyId) {
        return getBoolean(isActivePrefKeyId, false);
    }

    public static boolean hasOCAuthorization(int tokenPublicPrefKeyId, int tokenSecretPrefKeyId) {
        return StringUtils.isNotBlank(getString(tokenPublicPrefKeyId, ""))
                && StringUtils.isNotBlank(getString(tokenSecretPrefKeyId, ""));
    }

    public static boolean isGCvoteLogin() {
        final String preUsername = getString(R.string.pref_username, null);
        final String prePassword = getString(R.string.pref_pass_vote, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    public static ImmutablePair<String, String> getGCvoteLogin() {
        final String username = getString(R.string.pref_username, null);
        final String password = getString(R.string.pref_pass_vote, null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return null;
        }

        return new ImmutablePair<String, String>(username, password);
    }

    public static String getSignature() {
        return getString(R.string.pref_signature, null);
    }

    public static boolean setCookieStore(final String cookies) {
        if (StringUtils.isBlank(cookies)) {
            // erase cookies
            return remove(R.string.pref_cookiestore);
        }
        // save cookies
        return putString(R.string.pref_cookiestore, cookies);
    }

    public static String getCookieStore() {
        return getString(R.string.pref_cookiestore, null);
    }

    /**
     * @param cacheType
     *            The cache type used for future filtering
     */
    public static void setCacheType(final CacheType cacheType) {
        if (cacheType == null) {
            remove(R.string.pref_cachetype);
        } else {
            putString(R.string.pref_cachetype, cacheType.id);
        }
    }

    public static int getLastList() {
        return getInt(R.string.pref_lastusedlist, StoredList.STANDARD_LIST_ID);
    }

    public static void saveLastList(final int listId) {
        putInt(R.string.pref_lastusedlist, listId);
    }

    public static void setWebNameCode(final String name, final String code) {
        putString(R.string.pref_webDeviceName, name);
        putString(R.string.pref_webDeviceCode, code);
    }

    public static MapProvider getMapProvider() {
        return getMapSource().getMapProvider();
    }

    public static String getMapFile() {
        return getString(R.string.pref_mapfile, null);
    }

    public static boolean setMapFile(final String mapFile) {
        boolean result = putString(R.string.pref_mapfile, mapFile);
        if (mapFile != null) {
            setMapFileDirectory(new File(mapFile).getParent());
        }
        return result;
    }

    public static String getMapFileDirectory() {
        final String mapDir = getString(R.string.pref_mapDirectory, null);
        if (mapDir != null) {
            return mapDir;
        }
        final String mapFile = getMapFile();
        if (mapFile != null) {
            return new File(mapFile).getParent();
        }
        return null;
    }

    public static boolean setMapFileDirectory(final String mapFileDirectory) {
        boolean result = putString(R.string.pref_mapDirectory, mapFileDirectory);
        MapsforgeMapProvider.getInstance().updateOfflineMaps();
        return result;
    }

    public static boolean isValidMapFile() {
        return isValidMapFile(getMapFile());
    }

    public static boolean isValidMapFile(final String mapFileIn) {
        return MapsforgeMapProvider.isValidMapFile(mapFileIn);
    }

    public static boolean isScaleMapsforgeText() {
        return getBoolean(R.string.pref_mapsforge_scale_text, true);
    }

    public static CoordInputFormatEnum getCoordInputFormat() {
        return CoordInputFormatEnum.fromInt(getInt(R.string.pref_coordinputformat, 0));
    }

    public static void setCoordInputFormat(final CoordInputFormatEnum format) {
        putInt(R.string.pref_coordinputformat, format.ordinal());
    }

    static void setLogOffline(final boolean offline) {
        putBoolean(R.string.pref_log_offline, offline);
    }

    public static boolean getLogOffline() {
        return getBoolean(R.string.pref_log_offline, false);
    }

    public static boolean getChooseList() {
        return getBoolean(R.string.pref_choose_list, false);
    }

    public static boolean getLoadDirImg() {
        return !isPremiumMember() && getBoolean(R.string.pref_loaddirectionimg, true);
    }

    public static void setGcCustomDate(final String format) {
        putString(R.string.pref_gccustomdate, format);
    }

    /**
     * @return User selected date format on GC.com
     * @see Login#gcCustomDateFormats
     */
    public static String getGcCustomDate() {
        return getString(R.string.pref_gccustomdate, null);
    }

    public static boolean isExcludeMyCaches() {
        return getBoolean(R.string.pref_excludemine, false);
    }

    public static void setUseEnglish(final boolean english) {
        putBoolean(R.string.pref_useenglish, english);
        setLanguage(english);
    }

    public static boolean isUseEnglish() {
        return getBoolean(R.string.pref_useenglish, false);
    }

    public static boolean isShowAddress() {
        return getBoolean(R.string.pref_showaddress, true);
    }

    public static boolean isShowCaptcha() {
        return !isPremiumMember() && getBoolean(R.string.pref_showcaptcha, false);
    }

    public static boolean isExcludeDisabledCaches() {
        return getBoolean(R.string.pref_excludedisabled, false);
    }

    public static boolean isStoreOfflineMaps() {
        return getBoolean(R.string.pref_offlinemaps, true);
    }

    public static boolean isStoreOfflineWpMaps() {
        return getBoolean(R.string.pref_offlinewpmaps, false);
    }

    public static boolean isStoreLogImages() {
        return getBoolean(R.string.pref_logimages, false);
    }

    public static boolean isAutoLoadDescription() {
        return getBoolean(R.string.pref_autoloaddesc, true);
    }

    public static boolean isRatingWanted() {
        return getBoolean(R.string.pref_ratingwanted, true);
    }

    public static boolean isFriendLogsWanted() {
        if (!isLogin()) {
            // don't show a friends log if the user is anonymous
            return false;
        }
        return getBoolean(R.string.pref_friendlogswanted, true);
    }

    public static boolean isLiveList() {
        return getBoolean(R.string.pref_livelist, true);
    }

    public static boolean isTrackableAutoVisit() {
        return getBoolean(R.string.pref_trackautovisit, false);
    }

    public static boolean isAutoInsertSignature() {
        return getBoolean(R.string.pref_sigautoinsert, false);
    }

    public static boolean isUseImperialUnits() {
        return getBoolean(R.string.pref_units, getImperialUnitsDefault());
    }

    static boolean getImperialUnitsDefault() {
        final String countryCode = Locale.getDefault().getCountry();
        if ("US".equals(countryCode)) {
            return true; // USA
        }
        if ("LR".equals(countryCode)) {
            return true; // Liberia
        }
        if ("MM".equals(countryCode)) {
            return true; // Burma
        }
        return false;
    }

    public static boolean isLiveMap() {
        return getBoolean(R.string.pref_maplive, true);
    }

    public static void setLiveMap(final boolean live) {
        putBoolean(R.string.pref_maplive, live);
    }

    public static boolean isMapTrail() {
        return getBoolean(R.string.pref_maptrail, true);
    }

    public static void setMapTrail(final boolean showTrail) {
        putBoolean(R.string.pref_maptrail, showTrail);
    }

    public static int getMapZoom() {
        return getInt(R.string.pref_lastmapzoom, 14);
    }

    public static void setMapZoom(final int mapZoomLevel) {
        putInt(R.string.pref_lastmapzoom, mapZoomLevel);
    }

    public static GeoPointImpl getMapCenter() {
        return getMapProvider().getMapItemFactory()
                .getGeoPointBase(new Geopoint(getInt(R.string.pref_lastmaplat, 0) / 1e6,
                        getInt(R.string.pref_lastmaplon, 0) / 1e6));
    }

    public static void setMapCenter(final GeoPointImpl mapViewCenter) {
        putInt(R.string.pref_lastmaplat, mapViewCenter.getLatitudeE6());
        putInt(R.string.pref_lastmaplon, mapViewCenter.getLongitudeE6());
    }

    public static MapSource getMapSource() {
        if (mapSource != null) {
            return mapSource;
        }
        final int id = getConvertedMapId();
        mapSource = MapProviderFactory.getMapSource(id);
        if (mapSource != null) {
            // don't use offline maps if the map file is not valid
            if ((!(mapSource instanceof OfflineMapSource)) || (isValidMapFile())) {
                return mapSource;
            }
        }
        // fallback to first available map
        return MapProviderFactory.getDefaultSource();
    }

    private final static int GOOGLEMAP_BASEID = 30;
    private final static int MAP = 1;
    private final static int SATELLITE = 2;

    private final static int MFMAP_BASEID = 40;
    private final static int MAPNIK = 1;
    private final static int CYCLEMAP = 3;
    private final static int OFFLINE = 4;

    /**
     * convert old preference ids for maps (based on constant values) into new hash based ids
     *
     * @return
     */
    private static int getConvertedMapId() {
        // what the heck is happening here?? hashCodes of Strings?
        // why not strings?
        final int id = Integer.parseInt(getString(R.string.pref_mapsource,
                String.valueOf(MAP_SOURCE_DEFAULT)));
        switch (id) {
            case GOOGLEMAP_BASEID + MAP:
                return GoogleMapProvider.GOOGLE_MAP_ID.hashCode();
            case GOOGLEMAP_BASEID + SATELLITE:
                return GoogleMapProvider.GOOGLE_SATELLITE_ID.hashCode();
            case MFMAP_BASEID + MAPNIK:
                return MapsforgeMapProvider.MAPSFORGE_MAPNIK_ID.hashCode();
            case MFMAP_BASEID + CYCLEMAP:
                return MapsforgeMapProvider.MAPSFORGE_CYCLEMAP_ID.hashCode();
            case MFMAP_BASEID + OFFLINE: {
                final String mapFile = Settings.getMapFile();
                if (StringUtils.isNotEmpty(mapFile)) {
                    return mapFile.hashCode();
                }
                break;
            }
            default:
                break;
        }
        return id;
    }

    public static void setMapSource(final MapSource newMapSource) {
        putString(R.string.pref_mapsource, String.valueOf(newMapSource.getNumericalId()));
        if (newMapSource instanceof OfflineMapSource) {
            setMapFile(((OfflineMapSource) newMapSource).getFileName());
        }
        // cache the value
        mapSource = newMapSource;
    }

    public static void setAnyCoordinates(final Geopoint coords) {
        if (null != coords) {
            putFloat(R.string.pref_anylatitude, (float) coords.getLatitude());
            putFloat(R.string.pref_anylongitude, (float) coords.getLongitude());
        } else {
            remove(R.string.pref_anylatitude);
            remove(R.string.pref_anylongitude);
        }
    }

    public static Geopoint getAnyCoordinates() {
        if (contains(R.string.pref_anylatitude) && contains(R.string.pref_anylongitude)) {
            float lat = getFloat(R.string.pref_anylatitude, 0);
            float lon = getFloat(R.string.pref_anylongitude, 0);
            return new Geopoint(lat, lon);
        }
        return null;
    }

    public static boolean isUseCompass() {
        return getBoolean(R.string.pref_usecompass, true);
    }

    public static void setUseCompass(final boolean useCompass) {
        putBoolean(R.string.pref_usecompass, useCompass);
    }

    public static boolean isLightSkin() {
        return getBoolean(R.string.pref_skin, false);
    }

    public static String getKeyConsumerPublic() {
        return keyConsumerPublic;
    }

    public static String getKeyConsumerSecret() {
        return keyConsumerSecret;
    }

    public static String getWebDeviceCode() {
        return getString(R.string.pref_webDeviceCode, null);
    }

    public static String getWebDeviceName() {
        return getString(R.string.pref_webDeviceName, android.os.Build.MODEL);
    }

    /**
     * @return The cache type used for filtering or ALL if no filter is active.
     *         Returns never null
     */
    public static CacheType getCacheType() {
        return CacheType.getById(getString(R.string.pref_cachetype, CacheType.ALL.id));
    }

    /**
     * The Threshold for the showing of child waypoints
     */
    public static int getWayPointsThreshold() {
        return getInt(R.string.pref_showwaypointsthreshold, SHOW_WP_THRESHOLD_DEFAULT);
    }

    public static void setShowWaypointsThreshold(final int threshold) {
        putInt(R.string.pref_showwaypointsthreshold, threshold);
    }

    public static boolean isUseTwitter() {
        return getBoolean(R.string.pref_twitter, false);
    }

    public static void setUseTwitter(final boolean useTwitter) {
        putBoolean(R.string.pref_twitter, useTwitter);
    }

    public static boolean isTwitterLoginValid() {
        return !StringUtils.isBlank(getTokenPublic())
                && !StringUtils.isBlank(getTokenSecret());
    }

    public static String getTokenPublic() {
        return getString(R.string.pref_twitter_token_public, null);
    }

    public static String getTokenSecret() {
        return getString(R.string.pref_twitter_token_secret, null);

    }

    public static boolean hasTwitterAuthorization() {
        return StringUtils.isNotBlank(getTokenPublic())
                && StringUtils.isNotBlank(getTokenSecret());
    }

    public static void setTwitterTokens(final String tokenPublic,
            final String tokenSecret, boolean enableTwitter) {
        putString(R.string.pref_twitter_token_public, tokenPublic);
        putString(R.string.pref_twitter_token_secret, tokenSecret);
        if (tokenPublic != null) {
            remove(R.string.pref_temp_twitter_token_public);
            remove(R.string.pref_temp_twitter_token_secret);
        }
        setUseTwitter(enableTwitter);
    }

    public static void setTwitterTempTokens(final String tokenPublic,
            final String tokenSecret) {
        putString(R.string.pref_temp_twitter_token_public, tokenPublic);
        putString(R.string.pref_temp_twitter_token_secret, tokenSecret);
    }

    public static ImmutablePair<String, String> getTempToken() {
        String tokenPublic = getString(R.string.pref_temp_twitter_token_public, null);
        String tokenSecret = getString(R.string.pref_temp_twitter_token_secret, null);
        return new ImmutablePair<String, String>(tokenPublic, tokenSecret);
    }

    public static int getVersion() {
        return getInt(R.string.pref_version, 0);
    }

    public static void setVersion(final int version) {
        putInt(R.string.pref_version, version);
    }

    public static boolean isOpenLastDetailsPage() {
        return getBoolean(R.string.pref_opendetailslastpage, false);
    }

    public static int getLastDetailsPage() {
        return getInt(R.string.pref_lastdetailspage, 1);
    }

    public static void setLastDetailsPage(final int index) {
        putInt(R.string.pref_lastdetailspage, index);
    }

    public static int getDefaultNavigationTool() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool,
                String.valueOf(NavigationAppsEnum.COMPASS.id)));
    }

    public static void setDefaultNavigationTool(final int defaultNavigationTool) {
        putString(R.string.pref_defaultNavigationTool,
                String.valueOf(defaultNavigationTool));
    }

    public static int getDefaultNavigationTool2() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool2,
                String.valueOf(NavigationAppsEnum.INTERNAL_MAP.id)));
    }

    public static void setDefaultNavigationTool2(final int defaultNavigationTool) {
        putString(R.string.pref_defaultNavigationTool2,
                String.valueOf(defaultNavigationTool));
    }

    public static Strategy getLiveMapStrategy() {
        return Strategy.getById(getInt(R.string.pref_livemapstrategy, Strategy.AUTO.id));
    }

    public static void setLiveMapStrategy(final Strategy strategy) {
        putInt(R.string.pref_livemapstrategy, strategy.id);
    }

    public static boolean isDebug() {
        return Log.isDebug();
    }

    public static boolean getHideLiveMapHint() {
        return getBoolean(R.string.pref_hidelivemaphint, false);
    }

    public static void setHideLiveHint(final boolean hide) {
        putBoolean(R.string.pref_hidelivemaphint, hide);
    }

    public static int getLiveMapHintShowCount() {
        return getInt(R.string.pref_livemaphintshowcount, 0);
    }

    public static void setLiveMapHintShowCount(final int showCount) {
        putInt(R.string.pref_livemaphintshowcount, showCount);
    }

    public static boolean isDbOnSDCard() {
        return getBoolean(R.string.pref_dbonsdcard, false);
    }

    public static void setDbOnSDCard(final boolean dbOnSDCard) {
        putBoolean(R.string.pref_dbonsdcard, dbOnSDCard);
    }

    public static String getGpxExportDir() {
        return getString(R.string.pref_gpxExportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static String getGpxImportDir() {
        return getString(R.string.pref_gpxImportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static boolean getShareAfterExport() {
        return getBoolean(R.string.pref_shareafterexport, true);
    }

    public static void setShareAfterExport(final boolean shareAfterExport) {
        putBoolean(R.string.pref_shareafterexport, shareAfterExport);
    }

    public static int getTrackableAction() {
        return getInt(R.string.pref_trackableaction, LogType.RETRIEVED_IT.id);
    }

    public static void setTrackableAction(final int trackableAction) {
        putInt(R.string.pref_trackableaction, trackableAction);
    }

    public static String getCustomRenderThemeBaseFolder() {
        return getString(R.string.pref_renderthemepath, "");
    }

    public static String getCustomRenderThemeFilePath() {
        return getString(R.string.pref_renderthemefile, "");
    }

    public static void setCustomRenderThemeFile(final String customRenderThemeFile) {
        putString(R.string.pref_renderthemefile, customRenderThemeFile);
    }

    public static File[] getMapThemeFiles() {
        File directory = new File(Settings.getCustomRenderThemeBaseFolder());
        List<File> result = new ArrayList<File>();
        FileUtils.listDir(result, directory, new ExtensionsBasedFileSelector(new String[] { "xml" }), null);

        return result.toArray(new File[result.size()]);
    }

    private static class ExtensionsBasedFileSelector extends FileSelector {
        private final String[] extensions;
        public ExtensionsBasedFileSelector(String[] extensions) {
            this.extensions = extensions;
        }
        @Override
        public boolean isSelected(File file) {
            String filename = file.getName();
            for (String ext : extensions) {
                if (StringUtils.endsWithIgnoreCase(filename, ext)) {
                    return true;
                }
            }
            return false;
        }
        @Override
        public boolean shouldEnd() {
            return false;
        }
    }

    public static boolean getPlainLogs() {
        return getBoolean(R.string.pref_plainLogs, false);
    }

    public static boolean getUseNativeUa() {
        return getBoolean(R.string.pref_nativeUa, false);
    }

    public static String getCacheTwitterMessage() {
        // TODO make customizable from UI
        return "I found [NAME] ([URL])";
    }

    public static String getTrackableTwitterMessage() {
        // TODO make customizable from UI
        return "I touched [NAME] ([URL])!";
    }

    public static int getLogImageScale() {
        return getInt(R.string.pref_logImageScale, -1);
    }

    public static void setLogImageScale(final int scale) {
        putInt(R.string.pref_logImageScale, scale);
    }

    // Only for tests!
    static void setExcludeDisabledCaches(final boolean exclude) {
        putBoolean(R.string.pref_excludedisabled, exclude);
    }

    public static void setExcludeMine(final boolean exclude) {
        putBoolean(R.string.pref_excludemine, exclude);
    }

    static boolean setLogin(final String username, final String password) {

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            // erase username and password
            boolean a = remove(R.string.pref_username);
            boolean b = remove(R.string.pref_password);
            return a && b;
        }
        // save username and password
        boolean a = putString(R.string.pref_username, username);
        boolean b = putString(R.string.pref_password, password);
        return a && b;
    }

    static void setStoreOfflineMaps(final boolean offlineMaps) {
        putBoolean(R.string.pref_offlinemaps, offlineMaps);
    }

    static void setStoreOfflineWpMaps(final boolean offlineWpMaps) {
        putBoolean(R.string.pref_offlinewpmaps, offlineWpMaps);
    }

    static void setUseImperialUnits(final boolean imperial) {
        putBoolean(R.string.pref_units, imperial);
    }

    public static long getFieldnoteExportDate() {
        return getLong(R.string.pref_fieldnoteExportDate, 0);
    }

    public static void setFieldnoteExportDate(final long date) {
        putLong(R.string.pref_fieldnoteExportDate, date);
    }

    public static boolean isUseNavigationApp(NavigationAppsEnum navApp) {
        return getBoolean(navApp.preferenceKey, true);
    }

}
!@#$%
20190527_003039,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_b04528
package cgeo.geocaching.connector.oc;

import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.DataStore;
import cgeo.geocaching.Geocache;
import cgeo.geocaching.Image;
import cgeo.geocaching.LogEntry;
import cgeo.geocaching.R;
import cgeo.geocaching.Waypoint;
import cgeo.geocaching.connector.ConnectorFactory;
import cgeo.geocaching.connector.IConnector;
import cgeo.geocaching.connector.LogResult;
import cgeo.geocaching.connector.gc.GCConnector;
import cgeo.geocaching.connector.oc.OCApiConnector.ApiSupport;
import cgeo.geocaching.connector.oc.OCApiConnector.OAuthLevel;
import cgeo.geocaching.connector.oc.UserInfo.UserInfoStatus;
import cgeo.geocaching.enumerations.CacheAttribute;
import cgeo.geocaching.enumerations.CacheSize;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.LoadFlags.SaveFlag;
import cgeo.geocaching.enumerations.LogType;
import cgeo.geocaching.enumerations.StatusCode;
import cgeo.geocaching.enumerations.WaypointType;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.geopoint.GeopointFormatter;
import cgeo.geocaching.geopoint.Viewport;
import cgeo.geocaching.network.Network;
import cgeo.geocaching.network.OAuth;
import cgeo.geocaching.network.Parameters;
import cgeo.geocaching.settings.Settings;
import cgeo.geocaching.utils.Log;
import cgeo.geocaching.utils.SynchronizedDateFormat;

import ch.boye.httpclientandroidlib.HttpResponse;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.time.FastDateFormat;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import android.net.Uri;

import java.text.ParseException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Date;
import java.util.EnumSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.TimeZone;

final class OkapiClient {

    private static final char SEPARATOR = '|';
    private static final String SEPARATOR_STRING = Character.toString(SEPARATOR);
    private static final FastDateFormat LOG_DATE_FORMAT = FastDateFormat.getInstance("yyyy-MM-dd HH:mm:ss.SSSZ", TimeZone.getTimeZone("UTC"), Locale.US);
    private static final SynchronizedDateFormat ISO8601DATEFORMAT = new SynchronizedDateFormat("yyyy-MM-dd'T'HH:mm:ssZ", Locale.getDefault());

    private static final String CACHE_ATTRNAMES = "attrnames";
    private static final String CACHE_ATTR_ACODES = "attr_acodes";
    private static final String WPT_LOCATION = "location";
    private static final String WPT_DESCRIPTION = "description";
    private static final String WPT_TYPE = "type";
    private static final String WPT_NAME = "name";
    private static final String CACHE_IS_WATCHED = "is_watched";
    private static final String CACHE_WPTS = "alt_wpts";
    private static final String CACHE_STATUS_ARCHIVED = "Archived";
    private static final String CACHE_STATUS_DISABLED = "Temporarily unavailable";
    private static final String CACHE_IS_FOUND = "is_found";
    private static final String CACHE_SIZE = "size";
    private static final String CACHE_VOTES = "rating_votes";
    private static final String CACHE_NOTFOUNDS = "notfounds";
    private static final String CACHE_FOUNDS = "founds";
    private static final String CACHE_HIDDEN = "date_hidden";
    private static final String CACHE_LATEST_LOGS = "latest_logs";
    private static final String CACHE_IMAGE_URL = "url";
    private static final String CACHE_IMAGE_CAPTION = "caption";
    private static final String CACHE_IMAGES = "images";
    private static final String CACHE_HINT = "hint";
    private static final String CACHE_DESCRIPTION = "description";
    private static final String CACHE_RECOMMENDATIONS = "recommendations";
    private static final String CACHE_RATING = "rating";
    private static final String CACHE_TERRAIN = "terrain";
    private static final String CACHE_DIFFICULTY = "difficulty";
    private static final String CACHE_OWNER = "owner";
    private static final String CACHE_STATUS = "status";
    private static final String CACHE_TYPE = "type";
    private static final String CACHE_LOCATION = "location";
    private static final String CACHE_NAME = "name";
    private static final String CACHE_CODE = "code";
    private static final String CACHE_REQ_PASSWORD = "req_passwd";
    private static final String CACHE_MY_NOTES = "my_notes";

    private static final String LOG_TYPE = "type";
    private static final String LOG_COMMENT = "comment";
    private static final String LOG_DATE = "date";
    private static final String LOG_USER = "user";

    private static final String USER_UUID = "uuid";
    private static final String USER_USERNAME = "username";
    private static final String USER_CACHES_FOUND = "caches_found";
    private static final String USER_INFO_FIELDS = "username|caches_found";

    // the several realms of possible fields for cache retrieval:
    // Core: for livemap requests (L3 - only with level 3 auth)
    // Additional: additional fields for full cache (L3 - only for level 3 auth, current - only for connectors with current api)
    private static final String SERVICE_CACHE_CORE_FIELDS = "code|name|location|type|status|difficulty|terrain|size|date_hidden";
    private static final String SERVICE_CACHE_CORE_L3_FIELDS = "is_found";
    private static final String SERVICE_CACHE_ADDITIONAL_FIELDS = "owner|founds|notfounds|rating|rating_votes|recommendations|description|hint|images|latest_logs|alt_wpts|attrnames|req_passwd";
    private static final String SERVICE_CACHE_ADDITIONAL_CURRENT_FIELDS = "gc_code|attribution_note|attr_acodes";
    private static final String SERVICE_CACHE_ADDITIONAL_L3_FIELDS = "is_watched|my_notes";

    private static final String METHOD_SEARCH_ALL = "services/caches/search/all";
    private static final String METHOD_SEARCH_BBOX = "services/caches/search/bbox";
    private static final String METHOD_SEARCH_NEAREST = "services/caches/search/nearest";
    private static final String METHOD_RETRIEVE_CACHES = "services/caches/geocaches";

    public static Geocache getCache(final String geoCode) {
        final Parameters params = new Parameters("cache_code", geoCode);
        final IConnector connector = ConnectorFactory.getConnector(geoCode);
        if (!(connector instanceof OCApiConnector)) {
            return null;
        }

        final OCApiConnector ocapiConn = (OCApiConnector) connector;

        params.add("fields", getFullFields(ocapiConn));
        params.add("attribution_append", "none");

        final JSONResult result = request(ocapiConn, OkapiService.SERVICE_CACHE, params);

        return result.isSuccess ? parseCache(result.data) : null;
    }

    public static List<Geocache> getCachesAround(final Geopoint center, final OCApiConnector connector) {
        final String centerString = GeopointFormatter.format(GeopointFormatter.Format.LAT_DECDEGREE_RAW, center) + SEPARATOR + GeopointFormatter.format(GeopointFormatter.Format.LON_DECDEGREE_RAW, center);
        final Parameters params = new Parameters("search_method", METHOD_SEARCH_NEAREST);
        final Map<String, String> valueMap = new LinkedHashMap<String, String>();
        valueMap.put("center", centerString);
        valueMap.put("limit", "20");
        valueMap.put("radius", "200");

        return requestCaches(connector, params, valueMap);
    }

    public static List<Geocache> getCachesByOwner(final String username, final OCApiConnector connector) {
        final Parameters params = new Parameters("search_method", METHOD_SEARCH_ALL);
        final Map<String, String> valueMap = new LinkedHashMap<String, String>();
        final String uuid = getUserUUID(connector, username);
        valueMap.put("owner_uuid", uuid);

        return requestCaches(connector, params, valueMap);
    }

    public static List<Geocache> getCachesByFinder(final String username, final OCApiConnector connector) {
        final Parameters params = new Parameters("search_method", METHOD_SEARCH_ALL);
        final Map<String, String> valueMap = new LinkedHashMap<String, String>();
        final String uuid = getUserUUID(connector, username);
        valueMap.put("found_by", uuid);

        return requestCaches(connector, params, valueMap);
    }

    public static List<Geocache> getCachesNamed(final Geopoint center, final String namePart, final OCApiConnector connector) {
        final Map<String, String> valueMap = new LinkedHashMap<String, String>();
        final Parameters params;

        // search around current position, if there is a position
        if (center != null) {
            final String centerString = GeopointFormatter.format(GeopointFormatter.Format.LAT_DECDEGREE_RAW, center) + SEPARATOR + GeopointFormatter.format(GeopointFormatter.Format.LON_DECDEGREE_RAW, center);
            params = new Parameters("search_method", METHOD_SEARCH_NEAREST);
            valueMap.put("center", centerString);
            valueMap.put("limit", "20");
        }
        else {
            params = new Parameters("search_method", METHOD_SEARCH_ALL);
            valueMap.put("limit", "20");
        }

        // full wildcard search, maybe we need to change this after some testing and evaluation
        valueMap.put("name", "*" + namePart + "*");
        return requestCaches(connector, params, valueMap);
    }

    private static List<Geocache> requestCaches(final OCApiConnector connector, final Parameters params, final Map<String, String> valueMap) {
        // if a global type filter is set, and OKAPI does not know that type, then return an empty list instead of all caches
        if (Settings.getCacheType() != CacheType.ALL && StringUtils.isBlank(getFilterFromType())) {
            return Collections.emptyList();
        }

        addFilterParams(valueMap, connector);
        params.add("search_params", new JSONObject(valueMap).toString());
        addRetrieveParams(params, connector);

        final JSONObject data = request(connector, OkapiService.SERVICE_SEARCH_AND_RETRIEVE, params).data;

        if (data == null) {
            return Collections.emptyList();
        }

        return parseCaches(data);
    }

    /**
     * Assumes level 3 OAuth.
     */
    public static List<Geocache> getCachesBBox(final Viewport viewport, final OCApiConnector connector) {

        if (viewport.getLatitudeSpan() == 0 || viewport.getLongitudeSpan() == 0) {
            return Collections.emptyList();
        }

        final String bboxString = GeopointFormatter.format(GeopointFormatter.Format.LAT_DECDEGREE_RAW, viewport.bottomLeft)
                + SEPARATOR + GeopointFormatter.format(GeopointFormatter.Format.LON_DECDEGREE_RAW, viewport.bottomLeft)
                + SEPARATOR + GeopointFormatter.format(GeopointFormatter.Format.LAT_DECDEGREE_RAW, viewport.topRight)
                + SEPARATOR + GeopointFormatter.format(GeopointFormatter.Format.LON_DECDEGREE_RAW, viewport.topRight);
        final Parameters params = new Parameters("search_method", METHOD_SEARCH_BBOX);
        final Map<String, String> valueMap = new LinkedHashMap<String, String>();
        valueMap.put("bbox", bboxString);

        return requestCaches(connector, params, valueMap);
    }

    public static boolean setWatchState(final Geocache cache, final boolean watched, final OCApiConnector connector) {
        final Parameters params = new Parameters("cache_code", cache.getGeocode());
        params.add("watched", watched ? "true" : "false");

        final JSONObject data = request(connector, OkapiService.SERVICE_MARK_CACHE, params).data;

        if (data == null) {
            return false;
        }

        cache.setOnWatchlist(watched);

        return true;
    }

    public static LogResult postLog(final Geocache cache, final LogType logType, final Calendar date, final String log, final String logPassword, final OCApiConnector connector) {
        final Parameters params = new Parameters("cache_code", cache.getGeocode());
        params.add("logtype", logType.oc_type);
        params.add("comment", log);
        params.add("comment_format", "plaintext");
        params.add("when", LOG_DATE_FORMAT.format(date.getTime()));
        if (logType.equals(LogType.NEEDS_MAINTENANCE)) {
            params.add("needs_maintenance", "true");
        }
        if (logPassword != null) {
            params.add("password", logPassword);
        }

        final JSONObject data = request(connector, OkapiService.SERVICE_SUBMIT_LOG, params).data;

        if (data == null) {
            return new LogResult(StatusCode.LOG_POST_ERROR, "");
        }

        try {
            if (data.getBoolean("success")) {
                return new LogResult(StatusCode.NO_ERROR, data.getString("log_uuid"));
            }

            return new LogResult(StatusCode.LOG_POST_ERROR, "");
        } catch (final JSONException e) {
            Log.e("OkapiClient.postLog", e);
        }
        return new LogResult(StatusCode.LOG_POST_ERROR, "");
    }

    private static List<Geocache> parseCaches(final JSONObject response) {
        try {
            // Check for empty result
            final String result = response.getString("results");
            if (StringUtils.isBlank(result) || StringUtils.equals(result, "[]")) {
                return Collections.emptyList();
            }

            // Get and iterate result list
            final JSONObject cachesResponse = response.getJSONObject("results");
            if (cachesResponse != null) {
                final List<Geocache> caches = new ArrayList<Geocache>(cachesResponse.length());
                @SuppressWarnings("unchecked")
                final
                Iterator<String> keys = cachesResponse.keys();
                while (keys.hasNext()) {
                    final String key = keys.next();
                    final Geocache cache = parseSmallCache(cachesResponse.getJSONObject(key));
                    caches.add(cache);
                }
                return caches;
            }
        } catch (final JSONException e) {
            Log.e("OkapiClient.parseCachesResult", e);
        }
        return Collections.emptyList();
    }

    private static Geocache parseSmallCache(final JSONObject response) {
        final Geocache cache = new Geocache();
        cache.setReliableLatLon(true);
        try {

            parseCoreCache(response, cache);

            DataStore.saveCache(cache, EnumSet.of(SaveFlag.SAVE_CACHE));
        } catch (final JSONException e) {
            Log.e("OkapiClient.parseSmallCache", e);
        }
        return cache;
    }

    private static Geocache parseCache(final JSONObject response) {
        final Geocache cache = new Geocache();
        cache.setReliableLatLon(true);
        try {

            parseCoreCache(response, cache);

            // not used: url
            final JSONObject owner = response.getJSONObject(CACHE_OWNER);
            cache.setOwnerDisplayName(parseUser(owner));

            cache.getLogCounts().put(LogType.FOUND_IT, response.getInt(CACHE_FOUNDS));
            cache.getLogCounts().put(LogType.DIDNT_FIND_IT, response.getInt(CACHE_NOTFOUNDS));

            if (!response.isNull(CACHE_RATING)) {
                cache.setRating((float) response.getDouble(CACHE_RATING));
            }
            cache.setVotes(response.getInt(CACHE_VOTES));

            cache.setFavoritePoints(response.getInt(CACHE_RECOMMENDATIONS));
            // not used: req_password
            // Prepend gc-link to description if available
            final StringBuilder description = new StringBuilder(500);
            if (!response.isNull("gc_code")) {
                final String gccode = response.getString("gc_code");
                description.append(CgeoApplication.getInstance().getResources()
                        .getString(R.string.cache_listed_on, GCConnector.getInstance().getName()))
                        .append(": <a href=\"http://coord.info/")
                        .append(gccode)
                        .append("\">")
                        .append(gccode)
                        .append("</a><br /><br />");
            }
            description.append(response.getString(CACHE_DESCRIPTION));
            cache.setDescription(description.toString());

            // currently the hint is delivered as HTML (contrary to OKAPI documentation), so we can store it directly
            cache.setHint(response.getString(CACHE_HINT));
            // not used: hints

            final JSONArray images = response.getJSONArray(CACHE_IMAGES);
            if (images != null) {
                for (int i = 0; i < images.length(); i++) {
                    final JSONObject imageResponse = images.getJSONObject(i);
                    final String title = imageResponse.getString(CACHE_IMAGE_CAPTION);
                    final String url = absoluteUrl(imageResponse.getString(CACHE_IMAGE_URL), cache.getGeocode());
                    // all images are added as spoiler images, although OKAPI has spoiler and non spoiler images
                    cache.addSpoiler(new Image(url, title));
                }
            }

            cache.setAttributes(parseAttributes(response.getJSONArray(CACHE_ATTRNAMES), response.optJSONArray(CACHE_ATTR_ACODES)));
            cache.setLogs(parseLogs(response.getJSONArray(CACHE_LATEST_LOGS)));
            //TODO: Store license per cache
            //cache.setLicense(response.getString("attribution_note"));
            cache.setWaypoints(parseWaypoints(response.getJSONArray(CACHE_WPTS)), false);
            if (!response.isNull(CACHE_IS_WATCHED)) {
                cache.setOnWatchlist(response.getBoolean(CACHE_IS_WATCHED));
            }
            if (!response.isNull(CACHE_MY_NOTES)) {
                cache.setPersonalNote(response.getString(CACHE_MY_NOTES));
            }
            cache.setLogPasswordRequired(response.getBoolean(CACHE_REQ_PASSWORD));

            cache.setDetailedUpdatedNow();
            // save full detailed caches
            DataStore.saveCache(cache, EnumSet.of(SaveFlag.SAVE_DB));
        } catch (final JSONException e) {
            Log.e("OkapiClient.parseCache", e);
        }
        return cache;
    }

    private static void parseCoreCache(final JSONObject response, final Geocache cache) throws JSONException {
        cache.setGeocode(response.getString(CACHE_CODE));
        cache.setName(response.getString(CACHE_NAME));
        // not used: names
        setLocation(cache, response.getString(CACHE_LOCATION));
        cache.setType(getCacheType(response.getString(CACHE_TYPE)));

        final String status = response.getString(CACHE_STATUS);
        cache.setDisabled(status.equalsIgnoreCase(CACHE_STATUS_DISABLED));
        cache.setArchived(status.equalsIgnoreCase(CACHE_STATUS_ARCHIVED));

        cache.setSize(getCacheSize(response));
        cache.setDifficulty((float) response.getDouble(CACHE_DIFFICULTY));
        cache.setTerrain((float) response.getDouble(CACHE_TERRAIN));

        if (!response.isNull(CACHE_IS_FOUND)) {
            cache.setFound(response.getBoolean(CACHE_IS_FOUND));
        }
        cache.setHidden(parseDate(response.getString(CACHE_HIDDEN)));
    }

    private static String absoluteUrl(final String url, final String geocode) {
        final Uri uri = Uri.parse(url);

        if (!uri.isAbsolute()) {
            final IConnector connector = ConnectorFactory.getConnector(geocode);
            final String host = connector.getHost();
            if (StringUtils.isNotBlank(host)) {
                return "http://" + host + "/" + url;
            }
        }
        return url;
    }

    private static String parseUser(final JSONObject user) throws JSONException {
        return user.getString(USER_USERNAME);
    }

    private static List<LogEntry> parseLogs(final JSONArray logsJSON) {
        List<LogEntry> result = null;
        for (int i = 0; i < logsJSON.length(); i++) {
            try {
                final JSONObject logResponse = logsJSON.getJSONObject(i);
                final LogEntry log = new LogEntry(
                        parseUser(logResponse.getJSONObject(LOG_USER)),
                        parseDate(logResponse.getString(LOG_DATE)).getTime(),
                        parseLogType(logResponse.getString(LOG_TYPE)),
                        logResponse.getString(LOG_COMMENT).trim());
                if (result == null) {
                    result = new ArrayList<LogEntry>();
                }
                result.add(log);
            } catch (final JSONException e) {
                Log.e("OkapiClient.parseLogs", e);
            }
        }
        return result;
    }

    private static List<Waypoint> parseWaypoints(final JSONArray wptsJson) {
        List<Waypoint> result = null;
        for (int i = 0; i < wptsJson.length(); i++) {
            try {
                final JSONObject wptResponse = wptsJson.getJSONObject(i);
                final Waypoint wpt = new Waypoint(wptResponse.getString(WPT_NAME),
                        parseWptType(wptResponse.getString(WPT_TYPE)),
                        false);
                wpt.setNote(wptResponse.getString(WPT_DESCRIPTION));
                final Geopoint pt = parseCoords(wptResponse.getString(WPT_LOCATION));
                if (pt != null) {
                    wpt.setCoords(pt);
                }
                if (result == null) {
                    result = new ArrayList<Waypoint>();
                }
                wpt.setPrefix(wpt.getName());
                result.add(wpt);
            } catch (final JSONException e) {
                Log.e("OkapiClient.parseWaypoints", e);
            }
        }
        return result;
    }

    private static LogType parseLogType(final String logType) {
        if ("Found it".equalsIgnoreCase(logType)) {
            return LogType.FOUND_IT;
        }
        if ("Didn't find it".equalsIgnoreCase(logType)) {
            return LogType.DIDNT_FIND_IT;
        }
        return LogType.NOTE;
    }

    private static WaypointType parseWptType(final String wptType) {
        if ("parking".equalsIgnoreCase(wptType)) {
            return WaypointType.PARKING;
        }
        if ("path".equalsIgnoreCase(wptType)) {
            return WaypointType.TRAILHEAD;
        }
        if ("stage".equalsIgnoreCase(wptType)) {
            return WaypointType.STAGE;
        }
        if ("physical-stage".equalsIgnoreCase(wptType)) {
            return WaypointType.STAGE;
        }
        if ("virtual-stage".equalsIgnoreCase(wptType)) {
            return WaypointType.PUZZLE;
        }
        if ("final".equalsIgnoreCase(wptType)) {
            return WaypointType.FINAL;
        }
        if ("poi".equalsIgnoreCase(wptType)) {
            return WaypointType.TRAILHEAD;
        }
        return WaypointType.WAYPOINT;
    }

    private static Date parseDate(final String date) {
        final String strippedDate = date.replaceAll("\\+0([0-9]){1}\\:00", "+0$100");
        try {
            return ISO8601DATEFORMAT.parse(strippedDate);
        } catch (final ParseException e) {
            Log.e("OkapiClient.parseDate", e);
        }
        return null;
    }

    private static Geopoint parseCoords(final String location) {
        final String latitude = StringUtils.substringBefore(location, SEPARATOR_STRING);
        final String longitude = StringUtils.substringAfter(location, SEPARATOR_STRING);
        if (StringUtils.isNotBlank(latitude) && StringUtils.isNotBlank(longitude)) {
            return new Geopoint(latitude, longitude);
        }

        return null;
    }

    private static List<String> parseAttributes(final JSONArray nameList, final JSONArray acodeList) {

        final List<String> result = new ArrayList<String>();

        for (int i = 0; i < nameList.length(); i++) {
            try {
                final String name = nameList.getString(i);
                final int acode = acodeList != null ? Integer.parseInt(acodeList.getString(i).substring(1)) : CacheAttribute.NO_ID;
                final CacheAttribute attr = CacheAttribute.getByOcACode(acode);

                if (attr != null) {
                    result.add(attr.rawName);
                } else {
                    result.add(name);
                }
            } catch (final JSONException e) {
                Log.e("OkapiClient.parseAttributes", e);
            }
        }

        return result;
    }

    private static void setLocation(final Geocache cache, final String location) {
        final String latitude = StringUtils.substringBefore(location, SEPARATOR_STRING);
        final String longitude = StringUtils.substringAfter(location, SEPARATOR_STRING);
        cache.setCoords(new Geopoint(latitude, longitude));
    }

    private static CacheSize getCacheSize(final JSONObject response) {
        if (response.isNull(CACHE_SIZE)) {
            return CacheSize.NOT_CHOSEN;
        }
        double size = 0;
        try {
            size = response.getDouble(CACHE_SIZE);
        } catch (final JSONException e) {
            Log.e("OkapiClient.getCacheSize", e);
        }
        switch ((int) Math.round(size)) {
            case 1:
                return CacheSize.MICRO;
            case 2:
                return CacheSize.SMALL;
            case 3:
                return CacheSize.REGULAR;
            case 4:
                return CacheSize.LARGE;
            case 5:
                return CacheSize.LARGE;
            default:
                break;
        }
        return CacheSize.NOT_CHOSEN;
    }

    private static CacheType getCacheType(final String cacheType) {
        if (cacheType.equalsIgnoreCase("Traditional")) {
            return CacheType.TRADITIONAL;
        }
        if (cacheType.equalsIgnoreCase("Multi")) {
            return CacheType.MULTI;
        }
        if (cacheType.equalsIgnoreCase("Quiz")) {
            return CacheType.MYSTERY;
        }
        if (cacheType.equalsIgnoreCase("Virtual")) {
            return CacheType.VIRTUAL;
        }
        if (cacheType.equalsIgnoreCase("Event")) {
            return CacheType.EVENT;
        }
        if (cacheType.equalsIgnoreCase("Webcam")) {
            return CacheType.WEBCAM;
        }
        if (cacheType.equalsIgnoreCase("Math/Physics")) {
            return CacheType.MYSTERY;
        }
        if (cacheType.equalsIgnoreCase("Drive-In")) {
            return CacheType.TRADITIONAL;
        }
        return CacheType.UNKNOWN;
    }

    private static String getCoreFields(final OCApiConnector connector) {
        if (connector == null) {
            Log.e("OkapiClient.getCoreFields called with invalid connector");
            return StringUtils.EMPTY;
        }

        if (connector.getSupportedAuthLevel() == OAuthLevel.Level3) {
            return SERVICE_CACHE_CORE_FIELDS + SEPARATOR + SERVICE_CACHE_CORE_L3_FIELDS;
        }

        return SERVICE_CACHE_CORE_FIELDS;
    }

    private static String getFullFields(final OCApiConnector connector) {
        if (connector == null) {
            Log.e("OkapiClient.getFullFields called with invalid connector");
            return StringUtils.EMPTY;
        }

        final StringBuilder res = new StringBuilder(500);

        res.append(SERVICE_CACHE_CORE_FIELDS);
        res.append(SEPARATOR).append(SERVICE_CACHE_ADDITIONAL_FIELDS);
        if (connector.getSupportedAuthLevel() == OAuthLevel.Level3) {
            res.append(SEPARATOR).append(SERVICE_CACHE_CORE_L3_FIELDS);
            res.append(SEPARATOR).append(SERVICE_CACHE_ADDITIONAL_L3_FIELDS);
        }
        if (connector.getApiSupport() == ApiSupport.current) {
            res.append(SEPARATOR).append(SERVICE_CACHE_ADDITIONAL_CURRENT_FIELDS);
        }

        return res.toString();
    }

    @NonNull
    private static JSONResult request(final OCApiConnector connector, final OkapiService service, final Parameters params) {
        if (connector == null) {
            return new JSONResult(null);
        }

        final String host = connector.getHost();
        if (StringUtils.isBlank(host)) {
            return new JSONResult(null);
        }

        params.add("langpref", getPreferredLanguage());

        if (connector.getSupportedAuthLevel() == OAuthLevel.Level3) {
            ImmutablePair<String, String> tokens = Settings.getTokenPair(connector.getTokenPublicPrefKeyId(), connector.getTokenSecretPrefKeyId());
            OAuth.signOAuth(host, service.methodName, "GET", false, params, tokens.left, tokens.right, connector.getCK(), connector.getCS());
        } else {
            connector.addAuthentication(params);
        }

        final String uri = "http://" + host + service.methodName;
        return new JSONResult(Network.getRequest(uri, params));
    }

    private static String getPreferredLanguage() {
        final String code = Locale.getDefault().getCountry();
        if (StringUtils.isNotBlank(code)) {
            return StringUtils.lowerCase(code) + "|en";
        }
        return "en";
    }

    private static void addFilterParams(final Map<String, String> valueMap, final OCApiConnector connector) {
        if (!Settings.isExcludeDisabledCaches()) {
            valueMap.put("status", "Available|Temporarily unavailable");
        }
        if (Settings.isExcludeMyCaches() && connector.getSupportedAuthLevel() == OAuthLevel.Level3) {
            valueMap.put("exclude_my_own", "true");
            valueMap.put("found_status", "notfound_only");
        }
        if (Settings.getCacheType() != CacheType.ALL) {
            valueMap.put("type", getFilterFromType());
        }
    }

    private static void addRetrieveParams(final Parameters params, final OCApiConnector connector) {
        params.add("retr_method", METHOD_RETRIEVE_CACHES);
        params.add("retr_params", "{\"fields\": \"" + getCoreFields(connector) + "\"}");
        params.add("wrap", "true");
    }

    private static String getFilterFromType() {
        switch (Settings.getCacheType()) {
            case EVENT:
                return "Event";
            case MULTI:
                return "Multi";
            case MYSTERY:
                return "Quiz";
            case TRADITIONAL:
                return "Traditional";
            case VIRTUAL:
                return "Virtual";
            case WEBCAM:
                return "Webcam";
            default:
                return "";
        }
    }

    public static String getUserUUID(final OCApiConnector connector, final String userName) {
        final Parameters params = new Parameters("fields", USER_UUID, USER_USERNAME, userName);

        final JSONResult result = request(connector, OkapiService.SERVICE_USER_BY_USERNAME, params);
        if (!result.isSuccess) {
            final OkapiError error = new OkapiError(result.data);
            Log.e("OkapiClient.getUserUUID: error getting user info: '" + error.getMessage() + "'");
            return null;
        }

        JSONObject data = result.data;
        if (!data.isNull(USER_UUID)) {
            try {
                return data.getString(USER_UUID);
            } catch (final JSONException e) {
                Log.e("OkapiClient.getUserUUID - uuid", e);
            }
        }

        return null;
    }

    public static UserInfo getUserInfo(final OCApiLiveConnector connector) {
        final Parameters params = new Parameters("fields", USER_INFO_FIELDS);

        final JSONResult result = request(connector, OkapiService.SERVICE_USER, params);

        if (!result.isSuccess) {
            final OkapiError error = new OkapiError(result.data);
            Log.e("OkapiClient.getUserInfo: error getting user info: '" + error.getMessage() + "'");
            return new UserInfo(StringUtils.EMPTY, 0, UserInfoStatus.getFromOkapiError(error.getResult()));
        }

        JSONObject data = result.data;

        String name = StringUtils.EMPTY;
        boolean successUserName = false;

        if (!data.isNull(USER_USERNAME)) {
            try {
                name = data.getString(USER_USERNAME);
                successUserName = true;
            } catch (final JSONException e) {
                Log.e("OkapiClient.getUserInfo - name", e);
            }
        }

        int finds = 0;
        boolean successFinds = false;

        if (!data.isNull(USER_CACHES_FOUND)) {
            try {
                finds = data.getInt(USER_CACHES_FOUND);
                successFinds = true;
            } catch (final JSONException e) {
                Log.e("OkapiClient.getUserInfo - finds", e);
            }
        }

        return new UserInfo(name, finds, successUserName && successFinds ? UserInfoStatus.SUCCESSFUL : UserInfoStatus.FAILED);
    }

    /**
     * Encapsulates response state and content of an HTTP-request that expects a JSON result. <code>isSuccess</code> is
     * only true, if the response state was success and <code>data</code> is not null.
     */
    private static class JSONResult {

        public final boolean isSuccess;
        public final JSONObject data;

        public JSONResult(final @Nullable HttpResponse response) {
            boolean isSuccess = Network.isSuccess(response);
            final String responseData = Network.getResponseDataAlways(response);
            JSONObject data = null;
            if (responseData != null) {
                try {
                    data = new JSONObject(responseData);
                } catch (final JSONException e) {
                    Log.w("JSONResult", e);
                }
            }
            this.data = data;
            this.isSuccess = isSuccess && data != null;
        }
    }
}
!@#$%
20190527_003039,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_a04528
package cgeo.geocaching.connector.oc;

import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.DataStore;
import cgeo.geocaching.Geocache;
import cgeo.geocaching.Image;
import cgeo.geocaching.LogEntry;
import cgeo.geocaching.R;
import cgeo.geocaching.Waypoint;
import cgeo.geocaching.connector.ConnectorFactory;
import cgeo.geocaching.connector.IConnector;
import cgeo.geocaching.connector.LogResult;
import cgeo.geocaching.connector.gc.GCConnector;
import cgeo.geocaching.connector.oc.OCApiConnector.ApiSupport;
import cgeo.geocaching.connector.oc.OCApiConnector.OAuthLevel;
import cgeo.geocaching.connector.oc.UserInfo.UserInfoStatus;
import cgeo.geocaching.enumerations.CacheAttribute;
import cgeo.geocaching.enumerations.CacheSize;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.LoadFlags.SaveFlag;
import cgeo.geocaching.enumerations.LogType;
import cgeo.geocaching.enumerations.StatusCode;
import cgeo.geocaching.enumerations.WaypointType;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.geopoint.GeopointFormatter;
import cgeo.geocaching.geopoint.Viewport;
import cgeo.geocaching.network.Network;
import cgeo.geocaching.network.OAuth;
import cgeo.geocaching.network.Parameters;
import cgeo.geocaching.settings.Settings;
import cgeo.geocaching.utils.Log;
import cgeo.geocaching.utils.SynchronizedDateFormat;

import ch.boye.httpclientandroidlib.HttpResponse;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.time.FastDateFormat;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import android.net.Uri;

import java.text.ParseException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Date;
import java.util.EnumSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.TimeZone;

final class OkapiClient {

    private static final char SEPARATOR = '|';
    private static final String SEPARATOR_STRING = Character.toString(SEPARATOR);
    private static final FastDateFormat LOG_DATE_FORMAT = FastDateFormat.getInstance("yyyy-MM-dd HH:mm:ss.SSSZ", TimeZone.getTimeZone("UTC"), Locale.US);
    private static final SynchronizedDateFormat ISO8601DATEFORMAT = new SynchronizedDateFormat("yyyy-MM-dd'T'HH:mm:ssZ", Locale.getDefault());

    private static final String CACHE_ATTRNAMES = "attrnames";
    private static final String CACHE_ATTR_ACODES = "attr_acodes";
    private static final String WPT_LOCATION = "location";
    private static final String WPT_DESCRIPTION = "description";
    private static final String WPT_TYPE = "type";
    private static final String WPT_NAME = "name";
    private static final String CACHE_IS_WATCHED = "is_watched";
    private static final String CACHE_WPTS = "alt_wpts";
    private static final String CACHE_STATUS_ARCHIVED = "Archived";
    private static final String CACHE_STATUS_DISABLED = "Temporarily unavailable";
    private static final String CACHE_IS_FOUND = "is_found";
    private static final String CACHE_SIZE = "size";
    private static final String CACHE_VOTES = "rating_votes";
    private static final String CACHE_NOTFOUNDS = "notfounds";
    private static final String CACHE_FOUNDS = "founds";
    private static final String CACHE_HIDDEN = "date_hidden";
    private static final String CACHE_LATEST_LOGS = "latest_logs";
    private static final String CACHE_IMAGE_URL = "url";
    private static final String CACHE_IMAGE_CAPTION = "caption";
    private static final String CACHE_IMAGES = "images";
    private static final String CACHE_HINT = "hint";
    private static final String CACHE_DESCRIPTION = "description";
    private static final String CACHE_RECOMMENDATIONS = "recommendations";
    private static final String CACHE_RATING = "rating";
    private static final String CACHE_TERRAIN = "terrain";
    private static final String CACHE_DIFFICULTY = "difficulty";
    private static final String CACHE_OWNER = "owner";
    private static final String CACHE_STATUS = "status";
    private static final String CACHE_TYPE = "type";
    private static final String CACHE_LOCATION = "location";
    private static final String CACHE_NAME = "name";
    private static final String CACHE_CODE = "code";
    private static final String CACHE_REQ_PASSWORD = "req_passwd";
    private static final String CACHE_MY_NOTES = "my_notes";

    private static final String LOG_TYPE = "type";
    private static final String LOG_COMMENT = "comment";
    private static final String LOG_DATE = "date";
    private static final String LOG_USER = "user";

    private static final String USER_UUID = "uuid";
    private static final String USER_USERNAME = "username";
    private static final String USER_CACHES_FOUND = "caches_found";
    private static final String USER_INFO_FIELDS = "username|caches_found";

    // the several realms of possible fields for cache retrieval:
    // Core: for livemap requests (L3 - only with level 3 auth)
    // Additional: additional fields for full cache (L3 - only for level 3 auth, current - only for connectors with current api)
    private static final String SERVICE_CACHE_CORE_FIELDS = "code|name|location|type|status|difficulty|terrain|size|date_hidden";
    private static final String SERVICE_CACHE_CORE_L3_FIELDS = "is_found";
    private static final String SERVICE_CACHE_ADDITIONAL_FIELDS = "owner|founds|notfounds|rating|rating_votes|recommendations|description|hint|images|latest_logs|alt_wpts|attrnames|req_passwd";
    private static final String SERVICE_CACHE_ADDITIONAL_CURRENT_FIELDS = "gc_code|attribution_note|attr_acodes";
    private static final String SERVICE_CACHE_ADDITIONAL_L3_FIELDS = "is_watched|my_notes";

    private static final String METHOD_SEARCH_ALL = "services/caches/search/all";
    private static final String METHOD_SEARCH_BBOX = "services/caches/search/bbox";
    private static final String METHOD_SEARCH_NEAREST = "services/caches/search/nearest";
    private static final String METHOD_RETRIEVE_CACHES = "services/caches/geocaches";

    public static Geocache getCache(final String geoCode) {
        final Parameters params = new Parameters("cache_code", geoCode);
        final IConnector connector = ConnectorFactory.getConnector(geoCode);
        if (!(connector instanceof OCApiConnector)) {
            return null;
        }

        final OCApiConnector ocapiConn = (OCApiConnector) connector;

        params.add("fields", getFullFields(ocapiConn));
        params.add("attribution_append", "none");

        final JSONResult result = request(ocapiConn, OkapiService.SERVICE_CACHE, params);

        return result.isSuccess ? parseCache(result.data) : null;
    }

    public static List<Geocache> getCachesAround(final Geopoint center, final OCApiConnector connector) {
        final String centerString = GeopointFormatter.format(GeopointFormatter.Format.LAT_DECDEGREE_RAW, center) + SEPARATOR + GeopointFormatter.format(GeopointFormatter.Format.LON_DECDEGREE_RAW, center);
        final Parameters params = new Parameters("search_method", METHOD_SEARCH_NEAREST);
        final Map<String, String> valueMap = new LinkedHashMap<String, String>();
        valueMap.put("center", centerString);
        valueMap.put("limit", "20");
        valueMap.put("radius", "200");

        return requestCaches(connector, params, valueMap);
    }

    public static List<Geocache> getCachesByOwner(final String username, final OCApiConnector connector) {
        final Parameters params = new Parameters("search_method", METHOD_SEARCH_ALL);
        final Map<String, String> valueMap = new LinkedHashMap<String, String>();
        final String uuid = getUserUUID(connector, username);
        valueMap.put("owner_uuid", uuid);

        return requestCaches(connector, params, valueMap);
    }

    public static List<Geocache> getCachesByFinder(final String username, final OCApiConnector connector) {
        final Parameters params = new Parameters("search_method", METHOD_SEARCH_ALL);
        final Map<String, String> valueMap = new LinkedHashMap<String, String>();
        final String uuid = getUserUUID(connector, username);
        valueMap.put("found_by", uuid);

        return requestCaches(connector, params, valueMap);
    }

    public static List<Geocache> getCachesNamed(final Geopoint center, final String namePart, final OCApiConnector connector) {
        final Map<String, String> valueMap = new LinkedHashMap<String, String>();
        final Parameters params;

        // search around current position, if there is a position
        if (center != null) {
            final String centerString = GeopointFormatter.format(GeopointFormatter.Format.LAT_DECDEGREE_RAW, center) + SEPARATOR + GeopointFormatter.format(GeopointFormatter.Format.LON_DECDEGREE_RAW, center);
            params = new Parameters("search_method", METHOD_SEARCH_NEAREST);
            valueMap.put("center", centerString);
            valueMap.put("limit", "20");
        }
        else {
            params = new Parameters("search_method", METHOD_SEARCH_ALL);
            valueMap.put("limit", "20");
        }

        // full wildcard search, maybe we need to change this after some testing and evaluation
        valueMap.put("name", "*" + namePart + "*");
        return requestCaches(connector, params, valueMap);
    }

    private static List<Geocache> requestCaches(final OCApiConnector connector, final Parameters params, final Map<String, String> valueMap) {
        // if a global type filter is set, and OKAPI does not know that type, then return an empty list instead of all caches
        if (Settings.getCacheType() != CacheType.ALL && StringUtils.isBlank(getFilterFromType())) {
            return Collections.emptyList();
        }

        addFilterParams(valueMap, connector);
        params.add("search_params", new JSONObject(valueMap).toString());
        addRetrieveParams(params, connector);

        final JSONObject data = request(connector, OkapiService.SERVICE_SEARCH_AND_RETRIEVE, params).data;

        if (data == null) {
            return Collections.emptyList();
        }

        return parseCaches(data);
    }

    /**
     * Assumes level 3 OAuth.
     */
    public static List<Geocache> getCachesBBox(final Viewport viewport, final OCApiConnector connector) {

        if (viewport.getLatitudeSpan() == 0 || viewport.getLongitudeSpan() == 0) {
            return Collections.emptyList();
        }

        final String bboxString = GeopointFormatter.format(GeopointFormatter.Format.LAT_DECDEGREE_RAW, viewport.bottomLeft)
                + SEPARATOR + GeopointFormatter.format(GeopointFormatter.Format.LON_DECDEGREE_RAW, viewport.bottomLeft)
                + SEPARATOR + GeopointFormatter.format(GeopointFormatter.Format.LAT_DECDEGREE_RAW, viewport.topRight)
                + SEPARATOR + GeopointFormatter.format(GeopointFormatter.Format.LON_DECDEGREE_RAW, viewport.topRight);
        final Parameters params = new Parameters("search_method", METHOD_SEARCH_BBOX);
        final Map<String, String> valueMap = new LinkedHashMap<String, String>();
        valueMap.put("bbox", bboxString);

        return requestCaches(connector, params, valueMap);
    }

    public static boolean setWatchState(final Geocache cache, final boolean watched, final OCApiConnector connector) {
        final Parameters params = new Parameters("cache_code", cache.getGeocode());
        params.add("watched", watched ? "true" : "false");

        final JSONObject data = request(connector, OkapiService.SERVICE_MARK_CACHE, params).data;

        if (data == null) {
            return false;
        }

        cache.setOnWatchlist(watched);

        return true;
    }

    public static LogResult postLog(final Geocache cache, final LogType logType, final Calendar date, final String log, final String logPassword, final OCApiConnector connector) {
        final Parameters params = new Parameters("cache_code", cache.getGeocode());
        params.add("logtype", logType.oc_type);
        params.add("comment", log);
        params.add("comment_format", "plaintext");
        params.add("when", LOG_DATE_FORMAT.format(date.getTime()));
        if (logType.equals(LogType.NEEDS_MAINTENANCE)) {
            params.add("needs_maintenance", "true");
        }
        if (logPassword != null) {
            params.add("password", logPassword);
        }

        final JSONObject data = request(connector, OkapiService.SERVICE_SUBMIT_LOG, params).data;

        if (data == null) {
            return new LogResult(StatusCode.LOG_POST_ERROR, "");
        }

        try {
            if (data.getBoolean("success")) {
                return new LogResult(StatusCode.NO_ERROR, data.getString("log_uuid"));
            }

            return new LogResult(StatusCode.LOG_POST_ERROR, "");
        } catch (final JSONException e) {
            Log.e("OkapiClient.postLog", e);
        }
        return new LogResult(StatusCode.LOG_POST_ERROR, "");
    }

    private static List<Geocache> parseCaches(final JSONObject response) {
        try {
            // Check for empty result
            final String result = response.getString("results");
            if (StringUtils.isBlank(result) || StringUtils.equals(result, "[]")) {
                return Collections.emptyList();
            }

            // Get and iterate result list
            final JSONObject cachesResponse = response.getJSONObject("results");
            if (cachesResponse != null) {
                final List<Geocache> caches = new ArrayList<Geocache>(cachesResponse.length());
                @SuppressWarnings("unchecked")
                final
                Iterator<String> keys = cachesResponse.keys();
                while (keys.hasNext()) {
                    final String key = keys.next();
                    final Geocache cache = parseSmallCache(cachesResponse.getJSONObject(key));
                    caches.add(cache);
                }
                return caches;
            }
        } catch (final JSONException e) {
            Log.e("OkapiClient.parseCachesResult", e);
        }
        return Collections.emptyList();
    }

    private static Geocache parseSmallCache(final JSONObject response) {
        final Geocache cache = new Geocache();
        cache.setReliableLatLon(true);
        try {

            parseCoreCache(response, cache);

            DataStore.saveCache(cache, EnumSet.of(SaveFlag.SAVE_CACHE));
        } catch (final JSONException e) {
            Log.e("OkapiClient.parseSmallCache", e);
        }
        return cache;
    }

    private static Geocache parseCache(final JSONObject response) {
        final Geocache cache = new Geocache();
        cache.setReliableLatLon(true);
        try {

            parseCoreCache(response, cache);

            // not used: url
            final JSONObject owner = response.getJSONObject(CACHE_OWNER);
            cache.setOwnerDisplayName(parseUser(owner));

            cache.getLogCounts().put(LogType.FOUND_IT, response.getInt(CACHE_FOUNDS));
            cache.getLogCounts().put(LogType.DIDNT_FIND_IT, response.getInt(CACHE_NOTFOUNDS));

            if (!response.isNull(CACHE_RATING)) {
                cache.setRating((float) response.getDouble(CACHE_RATING));
            }
            cache.setVotes(response.getInt(CACHE_VOTES));

            cache.setFavoritePoints(response.getInt(CACHE_RECOMMENDATIONS));
            // not used: req_password
            // Prepend gc-link to description if available
            final StringBuilder description = new StringBuilder(500);
            if (!response.isNull("gc_code")) {
                final String gccode = response.getString("gc_code");
                description.append(CgeoApplication.getInstance().getResources()
                        .getString(R.string.cache_listed_on, GCConnector.getInstance().getName()))
                        .append(": <a href=\"http://coord.info/")
                        .append(gccode)
                        .append("\">")
                        .append(gccode)
                        .append("</a><br /><br />");
            }
            description.append(response.getString(CACHE_DESCRIPTION));
            cache.setDescription(description.toString());

            // currently the hint is delivered as HTML (contrary to OKAPI documentation), so we can store it directly
            cache.setHint(response.getString(CACHE_HINT));
            // not used: hints

            final JSONArray images = response.getJSONArray(CACHE_IMAGES);
            if (images != null) {
                for (int i = 0; i < images.length(); i++) {
                    final JSONObject imageResponse = images.getJSONObject(i);
                    final String title = imageResponse.getString(CACHE_IMAGE_CAPTION);
                    final String url = absoluteUrl(imageResponse.getString(CACHE_IMAGE_URL), cache.getGeocode());
                    // all images are added as spoiler images, although OKAPI has spoiler and non spoiler images
                    cache.addSpoiler(new Image(url, title));
                }
            }

            cache.setAttributes(parseAttributes(response.getJSONArray(CACHE_ATTRNAMES), response.optJSONArray(CACHE_ATTR_ACODES)));
            cache.setLogs(parseLogs(response.getJSONArray(CACHE_LATEST_LOGS)));
            //TODO: Store license per cache
            //cache.setLicense(response.getString("attribution_note"));
            cache.setWaypoints(parseWaypoints(response.getJSONArray(CACHE_WPTS)), false);
            if (!response.isNull(CACHE_IS_WATCHED)) {
                cache.setOnWatchlist(response.getBoolean(CACHE_IS_WATCHED));
            }
            if (!response.isNull(CACHE_MY_NOTES)) {
                cache.setPersonalNote(response.getString(CACHE_MY_NOTES));
            }
            cache.setLogPasswordRequired(response.getBoolean(CACHE_REQ_PASSWORD));

            cache.setDetailedUpdatedNow();
            // save full detailed caches
            DataStore.saveCache(cache, EnumSet.of(SaveFlag.SAVE_DB));
        } catch (final JSONException e) {
            Log.e("OkapiClient.parseCache", e);
        }
        return cache;
    }

    private static void parseCoreCache(final JSONObject response, final Geocache cache) throws JSONException {
        cache.setGeocode(response.getString(CACHE_CODE));
        cache.setName(response.getString(CACHE_NAME));
        // not used: names
        setLocation(cache, response.getString(CACHE_LOCATION));
        cache.setType(getCacheType(response.getString(CACHE_TYPE)));

        final String status = response.getString(CACHE_STATUS);
        cache.setDisabled(status.equalsIgnoreCase(CACHE_STATUS_DISABLED));
        cache.setArchived(status.equalsIgnoreCase(CACHE_STATUS_ARCHIVED));

        cache.setSize(getCacheSize(response));
        cache.setDifficulty((float) response.getDouble(CACHE_DIFFICULTY));
        cache.setTerrain((float) response.getDouble(CACHE_TERRAIN));

        if (!response.isNull(CACHE_IS_FOUND)) {
            cache.setFound(response.getBoolean(CACHE_IS_FOUND));
        }
        cache.setHidden(parseDate(response.getString(CACHE_HIDDEN)));
    }

    private static String absoluteUrl(final String url, final String geocode) {
        final Uri uri = Uri.parse(url);

        if (!uri.isAbsolute()) {
            final IConnector connector = ConnectorFactory.getConnector(geocode);
            final String host = connector.getHost();
            if (StringUtils.isNotBlank(host)) {
                return "http://" + host + "/" + url;
            }
        }
        return url;
    }

    private static String parseUser(final JSONObject user) throws JSONException {
        return user.getString(USER_USERNAME);
    }

    private static List<LogEntry> parseLogs(final JSONArray logsJSON) {
        List<LogEntry> result = null;
        for (int i = 0; i < logsJSON.length(); i++) {
            try {
                final JSONObject logResponse = logsJSON.getJSONObject(i);
                final LogEntry log = new LogEntry(
                        parseUser(logResponse.getJSONObject(LOG_USER)),
                        parseDate(logResponse.getString(LOG_DATE)).getTime(),
                        parseLogType(logResponse.getString(LOG_TYPE)),
                        logResponse.getString(LOG_COMMENT).trim());
                if (result == null) {
                    result = new ArrayList<LogEntry>();
                }
                result.add(log);
            } catch (final JSONException e) {
                Log.e("OkapiClient.parseLogs", e);
            }
        }
        return result;
    }

    private static List<Waypoint> parseWaypoints(final JSONArray wptsJson) {
        List<Waypoint> result = null;
        for (int i = 0; i < wptsJson.length(); i++) {
            try {
                final JSONObject wptResponse = wptsJson.getJSONObject(i);
                final Waypoint wpt = new Waypoint(wptResponse.getString(WPT_NAME),
                        parseWptType(wptResponse.getString(WPT_TYPE)),
                        false);
                wpt.setNote(wptResponse.getString(WPT_DESCRIPTION));
                final Geopoint pt = parseCoords(wptResponse.getString(WPT_LOCATION));
                if (pt != null) {
                    wpt.setCoords(pt);
                }
                if (result == null) {
                    result = new ArrayList<Waypoint>();
                }
                wpt.setPrefix(wpt.getName());
                result.add(wpt);
            } catch (final JSONException e) {
                Log.e("OkapiClient.parseWaypoints", e);
            }
        }
        return result;
    }

    private static LogType parseLogType(final String logType) {
        if ("Found it".equalsIgnoreCase(logType)) {
            return LogType.FOUND_IT;
        }
        if ("Didn't find it".equalsIgnoreCase(logType)) {
            return LogType.DIDNT_FIND_IT;
        }
        return LogType.NOTE;
    }

    private static WaypointType parseWptType(final String wptType) {
        if ("parking".equalsIgnoreCase(wptType)) {
            return WaypointType.PARKING;
        }
        if ("path".equalsIgnoreCase(wptType)) {
            return WaypointType.TRAILHEAD;
        }
        if ("stage".equalsIgnoreCase(wptType)) {
            return WaypointType.STAGE;
        }
        if ("physical-stage".equalsIgnoreCase(wptType)) {
            return WaypointType.STAGE;
        }
        if ("virtual-stage".equalsIgnoreCase(wptType)) {
            return WaypointType.PUZZLE;
        }
        if ("final".equalsIgnoreCase(wptType)) {
            return WaypointType.FINAL;
        }
        if ("poi".equalsIgnoreCase(wptType)) {
            return WaypointType.TRAILHEAD;
        }
        return WaypointType.WAYPOINT;
    }

    private static Date parseDate(final String date) {
        final String strippedDate = date.replaceAll("\\+0([0-9]){1}\\:00", "+0$100");
        try {
            return ISO8601DATEFORMAT.parse(strippedDate);
        } catch (final ParseException e) {
            Log.e("OkapiClient.parseDate", e);
        }
        return null;
    }

    private static Geopoint parseCoords(final String location) {
        final String latitude = StringUtils.substringBefore(location, SEPARATOR_STRING);
        final String longitude = StringUtils.substringAfter(location, SEPARATOR_STRING);
        if (StringUtils.isNotBlank(latitude) && StringUtils.isNotBlank(longitude)) {
            return new Geopoint(latitude, longitude);
        }

        return null;
    }

    private static List<String> parseAttributes(final JSONArray nameList, final JSONArray acodeList) {

        final List<String> result = new ArrayList<String>();

        for (int i = 0; i < nameList.length(); i++) {
            try {
                final String name = nameList.getString(i);
                final int acode = acodeList != null ? Integer.parseInt(acodeList.getString(i).substring(1)) : CacheAttribute.NO_ID;
                final CacheAttribute attr = CacheAttribute.getByOcACode(acode);

                if (attr != null) {
                    result.add(attr.rawName);
                } else {
                    result.add(name);
                }
            } catch (final JSONException e) {
                Log.e("OkapiClient.parseAttributes", e);
            }
        }

        return result;
    }

    private static void setLocation(final Geocache cache, final String location) {
        final String latitude = StringUtils.substringBefore(location, SEPARATOR_STRING);
        final String longitude = StringUtils.substringAfter(location, SEPARATOR_STRING);
        cache.setCoords(new Geopoint(latitude, longitude));
    }

    private static CacheSize getCacheSize(final JSONObject response) {
        if (response.isNull(CACHE_SIZE)) {
            return CacheSize.NOT_CHOSEN;
        }
        double size = 0;
        try {
            size = response.getDouble(CACHE_SIZE);
        } catch (final JSONException e) {
            Log.e("OkapiClient.getCacheSize", e);
        }
        switch ((int) Math.round(size)) {
            case 1:
                return CacheSize.MICRO;
            case 2:
                return CacheSize.SMALL;
            case 3:
                return CacheSize.REGULAR;
            case 4:
                return CacheSize.LARGE;
            case 5:
                return CacheSize.LARGE;
            default:
                break;
        }
        return CacheSize.NOT_CHOSEN;
    }

    private static CacheType getCacheType(final String cacheType) {
        if (cacheType.equalsIgnoreCase("Traditional")) {
            return CacheType.TRADITIONAL;
        }
        if (cacheType.equalsIgnoreCase("Multi")) {
            return CacheType.MULTI;
        }
        if (cacheType.equalsIgnoreCase("Quiz")) {
            return CacheType.MYSTERY;
        }
        if (cacheType.equalsIgnoreCase("Virtual")) {
            return CacheType.VIRTUAL;
        }
        if (cacheType.equalsIgnoreCase("Event")) {
            return CacheType.EVENT;
        }
        if (cacheType.equalsIgnoreCase("Webcam")) {
            return CacheType.WEBCAM;
        }
        if (cacheType.equalsIgnoreCase("Math/Physics")) {
            return CacheType.MYSTERY;
        }
        if (cacheType.equalsIgnoreCase("Drive-In")) {
            return CacheType.TRADITIONAL;
        }
        return CacheType.UNKNOWN;
    }

    private static String getCoreFields(final OCApiConnector connector) {
        if (connector == null) {
            Log.e("OkapiClient.getCoreFields called with invalid connector");
            return StringUtils.EMPTY;
        }

        if (connector.getSupportedAuthLevel() == OAuthLevel.Level3) {
            return SERVICE_CACHE_CORE_FIELDS + SEPARATOR + SERVICE_CACHE_CORE_L3_FIELDS;
        }

        return SERVICE_CACHE_CORE_FIELDS;
    }

    private static String getFullFields(final OCApiConnector connector) {
        if (connector == null) {
            Log.e("OkapiClient.getFullFields called with invalid connector");
            return StringUtils.EMPTY;
        }

        final StringBuilder res = new StringBuilder(500);

        res.append(SERVICE_CACHE_CORE_FIELDS);
        res.append(SEPARATOR).append(SERVICE_CACHE_ADDITIONAL_FIELDS);
        if (connector.getSupportedAuthLevel() == OAuthLevel.Level3) {
            res.append(SEPARATOR).append(SERVICE_CACHE_CORE_L3_FIELDS);
            res.append(SEPARATOR).append(SERVICE_CACHE_ADDITIONAL_L3_FIELDS);
        }
        if (connector.getApiSupport() == ApiSupport.current) {
            res.append(SEPARATOR).append(SERVICE_CACHE_ADDITIONAL_CURRENT_FIELDS);
        }

        return res.toString();
    }

    @NonNull
    private static JSONResult request(final OCApiConnector connector, final OkapiService service, final Parameters params) {
        if (connector == null) {
            return new JSONResult(null);
        }

        final String host = connector.getHost();
        if (StringUtils.isBlank(host)) {
            return new JSONResult(null);
        }

        params.add("langpref", getPreferredLanguage());

        if (connector.getSupportedAuthLevel() == OAuthLevel.Level3) {
            ImmutablePair<String, String> tokens = Settings.getTokenPair(connector.getTokenPublicPrefKeyId(), connector.getTokenSecretPrefKeyId());
            OAuth.signOAuth(host, service.methodName, "GET", false, params, tokens.left, tokens.right, connector.getCK(), connector.getCS());
        } else {
            connector.addAuthentication(params);
        }

        final String uri = "http://" + host + service.methodName;
        return new JSONResult(Network.getRequest(uri, params));
    }

    private static String getPreferredLanguage() {
        final String code = Locale.getDefault().getCountry();
        if (StringUtils.isNotBlank(code)) {
            return StringUtils.lowerCase(code) + "|en";
        }
        return "en";
    }

    private static void addFilterParams(final Map<String, String> valueMap, final OCApiConnector connector) {
        if (!Settings.isExcludeDisabledCaches()) {
            valueMap.put("status", "Available|Temporarily unavailable");
        }
        if (Settings.isExcludeMyCaches() && connector.getSupportedAuthLevel() == OAuthLevel.Level3) {
            valueMap.put("exclude_my_own", "true");
            valueMap.put("found_status", "notfound_only");
        }
        if (Settings.getCacheType() != CacheType.ALL) {
            valueMap.put("type", getFilterFromType());
        }
    }

    private static void addRetrieveParams(final Parameters params, final OCApiConnector connector) {
        params.add("retr_method", METHOD_RETRIEVE_CACHES);
        params.add("retr_params", "{\"fields\": \"" + getCoreFields(connector) + "\"}");
        params.add("wrap", "true");
    }

    private static String getFilterFromType() {
        switch (Settings.getCacheType()) {
            case EVENT:
                return "Event";
            case MULTI:
                return "Multi";
            case MYSTERY:
                return "Quiz";
            case TRADITIONAL:
                return "Traditional";
            case VIRTUAL:
                return "Virtual";
            case WEBCAM:
                return "Webcam";
            default:
                return "";
        }
    }

    public static String getUserUUID(final OCApiConnector connector, final String userName) {
        final Parameters params = new Parameters("fields", USER_UUID, USER_USERNAME, userName);

        final JSONResult result = request(connector, OkapiService.SERVICE_USER_BY_USERNAME, params);
        if (!result.isSuccess) {
            final OkapiError error = new OkapiError(result.data);
            Log.e("OkapiClient.getUserUUID: error getting user info: '" + error.getMessage() + "'");
            return null;
        }

        JSONObject data = result.data;
        if (!data.isNull(USER_UUID)) {
            try {
                return data.getString(USER_UUID);
            } catch (final JSONException e) {
                Log.e("OkapiClient.getUserUUID - uuid", e);
            }
        }

        return null;
    }

    public static UserInfo getUserInfo(final OCApiLiveConnector connector) {
        final Parameters params = new Parameters("fields", USER_INFO_FIELDS);

        final JSONResult result = request(connector, OkapiService.SERVICE_USER, params);

        if (!result.isSuccess) {
            final OkapiError error = new OkapiError(result.data);
            Log.e("OkapiClient.getUserInfo: error getting user info: '" + error.getMessage() + "'");
            return new UserInfo(StringUtils.EMPTY, 0, UserInfoStatus.getFromOkapiError(error.getResult()));
        }

        JSONObject data = result.data;

        String name = StringUtils.EMPTY;
        boolean successUserName = false;

        if (!data.isNull(USER_USERNAME)) {
            try {
                name = data.getString(USER_USERNAME);
                successUserName = true;
            } catch (final JSONException e) {
                Log.e("OkapiClient.getUserInfo - name", e);
            }
        }

        int finds = 0;
        boolean successFinds = false;

        if (!data.isNull(USER_CACHES_FOUND)) {
            try {
                finds = data.getInt(USER_CACHES_FOUND);
                successFinds = true;
            } catch (final JSONException e) {
                Log.e("OkapiClient.getUserInfo - finds", e);
            }
        }

        return new UserInfo(name, finds, successUserName && successFinds ? UserInfoStatus.SUCCESSFUL : UserInfoStatus.FAILED);
    }

    /**
     * Encapsulates response state and content of an HTTP-request that expects a JSON result. <code>isSuccess</code> is
     * only true, if the response state was success and <code>data</code> is not null.
     */
    private static class JSONResult {

        public final boolean isSuccess;
        public final JSONObject data;

        public JSONResult(final @Nullable HttpResponse response) {
            boolean isSuccess = Network.isSuccess(response);
            final String responseData = Network.getResponseDataAlways(response);
            JSONObject data = null;
            if (responseData != null) {
                try {
                    data = new JSONObject(responseData);
                } catch (final JSONException e) {
                    Log.w("JSONResult", e);
                }
            }
            this.data = data;
            this.isSuccess = isSuccess && data != null;
        }
    }
}
!@#$%
20190527_003039,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_c04528
package cgeo.geocaching.connector.oc;

import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.DataStore;
import cgeo.geocaching.Geocache;
import cgeo.geocaching.Image;
import cgeo.geocaching.LogEntry;
import cgeo.geocaching.R;
import cgeo.geocaching.Waypoint;
import cgeo.geocaching.connector.ConnectorFactory;
import cgeo.geocaching.connector.IConnector;
import cgeo.geocaching.connector.LogResult;
import cgeo.geocaching.connector.gc.GCConnector;
import cgeo.geocaching.connector.oc.OCApiConnector.ApiSupport;
import cgeo.geocaching.connector.oc.OCApiConnector.OAuthLevel;
import cgeo.geocaching.connector.oc.UserInfo.UserInfoStatus;
import cgeo.geocaching.enumerations.CacheAttribute;
import cgeo.geocaching.enumerations.CacheSize;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.LoadFlags.SaveFlag;
import cgeo.geocaching.enumerations.LogType;
import cgeo.geocaching.enumerations.StatusCode;
import cgeo.geocaching.enumerations.WaypointType;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.geopoint.GeopointFormatter;
import cgeo.geocaching.geopoint.Viewport;
import cgeo.geocaching.network.Network;
import cgeo.geocaching.network.OAuth;
import cgeo.geocaching.network.Parameters;
import cgeo.geocaching.settings.Settings;
import cgeo.geocaching.utils.Log;
import cgeo.geocaching.utils.SynchronizedDateFormat;

import ch.boye.httpclientandroidlib.HttpResponse;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.time.FastDateFormat;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import android.net.Uri;

import java.text.ParseException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Date;
import java.util.EnumSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.TimeZone;

final class OkapiClient {

    private static final char SEPARATOR = '|';
    private static final String SEPARATOR_STRING = Character.toString(SEPARATOR);
    private static final FastDateFormat LOG_DATE_FORMAT = FastDateFormat.getInstance("yyyy-MM-dd HH:mm:ss.SSSZ", TimeZone.getTimeZone("UTC"), Locale.US);
    private static final SynchronizedDateFormat ISO8601DATEFORMAT = new SynchronizedDateFormat("yyyy-MM-dd'T'HH:mm:ssZ", Locale.getDefault());

    private static final String CACHE_ATTRNAMES = "attrnames";
    private static final String CACHE_ATTR_ACODES = "attr_acodes";
    private static final String WPT_LOCATION = "location";
    private static final String WPT_DESCRIPTION = "description";
    private static final String WPT_TYPE = "type";
    private static final String WPT_NAME = "name";
    private static final String CACHE_IS_WATCHED = "is_watched";
    private static final String CACHE_WPTS = "alt_wpts";
    private static final String CACHE_STATUS_ARCHIVED = "Archived";
    private static final String CACHE_STATUS_DISABLED = "Temporarily unavailable";
    private static final String CACHE_IS_FOUND = "is_found";
    private static final String CACHE_SIZE = "size";
    private static final String CACHE_VOTES = "rating_votes";
    private static final String CACHE_NOTFOUNDS = "notfounds";
    private static final String CACHE_FOUNDS = "founds";
    private static final String CACHE_HIDDEN = "date_hidden";
    private static final String CACHE_LATEST_LOGS = "latest_logs";
    private static final String CACHE_IMAGE_URL = "url";
    private static final String CACHE_IMAGE_CAPTION = "caption";
    private static final String CACHE_IMAGES = "images";
    private static final String CACHE_HINT = "hint";
    private static final String CACHE_DESCRIPTION = "description";
    private static final String CACHE_RECOMMENDATIONS = "recommendations";
    private static final String CACHE_RATING = "rating";
    private static final String CACHE_TERRAIN = "terrain";
    private static final String CACHE_DIFFICULTY = "difficulty";
    private static final String CACHE_OWNER = "owner";
    private static final String CACHE_STATUS = "status";
    private static final String CACHE_TYPE = "type";
    private static final String CACHE_LOCATION = "location";
    private static final String CACHE_NAME = "name";
    private static final String CACHE_CODE = "code";
    private static final String CACHE_REQ_PASSWORD = "req_passwd";
    private static final String CACHE_MY_NOTES = "my_notes";

    private static final String LOG_TYPE = "type";
    private static final String LOG_COMMENT = "comment";
    private static final String LOG_DATE = "date";
    private static final String LOG_USER = "user";

    private static final String USER_UUID = "uuid";
    private static final String USER_USERNAME = "username";
    private static final String USER_CACHES_FOUND = "caches_found";
    private static final String USER_INFO_FIELDS = "username|caches_found";

    // the several realms of possible fields for cache retrieval:
    // Core: for livemap requests (L3 - only with level 3 auth)
    // Additional: additional fields for full cache (L3 - only for level 3 auth, current - only for connectors with current api)
    private static final String SERVICE_CACHE_CORE_FIELDS = "code|name|location|type|status|difficulty|terrain|size|date_hidden";
    private static final String SERVICE_CACHE_CORE_L3_FIELDS = "is_found";
    private static final String SERVICE_CACHE_ADDITIONAL_FIELDS = "owner|founds|notfounds|rating|rating_votes|recommendations|description|hint|images|latest_logs|alt_wpts|attrnames|req_passwd";
    private static final String SERVICE_CACHE_ADDITIONAL_CURRENT_FIELDS = "gc_code|attribution_note|attr_acodes";
    private static final String SERVICE_CACHE_ADDITIONAL_L3_FIELDS = "is_watched|my_notes";

    private static final String METHOD_SEARCH_ALL = "services/caches/search/all";
    private static final String METHOD_SEARCH_BBOX = "services/caches/search/bbox";
    private static final String METHOD_SEARCH_NEAREST = "services/caches/search/nearest";
    private static final String METHOD_RETRIEVE_CACHES = "services/caches/geocaches";

    public static Geocache getCache(final String geoCode) {
        final Parameters params = new Parameters("cache_code", geoCode);
        final IConnector connector = ConnectorFactory.getConnector(geoCode);
        if (!(connector instanceof OCApiConnector)) {
            return null;
        }

        final OCApiConnector ocapiConn = (OCApiConnector) connector;

        params.add("fields", getFullFields(ocapiConn));
        params.add("attribution_append", "none");

        final JSONResult result = request(ocapiConn, OkapiService.SERVICE_CACHE, params);

        return result.isSuccess ? parseCache(result.data) : null;
    }

    public static List<Geocache> getCachesAround(final Geopoint center, final OCApiConnector connector) {
        final String centerString = GeopointFormatter.format(GeopointFormatter.Format.LAT_DECDEGREE_RAW, center) + SEPARATOR + GeopointFormatter.format(GeopointFormatter.Format.LON_DECDEGREE_RAW, center);
        final Parameters params = new Parameters("search_method", METHOD_SEARCH_NEAREST);
        final Map<String, String> valueMap = new LinkedHashMap<String, String>();
        valueMap.put("center", centerString);
        valueMap.put("limit", "20");
        valueMap.put("radius", "200");

        return requestCaches(connector, params, valueMap);
    }

    public static List<Geocache> getCachesByOwner(final String username, final OCApiConnector connector) {
        final Parameters params = new Parameters("search_method", METHOD_SEARCH_ALL);
        final Map<String, String> valueMap = new LinkedHashMap<String, String>();
        final @Nullable
        String uuid = getUserUUID(connector, username);
        if (StringUtils.isEmpty(uuid)) {
            return Collections.emptyList();
        }
        valueMap.put("owner_uuid", uuid);

        return requestCaches(connector, params, valueMap);
    }

    public static List<Geocache> getCachesByFinder(final String username, final OCApiConnector connector) {
        final Parameters params = new Parameters("search_method", METHOD_SEARCH_ALL);
        final Map<String, String> valueMap = new LinkedHashMap<String, String>();
        final @Nullable
        String uuid = getUserUUID(connector, username);
        if (StringUtils.isEmpty(uuid)) {
            return Collections.emptyList();
        }
        valueMap.put("found_by", uuid);

        return requestCaches(connector, params, valueMap);
    }

    public static List<Geocache> getCachesNamed(final Geopoint center, final String namePart, final OCApiConnector connector) {
        final Map<String, String> valueMap = new LinkedHashMap<String, String>();
        final Parameters params;

        // search around current position, if there is a position
        if (center != null) {
            final String centerString = GeopointFormatter.format(GeopointFormatter.Format.LAT_DECDEGREE_RAW, center) + SEPARATOR + GeopointFormatter.format(GeopointFormatter.Format.LON_DECDEGREE_RAW, center);
            params = new Parameters("search_method", METHOD_SEARCH_NEAREST);
            valueMap.put("center", centerString);
            valueMap.put("limit", "20");
        }
        else {
            params = new Parameters("search_method", METHOD_SEARCH_ALL);
            valueMap.put("limit", "20");
        }

        // full wildcard search, maybe we need to change this after some testing and evaluation
        valueMap.put("name", "*" + namePart + "*");
        return requestCaches(connector, params, valueMap);
    }

    private static List<Geocache> requestCaches(final OCApiConnector connector, final Parameters params, final Map<String, String> valueMap) {
        // if a global type filter is set, and OKAPI does not know that type, then return an empty list instead of all caches
        if (Settings.getCacheType() != CacheType.ALL && StringUtils.isBlank(getFilterFromType())) {
            return Collections.emptyList();
        }

        addFilterParams(valueMap, connector);
        params.add("search_params", new JSONObject(valueMap).toString());
        addRetrieveParams(params, connector);

        final JSONObject data = request(connector, OkapiService.SERVICE_SEARCH_AND_RETRIEVE, params).data;

        if (data == null) {
            return Collections.emptyList();
        }

        return parseCaches(data);
    }

    /**
     * Assumes level 3 OAuth.
     */
    public static List<Geocache> getCachesBBox(final Viewport viewport, final OCApiConnector connector) {

        if (viewport.getLatitudeSpan() == 0 || viewport.getLongitudeSpan() == 0) {
            return Collections.emptyList();
        }

        final String bboxString = GeopointFormatter.format(GeopointFormatter.Format.LAT_DECDEGREE_RAW, viewport.bottomLeft)
                + SEPARATOR + GeopointFormatter.format(GeopointFormatter.Format.LON_DECDEGREE_RAW, viewport.bottomLeft)
                + SEPARATOR + GeopointFormatter.format(GeopointFormatter.Format.LAT_DECDEGREE_RAW, viewport.topRight)
                + SEPARATOR + GeopointFormatter.format(GeopointFormatter.Format.LON_DECDEGREE_RAW, viewport.topRight);
        final Parameters params = new Parameters("search_method", METHOD_SEARCH_BBOX);
        final Map<String, String> valueMap = new LinkedHashMap<String, String>();
        valueMap.put("bbox", bboxString);

        return requestCaches(connector, params, valueMap);
    }

    public static boolean setWatchState(final Geocache cache, final boolean watched, final OCApiConnector connector) {
        final Parameters params = new Parameters("cache_code", cache.getGeocode());
        params.add("watched", watched ? "true" : "false");

        final JSONObject data = request(connector, OkapiService.SERVICE_MARK_CACHE, params).data;

        if (data == null) {
            return false;
        }

        cache.setOnWatchlist(watched);

        return true;
    }

    public static LogResult postLog(final Geocache cache, final LogType logType, final Calendar date, final String log, final String logPassword, final OCApiConnector connector) {
        final Parameters params = new Parameters("cache_code", cache.getGeocode());
        params.add("logtype", logType.oc_type);
        params.add("comment", log);
        params.add("comment_format", "plaintext");
        params.add("when", LOG_DATE_FORMAT.format(date.getTime()));
        if (logType.equals(LogType.NEEDS_MAINTENANCE)) {
            params.add("needs_maintenance", "true");
        }
        if (logPassword != null) {
            params.add("password", logPassword);
        }

        final JSONObject data = request(connector, OkapiService.SERVICE_SUBMIT_LOG, params).data;

        if (data == null) {
            return new LogResult(StatusCode.LOG_POST_ERROR, "");
        }

        try {
            if (data.getBoolean("success")) {
                return new LogResult(StatusCode.NO_ERROR, data.getString("log_uuid"));
            }

            return new LogResult(StatusCode.LOG_POST_ERROR, "");
        } catch (final JSONException e) {
            Log.e("OkapiClient.postLog", e);
        }
        return new LogResult(StatusCode.LOG_POST_ERROR, "");
    }

    private static List<Geocache> parseCaches(final JSONObject response) {
        try {
            // Check for empty result
            final String result = response.getString("results");
            if (StringUtils.isBlank(result) || StringUtils.equals(result, "[]")) {
                return Collections.emptyList();
            }

            // Get and iterate result list
            final JSONObject cachesResponse = response.getJSONObject("results");
            if (cachesResponse != null) {
                final List<Geocache> caches = new ArrayList<Geocache>(cachesResponse.length());
                @SuppressWarnings("unchecked")
                final
                Iterator<String> keys = cachesResponse.keys();
                while (keys.hasNext()) {
                    final String key = keys.next();
                    final Geocache cache = parseSmallCache(cachesResponse.getJSONObject(key));
                    caches.add(cache);
                }
                return caches;
            }
        } catch (final JSONException e) {
            Log.e("OkapiClient.parseCachesResult", e);
        }
        return Collections.emptyList();
    }

    private static Geocache parseSmallCache(final JSONObject response) {
        final Geocache cache = new Geocache();
        cache.setReliableLatLon(true);
        try {

            parseCoreCache(response, cache);

            DataStore.saveCache(cache, EnumSet.of(SaveFlag.SAVE_CACHE));
        } catch (final JSONException e) {
            Log.e("OkapiClient.parseSmallCache", e);
        }
        return cache;
    }

    private static Geocache parseCache(final JSONObject response) {
        final Geocache cache = new Geocache();
        cache.setReliableLatLon(true);
        try {

            parseCoreCache(response, cache);

            // not used: url
            final JSONObject owner = response.getJSONObject(CACHE_OWNER);
            cache.setOwnerDisplayName(parseUser(owner));

            cache.getLogCounts().put(LogType.FOUND_IT, response.getInt(CACHE_FOUNDS));
            cache.getLogCounts().put(LogType.DIDNT_FIND_IT, response.getInt(CACHE_NOTFOUNDS));

            if (!response.isNull(CACHE_RATING)) {
                cache.setRating((float) response.getDouble(CACHE_RATING));
            }
            cache.setVotes(response.getInt(CACHE_VOTES));

            cache.setFavoritePoints(response.getInt(CACHE_RECOMMENDATIONS));
            // not used: req_password
            // Prepend gc-link to description if available
            final StringBuilder description = new StringBuilder(500);
            if (!response.isNull("gc_code")) {
                final String gccode = response.getString("gc_code");
                description.append(CgeoApplication.getInstance().getResources()
                        .getString(R.string.cache_listed_on, GCConnector.getInstance().getName()))
                        .append(": <a href=\"http://coord.info/")
                        .append(gccode)
                        .append("\">")
                        .append(gccode)
                        .append("</a><br /><br />");
            }
            description.append(response.getString(CACHE_DESCRIPTION));
            cache.setDescription(description.toString());

            // currently the hint is delivered as HTML (contrary to OKAPI documentation), so we can store it directly
            cache.setHint(response.getString(CACHE_HINT));
            // not used: hints

            final JSONArray images = response.getJSONArray(CACHE_IMAGES);
            if (images != null) {
                for (int i = 0; i < images.length(); i++) {
                    final JSONObject imageResponse = images.getJSONObject(i);
                    final String title = imageResponse.getString(CACHE_IMAGE_CAPTION);
                    final String url = absoluteUrl(imageResponse.getString(CACHE_IMAGE_URL), cache.getGeocode());
                    // all images are added as spoiler images, although OKAPI has spoiler and non spoiler images
                    cache.addSpoiler(new Image(url, title));
                }
            }

            cache.setAttributes(parseAttributes(response.getJSONArray(CACHE_ATTRNAMES), response.optJSONArray(CACHE_ATTR_ACODES)));
            cache.setLogs(parseLogs(response.getJSONArray(CACHE_LATEST_LOGS)));
            //TODO: Store license per cache
            //cache.setLicense(response.getString("attribution_note"));
            cache.setWaypoints(parseWaypoints(response.getJSONArray(CACHE_WPTS)), false);
            if (!response.isNull(CACHE_IS_WATCHED)) {
                cache.setOnWatchlist(response.getBoolean(CACHE_IS_WATCHED));
            }
            if (!response.isNull(CACHE_MY_NOTES)) {
                cache.setPersonalNote(response.getString(CACHE_MY_NOTES));
            }
            cache.setLogPasswordRequired(response.getBoolean(CACHE_REQ_PASSWORD));

            cache.setDetailedUpdatedNow();
            // save full detailed caches
            DataStore.saveCache(cache, EnumSet.of(SaveFlag.SAVE_DB));
        } catch (final JSONException e) {
            Log.e("OkapiClient.parseCache", e);
        }
        return cache;
    }

    private static void parseCoreCache(final JSONObject response, final Geocache cache) throws JSONException {
        cache.setGeocode(response.getString(CACHE_CODE));
        cache.setName(response.getString(CACHE_NAME));
        // not used: names
        setLocation(cache, response.getString(CACHE_LOCATION));
        cache.setType(getCacheType(response.getString(CACHE_TYPE)));

        final String status = response.getString(CACHE_STATUS);
        cache.setDisabled(status.equalsIgnoreCase(CACHE_STATUS_DISABLED));
        cache.setArchived(status.equalsIgnoreCase(CACHE_STATUS_ARCHIVED));

        cache.setSize(getCacheSize(response));
        cache.setDifficulty((float) response.getDouble(CACHE_DIFFICULTY));
        cache.setTerrain((float) response.getDouble(CACHE_TERRAIN));

        if (!response.isNull(CACHE_IS_FOUND)) {
            cache.setFound(response.getBoolean(CACHE_IS_FOUND));
        }
        cache.setHidden(parseDate(response.getString(CACHE_HIDDEN)));
    }

    private static String absoluteUrl(final String url, final String geocode) {
        final Uri uri = Uri.parse(url);

        if (!uri.isAbsolute()) {
            final IConnector connector = ConnectorFactory.getConnector(geocode);
            final String host = connector.getHost();
            if (StringUtils.isNotBlank(host)) {
                return "http://" + host + "/" + url;
            }
        }
        return url;
    }

    private static String parseUser(final JSONObject user) throws JSONException {
        return user.getString(USER_USERNAME);
    }

    private static List<LogEntry> parseLogs(final JSONArray logsJSON) {
        List<LogEntry> result = null;
        for (int i = 0; i < logsJSON.length(); i++) {
            try {
                final JSONObject logResponse = logsJSON.getJSONObject(i);
                final LogEntry log = new LogEntry(
                        parseUser(logResponse.getJSONObject(LOG_USER)),
                        parseDate(logResponse.getString(LOG_DATE)).getTime(),
                        parseLogType(logResponse.getString(LOG_TYPE)),
                        logResponse.getString(LOG_COMMENT).trim());
                if (result == null) {
                    result = new ArrayList<LogEntry>();
                }
                result.add(log);
            } catch (final JSONException e) {
                Log.e("OkapiClient.parseLogs", e);
            }
        }
        return result;
    }

    private static List<Waypoint> parseWaypoints(final JSONArray wptsJson) {
        List<Waypoint> result = null;
        for (int i = 0; i < wptsJson.length(); i++) {
            try {
                final JSONObject wptResponse = wptsJson.getJSONObject(i);
                final Waypoint wpt = new Waypoint(wptResponse.getString(WPT_NAME),
                        parseWptType(wptResponse.getString(WPT_TYPE)),
                        false);
                wpt.setNote(wptResponse.getString(WPT_DESCRIPTION));
                final Geopoint pt = parseCoords(wptResponse.getString(WPT_LOCATION));
                if (pt != null) {
                    wpt.setCoords(pt);
                }
                if (result == null) {
                    result = new ArrayList<Waypoint>();
                }
                wpt.setPrefix(wpt.getName());
                result.add(wpt);
            } catch (final JSONException e) {
                Log.e("OkapiClient.parseWaypoints", e);
            }
        }
        return result;
    }

    private static LogType parseLogType(final String logType) {
        if ("Found it".equalsIgnoreCase(logType)) {
            return LogType.FOUND_IT;
        }
        if ("Didn't find it".equalsIgnoreCase(logType)) {
            return LogType.DIDNT_FIND_IT;
        }
        return LogType.NOTE;
    }

    private static WaypointType parseWptType(final String wptType) {
        if ("parking".equalsIgnoreCase(wptType)) {
            return WaypointType.PARKING;
        }
        if ("path".equalsIgnoreCase(wptType)) {
            return WaypointType.TRAILHEAD;
        }
        if ("stage".equalsIgnoreCase(wptType)) {
            return WaypointType.STAGE;
        }
        if ("physical-stage".equalsIgnoreCase(wptType)) {
            return WaypointType.STAGE;
        }
        if ("virtual-stage".equalsIgnoreCase(wptType)) {
            return WaypointType.PUZZLE;
        }
        if ("final".equalsIgnoreCase(wptType)) {
            return WaypointType.FINAL;
        }
        if ("poi".equalsIgnoreCase(wptType)) {
            return WaypointType.TRAILHEAD;
        }
        return WaypointType.WAYPOINT;
    }

    private static Date parseDate(final String date) {
        final String strippedDate = date.replaceAll("\\+0([0-9]){1}\\:00", "+0$100");
        try {
            return ISO8601DATEFORMAT.parse(strippedDate);
        } catch (final ParseException e) {
            Log.e("OkapiClient.parseDate", e);
        }
        return null;
    }

    private static Geopoint parseCoords(final String location) {
        final String latitude = StringUtils.substringBefore(location, SEPARATOR_STRING);
        final String longitude = StringUtils.substringAfter(location, SEPARATOR_STRING);
        if (StringUtils.isNotBlank(latitude) && StringUtils.isNotBlank(longitude)) {
            return new Geopoint(latitude, longitude);
        }

        return null;
    }

    private static List<String> parseAttributes(final JSONArray nameList, final JSONArray acodeList) {

        final List<String> result = new ArrayList<String>();

        for (int i = 0; i < nameList.length(); i++) {
            try {
                final String name = nameList.getString(i);
                final int acode = acodeList != null ? Integer.parseInt(acodeList.getString(i).substring(1)) : CacheAttribute.NO_ID;
                final CacheAttribute attr = CacheAttribute.getByOcACode(acode);

                if (attr != null) {
                    result.add(attr.rawName);
                } else {
                    result.add(name);
                }
            } catch (final JSONException e) {
                Log.e("OkapiClient.parseAttributes", e);
            }
        }

        return result;
    }

    private static void setLocation(final Geocache cache, final String location) {
        final String latitude = StringUtils.substringBefore(location, SEPARATOR_STRING);
        final String longitude = StringUtils.substringAfter(location, SEPARATOR_STRING);
        cache.setCoords(new Geopoint(latitude, longitude));
    }

    private static CacheSize getCacheSize(final JSONObject response) {
        if (response.isNull(CACHE_SIZE)) {
            return CacheSize.NOT_CHOSEN;
        }
        double size = 0;
        try {
            size = response.getDouble(CACHE_SIZE);
        } catch (final JSONException e) {
            Log.e("OkapiClient.getCacheSize", e);
        }
        switch ((int) Math.round(size)) {
            case 1:
                return CacheSize.MICRO;
            case 2:
                return CacheSize.SMALL;
            case 3:
                return CacheSize.REGULAR;
            case 4:
                return CacheSize.LARGE;
            case 5:
                return CacheSize.LARGE;
            default:
                break;
        }
        return CacheSize.NOT_CHOSEN;
    }

    private static CacheType getCacheType(final String cacheType) {
        if (cacheType.equalsIgnoreCase("Traditional")) {
            return CacheType.TRADITIONAL;
        }
        if (cacheType.equalsIgnoreCase("Multi")) {
            return CacheType.MULTI;
        }
        if (cacheType.equalsIgnoreCase("Quiz")) {
            return CacheType.MYSTERY;
        }
        if (cacheType.equalsIgnoreCase("Virtual")) {
            return CacheType.VIRTUAL;
        }
        if (cacheType.equalsIgnoreCase("Event")) {
            return CacheType.EVENT;
        }
        if (cacheType.equalsIgnoreCase("Webcam")) {
            return CacheType.WEBCAM;
        }
        if (cacheType.equalsIgnoreCase("Math/Physics")) {
            return CacheType.MYSTERY;
        }
        if (cacheType.equalsIgnoreCase("Drive-In")) {
            return CacheType.TRADITIONAL;
        }
        return CacheType.UNKNOWN;
    }

    private static String getCoreFields(final OCApiConnector connector) {
        if (connector == null) {
            Log.e("OkapiClient.getCoreFields called with invalid connector");
            return StringUtils.EMPTY;
        }

        if (connector.getSupportedAuthLevel() == OAuthLevel.Level3) {
            return SERVICE_CACHE_CORE_FIELDS + SEPARATOR + SERVICE_CACHE_CORE_L3_FIELDS;
        }

        return SERVICE_CACHE_CORE_FIELDS;
    }

    private static String getFullFields(final OCApiConnector connector) {
        if (connector == null) {
            Log.e("OkapiClient.getFullFields called with invalid connector");
            return StringUtils.EMPTY;
        }

        final StringBuilder res = new StringBuilder(500);

        res.append(SERVICE_CACHE_CORE_FIELDS);
        res.append(SEPARATOR).append(SERVICE_CACHE_ADDITIONAL_FIELDS);
        if (connector.getSupportedAuthLevel() == OAuthLevel.Level3) {
            res.append(SEPARATOR).append(SERVICE_CACHE_CORE_L3_FIELDS);
            res.append(SEPARATOR).append(SERVICE_CACHE_ADDITIONAL_L3_FIELDS);
        }
        if (connector.getApiSupport() == ApiSupport.current) {
            res.append(SEPARATOR).append(SERVICE_CACHE_ADDITIONAL_CURRENT_FIELDS);
        }

        return res.toString();
    }

    @NonNull
    private static JSONResult request(final OCApiConnector connector, final OkapiService service, final Parameters params) {
        if (connector == null) {
            return new JSONResult(null);
        }

        final String host = connector.getHost();
        if (StringUtils.isBlank(host)) {
            return new JSONResult(null);
        }

        params.add("langpref", getPreferredLanguage());

        if (connector.getSupportedAuthLevel() == OAuthLevel.Level3) {
            ImmutablePair<String, String> tokens = Settings.getTokenPair(connector.getTokenPublicPrefKeyId(), connector.getTokenSecretPrefKeyId());
            OAuth.signOAuth(host, service.methodName, "GET", false, params, tokens.left, tokens.right, connector.getCK(), connector.getCS());
        } else {
            connector.addAuthentication(params);
        }

        final String uri = "http://" + host + service.methodName;
        return new JSONResult(Network.getRequest(uri, params));
    }

    private static String getPreferredLanguage() {
        final String code = Locale.getDefault().getCountry();
        if (StringUtils.isNotBlank(code)) {
            return StringUtils.lowerCase(code) + "|en";
        }
        return "en";
    }

    private static void addFilterParams(final Map<String, String> valueMap, final OCApiConnector connector) {
        if (!Settings.isExcludeDisabledCaches()) {
            valueMap.put("status", "Available|Temporarily unavailable");
        }
        if (Settings.isExcludeMyCaches() && connector.getSupportedAuthLevel() == OAuthLevel.Level3) {
            valueMap.put("exclude_my_own", "true");
            valueMap.put("found_status", "notfound_only");
        }
        if (Settings.getCacheType() != CacheType.ALL) {
            valueMap.put("type", getFilterFromType());
        }
    }

    private static void addRetrieveParams(final Parameters params, final OCApiConnector connector) {
        params.add("retr_method", METHOD_RETRIEVE_CACHES);
        params.add("retr_params", "{\"fields\": \"" + getCoreFields(connector) + "\"}");
        params.add("wrap", "true");
    }

    private static String getFilterFromType() {
        switch (Settings.getCacheType()) {
            case EVENT:
                return "Event";
            case MULTI:
                return "Multi";
            case MYSTERY:
                return "Quiz";
            case TRADITIONAL:
                return "Traditional";
            case VIRTUAL:
                return "Virtual";
            case WEBCAM:
                return "Webcam";
            default:
                return "";
        }
    }

    public static @Nullable
    String getUserUUID(final OCApiConnector connector, final String userName) {
        final Parameters params = new Parameters("fields", USER_UUID, USER_USERNAME, userName);

        final JSONResult result = request(connector, OkapiService.SERVICE_USER_BY_USERNAME, params);
        if (!result.isSuccess) {
            final OkapiError error = new OkapiError(result.data);
            Log.e("OkapiClient.getUserUUID: error getting user info: '" + error.getMessage() + "'");
            return null;
        }

        JSONObject data = result.data;
        if (!data.isNull(USER_UUID)) {
            try {
                return data.getString(USER_UUID);
            } catch (final JSONException e) {
                Log.e("OkapiClient.getUserUUID - uuid", e);
            }
        }

        return null;
    }

    public static UserInfo getUserInfo(final OCApiLiveConnector connector) {
        final Parameters params = new Parameters("fields", USER_INFO_FIELDS);

        final JSONResult result = request(connector, OkapiService.SERVICE_USER, params);

        if (!result.isSuccess) {
            final OkapiError error = new OkapiError(result.data);
            Log.e("OkapiClient.getUserInfo: error getting user info: '" + error.getMessage() + "'");
            return new UserInfo(StringUtils.EMPTY, 0, UserInfoStatus.getFromOkapiError(error.getResult()));
        }

        JSONObject data = result.data;

        String name = StringUtils.EMPTY;
        boolean successUserName = false;

        if (!data.isNull(USER_USERNAME)) {
            try {
                name = data.getString(USER_USERNAME);
                successUserName = true;
            } catch (final JSONException e) {
                Log.e("OkapiClient.getUserInfo - name", e);
            }
        }

        int finds = 0;
        boolean successFinds = false;

        if (!data.isNull(USER_CACHES_FOUND)) {
            try {
                finds = data.getInt(USER_CACHES_FOUND);
                successFinds = true;
            } catch (final JSONException e) {
                Log.e("OkapiClient.getUserInfo - finds", e);
            }
        }

        return new UserInfo(name, finds, successUserName && successFinds ? UserInfoStatus.SUCCESSFUL : UserInfoStatus.FAILED);
    }

    /**
     * Encapsulates response state and content of an HTTP-request that expects a JSON result. <code>isSuccess</code> is
     * only true, if the response state was success and <code>data</code> is not null.
     */
    private static class JSONResult {

        public final boolean isSuccess;
        public final JSONObject data;

        public JSONResult(final @Nullable HttpResponse response) {
            boolean isSuccess = Network.isSuccess(response);
            final String responseData = Network.getResponseDataAlways(response);
            JSONObject data = null;
            if (responseData != null) {
                try {
                    data = new JSONObject(responseData);
                } catch (final JSONException e) {
                    Log.w("JSONResult", e);
                }
            }
            this.data = data;
            this.isSuccess = isSuccess && data != null;
        }
    }
}
!@#$%
20190527_003044,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_b03032
package cgeo.geocaching.activity;

import cgeo.geocaching.R;
import cgeo.geocaching.utils.Log;

import com.viewpagerindicator.TitlePageIndicator;
import com.viewpagerindicator.TitleProvider;
import org.apache.commons.lang3.tuple.Pair;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;

import android.app.Activity;
import android.os.Bundle;
import android.os.Parcelable;
import android.support.v4.view.PagerAdapter;
import android.support.v4.view.ViewPager;
import android.support.v4.view.ViewPager.OnPageChangeListener;
import android.view.View;
import android.view.ViewGroup;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Abstract activity with the ability to manage pages in a view pager.
 *
 * @param <Page>
 *            Enum listing all available pages of this activity. The pages available at a certain point of time are
 *            defined by overriding {@link #getOrderedPages()}.
 */
public abstract class AbstractViewPagerActivity<Page extends Enum<Page>> extends AbstractActivity {

    /**
     * A {@link List} of all available pages.
     *
     * TODO Move to adapter
     */
    private final List<Page> pageOrder = new ArrayList<Page>();

    /**
     * Instances of all {@link PageViewCreator}.
     */
    private final Map<Page, PageViewCreator> viewCreators = new HashMap<Page, PageViewCreator>();

    /**
     * Store the states of the page views to be able to persist them when destroyed and reinstantiated again
     */
    private final Map<Page, Bundle> viewStates = new HashMap<Page, Bundle>();
    /**
     * The {@link ViewPager} for this activity.
     */
    private ViewPager viewPager;

    /**
     * The {@link ViewPagerAdapter} for this activity.
     */
    private ViewPagerAdapter viewPagerAdapter;

    /**
     * The {@link TitlePageIndicator} for this activity.
     */
    private TitlePageIndicator titleIndicator;

    public interface PageViewCreator {
        /**
         * Returns a validated view.
         *
         * @return
         */
        public View getDispatchedView();

        /**
         * Returns a (maybe cached) view.
         *
         * @return
         */
        public View getView();

        /**
         * Handles changed data-sets.
         */
        public void notifyDataSetChanged();

        /**
         * Gets state of the view
         */
        public @Nullable
        Bundle getViewState();

        /**
         * Set the state of the view
         */
        public void setViewState(@NonNull Bundle state);
    }

    /**
     * Page selection interface for the view pager.
     *
     */
    protected interface OnPageSelectedListener {
        public void onPageSelected(int position);
    }

    /**
     * The ViewPagerAdapter for scrolling through pages of the CacheDetailActivity.
     */
    private class ViewPagerAdapter extends PagerAdapter implements TitleProvider {

        @Override
        public void destroyItem(ViewGroup container, int position, Object object) {

            final Page page = pageOrder.get(position);

            // Store the state of the view if the page supports it
            PageViewCreator creator = viewCreators.get(page);
            if (creator != null) {
                @Nullable
                Bundle state = creator.getViewState();
                if (state != null) {
                    viewStates.put(page, state);
                }
            }

            container.removeView((View) object);
        }

        @Override
        public void finishUpdate(ViewGroup container) {
        }

        @Override
        public int getCount() {
            return pageOrder.size();
        }

        @Override
        public Object instantiateItem(ViewGroup container, int position) {

            final Page page = pageOrder.get(position);

            PageViewCreator creator = viewCreators.get(page);

            if (null == creator && null != page) {
                creator = AbstractViewPagerActivity.this.createViewCreator(page);
                viewCreators.put(page, creator);
                viewStates.put(page, new Bundle());
            }

            View view = null;

            try {
                if (null != creator) {
                    // Result from getView() is maybe cached, but it should be valid because the
                    // creator should be informed about data-changes with notifyDataSetChanged()
                    view = creator.getView();

                    // Restore the state of the view if the page supports it
                    Bundle state = viewStates.get(page);
                    if (state != null) {
                        creator.setViewState(state);
                    }

                    container.addView(view, 0);
                }
            } catch (Exception e) {
                Log.e("ViewPagerAdapter.instantiateItem ", e);
            }
            return view;
        }

        @Override
        public boolean isViewFromObject(View view, Object object) {
            return view == object;
        }

        @Override
        public void restoreState(Parcelable arg0, ClassLoader arg1) {
        }

        @Override
        public Parcelable saveState() {
            return null;
        }

        @Override
        public void startUpdate(ViewGroup arg0) {
        }

        @Override
        public int getItemPosition(Object object) {
            // We are doing the caching. So pretend that the view is gone.
            // The ViewPager will get it back in instantiateItem()
            return POSITION_NONE;
        }

        @Override
        public String getTitle(int position) {
            final Page page = pageOrder.get(position);
            if (null == page) {
                return "";
            }
            return AbstractViewPagerActivity.this.getTitle(page);
        }

    }

    /**
     * Create the view pager. Call this from the {@link Activity#onCreate} implementation.
     *
     * @param startPageIndex
     *            index of the page shown first
     * @param pageSelectedListener
     *            page selection listener or <code>null</code>
     */
    protected final void createViewPager(int startPageIndex, final OnPageSelectedListener pageSelectedListener) {
        // initialize ViewPager
        viewPager = (ViewPager) findViewById(R.id.viewpager);
        viewPagerAdapter = new ViewPagerAdapter();
        viewPager.setAdapter(viewPagerAdapter);

        titleIndicator = (TitlePageIndicator) findViewById(R.id.pager_indicator);
        titleIndicator.setViewPager(viewPager);
        if (pageSelectedListener != null) {
            titleIndicator.setOnPageChangeListener(new OnPageChangeListener() {
                @Override
                public void onPageSelected(int position) {
                    pageSelectedListener.onPageSelected(position);
                }

                @Override
                public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
                }

                @Override
                public void onPageScrollStateChanged(int state) {
                }
            });
        }

        // switch to entry page (last used or 2)
        if (viewPagerAdapter.getCount() < startPageIndex) {
            for (int i = 0; i <= startPageIndex; i++) {
                // we can't switch to a page that is out of bounds, so we add null-pages
                pageOrder.add(null);
            }
        }
        viewPagerAdapter.notifyDataSetChanged();
        viewPager.setCurrentItem(startPageIndex, false);
    }

    /**
     * create the view creator for the given page
     *
     * @return new view creator
     */
    protected abstract PageViewCreator createViewCreator(Page page);

    /**
     * get the title for the given page
     */
    protected abstract String getTitle(Page page);

    protected final void reinitializeViewPager() {

        // notify all creators that the data has changed
        for (PageViewCreator creator : viewCreators.values()) {
            creator.notifyDataSetChanged();
        }
        // reset the stored view states of all pages
        for (Bundle state : viewStates.values()) {
            state.clear();
        }

        pageOrder.clear();
        final Pair<List<? extends Page>, Integer> pagesAndIndex = getOrderedPages();
        pageOrder.addAll(pagesAndIndex.getLeft());

        // Since we just added pages notifyDataSetChanged needs to be called before we possibly setCurrentItem below.
        //  But, calling it will reset current item and we won't be able to tell if we would have been out of bounds
        final int currentItem = getCurrentItem();

        // notify the adapter that the data has changed
        viewPagerAdapter.notifyDataSetChanged();

        // switch to details page, if we're out of bounds
        final int defaultPage = pagesAndIndex.getRight();
        if (currentItem < 0 || currentItem >= viewPagerAdapter.getCount()) {
            viewPager.setCurrentItem(defaultPage, false);
        }

        // notify the indicator that the data has changed
        titleIndicator.notifyDataSetChanged();
    }

    /**
     * @return the currently available list of ordered pages, together with the index of the default page
     */
    protected abstract Pair<List<? extends Page>, Integer> getOrderedPages();

    public final Page getPage(int position) {
        return pageOrder.get(position);
    }

    protected final int getPageIndex(Page page) {
        return pageOrder.indexOf(page);
    }

    protected final PageViewCreator getViewCreator(Page page) {
        return viewCreators.get(page);
    }

    protected final boolean isCurrentPage(Page page) {
        return getCurrentItem() == getPageIndex(page);
    }

    protected int getCurrentItem() {
        return viewPager.getCurrentItem();
    }
}
!@#$%
20190527_003044,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_a03032
package cgeo.geocaching.activity;

import cgeo.geocaching.R;
import cgeo.geocaching.utils.Log;

import com.viewpagerindicator.TitlePageIndicator;
import com.viewpagerindicator.TitleProvider;

import org.apache.commons.lang3.tuple.Pair;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;

import android.app.Activity;
import android.os.Bundle;
import android.os.Parcelable;
import android.support.v4.view.PagerAdapter;
import android.support.v4.view.ViewPager;
import android.support.v4.view.ViewPager.OnPageChangeListener;
import android.view.View;
import android.view.ViewGroup;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Abstract activity with the ability to manage pages in a view pager.
 *
 * @param <Page>
 *            Enum listing all available pages of this activity. The pages available at a certain point of time are
 *            defined by overriding {@link #getOrderedPages()}.
 */
public abstract class AbstractViewPagerActivity<Page extends Enum<Page>> extends AbstractActivity {

    /**
     * A {@link List} of all available pages.
     *
     * TODO Move to adapter
     */
    private final List<Page> pageOrder = new ArrayList<Page>();

    /**
     * Instances of all {@link PageViewCreator}.
     */
    private final Map<Page, PageViewCreator> viewCreators = new HashMap<Page, PageViewCreator>();

    /**
     * Store the states of the page views to be able to persist them when destroyed and reinstantiated again
     */
    private final Map<Page, Bundle> viewStates = new HashMap<Page, Bundle>();
    /**
     * The {@link ViewPager} for this activity.
     */
    private ViewPager viewPager;

    /**
     * The {@link ViewPagerAdapter} for this activity.
     */
    private ViewPagerAdapter viewPagerAdapter;

    /**
     * The {@link TitlePageIndicator} for this activity.
     */
    private TitlePageIndicator titleIndicator;

    public interface PageViewCreator {
        /**
         * Returns a validated view.
         *
         * @return
         */
        public View getDispatchedView();

        /**
         * Returns a (maybe cached) view.
         *
         * @return
         */
        public View getView();

        /**
         * Handles changed data-sets.
         */
        public void notifyDataSetChanged();

        /**
         * Gets state of the view
         */
        public @Nullable
        Bundle getViewState();

        /**
         * Set the state of the view
         */
        public void setViewState(@NonNull Bundle state);
    }

    /**
     * Page selection interface for the view pager.
     *
     */
    protected interface OnPageSelectedListener {
        public void onPageSelected(int position);
    }

    /**
     * The ViewPagerAdapter for scrolling through pages of the CacheDetailActivity.
     */
    private class ViewPagerAdapter extends PagerAdapter implements TitleProvider {

        @Override
        public void destroyItem(ViewGroup container, int position, Object object) {

            final Page page = pageOrder.get(position);

            // Store the state of the view if the page supports it
            PageViewCreator creator = viewCreators.get(page);
            if (creator != null) {
                @Nullable
                Bundle state = creator.getViewState();
                if (state != null) {
                    viewStates.put(page, state);
                }
            }

            container.removeView((View) object);
        }

        @Override
        public void finishUpdate(ViewGroup container) {
        }

        @Override
        public int getCount() {
            return pageOrder.size();
        }

        @Override
        public Object instantiateItem(ViewGroup container, int position) {

            final Page page = pageOrder.get(position);

            PageViewCreator creator = viewCreators.get(page);

            if (null == creator && null != page) {
                creator = AbstractViewPagerActivity.this.createViewCreator(page);
                viewCreators.put(page, creator);
                viewStates.put(page, new Bundle());
            }

            View view = null;

            try {
                if (null != creator) {
                    // Result from getView() is maybe cached, but it should be valid because the
                    // creator should be informed about data-changes with notifyDataSetChanged()
                    view = creator.getView();

                    // Restore the state of the view if the page supports it
                    Bundle state = viewStates.get(page);
                    if (state != null) {
                        creator.setViewState(state);
                    }

                    container.addView(view, 0);
                }
            } catch (Exception e) {
                Log.e("ViewPagerAdapter.instantiateItem ", e);
            }
            return view;
        }

        @Override
        public boolean isViewFromObject(View view, Object object) {
            return view == object;
        }

        @Override
        public void restoreState(Parcelable arg0, ClassLoader arg1) {
        }

        @Override
        public Parcelable saveState() {
            return null;
        }

        @Override
        public void startUpdate(ViewGroup arg0) {
        }

        @Override
        public int getItemPosition(Object object) {
            // We are doing the caching. So pretend that the view is gone.
            // The ViewPager will get it back in instantiateItem()
            return POSITION_NONE;
        }

        @Override
        public String getTitle(int position) {
            final Page page = pageOrder.get(position);
            if (null == page) {
                return "";
            }
            return AbstractViewPagerActivity.this.getTitle(page);
        }

    }

    /**
     * Create the view pager. Call this from the {@link Activity#onCreate} implementation.
     *
     * @param startPageIndex
     *            index of the page shown first
     * @param pageSelectedListener
     *            page selection listener or <code>null</code>
     */
    protected final void createViewPager(int startPageIndex, final OnPageSelectedListener pageSelectedListener) {
        // initialize ViewPager
        viewPager = (ViewPager) findViewById(R.id.viewpager);
        viewPagerAdapter = new ViewPagerAdapter();
        viewPager.setAdapter(viewPagerAdapter);

        titleIndicator = (TitlePageIndicator) findViewById(R.id.pager_indicator);
        titleIndicator.setViewPager(viewPager);
        if (pageSelectedListener != null) {
            titleIndicator.setOnPageChangeListener(new OnPageChangeListener() {
                @Override
                public void onPageSelected(int position) {
                    pageSelectedListener.onPageSelected(position);
                }

                @Override
                public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
                }

                @Override
                public void onPageScrollStateChanged(int state) {
                }
            });
        }

        // switch to entry page (last used or 2)
        if (viewPagerAdapter.getCount() < startPageIndex) {
            for (int i = 0; i <= startPageIndex; i++) {
                // we can't switch to a page that is out of bounds, so we add null-pages
                pageOrder.add(null);
            }
        }
        viewPagerAdapter.notifyDataSetChanged();
        viewPager.setCurrentItem(startPageIndex, false);
    }

    /**
     * create the view creator for the given page
     *
     * @return new view creator
     */
    protected abstract PageViewCreator createViewCreator(Page page);

    /**
     * get the title for the given page
     */
    protected abstract String getTitle(Page page);

    protected final void reinitializeViewPager() {

        // notify all creators that the data has changed
        for (PageViewCreator creator : viewCreators.values()) {
            creator.notifyDataSetChanged();
        }
        // reset the stored view states of all pages
        for (Bundle state : viewStates.values()) {
            state.clear();
        }

        pageOrder.clear();
        final Pair<List<? extends Page>, Integer> pagesAndIndex = getOrderedPages();
        pageOrder.addAll(pagesAndIndex.getLeft());

        // Since we just added pages notifyDataSetChanged needs to be called before we possibly setCurrentItem below.
        //  But, calling it will reset current item and we won't be able to tell if we would have been out of bounds
        final int currentItem = getCurrentItem();

        // notify the adapter that the data has changed
        viewPagerAdapter.notifyDataSetChanged();

        // switch to details page, if we're out of bounds
        final int defaultPage = pagesAndIndex.getRight();
        if (currentItem < 0 || currentItem >= viewPagerAdapter.getCount()) {
            viewPager.setCurrentItem(defaultPage, false);
        }

        // notify the indicator that the data has changed
        titleIndicator.notifyDataSetChanged();
    }

    /**
     * @return the currently available list of ordered pages, together with the index of the default page
     */
    protected abstract Pair<List<? extends Page>, Integer> getOrderedPages();

    public final Page getPage(int position) {
        return pageOrder.get(position);
    }

    protected final int getPageIndex(Page page) {
        return pageOrder.indexOf(page);
    }

    protected final PageViewCreator getViewCreator(Page page) {
        return viewCreators.get(page);
    }

    protected final boolean isCurrentPage(Page page) {
        return getCurrentItem() == getPageIndex(page);
    }

    protected int getCurrentItem() {
        return viewPager.getCurrentItem();
    }
}
!@#$%
20190527_003044,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_c03032
package cgeo.geocaching.activity;

import cgeo.geocaching.R;
import cgeo.geocaching.utils.Log;

import com.viewpagerindicator.TitlePageIndicator;
import com.viewpagerindicator.TitleProvider;

import org.apache.commons.lang3.tuple.Pair;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;

import android.app.Activity;
import android.os.Bundle;
import android.os.Parcelable;
import android.support.v4.view.PagerAdapter;
import android.support.v4.view.ViewPager;
import android.support.v4.view.ViewPager.OnPageChangeListener;
import android.view.View;
import android.view.ViewGroup;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Abstract activity with the ability to manage pages in a view pager.
 *
 * @param <Page>
 *            Enum listing all available pages of this activity. The pages available at a certain point of time are
 *            defined by overriding {@link #getOrderedPages()}.
 */
public abstract class AbstractViewPagerActivity<Page extends Enum<Page>> extends AbstractActivity {

    /**
     * A {@link List} of all available pages.
     *
     * TODO Move to adapter
     */
    private final List<Page> pageOrder = new ArrayList<Page>();

    /**
     * Instances of all {@link PageViewCreator}.
     */
    private final Map<Page, PageViewCreator> viewCreators = new HashMap<Page, PageViewCreator>();

    /**
     * Store the states of the page views to be able to persist them when destroyed and reinstantiated again
     */
    private final Map<Page, Bundle> viewStates = new HashMap<Page, Bundle>();
    /**
     * The {@link ViewPager} for this activity.
     */
    private ViewPager viewPager;

    /**
     * The {@link ViewPagerAdapter} for this activity.
     */
    private ViewPagerAdapter viewPagerAdapter;

    /**
     * The {@link TitlePageIndicator} for this activity.
     */
    private TitlePageIndicator titleIndicator;

    public interface PageViewCreator {
        /**
         * Returns a validated view.
         *
         * @return
         */
        public View getDispatchedView();

        /**
         * Returns a (maybe cached) view.
         *
         * @return
         */
        public View getView();

        /**
         * Handles changed data-sets.
         */
        public void notifyDataSetChanged();

        /**
         * Gets state of the view
         */
        public @Nullable
        Bundle getViewState();

        /**
         * Set the state of the view
         */
        public void setViewState(@NonNull Bundle state);
    }

    /**
     * Page selection interface for the view pager.
     *
     */
    protected interface OnPageSelectedListener {
        public void onPageSelected(int position);
    }

    /**
     * The ViewPagerAdapter for scrolling through pages of the CacheDetailActivity.
     */
    private class ViewPagerAdapter extends PagerAdapter implements TitleProvider {

        @Override
        public void destroyItem(ViewGroup container, int position, Object object) {
            if (position >= pageOrder.size()) {
                return;
            }
            final Page page = pageOrder.get(position);

            // Store the state of the view if the page supports it
            PageViewCreator creator = viewCreators.get(page);
            if (creator != null) {
                @Nullable
                Bundle state = creator.getViewState();
                if (state != null) {
                    viewStates.put(page, state);
                }
            }

            container.removeView((View) object);
        }

        @Override
        public void finishUpdate(ViewGroup container) {
        }

        @Override
        public int getCount() {
            return pageOrder.size();
        }

        @Override
        public Object instantiateItem(ViewGroup container, int position) {

            final Page page = pageOrder.get(position);

            PageViewCreator creator = viewCreators.get(page);

            if (null == creator && null != page) {
                creator = AbstractViewPagerActivity.this.createViewCreator(page);
                viewCreators.put(page, creator);
                viewStates.put(page, new Bundle());
            }

            View view = null;

            try {
                if (null != creator) {
                    // Result from getView() is maybe cached, but it should be valid because the
                    // creator should be informed about data-changes with notifyDataSetChanged()
                    view = creator.getView();

                    // Restore the state of the view if the page supports it
                    Bundle state = viewStates.get(page);
                    if (state != null) {
                        creator.setViewState(state);
                    }

                    container.addView(view, 0);
                }
            } catch (Exception e) {
                Log.e("ViewPagerAdapter.instantiateItem ", e);
            }
            return view;
        }

        @Override
        public boolean isViewFromObject(View view, Object object) {
            return view == object;
        }

        @Override
        public void restoreState(Parcelable arg0, ClassLoader arg1) {
        }

        @Override
        public Parcelable saveState() {
            return null;
        }

        @Override
        public void startUpdate(ViewGroup arg0) {
        }

        @Override
        public int getItemPosition(Object object) {
            // We are doing the caching. So pretend that the view is gone.
            // The ViewPager will get it back in instantiateItem()
            return POSITION_NONE;
        }

        @Override
        public String getTitle(int position) {
            final Page page = pageOrder.get(position);
            if (null == page) {
                return "";
            }
            return AbstractViewPagerActivity.this.getTitle(page);
        }

    }

    /**
     * Create the view pager. Call this from the {@link Activity#onCreate} implementation.
     *
     * @param startPageIndex
     *            index of the page shown first
     * @param pageSelectedListener
     *            page selection listener or <code>null</code>
     */
    protected final void createViewPager(int startPageIndex, final OnPageSelectedListener pageSelectedListener) {
        // initialize ViewPager
        viewPager = (ViewPager) findViewById(R.id.viewpager);
        viewPagerAdapter = new ViewPagerAdapter();
        viewPager.setAdapter(viewPagerAdapter);

        titleIndicator = (TitlePageIndicator) findViewById(R.id.pager_indicator);
        titleIndicator.setViewPager(viewPager);
        if (pageSelectedListener != null) {
            titleIndicator.setOnPageChangeListener(new OnPageChangeListener() {
                @Override
                public void onPageSelected(int position) {
                    pageSelectedListener.onPageSelected(position);
                }

                @Override
                public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
                }

                @Override
                public void onPageScrollStateChanged(int state) {
                }
            });
        }

        // switch to entry page (last used or 2)
        if (viewPagerAdapter.getCount() < startPageIndex) {
            for (int i = 0; i <= startPageIndex; i++) {
                // we can't switch to a page that is out of bounds, so we add null-pages
                pageOrder.add(null);
            }
        }
        viewPagerAdapter.notifyDataSetChanged();
        viewPager.setCurrentItem(startPageIndex, false);
    }

    /**
     * create the view creator for the given page
     *
     * @return new view creator
     */
    protected abstract PageViewCreator createViewCreator(Page page);

    /**
     * get the title for the given page
     */
    protected abstract String getTitle(Page page);

    protected final void reinitializeViewPager() {

        // notify all creators that the data has changed
        for (PageViewCreator creator : viewCreators.values()) {
            creator.notifyDataSetChanged();
        }
        // reset the stored view states of all pages
        for (Bundle state : viewStates.values()) {
            state.clear();
        }

        pageOrder.clear();
        final Pair<List<? extends Page>, Integer> pagesAndIndex = getOrderedPages();
        pageOrder.addAll(pagesAndIndex.getLeft());

        // Since we just added pages notifyDataSetChanged needs to be called before we possibly setCurrentItem below.
        //  But, calling it will reset current item and we won't be able to tell if we would have been out of bounds
        final int currentItem = getCurrentItem();

        // notify the adapter that the data has changed
        viewPagerAdapter.notifyDataSetChanged();

        // switch to details page, if we're out of bounds
        final int defaultPage = pagesAndIndex.getRight();
        if (currentItem < 0 || currentItem >= viewPagerAdapter.getCount()) {
            viewPager.setCurrentItem(defaultPage, false);
        }

        // notify the indicator that the data has changed
        titleIndicator.notifyDataSetChanged();
    }

    /**
     * @return the currently available list of ordered pages, together with the index of the default page
     */
    protected abstract Pair<List<? extends Page>, Integer> getOrderedPages();

    public final Page getPage(int position) {
        return pageOrder.get(position);
    }

    protected final int getPageIndex(Page page) {
        return pageOrder.indexOf(page);
    }

    protected final PageViewCreator getViewCreator(Page page) {
        return viewCreators.get(page);
    }

    protected final boolean isCurrentPage(Page page) {
        return getCurrentItem() == getPageIndex(page);
    }

    protected int getCurrentItem() {
        return viewPager.getCurrentItem();
    }
}
!@#$%
20190527_003119,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_b09076
package cgeo.geocaching.twitter;

import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.DataStore;
import cgeo.geocaching.Geocache;
import cgeo.geocaching.LogEntry;
import cgeo.geocaching.Trackable;
import cgeo.geocaching.enumerations.LoadFlags;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.geopoint.GeopointFormatter.Format;
import cgeo.geocaching.network.Network;
import cgeo.geocaching.network.OAuth;
import cgeo.geocaching.network.Parameters;
import cgeo.geocaching.settings.Settings;
import cgeo.geocaching.utils.Log;
import cgeo.geocaching.utils.LogTemplateProvider;
import cgeo.geocaching.utils.LogTemplateProvider.LogContext;

import ch.boye.httpclientandroidlib.HttpResponse;
import org.apache.commons.lang3.StringUtils;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;

public final class Twitter {
    private static final String HASH_PREFIX_WITH_BLANK = " #";
    private static final int MAX_TWEET_SIZE = 140;

    public static void postTweetCache(String geocode, final @Nullable LogEntry logEntry) {
        final Geocache cache = DataStore.loadCache(geocode, LoadFlags.LOAD_CACHE_OR_DB);
        if (cache == null) {
            return;
        }
        postTweet(CgeoApplication.getInstance(), getStatusMessage(cache, logEntry), null);
    }

    public static void postTweetTrackable(String geocode, final @Nullable LogEntry logEntry) {
        final Trackable trackable = DataStore.loadTrackable(geocode);
        if (trackable == null) {
            return;
        }
        postTweet(CgeoApplication.getInstance(), getStatusMessage(trackable, logEntry), null);
    }

    private static void postTweet(final CgeoApplication app, final String statusIn, final Geopoint coords) {
        if (app == null || !Settings.isUseTwitter() || !Settings.isTwitterLoginValid()) {
            return;
        }

        try {
            final String status = shortenToMaxSize(statusIn);
            Parameters parameters = new Parameters("status", status);
            if (coords != null) {
                parameters.put(
                        "lat", coords.format(Format.LAT_DECDEGREE_RAW),
                        "long", coords.format(Format.LON_DECDEGREE_RAW),
                        "display_coordinates", "true");
            }

            OAuth.signOAuth("api.twitter.com", "/1.1/statuses/update.json", "POST", false, parameters, Settings.getTokenPublic(), Settings.getTokenSecret(), Settings.getKeyConsumerPublic(), Settings.getKeyConsumerSecret());
            final HttpResponse httpResponse = Network.postRequest("http://api.twitter.com/1.1/statuses/update.json", parameters);
            if (httpResponse != null) {
                if (httpResponse.getStatusLine().getStatusCode() == 200) {
                    Log.i("Tweet posted");
                } else {
                    Log.e("Tweet could not be posted. Reason: " + httpResponse.toString());
                }
            } else {
                Log.e("Tweet could not be posted. Reason: httpResponse Object is null");
            }
        } catch (Exception e) {
            Log.e("Twitter.postTweet", e);
        }
    }

    private static String shortenToMaxSize(final String status) {
        String result = StringUtils.trim(status);
        if (StringUtils.length(result) > MAX_TWEET_SIZE) {
            return StringUtils.substring(result, 0, MAX_TWEET_SIZE - 1) + '';
        }
        return result;
    }

    private static void appendHashTag(final StringBuilder status, final String tag) {
        if (status.length() + HASH_PREFIX_WITH_BLANK.length() + tag.length() <= MAX_TWEET_SIZE) {
            final String tagWithPrefix = HASH_PREFIX_WITH_BLANK + tag;
            if (!StringUtils.contains(status, tagWithPrefix)) {
                status.append(tagWithPrefix);
            }
        }
    }

    static String getStatusMessage(final @NonNull Geocache cache, final @Nullable LogEntry logEntry) {
        return appendHashTags(LogTemplateProvider.applyTemplates(Settings.getCacheTwitterMessage(), new LogContext(cache, logEntry)));
    }

    static String getStatusMessage(final @NonNull Trackable trackable, final @Nullable LogEntry logEntry) {
        return appendHashTags(LogTemplateProvider.applyTemplates(Settings.getTrackableTwitterMessage(), new LogContext(trackable, logEntry)));
    }

    private static String appendHashTags(final String status) {
        StringBuilder builder = new StringBuilder(status);
        appendHashTag(builder, "cgeo");
        appendHashTag(builder, "geocaching");
        return builder.toString();
    }
}
!@#$%
20190527_003119,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_a09076
package cgeo.geocaching.twitter;

import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.DataStore;
import cgeo.geocaching.Geocache;
import cgeo.geocaching.LogEntry;
import cgeo.geocaching.Trackable;
import cgeo.geocaching.enumerations.LoadFlags;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.geopoint.GeopointFormatter.Format;
import cgeo.geocaching.network.Network;
import cgeo.geocaching.network.OAuth;
import cgeo.geocaching.network.Parameters;
import cgeo.geocaching.settings.Settings;
import cgeo.geocaching.utils.Log;
import cgeo.geocaching.utils.LogTemplateProvider;
import cgeo.geocaching.utils.LogTemplateProvider.LogContext;

import ch.boye.httpclientandroidlib.HttpResponse;

import org.apache.commons.lang3.StringUtils;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;

public final class Twitter {
    private static final String HASH_PREFIX_WITH_BLANK = " #";
    private static final int MAX_TWEET_SIZE = 140;

    public static void postTweetCache(String geocode, final @Nullable LogEntry logEntry) {
        final Geocache cache = DataStore.loadCache(geocode, LoadFlags.LOAD_CACHE_OR_DB);
        if (cache == null) {
            return;
        }
        postTweet(CgeoApplication.getInstance(), getStatusMessage(cache, logEntry), null);
    }

    public static void postTweetTrackable(String geocode, final @Nullable LogEntry logEntry) {
        final Trackable trackable = DataStore.loadTrackable(geocode);
        if (trackable == null) {
            return;
        }
        postTweet(CgeoApplication.getInstance(), getStatusMessage(trackable, logEntry), null);
    }

    private static void postTweet(final CgeoApplication app, final String statusIn, final Geopoint coords) {
        if (app == null || !Settings.isUseTwitter() || !Settings.isTwitterLoginValid()) {
            return;
        }

        try {
            final String status = shortenToMaxSize(statusIn);
            Parameters parameters = new Parameters("status", status);
            if (coords != null) {
                parameters.put(
                        "lat", coords.format(Format.LAT_DECDEGREE_RAW),
                        "long", coords.format(Format.LON_DECDEGREE_RAW),
                        "display_coordinates", "true");
            }

            OAuth.signOAuth("api.twitter.com", "/1.1/statuses/update.json", "POST", false, parameters, Settings.getTokenPublic(), Settings.getTokenSecret(), Settings.getKeyConsumerPublic(), Settings.getKeyConsumerSecret());
            final HttpResponse httpResponse = Network.postRequest("http://api.twitter.com/1.1/statuses/update.json", parameters);
            if (httpResponse != null) {
                if (httpResponse.getStatusLine().getStatusCode() == 200) {
                    Log.i("Tweet posted");
                } else {
                    Log.e("Tweet could not be posted. Reason: " + httpResponse.toString());
                }
            } else {
                Log.e("Tweet could not be posted. Reason: httpResponse Object is null");
            }
        } catch (Exception e) {
            Log.e("Twitter.postTweet", e);
        }
    }

    private static String shortenToMaxSize(final String status) {
        String result = StringUtils.trim(status);
        if (StringUtils.length(result) > MAX_TWEET_SIZE) {
            return StringUtils.substring(result, 0, MAX_TWEET_SIZE - 1) + '';
        }
        return result;
    }

    private static void appendHashTag(final StringBuilder status, final String tag) {
        if (status.length() + HASH_PREFIX_WITH_BLANK.length() + tag.length() <= MAX_TWEET_SIZE) {
            final String tagWithPrefix = HASH_PREFIX_WITH_BLANK + tag;
            if (!StringUtils.contains(status, tagWithPrefix)) {
                status.append(tagWithPrefix);
            }
        }
    }

    static String getStatusMessage(final @NonNull Geocache cache, final @Nullable LogEntry logEntry) {
        return appendHashTags(LogTemplateProvider.applyTemplates(Settings.getCacheTwitterMessage(), new LogContext(cache, logEntry)));
    }

    static String getStatusMessage(final @NonNull Trackable trackable, final @Nullable LogEntry logEntry) {
        return appendHashTags(LogTemplateProvider.applyTemplates(Settings.getTrackableTwitterMessage(), new LogContext(trackable, logEntry)));
    }

    private static String appendHashTags(final String status) {
        StringBuilder builder = new StringBuilder(status);
        appendHashTag(builder, "cgeo");
        appendHashTag(builder, "geocaching");
        return builder.toString();
    }
}
!@#$%
20190527_003119,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_c09076
package cgeo.geocaching.twitter;

import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.DataStore;
import cgeo.geocaching.Geocache;
import cgeo.geocaching.LogEntry;
import cgeo.geocaching.Trackable;
import cgeo.geocaching.enumerations.LoadFlags;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.geopoint.GeopointFormatter.Format;
import cgeo.geocaching.network.Network;
import cgeo.geocaching.network.OAuth;
import cgeo.geocaching.network.Parameters;
import cgeo.geocaching.settings.Settings;
import cgeo.geocaching.utils.Log;
import cgeo.geocaching.utils.LogTemplateProvider;
import cgeo.geocaching.utils.LogTemplateProvider.LogContext;

import ch.boye.httpclientandroidlib.HttpResponse;

import org.apache.commons.lang3.StringUtils;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;

public final class Twitter {
    private static final String HASH_PREFIX_WITH_BLANK = " #";
    private static final int MAX_TWEET_SIZE = 140;

    public static void postTweetCache(String geocode, final @Nullable LogEntry logEntry) {
        final Geocache cache = DataStore.loadCache(geocode, LoadFlags.LOAD_CACHE_OR_DB);
        if (cache == null) {
            return;
        }
        postTweet(CgeoApplication.getInstance(), getStatusMessage(cache, logEntry), null);
    }

    public static void postTweetTrackable(String geocode, final @Nullable LogEntry logEntry) {
        final Trackable trackable = DataStore.loadTrackable(geocode);
        if (trackable == null) {
            return;
        }
        postTweet(CgeoApplication.getInstance(), getStatusMessage(trackable, logEntry), null);
    }

    private static void postTweet(final CgeoApplication app, final String statusIn, final Geopoint coords) {
        if (app == null || !Settings.isUseTwitter() || !Settings.isTwitterLoginValid()) {
            return;
        }

        try {
            final String status = shortenToMaxSize(statusIn);
            Parameters parameters = new Parameters("status", status);
            if (coords != null) {
                parameters.put(
                        "lat", coords.format(Format.LAT_DECDEGREE_RAW),
                        "long", coords.format(Format.LON_DECDEGREE_RAW),
                        "display_coordinates", "true");
            }

            OAuth.signOAuth("api.twitter.com", "/1.1/statuses/update.json", "POST", true, parameters, Settings.getTokenPublic(), Settings.getTokenSecret(), Settings.getKeyConsumerPublic(), Settings.getKeyConsumerSecret());
            final HttpResponse httpResponse = Network.postRequest("https://api.twitter.com/1.1/statuses/update.json", parameters);
            if (httpResponse != null) {
                if (httpResponse.getStatusLine().getStatusCode() == 200) {
                    Log.i("Tweet posted");
                } else {
                    Log.e("Tweet could not be posted. Reason: " + httpResponse.toString());
                }
            } else {
                Log.e("Tweet could not be posted. Reason: httpResponse Object is null");
            }
        } catch (Exception e) {
            Log.e("Twitter.postTweet", e);
        }
    }

    private static String shortenToMaxSize(final String status) {
        String result = StringUtils.trim(status);
        if (StringUtils.length(result) > MAX_TWEET_SIZE) {
            return StringUtils.substring(result, 0, MAX_TWEET_SIZE - 1) + '';
        }
        return result;
    }

    private static void appendHashTag(final StringBuilder status, final String tag) {
        if (status.length() + HASH_PREFIX_WITH_BLANK.length() + tag.length() <= MAX_TWEET_SIZE) {
            final String tagWithPrefix = HASH_PREFIX_WITH_BLANK + tag;
            if (!StringUtils.contains(status, tagWithPrefix)) {
                status.append(tagWithPrefix);
            }
        }
    }

    static String getStatusMessage(final @NonNull Geocache cache, final @Nullable LogEntry logEntry) {
        return appendHashTags(LogTemplateProvider.applyTemplates(Settings.getCacheTwitterMessage(), new LogContext(cache, logEntry)));
    }

    static String getStatusMessage(final @NonNull Trackable trackable, final @Nullable LogEntry logEntry) {
        return appendHashTags(LogTemplateProvider.applyTemplates(Settings.getTrackableTwitterMessage(), new LogContext(trackable, logEntry)));
    }

    private static String appendHashTags(final String status) {
        StringBuilder builder = new StringBuilder(status);
        appendHashTag(builder, "cgeo");
        appendHashTag(builder, "geocaching");
        return builder.toString();
    }
}
!@#$%
20190527_003501,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_b19108
package cgeo.geocaching.sensors;

import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.utils.AngleUtils;
import cgeo.geocaching.utils.StartableHandlerThread;

import rx.Observable;
import rx.Observable.OnSubscribe;
import rx.Subscriber;
import rx.subjects.BehaviorSubject;

import android.content.Context;
import android.hardware.Sensor;
import android.hardware.SensorEvent;
import android.hardware.SensorEventListener;
import android.hardware.SensorManager;
import android.os.Handler;
import android.os.Process;
import android.view.Surface;
import android.view.WindowManager;

public class DirectionProvider {

    private static final BehaviorSubject<Float> subject = BehaviorSubject.create(0.0f);

    private static final WindowManager windowManager = (WindowManager) CgeoApplication.getInstance().getSystemService(Context.WINDOW_SERVICE);

    static class Listener implements SensorEventListener, StartableHandlerThread.Callback {

        private int count = 0;

        private SensorManager sensorManager;
        @Override
        public void onSensorChanged(final SensorEvent event) {
            subject.onNext(event.values[0]);
        }

        @Override
        public void onAccuracyChanged(final Sensor sensor, final int accuracy) {
                /*
                * There is a bug in Android, which apparently causes this method to be called every
                * time the sensor _value_ changed, even if the _accuracy_ did not change. So logging
                * this event leads to the log being flooded with multiple entries _per second_,
                * which I experienced when running cgeo in a building (with GPS and network being
                * unreliable).
                *
                * See for example https://code.google.com/p/android/issues/detail?id=14792
                */

            //Log.i(Settings.tag, "Compass' accuracy is low (" + accuracy + ")");
        }

        // This will be removed when using a new location service. Until then, it is okay to be used.
        @SuppressWarnings("deprecation")
        @Override
        public void start(final Context context, final Handler handler) {
            if (++count == 1) {
                sensorManager = (SensorManager) context.getSystemService(Context.SENSOR_SERVICE);
                sensorManager.registerListener(this, sensorManager.getDefaultSensor(Sensor.TYPE_ORIENTATION), SensorManager.SENSOR_DELAY_NORMAL, handler);
            }
        }

        @Override
        public void stop() {
            if (--count == 0) {
                sensorManager.unregisterListener(this);
            }
        }

    }

    private static final StartableHandlerThread handlerThread =
            new StartableHandlerThread("DirectionProvider thread", Process.THREAD_PRIORITY_BACKGROUND, new Listener());

    static {
      handlerThread.start();
    }
    static public Observable<Float> create(final Context context) {
        return Observable.create(new OnSubscribe<Float>() {
            @Override
            public void call(final Subscriber<? super Float> subscriber) {
                handlerThread.start(subscriber, context);
                subject.subscribe(subscriber);
            }
        });
    }

    /**
     * Take the phone rotation (through a given activity) in account and adjust the direction.
     *
     * @param direction the unadjusted direction in degrees, in the [0, 360[ range
     * @return the adjusted direction in degrees, in the [0, 360[ range
     */

    public static float getDirectionNow(final float direction) {
        return AngleUtils.normalize(direction + getRotationOffset());
    }

    static float reverseDirectionNow(final float direction) {
        return AngleUtils.normalize(direction - getRotationOffset());
    }

    private static int getRotationOffset() {
        switch (windowManager.getDefaultDisplay().getRotation()) {
            case Surface.ROTATION_90:
                return 90;
            case Surface.ROTATION_180:
                return 180;
            case Surface.ROTATION_270:
                return 270;
            default:
                return 0;
        }
    }

}
!@#$%
20190527_003501,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_a19108
package cgeo.geocaching.sensors;

import android.os.Process;
import cgeo.geocaching.compatibility.Compatibility;

import cgeo.geocaching.utils.StartableHandlerThread;
import rx.Observable;
import rx.Observable.OnSubscribe;
import rx.Subscriber;
import rx.subjects.BehaviorSubject;

import android.app.Activity;
import android.content.Context;
import android.hardware.Sensor;
import android.hardware.SensorEvent;
import android.hardware.SensorEventListener;
import android.hardware.SensorManager;
import android.os.*;

public class DirectionProvider {

    private static final BehaviorSubject<Float> subject = BehaviorSubject.create(0.0f);

    static class Listener implements SensorEventListener, StartableHandlerThread.Callback {

        private int count = 0;
        private SensorManager sensorManager;

        @Override
        public void onSensorChanged(final SensorEvent event) {
            subject.onNext(event.values[0]);
        }

        @Override
        public void onAccuracyChanged(final Sensor sensor, final int accuracy) {
                /*
                * There is a bug in Android, which apparently causes this method to be called every
                * time the sensor _value_ changed, even if the _accuracy_ did not change. So logging
                * this event leads to the log being flooded with multiple entries _per second_,
                * which I experienced when running cgeo in a building (with GPS and network being
                * unreliable).
                *
                * See for example https://code.google.com/p/android/issues/detail?id=14792
                */

            //Log.i(Settings.tag, "Compass' accuracy is low (" + accuracy + ")");
        }

        // This will be removed when using a new location service. Until then, it is okay to be used.
        @SuppressWarnings("deprecation")
        @Override
        public void start(final Context context, final Handler handler) {
            if (++count == 1) {
                sensorManager = (SensorManager) context.getSystemService(Context.SENSOR_SERVICE);
                sensorManager.registerListener(this, sensorManager.getDefaultSensor(Sensor.TYPE_ORIENTATION), SensorManager.SENSOR_DELAY_NORMAL, handler);
            }
        }

        @Override
        public void stop() {
            if (--count == 0) {
                sensorManager.unregisterListener(this);
            }
        }

    }

    private static final StartableHandlerThread handlerThread =
            new StartableHandlerThread("DirectionProvider thread", Process.THREAD_PRIORITY_BACKGROUND, new Listener());
    static {
      handlerThread.start();
    }

    static public Observable<Float> create(final Context context) {
        return Observable.create(new OnSubscribe<Float>() {
            @Override
            public void call(final Subscriber<? super Float> subscriber) {
                handlerThread.start(subscriber, context);
                subject.subscribe(subscriber);
            }
        });
    }

    /**
     * Take the phone rotation (through a given activity) in account and adjust the direction.
     *
     * @param activity the activity to consider when computing the rotation
     * @param direction the unadjusted direction in degrees, in the [0, 360[ range
     * @return the adjusted direction in degrees, in the [0, 360[ range
     */

    public static float getDirectionNow(final Activity activity, final float direction) {
        return Compatibility.getDirectionNow(direction, activity);
    }

}
!@#$%
20190527_003501,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_c19108
package cgeo.geocaching.sensors;

import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.utils.AngleUtils;
import cgeo.geocaching.utils.StartableHandlerThread;

import rx.Observable;
import rx.Observable.OnSubscribe;
import rx.Subscriber;
import rx.subjects.BehaviorSubject;

import android.content.Context;
import android.hardware.Sensor;
import android.hardware.SensorEvent;
import android.hardware.SensorEventListener;
import android.hardware.SensorManager;
import android.os.Handler;
import android.os.Process;
import android.view.Surface;
import android.view.WindowManager;

public class DirectionProvider {

    private static final BehaviorSubject<Float> subject = BehaviorSubject.create(0.0f);

    private static final WindowManager windowManager = (WindowManager) CgeoApplication.getInstance().getSystemService(Context.WINDOW_SERVICE);

    static class Listener implements SensorEventListener, StartableHandlerThread.Callback {

        private int count = 0;
        private SensorManager sensorManager;

        @Override
        public void onSensorChanged(final SensorEvent event) {
            subject.onNext(event.values[0]);
        }

        @Override
        public void onAccuracyChanged(final Sensor sensor, final int accuracy) {
                /*
                * There is a bug in Android, which apparently causes this method to be called every
                * time the sensor _value_ changed, even if the _accuracy_ did not change. So logging
                * this event leads to the log being flooded with multiple entries _per second_,
                * which I experienced when running cgeo in a building (with GPS and network being
                * unreliable).
                *
                * See for example https://code.google.com/p/android/issues/detail?id=14792
                */

            //Log.i(Settings.tag, "Compass' accuracy is low (" + accuracy + ")");
        }

        // This will be removed when using a new location service. Until then, it is okay to be used.
        @SuppressWarnings("deprecation")
        @Override
        public void start(final Context context, final Handler handler) {
            if (++count == 1) {
                sensorManager = (SensorManager) context.getSystemService(Context.SENSOR_SERVICE);
                sensorManager.registerListener(this, sensorManager.getDefaultSensor(Sensor.TYPE_ORIENTATION), SensorManager.SENSOR_DELAY_NORMAL, handler);
            }
        }

        @Override
        public void stop() {
            if (--count == 0) {
                sensorManager.unregisterListener(this);
            }
        }

    }

    private static final StartableHandlerThread handlerThread =
            new StartableHandlerThread("DirectionProvider thread", Process.THREAD_PRIORITY_BACKGROUND, new Listener());
    static {
      handlerThread.start();
    }

    static public Observable<Float> create(final Context context) {
        return Observable.create(new OnSubscribe<Float>() {
            @Override
            public void call(final Subscriber<? super Float> subscriber) {
                handlerThread.start(subscriber, context);
                subject.subscribe(subscriber);
            }
        });
    }

    /**
     * Take the phone rotation (through a given activity) in account and adjust the direction.
     *
     * @param direction the unadjusted direction in degrees, in the [0, 360[ range
     * @return the adjusted direction in degrees, in the [0, 360[ range
     */

    public static float getDirectionNow(final float direction) {
        return AngleUtils.normalize(direction + getRotationOffset());
    }

    static float reverseDirectionNow(final float direction) {
        return AngleUtils.normalize(direction - getRotationOffset());
    }

    private static int getRotationOffset() {
        switch (windowManager.getDefaultDisplay().getRotation()) {
            case Surface.ROTATION_90:
                return 90;
            case Surface.ROTATION_180:
                return 180;
            case Surface.ROTATION_270:
                return 270;
            default:
                return 0;
        }
    }

}
!@#$%
20190527_003655,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_b20560
package cgeo.geocaching;

import cgeo.geocaching.sensors.DirectionProvider;
import cgeo.geocaching.sensors.GeoDataProvider;
import cgeo.geocaching.sensors.IGeoData;
import cgeo.geocaching.utils.Log;

import rx.Observable;
import rx.functions.Action1;
import rx.observables.ConnectableObservable;

import android.app.Application;
import android.os.Environment;

import java.io.IOException;
import java.lang.Thread.UncaughtExceptionHandler;

public class CgeoApplication extends Application {

    private boolean forceRelog = false; // c:geo needs to log into cache providers
    public boolean showLoginToast = true; //login toast shown just once.
    private boolean liveMapHintShownInThisSession = false; // livemap hint has been shown
    private static CgeoApplication instance;
    private Observable<IGeoData> geoDataObservable;
    private Observable<Float> directionObservable;
    private volatile IGeoData currentGeo = null;
    private volatile float currentDirection = 0.0f;

    static {
        final UncaughtExceptionHandler defaultHandler = Thread.getDefaultUncaughtExceptionHandler();

        Thread.setDefaultUncaughtExceptionHandler(new UncaughtExceptionHandler() {

            @Override
            public void uncaughtException(Thread thread, Throwable ex) {
                Log.e("UncaughtException", ex);
                Throwable exx = ex;
                while (exx.getCause() != null) {
                    exx = exx.getCause();
                }
                if (exx.getClass().equals(OutOfMemoryError.class)) {
                    try {
                        Log.e("OutOfMemory");
                        android.os.Debug.dumpHprofData(Environment.getExternalStorageDirectory().getPath() + "/dump.hprof");
                    } catch (IOException e) {
                        Log.e("Error writing dump", e);
                    }
                }
                defaultHandler.uncaughtException(thread, ex);
            }
        });
    }

    public CgeoApplication() {
        setInstance(this);
    }

    private static void setInstance(final CgeoApplication application) {
        instance = application;
    }

    public static CgeoApplication getInstance() {
        return instance;
    }

    @Override
    public void onLowMemory() {
        Log.i("Cleaning applications cache.");
        DataStore.removeAllFromCache();
    }

    public synchronized Observable<IGeoData> geoDataObservable() {
        if (geoDataObservable == null) {
            final ConnectableObservable<IGeoData> onDemand = GeoDataProvider.create(this).replay(1);
            onDemand.subscribe(new Action1<IGeoData>() {
                                  @Override
                                  public void call(final IGeoData geoData) {
                                      currentGeo = geoData;
                                  }
                              });
            geoDataObservable = onDemand.refCount();
        }
        return geoDataObservable;
    }

    public synchronized Observable<Float> directionObservable() {
        if (directionObservable == null) {
            final ConnectableObservable<Float> onDemand = DirectionProvider.create(this).replay(1);
            onDemand.subscribe(new Action1<Float>() {
                                  @Override
                                  public void call(final Float direction) {
                                      currentDirection = direction;
                                  }
                              });
            directionObservable = onDemand.refCount();
        }
        return directionObservable;
    }

    public IGeoData currentGeo() {
        return currentGeo != null ? currentGeo : geoDataObservable().toBlockingObservable().first();
    }

    public float currentDirection() {
        return currentDirection;
    }

    public boolean isLiveMapHintShownInThisSession() {
        return liveMapHintShownInThisSession;
    }

    public void setLiveMapHintShownInThisSession() {
        liveMapHintShownInThisSession = true;
    }

    /**
     * Check if cgeo must relog even if already logged in.
     *
     * @return <code>true</code> if it is necessary to relog
     */
    public boolean mustRelog() {
        final boolean mustLogin = forceRelog;
        forceRelog = false;
        return mustLogin;
    }

    /**
     * Force cgeo to relog when reaching the main activity.
     */
    public void forceRelog() {
        forceRelog = true;
    }

}
!@#$%
20190527_003655,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_a20560
package cgeo.geocaching;

import cgeo.geocaching.sensors.DirectionProvider;
import cgeo.geocaching.sensors.GeoDataProvider;
import cgeo.geocaching.sensors.IGeoData;
import cgeo.geocaching.utils.Log;

import rx.Observable;
import rx.functions.Action1;
import rx.observables.ConnectableObservable;

import android.app.Application;

import java.io.IOException;
import java.lang.Thread.UncaughtExceptionHandler;

public class CgeoApplication extends Application {

    private boolean forceRelog = false; // c:geo needs to log into cache providers
    public boolean showLoginToast = true; //login toast shown just once.
    private boolean liveMapHintShownInThisSession = false; // livemap hint has been shown
    private static CgeoApplication instance;
    private Observable<IGeoData> geoDataObservable;
    private Observable<Float> directionObservable;
    private volatile IGeoData currentGeo = null;
    private volatile float currentDirection = 0.0f;

    private static final UncaughtExceptionHandler defaultHandler;

    static {
        defaultHandler = Thread.getDefaultUncaughtExceptionHandler();

        Thread.setDefaultUncaughtExceptionHandler(new UncaughtExceptionHandler() {

            @Override
            public void uncaughtException(Thread thread, Throwable ex) {
                Log.e("UncaughtException", ex);
                Throwable exx = ex;
                while (exx.getCause() != null) {
                    exx = exx.getCause();
                }
                if (exx.getClass().equals(OutOfMemoryError.class))
                {
                    try {
                        Log.e("OutOfMemory");
                        android.os.Debug.dumpHprofData("/sdcard/dump.hprof");
                    } catch (IOException e) {
                        Log.e("Error writing dump", e);
                    }
                }
                defaultHandler.uncaughtException(thread, ex);
            }
        });
    }

    public CgeoApplication() {
        setInstance(this);
    }

    private static void setInstance(final CgeoApplication application) {
        instance = application;
    }

    public static CgeoApplication getInstance() {
        return instance;
    }

    @Override
    public void onLowMemory() {
        Log.i("Cleaning applications cache.");
        DataStore.removeAllFromCache();
    }

    public synchronized Observable<IGeoData> geoDataObservable() {
        if (geoDataObservable == null) {
            final ConnectableObservable<IGeoData> onDemand = GeoDataProvider.create(this).replay(1);
            onDemand.subscribe(new Action1<IGeoData>() {
                                  @Override
                                  public void call(final IGeoData geoData) {
                                      currentGeo = geoData;
                                  }
                              });
            geoDataObservable = onDemand.refCount();
        }
        return geoDataObservable;
    }

    public synchronized Observable<Float> directionObservable() {
        if (directionObservable == null) {
            final ConnectableObservable<Float> onDemand = DirectionProvider.create(this).replay(1);
            onDemand.subscribe(new Action1<Float>() {
                                  @Override
                                  public void call(final Float direction) {
                                      currentDirection = direction;
                                  }
                              });
            directionObservable = onDemand.refCount();
        }
        return directionObservable;
    }

    public IGeoData currentGeo() {
        return currentGeo != null ? currentGeo : geoDataObservable().toBlockingObservable().first();
    }

    public float currentDirection() {
        return currentDirection;
    }

    public boolean isLiveMapHintShownInThisSession() {
        return liveMapHintShownInThisSession;
    }

    public void setLiveMapHintShownInThisSession() {
        liveMapHintShownInThisSession = true;
    }

    /**
     * Check if cgeo must relog even if already logged in.
     *
     * @return <code>true</code> if it is necessary to relog
     */
    public boolean mustRelog() {
        final boolean mustLogin = forceRelog;
        forceRelog = false;
        return mustLogin;
    }

    /**
     * Force cgeo to relog when reaching the main activity.
     */
    public void forceRelog() {
        forceRelog = true;
    }

}
!@#$%
20190527_003655,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_c20560
package cgeo.geocaching;

import cgeo.geocaching.sensors.DirectionProvider;
import cgeo.geocaching.sensors.GeoDataProvider;
import cgeo.geocaching.sensors.IGeoData;
import cgeo.geocaching.settings.Settings;
import cgeo.geocaching.utils.Log;

import rx.Observable;
import rx.functions.Action1;
import rx.observables.ConnectableObservable;

import android.app.Application;
import android.view.ViewConfiguration;

import java.lang.reflect.Field;

import java.io.IOException;
import java.lang.Thread.UncaughtExceptionHandler;

public class CgeoApplication extends Application {

    private boolean forceRelog = false; // c:geo needs to log into cache providers
    public boolean showLoginToast = true; //login toast shown just once.
    private boolean liveMapHintShownInThisSession = false; // livemap hint has been shown
    private static CgeoApplication instance;
    private Observable<IGeoData> geoDataObservable;
    private Observable<Float> directionObservable;
    private volatile IGeoData currentGeo = null;
    private volatile float currentDirection = 0.0f;

    private static final UncaughtExceptionHandler defaultHandler;

    static {
        defaultHandler = Thread.getDefaultUncaughtExceptionHandler();

        Thread.setDefaultUncaughtExceptionHandler(new UncaughtExceptionHandler() {

            @Override
            public void uncaughtException(Thread thread, Throwable ex) {
                Log.e("UncaughtException", ex);
                Throwable exx = ex;
                while (exx.getCause() != null) {
                    exx = exx.getCause();
                }
                if (exx.getClass().equals(OutOfMemoryError.class))
                {
                    try {
                        Log.e("OutOfMemory");
                        android.os.Debug.dumpHprofData("/sdcard/dump.hprof");
                    } catch (IOException e) {
                        Log.e("Error writing dump", e);
                    }
                }
                defaultHandler.uncaughtException(thread, ex);
            }
        });
    }

    public CgeoApplication() {
        setInstance(this);
    }

    private static void setInstance(final CgeoApplication application) {
        instance = application;
    }

    public static CgeoApplication getInstance() {
        return instance;
    }

    @Override
    public void onCreate() {
        if (Settings.isAlwaysShowOverlfowMenu()) {
            try {
                ViewConfiguration config = ViewConfiguration.get(this);
                Field menuKeyField = ViewConfiguration.class.getDeclaredField("sHasPermanentMenuKey");

                if (menuKeyField != null) {
                    menuKeyField.setAccessible(true);
                    menuKeyField.setBoolean(config, false);
                }
            } catch (Exception ex) {
                // Ignore
            }
        }
    }


    @Override
    public void onLowMemory() {
        Log.i("Cleaning applications cache.");
        DataStore.removeAllFromCache();
    }

    public synchronized Observable<IGeoData> geoDataObservable() {
        if (geoDataObservable == null) {
            final ConnectableObservable<IGeoData> onDemand = GeoDataProvider.create(this).replay(1);
            onDemand.subscribe(new Action1<IGeoData>() {
                                  @Override
                                  public void call(final IGeoData geoData) {
                                      currentGeo = geoData;
                                  }
                              });
            geoDataObservable = onDemand.refCount();
        }
        return geoDataObservable;
    }

    public synchronized Observable<Float> directionObservable() {
        if (directionObservable == null) {
            final ConnectableObservable<Float> onDemand = DirectionProvider.create(this).replay(1);
            onDemand.subscribe(new Action1<Float>() {
                                  @Override
                                  public void call(final Float direction) {
                                      currentDirection = direction;
                                  }
                              });
            directionObservable = onDemand.refCount();
        }
        return directionObservable;
    }

    public IGeoData currentGeo() {
        return currentGeo != null ? currentGeo : geoDataObservable().toBlockingObservable().first();
    }

    public float currentDirection() {
        return currentDirection;
    }

    public boolean isLiveMapHintShownInThisSession() {
        return liveMapHintShownInThisSession;
    }

    public void setLiveMapHintShownInThisSession() {
        liveMapHintShownInThisSession = true;
    }

    /**
     * Check if cgeo must relog even if already logged in.
     *
     * @return <code>true</code> if it is necessary to relog
     */
    public boolean mustRelog() {
        final boolean mustLogin = forceRelog;
        forceRelog = false;
        return mustLogin;
    }

    /**
     * Force cgeo to relog when reaching the main activity.
     */
    public void forceRelog() {
        forceRelog = true;
    }

}
!@#$%
20190527_004029,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_b19012
package cgeo.geocaching.ui;

import butterknife.InjectView;

import cgeo.geocaching.CacheDetailActivity;
import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.Geocache;
import cgeo.geocaching.R;
import cgeo.geocaching.enumerations.CacheListType;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.filter.IFilter;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.sensors.IGeoData;
import cgeo.geocaching.settings.Settings;
import cgeo.geocaching.sorting.CacheComparator;
import cgeo.geocaching.sorting.DistanceComparator;
import cgeo.geocaching.sorting.EventDateComparator;
import cgeo.geocaching.sorting.InverseComparator;
import cgeo.geocaching.sorting.VisitComparator;
import cgeo.geocaching.utils.AngleUtils;
import cgeo.geocaching.utils.DateUtils;
import cgeo.geocaching.utils.Formatter;
import cgeo.geocaching.utils.Log;

import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.builder.HashCodeBuilder;
import org.eclipse.jdt.annotation.NonNull;

import android.annotation.SuppressLint;
import android.app.Activity;
import android.content.res.Resources;
import android.graphics.drawable.Drawable;
import android.graphics.drawable.LayerDrawable;
import android.text.Spannable;
import android.text.Spanned;
import android.text.style.ForegroundColorSpan;
import android.text.style.StrikethroughSpan;
import android.util.SparseArray;
import android.view.GestureDetector;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ArrayAdapter;
import android.widget.CheckBox;
import android.widget.ImageView;
import android.widget.TextView;

import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;

public class CacheListAdapter extends ArrayAdapter<Geocache> {

    private LayoutInflater inflater = null;
    private static CacheComparator cacheComparator = null;
    private Geopoint coords;
    private float azimuth = 0;
    private long lastSort = 0L;
    private boolean selectMode = false;
    private IFilter currentFilter = null;
    private List<Geocache> originalList = null;
    private final boolean isLiveList = Settings.isLiveList();

    final private Set<CompassMiniView> compasses = new LinkedHashSet<>();
    final private Set<DistanceView> distances = new LinkedHashSet<>();
    final private CacheListType cacheListType;
    final private Resources res;
    /** Resulting list of caches */
    final private List<Geocache> list;
    private boolean eventsOnly;
    private boolean inverseSort = false;

    private static final int SWIPE_MIN_DISTANCE = 60;
    private static final int SWIPE_MAX_OFF_PATH = 100;
    private static final SparseArray<Drawable> gcIconDrawables = new SparseArray<>();
    /**
     * time in milliseconds after which the list may be resorted due to position updates
     */
    private static final int PAUSE_BETWEEN_LIST_SORT = 1000;

    private static final int[] RATING_BACKGROUND = new int[3];
    static {
        if (Settings.isLightSkin()) {
            RATING_BACKGROUND[0] = R.drawable.favorite_background_red_light;
            RATING_BACKGROUND[1] = R.drawable.favorite_background_orange_light;
            RATING_BACKGROUND[2] = R.drawable.favorite_background_green_light;
        } else {
            RATING_BACKGROUND[0] = R.drawable.favorite_background_red_dark;
            RATING_BACKGROUND[1] = R.drawable.favorite_background_orange_dark;
            RATING_BACKGROUND[2] = R.drawable.favorite_background_green_dark;
        }
    }

    /**
     * view holder for the cache list adapter
     *
     */
    protected static class ViewHolder extends AbstractViewHolder {
        @InjectView(R.id.checkbox) protected CheckBox checkbox;
        @InjectView(R.id.log_status_mark) protected ImageView logStatusMark;
        @InjectView(R.id.text) protected TextView text;
        @InjectView(R.id.distance) protected DistanceView distance;
        @InjectView(R.id.favorite) protected TextView favorite;
        @InjectView(R.id.info) protected TextView info;
        @InjectView(R.id.inventory) protected ImageView inventory;
        @InjectView(R.id.direction) protected CompassMiniView direction;
        @InjectView(R.id.dirimg) protected ImageView dirImg;

        public ViewHolder(final View view) {
            super(view);
        }
    }

    public CacheListAdapter(final Activity activity, final List<Geocache> list, final CacheListType cacheListType) {
        super(activity, 0, list);
        final IGeoData currentGeo = CgeoApplication.getInstance().currentGeo();
        if (currentGeo != null) {
            coords = currentGeo.getCoords();
        }
        this.res = activity.getResources();
        this.list = list;
        this.cacheListType = cacheListType;
        checkEvents();

        final Drawable modifiedCoordinatesMarker = activity.getResources().getDrawable(R.drawable.marker_usermodifiedcoords);
        for (final CacheType cacheType : CacheType.values()) {
            // unmodified icon
            int hashCode = getIconHashCode(cacheType, false);
            gcIconDrawables.put(hashCode, activity.getResources().getDrawable(cacheType.markerId));
            // icon with flag for user modified coordinates
            hashCode = getIconHashCode(cacheType, true);
            final Drawable[] layers = new Drawable[2];
            layers[0] = activity.getResources().getDrawable(cacheType.markerId);
            layers[1] = modifiedCoordinatesMarker;
            final LayerDrawable ld = new LayerDrawable(layers);
            ld.setLayerInset(1,
                    layers[0].getIntrinsicWidth() - layers[1].getIntrinsicWidth(),
                    layers[0].getIntrinsicHeight() - layers[1].getIntrinsicHeight(),
                    0, 0);
            gcIconDrawables.put(hashCode, ld);
        }
    }

    private static int getIconHashCode(final CacheType cacheType, final boolean userModifiedOrFinal) {
        return new HashCodeBuilder()
                .append(cacheType)
                .append(userModifiedOrFinal)
                .toHashCode();
    }

    /**
     * change the sort order
     *
     * @param comparator
     */
    public void setComparator(final CacheComparator comparator) {
        cacheComparator = comparator;
        forceSort();
    }

    public void resetInverseSort() {
        inverseSort = false;
    }

    public void toggleInverseSort() {
        inverseSort = !inverseSort;
    }

    public CacheComparator getCacheComparator() {
        if (isHistory()) {
            return VisitComparator.singleton;
        }
        if (cacheComparator == null && eventsOnly) {
            return EventDateComparator.singleton;
        }
        return cacheComparator;
    }

    private boolean isHistory() {
        return cacheListType == CacheListType.HISTORY;
    }

    public Geocache findCacheByGeocode(final String geocode) {
        for (int i = 0; i < getCount(); i++) {
            if (getItem(i).getGeocode().equalsIgnoreCase(geocode)) {
                return getItem(i);
            }
        }

        return null;
    }
    /**
     * Called when a new page of caches was loaded.
     */
    public void reFilter() {
        if (currentFilter != null) {
            // Back up the list again
            originalList = new ArrayList<>(list);

            currentFilter.filter(list);
        }
    }

    /**
     * Called after a user action on the filter menu.
     */
    public void setFilter(final IFilter filter) {
        // Backup current caches list if it isn't backed up yet
        if (originalList == null) {
            originalList = new ArrayList<>(list);
        }

        // If there is already a filter in place, this is a request to change or clear the filter, so we have to
        // replace the original cache list
        if (currentFilter != null) {
            list.clear();
            list.addAll(originalList);
        }

        // Do the filtering or clear it
        if (filter != null) {
            filter.filter(list);
        }
        currentFilter = filter;

        notifyDataSetChanged();
    }

    public boolean isFiltered() {
        return currentFilter != null;
    }

    public String getFilterName() {
        return currentFilter.getName();
    }

    public int getCheckedCount() {
        int checked = 0;
        for (final Geocache cache : list) {
            if (cache.isStatusChecked()) {
                checked++;
            }
        }
        return checked;
    }

    public void setSelectMode(final boolean selectMode) {
        this.selectMode = selectMode;

        if (!selectMode) {
            for (final Geocache cache : list) {
                cache.setStatusChecked(false);
            }
        }
        notifyDataSetChanged();
    }

    public boolean isSelectMode() {
        return selectMode;
    }

    public void switchSelectMode() {
        setSelectMode(!isSelectMode());
    }

    public void invertSelection() {
        for (final Geocache cache : list) {
            cache.setStatusChecked(!cache.isStatusChecked());
        }
        notifyDataSetChanged();
    }

    public void forceSort() {
        if (CollectionUtils.isEmpty(list) || selectMode) {
            return;
        }

        if (isSortedByDistance()) {
            lastSort = 0;
            updateSortByDistance();
        }
        else {
            Collections.sort(list, getPotentialInversion(getCacheComparator()));
        }

        notifyDataSetChanged();
    }

    public void setActualCoordinates(@NonNull final Geopoint coords) {
        this.coords = coords;
        updateSortByDistance();

        for (final DistanceView distance : distances) {
            distance.update(coords);
        }
        for (final CompassMiniView compass : compasses) {
            compass.updateCurrentCoords(coords);
        }
    }

    private void updateSortByDistance() {
        if (CollectionUtils.isEmpty(list)) {
            return;
        }
        if (selectMode) {
            return;
        }
        if ((System.currentTimeMillis() - lastSort) <= PAUSE_BETWEEN_LIST_SORT) {
            return;
        }
        if (!isSortedByDistance()) {
            return;
        }
        if (coords == null) {
            return;
        }
        final ArrayList<Geocache> oldList = new ArrayList<>(list);
        Collections.sort(list, getPotentialInversion(new DistanceComparator(coords, list)));

        // avoid an update if the list has not changed due to location update
        if (list.equals(oldList)) {
            return;
        }
        notifyDataSetChanged();
        lastSort = System.currentTimeMillis();
    }

    private Comparator<? super Geocache> getPotentialInversion(final CacheComparator comparator) {
        if (inverseSort) {
            return new InverseComparator(comparator);
        }
        return comparator;
    }

    private boolean isSortedByDistance() {
        final CacheComparator comparator = getCacheComparator();
        return comparator == null || comparator instanceof DistanceComparator;
    }

    public void setActualHeading(final float direction) {
        if (Math.abs(AngleUtils.difference(azimuth, direction)) < 5) {
            return;
        }

        azimuth = direction;
        for (final CompassMiniView compass : compasses) {
            compass.updateAzimuth(azimuth);
        }
    }

    @Override
    public View getView(final int position, final View rowView, final ViewGroup parent) {
        if (inflater == null) {
            inflater = ((Activity) getContext()).getLayoutInflater();
        }

        if (position > getCount()) {
            Log.w("CacheListAdapter.getView: Attempt to access missing item #" + position);
            return null;
        }

        final Geocache cache = getItem(position);

        View v = rowView;

        final ViewHolder holder;
        if (v == null) {
            v = inflater.inflate(R.layout.cacheslist_item, parent, false);

            holder = new ViewHolder(v);
        } else {
            holder = (ViewHolder) v.getTag();
        }

        final boolean lightSkin = Settings.isLightSkin();

        final TouchListener touchListener = new TouchListener(cache, this);
        v.setOnClickListener(touchListener);
        v.setOnLongClickListener(touchListener);
        v.setOnTouchListener(touchListener);

        holder.checkbox.setVisibility(selectMode ? View.VISIBLE : View.GONE);
        holder.checkbox.setChecked(cache.isStatusChecked());
        holder.checkbox.setOnClickListener(new SelectionCheckBoxListener(cache));

        distances.add(holder.distance);
        holder.distance.setContent(cache.getCoords());
        compasses.add(holder.direction);
        holder.direction.setTargetCoords(cache.getCoords());

        if (cache.isFound() && cache.isLogOffline()) {
            holder.logStatusMark.setImageResource(R.drawable.mark_green_orange);
            holder.logStatusMark.setVisibility(View.VISIBLE);
        } else if (cache.isFound()) {
            holder.logStatusMark.setImageResource(R.drawable.mark_green_more);
            holder.logStatusMark.setVisibility(View.VISIBLE);
        } else if (cache.isLogOffline()) {
            holder.logStatusMark.setImageResource(R.drawable.mark_orange);
            holder.logStatusMark.setVisibility(View.VISIBLE);
        } else {
            holder.logStatusMark.setVisibility(View.GONE);
        }

        Spannable spannable = null;
        if (cache.isDisabled() || cache.isArchived() || DateUtils.isPastEvent(cache)) { // strike
            spannable = Spannable.Factory.getInstance().newSpannable(cache.getName());
            spannable.setSpan(new StrikethroughSpan(), 0, spannable.toString().length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        }
        if (cache.isArchived()) { // red color
            if (spannable == null) {
                spannable = Spannable.Factory.getInstance().newSpannable(cache.getName());
            }
            spannable.setSpan(new ForegroundColorSpan(res.getColor(R.color.archived_cache_color)), 0, spannable.toString().length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        }

        if (spannable != null) {
            holder.text.setText(spannable, TextView.BufferType.SPANNABLE);
        }
        else {
            holder.text.setText(cache.getName());
        }
        holder.text.setCompoundDrawablesWithIntrinsicBounds(getCacheIcon(cache), null, null, null);

        if (cache.getInventoryItems() > 0) {
            holder.inventory.setVisibility(View.VISIBLE);
        } else {
            holder.inventory.setVisibility(View.GONE);
        }

        if (cache.getDistance() != null) {
            holder.distance.setDistance(cache.getDistance());
        }

        if (cache.getCoords() != null && coords != null) {
            holder.distance.update(coords);
        }

        // only show the direction if this is enabled in the settings
        if (isLiveList) {
            if (cache.getCoords() != null) {
                holder.direction.setVisibility(View.VISIBLE);
                holder.dirImg.setVisibility(View.GONE);
                holder.direction.updateAzimuth(azimuth);
                if (coords != null) {
                    holder.direction.updateCurrentCoords(coords);
                }
            } else if (cache.getDirection() != null) {
                holder.direction.setVisibility(View.VISIBLE);
                holder.dirImg.setVisibility(View.GONE);
                holder.direction.updateAzimuth(azimuth);
                holder.direction.updateHeading(cache.getDirection());
            } else if (StringUtils.isNotBlank(cache.getDirectionImg())) {
                holder.dirImg.setImageDrawable(DirectionImage.getDrawable(cache.getDirectionImg()));
                holder.dirImg.setVisibility(View.VISIBLE);
                holder.direction.setVisibility(View.GONE);
            } else {
                holder.dirImg.setVisibility(View.GONE);
                holder.direction.setVisibility(View.GONE);
            }
        }

        holder.favorite.setText(Integer.toString(cache.getFavoritePoints()));

        int favoriteBack;
        // set default background, neither vote nor rating may be available
        if (lightSkin) {
            favoriteBack = R.drawable.favorite_background_light;
        } else {
            favoriteBack = R.drawable.favorite_background_dark;
        }
        final float myVote = cache.getMyVote();
        if (myVote > 0) { // use my own rating for display, if I have voted
            if (myVote >= 4) {
                favoriteBack = RATING_BACKGROUND[2];
            } else if (myVote >= 3) {
                favoriteBack = RATING_BACKGROUND[1];
            } else if (myVote > 0) {
                favoriteBack = RATING_BACKGROUND[0];
            }
        } else {
            final float rating = cache.getRating();
            if (rating >= 3.5) {
                favoriteBack = RATING_BACKGROUND[2];
            } else if (rating >= 2.1) {
                favoriteBack = RATING_BACKGROUND[1];
            } else if (rating > 0.0) {
                favoriteBack = RATING_BACKGROUND[0];
            }
        }
        holder.favorite.setBackgroundResource(favoriteBack);

        if (isHistory() && cache.getVisitedDate() > 0) {
            holder.info.setText(Formatter.formatCacheInfoHistory(cache));
        } else {
            holder.info.setText(Formatter.formatCacheInfoLong(cache, cacheListType));
        }

        return v;
    }

    private static Drawable getCacheIcon(final Geocache cache) {
        int hashCode = getIconHashCode(cache.getType(), cache.hasUserModifiedCoords() || cache.hasFinalDefined());
        final Drawable drawable = gcIconDrawables.get(hashCode);
        if (drawable != null) {
            return drawable;
        }

        // fallback to mystery icon
        hashCode = getIconHashCode(CacheType.MYSTERY, cache.hasUserModifiedCoords() || cache.hasFinalDefined());
        return gcIconDrawables.get(hashCode);
    }

    @Override
    public void notifyDataSetChanged() {
        super.notifyDataSetChanged();
        distances.clear();
        compasses.clear();
    }

    private static class SelectionCheckBoxListener implements View.OnClickListener {

        private final Geocache cache;

        public SelectionCheckBoxListener(final Geocache cache) {
            this.cache = cache;
        }

        @Override
        public void onClick(final View view) {
            assert view instanceof CheckBox;
            final boolean checkNow = ((CheckBox) view).isChecked();
            cache.setStatusChecked(checkNow);
        }
    }

    private static class TouchListener implements View.OnClickListener, View.OnLongClickListener, View.OnTouchListener {

        private final Geocache cache;
        private final GestureDetector gestureDetector;
        private final @NonNull WeakReference<CacheListAdapter> adapterRef;

        public TouchListener(final Geocache cache, final @NonNull CacheListAdapter adapter) {
            this.cache = cache;
            gestureDetector = new GestureDetector(adapter.getContext(), new FlingGesture(cache, adapter));
            adapterRef = new WeakReference<>(adapter);
        }

        // Tap on item
        @Override
        public void onClick(final View view) {
            final CacheListAdapter adapter = adapterRef.get();
            if (adapter == null) {
                return;
            }
            if (adapter.isSelectMode()) {
                cache.setStatusChecked(!cache.isStatusChecked());
                adapter.notifyDataSetChanged();
            } else {
                CacheDetailActivity.startActivity(adapter.getContext(), cache.getGeocode(), cache.getName());
            }
        }

        // Long tap on item
        @Override
        public boolean onLongClick(final View view) {
            view.showContextMenu();
            return true;
        }

        // Swipe on item
        @SuppressLint("ClickableViewAccessibility")
        @Override
        public boolean onTouch(final View view, final MotionEvent event) {
            return gestureDetector.onTouchEvent(event);

        }
    }

    private static class FlingGesture extends GestureDetector.SimpleOnGestureListener {

        private final Geocache cache;
        private final @NonNull WeakReference<CacheListAdapter> adapterRef;

        public FlingGesture(final Geocache cache, final @NonNull CacheListAdapter adapter) {
            this.cache = cache;
            adapterRef = new WeakReference<>(adapter);
        }

        @Override
        public boolean onFling(final MotionEvent e1, final MotionEvent e2, final float velocityX, final float velocityY) {
            try {
                if (Math.abs(e1.getY() - e2.getY()) > SWIPE_MAX_OFF_PATH) {
                    return false;
                }
                final CacheListAdapter adapter = adapterRef.get();
                if (adapter == null) {
                    return false;
                }

                // left to right swipe
                if ((e2.getX() - e1.getX()) > SWIPE_MIN_DISTANCE && Math.abs(velocityX) > Math.abs(velocityY)) {
                    if (!adapter.selectMode) {
                        adapter.switchSelectMode();
                        cache.setStatusChecked(true);
                    }
                    return true;
                }

                // right to left swipe
                if ((e1.getX() - e2.getX()) > SWIPE_MIN_DISTANCE && Math.abs(velocityX) > Math.abs(velocityY)) {
                    if (adapter.selectMode) {
                        adapter.switchSelectMode();
                    }
                    return true;
                }
            } catch (final Exception e) {
                Log.w("CacheListAdapter.FlingGesture.onFling", e);
            }

            return false;
        }
    }

    public List<Geocache> getFilteredList() {
        return list;
    }

    public List<Geocache> getCheckedCaches() {
        final ArrayList<Geocache> result = new ArrayList<>();
        for (final Geocache cache : list) {
            if (cache.isStatusChecked()) {
                result.add(cache);
            }
        }
        return result;
    }

    public List<Geocache> getCheckedOrAllCaches() {
        final List<Geocache> result = getCheckedCaches();
        if (!result.isEmpty()) {
            return result;
        }
        return new ArrayList<>(list);
    }

    public int getCheckedOrAllCount() {
        final int checked = getCheckedCount();
        if (checked > 0) {
            return checked;
        }
        return list.size();
    }

    public void checkEvents() {
        eventsOnly = true;
        for (final Geocache cache : list) {
            if (!cache.isEventCache()) {
                eventsOnly = false;
                return;
            }
        }
    }
}
!@#$%
20190527_004029,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_a19012
package cgeo.geocaching.ui;

import butterknife.InjectView;

import cgeo.geocaching.CacheDetailActivity;
import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.Geocache;
import cgeo.geocaching.R;
import cgeo.geocaching.enumerations.CacheListType;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.filter.IFilter;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.sensors.IGeoData;
import cgeo.geocaching.settings.Settings;
import cgeo.geocaching.sorting.CacheComparator;
import cgeo.geocaching.sorting.DistanceComparator;
import cgeo.geocaching.sorting.EventDateComparator;
import cgeo.geocaching.sorting.InverseComparator;
import cgeo.geocaching.sorting.VisitComparator;
import cgeo.geocaching.utils.AngleUtils;
import cgeo.geocaching.utils.DateUtils;
import cgeo.geocaching.utils.Log;

import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.builder.HashCodeBuilder;
import org.eclipse.jdt.annotation.NonNull;

import android.annotation.SuppressLint;
import android.app.Activity;
import android.content.res.Resources;
import android.graphics.drawable.Drawable;
import android.graphics.drawable.LayerDrawable;
import android.text.Spannable;
import android.text.Spanned;
import android.text.style.ForegroundColorSpan;
import android.text.style.StrikethroughSpan;
import android.util.SparseArray;
import android.view.GestureDetector;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ArrayAdapter;
import android.widget.CheckBox;
import android.widget.ImageView;
import android.widget.TextView;

import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;

public class CacheListAdapter extends ArrayAdapter<Geocache> {

    private LayoutInflater inflater = null;
    private static CacheComparator cacheComparator = null;
    private Geopoint coords;
    private float azimuth = 0;
    private long lastSort = 0L;
    private boolean selectMode = false;
    private IFilter currentFilter = null;
    private List<Geocache> originalList = null;
    private final boolean isLiveList = Settings.isLiveList();

    final private Set<CompassMiniView> compasses = new LinkedHashSet<CompassMiniView>();
    final private Set<DistanceView> distances = new LinkedHashSet<DistanceView>();
    final private CacheListType cacheListType;
    final private Resources res;
    /** Resulting list of caches */
    final private List<Geocache> list;
    private boolean eventsOnly;
    private boolean inverseSort = false;

    private static final int SWIPE_MIN_DISTANCE = 60;
    private static final int SWIPE_MAX_OFF_PATH = 100;
    private static final SparseArray<Drawable> gcIconDrawables = new SparseArray<Drawable>();
    /**
     * time in milliseconds after which the list may be resorted due to position updates
     */
    private static final int PAUSE_BETWEEN_LIST_SORT = 1000;

    private static final int[] RATING_BACKGROUND = new int[3];
    static {
        if (Settings.isLightSkin()) {
            RATING_BACKGROUND[0] = R.drawable.favorite_background_red_light;
            RATING_BACKGROUND[1] = R.drawable.favorite_background_orange_light;
            RATING_BACKGROUND[2] = R.drawable.favorite_background_green_light;
        } else {
            RATING_BACKGROUND[0] = R.drawable.favorite_background_red_dark;
            RATING_BACKGROUND[1] = R.drawable.favorite_background_orange_dark;
            RATING_BACKGROUND[2] = R.drawable.favorite_background_green_dark;
        }
    }

    /**
     * view holder for the cache list adapter
     *
     */
    protected static class ViewHolder extends AbstractViewHolder {
        @InjectView(R.id.checkbox) protected CheckBox checkbox;
        @InjectView(R.id.log_status_mark) protected ImageView logStatusMark;
        @InjectView(R.id.text) protected TextView text;
        @InjectView(R.id.distance) protected DistanceView distance;
        @InjectView(R.id.favorite) protected TextView favorite;
        @InjectView(R.id.info) protected TextView info;
        @InjectView(R.id.inventory) protected ImageView inventory;
        @InjectView(R.id.direction) protected CompassMiniView direction;
        @InjectView(R.id.dirimg) protected ImageView dirImg;

        public ViewHolder(final View view) {
            super(view);
        }
    }

    public CacheListAdapter(final Activity activity, final List<Geocache> list, final CacheListType cacheListType) {
        super(activity, 0, list);
        final IGeoData currentGeo = CgeoApplication.getInstance().currentGeo();
        if (currentGeo != null) {
            coords = currentGeo.getCoords();
        }
        this.res = activity.getResources();
        this.list = list;
        this.cacheListType = cacheListType;
        checkEvents();

        final Drawable modifiedCoordinatesMarker = activity.getResources().getDrawable(R.drawable.marker_usermodifiedcoords);
        for (final CacheType cacheType : CacheType.values()) {
            // unmodified icon
            int hashCode = getIconHashCode(cacheType, false);
            gcIconDrawables.put(hashCode, activity.getResources().getDrawable(cacheType.markerId));
            // icon with flag for user modified coordinates
            hashCode = getIconHashCode(cacheType, true);
            final Drawable[] layers = new Drawable[2];
            layers[0] = activity.getResources().getDrawable(cacheType.markerId);
            layers[1] = modifiedCoordinatesMarker;
            final LayerDrawable ld = new LayerDrawable(layers);
            ld.setLayerInset(1,
                    layers[0].getIntrinsicWidth() - layers[1].getIntrinsicWidth(),
                    layers[0].getIntrinsicHeight() - layers[1].getIntrinsicHeight(),
                    0, 0);
            gcIconDrawables.put(hashCode, ld);
        }
    }

    private static int getIconHashCode(final CacheType cacheType, final boolean userModifiedOrFinal) {
        return new HashCodeBuilder()
                .append(cacheType)
                .append(userModifiedOrFinal)
                .toHashCode();
    }

    /**
     * change the sort order
     *
     * @param comparator
     */
    public void setComparator(final CacheComparator comparator) {
        cacheComparator = comparator;
        forceSort();
    }

    public void resetInverseSort() {
        inverseSort = false;
    }

    public void toggleInverseSort() {
        inverseSort = !inverseSort;
    }

    public CacheComparator getCacheComparator() {
        if (isHistory()) {
            return VisitComparator.singleton;
        }
        if (cacheComparator == null && eventsOnly) {
            return EventDateComparator.singleton;
        }
        return cacheComparator;
    }

    private boolean isHistory() {
        return cacheListType == CacheListType.HISTORY;
    }

    public Geocache findCacheByGeocode(final String geocode) {
        for (int i = 0; i < getCount(); i++) {
            if (getItem(i).getGeocode().equalsIgnoreCase(geocode)) {
                return getItem(i);
            }
        }

        return null;
    }
    /**
     * Called when a new page of caches was loaded.
     */
    public void reFilter() {
        if (currentFilter != null) {
            // Back up the list again
            originalList = new ArrayList<Geocache>(list);

            currentFilter.filter(list);
        }
    }

    /**
     * Called after a user action on the filter menu.
     */
    public void setFilter(final IFilter filter) {
        // Backup current caches list if it isn't backed up yet
        if (originalList == null) {
            originalList = new ArrayList<Geocache>(list);
        }

        // If there is already a filter in place, this is a request to change or clear the filter, so we have to
        // replace the original cache list
        if (currentFilter != null) {
            list.clear();
            list.addAll(originalList);
        }

        // Do the filtering or clear it
        if (filter != null) {
            filter.filter(list);
        }
        currentFilter = filter;

        notifyDataSetChanged();
    }

    public boolean isFiltered() {
        return currentFilter != null;
    }

    public String getFilterName() {
        return currentFilter.getName();
    }

    public int getCheckedCount() {
        int checked = 0;
        for (final Geocache cache : list) {
            if (cache.isStatusChecked()) {
                checked++;
            }
        }
        return checked;
    }

    public void setSelectMode(final boolean selectMode) {
        this.selectMode = selectMode;

        if (!selectMode) {
            for (final Geocache cache : list) {
                cache.setStatusChecked(false);
            }
        }
        notifyDataSetChanged();
    }

    public boolean isSelectMode() {
        return selectMode;
    }

    public void switchSelectMode() {
        setSelectMode(!isSelectMode());
    }

    public void invertSelection() {
        for (final Geocache cache : list) {
            cache.setStatusChecked(!cache.isStatusChecked());
        }
        notifyDataSetChanged();
    }

    public void forceSort() {
        if (CollectionUtils.isEmpty(list) || selectMode) {
            return;
        }

        if (isSortedByDistance()) {
            lastSort = 0;
            updateSortByDistance();
        }
        else {
            Collections.sort(list, getPotentialInversion(getCacheComparator()));
        }

        notifyDataSetChanged();
    }

    public void setActualCoordinates(@NonNull final Geopoint coords) {
        this.coords = coords;
        updateSortByDistance();

        for (final DistanceView distance : distances) {
            distance.update(coords);
        }
        for (final CompassMiniView compass : compasses) {
            compass.updateCurrentCoords(coords);
        }
    }

    private void updateSortByDistance() {
        if (CollectionUtils.isEmpty(list)) {
            return;
        }
        if (selectMode) {
            return;
        }
        if ((System.currentTimeMillis() - lastSort) <= PAUSE_BETWEEN_LIST_SORT) {
            return;
        }
        if (!isSortedByDistance()) {
            return;
        }
        if (coords == null) {
            return;
        }
        final ArrayList<Geocache> oldList = new ArrayList<Geocache>(list);
        Collections.sort(list, getPotentialInversion(new DistanceComparator(coords, list)));

        // avoid an update if the list has not changed due to location update
        if (list.equals(oldList)) {
            return;
        }
        notifyDataSetChanged();
        lastSort = System.currentTimeMillis();
    }

    private Comparator<? super Geocache> getPotentialInversion(final CacheComparator comparator) {
        if (inverseSort) {
            return new InverseComparator(comparator);
        }
        return comparator;
    }

    private boolean isSortedByDistance() {
        final CacheComparator comparator = getCacheComparator();
        return comparator == null || comparator instanceof DistanceComparator;
    }

    public void setActualHeading(final float direction) {
        if (Math.abs(AngleUtils.difference(azimuth, direction)) < 5) {
            return;
        }

        azimuth = direction;
        for (final CompassMiniView compass : compasses) {
            compass.updateAzimuth(azimuth);
        }
    }

    @Override
    public View getView(final int position, final View rowView, final ViewGroup parent) {
        if (inflater == null) {
            inflater = ((Activity) getContext()).getLayoutInflater();
        }

        if (position > getCount()) {
            Log.w("CacheListAdapter.getView: Attempt to access missing item #" + position);
            return null;
        }

        final Geocache cache = getItem(position);

        View v = rowView;

        final ViewHolder holder;
        if (v == null) {
            v = inflater.inflate(R.layout.cacheslist_item, parent, false);

            holder = new ViewHolder(v);
        } else {
            holder = (ViewHolder) v.getTag();
        }

        final boolean lightSkin = Settings.isLightSkin();

        final TouchListener touchListener = new TouchListener(cache, this);
        v.setOnClickListener(touchListener);
        v.setOnLongClickListener(touchListener);
        v.setOnTouchListener(touchListener);

        holder.checkbox.setVisibility(selectMode ? View.VISIBLE : View.GONE);
        holder.checkbox.setChecked(cache.isStatusChecked());
        holder.checkbox.setOnClickListener(new SelectionCheckBoxListener(cache));

        distances.add(holder.distance);
        holder.distance.setContent(cache.getCoords());
        compasses.add(holder.direction);
        holder.direction.setTargetCoords(cache.getCoords());

        if (cache.isFound() && cache.isLogOffline()) {
            holder.logStatusMark.setImageResource(R.drawable.mark_green_orange);
            holder.logStatusMark.setVisibility(View.VISIBLE);
        } else if (cache.isFound()) {
            holder.logStatusMark.setImageResource(R.drawable.mark_green_more);
            holder.logStatusMark.setVisibility(View.VISIBLE);
        } else if (cache.isLogOffline()) {
            holder.logStatusMark.setImageResource(R.drawable.mark_orange);
            holder.logStatusMark.setVisibility(View.VISIBLE);
        } else {
            holder.logStatusMark.setVisibility(View.GONE);
        }

        Spannable spannable = null;
        if (cache.isDisabled() || cache.isArchived() || DateUtils.isPastEvent(cache)) { // strike
            spannable = Spannable.Factory.getInstance().newSpannable(cache.getName());
            spannable.setSpan(new StrikethroughSpan(), 0, spannable.toString().length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        }
        if (cache.isArchived()) { // red color
            if (spannable == null) {
                spannable = Spannable.Factory.getInstance().newSpannable(cache.getName());
            }
            spannable.setSpan(new ForegroundColorSpan(res.getColor(R.color.archived_cache_color)), 0, spannable.toString().length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        }

        if (spannable != null) {
            holder.text.setText(spannable, TextView.BufferType.SPANNABLE);
        }
        else {
            holder.text.setText(cache.getName());
        }
        holder.text.setCompoundDrawablesWithIntrinsicBounds(getCacheIcon(cache), null, null, null);

        if (cache.getInventoryItems() > 0) {
            holder.inventory.setVisibility(View.VISIBLE);
        } else {
            holder.inventory.setVisibility(View.GONE);
        }

        if (cache.getDistance() != null) {
            holder.distance.setDistance(cache.getDistance());
        }

        if (cache.getCoords() != null && coords != null) {
            holder.distance.update(coords);
        }

        // only show the direction if this is enabled in the settings
        if (isLiveList) {
            if (cache.getCoords() != null) {
                holder.direction.setVisibility(View.VISIBLE);
                holder.dirImg.setVisibility(View.GONE);
                holder.direction.updateAzimuth(azimuth);
                if (coords != null) {
                    holder.direction.updateCurrentCoords(coords);
                }
            } else if (cache.getDirection() != null) {
                holder.direction.setVisibility(View.VISIBLE);
                holder.dirImg.setVisibility(View.GONE);
                holder.direction.updateAzimuth(azimuth);
                holder.direction.updateHeading(cache.getDirection());
            } else if (StringUtils.isNotBlank(cache.getDirectionImg())) {
                holder.dirImg.setImageDrawable(DirectionImage.getDrawable(cache.getDirectionImg()));
                holder.dirImg.setVisibility(View.VISIBLE);
                holder.direction.setVisibility(View.GONE);
            } else {
                holder.dirImg.setVisibility(View.GONE);
                holder.direction.setVisibility(View.GONE);
            }
        }

        holder.favorite.setText(Integer.toString(cache.getFavoritePoints()));

        int favoriteBack;
        // set default background, neither vote nor rating may be available
        if (lightSkin) {
            favoriteBack = R.drawable.favorite_background_light;
        } else {
            favoriteBack = R.drawable.favorite_background_dark;
        }
        final float myVote = cache.getMyVote();
        if (myVote > 0) { // use my own rating for display, if I have voted
            if (myVote >= 4) {
                favoriteBack = RATING_BACKGROUND[2];
            } else if (myVote >= 3) {
                favoriteBack = RATING_BACKGROUND[1];
            } else if (myVote > 0) {
                favoriteBack = RATING_BACKGROUND[0];
            }
        } else {
            final float rating = cache.getRating();
            if (rating >= 3.5) {
                favoriteBack = RATING_BACKGROUND[2];
            } else if (rating >= 2.1) {
                favoriteBack = RATING_BACKGROUND[1];
            } else if (rating > 0.0) {
                favoriteBack = RATING_BACKGROUND[0];
            }
        }
        holder.favorite.setBackgroundResource(favoriteBack);

        if (isHistory() && cache.getVisitedDate() > 0) {
            holder.info.setText(Formatter.formatCacheInfoHistory(cache));
        } else {
            holder.info.setText(Formatter.formatCacheInfoLong(cache, cacheListType));
        }

        return v;
    }

    private static Drawable getCacheIcon(final Geocache cache) {
        int hashCode = getIconHashCode(cache.getType(), cache.hasUserModifiedCoords() || cache.hasFinalDefined());
        final Drawable drawable = gcIconDrawables.get(hashCode);
        if (drawable != null) {
            return drawable;
        }

        // fallback to mystery icon
        hashCode = getIconHashCode(CacheType.MYSTERY, cache.hasUserModifiedCoords() || cache.hasFinalDefined());
        return gcIconDrawables.get(hashCode);
    }

    @Override
    public void notifyDataSetChanged() {
        super.notifyDataSetChanged();
        distances.clear();
        compasses.clear();
    }

    private static class SelectionCheckBoxListener implements View.OnClickListener {

        private final Geocache cache;

        public SelectionCheckBoxListener(final Geocache cache) {
            this.cache = cache;
        }

        @Override
        public void onClick(final View view) {
            assert view instanceof CheckBox;
            final boolean checkNow = ((CheckBox) view).isChecked();
            cache.setStatusChecked(checkNow);
        }
    }

    private static class TouchListener implements View.OnClickListener, View.OnLongClickListener, View.OnTouchListener {

        private final Geocache cache;
        private final GestureDetector gestureDetector;
        private final @NonNull WeakReference<CacheListAdapter> adapterRef;

        public TouchListener(final Geocache cache, final @NonNull CacheListAdapter adapter) {
            this.cache = cache;
            gestureDetector = new GestureDetector(adapter.getContext(), new FlingGesture(cache, adapter));
            adapterRef = new WeakReference<CacheListAdapter>(adapter);
        }

        // Tap on item
        @Override
        public void onClick(final View view) {
            final CacheListAdapter adapter = adapterRef.get();
            if (adapter == null) {
                return;
            }
            if (adapter.isSelectMode()) {
                cache.setStatusChecked(!cache.isStatusChecked());
                adapter.notifyDataSetChanged();
            } else {
                CacheDetailActivity.startActivity(adapter.getContext(), cache.getGeocode(), cache.getName());
            }
        }

        // Long tap on item
        @Override
        public boolean onLongClick(final View view) {
            view.showContextMenu();
            return true;
        }

        // Swipe on item
        @SuppressLint("ClickableViewAccessibility")
        @Override
        public boolean onTouch(final View view, final MotionEvent event) {
            return gestureDetector.onTouchEvent(event);

        }
    }

    private static class FlingGesture extends GestureDetector.SimpleOnGestureListener {

        private final Geocache cache;
        private final @NonNull WeakReference<CacheListAdapter> adapterRef;

        public FlingGesture(final Geocache cache, final @NonNull CacheListAdapter adapter) {
            this.cache = cache;
            adapterRef = new WeakReference<CacheListAdapter>(adapter);
        }

        @Override
        public boolean onFling(final MotionEvent e1, final MotionEvent e2, final float velocityX, final float velocityY) {
            try {
                if (Math.abs(e1.getY() - e2.getY()) > SWIPE_MAX_OFF_PATH) {
                    return false;
                }
                final CacheListAdapter adapter = adapterRef.get();
                if (adapter == null) {
                    return false;
                }

                // left to right swipe
                if ((e2.getX() - e1.getX()) > SWIPE_MIN_DISTANCE && Math.abs(velocityX) > Math.abs(velocityY)) {
                    if (!adapter.selectMode) {
                        adapter.switchSelectMode();
                        cache.setStatusChecked(true);
                    }
                    return true;
                }

                // right to left swipe
                if ((e1.getX() - e2.getX()) > SWIPE_MIN_DISTANCE && Math.abs(velocityX) > Math.abs(velocityY)) {
                    if (adapter.selectMode) {
                        adapter.switchSelectMode();
                    }
                    return true;
                }
            } catch (final Exception e) {
                Log.w("CacheListAdapter.FlingGesture.onFling", e);
            }

            return false;
        }
    }

    public List<Geocache> getFilteredList() {
        return list;
    }

    public List<Geocache> getCheckedCaches() {
        final ArrayList<Geocache> result = new ArrayList<Geocache>();
        for (final Geocache cache : list) {
            if (cache.isStatusChecked()) {
                result.add(cache);
            }
        }
        return result;
    }

    public List<Geocache> getCheckedOrAllCaches() {
        final List<Geocache> result = getCheckedCaches();
        if (!result.isEmpty()) {
            return result;
        }
        return new ArrayList<Geocache>(list);
    }

    public int getCheckedOrAllCount() {
        final int checked = getCheckedCount();
        if (checked > 0) {
            return checked;
        }
        return list.size();
    }

    public void checkEvents() {
        eventsOnly = true;
        for (final Geocache cache : list) {
            if (!cache.isEventCache()) {
                eventsOnly = false;
                return;
            }
        }
    }
}
!@#$%
20190527_004029,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_c19012
package cgeo.geocaching.ui;

import butterknife.InjectView;

import cgeo.geocaching.CacheDetailActivity;
import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.Geocache;
import cgeo.geocaching.R;
import cgeo.geocaching.enumerations.CacheListType;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.filter.IFilter;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.sensors.IGeoData;
import cgeo.geocaching.settings.Settings;
import cgeo.geocaching.sorting.CacheComparator;
import cgeo.geocaching.sorting.DistanceComparator;
import cgeo.geocaching.sorting.EventDateComparator;
import cgeo.geocaching.sorting.InverseComparator;
import cgeo.geocaching.sorting.VisitComparator;
import cgeo.geocaching.utils.AngleUtils;
import cgeo.geocaching.utils.DateUtils;
import cgeo.geocaching.utils.Log;

import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.builder.HashCodeBuilder;
import org.eclipse.jdt.annotation.NonNull;

import android.annotation.SuppressLint;
import android.app.Activity;
import android.content.res.Resources;
import android.graphics.drawable.Drawable;
import android.graphics.drawable.LayerDrawable;
import android.text.Spannable;
import android.text.Spanned;
import android.text.style.ForegroundColorSpan;
import android.text.style.StrikethroughSpan;
import android.util.SparseArray;
import android.view.GestureDetector;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ArrayAdapter;
import android.widget.CheckBox;
import android.widget.ImageView;
import android.widget.TextView;

import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;

public class CacheListAdapter extends ArrayAdapter<Geocache> {

    private LayoutInflater inflater = null;
    private static CacheComparator cacheComparator = null;
    private Geopoint coords;
    private float azimuth = 0;
    private long lastSort = 0L;
    private boolean selectMode = false;
    private IFilter currentFilter = null;
    private List<Geocache> originalList = null;
    private final boolean isLiveList = Settings.isLiveList();

    final private Set<CompassMiniView> compasses = new LinkedHashSet<CompassMiniView>();
    final private Set<DistanceView> distances = new LinkedHashSet<DistanceView>();
    final private CacheListType cacheListType;
    final private Resources res;
    /** Resulting list of caches */
    final private List<Geocache> list;
    private boolean eventsOnly;
    private boolean inverseSort = false;

    private static final int SWIPE_MIN_DISTANCE = 60;
    private static final int SWIPE_MAX_OFF_PATH = 100;
    private static final SparseArray<Drawable> gcIconDrawables = new SparseArray<Drawable>();
    /**
     * time in milliseconds after which the list may be resorted due to position updates
     */
    private static final int PAUSE_BETWEEN_LIST_SORT = 1000;

    private static final int[] RATING_BACKGROUND = new int[3];
    static {
        if (Settings.isLightSkin()) {
            RATING_BACKGROUND[0] = R.drawable.favorite_background_red_light;
            RATING_BACKGROUND[1] = R.drawable.favorite_background_orange_light;
            RATING_BACKGROUND[2] = R.drawable.favorite_background_green_light;
        } else {
            RATING_BACKGROUND[0] = R.drawable.favorite_background_red_dark;
            RATING_BACKGROUND[1] = R.drawable.favorite_background_orange_dark;
            RATING_BACKGROUND[2] = R.drawable.favorite_background_green_dark;
        }
    }

    /**
     * view holder for the cache list adapter
     *
     */
    protected static class ViewHolder extends AbstractViewHolder {
        @InjectView(R.id.checkbox) protected CheckBox checkbox;
        @InjectView(R.id.log_status_mark) protected ImageView logStatusMark;
        @InjectView(R.id.text) protected TextView text;
        @InjectView(R.id.distance) protected DistanceView distance;
        @InjectView(R.id.favorite) protected TextView favorite;
        @InjectView(R.id.info) protected TextView info;
        @InjectView(R.id.inventory) protected ImageView inventory;
        @InjectView(R.id.direction) protected CompassMiniView direction;
        @InjectView(R.id.dirimg) protected ImageView dirImg;

        public ViewHolder(final View view) {
            super(view);
        }
    }

    public CacheListAdapter(final Activity activity, final List<Geocache> list, final CacheListType cacheListType) {
        super(activity, 0, list);
        final IGeoData currentGeo = CgeoApplication.getInstance().currentGeo();
        if (currentGeo != null) {
            coords = currentGeo.getCoords();
        }
        this.res = activity.getResources();
        this.list = list;
        this.cacheListType = cacheListType;
        checkEvents();

        final Drawable modifiedCoordinatesMarker = activity.getResources().getDrawable(R.drawable.marker_usermodifiedcoords);
        for (final CacheType cacheType : CacheType.values()) {
            // unmodified icon
            int hashCode = getIconHashCode(cacheType, false);
            gcIconDrawables.put(hashCode, activity.getResources().getDrawable(cacheType.markerId));
            // icon with flag for user modified coordinates
            hashCode = getIconHashCode(cacheType, true);
            final Drawable[] layers = new Drawable[2];
            layers[0] = activity.getResources().getDrawable(cacheType.markerId);
            layers[1] = modifiedCoordinatesMarker;
            final LayerDrawable ld = new LayerDrawable(layers);
            ld.setLayerInset(1,
                    layers[0].getIntrinsicWidth() - layers[1].getIntrinsicWidth(),
                    layers[0].getIntrinsicHeight() - layers[1].getIntrinsicHeight(),
                    0, 0);
            gcIconDrawables.put(hashCode, ld);
        }
    }

    private static int getIconHashCode(final CacheType cacheType, final boolean userModifiedOrFinal) {
        return new HashCodeBuilder()
                .append(cacheType)
                .append(userModifiedOrFinal)
                .toHashCode();
    }

    /**
     * change the sort order
     *
     * @param comparator
     */
    public void setComparator(final CacheComparator comparator) {
        cacheComparator = comparator;
        forceSort();
    }

    public void resetInverseSort() {
        inverseSort = false;
    }

    public void toggleInverseSort() {
        inverseSort = !inverseSort;
    }

    public CacheComparator getCacheComparator() {
        if (isHistory()) {
            return VisitComparator.singleton;
        }
        if (cacheComparator == null && eventsOnly) {
            return EventDateComparator.singleton;
        }
        return cacheComparator;
    }

    private boolean isHistory() {
        return cacheListType == CacheListType.HISTORY;
    }

    public Geocache findCacheByGeocode(final String geocode) {
        for (int i = 0; i < getCount(); i++) {
            if (getItem(i).getGeocode().equalsIgnoreCase(geocode)) {
                return getItem(i);
            }
        }

        return null;
    }
    /**
     * Called when a new page of caches was loaded.
     */
    public void reFilter() {
        if (currentFilter != null) {
            // Back up the list again
            originalList = new ArrayList<Geocache>(list);

            currentFilter.filter(list);
        }
    }

    /**
     * Called after a user action on the filter menu.
     */
    public void setFilter(final IFilter filter) {
        // Backup current caches list if it isn't backed up yet
        if (originalList == null) {
            originalList = new ArrayList<Geocache>(list);
        }

        // If there is already a filter in place, this is a request to change or clear the filter, so we have to
        // replace the original cache list
        if (currentFilter != null) {
            list.clear();
            list.addAll(originalList);
        }

        // Do the filtering or clear it
        if (filter != null) {
            filter.filter(list);
        }
        currentFilter = filter;

        notifyDataSetChanged();
    }

    public boolean isFiltered() {
        return currentFilter != null;
    }

    public String getFilterName() {
        return currentFilter.getName();
    }

    public int getCheckedCount() {
        int checked = 0;
        for (final Geocache cache : list) {
            if (cache.isStatusChecked()) {
                checked++;
            }
        }
        return checked;
    }

    public void setSelectMode(final boolean selectMode) {
        this.selectMode = selectMode;

        if (!selectMode) {
            for (final Geocache cache : list) {
                cache.setStatusChecked(false);
            }
        }
        notifyDataSetChanged();
    }

    public boolean isSelectMode() {
        return selectMode;
    }

    public void switchSelectMode() {
        setSelectMode(!isSelectMode());
    }

    public void invertSelection() {
        for (final Geocache cache : list) {
            cache.setStatusChecked(!cache.isStatusChecked());
        }
        notifyDataSetChanged();
    }

    public void forceSort() {
        if (CollectionUtils.isEmpty(list) || selectMode) {
            return;
        }

        if (isSortedByDistance()) {
            lastSort = 0;
            updateSortByDistance();
        }
        else {
            Collections.sort(list, getPotentialInversion(getCacheComparator()));
        }

        notifyDataSetChanged();
    }

    public void setActualCoordinates(@NonNull final Geopoint coords) {
        this.coords = coords;
        updateSortByDistance();

        for (final DistanceView distance : distances) {
            distance.update(coords);
        }
        for (final CompassMiniView compass : compasses) {
            compass.updateCurrentCoords(coords);
        }
    }

    private void updateSortByDistance() {
        if (CollectionUtils.isEmpty(list)) {
            return;
        }
        if (selectMode) {
            return;
        }
        if ((System.currentTimeMillis() - lastSort) <= PAUSE_BETWEEN_LIST_SORT) {
            return;
        }
        if (!isSortedByDistance()) {
            return;
        }
        if (coords == null) {
            return;
        }
        final ArrayList<Geocache> oldList = new ArrayList<Geocache>(list);
        Collections.sort(list, getPotentialInversion(new DistanceComparator(coords, list)));

        // avoid an update if the list has not changed due to location update
        if (list.equals(oldList)) {
            return;
        }
        notifyDataSetChanged();
        lastSort = System.currentTimeMillis();
    }

    private Comparator<? super Geocache> getPotentialInversion(final CacheComparator comparator) {
        if (inverseSort) {
            return new InverseComparator(comparator);
        }
        return comparator;
    }

    private boolean isSortedByDistance() {
        final CacheComparator comparator = getCacheComparator();
        return comparator == null || comparator instanceof DistanceComparator;
    }

    public void setActualHeading(final float direction) {
        if (Math.abs(AngleUtils.difference(azimuth, direction)) < 5) {
            return;
        }

        azimuth = direction;
        for (final CompassMiniView compass : compasses) {
            compass.updateAzimuth(azimuth);
        }
    }

    @Override
    public View getView(final int position, final View rowView, final ViewGroup parent) {
        if (inflater == null) {
            inflater = ((Activity) getContext()).getLayoutInflater();
        }

        if (position > getCount()) {
            Log.w("CacheListAdapter.getView: Attempt to access missing item #" + position);
            return null;
        }

        final Geocache cache = getItem(position);

        View v = rowView;

        final ViewHolder holder;
        if (v == null) {
            v = inflater.inflate(R.layout.cacheslist_item, parent, false);

            holder = new ViewHolder(v);
        } else {
            holder = (ViewHolder) v.getTag();
        }

        final boolean lightSkin = Settings.isLightSkin();

        final TouchListener touchListener = new TouchListener(cache, this);
        v.setOnClickListener(touchListener);
        v.setOnLongClickListener(touchListener);
        v.setOnTouchListener(touchListener);

        holder.checkbox.setVisibility(selectMode ? View.VISIBLE : View.GONE);
        holder.checkbox.setChecked(cache.isStatusChecked());
        holder.checkbox.setOnClickListener(new SelectionCheckBoxListener(cache));

        distances.add(holder.distance);
        holder.distance.setContent(cache.getCoords());
        compasses.add(holder.direction);
        holder.direction.setTargetCoords(cache.getCoords());

        if (cache.isFound() && cache.isLogOffline()) {
            holder.logStatusMark.setImageResource(R.drawable.mark_green_orange);
            holder.logStatusMark.setVisibility(View.VISIBLE);
        } else if (cache.isFound()) {
            holder.logStatusMark.setImageResource(R.drawable.mark_green_more);
            holder.logStatusMark.setVisibility(View.VISIBLE);
        } else if (cache.isLogOffline()) {
            holder.logStatusMark.setImageResource(R.drawable.mark_orange);
            holder.logStatusMark.setVisibility(View.VISIBLE);
        } else {
            holder.logStatusMark.setVisibility(View.GONE);
        }

        Spannable spannable = null;
        if (cache.isDisabled() || cache.isArchived() || DateUtils.isPastEvent(cache)) { // strike
            spannable = Spannable.Factory.getInstance().newSpannable(cache.getName());
            spannable.setSpan(new StrikethroughSpan(), 0, spannable.toString().length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        }
        if (cache.isArchived()) { // red color
            if (spannable == null) {
                spannable = Spannable.Factory.getInstance().newSpannable(cache.getName());
            }
            spannable.setSpan(new ForegroundColorSpan(res.getColor(R.color.archived_cache_color)), 0, spannable.toString().length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        }

        if (spannable != null) {
            holder.text.setText(spannable, TextView.BufferType.SPANNABLE);
        }
        else {
            holder.text.setText(cache.getName());
        }
        holder.text.setCompoundDrawablesWithIntrinsicBounds(getCacheIcon(cache), null, null, null);

        if (cache.getInventoryItems() > 0) {
            holder.inventory.setVisibility(View.VISIBLE);
        } else {
            holder.inventory.setVisibility(View.GONE);
        }

        if (cache.getDistance() != null) {
            holder.distance.setDistance(cache.getDistance());
        }

        if (cache.getCoords() != null && coords != null) {
            holder.distance.update(coords);
        }

        // only show the direction if this is enabled in the settings
        if (isLiveList) {
            if (cache.getCoords() != null) {
                holder.direction.setVisibility(View.VISIBLE);
                holder.dirImg.setVisibility(View.GONE);
                holder.direction.updateAzimuth(azimuth);
                if (coords != null) {
                    holder.direction.updateCurrentCoords(coords);
                }
            } else if (cache.getDirection() != null) {
                holder.direction.setVisibility(View.VISIBLE);
                holder.dirImg.setVisibility(View.GONE);
                holder.direction.updateAzimuth(azimuth);
                holder.direction.updateHeading(cache.getDirection());
            } else if (StringUtils.isNotBlank(cache.getDirectionImg())) {
                holder.dirImg.setImageDrawable(DirectionImage.getDrawable(cache.getDirectionImg()));
                holder.dirImg.setVisibility(View.VISIBLE);
                holder.direction.setVisibility(View.GONE);
            } else {
                holder.dirImg.setVisibility(View.GONE);
                holder.direction.setVisibility(View.GONE);
            }
        }

        holder.favorite.setText(Integer.toString(cache.getFavoritePoints()));

        int favoriteBack;
        // set default background, neither vote nor rating may be available
        if (lightSkin) {
            favoriteBack = R.drawable.favorite_background_light;
        } else {
            favoriteBack = R.drawable.favorite_background_dark;
        }
        final float rating = cache.getRating();
        if (rating >= 3.5) {
            favoriteBack = RATING_BACKGROUND[2];
        } else if (rating >= 2.1) {
            favoriteBack = RATING_BACKGROUND[1];
        } else if (rating > 0.0) {
            favoriteBack = RATING_BACKGROUND[0];
        }
        holder.favorite.setBackgroundResource(favoriteBack);

        if (isHistory() && cache.getVisitedDate() > 0) {
            holder.info.setText(Formatter.formatCacheInfoHistory(cache));
        } else {
            holder.info.setText(Formatter.formatCacheInfoLong(cache, cacheListType));
        }

        return v;
    }

    private static Drawable getCacheIcon(final Geocache cache) {
        int hashCode = getIconHashCode(cache.getType(), cache.hasUserModifiedCoords() || cache.hasFinalDefined());
        final Drawable drawable = gcIconDrawables.get(hashCode);
        if (drawable != null) {
            return drawable;
        }

        // fallback to mystery icon
        hashCode = getIconHashCode(CacheType.MYSTERY, cache.hasUserModifiedCoords() || cache.hasFinalDefined());
        return gcIconDrawables.get(hashCode);
    }

    @Override
    public void notifyDataSetChanged() {
        super.notifyDataSetChanged();
        distances.clear();
        compasses.clear();
    }

    private static class SelectionCheckBoxListener implements View.OnClickListener {

        private final Geocache cache;

        public SelectionCheckBoxListener(final Geocache cache) {
            this.cache = cache;
        }

        @Override
        public void onClick(final View view) {
            assert view instanceof CheckBox;
            final boolean checkNow = ((CheckBox) view).isChecked();
            cache.setStatusChecked(checkNow);
        }
    }

    private static class TouchListener implements View.OnClickListener, View.OnLongClickListener, View.OnTouchListener {

        private final Geocache cache;
        private final GestureDetector gestureDetector;
        private final @NonNull WeakReference<CacheListAdapter> adapterRef;

        public TouchListener(final Geocache cache, final @NonNull CacheListAdapter adapter) {
            this.cache = cache;
            gestureDetector = new GestureDetector(adapter.getContext(), new FlingGesture(cache, adapter));
            adapterRef = new WeakReference<CacheListAdapter>(adapter);
        }

        // Tap on item
        @Override
        public void onClick(final View view) {
            final CacheListAdapter adapter = adapterRef.get();
            if (adapter == null) {
                return;
            }
            if (adapter.isSelectMode()) {
                cache.setStatusChecked(!cache.isStatusChecked());
                adapter.notifyDataSetChanged();
            } else {
                CacheDetailActivity.startActivity(adapter.getContext(), cache.getGeocode(), cache.getName());
            }
        }

        // Long tap on item
        @Override
        public boolean onLongClick(final View view) {
            view.showContextMenu();
            return true;
        }

        // Swipe on item
        @SuppressLint("ClickableViewAccessibility")
        @Override
        public boolean onTouch(final View view, final MotionEvent event) {
            return gestureDetector.onTouchEvent(event);

        }
    }

    private static class FlingGesture extends GestureDetector.SimpleOnGestureListener {

        private final Geocache cache;
        private final @NonNull WeakReference<CacheListAdapter> adapterRef;

        public FlingGesture(final Geocache cache, final @NonNull CacheListAdapter adapter) {
            this.cache = cache;
            adapterRef = new WeakReference<CacheListAdapter>(adapter);
        }

        @Override
        public boolean onFling(final MotionEvent e1, final MotionEvent e2, final float velocityX, final float velocityY) {
            try {
                if (Math.abs(e1.getY() - e2.getY()) > SWIPE_MAX_OFF_PATH) {
                    return false;
                }
                final CacheListAdapter adapter = adapterRef.get();
                if (adapter == null) {
                    return false;
                }

                // left to right swipe
                if ((e2.getX() - e1.getX()) > SWIPE_MIN_DISTANCE && Math.abs(velocityX) > Math.abs(velocityY)) {
                    if (!adapter.selectMode) {
                        adapter.switchSelectMode();
                        cache.setStatusChecked(true);
                    }
                    return true;
                }

                // right to left swipe
                if ((e1.getX() - e2.getX()) > SWIPE_MIN_DISTANCE && Math.abs(velocityX) > Math.abs(velocityY)) {
                    if (adapter.selectMode) {
                        adapter.switchSelectMode();
                    }
                    return true;
                }
            } catch (final Exception e) {
                Log.w("CacheListAdapter.FlingGesture.onFling", e);
            }

            return false;
        }
    }

    public List<Geocache> getFilteredList() {
        return list;
    }

    public List<Geocache> getCheckedCaches() {
        final ArrayList<Geocache> result = new ArrayList<Geocache>();
        for (final Geocache cache : list) {
            if (cache.isStatusChecked()) {
                result.add(cache);
            }
        }
        return result;
    }

    public List<Geocache> getCheckedOrAllCaches() {
        final List<Geocache> result = getCheckedCaches();
        if (!result.isEmpty()) {
            return result;
        }
        return new ArrayList<Geocache>(list);
    }

    public int getCheckedOrAllCount() {
        final int checked = getCheckedCount();
        if (checked > 0) {
            return checked;
        }
        return list.size();
    }

    public void checkEvents() {
        eventsOnly = true;
        for (final Geocache cache : list) {
            if (!cache.isEventCache()) {
                eventsOnly = false;
                return;
            }
        }
    }
}
!@#$%
20190527_004037,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_b14064
package cgeo.geocaching.connector.gc;

import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.R;
import cgeo.geocaching.connector.AbstractLogin;
import cgeo.geocaching.enumerations.StatusCode;
import cgeo.geocaching.network.Cookies;
import cgeo.geocaching.network.HtmlImage;
import cgeo.geocaching.network.Network;
import cgeo.geocaching.network.Parameters;
import cgeo.geocaching.settings.Settings;
import cgeo.geocaching.utils.Log;
import cgeo.geocaching.utils.MatcherWrapper;
import cgeo.geocaching.utils.TextUtils;

import ch.boye.httpclientandroidlib.HttpResponse;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;

import android.graphics.drawable.BitmapDrawable;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

public class GCLogin extends AbstractLogin {

    private static final String DEFAULT_CUSTOM_DATE_FORMAT = "MM/dd/yyyy";

    private final static String ENGLISH = "<a href=\"#\">English&#9660;</a>";

    private final static Map<String, SimpleDateFormat> GC_CUSTOM_DATE_FORMATS;
    public static final String LANGUAGE_CHANGE_URI = "http://www.geocaching.com/my/souvenirs.aspx";

    static {
        final String[] formats = new String[] {
                DEFAULT_CUSTOM_DATE_FORMAT,
                "yyyy-MM-dd",
                "yyyy/MM/dd",
                "dd/MMM/yyyy",
                "MMM/dd/yyyy",
                "dd MMM yy",
                "dd/MM/yyyy"
        };

        final Map<String, SimpleDateFormat> map = new HashMap<>();

        for (final String format : formats) {
            map.put(format, new SimpleDateFormat(format, Locale.ENGLISH));
        }

        GC_CUSTOM_DATE_FORMATS = Collections.unmodifiableMap(map);
    }

    private GCLogin() {
        // singleton
    }

    public static GCLogin getInstance() {
        return SingletonHolder.INSTANCE;
    }

    private static class SingletonHolder {
        private static final GCLogin INSTANCE = new GCLogin();
    }

    @Override
    protected StatusCode login(boolean retry) {
        final ImmutablePair<String, String> credentials = Settings.getGcCredentials();
        final String username = credentials.left;
        final String password = credentials.right;

        if (StringUtils.isEmpty(username) || StringUtils.isEmpty(password)) {
            clearLoginInfo();
            Log.e("Login.login: No login information stored");
            return StatusCode.NO_LOGIN_INFO_STORED;
        }

        setActualStatus(CgeoApplication.getInstance().getString(R.string.init_login_popup_working));
        HttpResponse loginResponse = Network.getRequest("https://www.geocaching.com/login/default.aspx");
        String loginData = Network.getResponseData(loginResponse);
        if (loginResponse != null && loginResponse.getStatusLine().getStatusCode() == 503 && TextUtils.matches(loginData, GCConstants.PATTERN_MAINTENANCE)) {
            return StatusCode.MAINTENANCE;
        }

        if (StringUtils.isBlank(loginData)) {
            Log.e("Login.login: Failed to retrieve login page (1st)");
            return StatusCode.CONNECTION_FAILED; // no login page
        }

        if (getLoginStatus(loginData)) {
            Log.i("Already logged in Geocaching.com as " + username + " (" + Settings.getGCMemberStatus() + ')');
            if (switchToEnglish(loginData) && retry) {
                return login(false);
            }
            return StatusCode.NO_ERROR; // logged in
        }

        Cookies.clearCookies();
        Settings.setCookieStore(null);

        final Parameters params = new Parameters(
                "__EVENTTARGET", "",
                "__EVENTARGUMENT", "",
                "ctl00$ContentBody$tbUsername", username,
                "ctl00$ContentBody$tbPassword", password,
                "ctl00$ContentBody$cbRememberMe", "on",
                "ctl00$ContentBody$btnSignIn", "Login");
        final String[] viewstates = GCLogin.getViewstates(loginData);
        if (isEmpty(viewstates)) {
            Log.e("Login.login: Failed to find viewstates");
            return StatusCode.LOGIN_PARSE_ERROR; // no viewstates
        }
        GCLogin.putViewstates(params, viewstates);

        loginResponse = Network.postRequest("https://www.geocaching.com/login/default.aspx", params);
        loginData = Network.getResponseData(loginResponse);

        if (StringUtils.isBlank(loginData)) {
            Log.e("Login.login: Failed to retrieve login page (2nd)");
            // FIXME: should it be CONNECTION_FAILED to match the first attempt?
            return StatusCode.COMMUNICATION_ERROR; // no login page
        }
        assert loginData != null;  // Caught above

        if (getLoginStatus(loginData)) {
            Log.i("Successfully logged in Geocaching.com as " + username + " (" + Settings.getGCMemberStatus() + ')');

            if (switchToEnglish(loginData) && retry) {
                return login(false);
            }
            Settings.setCookieStore(Cookies.dumpCookieStore());

            return StatusCode.NO_ERROR; // logged in
        }

        if (loginData.contains("Your username/password combination does not match.")) {
            Log.i("Failed to log in Geocaching.com as " + username + " because of wrong username/password");
            return StatusCode.WRONG_LOGIN_DATA; // wrong login
        }

        if (loginData.contains("You must validate your account before you can log in.")) {
            Log.i("Failed to log in Geocaching.com as " + username + " because account needs to be validated first");
            return StatusCode.UNVALIDATED_ACCOUNT;
        }

        Log.i("Failed to log in Geocaching.com as " + username + " for some unknown reason");
        if (retry) {
            switchToEnglish(loginData);
            return login(false);
        }

        return StatusCode.UNKNOWN_ERROR; // can't login
    }

    public StatusCode logout() {
        final HttpResponse logoutResponse = Network.getRequest("https://www.geocaching.com/login/default.aspx?RESET=Y&redir=http%3a%2f%2fwww.geocaching.com%2fdefault.aspx%3f");
        final String logoutData = Network.getResponseData(logoutResponse);
        if (logoutResponse != null && logoutResponse.getStatusLine().getStatusCode() == 503 && TextUtils.matches(logoutData, GCConstants.PATTERN_MAINTENANCE)) {
            return StatusCode.MAINTENANCE;
        }

        resetLoginStatus();

        return StatusCode.NO_ERROR;
    }


    /**
     * Check if the user has been logged in when he retrieved the data.
     *
     * @param page
     * @return <code>true</code> if user is logged in, <code>false</code> otherwise
     */
    public boolean getLoginStatus(@Nullable final String page) {
        if (StringUtils.isBlank(page)) {
            Log.e("Login.checkLogin: No page given");
            return false;
        }
        assert page != null;

        if (TextUtils.matches(page, GCConstants.PATTERN_MAP_LOGGED_IN)) {
            return true;
        }

        setActualStatus(CgeoApplication.getInstance().getString(R.string.init_login_popup_ok));

        // on every page except login page
        setActualLoginStatus(TextUtils.matches(page, GCConstants.PATTERN_LOGIN_NAME));
        if (isActualLoginStatus()) {
            setActualUserName(TextUtils.getMatch(page, GCConstants.PATTERN_LOGIN_NAME, true, "???"));
            int cachesCount = 0;
            try {
                cachesCount = Integer.parseInt(TextUtils.getMatch(page, GCConstants.PATTERN_CACHES_FOUND, true, "0").replaceAll("[,.]", ""));
            } catch (final NumberFormatException e) {
                Log.e("getLoginStatus: bad cache count", e);
            }
            setActualCachesFound(cachesCount);
            Settings.setGCMemberStatus(TextUtils.getMatch(page, GCConstants.PATTERN_MEMBER_STATUS, true, null));
            if (page.contains(GCConstants.MEMBER_STATUS_RENEW)) {
                Settings.setGCMemberStatus(GCConstants.MEMBER_STATUS_PM);
            }
            return true;
        }

        // login page
        setActualLoginStatus(TextUtils.matches(page, GCConstants.PATTERN_LOGIN_NAME_LOGIN_PAGE));
        if (isActualLoginStatus()) {
            setActualUserName(Settings.getUsername());
            // number of caches found is not part of this page
            return true;
        }

        setActualStatus(CgeoApplication.getInstance().getString(R.string.init_login_popup_failed));
        return false;
    }

    /**
     * Ensure that the web site is in English.
     *
     * @param previousPage the content of the last loaded page
     * @return <code>true</code> if a switch was necessary and succesfully performed (non-English -> English)
     */
    private boolean switchToEnglish(String previousPage) {
        if (previousPage != null && previousPage.contains(ENGLISH)) {
            Log.i("Geocaching.com language already set to English");
            // get find count
            getLoginStatus(Network.getResponseData(Network.getRequest("http://www.geocaching.com/email/")));
        } else {
            final String page = Network.getResponseData(Network.getRequest(LANGUAGE_CHANGE_URI));
            getLoginStatus(page);
            if (page == null) {
                Log.e("Failed to read viewstates to set geocaching.com language");
            }
            final Parameters params = new Parameters(
                    "__EVENTTARGET", "ctl00$uxLocaleList$uxLocaleList$ctl00$uxLocaleItem", // switch to english
                    "__EVENTARGUMENT", "");
            GCLogin.transferViewstates(page, params);
            final HttpResponse response = Network.postRequest(LANGUAGE_CHANGE_URI, params, new Parameters("Referer", LANGUAGE_CHANGE_URI));
            if (Network.isSuccess(response)) {
                Log.i("changed language on geocaching.com to English");
                return true;
            }
            Log.e("Failed to set geocaching.com language to English");
        }
        return false;
    }

    public BitmapDrawable downloadAvatarAndGetMemberStatus() {
        try {
            final String responseData = StringUtils.defaultString(Network.getResponseData(Network.getRequest("http://www.geocaching.com/my/")));
            final String profile = TextUtils.replaceWhitespace(responseData);

            Settings.setGCMemberStatus(TextUtils.getMatch(profile, GCConstants.PATTERN_MEMBER_STATUS, true, null));
            if (profile.contains(GCConstants.MEMBER_STATUS_RENEW)) {
                Settings.setGCMemberStatus(GCConstants.MEMBER_STATUS_PM);
            }

            setActualCachesFound(Integer.parseInt(TextUtils.getMatch(profile, GCConstants.PATTERN_CACHES_FOUND, true, "-1").replaceAll("[,.]", "")));

            final String avatarURL = TextUtils.getMatch(profile, GCConstants.PATTERN_AVATAR_IMAGE_PROFILE_PAGE, false, null);
            if (null != avatarURL) {
                final HtmlImage imgGetter = new HtmlImage("", false, 0, false);
                return imgGetter.getDrawable(avatarURL.replace("avatar", "user/large"));
            }
            // No match? There may be no avatar set by user.
            Log.d("No avatar set for user");
        } catch (final Exception e) {
            Log.w("Error when retrieving user avatar", e);
        }
        return null;
    }

    /**
     * Detect user date settings on geocaching.com
     */
    public static void detectGcCustomDate() {

        final String result = Network.getResponseData(Network.getRequest("http://www.geocaching.com/account/ManagePreferences.aspx"));

        if (null == result) {
            Log.w("Login.detectGcCustomDate: result is null");
            return;
        }

        final String customDate = TextUtils.getMatch(result, GCConstants.PATTERN_CUSTOMDATE, true, null);
        if (null != customDate) {
            Settings.setGcCustomDate(customDate);
        }
    }

    public static Date parseGcCustomDate(final String input, final String format) throws ParseException {
        if (StringUtils.isBlank(input)) {
            throw new ParseException("Input is null", 0);
        }

        final String trimmed = input.trim();

        if (GC_CUSTOM_DATE_FORMATS.containsKey(format)) {
            try {
                return GC_CUSTOM_DATE_FORMATS.get(format).parse(trimmed);
            } catch (final ParseException e) {
            }
        }

        for (final SimpleDateFormat sdf : GC_CUSTOM_DATE_FORMATS.values()) {
            try {
                return sdf.parse(trimmed);
            } catch (final ParseException e) {
            }
        }

        throw new ParseException("No matching pattern", 0);
    }

    public static Date parseGcCustomDate(final String input) throws ParseException {
        return parseGcCustomDate(input, Settings.getGcCustomDate());
    }

    public static SimpleDateFormat getCustomGcDateFormat() {
        final String format = Settings.getGcCustomDate();
        if (GC_CUSTOM_DATE_FORMATS.containsKey(format)) {
            return GC_CUSTOM_DATE_FORMATS.get(format);
        }

        return GC_CUSTOM_DATE_FORMATS.get(DEFAULT_CUSTOM_DATE_FORMAT);
    }

    /**
     * checks if an Array of Strings is empty or not. Empty means:
     * - Array is null
     * - or all elements are null or empty strings
     */
    public static boolean isEmpty(String[] a) {
        if (a == null) {
            return true;
        }

        for (final String s : a) {
            if (StringUtils.isNotEmpty(s)) {
                return false;
            }
        }
        return true;
    }

    /**
     * read all viewstates from page
     *
     * @return String[] with all view states
     */
    public static String[] getViewstates(String page) {
        // Get the number of viewstates.
        // If there is only one viewstate, __VIEWSTATEFIELDCOUNT is not present

        if (page == null) { // no network access
            return null;
        }

        int count = 1;
        final MatcherWrapper matcherViewstateCount = new MatcherWrapper(GCConstants.PATTERN_VIEWSTATEFIELDCOUNT, page);
        if (matcherViewstateCount.find()) {
            try {
                count = Integer.parseInt(matcherViewstateCount.group(1));
            } catch (final NumberFormatException e) {
                Log.e("getViewStates", e);
            }
        }

        final String[] viewstates = new String[count];

        // Get the viewstates
        final MatcherWrapper matcherViewstates = new MatcherWrapper(GCConstants.PATTERN_VIEWSTATES, page);
        while (matcherViewstates.find()) {
            final String sno = matcherViewstates.group(1); // number of viewstate
            int no;
            if (StringUtils.isEmpty(sno)) {
                no = 0;
            } else {
                try {
                    no = Integer.parseInt(sno);
                } catch (final NumberFormatException e) {
                    Log.e("getViewStates", e);
                    no = 0;
                }
            }
            viewstates[no] = matcherViewstates.group(2);
        }

        if (viewstates.length != 1 || viewstates[0] != null) {
            return viewstates;
        }
        // no viewstates were present
        return null;
    }

    /**
     * put viewstates into request parameters
     */
    public static void putViewstates(final Parameters params, final String[] viewstates) {
        if (ArrayUtils.isEmpty(viewstates)) {
            return;
        }
        params.put("__VIEWSTATE", viewstates[0]);
        if (viewstates.length > 1) {
            for (int i = 1; i < viewstates.length; i++) {
                params.put("__VIEWSTATE" + i, viewstates[i]);
            }
            params.put("__VIEWSTATEFIELDCOUNT", String.valueOf(viewstates.length));
        }
    }

    /**
     * transfers the viewstates variables from a page (response) to parameters
     * (next request)
     */
    public static void transferViewstates(final String page, final Parameters params) {
        putViewstates(params, getViewstates(page));
    }

    /**
     * POST HTTP request. Do the request a second time if the user is not logged in
     *
     * @param uri
     * @return
     */
    public String postRequestLogged(final String uri, final Parameters params) {
        final String data = Network.getResponseData(Network.postRequest(uri, params));

        if (getLoginStatus(data)) {
            return data;
        }

        if (login() == StatusCode.NO_ERROR) {
            return Network.getResponseData(Network.postRequest(uri, params));
        }

        Log.i("Working as guest.");
        return data;
    }

    /**
     * GET HTTP request. Do the request a second time if the user is not logged in
     *
     * @param uri
     * @param params
     * @return
     */
    @Nullable
    public String getRequestLogged(@NonNull final String uri, @Nullable final Parameters params) {
        final HttpResponse response = Network.getRequest(uri, params);
        final String data = Network.getResponseData(response, canRemoveWhitespace(uri));

        // A page not found will not be found if the user logs in either
        if (Network.isPageNotFound(response) || getLoginStatus(data)) {
            return data;
        }

        if (login() == StatusCode.NO_ERROR) {
            return Network.getResponseData(Network.getRequest(uri, params), canRemoveWhitespace(uri));
        }

        Log.w("Working as guest.");
        return data;
    }

    /**
     * Unfortunately the cache details page contains user generated whitespace in the personal note, therefore we cannot
     * remove the white space from cache details pages.
     *
     * @param uri
     * @return
     */
    private static boolean canRemoveWhitespace(final String uri) {
        return !StringUtils.contains(uri, "cache_details");
    }

    /**
     * Get user session & session token from the Live Map. Needed for following requests.
     *
     * @return first is user session, second is session token
     */
    public @NonNull
    MapTokens getMapTokens() {
        final String data = getRequestLogged(GCConstants.URL_LIVE_MAP, null);
        final String userSession = TextUtils.getMatch(data, GCConstants.PATTERN_USERSESSION, "");
        final String sessionToken = TextUtils.getMatch(data, GCConstants.PATTERN_SESSIONTOKEN, "");
        return new MapTokens(userSession, sessionToken);
    }

}
!@#$%
20190527_004037,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_a14064
package cgeo.geocaching.connector.gc;

import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.R;
import cgeo.geocaching.connector.AbstractLogin;
import cgeo.geocaching.enumerations.StatusCode;
import cgeo.geocaching.network.Cookies;
import cgeo.geocaching.network.HtmlImage;
import cgeo.geocaching.network.Network;
import cgeo.geocaching.network.Parameters;
import cgeo.geocaching.settings.Settings;
import cgeo.geocaching.utils.Log;
import cgeo.geocaching.utils.MatcherWrapper;
import cgeo.geocaching.utils.TextUtils;

import ch.boye.httpclientandroidlib.HttpResponse;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;

import android.graphics.drawable.BitmapDrawable;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

public class GCLogin extends AbstractLogin {

    private static final String DEFAULT_CUSTOM_DATE_FORMAT = "MM/dd/yyyy";

    private final static String ENGLISH = "<a href=\"#\">English&#9660;</a>";

    private final static Map<String, SimpleDateFormat> GC_CUSTOM_DATE_FORMATS;
    public static final String LANGUAGE_CHANGE_URI = "http://www.geocaching.com/my/souvenirs.aspx";

    static {
        final String[] formats = new String[] {
                DEFAULT_CUSTOM_DATE_FORMAT,
                "yyyy-MM-dd",
                "yyyy/MM/dd",
                "dd/MMM/yyyy",
                "MMM/dd/yyyy",
                "dd MMM yy",
                "dd/MM/yyyy"
        };

        final Map<String, SimpleDateFormat> map = new HashMap<String, SimpleDateFormat>();

        for (final String format : formats) {
            map.put(format, new SimpleDateFormat(format, Locale.ENGLISH));
        }

        GC_CUSTOM_DATE_FORMATS = Collections.unmodifiableMap(map);
    }

    private GCLogin() {
        // singleton
    }

    public static GCLogin getInstance() {
        return SingletonHolder.INSTANCE;
    }

    private static class SingletonHolder {
        private static final GCLogin INSTANCE = new GCLogin();
    }

    @Override
    protected StatusCode login(boolean retry) {
        final ImmutablePair<String, String> credentials = Settings.getGcCredentials();
        final String username = credentials.left;
        final String password = credentials.right;

        if (StringUtils.isEmpty(username) || StringUtils.isEmpty(password)) {
            clearLoginInfo();
            Log.e("Login.login: No login information stored");
            return StatusCode.NO_LOGIN_INFO_STORED;
        }

        setActualStatus(CgeoApplication.getInstance().getString(R.string.init_login_popup_working));
        HttpResponse loginResponse = Network.getRequest("https://www.geocaching.com/login/default.aspx");
        String loginData = Network.getResponseData(loginResponse);
        if (loginResponse != null && loginResponse.getStatusLine().getStatusCode() == 503 && TextUtils.matches(loginData, GCConstants.PATTERN_MAINTENANCE)) {
            return StatusCode.MAINTENANCE;
        }

        if (StringUtils.isBlank(loginData)) {
            Log.e("Login.login: Failed to retrieve login page (1st)");
            return StatusCode.CONNECTION_FAILED; // no login page
        }

        if (getLoginStatus(loginData)) {
            Log.i("Already logged in Geocaching.com as " + username + " (" + Settings.getGCMemberStatus() + ')');
            if (switchToEnglish(loginData) && retry) {
                return login(false);
            }
            return StatusCode.NO_ERROR; // logged in
        }

        Cookies.clearCookies();
        Settings.setCookieStore(null);

        final Parameters params = new Parameters(
                "__EVENTTARGET", "",
                "__EVENTARGUMENT", "",
                "ctl00$ContentBody$tbUsername", username,
                "ctl00$ContentBody$tbPassword", password,
                "ctl00$ContentBody$cbRememberMe", "on",
                "ctl00$ContentBody$btnSignIn", "Login");
        final String[] viewstates = GCLogin.getViewstates(loginData);
        if (isEmpty(viewstates)) {
            Log.e("Login.login: Failed to find viewstates");
            return StatusCode.LOGIN_PARSE_ERROR; // no viewstates
        }
        GCLogin.putViewstates(params, viewstates);

        loginResponse = Network.postRequest("https://www.geocaching.com/login/default.aspx", params);
        loginData = Network.getResponseData(loginResponse);

        if (StringUtils.isBlank(loginData)) {
            Log.e("Login.login: Failed to retrieve login page (2nd)");
            // FIXME: should it be CONNECTION_FAILED to match the first attempt?
            return StatusCode.COMMUNICATION_ERROR; // no login page
        }
        assert loginData != null;  // Caught above

        if (getLoginStatus(loginData)) {
            Log.i("Successfully logged in Geocaching.com as " + username + " (" + Settings.getGCMemberStatus() + ')');

            if (switchToEnglish(loginData) && retry) {
                return login(false);
            }
            Settings.setCookieStore(Cookies.dumpCookieStore());

            return StatusCode.NO_ERROR; // logged in
        }

        if (loginData.contains("Your username/password combination does not match.")) {
            Log.i("Failed to log in Geocaching.com as " + username + " because of wrong username/password");
            return StatusCode.WRONG_LOGIN_DATA; // wrong login
        }

        if (loginData.contains("You must validate your account before you can log in.")) {
            Log.i("Failed to log in Geocaching.com as " + username + " because account needs to be validated first");
            return StatusCode.UNVALIDATED_ACCOUNT;
        }

        Log.i("Failed to log in Geocaching.com as " + username + " for some unknown reason");
        if (retry) {
            switchToEnglish(loginData);
            return login(false);
        }

        return StatusCode.UNKNOWN_ERROR; // can't login
    }

    public StatusCode logout() {
        final HttpResponse logoutResponse = Network.getRequest("https://www.geocaching.com/login/default.aspx?RESET=Y&redir=http%3a%2f%2fwww.geocaching.com%2fdefault.aspx%3f");
        final String logoutData = Network.getResponseData(logoutResponse);
        if (logoutResponse != null && logoutResponse.getStatusLine().getStatusCode() == 503 && TextUtils.matches(logoutData, GCConstants.PATTERN_MAINTENANCE)) {
            return StatusCode.MAINTENANCE;
        }

        resetLoginStatus();

        return StatusCode.NO_ERROR;
    }


    /**
     * Check if the user has been logged in when he retrieved the data.
     *
     * @param page
     * @return <code>true</code> if user is logged in, <code>false</code> otherwise
     */
    public boolean getLoginStatus(@Nullable final String page) {
        if (StringUtils.isBlank(page)) {
            Log.e("Login.checkLogin: No page given");
            return false;
        }
        assert page != null;

        if (TextUtils.matches(page, GCConstants.PATTERN_MAP_LOGGED_IN)) {
            return true;
        }

        setActualStatus(CgeoApplication.getInstance().getString(R.string.init_login_popup_ok));

        // on every page except login page
        setActualLoginStatus(TextUtils.matches(page, GCConstants.PATTERN_LOGIN_NAME));
        if (isActualLoginStatus()) {
            setActualUserName(TextUtils.getMatch(page, GCConstants.PATTERN_LOGIN_NAME, true, "???"));
            int cachesCount = 0;
            try {
                cachesCount = Integer.parseInt(TextUtils.getMatch(page, GCConstants.PATTERN_CACHES_FOUND, true, "0").replaceAll("[,.]", ""));
            } catch (final NumberFormatException e) {
                Log.e("getLoginStatus: bad cache count", e);
            }
            setActualCachesFound(cachesCount);
            Settings.setGCMemberStatus(TextUtils.getMatch(page, GCConstants.PATTERN_MEMBER_STATUS, true, null));
            if (page.contains(GCConstants.MEMBER_STATUS_RENEW)) {
                Settings.setGCMemberStatus(GCConstants.MEMBER_STATUS_PM);
            }
            return true;
        }

        // login page
        setActualLoginStatus(TextUtils.matches(page, GCConstants.PATTERN_LOGIN_NAME_LOGIN_PAGE));
        if (isActualLoginStatus()) {
            setActualUserName(Settings.getUsername());
            // number of caches found is not part of this page
            return true;
        }

        setActualStatus(CgeoApplication.getInstance().getString(R.string.init_login_popup_failed));
        return false;
    }

    /**
     * Ensure that the web site is in English.
     *
     * @param previousPage the content of the last loaded page
     * @return <code>true</code> if a switch was necessary and succesfully performed (non-English -> English)
     */
    private boolean switchToEnglish(String previousPage) {
        if (previousPage != null && previousPage.contains(ENGLISH)) {
            Log.i("Geocaching.com language already set to English");
            // get find count
            getLoginStatus(Network.getResponseData(Network.getRequest("http://www.geocaching.com/email/")));
        } else {
            final String page = Network.getResponseData(Network.getRequest(LANGUAGE_CHANGE_URI));
            getLoginStatus(page);
            if (page == null) {
                Log.e("Failed to read viewstates to set geocaching.com language");
            }
            final Parameters params = new Parameters(
                    "__EVENTTARGET", "ctl00$uxLocaleList$uxLocaleList$ctl00$uxLocaleItem", // switch to english
                    "__EVENTARGUMENT", "");
            GCLogin.transferViewstates(page, params);
            final HttpResponse response = Network.postRequest(LANGUAGE_CHANGE_URI, params, new Parameters("Referer", LANGUAGE_CHANGE_URI));
            if (Network.isSuccess(response)) {
                Log.i("changed language on geocaching.com to English");
                return true;
            }
            Log.e("Failed to set geocaching.com language to English");
        }
        return false;
    }

    public BitmapDrawable downloadAvatarAndGetMemberStatus() {
        try {
            final String responseData = StringUtils.defaultString(Network.getResponseData(Network.getRequest("http://www.geocaching.com/my/")));
            final String profile = TextUtils.replaceWhitespace(responseData);

            Settings.setGCMemberStatus(TextUtils.getMatch(profile, GCConstants.PATTERN_MEMBER_STATUS, true, null));
            if (profile.contains(GCConstants.MEMBER_STATUS_RENEW)) {
                Settings.setGCMemberStatus(GCConstants.MEMBER_STATUS_PM);
            }

            setActualCachesFound(Integer.parseInt(TextUtils.getMatch(profile, GCConstants.PATTERN_CACHES_FOUND, true, "-1").replaceAll("[,.]", "")));

            final String avatarURL = TextUtils.getMatch(profile, GCConstants.PATTERN_AVATAR_IMAGE_PROFILE_PAGE, false, null);
            if (null != avatarURL) {
                final HtmlImage imgGetter = new HtmlImage("", false, 0, false);
                return imgGetter.getDrawable(avatarURL.replace("avatar", "user/large"));
            }
            // No match? There may be no avatar set by user.
            Log.d("No avatar set for user");
        } catch (final Exception e) {
            Log.w("Error when retrieving user avatar", e);
        }
        return null;
    }

    /**
     * Detect user date settings on geocaching.com
     */
    public static void detectGcCustomDate() {

        final String result = Network.getResponseData(Network.getRequest("http://www.geocaching.com/account/ManagePreferences.aspx"));

        if (null == result) {
            Log.w("Login.detectGcCustomDate: result is null");
            return;
        }

        final String customDate = TextUtils.getMatch(result, GCConstants.PATTERN_CUSTOMDATE, true, null);
        if (null != customDate) {
            Settings.setGcCustomDate(customDate);
        }
    }

    public static Date parseGcCustomDate(final String input, final String format) throws ParseException {
        if (StringUtils.isBlank(input)) {
            throw new ParseException("Input is null", 0);
        }

        final String trimmed = input.trim();

        if (GC_CUSTOM_DATE_FORMATS.containsKey(format)) {
            try {
                return GC_CUSTOM_DATE_FORMATS.get(format).parse(trimmed);
            } catch (final ParseException e) {
            }
        }

        for (final SimpleDateFormat sdf : GC_CUSTOM_DATE_FORMATS.values()) {
            try {
                return sdf.parse(trimmed);
            } catch (final ParseException e) {
            }
        }

        throw new ParseException("No matching pattern", 0);
    }

    public static Date parseGcCustomDate(final String input) throws ParseException {
        return parseGcCustomDate(input, Settings.getGcCustomDate());
    }

    public static SimpleDateFormat getCustomGcDateFormat() {
        final String format = Settings.getGcCustomDate();
        if (GC_CUSTOM_DATE_FORMATS.containsKey(format)) {
            return GC_CUSTOM_DATE_FORMATS.get(format);
        }

        return GC_CUSTOM_DATE_FORMATS.get(DEFAULT_CUSTOM_DATE_FORMAT);
    }

    /**
     * checks if an Array of Strings is empty or not. Empty means:
     * - Array is null
     * - or all elements are null or empty strings
     */
    public static boolean isEmpty(String[] a) {
        if (a == null) {
            return true;
        }

        for (final String s : a) {
            if (StringUtils.isNotEmpty(s)) {
                return false;
            }
        }
        return true;
    }

    /**
     * read all viewstates from page
     *
     * @return String[] with all view states
     */
    public static String[] getViewstates(String page) {
        // Get the number of viewstates.
        // If there is only one viewstate, __VIEWSTATEFIELDCOUNT is not present

        if (page == null) { // no network access
            return null;
        }

        int count = 1;
        final MatcherWrapper matcherViewstateCount = new MatcherWrapper(GCConstants.PATTERN_VIEWSTATEFIELDCOUNT, page);
        if (matcherViewstateCount.find()) {
            try {
                count = Integer.parseInt(matcherViewstateCount.group(1));
            } catch (final NumberFormatException e) {
                Log.e("getViewStates", e);
            }
        }

        final String[] viewstates = new String[count];

        // Get the viewstates
        final MatcherWrapper matcherViewstates = new MatcherWrapper(GCConstants.PATTERN_VIEWSTATES, page);
        while (matcherViewstates.find()) {
            final String sno = matcherViewstates.group(1); // number of viewstate
            int no;
            if (StringUtils.isEmpty(sno)) {
                no = 0;
            } else {
                try {
                    no = Integer.parseInt(sno);
                } catch (final NumberFormatException e) {
                    Log.e("getViewStates", e);
                    no = 0;
                }
            }
            viewstates[no] = matcherViewstates.group(2);
        }

        if (viewstates.length != 1 || viewstates[0] != null) {
            return viewstates;
        }
        // no viewstates were present
        return null;
    }

    /**
     * put viewstates into request parameters
     */
    public static void putViewstates(final Parameters params, final String[] viewstates) {
        if (ArrayUtils.isEmpty(viewstates)) {
            return;
        }
        params.put("__VIEWSTATE", viewstates[0]);
        if (viewstates.length > 1) {
            for (int i = 1; i < viewstates.length; i++) {
                params.put("__VIEWSTATE" + i, viewstates[i]);
            }
            params.put("__VIEWSTATEFIELDCOUNT", String.valueOf(viewstates.length));
        }
    }

    /**
     * transfers the viewstates variables from a page (response) to parameters
     * (next request)
     */
    public static void transferViewstates(final String page, final Parameters params) {
        putViewstates(params, getViewstates(page));
    }

    /**
     * POST HTTP request. Do the request a second time if the user is not logged in
     *
     * @param uri
     * @return
     */
    public String postRequestLogged(final String uri, final Parameters params) {
        final String data = Network.getResponseData(Network.postRequest(uri, params));

        if (getLoginStatus(data)) {
            return data;
        }

        if (login() == StatusCode.NO_ERROR) {
            return Network.getResponseData(Network.postRequest(uri, params));
        }

        Log.i("Working as guest.");
        return data;
    }

    /**
     * GET HTTP request. Do the request a second time if the user is not logged in
     *
     * @param uri
     * @param params
     * @return
     */
    @Nullable
    public String getRequestLogged(@NonNull final String uri, @Nullable final Parameters params) {
        final HttpResponse response = Network.getRequest(uri, params);
        final String data = Network.getResponseData(response, canRemoveWhitespace(uri));

        // A page not found will not be found if the user logs in either
        if (Network.isPageNotFound(response) || getLoginStatus(data)) {
            return data;
        }

        if (login() == StatusCode.NO_ERROR) {
            return Network.getResponseData(Network.getRequest(uri, params), canRemoveWhitespace(uri));
        }

        Log.w("Working as guest.");
        return data;
    }

    /**
     * Unfortunately the cache details page contains user generated whitespace in the personal note, therefore we cannot
     * remove the white space from cache details pages.
     *
     * @param uri
     * @return
     */
    private static boolean canRemoveWhitespace(final String uri) {
        return !StringUtils.contains(uri, "cache_details");
    }

    /**
     * Get user session & session token from the Live Map. Needed for following requests.
     *
     * @return first is user session, second is session token
     */
    public @NonNull
    MapTokens getMapTokens() {
        final String data = getRequestLogged(GCConstants.URL_LIVE_MAP, null);
        final String userSession = TextUtils.getMatch(data, GCConstants.PATTERN_USERSESSION, "");
        final String sessionToken = TextUtils.getMatch(data, GCConstants.PATTERN_SESSIONTOKEN, "");
        return new MapTokens(userSession, sessionToken);
    }

}
!@#$%
20190527_004037,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_c14064
package cgeo.geocaching.connector.gc;

import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.R;
import cgeo.geocaching.connector.AbstractLogin;
import cgeo.geocaching.enumerations.StatusCode;
import cgeo.geocaching.network.Cookies;
import cgeo.geocaching.network.HtmlImage;
import cgeo.geocaching.network.Network;
import cgeo.geocaching.network.Parameters;
import cgeo.geocaching.settings.Settings;
import cgeo.geocaching.utils.Log;
import cgeo.geocaching.utils.MatcherWrapper;
import cgeo.geocaching.utils.TextUtils;

import ch.boye.httpclientandroidlib.HttpResponse;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;

import android.graphics.drawable.BitmapDrawable;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

public class GCLogin extends AbstractLogin {

    private static final String DEFAULT_CUSTOM_DATE_FORMAT = "MM/dd/yyyy";

    private final static String ENGLISH = "<a href=\"#\">English &#9660;</a>";

    private final static Map<String, SimpleDateFormat> GC_CUSTOM_DATE_FORMATS;
    public static final String LANGUAGE_CHANGE_URI = "http://www.geocaching.com/my/souvenirs.aspx";

    static {
        final String[] formats = new String[] {
                DEFAULT_CUSTOM_DATE_FORMAT,
                "yyyy-MM-dd",
                "yyyy/MM/dd",
                "dd/MMM/yyyy",
                "MMM/dd/yyyy",
                "dd MMM yy",
                "dd/MM/yyyy"
        };

        final Map<String, SimpleDateFormat> map = new HashMap<String, SimpleDateFormat>();

        for (final String format : formats) {
            map.put(format, new SimpleDateFormat(format, Locale.ENGLISH));
        }

        GC_CUSTOM_DATE_FORMATS = Collections.unmodifiableMap(map);
    }

    private GCLogin() {
        // singleton
    }

    public static GCLogin getInstance() {
        return SingletonHolder.INSTANCE;
    }

    private static class SingletonHolder {
        private static final GCLogin INSTANCE = new GCLogin();
    }

    @Override
    protected StatusCode login(boolean retry) {
        final ImmutablePair<String, String> credentials = Settings.getGcCredentials();
        final String username = credentials.left;
        final String password = credentials.right;

        if (StringUtils.isEmpty(username) || StringUtils.isEmpty(password)) {
            clearLoginInfo();
            Log.e("Login.login: No login information stored");
            return StatusCode.NO_LOGIN_INFO_STORED;
        }

        setActualStatus(CgeoApplication.getInstance().getString(R.string.init_login_popup_working));
        HttpResponse loginResponse = Network.getRequest("https://www.geocaching.com/login/default.aspx");
        String loginData = Network.getResponseData(loginResponse);
        if (loginResponse != null && loginResponse.getStatusLine().getStatusCode() == 503 && TextUtils.matches(loginData, GCConstants.PATTERN_MAINTENANCE)) {
            return StatusCode.MAINTENANCE;
        }

        if (StringUtils.isBlank(loginData)) {
            Log.e("Login.login: Failed to retrieve login page (1st)");
            return StatusCode.CONNECTION_FAILED; // no login page
        }

        if (getLoginStatus(loginData)) {
            Log.i("Already logged in Geocaching.com as " + username + " (" + Settings.getGCMemberStatus() + ')');
            if (switchToEnglish(loginData) && retry) {
                return login(false);
            }
            return StatusCode.NO_ERROR; // logged in
        }

        Cookies.clearCookies();
        Settings.setCookieStore(null);

        final Parameters params = new Parameters(
                "__EVENTTARGET", "",
                "__EVENTARGUMENT", "",
                "ctl00$ContentBody$tbUsername", username,
                "ctl00$ContentBody$tbPassword", password,
                "ctl00$ContentBody$cbRememberMe", "on",
                "ctl00$ContentBody$btnSignIn", "Login");
        final String[] viewstates = GCLogin.getViewstates(loginData);
        if (isEmpty(viewstates)) {
            Log.e("Login.login: Failed to find viewstates");
            return StatusCode.LOGIN_PARSE_ERROR; // no viewstates
        }
        GCLogin.putViewstates(params, viewstates);

        loginResponse = Network.postRequest("https://www.geocaching.com/login/default.aspx", params);
        loginData = Network.getResponseData(loginResponse);

        if (StringUtils.isBlank(loginData)) {
            Log.e("Login.login: Failed to retrieve login page (2nd)");
            // FIXME: should it be CONNECTION_FAILED to match the first attempt?
            return StatusCode.COMMUNICATION_ERROR; // no login page
        }
        assert loginData != null;  // Caught above

        if (getLoginStatus(loginData)) {
            Log.i("Successfully logged in Geocaching.com as " + username + " (" + Settings.getGCMemberStatus() + ')');

            if (switchToEnglish(loginData) && retry) {
                return login(false);
            }
            Settings.setCookieStore(Cookies.dumpCookieStore());

            return StatusCode.NO_ERROR; // logged in
        }

        if (loginData.contains("Your username/password combination does not match.")) {
            Log.i("Failed to log in Geocaching.com as " + username + " because of wrong username/password");
            return StatusCode.WRONG_LOGIN_DATA; // wrong login
        }

        if (loginData.contains("You must validate your account before you can log in.")) {
            Log.i("Failed to log in Geocaching.com as " + username + " because account needs to be validated first");
            return StatusCode.UNVALIDATED_ACCOUNT;
        }

        Log.i("Failed to log in Geocaching.com as " + username + " for some unknown reason");
        if (retry) {
            switchToEnglish(loginData);
            return login(false);
        }

        return StatusCode.UNKNOWN_ERROR; // can't login
    }

    public StatusCode logout() {
        final HttpResponse logoutResponse = Network.getRequest("https://www.geocaching.com/login/default.aspx?RESET=Y&redir=http%3a%2f%2fwww.geocaching.com%2fdefault.aspx%3f");
        final String logoutData = Network.getResponseData(logoutResponse);
        if (logoutResponse != null && logoutResponse.getStatusLine().getStatusCode() == 503 && TextUtils.matches(logoutData, GCConstants.PATTERN_MAINTENANCE)) {
            return StatusCode.MAINTENANCE;
        }

        resetLoginStatus();

        return StatusCode.NO_ERROR;
    }


    /**
     * Check if the user has been logged in when he retrieved the data.
     *
     * @param page
     * @return <code>true</code> if user is logged in, <code>false</code> otherwise
     */
    public boolean getLoginStatus(@Nullable final String page) {
        if (StringUtils.isBlank(page)) {
            Log.e("Login.checkLogin: No page given");
            return false;
        }
        assert page != null;

        if (TextUtils.matches(page, GCConstants.PATTERN_MAP_LOGGED_IN)) {
            return true;
        }

        setActualStatus(CgeoApplication.getInstance().getString(R.string.init_login_popup_ok));

        // on every page except login page
        setActualLoginStatus(TextUtils.matches(page, GCConstants.PATTERN_LOGIN_NAME));
        if (isActualLoginStatus()) {
            setActualUserName(TextUtils.getMatch(page, GCConstants.PATTERN_LOGIN_NAME, true, "???"));
            int cachesCount = 0;
            try {
                cachesCount = Integer.parseInt(TextUtils.getMatch(page, GCConstants.PATTERN_CACHES_FOUND, true, "0").replaceAll("[,.]", ""));
            } catch (final NumberFormatException e) {
                Log.e("getLoginStatus: bad cache count", e);
            }
            setActualCachesFound(cachesCount);
            Settings.setGCMemberStatus(TextUtils.getMatch(page, GCConstants.PATTERN_MEMBER_STATUS, true, null));
            if (page.contains(GCConstants.MEMBER_STATUS_RENEW)) {
                Settings.setGCMemberStatus(GCConstants.MEMBER_STATUS_PM);
            }
            return true;
        }

        // login page
        setActualLoginStatus(TextUtils.matches(page, GCConstants.PATTERN_LOGIN_NAME_LOGIN_PAGE));
        if (isActualLoginStatus()) {
            setActualUserName(Settings.getUsername());
            // number of caches found is not part of this page
            return true;
        }

        setActualStatus(CgeoApplication.getInstance().getString(R.string.init_login_popup_failed));
        return false;
    }

    /**
     * Ensure that the web site is in English.
     *
     * @param previousPage the content of the last loaded page
     * @return <code>true</code> if a switch was necessary and succesfully performed (non-English -> English)
     */
    private boolean switchToEnglish(String previousPage) {
        if (previousPage != null && previousPage.contains(ENGLISH)) {
            Log.i("Geocaching.com language already set to English");
            // get find count
            getLoginStatus(Network.getResponseData(Network.getRequest("http://www.geocaching.com/email/")));
        } else {
            final String page = Network.getResponseData(Network.getRequest(LANGUAGE_CHANGE_URI));
            getLoginStatus(page);
            if (page == null) {
                Log.e("Failed to read viewstates to set geocaching.com language");
            }
            final Parameters params = new Parameters(
                    "__EVENTTARGET", "ctl00$uxLocaleList$uxLocaleList$ctl00$uxLocaleItem", // switch to english
                    "__EVENTARGUMENT", "");
            GCLogin.transferViewstates(page, params);
            final HttpResponse response = Network.postRequest(LANGUAGE_CHANGE_URI, params, new Parameters("Referer", LANGUAGE_CHANGE_URI));
            if (Network.isSuccess(response)) {
                Log.i("changed language on geocaching.com to English");
                return true;
            }
            Log.e("Failed to set geocaching.com language to English");
        }
        return false;
    }

    public BitmapDrawable downloadAvatarAndGetMemberStatus() {
        try {
            final String responseData = StringUtils.defaultString(Network.getResponseData(Network.getRequest("http://www.geocaching.com/my/")));
            final String profile = TextUtils.replaceWhitespace(responseData);

            Settings.setGCMemberStatus(TextUtils.getMatch(profile, GCConstants.PATTERN_MEMBER_STATUS, true, null));
            if (profile.contains(GCConstants.MEMBER_STATUS_RENEW)) {
                Settings.setGCMemberStatus(GCConstants.MEMBER_STATUS_PM);
            }

            setActualCachesFound(Integer.parseInt(TextUtils.getMatch(profile, GCConstants.PATTERN_CACHES_FOUND, true, "-1").replaceAll("[,.]", "")));

            final String avatarURL = TextUtils.getMatch(profile, GCConstants.PATTERN_AVATAR_IMAGE_PROFILE_PAGE, false, null);
            if (null != avatarURL) {
                final HtmlImage imgGetter = new HtmlImage("", false, 0, false);
                return imgGetter.getDrawable(avatarURL.replace("avatar", "user/large"));
            }
            // No match? There may be no avatar set by user.
            Log.d("No avatar set for user");
        } catch (final Exception e) {
            Log.w("Error when retrieving user avatar", e);
        }
        return null;
    }

    /**
     * Detect user date settings on geocaching.com
     */
    public static void detectGcCustomDate() {

        final String result = Network.getResponseData(Network.getRequest("http://www.geocaching.com/account/ManagePreferences.aspx"));

        if (null == result) {
            Log.w("Login.detectGcCustomDate: result is null");
            return;
        }

        final String customDate = TextUtils.getMatch(result, GCConstants.PATTERN_CUSTOMDATE, true, null);
        if (null != customDate) {
            Settings.setGcCustomDate(customDate);
        }
    }

    public static Date parseGcCustomDate(final String input, final String format) throws ParseException {
        if (StringUtils.isBlank(input)) {
            throw new ParseException("Input is null", 0);
        }

        final String trimmed = input.trim();

        if (GC_CUSTOM_DATE_FORMATS.containsKey(format)) {
            try {
                return GC_CUSTOM_DATE_FORMATS.get(format).parse(trimmed);
            } catch (final ParseException e) {
            }
        }

        for (final SimpleDateFormat sdf : GC_CUSTOM_DATE_FORMATS.values()) {
            try {
                return sdf.parse(trimmed);
            } catch (final ParseException e) {
            }
        }

        throw new ParseException("No matching pattern", 0);
    }

    public static Date parseGcCustomDate(final String input) throws ParseException {
        return parseGcCustomDate(input, Settings.getGcCustomDate());
    }

    public static SimpleDateFormat getCustomGcDateFormat() {
        final String format = Settings.getGcCustomDate();
        if (GC_CUSTOM_DATE_FORMATS.containsKey(format)) {
            return GC_CUSTOM_DATE_FORMATS.get(format);
        }

        return GC_CUSTOM_DATE_FORMATS.get(DEFAULT_CUSTOM_DATE_FORMAT);
    }

    /**
     * checks if an Array of Strings is empty or not. Empty means:
     * - Array is null
     * - or all elements are null or empty strings
     */
    public static boolean isEmpty(String[] a) {
        if (a == null) {
            return true;
        }

        for (final String s : a) {
            if (StringUtils.isNotEmpty(s)) {
                return false;
            }
        }
        return true;
    }

    /**
     * read all viewstates from page
     *
     * @return String[] with all view states
     */
    public static String[] getViewstates(String page) {
        // Get the number of viewstates.
        // If there is only one viewstate, __VIEWSTATEFIELDCOUNT is not present

        if (page == null) { // no network access
            return null;
        }

        int count = 1;
        final MatcherWrapper matcherViewstateCount = new MatcherWrapper(GCConstants.PATTERN_VIEWSTATEFIELDCOUNT, page);
        if (matcherViewstateCount.find()) {
            try {
                count = Integer.parseInt(matcherViewstateCount.group(1));
            } catch (final NumberFormatException e) {
                Log.e("getViewStates", e);
            }
        }

        final String[] viewstates = new String[count];

        // Get the viewstates
        final MatcherWrapper matcherViewstates = new MatcherWrapper(GCConstants.PATTERN_VIEWSTATES, page);
        while (matcherViewstates.find()) {
            final String sno = matcherViewstates.group(1); // number of viewstate
            int no;
            if (StringUtils.isEmpty(sno)) {
                no = 0;
            } else {
                try {
                    no = Integer.parseInt(sno);
                } catch (final NumberFormatException e) {
                    Log.e("getViewStates", e);
                    no = 0;
                }
            }
            viewstates[no] = matcherViewstates.group(2);
        }

        if (viewstates.length != 1 || viewstates[0] != null) {
            return viewstates;
        }
        // no viewstates were present
        return null;
    }

    /**
     * put viewstates into request parameters
     */
    public static void putViewstates(final Parameters params, final String[] viewstates) {
        if (ArrayUtils.isEmpty(viewstates)) {
            return;
        }
        params.put("__VIEWSTATE", viewstates[0]);
        if (viewstates.length > 1) {
            for (int i = 1; i < viewstates.length; i++) {
                params.put("__VIEWSTATE" + i, viewstates[i]);
            }
            params.put("__VIEWSTATEFIELDCOUNT", String.valueOf(viewstates.length));
        }
    }

    /**
     * transfers the viewstates variables from a page (response) to parameters
     * (next request)
     */
    public static void transferViewstates(final String page, final Parameters params) {
        putViewstates(params, getViewstates(page));
    }

    /**
     * POST HTTP request. Do the request a second time if the user is not logged in
     *
     * @param uri
     * @return
     */
    public String postRequestLogged(final String uri, final Parameters params) {
        final String data = Network.getResponseData(Network.postRequest(uri, params));

        if (getLoginStatus(data)) {
            return data;
        }

        if (login() == StatusCode.NO_ERROR) {
            return Network.getResponseData(Network.postRequest(uri, params));
        }

        Log.i("Working as guest.");
        return data;
    }

    /**
     * GET HTTP request. Do the request a second time if the user is not logged in
     *
     * @param uri
     * @param params
     * @return
     */
    @Nullable
    public String getRequestLogged(@NonNull final String uri, @Nullable final Parameters params) {
        final HttpResponse response = Network.getRequest(uri, params);
        final String data = Network.getResponseData(response, canRemoveWhitespace(uri));

        // A page not found will not be found if the user logs in either
        if (Network.isPageNotFound(response) || getLoginStatus(data)) {
            return data;
        }

        if (login() == StatusCode.NO_ERROR) {
            return Network.getResponseData(Network.getRequest(uri, params), canRemoveWhitespace(uri));
        }

        Log.w("Working as guest.");
        return data;
    }

    /**
     * Unfortunately the cache details page contains user generated whitespace in the personal note, therefore we cannot
     * remove the white space from cache details pages.
     *
     * @param uri
     * @return
     */
    private static boolean canRemoveWhitespace(final String uri) {
        return !StringUtils.contains(uri, "cache_details");
    }

    /**
     * Get user session & session token from the Live Map. Needed for following requests.
     *
     * @return first is user session, second is session token
     */
    public @NonNull
    MapTokens getMapTokens() {
        final String data = getRequestLogged(GCConstants.URL_LIVE_MAP, null);
        final String userSession = TextUtils.getMatch(data, GCConstants.PATTERN_USERSESSION, "");
        final String sessionToken = TextUtils.getMatch(data, GCConstants.PATTERN_SESSIONTOKEN, "");
        return new MapTokens(userSession, sessionToken);
    }

}
!@#$%
20190527_004241,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_b20560
package cgeo.geocaching.connector.gc;

import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.R;
import cgeo.geocaching.connector.AbstractLogin;
import cgeo.geocaching.enumerations.StatusCode;
import cgeo.geocaching.network.Cookies;
import cgeo.geocaching.network.HtmlImage;
import cgeo.geocaching.network.Network;
import cgeo.geocaching.network.Parameters;
import cgeo.geocaching.settings.Settings;
import cgeo.geocaching.utils.Log;
import cgeo.geocaching.utils.MatcherWrapper;
import cgeo.geocaching.utils.TextUtils;

import ch.boye.httpclientandroidlib.HttpResponse;

import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;

import rx.Observable;
import rx.functions.Func0;
import rx.util.async.Async;

import android.graphics.drawable.Drawable;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

public class GCLogin extends AbstractLogin {

    private static final String DEFAULT_CUSTOM_DATE_FORMAT = "MM/dd/yyyy";

    private final static String ENGLISH = "<a href=\"#\">English &#9660;</a>";

    private final static Map<String, SimpleDateFormat> GC_CUSTOM_DATE_FORMATS;
    public static final String LANGUAGE_CHANGE_URI = "http://www.geocaching.com/my/souvenirs.aspx";

    static {
        final String[] formats = new String[] {
                DEFAULT_CUSTOM_DATE_FORMAT,
                "yyyy-MM-dd",
                "yyyy/MM/dd",
                "dd/MMM/yyyy",
                "MMM/dd/yyyy",
                "dd MMM yy",
                "dd/MM/yyyy"
        };

        final Map<String, SimpleDateFormat> map = new HashMap<>();

        for (final String format : formats) {
            map.put(format, new SimpleDateFormat(format, Locale.ENGLISH));
        }

        GC_CUSTOM_DATE_FORMATS = Collections.unmodifiableMap(map);
    }

    private GCLogin() {
        // singleton
    }

    public static GCLogin getInstance() {
        return SingletonHolder.INSTANCE;
    }

    private static class SingletonHolder {
        private static final GCLogin INSTANCE = new GCLogin();
    }

    @Override
    protected StatusCode login(boolean retry) {
        final ImmutablePair<String, String> credentials = Settings.getGcCredentials();
        final String username = credentials.left;
        final String password = credentials.right;

        if (StringUtils.isEmpty(username) || StringUtils.isEmpty(password)) {
            clearLoginInfo();
            Log.e("Login.login: No login information stored");
            return StatusCode.NO_LOGIN_INFO_STORED;
        }

        setActualStatus(CgeoApplication.getInstance().getString(R.string.init_login_popup_working));
        HttpResponse loginResponse = Network.getRequest("https://www.geocaching.com/login/default.aspx");
        String loginData = Network.getResponseData(loginResponse);
        if (loginResponse != null && loginResponse.getStatusLine().getStatusCode() == 503 && TextUtils.matches(loginData, GCConstants.PATTERN_MAINTENANCE)) {
            return StatusCode.MAINTENANCE;
        }

        if (StringUtils.isBlank(loginData)) {
            Log.e("Login.login: Failed to retrieve login page (1st)");
            return StatusCode.CONNECTION_FAILED; // no login page
        }

        if (getLoginStatus(loginData)) {
            Log.i("Already logged in Geocaching.com as " + username + " (" + Settings.getGCMemberStatus() + ')');
            if (switchToEnglish(loginData) && retry) {
                return login(false);
            }
            return StatusCode.NO_ERROR; // logged in
        }

        Cookies.clearCookies();
        Settings.setCookieStore(null);

        final Parameters params = new Parameters(
                "__EVENTTARGET", "",
                "__EVENTARGUMENT", "",
                "ctl00$ContentBody$tbUsername", username,
                "ctl00$ContentBody$tbPassword", password,
                "ctl00$ContentBody$cbRememberMe", "on",
                "ctl00$ContentBody$btnSignIn", "Login");
        final String[] viewstates = GCLogin.getViewstates(loginData);
        if (isEmpty(viewstates)) {
            Log.e("Login.login: Failed to find viewstates");
            return StatusCode.LOGIN_PARSE_ERROR; // no viewstates
        }
        GCLogin.putViewstates(params, viewstates);

        loginResponse = Network.postRequest("https://www.geocaching.com/login/default.aspx", params);
        loginData = Network.getResponseData(loginResponse);

        if (StringUtils.isBlank(loginData)) {
            Log.e("Login.login: Failed to retrieve login page (2nd)");
            // FIXME: should it be CONNECTION_FAILED to match the first attempt?
            return StatusCode.COMMUNICATION_ERROR; // no login page
        }
        assert loginData != null;  // Caught above

        if (getLoginStatus(loginData)) {
            Log.i("Successfully logged in Geocaching.com as " + username + " (" + Settings.getGCMemberStatus() + ')');

            if (switchToEnglish(loginData) && retry) {
                return login(false);
            }
            Settings.setCookieStore(Cookies.dumpCookieStore());

            return StatusCode.NO_ERROR; // logged in
        }

        if (loginData.contains("Your username/password combination does not match.")) {
            Log.i("Failed to log in Geocaching.com as " + username + " because of wrong username/password");
            return StatusCode.WRONG_LOGIN_DATA; // wrong login
        }

        if (loginData.contains("You must validate your account before you can log in.")) {
            Log.i("Failed to log in Geocaching.com as " + username + " because account needs to be validated first");
            return StatusCode.UNVALIDATED_ACCOUNT;
        }

        Log.i("Failed to log in Geocaching.com as " + username + " for some unknown reason");
        if (retry) {
            switchToEnglish(loginData);
            return login(false);
        }

        return StatusCode.UNKNOWN_ERROR; // can't login
    }

    public StatusCode logout() {
        final HttpResponse logoutResponse = Network.getRequest("https://www.geocaching.com/login/default.aspx?RESET=Y&redir=http%3a%2f%2fwww.geocaching.com%2fdefault.aspx%3f");
        final String logoutData = Network.getResponseData(logoutResponse);
        if (logoutResponse != null && logoutResponse.getStatusLine().getStatusCode() == 503 && TextUtils.matches(logoutData, GCConstants.PATTERN_MAINTENANCE)) {
            return StatusCode.MAINTENANCE;
        }

        resetLoginStatus();

        return StatusCode.NO_ERROR;
    }

    private static String removeDotAndComma(final String str) {
        return StringUtils.replaceChars(str, ".,", null);
    }

    /**
     * Check if the user has been logged in when he retrieved the data.
     *
     * @param page
     * @return <code>true</code> if user is logged in, <code>false</code> otherwise
     */
    public boolean getLoginStatus(@Nullable final String page) {
        if (StringUtils.isBlank(page)) {
            Log.e("Login.checkLogin: No page given");
            return false;
        }
        assert page != null;

        if (TextUtils.matches(page, GCConstants.PATTERN_MAP_LOGGED_IN)) {
            return true;
        }

        setActualStatus(CgeoApplication.getInstance().getString(R.string.init_login_popup_ok));

        // on every page except login page
        setActualLoginStatus(TextUtils.matches(page, GCConstants.PATTERN_LOGIN_NAME));
        if (isActualLoginStatus()) {
            setActualUserName(TextUtils.getMatch(page, GCConstants.PATTERN_LOGIN_NAME, true, "???"));
            int cachesCount = 0;
            try {
                cachesCount = Integer.parseInt(removeDotAndComma(TextUtils.getMatch(page, GCConstants.PATTERN_CACHES_FOUND, true, "0")));
            } catch (final NumberFormatException e) {
                Log.e("getLoginStatus: bad cache count", e);
            }
            setActualCachesFound(cachesCount);
            Settings.setGCMemberStatus(TextUtils.getMatch(page, GCConstants.PATTERN_MEMBER_STATUS, true, null));
            if (page.contains(GCConstants.MEMBER_STATUS_RENEW)) {
                Settings.setGCMemberStatus(GCConstants.MEMBER_STATUS_PM);
            }
            return true;
        }

        // login page
        setActualLoginStatus(TextUtils.matches(page, GCConstants.PATTERN_LOGIN_NAME_LOGIN_PAGE));
        if (isActualLoginStatus()) {
            setActualUserName(Settings.getUsername());
            // number of caches found is not part of this page
            return true;
        }

        setActualStatus(CgeoApplication.getInstance().getString(R.string.init_login_popup_failed));
        return false;
    }

    /**
     * Ensure that the web site is in English.
     *
     * @param previousPage the content of the last loaded page
     * @return <code>true</code> if a switch was necessary and succesfully performed (non-English -> English)
     */
    private boolean switchToEnglish(String previousPage) {
        if (previousPage != null && previousPage.contains(ENGLISH)) {
            Log.i("Geocaching.com language already set to English");
            // get find count
            getLoginStatus(Network.getResponseData(Network.getRequest("http://www.geocaching.com/email/")));
        } else {
            final String page = Network.getResponseData(Network.getRequest(LANGUAGE_CHANGE_URI));
            getLoginStatus(page);
            if (page == null) {
                Log.e("Failed to read viewstates to set geocaching.com language");
            }
            final Parameters params = new Parameters(
                    "__EVENTTARGET", "ctl00$uxLocaleList$uxLocaleList$ctl00$uxLocaleItem", // switch to english
                    "__EVENTARGUMENT", "");
            GCLogin.transferViewstates(page, params);
            final HttpResponse response = Network.postRequest(LANGUAGE_CHANGE_URI, params, new Parameters("Referer", LANGUAGE_CHANGE_URI));
            if (Network.isSuccess(response)) {
                Log.i("changed language on geocaching.com to English");
                return true;
            }
            Log.e("Failed to set geocaching.com language to English");
        }
        return false;
    }

    public Observable<Drawable> downloadAvatarAndGetMemberStatus() {
        try {
            final String responseData = StringUtils.defaultString(Network.getResponseData(Network.getRequest("http://www.geocaching.com/my/")));
            final String profile = TextUtils.replaceWhitespace(responseData);

            Settings.setGCMemberStatus(TextUtils.getMatch(profile, GCConstants.PATTERN_MEMBER_STATUS, true, null));
            if (profile.contains(GCConstants.MEMBER_STATUS_RENEW)) {
                Settings.setGCMemberStatus(GCConstants.MEMBER_STATUS_PM);
            }

            setActualCachesFound(Integer.parseInt(removeDotAndComma(TextUtils.getMatch(profile, GCConstants.PATTERN_CACHES_FOUND, true, "-1"))));

            final String avatarURL = TextUtils.getMatch(profile, GCConstants.PATTERN_AVATAR_IMAGE_PROFILE_PAGE, false, null);
            if (null != avatarURL) {
                return Async.start(new Func0<Drawable>() {
                    @Override
                    public Drawable call() {
                        final HtmlImage imgGetter = new HtmlImage("", false, 0, false);
                        return imgGetter.getDrawable(avatarURL.replace("avatar", "user/large"));
                    }
                });
            }
            // No match? There may be no avatar set by user.
            Log.d("No avatar set for user");
        } catch (final Exception e) {
            Log.w("Error when retrieving user avatar", e);
        }
        return null;
    }

    /**
     * Detect user date settings on geocaching.com
     */
    public static void detectGcCustomDate() {

        final String result = Network.getResponseData(Network.getRequest("http://www.geocaching.com/account/ManagePreferences.aspx"));

        if (null == result) {
            Log.w("Login.detectGcCustomDate: result is null");
            return;
        }

        final String customDate = TextUtils.getMatch(result, GCConstants.PATTERN_CUSTOMDATE, true, null);
        if (null != customDate) {
            Settings.setGcCustomDate(customDate);
        }
    }

    public static Date parseGcCustomDate(final String input, final String format) throws ParseException {
        if (StringUtils.isBlank(input)) {
            throw new ParseException("Input is null", 0);
        }

        final String trimmed = input.trim();

        if (GC_CUSTOM_DATE_FORMATS.containsKey(format)) {
            try {
                return GC_CUSTOM_DATE_FORMATS.get(format).parse(trimmed);
            } catch (final ParseException e) {
            }
        }

        for (final SimpleDateFormat sdf : GC_CUSTOM_DATE_FORMATS.values()) {
            try {
                return sdf.parse(trimmed);
            } catch (final ParseException e) {
            }
        }

        throw new ParseException("No matching pattern", 0);
    }

    public static Date parseGcCustomDate(final String input) throws ParseException {
        return parseGcCustomDate(input, Settings.getGcCustomDate());
    }

    public static SimpleDateFormat getCustomGcDateFormat() {
        final String format = Settings.getGcCustomDate();
        if (GC_CUSTOM_DATE_FORMATS.containsKey(format)) {
            return GC_CUSTOM_DATE_FORMATS.get(format);
        }

        return GC_CUSTOM_DATE_FORMATS.get(DEFAULT_CUSTOM_DATE_FORMAT);
    }

    /**
     * checks if an Array of Strings is empty or not. Empty means:
     * - Array is null
     * - or all elements are null or empty strings
     */
    public static boolean isEmpty(String[] a) {
        if (a == null) {
            return true;
        }

        for (final String s : a) {
            if (StringUtils.isNotEmpty(s)) {
                return false;
            }
        }
        return true;
    }

    /**
     * read all viewstates from page
     *
     * @return String[] with all view states
     */
    public static String[] getViewstates(String page) {
        // Get the number of viewstates.
        // If there is only one viewstate, __VIEWSTATEFIELDCOUNT is not present

        if (page == null) { // no network access
            return null;
        }

        int count = 1;
        final MatcherWrapper matcherViewstateCount = new MatcherWrapper(GCConstants.PATTERN_VIEWSTATEFIELDCOUNT, page);
        if (matcherViewstateCount.find()) {
            try {
                count = Integer.parseInt(matcherViewstateCount.group(1));
            } catch (final NumberFormatException e) {
                Log.e("getViewStates", e);
            }
        }

        final String[] viewstates = new String[count];

        // Get the viewstates
        final MatcherWrapper matcherViewstates = new MatcherWrapper(GCConstants.PATTERN_VIEWSTATES, page);
        while (matcherViewstates.find()) {
            final String sno = matcherViewstates.group(1); // number of viewstate
            int no;
            if (StringUtils.isEmpty(sno)) {
                no = 0;
            } else {
                try {
                    no = Integer.parseInt(sno);
                } catch (final NumberFormatException e) {
                    Log.e("getViewStates", e);
                    no = 0;
                }
            }
            viewstates[no] = matcherViewstates.group(2);
        }

        if (viewstates.length != 1 || viewstates[0] != null) {
            return viewstates;
        }
        // no viewstates were present
        return null;
    }

    /**
     * put viewstates into request parameters
     */
    public static void putViewstates(final Parameters params, final String[] viewstates) {
        if (ArrayUtils.isEmpty(viewstates)) {
            return;
        }
        params.put("__VIEWSTATE", viewstates[0]);
        if (viewstates.length > 1) {
            for (int i = 1; i < viewstates.length; i++) {
                params.put("__VIEWSTATE" + i, viewstates[i]);
            }
            params.put("__VIEWSTATEFIELDCOUNT", String.valueOf(viewstates.length));
        }
    }

    /**
     * transfers the viewstates variables from a page (response) to parameters
     * (next request)
     */
    public static void transferViewstates(final String page, final Parameters params) {
        putViewstates(params, getViewstates(page));
    }

    /**
     * POST HTTP request. Do the request a second time if the user is not logged in
     *
     * @param uri
     * @return
     */
    public String postRequestLogged(final String uri, final Parameters params) {
        final String data = Network.getResponseData(Network.postRequest(uri, params));

        if (getLoginStatus(data)) {
            return data;
        }

        if (login() == StatusCode.NO_ERROR) {
            return Network.getResponseData(Network.postRequest(uri, params));
        }

        Log.i("Working as guest.");
        return data;
    }

    /**
     * GET HTTP request. Do the request a second time if the user is not logged in
     *
     * @param uri
     * @param params
     * @return
     */
    @Nullable
    public String getRequestLogged(@NonNull final String uri, @Nullable final Parameters params) {
        final HttpResponse response = Network.getRequest(uri, params);
        final String data = Network.getResponseData(response, canRemoveWhitespace(uri));

        // A page not found will not be found if the user logs in either
        if (Network.isPageNotFound(response) || getLoginStatus(data)) {
            return data;
        }

        if (login() == StatusCode.NO_ERROR) {
            return Network.getResponseData(Network.getRequest(uri, params), canRemoveWhitespace(uri));
        }

        Log.w("Working as guest.");
        return data;
    }

    /**
     * Unfortunately the cache details page contains user generated whitespace in the personal note, therefore we cannot
     * remove the white space from cache details pages.
     *
     * @param uri
     * @return
     */
    private static boolean canRemoveWhitespace(final String uri) {
        return !StringUtils.contains(uri, "cache_details");
    }

    /**
     * Get user session & session token from the Live Map. Needed for following requests.
     *
     * @return first is user session, second is session token
     */
    public @NonNull
    MapTokens getMapTokens() {
        final String data = getRequestLogged(GCConstants.URL_LIVE_MAP, null);
        final String userSession = TextUtils.getMatch(data, GCConstants.PATTERN_USERSESSION, "");
        final String sessionToken = TextUtils.getMatch(data, GCConstants.PATTERN_SESSIONTOKEN, "");
        return new MapTokens(userSession, sessionToken);
    }

}
!@#$%
20190527_004241,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_a20560
package cgeo.geocaching.connector.gc;

import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.R;
import cgeo.geocaching.connector.AbstractLogin;
import cgeo.geocaching.enumerations.StatusCode;
import cgeo.geocaching.network.Cookies;
import cgeo.geocaching.network.HtmlImage;
import cgeo.geocaching.network.Network;
import cgeo.geocaching.network.Parameters;
import cgeo.geocaching.settings.Settings;
import cgeo.geocaching.utils.Log;
import cgeo.geocaching.utils.MatcherWrapper;
import cgeo.geocaching.utils.TextUtils;

import ch.boye.httpclientandroidlib.HttpResponse;

import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;

import rx.Observable;
import rx.functions.Func0;
import rx.util.async.Async;

import android.graphics.drawable.Drawable;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

public class GCLogin extends AbstractLogin {

    private static final String DEFAULT_CUSTOM_DATE_FORMAT = "MM/dd/yyyy";

    private final static String ENGLISH = "<a href=\"#\">English &#9660;</a>";

    private final static Map<String, SimpleDateFormat> GC_CUSTOM_DATE_FORMATS;
    public static final String LANGUAGE_CHANGE_URI = "http://www.geocaching.com/my/souvenirs.aspx";

    static {
        final String[] formats = new String[] {
                DEFAULT_CUSTOM_DATE_FORMAT,
                "yyyy-MM-dd",
                "yyyy/MM/dd",
                "dd/MMM/yyyy",
                "MMM/dd/yyyy",
                "dd MMM yy",
                "dd/MM/yyyy"
        };

        final Map<String, SimpleDateFormat> map = new HashMap<>();

        for (final String format : formats) {
            map.put(format, new SimpleDateFormat(format, Locale.ENGLISH));
        }

        GC_CUSTOM_DATE_FORMATS = Collections.unmodifiableMap(map);
    }

    private GCLogin() {
        // singleton
    }

    public static GCLogin getInstance() {
        return SingletonHolder.INSTANCE;
    }

    private static class SingletonHolder {
        private static final GCLogin INSTANCE = new GCLogin();
    }

    @Override
    protected StatusCode login(boolean retry) {
        final ImmutablePair<String, String> credentials = Settings.getGcCredentials();
        final String username = credentials.left;
        final String password = credentials.right;

        if (StringUtils.isEmpty(username) || StringUtils.isEmpty(password)) {
            clearLoginInfo();
            Log.e("Login.login: No login information stored");
            return StatusCode.NO_LOGIN_INFO_STORED;
        }

        setActualStatus(CgeoApplication.getInstance().getString(R.string.init_login_popup_working));
        HttpResponse loginResponse = Network.getRequest("https://www.geocaching.com/login/default.aspx");
        String loginData = Network.getResponseData(loginResponse);
        if (loginResponse != null && loginResponse.getStatusLine().getStatusCode() == 503 && TextUtils.matches(loginData, GCConstants.PATTERN_MAINTENANCE)) {
            return StatusCode.MAINTENANCE;
        }

        if (StringUtils.isBlank(loginData)) {
            Log.e("Login.login: Failed to retrieve login page (1st)");
            return StatusCode.CONNECTION_FAILED; // no login page
        }

        if (getLoginStatus(loginData)) {
            Log.i("Already logged in Geocaching.com as " + username + " (" + Settings.getGCMemberStatus() + ')');
            if (switchToEnglish(loginData) && retry) {
                return login(false);
            }
            return StatusCode.NO_ERROR; // logged in
        }

        Cookies.clearCookies();
        Settings.setCookieStore(null);

        final Parameters params = new Parameters(
                "__EVENTTARGET", "",
                "__EVENTARGUMENT", "",
                "ctl00$ContentBody$tbUsername", username,
                "ctl00$ContentBody$tbPassword", password,
                "ctl00$ContentBody$cbRememberMe", "on",
                "ctl00$ContentBody$btnSignIn", "Login");
        final String[] viewstates = GCLogin.getViewstates(loginData);
        if (isEmpty(viewstates)) {
            Log.e("Login.login: Failed to find viewstates");
            return StatusCode.LOGIN_PARSE_ERROR; // no viewstates
        }
        GCLogin.putViewstates(params, viewstates);

        loginResponse = Network.postRequest("https://www.geocaching.com/login/default.aspx", params);
        loginData = Network.getResponseData(loginResponse);

        if (StringUtils.isBlank(loginData)) {
            Log.e("Login.login: Failed to retrieve login page (2nd)");
            // FIXME: should it be CONNECTION_FAILED to match the first attempt?
            return StatusCode.COMMUNICATION_ERROR; // no login page
        }
        assert loginData != null;  // Caught above

        if (getLoginStatus(loginData)) {
            Log.i("Successfully logged in Geocaching.com as " + username + " (" + Settings.getGCMemberStatus() + ')');

            if (switchToEnglish(loginData) && retry) {
                return login(false);
            }
            Settings.setCookieStore(Cookies.dumpCookieStore());

            return StatusCode.NO_ERROR; // logged in
        }

        if (loginData.contains("Your username/password combination does not match.")) {
            Log.i("Failed to log in Geocaching.com as " + username + " because of wrong username/password");
            return StatusCode.WRONG_LOGIN_DATA; // wrong login
        }

        if (loginData.contains("You must validate your account before you can log in.")) {
            Log.i("Failed to log in Geocaching.com as " + username + " because account needs to be validated first");
            return StatusCode.UNVALIDATED_ACCOUNT;
        }

        Log.i("Failed to log in Geocaching.com as " + username + " for some unknown reason");
        if (retry) {
            switchToEnglish(loginData);
            return login(false);
        }

        return StatusCode.UNKNOWN_ERROR; // can't login
    }

    public StatusCode logout() {
        final HttpResponse logoutResponse = Network.getRequest("https://www.geocaching.com/login/default.aspx?RESET=Y&redir=http%3a%2f%2fwww.geocaching.com%2fdefault.aspx%3f");
        final String logoutData = Network.getResponseData(logoutResponse);
        if (logoutResponse != null && logoutResponse.getStatusLine().getStatusCode() == 503 && TextUtils.matches(logoutData, GCConstants.PATTERN_MAINTENANCE)) {
            return StatusCode.MAINTENANCE;
        }

        resetLoginStatus();

        return StatusCode.NO_ERROR;
    }


    /**
     * Check if the user has been logged in when he retrieved the data.
     *
     * @param page
     * @return <code>true</code> if user is logged in, <code>false</code> otherwise
     */
    public boolean getLoginStatus(@Nullable final String page) {
        if (StringUtils.isBlank(page)) {
            Log.e("Login.checkLogin: No page given");
            return false;
        }
        assert page != null;

        if (TextUtils.matches(page, GCConstants.PATTERN_MAP_LOGGED_IN)) {
            return true;
        }

        setActualStatus(CgeoApplication.getInstance().getString(R.string.init_login_popup_ok));

        // on every page except login page
        setActualLoginStatus(TextUtils.matches(page, GCConstants.PATTERN_LOGIN_NAME));
        if (isActualLoginStatus()) {
            setActualUserName(TextUtils.getMatch(page, GCConstants.PATTERN_LOGIN_NAME, true, "???"));
            int cachesCount = 0;
            try {
                cachesCount = Integer.parseInt(TextUtils.getMatch(page, GCConstants.PATTERN_CACHES_FOUND, true, "0").replaceAll("[,.]", ""));
            } catch (final NumberFormatException e) {
                Log.e("getLoginStatus: bad cache count", e);
            }
            setActualCachesFound(cachesCount);
            Settings.setGCMemberStatus(TextUtils.getMatch(page, GCConstants.PATTERN_MEMBER_STATUS, true, null));
            if (page.contains(GCConstants.MEMBER_STATUS_RENEW)) {
                Settings.setGCMemberStatus(GCConstants.MEMBER_STATUS_PM);
            }
            return true;
        }

        // login page
        setActualLoginStatus(TextUtils.matches(page, GCConstants.PATTERN_LOGIN_NAME_LOGIN_PAGE));
        if (isActualLoginStatus()) {
            setActualUserName(Settings.getUsername());
            // number of caches found is not part of this page
            return true;
        }

        setActualStatus(CgeoApplication.getInstance().getString(R.string.init_login_popup_failed));
        return false;
    }

    /**
     * Ensure that the web site is in English.
     *
     * @param previousPage the content of the last loaded page
     * @return <code>true</code> if a switch was necessary and succesfully performed (non-English -> English)
     */
    private boolean switchToEnglish(String previousPage) {
        if (previousPage != null && previousPage.contains(ENGLISH)) {
            Log.i("Geocaching.com language already set to English");
            // get find count
            getLoginStatus(Network.getResponseData(Network.getRequest("http://www.geocaching.com/email/")));
        } else {
            final String page = Network.getResponseData(Network.getRequest(LANGUAGE_CHANGE_URI));
            getLoginStatus(page);
            if (page == null) {
                Log.e("Failed to read viewstates to set geocaching.com language");
            }
            final Parameters params = new Parameters(
                    "__EVENTTARGET", "ctl00$uxLocaleList$uxLocaleList$ctl00$uxLocaleItem", // switch to english
                    "__EVENTARGUMENT", "");
            GCLogin.transferViewstates(page, params);
            final HttpResponse response = Network.postRequest(LANGUAGE_CHANGE_URI, params, new Parameters("Referer", LANGUAGE_CHANGE_URI));
            if (Network.isSuccess(response)) {
                Log.i("changed language on geocaching.com to English");
                return true;
            }
            Log.e("Failed to set geocaching.com language to English");
        }
        return false;
    }

    public Observable<Drawable> downloadAvatarAndGetMemberStatus() {
        try {
            final String responseData = StringUtils.defaultString(Network.getResponseData(Network.getRequest("http://www.geocaching.com/my/")));
            final String profile = TextUtils.replaceWhitespace(responseData);

            Settings.setGCMemberStatus(TextUtils.getMatch(profile, GCConstants.PATTERN_MEMBER_STATUS, true, null));
            if (profile.contains(GCConstants.MEMBER_STATUS_RENEW)) {
                Settings.setGCMemberStatus(GCConstants.MEMBER_STATUS_PM);
            }

            setActualCachesFound(Integer.parseInt(TextUtils.getMatch(profile, GCConstants.PATTERN_CACHES_FOUND, true, "-1").replaceAll("[,.]", "")));

            final String avatarURL = TextUtils.getMatch(profile, GCConstants.PATTERN_AVATAR_IMAGE_PROFILE_PAGE, false, null);
            if (null != avatarURL) {
                return Async.start(new Func0<Drawable>() {
                    @Override
                    public Drawable call() {
                        final HtmlImage imgGetter = new HtmlImage("", false, 0, false);
                        return imgGetter.getDrawable(avatarURL.replace("avatar", "user/large"));
                    }
                });
            }
            // No match? There may be no avatar set by user.
            Log.d("No avatar set for user");
        } catch (final Exception e) {
            Log.w("Error when retrieving user avatar", e);
        }
        return null;
    }

    /**
     * Detect user date settings on geocaching.com
     */
    public static void detectGcCustomDate() {

        final String result = Network.getResponseData(Network.getRequest("http://www.geocaching.com/account/ManagePreferences.aspx"));

        if (null == result) {
            Log.w("Login.detectGcCustomDate: result is null");
            return;
        }

        final String customDate = TextUtils.getMatch(result, GCConstants.PATTERN_CUSTOMDATE, true, null);
        if (null != customDate) {
            Settings.setGcCustomDate(customDate);
        }
    }

    public static Date parseGcCustomDate(final String input, final String format) throws ParseException {
        if (StringUtils.isBlank(input)) {
            throw new ParseException("Input is null", 0);
        }

        final String trimmed = input.trim();

        if (GC_CUSTOM_DATE_FORMATS.containsKey(format)) {
            try {
                return GC_CUSTOM_DATE_FORMATS.get(format).parse(trimmed);
            } catch (final ParseException e) {
            }
        }

        for (final SimpleDateFormat sdf : GC_CUSTOM_DATE_FORMATS.values()) {
            try {
                return sdf.parse(trimmed);
            } catch (final ParseException e) {
            }
        }

        throw new ParseException("No matching pattern", 0);
    }

    public static Date parseGcCustomDate(final String input) throws ParseException {
        return parseGcCustomDate(input, Settings.getGcCustomDate());
    }

    public static SimpleDateFormat getCustomGcDateFormat() {
        final String format = Settings.getGcCustomDate();
        if (GC_CUSTOM_DATE_FORMATS.containsKey(format)) {
            return GC_CUSTOM_DATE_FORMATS.get(format);
        }

        return GC_CUSTOM_DATE_FORMATS.get(DEFAULT_CUSTOM_DATE_FORMAT);
    }

    /**
     * checks if an Array of Strings is empty or not. Empty means:
     * - Array is null
     * - or all elements are null or empty strings
     */
    public static boolean isEmpty(String[] a) {
        if (a == null) {
            return true;
        }

        for (final String s : a) {
            if (StringUtils.isNotEmpty(s)) {
                return false;
            }
        }
        return true;
    }

    /**
     * read all viewstates from page
     *
     * @return String[] with all view states
     */
    public static String[] getViewstates(String page) {
        // Get the number of viewstates.
        // If there is only one viewstate, __VIEWSTATEFIELDCOUNT is not present

        if (page == null) { // no network access
            return null;
        }

        int count = 1;
        final MatcherWrapper matcherViewstateCount = new MatcherWrapper(GCConstants.PATTERN_VIEWSTATEFIELDCOUNT, page);
        if (matcherViewstateCount.find()) {
            try {
                count = Integer.parseInt(matcherViewstateCount.group(1));
            } catch (final NumberFormatException e) {
                Log.e("getViewStates", e);
            }
        }

        final String[] viewstates = new String[count];

        // Get the viewstates
        final MatcherWrapper matcherViewstates = new MatcherWrapper(GCConstants.PATTERN_VIEWSTATES, page);
        while (matcherViewstates.find()) {
            final String sno = matcherViewstates.group(1); // number of viewstate
            int no;
            if (StringUtils.isEmpty(sno)) {
                no = 0;
            } else {
                try {
                    no = Integer.parseInt(sno);
                } catch (final NumberFormatException e) {
                    Log.e("getViewStates", e);
                    no = 0;
                }
            }
            viewstates[no] = matcherViewstates.group(2);
        }

        if (viewstates.length != 1 || viewstates[0] != null) {
            return viewstates;
        }
        // no viewstates were present
        return null;
    }

    /**
     * put viewstates into request parameters
     */
    public static void putViewstates(final Parameters params, final String[] viewstates) {
        if (ArrayUtils.isEmpty(viewstates)) {
            return;
        }
        params.put("__VIEWSTATE", viewstates[0]);
        if (viewstates.length > 1) {
            for (int i = 1; i < viewstates.length; i++) {
                params.put("__VIEWSTATE" + i, viewstates[i]);
            }
            params.put("__VIEWSTATEFIELDCOUNT", String.valueOf(viewstates.length));
        }
    }

    /**
     * transfers the viewstates variables from a page (response) to parameters
     * (next request)
     */
    public static void transferViewstates(final String page, final Parameters params) {
        putViewstates(params, getViewstates(page));
    }

    /**
     * POST HTTP request. Do the request a second time if the user is not logged in
     *
     * @param uri
     * @return
     */
    public String postRequestLogged(final String uri, final Parameters params) {
        final String data = Network.getResponseData(Network.postRequest(uri, params));

        if (getLoginStatus(data)) {
            return data;
        }

        if (login() == StatusCode.NO_ERROR) {
            return Network.getResponseData(Network.postRequest(uri, params));
        }

        Log.i("Working as guest.");
        return data;
    }

    /**
     * GET HTTP request. Do the request a second time if the user is not logged in
     *
     * @param uri
     * @param params
     * @return
     */
    @Nullable
    public String getRequestLogged(@NonNull final String uri, @Nullable final Parameters params) {
        final HttpResponse response = Network.getRequest(uri, params);
        final String data = Network.getResponseData(response, canRemoveWhitespace(uri));

        // A page not found will not be found if the user logs in either
        if (Network.isPageNotFound(response) || getLoginStatus(data)) {
            return data;
        }

        if (login() == StatusCode.NO_ERROR) {
            return Network.getResponseData(Network.getRequest(uri, params), canRemoveWhitespace(uri));
        }

        Log.w("Working as guest.");
        return data;
    }

    /**
     * Unfortunately the cache details page contains user generated whitespace in the personal note, therefore we cannot
     * remove the white space from cache details pages.
     *
     * @param uri
     * @return
     */
    private static boolean canRemoveWhitespace(final String uri) {
        return !StringUtils.contains(uri, "cache_details");
    }

    /**
     * Get user session & session token from the Live Map. Needed for following requests.
     *
     * @return first is user session, second is session token
     */
    public @NonNull
    MapTokens getMapTokens() {
        final String data = getRequestLogged(GCConstants.URL_LIVE_MAP, null);
        final String userSession = TextUtils.getMatch(data, GCConstants.PATTERN_USERSESSION, "");
        final String sessionToken = TextUtils.getMatch(data, GCConstants.PATTERN_SESSIONTOKEN, "");
        return new MapTokens(userSession, sessionToken);
    }

}
!@#$%
20190527_004241,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_c20560
package cgeo.geocaching.connector.gc;

import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.R;
import cgeo.geocaching.connector.AbstractLogin;
import cgeo.geocaching.enumerations.StatusCode;
import cgeo.geocaching.network.Cookies;
import cgeo.geocaching.network.HtmlImage;
import cgeo.geocaching.network.Network;
import cgeo.geocaching.network.Parameters;
import cgeo.geocaching.settings.Settings;
import cgeo.geocaching.utils.Log;
import cgeo.geocaching.utils.MatcherWrapper;
import cgeo.geocaching.utils.TextUtils;

import ch.boye.httpclientandroidlib.HttpResponse;

import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;

import rx.Observable;

import android.graphics.drawable.Drawable;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

public class GCLogin extends AbstractLogin {

    private static final String DEFAULT_CUSTOM_DATE_FORMAT = "MM/dd/yyyy";

    private final static String ENGLISH = "<a href=\"#\">English &#9660;</a>";

    private final static Map<String, SimpleDateFormat> GC_CUSTOM_DATE_FORMATS;
    public static final String LANGUAGE_CHANGE_URI = "http://www.geocaching.com/my/souvenirs.aspx";

    static {
        final String[] formats = new String[] {
                DEFAULT_CUSTOM_DATE_FORMAT,
                "yyyy-MM-dd",
                "yyyy/MM/dd",
                "dd/MMM/yyyy",
                "MMM/dd/yyyy",
                "dd MMM yy",
                "dd/MM/yyyy"
        };

        final Map<String, SimpleDateFormat> map = new HashMap<>();

        for (final String format : formats) {
            map.put(format, new SimpleDateFormat(format, Locale.ENGLISH));
        }

        GC_CUSTOM_DATE_FORMATS = Collections.unmodifiableMap(map);
    }

    private GCLogin() {
        // singleton
    }

    public static GCLogin getInstance() {
        return SingletonHolder.INSTANCE;
    }

    private static class SingletonHolder {
        private static final GCLogin INSTANCE = new GCLogin();
    }

    @Override
    protected StatusCode login(boolean retry) {
        final ImmutablePair<String, String> credentials = Settings.getGcCredentials();
        final String username = credentials.left;
        final String password = credentials.right;

        if (StringUtils.isEmpty(username) || StringUtils.isEmpty(password)) {
            clearLoginInfo();
            Log.e("Login.login: No login information stored");
            return StatusCode.NO_LOGIN_INFO_STORED;
        }

        setActualStatus(CgeoApplication.getInstance().getString(R.string.init_login_popup_working));
        HttpResponse loginResponse = Network.getRequest("https://www.geocaching.com/login/default.aspx");
        String loginData = Network.getResponseData(loginResponse);
        if (loginResponse != null && loginResponse.getStatusLine().getStatusCode() == 503 && TextUtils.matches(loginData, GCConstants.PATTERN_MAINTENANCE)) {
            return StatusCode.MAINTENANCE;
        }

        if (StringUtils.isBlank(loginData)) {
            Log.e("Login.login: Failed to retrieve login page (1st)");
            return StatusCode.CONNECTION_FAILED; // no login page
        }

        if (getLoginStatus(loginData)) {
            Log.i("Already logged in Geocaching.com as " + username + " (" + Settings.getGCMemberStatus() + ')');
            if (switchToEnglish(loginData) && retry) {
                return login(false);
            }
            return StatusCode.NO_ERROR; // logged in
        }

        Cookies.clearCookies();
        Settings.setCookieStore(null);

        final Parameters params = new Parameters(
                "__EVENTTARGET", "",
                "__EVENTARGUMENT", "",
                "ctl00$ContentBody$tbUsername", username,
                "ctl00$ContentBody$tbPassword", password,
                "ctl00$ContentBody$cbRememberMe", "on",
                "ctl00$ContentBody$btnSignIn", "Login");
        final String[] viewstates = GCLogin.getViewstates(loginData);
        if (isEmpty(viewstates)) {
            Log.e("Login.login: Failed to find viewstates");
            return StatusCode.LOGIN_PARSE_ERROR; // no viewstates
        }
        GCLogin.putViewstates(params, viewstates);

        loginResponse = Network.postRequest("https://www.geocaching.com/login/default.aspx", params);
        loginData = Network.getResponseData(loginResponse);

        if (StringUtils.isBlank(loginData)) {
            Log.e("Login.login: Failed to retrieve login page (2nd)");
            // FIXME: should it be CONNECTION_FAILED to match the first attempt?
            return StatusCode.COMMUNICATION_ERROR; // no login page
        }
        assert loginData != null;  // Caught above

        if (getLoginStatus(loginData)) {
            Log.i("Successfully logged in Geocaching.com as " + username + " (" + Settings.getGCMemberStatus() + ')');

            if (switchToEnglish(loginData) && retry) {
                return login(false);
            }
            Settings.setCookieStore(Cookies.dumpCookieStore());

            return StatusCode.NO_ERROR; // logged in
        }

        if (loginData.contains("Your username/password combination does not match.")) {
            Log.i("Failed to log in Geocaching.com as " + username + " because of wrong username/password");
            return StatusCode.WRONG_LOGIN_DATA; // wrong login
        }

        if (loginData.contains("You must validate your account before you can log in.")) {
            Log.i("Failed to log in Geocaching.com as " + username + " because account needs to be validated first");
            return StatusCode.UNVALIDATED_ACCOUNT;
        }

        Log.i("Failed to log in Geocaching.com as " + username + " for some unknown reason");
        if (retry) {
            switchToEnglish(loginData);
            return login(false);
        }

        return StatusCode.UNKNOWN_ERROR; // can't login
    }

    public StatusCode logout() {
        final HttpResponse logoutResponse = Network.getRequest("https://www.geocaching.com/login/default.aspx?RESET=Y&redir=http%3a%2f%2fwww.geocaching.com%2fdefault.aspx%3f");
        final String logoutData = Network.getResponseData(logoutResponse);
        if (logoutResponse != null && logoutResponse.getStatusLine().getStatusCode() == 503 && TextUtils.matches(logoutData, GCConstants.PATTERN_MAINTENANCE)) {
            return StatusCode.MAINTENANCE;
        }

        resetLoginStatus();

        return StatusCode.NO_ERROR;
    }


    /**
     * Check if the user has been logged in when he retrieved the data.
     *
     * @param page
     * @return <code>true</code> if user is logged in, <code>false</code> otherwise
     */
    public boolean getLoginStatus(@Nullable final String page) {
        if (StringUtils.isBlank(page)) {
            Log.e("Login.checkLogin: No page given");
            return false;
        }
        assert page != null;

        if (TextUtils.matches(page, GCConstants.PATTERN_MAP_LOGGED_IN)) {
            return true;
        }

        setActualStatus(CgeoApplication.getInstance().getString(R.string.init_login_popup_ok));

        // on every page except login page
        setActualLoginStatus(TextUtils.matches(page, GCConstants.PATTERN_LOGIN_NAME));
        if (isActualLoginStatus()) {
            setActualUserName(TextUtils.getMatch(page, GCConstants.PATTERN_LOGIN_NAME, true, "???"));
            int cachesCount = 0;
            try {
                cachesCount = Integer.parseInt(TextUtils.getMatch(page, GCConstants.PATTERN_CACHES_FOUND, true, "0").replaceAll("[,.]", ""));
            } catch (final NumberFormatException e) {
                Log.e("getLoginStatus: bad cache count", e);
            }
            setActualCachesFound(cachesCount);
            Settings.setGCMemberStatus(TextUtils.getMatch(page, GCConstants.PATTERN_MEMBER_STATUS, true, null));
            if (page.contains(GCConstants.MEMBER_STATUS_RENEW)) {
                Settings.setGCMemberStatus(GCConstants.MEMBER_STATUS_PM);
            }
            return true;
        }

        // login page
        setActualLoginStatus(TextUtils.matches(page, GCConstants.PATTERN_LOGIN_NAME_LOGIN_PAGE));
        if (isActualLoginStatus()) {
            setActualUserName(Settings.getUsername());
            // number of caches found is not part of this page
            return true;
        }

        setActualStatus(CgeoApplication.getInstance().getString(R.string.init_login_popup_failed));
        return false;
    }

    /**
     * Ensure that the web site is in English.
     *
     * @param previousPage the content of the last loaded page
     * @return <code>true</code> if a switch was necessary and succesfully performed (non-English -> English)
     */
    private boolean switchToEnglish(String previousPage) {
        if (previousPage != null && previousPage.contains(ENGLISH)) {
            Log.i("Geocaching.com language already set to English");
            // get find count
            getLoginStatus(Network.getResponseData(Network.getRequest("http://www.geocaching.com/email/")));
        } else {
            final String page = Network.getResponseData(Network.getRequest(LANGUAGE_CHANGE_URI));
            getLoginStatus(page);
            if (page == null) {
                Log.e("Failed to read viewstates to set geocaching.com language");
            }
            final Parameters params = new Parameters(
                    "__EVENTTARGET", "ctl00$uxLocaleList$uxLocaleList$ctl00$uxLocaleItem", // switch to english
                    "__EVENTARGUMENT", "");
            GCLogin.transferViewstates(page, params);
            final HttpResponse response = Network.postRequest(LANGUAGE_CHANGE_URI, params, new Parameters("Referer", LANGUAGE_CHANGE_URI));
            if (Network.isSuccess(response)) {
                Log.i("changed language on geocaching.com to English");
                return true;
            }
            Log.e("Failed to set geocaching.com language to English");
        }
        return false;
    }

    public Observable<Drawable> downloadAvatarAndGetMemberStatus() {
        try {
            final String responseData = StringUtils.defaultString(Network.getResponseData(Network.getRequest("http://www.geocaching.com/my/")));
            final String profile = TextUtils.replaceWhitespace(responseData);

            Settings.setGCMemberStatus(TextUtils.getMatch(profile, GCConstants.PATTERN_MEMBER_STATUS, true, null));
            if (profile.contains(GCConstants.MEMBER_STATUS_RENEW)) {
                Settings.setGCMemberStatus(GCConstants.MEMBER_STATUS_PM);
            }

            setActualCachesFound(Integer.parseInt(TextUtils.getMatch(profile, GCConstants.PATTERN_CACHES_FOUND, true, "-1").replaceAll("[,.]", "")));

            final String avatarURL = TextUtils.getMatch(profile, GCConstants.PATTERN_AVATAR_IMAGE_PROFILE_PAGE, false, null);
            if (avatarURL != null) {
                final HtmlImage imgGetter = new HtmlImage("", false, 0, false);
                return imgGetter.fetchDrawable(avatarURL.replace("avatar", "user/large")).cast(Drawable.class);
            }
            // No match? There may be no avatar set by user.
            Log.d("No avatar set for user");
        } catch (final Exception e) {
            Log.w("Error when retrieving user avatar", e);
        }
        return null;
    }

    /**
     * Detect user date settings on geocaching.com
     */
    public static void detectGcCustomDate() {

        final String result = Network.getResponseData(Network.getRequest("http://www.geocaching.com/account/ManagePreferences.aspx"));

        if (null == result) {
            Log.w("Login.detectGcCustomDate: result is null");
            return;
        }

        final String customDate = TextUtils.getMatch(result, GCConstants.PATTERN_CUSTOMDATE, true, null);
        if (null != customDate) {
            Settings.setGcCustomDate(customDate);
        }
    }

    public static Date parseGcCustomDate(final String input, final String format) throws ParseException {
        if (StringUtils.isBlank(input)) {
            throw new ParseException("Input is null", 0);
        }

        final String trimmed = input.trim();

        if (GC_CUSTOM_DATE_FORMATS.containsKey(format)) {
            try {
                return GC_CUSTOM_DATE_FORMATS.get(format).parse(trimmed);
            } catch (final ParseException e) {
            }
        }

        for (final SimpleDateFormat sdf : GC_CUSTOM_DATE_FORMATS.values()) {
            try {
                return sdf.parse(trimmed);
            } catch (final ParseException e) {
            }
        }

        throw new ParseException("No matching pattern", 0);
    }

    public static Date parseGcCustomDate(final String input) throws ParseException {
        return parseGcCustomDate(input, Settings.getGcCustomDate());
    }

    public static SimpleDateFormat getCustomGcDateFormat() {
        final String format = Settings.getGcCustomDate();
        if (GC_CUSTOM_DATE_FORMATS.containsKey(format)) {
            return GC_CUSTOM_DATE_FORMATS.get(format);
        }

        return GC_CUSTOM_DATE_FORMATS.get(DEFAULT_CUSTOM_DATE_FORMAT);
    }

    /**
     * checks if an Array of Strings is empty or not. Empty means:
     * - Array is null
     * - or all elements are null or empty strings
     */
    public static boolean isEmpty(String[] a) {
        if (a == null) {
            return true;
        }

        for (final String s : a) {
            if (StringUtils.isNotEmpty(s)) {
                return false;
            }
        }
        return true;
    }

    /**
     * read all viewstates from page
     *
     * @return String[] with all view states
     */
    public static String[] getViewstates(String page) {
        // Get the number of viewstates.
        // If there is only one viewstate, __VIEWSTATEFIELDCOUNT is not present

        if (page == null) { // no network access
            return null;
        }

        int count = 1;
        final MatcherWrapper matcherViewstateCount = new MatcherWrapper(GCConstants.PATTERN_VIEWSTATEFIELDCOUNT, page);
        if (matcherViewstateCount.find()) {
            try {
                count = Integer.parseInt(matcherViewstateCount.group(1));
            } catch (final NumberFormatException e) {
                Log.e("getViewStates", e);
            }
        }

        final String[] viewstates = new String[count];

        // Get the viewstates
        final MatcherWrapper matcherViewstates = new MatcherWrapper(GCConstants.PATTERN_VIEWSTATES, page);
        while (matcherViewstates.find()) {
            final String sno = matcherViewstates.group(1); // number of viewstate
            int no;
            if (StringUtils.isEmpty(sno)) {
                no = 0;
            } else {
                try {
                    no = Integer.parseInt(sno);
                } catch (final NumberFormatException e) {
                    Log.e("getViewStates", e);
                    no = 0;
                }
            }
            viewstates[no] = matcherViewstates.group(2);
        }

        if (viewstates.length != 1 || viewstates[0] != null) {
            return viewstates;
        }
        // no viewstates were present
        return null;
    }

    /**
     * put viewstates into request parameters
     */
    public static void putViewstates(final Parameters params, final String[] viewstates) {
        if (ArrayUtils.isEmpty(viewstates)) {
            return;
        }
        params.put("__VIEWSTATE", viewstates[0]);
        if (viewstates.length > 1) {
            for (int i = 1; i < viewstates.length; i++) {
                params.put("__VIEWSTATE" + i, viewstates[i]);
            }
            params.put("__VIEWSTATEFIELDCOUNT", String.valueOf(viewstates.length));
        }
    }

    /**
     * transfers the viewstates variables from a page (response) to parameters
     * (next request)
     */
    public static void transferViewstates(final String page, final Parameters params) {
        putViewstates(params, getViewstates(page));
    }

    /**
     * POST HTTP request. Do the request a second time if the user is not logged in
     *
     * @param uri
     * @return
     */
    public String postRequestLogged(final String uri, final Parameters params) {
        final String data = Network.getResponseData(Network.postRequest(uri, params));

        if (getLoginStatus(data)) {
            return data;
        }

        if (login() == StatusCode.NO_ERROR) {
            return Network.getResponseData(Network.postRequest(uri, params));
        }

        Log.i("Working as guest.");
        return data;
    }

    /**
     * GET HTTP request. Do the request a second time if the user is not logged in
     *
     * @param uri
     * @param params
     * @return
     */
    @Nullable
    public String getRequestLogged(@NonNull final String uri, @Nullable final Parameters params) {
        final HttpResponse response = Network.getRequest(uri, params);
        final String data = Network.getResponseData(response, canRemoveWhitespace(uri));

        // A page not found will not be found if the user logs in either
        if (Network.isPageNotFound(response) || getLoginStatus(data)) {
            return data;
        }

        if (login() == StatusCode.NO_ERROR) {
            return Network.getResponseData(Network.getRequest(uri, params), canRemoveWhitespace(uri));
        }

        Log.w("Working as guest.");
        return data;
    }

    /**
     * Unfortunately the cache details page contains user generated whitespace in the personal note, therefore we cannot
     * remove the white space from cache details pages.
     *
     * @param uri
     * @return
     */
    private static boolean canRemoveWhitespace(final String uri) {
        return !StringUtils.contains(uri, "cache_details");
    }

    /**
     * Get user session & session token from the Live Map. Needed for following requests.
     *
     * @return first is user session, second is session token
     */
    public @NonNull
    MapTokens getMapTokens() {
        final String data = getRequestLogged(GCConstants.URL_LIVE_MAP, null);
        final String userSession = TextUtils.getMatch(data, GCConstants.PATTERN_USERSESSION, "");
        final String sessionToken = TextUtils.getMatch(data, GCConstants.PATTERN_SESSIONTOKEN, "");
        return new MapTokens(userSession, sessionToken);
    }

}
!@#$%
20190527_004413,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_b07412
package cgeo.geocaching.connector.gc;

import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.R;
import cgeo.geocaching.connector.AbstractLogin;
import cgeo.geocaching.enumerations.StatusCode;
import cgeo.geocaching.network.Cookies;
import cgeo.geocaching.network.HtmlImage;
import cgeo.geocaching.network.Network;
import cgeo.geocaching.network.Parameters;
import cgeo.geocaching.settings.Settings;
import cgeo.geocaching.utils.Log;
import cgeo.geocaching.utils.MatcherWrapper;
import cgeo.geocaching.utils.TextUtils;

import ch.boye.httpclientandroidlib.HttpResponse;

import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;

import rx.Observable;

import android.graphics.drawable.Drawable;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

public class GCLogin extends AbstractLogin {

    private static final String DEFAULT_CUSTOM_DATE_FORMAT = "MM/dd/yyyy";

    private final static String ENGLISH = "<a href=\"#\">English &#9660;</a>";

    private final static Map<String, SimpleDateFormat> GC_CUSTOM_DATE_FORMATS;
    public static final String LANGUAGE_CHANGE_URI = "http://www.geocaching.com/my/souvenirs.aspx";

    static {
        final String[] formats = new String[] {
                DEFAULT_CUSTOM_DATE_FORMAT,
                "yyyy-MM-dd",
                "yyyy/MM/dd",
                "dd/MMM/yyyy",
                "MMM/dd/yyyy",
                "dd MMM yy",
                "dd/MM/yyyy"
        };

        final Map<String, SimpleDateFormat> map = new HashMap<>();

        for (final String format : formats) {
            map.put(format, new SimpleDateFormat(format, Locale.ENGLISH));
        }

        GC_CUSTOM_DATE_FORMATS = Collections.unmodifiableMap(map);
    }

    private GCLogin() {
        // singleton
    }

    public static GCLogin getInstance() {
        return SingletonHolder.INSTANCE;
    }

    private static class SingletonHolder {
        private static final GCLogin INSTANCE = new GCLogin();
    }

    @Override
    protected StatusCode login(boolean retry) {
        final ImmutablePair<String, String> credentials = Settings.getGcCredentials();
        final String username = credentials.left;
        final String password = credentials.right;

        if (StringUtils.isEmpty(username) || StringUtils.isEmpty(password)) {
            clearLoginInfo();
            Log.e("Login.login: No login information stored");
            return StatusCode.NO_LOGIN_INFO_STORED;
        }

        setActualStatus(CgeoApplication.getInstance().getString(R.string.init_login_popup_working));
        HttpResponse loginResponse = Network.getRequest("https://www.geocaching.com/login/default.aspx");
        String loginData = Network.getResponseData(loginResponse);
        if (loginResponse != null && loginResponse.getStatusLine().getStatusCode() == 503 && TextUtils.matches(loginData, GCConstants.PATTERN_MAINTENANCE)) {
            return StatusCode.MAINTENANCE;
        }

        if (StringUtils.isBlank(loginData)) {
            Log.e("Login.login: Failed to retrieve login page (1st)");
            return StatusCode.CONNECTION_FAILED; // no login page
        }

        if (getLoginStatus(loginData)) {
            Log.i("Already logged in Geocaching.com as " + username + " (" + Settings.getGCMemberStatus() + ')');
            if (switchToEnglish(loginData) && retry) {
                return login(false);
            }
            return StatusCode.NO_ERROR; // logged in
        }

        Cookies.clearCookies();
        Settings.setCookieStore(null);

        final Parameters params = new Parameters(
                "__EVENTTARGET", "",
                "__EVENTARGUMENT", "",
                "ctl00$ContentBody$tbUsername", username,
                "ctl00$ContentBody$tbPassword", password,
                "ctl00$ContentBody$cbRememberMe", "on",
                "ctl00$ContentBody$btnSignIn", "Login");
        final String[] viewstates = GCLogin.getViewstates(loginData);
        if (isEmpty(viewstates)) {
            Log.e("Login.login: Failed to find viewstates");
            return StatusCode.LOGIN_PARSE_ERROR; // no viewstates
        }
        GCLogin.putViewstates(params, viewstates);

        loginResponse = Network.postRequest("https://www.geocaching.com/login/default.aspx", params);
        loginData = Network.getResponseData(loginResponse);

        if (StringUtils.isBlank(loginData)) {
            Log.e("Login.login: Failed to retrieve login page (2nd)");
            // FIXME: should it be CONNECTION_FAILED to match the first attempt?
            return StatusCode.COMMUNICATION_ERROR; // no login page
        }
        assert loginData != null;  // Caught above

        if (getLoginStatus(loginData)) {
            if (switchToEnglish(loginData) && retry) {
                return login(false);
            }
            Log.i("Successfully logged in Geocaching.com as " + username + " (" + Settings.getGCMemberStatus() + ')');
            Settings.setCookieStore(Cookies.dumpCookieStore());
            return StatusCode.NO_ERROR; // logged in
        }

        if (loginData.contains("Your username/password combination does not match.")) {
            Log.i("Failed to log in Geocaching.com as " + username + " because of wrong username/password");
            return StatusCode.WRONG_LOGIN_DATA; // wrong login
        }

        if (loginData.contains("You must validate your account before you can log in.")) {
            Log.i("Failed to log in Geocaching.com as " + username + " because account needs to be validated first");
            return StatusCode.UNVALIDATED_ACCOUNT;
        }

        Log.i("Failed to log in Geocaching.com as " + username + " for some unknown reason");
        if (retry) {
            switchToEnglish(loginData);
            return login(false);
        }

        return StatusCode.UNKNOWN_ERROR; // can't login
    }

    public StatusCode logout() {
        final HttpResponse logoutResponse = Network.getRequest("https://www.geocaching.com/login/default.aspx?RESET=Y&redir=http%3a%2f%2fwww.geocaching.com%2fdefault.aspx%3f");
        final String logoutData = Network.getResponseData(logoutResponse);
        if (logoutResponse != null && logoutResponse.getStatusLine().getStatusCode() == 503 && TextUtils.matches(logoutData, GCConstants.PATTERN_MAINTENANCE)) {
            return StatusCode.MAINTENANCE;
        }

        resetLoginStatus();

        return StatusCode.NO_ERROR;
    }

    private static String removeDotAndComma(final String str) {
        return StringUtils.replaceChars(str, ".,", null);
    }

    /**
     * Check if the user has been logged in when he retrieved the data.
     *
     * @param page
     * @return <code>true</code> if user is logged in, <code>false</code> otherwise
     */
    public boolean getLoginStatus(@Nullable final String page) {
        if (StringUtils.isBlank(page)) {
            Log.e("Login.checkLogin: No page given");
            return false;
        }
        assert page != null;

        if (TextUtils.matches(page, GCConstants.PATTERN_MAP_LOGGED_IN)) {
            return true;
        }

        setActualStatus(CgeoApplication.getInstance().getString(R.string.init_login_popup_ok));

        // on every page except login page
        setActualLoginStatus(TextUtils.matches(page, GCConstants.PATTERN_LOGIN_NAME));
        if (isActualLoginStatus()) {
            setActualUserName(TextUtils.getMatch(page, GCConstants.PATTERN_LOGIN_NAME, true, "???"));
            int cachesCount = 0;
            try {
                cachesCount = Integer.parseInt(removeDotAndComma(TextUtils.getMatch(page, GCConstants.PATTERN_CACHES_FOUND, true, "0")));
            } catch (final NumberFormatException e) {
                Log.e("getLoginStatus: bad cache count", e);
            }
            setActualCachesFound(cachesCount);
            Settings.setGCMemberStatus(TextUtils.getMatch(page, GCConstants.PATTERN_MEMBER_STATUS, true, null));
            if (page.contains(GCConstants.MEMBER_STATUS_RENEW)) {
                Settings.setGCMemberStatus(GCConstants.MEMBER_STATUS_PM);
            }
            return true;
        }

        // login page
        setActualLoginStatus(TextUtils.matches(page, GCConstants.PATTERN_LOGIN_NAME_LOGIN_PAGE));
        if (isActualLoginStatus()) {
            setActualUserName(Settings.getUsername());
            // number of caches found is not part of this page
            return true;
        }

        setActualStatus(CgeoApplication.getInstance().getString(R.string.init_login_popup_failed));
        return false;
    }

    /**
     * Ensure that the web site is in English.
     *
     * @param previousPage the content of the last loaded page
     * @return <code>true</code> if a switch was necessary and succesfully performed (non-English -> English)
     */
    private boolean switchToEnglish(String previousPage) {
        if (previousPage != null && previousPage.contains(ENGLISH)) {
            Log.i("Geocaching.com language already set to English");
            // get find count
            getLoginStatus(Network.getResponseData(Network.getRequest("http://www.geocaching.com/email/")));
        } else {
            final String page = Network.getResponseData(Network.getRequest(LANGUAGE_CHANGE_URI));
            getLoginStatus(page);
            if (page == null) {
                Log.e("Failed to read viewstates to set geocaching.com language");
            }
            final Parameters params = new Parameters(
                    "__EVENTTARGET", "ctl00$uxLocaleList$uxLocaleList$ctl00$uxLocaleItem", // switch to english
                    "__EVENTARGUMENT", "");
            GCLogin.transferViewstates(page, params);
            final HttpResponse response = Network.postRequest(LANGUAGE_CHANGE_URI, params, new Parameters("Referer", LANGUAGE_CHANGE_URI));
            if (Network.isSuccess(response)) {
                Log.i("changed language on geocaching.com to English");
                return true;
            }
            Log.e("Failed to set geocaching.com language to English");
        }
        return false;
    }

    public Observable<Drawable> downloadAvatarAndGetMemberStatus() {
        try {
            final String responseData = StringUtils.defaultString(Network.getResponseData(Network.getRequest("http://www.geocaching.com/my/")));
            final String profile = TextUtils.replaceWhitespace(responseData);

            Settings.setGCMemberStatus(TextUtils.getMatch(profile, GCConstants.PATTERN_MEMBER_STATUS, true, null));
            if (profile.contains(GCConstants.MEMBER_STATUS_RENEW)) {
                Settings.setGCMemberStatus(GCConstants.MEMBER_STATUS_PM);
            }

            setActualCachesFound(Integer.parseInt(removeDotAndComma(TextUtils.getMatch(profile, GCConstants.PATTERN_CACHES_FOUND, true, "-1"))));

            final String avatarURL = TextUtils.getMatch(profile, GCConstants.PATTERN_AVATAR_IMAGE_PROFILE_PAGE, false, null);
            if (avatarURL != null) {
                final HtmlImage imgGetter = new HtmlImage("", false, 0, false);
                return imgGetter.fetchDrawable(avatarURL.replace("avatar", "user/large")).cast(Drawable.class);
            }
            // No match? There may be no avatar set by user.
            Log.d("No avatar set for user");
        } catch (final Exception e) {
            Log.w("Error when retrieving user avatar", e);
        }
        return null;
    }

    /**
     * Detect user date settings on geocaching.com
     */
    public static void detectGcCustomDate() {

        final String result = Network.getResponseData(Network.getRequest("http://www.geocaching.com/account/ManagePreferences.aspx"));

        if (null == result) {
            Log.w("Login.detectGcCustomDate: result is null");
            return;
        }

        final String customDate = TextUtils.getMatch(result, GCConstants.PATTERN_CUSTOMDATE, true, null);
        if (null != customDate) {
            Settings.setGcCustomDate(customDate);
        }
    }

    public static Date parseGcCustomDate(final String input, final String format) throws ParseException {
        if (StringUtils.isBlank(input)) {
            throw new ParseException("Input is null", 0);
        }

        final String trimmed = input.trim();

        if (GC_CUSTOM_DATE_FORMATS.containsKey(format)) {
            try {
                return GC_CUSTOM_DATE_FORMATS.get(format).parse(trimmed);
            } catch (final ParseException e) {
            }
        }

        for (final SimpleDateFormat sdf : GC_CUSTOM_DATE_FORMATS.values()) {
            try {
                return sdf.parse(trimmed);
            } catch (final ParseException e) {
            }
        }

        throw new ParseException("No matching pattern", 0);
    }

    public static Date parseGcCustomDate(final String input) throws ParseException {
        return parseGcCustomDate(input, Settings.getGcCustomDate());
    }

    public static SimpleDateFormat getCustomGcDateFormat() {
        final String format = Settings.getGcCustomDate();
        if (GC_CUSTOM_DATE_FORMATS.containsKey(format)) {
            return GC_CUSTOM_DATE_FORMATS.get(format);
        }

        return GC_CUSTOM_DATE_FORMATS.get(DEFAULT_CUSTOM_DATE_FORMAT);
    }

    /**
     * checks if an Array of Strings is empty or not. Empty means:
     * - Array is null
     * - or all elements are null or empty strings
     */
    public static boolean isEmpty(String[] a) {
        if (a == null) {
            return true;
        }

        for (final String s : a) {
            if (StringUtils.isNotEmpty(s)) {
                return false;
            }
        }
        return true;
    }

    /**
     * read all viewstates from page
     *
     * @return String[] with all view states
     */
    public static String[] getViewstates(String page) {
        // Get the number of viewstates.
        // If there is only one viewstate, __VIEWSTATEFIELDCOUNT is not present

        if (page == null) { // no network access
            return null;
        }

        int count = 1;
        final MatcherWrapper matcherViewstateCount = new MatcherWrapper(GCConstants.PATTERN_VIEWSTATEFIELDCOUNT, page);
        if (matcherViewstateCount.find()) {
            try {
                count = Integer.parseInt(matcherViewstateCount.group(1));
            } catch (final NumberFormatException e) {
                Log.e("getViewStates", e);
            }
        }

        final String[] viewstates = new String[count];

        // Get the viewstates
        final MatcherWrapper matcherViewstates = new MatcherWrapper(GCConstants.PATTERN_VIEWSTATES, page);
        while (matcherViewstates.find()) {
            final String sno = matcherViewstates.group(1); // number of viewstate
            int no;
            if (StringUtils.isEmpty(sno)) {
                no = 0;
            } else {
                try {
                    no = Integer.parseInt(sno);
                } catch (final NumberFormatException e) {
                    Log.e("getViewStates", e);
                    no = 0;
                }
            }
            viewstates[no] = matcherViewstates.group(2);
        }

        if (viewstates.length != 1 || viewstates[0] != null) {
            return viewstates;
        }
        // no viewstates were present
        return null;
    }

    /**
     * put viewstates into request parameters
     */
    public static void putViewstates(final Parameters params, final String[] viewstates) {
        if (ArrayUtils.isEmpty(viewstates)) {
            return;
        }
        params.put("__VIEWSTATE", viewstates[0]);
        if (viewstates.length > 1) {
            for (int i = 1; i < viewstates.length; i++) {
                params.put("__VIEWSTATE" + i, viewstates[i]);
            }
            params.put("__VIEWSTATEFIELDCOUNT", String.valueOf(viewstates.length));
        }
    }

    /**
     * transfers the viewstates variables from a page (response) to parameters
     * (next request)
     */
    public static void transferViewstates(final String page, final Parameters params) {
        putViewstates(params, getViewstates(page));
    }

    /**
     * POST HTTP request. Do the request a second time if the user is not logged in
     *
     * @param uri
     * @return
     */
    public String postRequestLogged(final String uri, final Parameters params) {
        final String data = Network.getResponseData(Network.postRequest(uri, params));

        if (getLoginStatus(data)) {
            return data;
        }

        if (login() == StatusCode.NO_ERROR) {
            return Network.getResponseData(Network.postRequest(uri, params));
        }

        Log.i("Working as guest.");
        return data;
    }

    /**
     * GET HTTP request. Do the request a second time if the user is not logged in
     *
     * @param uri
     * @param params
     * @return
     */
    @Nullable
    public String getRequestLogged(@NonNull final String uri, @Nullable final Parameters params) {
        final HttpResponse response = Network.getRequest(uri, params);
        final String data = Network.getResponseData(response, canRemoveWhitespace(uri));

        // A page not found will not be found if the user logs in either
        if (Network.isPageNotFound(response) || getLoginStatus(data)) {
            return data;
        }

        if (login() == StatusCode.NO_ERROR) {
            return Network.getResponseData(Network.getRequest(uri, params), canRemoveWhitespace(uri));
        }

        Log.w("Working as guest.");
        return data;
    }

    /**
     * Unfortunately the cache details page contains user generated whitespace in the personal note, therefore we cannot
     * remove the white space from cache details pages.
     *
     * @param uri
     * @return
     */
    private static boolean canRemoveWhitespace(final String uri) {
        return !StringUtils.contains(uri, "cache_details");
    }

    /**
     * Get user session & session token from the Live Map. Needed for following requests.
     *
     * @return first is user session, second is session token
     */
    public @NonNull
    MapTokens getMapTokens() {
        final String data = getRequestLogged(GCConstants.URL_LIVE_MAP, null);
        final String userSession = TextUtils.getMatch(data, GCConstants.PATTERN_USERSESSION, "");
        final String sessionToken = TextUtils.getMatch(data, GCConstants.PATTERN_SESSIONTOKEN, "");
        return new MapTokens(userSession, sessionToken);
    }

}
!@#$%
20190527_004413,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_a07412
package cgeo.geocaching.connector.gc;

import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.R;
import cgeo.geocaching.connector.AbstractLogin;
import cgeo.geocaching.enumerations.StatusCode;
import cgeo.geocaching.network.Cookies;
import cgeo.geocaching.network.HtmlImage;
import cgeo.geocaching.network.Network;
import cgeo.geocaching.network.Parameters;
import cgeo.geocaching.settings.Settings;
import cgeo.geocaching.utils.Log;
import cgeo.geocaching.utils.MatcherWrapper;
import cgeo.geocaching.utils.TextUtils;

import ch.boye.httpclientandroidlib.HttpResponse;

import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;

import rx.Observable;

import android.graphics.drawable.Drawable;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

public class GCLogin extends AbstractLogin {

    private static final String DEFAULT_CUSTOM_DATE_FORMAT = "MM/dd/yyyy";

    private final static String ENGLISH = "<a href=\"#\">English &#9660;</a>";

    private final static Map<String, SimpleDateFormat> GC_CUSTOM_DATE_FORMATS;
    public static final String LANGUAGE_CHANGE_URI = "http://www.geocaching.com/my/souvenirs.aspx";

    static {
        final String[] formats = new String[] {
                DEFAULT_CUSTOM_DATE_FORMAT,
                "yyyy-MM-dd",
                "yyyy/MM/dd",
                "dd/MMM/yyyy",
                "MMM/dd/yyyy",
                "dd MMM yy",
                "dd/MM/yyyy"
        };

        final Map<String, SimpleDateFormat> map = new HashMap<>();

        for (final String format : formats) {
            map.put(format, new SimpleDateFormat(format, Locale.ENGLISH));
        }

        GC_CUSTOM_DATE_FORMATS = Collections.unmodifiableMap(map);
    }

    private GCLogin() {
        // singleton
    }

    public static GCLogin getInstance() {
        return SingletonHolder.INSTANCE;
    }

    private static class SingletonHolder {
        private static final GCLogin INSTANCE = new GCLogin();
    }

    @Override
    protected StatusCode login(boolean retry) {
        final ImmutablePair<String, String> credentials = Settings.getGcCredentials();
        final String username = credentials.left;
        final String password = credentials.right;

        if (StringUtils.isEmpty(username) || StringUtils.isEmpty(password)) {
            clearLoginInfo();
            Log.e("Login.login: No login information stored");
            return StatusCode.NO_LOGIN_INFO_STORED;
        }

        setActualStatus(CgeoApplication.getInstance().getString(R.string.init_login_popup_working));
        HttpResponse loginResponse = Network.getRequest("https://www.geocaching.com/login/default.aspx");
        String loginData = Network.getResponseData(loginResponse);
        if (loginResponse != null && loginResponse.getStatusLine().getStatusCode() == 503 && TextUtils.matches(loginData, GCConstants.PATTERN_MAINTENANCE)) {
            return StatusCode.MAINTENANCE;
        }

        if (StringUtils.isBlank(loginData)) {
            Log.e("Login.login: Failed to retrieve login page (1st)");
            return StatusCode.CONNECTION_FAILED; // no login page
        }

        if (getLoginStatus(loginData)) {
            Log.i("Already logged in Geocaching.com as " + username + " (" + Settings.getGCMemberStatus() + ')');
            if (switchToEnglish(loginData) && retry) {
                return login(false);
            }
            return StatusCode.NO_ERROR; // logged in
        }

        Cookies.clearCookies();
        Settings.setCookieStore(null);

        final Parameters params = new Parameters(
                "__EVENTTARGET", "",
                "__EVENTARGUMENT", "",
                "ctl00$ContentBody$tbUsername", username,
                "ctl00$ContentBody$tbPassword", password,
                "ctl00$ContentBody$cbRememberMe", "on",
                "ctl00$ContentBody$btnSignIn", "Login");
        final String[] viewstates = GCLogin.getViewstates(loginData);
        if (isEmpty(viewstates)) {
            Log.e("Login.login: Failed to find viewstates");
            return StatusCode.LOGIN_PARSE_ERROR; // no viewstates
        }
        GCLogin.putViewstates(params, viewstates);

        loginResponse = Network.postRequest("https://www.geocaching.com/login/default.aspx", params);
        loginData = Network.getResponseData(loginResponse);

        if (StringUtils.isBlank(loginData)) {
            Log.e("Login.login: Failed to retrieve login page (2nd)");
            // FIXME: should it be CONNECTION_FAILED to match the first attempt?
            return StatusCode.COMMUNICATION_ERROR; // no login page
        }
        assert loginData != null;  // Caught above

        if (getLoginStatus(loginData)) {
            Log.i("Successfully logged in Geocaching.com as " + username + " (" + Settings.getGCMemberStatus() + ')');

            if (switchToEnglish(loginData) && retry) {
                return login(false);
            }
            Settings.setCookieStore(Cookies.dumpCookieStore());

            return StatusCode.NO_ERROR; // logged in
        }

        if (loginData.contains("Your username/password combination does not match.")) {
            Log.i("Failed to log in Geocaching.com as " + username + " because of wrong username/password");
            return StatusCode.WRONG_LOGIN_DATA; // wrong login
        }

        if (loginData.contains("You must validate your account before you can log in.")) {
            Log.i("Failed to log in Geocaching.com as " + username + " because account needs to be validated first");
            return StatusCode.UNVALIDATED_ACCOUNT;
        }

        Log.i("Failed to log in Geocaching.com as " + username + " for some unknown reason");
        if (retry) {
            switchToEnglish(loginData);
            return login(false);
        }

        return StatusCode.UNKNOWN_ERROR; // can't login
    }

    public StatusCode logout() {
        final HttpResponse logoutResponse = Network.getRequest("https://www.geocaching.com/login/default.aspx?RESET=Y&redir=http%3a%2f%2fwww.geocaching.com%2fdefault.aspx%3f");
        final String logoutData = Network.getResponseData(logoutResponse);
        if (logoutResponse != null && logoutResponse.getStatusLine().getStatusCode() == 503 && TextUtils.matches(logoutData, GCConstants.PATTERN_MAINTENANCE)) {
            return StatusCode.MAINTENANCE;
        }

        resetLoginStatus();

        return StatusCode.NO_ERROR;
    }


    /**
     * Check if the user has been logged in when he retrieved the data.
     *
     * @param page
     * @return <code>true</code> if user is logged in, <code>false</code> otherwise
     */
    public boolean getLoginStatus(@Nullable final String page) {
        if (StringUtils.isBlank(page)) {
            Log.e("Login.checkLogin: No page given");
            return false;
        }
        assert page != null;

        if (TextUtils.matches(page, GCConstants.PATTERN_MAP_LOGGED_IN)) {
            return true;
        }

        setActualStatus(CgeoApplication.getInstance().getString(R.string.init_login_popup_ok));

        // on every page except login page
        setActualLoginStatus(TextUtils.matches(page, GCConstants.PATTERN_LOGIN_NAME));
        if (isActualLoginStatus()) {
            setActualUserName(TextUtils.getMatch(page, GCConstants.PATTERN_LOGIN_NAME, true, "???"));
            int cachesCount = 0;
            try {
                cachesCount = Integer.parseInt(TextUtils.getMatch(page, GCConstants.PATTERN_CACHES_FOUND, true, "0").replaceAll("[,.]", ""));
            } catch (final NumberFormatException e) {
                Log.e("getLoginStatus: bad cache count", e);
            }
            setActualCachesFound(cachesCount);
            Settings.setGCMemberStatus(TextUtils.getMatch(page, GCConstants.PATTERN_MEMBER_STATUS, true, null));
            if (page.contains(GCConstants.MEMBER_STATUS_RENEW)) {
                Settings.setGCMemberStatus(GCConstants.MEMBER_STATUS_PM);
            }
            return true;
        }

        // login page
        setActualLoginStatus(TextUtils.matches(page, GCConstants.PATTERN_LOGIN_NAME_LOGIN_PAGE));
        if (isActualLoginStatus()) {
            setActualUserName(Settings.getUsername());
            // number of caches found is not part of this page
            return true;
        }

        setActualStatus(CgeoApplication.getInstance().getString(R.string.init_login_popup_failed));
        return false;
    }

    /**
     * Ensure that the web site is in English.
     *
     * @param previousPage the content of the last loaded page
     * @return <code>true</code> if a switch was necessary and succesfully performed (non-English -> English)
     */
    private boolean switchToEnglish(String previousPage) {
        if (previousPage != null && previousPage.contains(ENGLISH)) {
            Log.i("Geocaching.com language already set to English");
            // get find count
            getLoginStatus(Network.getResponseData(Network.getRequest("http://www.geocaching.com/email/")));
        } else {
            final String page = Network.getResponseData(Network.getRequest(LANGUAGE_CHANGE_URI));
            getLoginStatus(page);
            if (page == null) {
                Log.e("Failed to read viewstates to set geocaching.com language");
            }
            final Parameters params = new Parameters(
                    "__EVENTTARGET", "ctl00$uxLocaleList$uxLocaleList$ctl00$uxLocaleItem", // switch to english
                    "__EVENTARGUMENT", "");
            GCLogin.transferViewstates(page, params);
            final HttpResponse response = Network.postRequest(LANGUAGE_CHANGE_URI, params, new Parameters("Referer", LANGUAGE_CHANGE_URI));
            if (Network.isSuccess(response)) {
                Log.i("changed language on geocaching.com to English");
                return true;
            }
            Log.e("Failed to set geocaching.com language to English");
        }
        return false;
    }

    public Observable<Drawable> downloadAvatarAndGetMemberStatus() {
        try {
            final String responseData = StringUtils.defaultString(Network.getResponseData(Network.getRequest("http://www.geocaching.com/my/")));
            final String profile = TextUtils.replaceWhitespace(responseData);

            Settings.setGCMemberStatus(TextUtils.getMatch(profile, GCConstants.PATTERN_MEMBER_STATUS, true, null));
            if (profile.contains(GCConstants.MEMBER_STATUS_RENEW)) {
                Settings.setGCMemberStatus(GCConstants.MEMBER_STATUS_PM);
            }

            setActualCachesFound(Integer.parseInt(TextUtils.getMatch(profile, GCConstants.PATTERN_CACHES_FOUND, true, "-1").replaceAll("[,.]", "")));

            final String avatarURL = TextUtils.getMatch(profile, GCConstants.PATTERN_AVATAR_IMAGE_PROFILE_PAGE, false, null);
            if (avatarURL != null) {
                final HtmlImage imgGetter = new HtmlImage("", false, 0, false);
                return imgGetter.fetchDrawable(avatarURL.replace("avatar", "user/large")).cast(Drawable.class);
            }
            // No match? There may be no avatar set by user.
            Log.d("No avatar set for user");
        } catch (final Exception e) {
            Log.w("Error when retrieving user avatar", e);
        }
        return null;
    }

    /**
     * Detect user date settings on geocaching.com
     */
    public static void detectGcCustomDate() {

        final String result = Network.getResponseData(Network.getRequest("http://www.geocaching.com/account/ManagePreferences.aspx"));

        if (null == result) {
            Log.w("Login.detectGcCustomDate: result is null");
            return;
        }

        final String customDate = TextUtils.getMatch(result, GCConstants.PATTERN_CUSTOMDATE, true, null);
        if (null != customDate) {
            Settings.setGcCustomDate(customDate);
        }
    }

    public static Date parseGcCustomDate(final String input, final String format) throws ParseException {
        if (StringUtils.isBlank(input)) {
            throw new ParseException("Input is null", 0);
        }

        final String trimmed = input.trim();

        if (GC_CUSTOM_DATE_FORMATS.containsKey(format)) {
            try {
                return GC_CUSTOM_DATE_FORMATS.get(format).parse(trimmed);
            } catch (final ParseException e) {
            }
        }

        for (final SimpleDateFormat sdf : GC_CUSTOM_DATE_FORMATS.values()) {
            try {
                return sdf.parse(trimmed);
            } catch (final ParseException e) {
            }
        }

        throw new ParseException("No matching pattern", 0);
    }

    public static Date parseGcCustomDate(final String input) throws ParseException {
        return parseGcCustomDate(input, Settings.getGcCustomDate());
    }

    public static SimpleDateFormat getCustomGcDateFormat() {
        final String format = Settings.getGcCustomDate();
        if (GC_CUSTOM_DATE_FORMATS.containsKey(format)) {
            return GC_CUSTOM_DATE_FORMATS.get(format);
        }

        return GC_CUSTOM_DATE_FORMATS.get(DEFAULT_CUSTOM_DATE_FORMAT);
    }

    /**
     * checks if an Array of Strings is empty or not. Empty means:
     * - Array is null
     * - or all elements are null or empty strings
     */
    public static boolean isEmpty(String[] a) {
        if (a == null) {
            return true;
        }

        for (final String s : a) {
            if (StringUtils.isNotEmpty(s)) {
                return false;
            }
        }
        return true;
    }

    /**
     * read all viewstates from page
     *
     * @return String[] with all view states
     */
    public static String[] getViewstates(String page) {
        // Get the number of viewstates.
        // If there is only one viewstate, __VIEWSTATEFIELDCOUNT is not present

        if (page == null) { // no network access
            return null;
        }

        int count = 1;
        final MatcherWrapper matcherViewstateCount = new MatcherWrapper(GCConstants.PATTERN_VIEWSTATEFIELDCOUNT, page);
        if (matcherViewstateCount.find()) {
            try {
                count = Integer.parseInt(matcherViewstateCount.group(1));
            } catch (final NumberFormatException e) {
                Log.e("getViewStates", e);
            }
        }

        final String[] viewstates = new String[count];

        // Get the viewstates
        final MatcherWrapper matcherViewstates = new MatcherWrapper(GCConstants.PATTERN_VIEWSTATES, page);
        while (matcherViewstates.find()) {
            final String sno = matcherViewstates.group(1); // number of viewstate
            int no;
            if (StringUtils.isEmpty(sno)) {
                no = 0;
            } else {
                try {
                    no = Integer.parseInt(sno);
                } catch (final NumberFormatException e) {
                    Log.e("getViewStates", e);
                    no = 0;
                }
            }
            viewstates[no] = matcherViewstates.group(2);
        }

        if (viewstates.length != 1 || viewstates[0] != null) {
            return viewstates;
        }
        // no viewstates were present
        return null;
    }

    /**
     * put viewstates into request parameters
     */
    public static void putViewstates(final Parameters params, final String[] viewstates) {
        if (ArrayUtils.isEmpty(viewstates)) {
            return;
        }
        params.put("__VIEWSTATE", viewstates[0]);
        if (viewstates.length > 1) {
            for (int i = 1; i < viewstates.length; i++) {
                params.put("__VIEWSTATE" + i, viewstates[i]);
            }
            params.put("__VIEWSTATEFIELDCOUNT", String.valueOf(viewstates.length));
        }
    }

    /**
     * transfers the viewstates variables from a page (response) to parameters
     * (next request)
     */
    public static void transferViewstates(final String page, final Parameters params) {
        putViewstates(params, getViewstates(page));
    }

    /**
     * POST HTTP request. Do the request a second time if the user is not logged in
     *
     * @param uri
     * @return
     */
    public String postRequestLogged(final String uri, final Parameters params) {
        final String data = Network.getResponseData(Network.postRequest(uri, params));

        if (getLoginStatus(data)) {
            return data;
        }

        if (login() == StatusCode.NO_ERROR) {
            return Network.getResponseData(Network.postRequest(uri, params));
        }

        Log.i("Working as guest.");
        return data;
    }

    /**
     * GET HTTP request. Do the request a second time if the user is not logged in
     *
     * @param uri
     * @param params
     * @return
     */
    @Nullable
    public String getRequestLogged(@NonNull final String uri, @Nullable final Parameters params) {
        final HttpResponse response = Network.getRequest(uri, params);
        final String data = Network.getResponseData(response, canRemoveWhitespace(uri));

        // A page not found will not be found if the user logs in either
        if (Network.isPageNotFound(response) || getLoginStatus(data)) {
            return data;
        }

        if (login() == StatusCode.NO_ERROR) {
            return Network.getResponseData(Network.getRequest(uri, params), canRemoveWhitespace(uri));
        }

        Log.w("Working as guest.");
        return data;
    }

    /**
     * Unfortunately the cache details page contains user generated whitespace in the personal note, therefore we cannot
     * remove the white space from cache details pages.
     *
     * @param uri
     * @return
     */
    private static boolean canRemoveWhitespace(final String uri) {
        return !StringUtils.contains(uri, "cache_details");
    }

    /**
     * Get user session & session token from the Live Map. Needed for following requests.
     *
     * @return first is user session, second is session token
     */
    public @NonNull
    MapTokens getMapTokens() {
        final String data = getRequestLogged(GCConstants.URL_LIVE_MAP, null);
        final String userSession = TextUtils.getMatch(data, GCConstants.PATTERN_USERSESSION, "");
        final String sessionToken = TextUtils.getMatch(data, GCConstants.PATTERN_SESSIONTOKEN, "");
        return new MapTokens(userSession, sessionToken);
    }

}
!@#$%
20190527_004413,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_c07412
package cgeo.geocaching.connector.gc;

import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.R;
import cgeo.geocaching.connector.AbstractLogin;
import cgeo.geocaching.enumerations.StatusCode;
import cgeo.geocaching.network.Cookies;
import cgeo.geocaching.network.HtmlImage;
import cgeo.geocaching.network.Network;
import cgeo.geocaching.network.Parameters;
import cgeo.geocaching.settings.Settings;
import cgeo.geocaching.utils.Log;
import cgeo.geocaching.utils.MatcherWrapper;
import cgeo.geocaching.utils.TextUtils;

import ch.boye.httpclientandroidlib.HttpResponse;

import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;

import rx.Observable;

import android.graphics.drawable.Drawable;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

public class GCLogin extends AbstractLogin {

    private static final String DEFAULT_CUSTOM_DATE_FORMAT = "MM/dd/yyyy";

    private final static String ENGLISH = "<a href=\"#\">English &#9660;</a>";

    private final static Map<String, SimpleDateFormat> GC_CUSTOM_DATE_FORMATS;
    public static final String LANGUAGE_CHANGE_URI = "http://www.geocaching.com/my/souvenirs.aspx";

    static {
        final String[] formats = new String[] {
                DEFAULT_CUSTOM_DATE_FORMAT,
                "yyyy-MM-dd",
                "yyyy/MM/dd",
                "dd/MMM/yyyy",
                "MMM/dd/yyyy",
                "dd MMM yy",
                "dd/MM/yyyy"
        };

        final Map<String, SimpleDateFormat> map = new HashMap<>();

        for (final String format : formats) {
            map.put(format, new SimpleDateFormat(format, Locale.ENGLISH));
        }

        GC_CUSTOM_DATE_FORMATS = Collections.unmodifiableMap(map);
    }

    private GCLogin() {
        // singleton
    }

    public static GCLogin getInstance() {
        return SingletonHolder.INSTANCE;
    }

    private static class SingletonHolder {
        private static final GCLogin INSTANCE = new GCLogin();
    }

    @Override
    protected StatusCode login(boolean retry) {
        final ImmutablePair<String, String> credentials = Settings.getGcCredentials();
        final String username = credentials.left;
        final String password = credentials.right;

        if (StringUtils.isEmpty(username) || StringUtils.isEmpty(password)) {
            clearLoginInfo();
            Log.e("Login.login: No login information stored");
            return StatusCode.NO_LOGIN_INFO_STORED;
        }

        setActualStatus(CgeoApplication.getInstance().getString(R.string.init_login_popup_working));
        HttpResponse loginResponse = Network.getRequest("https://www.geocaching.com/login/default.aspx");
        String loginData = Network.getResponseData(loginResponse);
        if (loginResponse != null && loginResponse.getStatusLine().getStatusCode() == 503 && TextUtils.matches(loginData, GCConstants.PATTERN_MAINTENANCE)) {
            return StatusCode.MAINTENANCE;
        }

        if (StringUtils.isBlank(loginData)) {
            Log.e("Login.login: Failed to retrieve login page (1st)");
            return StatusCode.CONNECTION_FAILED; // no login page
        }

        if (getLoginStatus(loginData)) {
            Log.i("Already logged in Geocaching.com as " + username + " (" + Settings.getGCMemberStatus() + ')');
            if (switchToEnglish(loginData) && retry) {
                return login(false);
            }
            return StatusCode.NO_ERROR; // logged in
        }

        Cookies.clearCookies();
        Settings.setCookieStore(null);

        final Parameters params = new Parameters(
                "__EVENTTARGET", "",
                "__EVENTARGUMENT", "",
                "ctl00$ContentBody$tbUsername", username,
                "ctl00$ContentBody$tbPassword", password,
                "ctl00$ContentBody$cbRememberMe", "on",
                "ctl00$ContentBody$btnSignIn", "Login");
        final String[] viewstates = GCLogin.getViewstates(loginData);
        if (isEmpty(viewstates)) {
            Log.e("Login.login: Failed to find viewstates");
            return StatusCode.LOGIN_PARSE_ERROR; // no viewstates
        }
        GCLogin.putViewstates(params, viewstates);

        loginResponse = Network.postRequest("https://www.geocaching.com/login/default.aspx", params);
        loginData = Network.getResponseData(loginResponse);

        if (StringUtils.isBlank(loginData)) {
            Log.e("Login.login: Failed to retrieve login page (2nd)");
            // FIXME: should it be CONNECTION_FAILED to match the first attempt?
            return StatusCode.COMMUNICATION_ERROR; // no login page
        }
        assert loginData != null;  // Caught above

        if (getLoginStatus(loginData)) {
            if (switchToEnglish(loginData) && retry) {
                return login(false);
            }
            Log.i("Successfully logged in Geocaching.com as " + username + " (" + Settings.getGCMemberStatus() + ')');
            Settings.setCookieStore(Cookies.dumpCookieStore());
            return StatusCode.NO_ERROR; // logged in
        }

        if (loginData.contains("Your username/password combination does not match.")) {
            Log.i("Failed to log in Geocaching.com as " + username + " because of wrong username/password");
            return StatusCode.WRONG_LOGIN_DATA; // wrong login
        }

        if (loginData.contains("You must validate your account before you can log in.")) {
            Log.i("Failed to log in Geocaching.com as " + username + " because account needs to be validated first");
            return StatusCode.UNVALIDATED_ACCOUNT;
        }

        Log.i("Failed to log in Geocaching.com as " + username + " for some unknown reason");
        if (retry) {
            switchToEnglish(loginData);
            return login(false);
        }

        return StatusCode.UNKNOWN_ERROR; // can't login
    }

    public StatusCode logout() {
        final HttpResponse logoutResponse = Network.getRequest("https://www.geocaching.com/login/default.aspx?RESET=Y&redir=http%3a%2f%2fwww.geocaching.com%2fdefault.aspx%3f");
        final String logoutData = Network.getResponseData(logoutResponse);
        if (logoutResponse != null && logoutResponse.getStatusLine().getStatusCode() == 503 && TextUtils.matches(logoutData, GCConstants.PATTERN_MAINTENANCE)) {
            return StatusCode.MAINTENANCE;
        }

        resetLoginStatus();

        return StatusCode.NO_ERROR;
    }


    /**
     * Check if the user has been logged in when he retrieved the data.
     *
     * @param page
     * @return <code>true</code> if user is logged in, <code>false</code> otherwise
     */
    public boolean getLoginStatus(@Nullable final String page) {
        if (StringUtils.isBlank(page)) {
            Log.e("Login.checkLogin: No page given");
            return false;
        }
        assert page != null;

        if (TextUtils.matches(page, GCConstants.PATTERN_MAP_LOGGED_IN)) {
            return true;
        }

        setActualStatus(CgeoApplication.getInstance().getString(R.string.init_login_popup_ok));

        // on every page except login page
        setActualLoginStatus(TextUtils.matches(page, GCConstants.PATTERN_LOGIN_NAME));
        if (isActualLoginStatus()) {
            setActualUserName(TextUtils.getMatch(page, GCConstants.PATTERN_LOGIN_NAME, true, "???"));
            int cachesCount = 0;
            try {
                cachesCount = Integer.parseInt(TextUtils.getMatch(page, GCConstants.PATTERN_CACHES_FOUND, true, "0").replaceAll("[,.]", ""));
            } catch (final NumberFormatException e) {
                Log.e("getLoginStatus: bad cache count", e);
            }
            setActualCachesFound(cachesCount);
            Settings.setGCMemberStatus(TextUtils.getMatch(page, GCConstants.PATTERN_MEMBER_STATUS, true, null));
            if (page.contains(GCConstants.MEMBER_STATUS_RENEW)) {
                Settings.setGCMemberStatus(GCConstants.MEMBER_STATUS_PM);
            }
            return true;
        }

        // login page
        setActualLoginStatus(TextUtils.matches(page, GCConstants.PATTERN_LOGIN_NAME_LOGIN_PAGE));
        if (isActualLoginStatus()) {
            setActualUserName(Settings.getUsername());
            // number of caches found is not part of this page
            return true;
        }

        setActualStatus(CgeoApplication.getInstance().getString(R.string.init_login_popup_failed));
        return false;
    }

    /**
     * Ensure that the web site is in English.
     *
     * @param previousPage the content of the last loaded page
     * @return <code>true</code> if a switch was necessary and succesfully performed (non-English -> English)
     */
    private boolean switchToEnglish(String previousPage) {
        if (previousPage != null && previousPage.contains(ENGLISH)) {
            Log.i("Geocaching.com language already set to English");
            // get find count
            getLoginStatus(Network.getResponseData(Network.getRequest("http://www.geocaching.com/email/")));
        } else {
            final String page = Network.getResponseData(Network.getRequest(LANGUAGE_CHANGE_URI));
            getLoginStatus(page);
            if (page == null) {
                Log.e("Failed to read viewstates to set geocaching.com language");
            }
            final Parameters params = new Parameters(
                    "__EVENTTARGET", "ctl00$uxLocaleList$uxLocaleList$ctl00$uxLocaleItem", // switch to english
                    "__EVENTARGUMENT", "");
            GCLogin.transferViewstates(page, params);
            final HttpResponse response = Network.postRequest(LANGUAGE_CHANGE_URI, params, new Parameters("Referer", LANGUAGE_CHANGE_URI));
            if (Network.isSuccess(response)) {
                Log.i("changed language on geocaching.com to English");
                return true;
            }
            Log.e("Failed to set geocaching.com language to English");
        }
        return false;
    }

    public Observable<Drawable> downloadAvatarAndGetMemberStatus() {
        try {
            final String responseData = StringUtils.defaultString(Network.getResponseData(Network.getRequest("http://www.geocaching.com/my/")));
            final String profile = TextUtils.replaceWhitespace(responseData);

            Settings.setGCMemberStatus(TextUtils.getMatch(profile, GCConstants.PATTERN_MEMBER_STATUS, true, null));
            if (profile.contains(GCConstants.MEMBER_STATUS_RENEW)) {
                Settings.setGCMemberStatus(GCConstants.MEMBER_STATUS_PM);
            }

            setActualCachesFound(Integer.parseInt(TextUtils.getMatch(profile, GCConstants.PATTERN_CACHES_FOUND, true, "-1").replaceAll("[,.]", "")));

            final String avatarURL = TextUtils.getMatch(profile, GCConstants.PATTERN_AVATAR_IMAGE_PROFILE_PAGE, false, null);
            if (avatarURL != null) {
                final HtmlImage imgGetter = new HtmlImage("", false, 0, false);
                return imgGetter.fetchDrawable(avatarURL.replace("avatar", "user/large")).cast(Drawable.class);
            }
            // No match? There may be no avatar set by user.
            Log.d("No avatar set for user");
        } catch (final Exception e) {
            Log.w("Error when retrieving user avatar", e);
        }
        return null;
    }

    /**
     * Detect user date settings on geocaching.com
     */
    public static void detectGcCustomDate() {

        final String result = Network.getResponseData(Network.getRequest("http://www.geocaching.com/account/ManagePreferences.aspx"));

        if (null == result) {
            Log.w("Login.detectGcCustomDate: result is null");
            return;
        }

        final String customDate = TextUtils.getMatch(result, GCConstants.PATTERN_CUSTOMDATE, true, null);
        if (null != customDate) {
            Settings.setGcCustomDate(customDate);
        }
    }

    public static Date parseGcCustomDate(final String input, final String format) throws ParseException {
        if (StringUtils.isBlank(input)) {
            throw new ParseException("Input is null", 0);
        }

        final String trimmed = input.trim();

        if (GC_CUSTOM_DATE_FORMATS.containsKey(format)) {
            try {
                return GC_CUSTOM_DATE_FORMATS.get(format).parse(trimmed);
            } catch (final ParseException e) {
            }
        }

        for (final SimpleDateFormat sdf : GC_CUSTOM_DATE_FORMATS.values()) {
            try {
                return sdf.parse(trimmed);
            } catch (final ParseException e) {
            }
        }

        throw new ParseException("No matching pattern", 0);
    }

    public static Date parseGcCustomDate(final String input) throws ParseException {
        return parseGcCustomDate(input, Settings.getGcCustomDate());
    }

    public static SimpleDateFormat getCustomGcDateFormat() {
        final String format = Settings.getGcCustomDate();
        if (GC_CUSTOM_DATE_FORMATS.containsKey(format)) {
            return GC_CUSTOM_DATE_FORMATS.get(format);
        }

        return GC_CUSTOM_DATE_FORMATS.get(DEFAULT_CUSTOM_DATE_FORMAT);
    }

    /**
     * checks if an Array of Strings is empty or not. Empty means:
     * - Array is null
     * - or all elements are null or empty strings
     */
    public static boolean isEmpty(String[] a) {
        if (a == null) {
            return true;
        }

        for (final String s : a) {
            if (StringUtils.isNotEmpty(s)) {
                return false;
            }
        }
        return true;
    }

    /**
     * read all viewstates from page
     *
     * @return String[] with all view states
     */
    public static String[] getViewstates(String page) {
        // Get the number of viewstates.
        // If there is only one viewstate, __VIEWSTATEFIELDCOUNT is not present

        if (page == null) { // no network access
            return null;
        }

        int count = 1;
        final MatcherWrapper matcherViewstateCount = new MatcherWrapper(GCConstants.PATTERN_VIEWSTATEFIELDCOUNT, page);
        if (matcherViewstateCount.find()) {
            try {
                count = Integer.parseInt(matcherViewstateCount.group(1));
            } catch (final NumberFormatException e) {
                Log.e("getViewStates", e);
            }
        }

        final String[] viewstates = new String[count];

        // Get the viewstates
        final MatcherWrapper matcherViewstates = new MatcherWrapper(GCConstants.PATTERN_VIEWSTATES, page);
        while (matcherViewstates.find()) {
            final String sno = matcherViewstates.group(1); // number of viewstate
            int no;
            if (StringUtils.isEmpty(sno)) {
                no = 0;
            } else {
                try {
                    no = Integer.parseInt(sno);
                } catch (final NumberFormatException e) {
                    Log.e("getViewStates", e);
                    no = 0;
                }
            }
            viewstates[no] = matcherViewstates.group(2);
        }

        if (viewstates.length != 1 || viewstates[0] != null) {
            return viewstates;
        }
        // no viewstates were present
        return null;
    }

    /**
     * put viewstates into request parameters
     */
    public static void putViewstates(final Parameters params, final String[] viewstates) {
        if (ArrayUtils.isEmpty(viewstates)) {
            return;
        }
        params.put("__VIEWSTATE", viewstates[0]);
        if (viewstates.length > 1) {
            for (int i = 1; i < viewstates.length; i++) {
                params.put("__VIEWSTATE" + i, viewstates[i]);
            }
            params.put("__VIEWSTATEFIELDCOUNT", String.valueOf(viewstates.length));
        }
    }

    /**
     * transfers the viewstates variables from a page (response) to parameters
     * (next request)
     */
    public static void transferViewstates(final String page, final Parameters params) {
        putViewstates(params, getViewstates(page));
    }

    /**
     * POST HTTP request. Do the request a second time if the user is not logged in
     *
     * @param uri
     * @return
     */
    public String postRequestLogged(final String uri, final Parameters params) {
        final String data = Network.getResponseData(Network.postRequest(uri, params));

        if (getLoginStatus(data)) {
            return data;
        }

        if (login() == StatusCode.NO_ERROR) {
            return Network.getResponseData(Network.postRequest(uri, params));
        }

        Log.i("Working as guest.");
        return data;
    }

    /**
     * GET HTTP request. Do the request a second time if the user is not logged in
     *
     * @param uri
     * @param params
     * @return
     */
    @Nullable
    public String getRequestLogged(@NonNull final String uri, @Nullable final Parameters params) {
        final HttpResponse response = Network.getRequest(uri, params);
        final String data = Network.getResponseData(response, canRemoveWhitespace(uri));

        // A page not found will not be found if the user logs in either
        if (Network.isPageNotFound(response) || getLoginStatus(data)) {
            return data;
        }

        if (login() == StatusCode.NO_ERROR) {
            return Network.getResponseData(Network.getRequest(uri, params), canRemoveWhitespace(uri));
        }

        Log.w("Working as guest.");
        return data;
    }

    /**
     * Unfortunately the cache details page contains user generated whitespace in the personal note, therefore we cannot
     * remove the white space from cache details pages.
     *
     * @param uri
     * @return
     */
    private static boolean canRemoveWhitespace(final String uri) {
        return !StringUtils.contains(uri, "cache_details");
    }

    /**
     * Get user session & session token from the Live Map. Needed for following requests.
     *
     * @return first is user session, second is session token
     */
    public @NonNull
    MapTokens getMapTokens() {
        final String data = getRequestLogged(GCConstants.URL_LIVE_MAP, null);
        final String userSession = TextUtils.getMatch(data, GCConstants.PATTERN_USERSESSION, "");
        final String sessionToken = TextUtils.getMatch(data, GCConstants.PATTERN_SESSIONTOKEN, "");
        return new MapTokens(userSession, sessionToken);
    }

}
!@#$%
20190527_004634,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_b15724
package cgeo.geocaching.network;

import cgeo.geocaching.files.LocalStorage;
import cgeo.geocaching.settings.Settings;
import cgeo.geocaching.utils.JsonUtils;
import cgeo.geocaching.utils.Log;
import cgeo.geocaching.utils.TextUtils;

import ch.boye.httpclientandroidlib.HttpEntity;
import ch.boye.httpclientandroidlib.HttpResponse;
import ch.boye.httpclientandroidlib.NameValuePair;
import ch.boye.httpclientandroidlib.client.HttpClient;
import ch.boye.httpclientandroidlib.client.entity.UrlEncodedFormEntity;
import ch.boye.httpclientandroidlib.client.methods.HttpGet;
import ch.boye.httpclientandroidlib.client.methods.HttpPost;
import ch.boye.httpclientandroidlib.client.methods.HttpRequestBase;
import ch.boye.httpclientandroidlib.client.params.ClientPNames;
import ch.boye.httpclientandroidlib.entity.StringEntity;
import ch.boye.httpclientandroidlib.entity.mime.MultipartEntity;
import ch.boye.httpclientandroidlib.entity.mime.content.FileBody;
import ch.boye.httpclientandroidlib.entity.mime.content.StringBody;
import ch.boye.httpclientandroidlib.impl.client.DecompressingHttpClient;
import ch.boye.httpclientandroidlib.impl.client.DefaultHttpClient;
import ch.boye.httpclientandroidlib.impl.client.LaxRedirectStrategy;
import ch.boye.httpclientandroidlib.params.BasicHttpParams;
import ch.boye.httpclientandroidlib.params.CoreConnectionPNames;
import ch.boye.httpclientandroidlib.params.CoreProtocolPNames;
import ch.boye.httpclientandroidlib.params.HttpParams;
import ch.boye.httpclientandroidlib.util.EntityUtils;

import com.fasterxml.jackson.databind.node.ObjectNode;

import org.apache.commons.lang3.CharEncoding;
import org.apache.commons.lang3.StringUtils;
import org.eclipse.jdt.annotation.Nullable;

import android.content.Context;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.net.Uri;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.util.regex.Pattern;

public abstract class Network {

    /** User agent id */
    private final static String PC_USER_AGENT = "Mozilla/5.0 (X11; Linux x86_64; rv:9.0.1) Gecko/20100101 Firefox/9.0.1";
    /** Native user agent, taken from a Android 2.2 Nexus **/
    private final static String NATIVE_USER_AGENT = "Mozilla/5.0 (Linux; U; Android 2.2; en-us; Nexus One Build/FRF91) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1";

    private static final Pattern PATTERN_PASSWORD = Pattern.compile("(?<=[\\?&])[Pp]ass(w(or)?d)?=[^&#$]+");

    private final static HttpParams clientParams = new BasicHttpParams();

    static {
        clientParams.setParameter(CoreProtocolPNames.HTTP_CONTENT_CHARSET, CharEncoding.UTF_8);
        clientParams.setParameter(CoreConnectionPNames.CONNECTION_TIMEOUT, 30000);
        clientParams.setParameter(CoreConnectionPNames.SO_TIMEOUT, 90000);
        clientParams.setParameter(ClientPNames.HANDLE_REDIRECTS,  true);
    }

    private static String hidePassword(final String message) {
        return PATTERN_PASSWORD.matcher(message).replaceAll("password=***");
    }

    private static HttpClient getHttpClient() {
        final DefaultHttpClient client = new DefaultHttpClient();
        client.setCookieStore(Cookies.cookieStore);
        client.setParams(clientParams);
        client.setRedirectStrategy(new LaxRedirectStrategy());
        return new DecompressingHttpClient(client);
    }

    /**
     * POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @return the HTTP response, or null in case of an encoding error params
     */
    @Nullable
    public static HttpResponse postRequest(final String uri, final Parameters params) {
        return request("POST", uri, params, null, null);
    }

    /**
     * POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @params headers the headers to add to the request
     * @return the HTTP response, or null in case of an encoding error params
     */
    @Nullable
    public static HttpResponse postRequest(final String uri, final Parameters params, final Parameters headers) {
        return request("POST", uri, params, headers, null);
    }

    /**
     *  POST HTTP request with Json POST DATA
     *
     * @param uri the URI to request
     * @param json the json object to add to the POST request
     * @return the HTTP response, or null in case of an encoding error params
     */
    @Nullable
    public static HttpResponse postJsonRequest(final String uri, final ObjectNode json) {
        HttpPost request = new HttpPost(uri);
        request.addHeader("Content-Type", "application/json; charset=utf-8");
        if (json != null) {
            try {
                request.setEntity(new StringEntity(json.toString(), CharEncoding.UTF_8));
            } catch (UnsupportedEncodingException e) {
                Log.e("postJsonRequest:JSON Entity: UnsupportedEncodingException", e);
                return null;
            }
        }
        return doLogRequest(request);
    }

    /**
     * Multipart POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @param fileFieldName the name of the file field name
     * @param fileContentType the content-type of the file
     * @param file the file to include in the request
     * @return the HTTP response, or null in case of an encoding error param
     */
    @Nullable
    public static HttpResponse postRequest(final String uri, final Parameters params,
            final String fileFieldName, final String fileContentType, final File file) {
        final MultipartEntity entity = new MultipartEntity();
        for (final NameValuePair param : params) {
            try {
                entity.addPart(param.getName(), new StringBody(param.getValue(), TextUtils.CHARSET_UTF8));
            } catch (final UnsupportedEncodingException e) {
                Log.e("Network.postRequest: unsupported encoding for parameter " + param.getName(), e);
                return null;
            }
        }
        entity.addPart(fileFieldName, new FileBody(file, fileContentType));

        final HttpPost request = new HttpPost(uri);
        request.setEntity(entity);

        addHeaders(request, null, null);
        return doLogRequest(request);
    }

    /**
     * Make an HTTP request
     *
     * @param method
     *            the HTTP method to use ("GET" or "POST")
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add to the URI
     * @param headers
     *            the headers to add to the request
     * @param cacheFile
     *            the cache file used to cache this query
     * @return the HTTP response, or null in case of an encoding error in a POST request arguments
     */
    @Nullable
    private static HttpResponse request(final String method, final String uri,
                                        @Nullable final Parameters params, @Nullable final Parameters headers, @Nullable final File cacheFile) {
        HttpRequestBase request;
        if (method.equals("GET")) {
            final String fullUri = params == null ? uri : Uri.parse(uri).buildUpon().encodedQuery(params.toString()).build().toString();
            request = new HttpGet(fullUri);
        } else {
            request = new HttpPost(uri);
            if (params != null) {
                try {
                    ((HttpPost) request).setEntity(new UrlEncodedFormEntity(params, CharEncoding.UTF_8));
                } catch (final UnsupportedEncodingException e) {
                    Log.e("request", e);
                    return null;
                }
            }
        }

        addHeaders(request, headers, cacheFile);

        return doLogRequest(request);
    }

    /**
     * Add headers to HTTP request.
     * @param request
     *            the request to add headers to
     * @param headers
     *            the headers to add (in addition to the standard headers), can be null
     * @param cacheFile
     *            if non-null, the file to take ETag and If-Modified-Since information from
     */
    private static void addHeaders(final HttpRequestBase request, @Nullable final Parameters headers, @Nullable final File cacheFile) {
        for (final NameValuePair header : Parameters.extend(Parameters.merge(headers, cacheHeaders(cacheFile)),
                "Accept-Charset", "utf-8,iso-8859-1;q=0.8,utf-16;q=0.8,*;q=0.7",
                "Accept-Language", "en-US,*;q=0.9",
                "X-Requested-With", "XMLHttpRequest")) {
            request.setHeader(header.getName(), header.getValue());
        }
        request.getParams().setParameter(CoreProtocolPNames.USER_AGENT,
                Settings.getUseNativeUa() ? NATIVE_USER_AGENT : PC_USER_AGENT);
    }

    /**
     * Perform an HTTP request and log it.
     *
     * @param request
     *            the request to try
     * @return
     *            the response, or null if there has been a failure
     */
    @Nullable
    private static HttpResponse doLogRequest(final HttpRequestBase request) {
        final String reqLogStr = request.getMethod() + " " + hidePassword(request.getURI().toString());
        Log.d(reqLogStr);

        final HttpClient client = getHttpClient();
        final long before = System.currentTimeMillis();
        try {
            final HttpResponse response = client.execute(request);
            int status = response.getStatusLine().getStatusCode();
            if (status == 200) {
                Log.d(status + formatTimeSpan(before) + reqLogStr);
            } else {
                Log.w(status + " [" + response.getStatusLine().getReasonPhrase() + "]" + formatTimeSpan(before) + reqLogStr);
            }
            return response;
        } catch (final IOException e) {
            final String timeSpan = formatTimeSpan(before);
            Log.w("Failure" + timeSpan + reqLogStr + " (" + e.toString() + ")");
        }

        return null;
    }

    @Nullable
    private static Parameters cacheHeaders(@Nullable final File cacheFile) {
        if (cacheFile == null || !cacheFile.exists()) {
            return null;
        }

        final String etag = LocalStorage.getSavedHeader(cacheFile, LocalStorage.HEADER_ETAG);
        if (etag != null) {
            // The ETag is a more robust check than a timestamp. If we have an ETag, it is enough
            // to identify the right version of the resource.
            return new Parameters("If-None-Match", etag);
        }

        final String lastModified = LocalStorage.getSavedHeader(cacheFile, LocalStorage.HEADER_LAST_MODIFIED);
        if (lastModified != null) {
            return new Parameters("If-Modified-Since", lastModified);
        }

        return null;
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @param cacheFile
     *            the name of the file storing the cached resource, or null not to use one
     * @return the HTTP response
     */
    @Nullable
    public static HttpResponse getRequest(final String uri, @Nullable final Parameters params, @Nullable final File cacheFile) {
        return request("GET", uri, params, null, cacheFile);
    }


    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @return the HTTP response
     */
    @Nullable
    public static HttpResponse getRequest(final String uri, @Nullable final Parameters params) {
        return request("GET", uri, params, null, null);
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @param headers
     *            the headers to add to the GET request
     * @return the HTTP response
     */
    @Nullable
    public static HttpResponse getRequest(final String uri, @Nullable final Parameters params, @Nullable final Parameters headers) {
        return request("GET", uri, params, headers, null);
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @return the HTTP response
     */
    @Nullable
    public static HttpResponse getRequest(final String uri) {
        return request("GET", uri, null, null, null);
    }

    private static String formatTimeSpan(final long before) {
        // don't use String.format in a pure logging routine, it has very bad performance
        return " (" + (System.currentTimeMillis() - before) + " ms) ";
    }

    static public boolean isSuccess(@Nullable final HttpResponse response) {
        return response != null && response.getStatusLine().getStatusCode() == 200;
    }

    static public boolean isPageNotFound(@Nullable final HttpResponse response) {
        return response != null && response.getStatusLine().getStatusCode() == 404;
    }

    /**
     * Get the result of a GET HTTP request returning a JSON body.
     *
     * @param uri the base URI of the GET HTTP request
     * @param params the query parameters, or <code>null</code> if there are none
     * @return a JSON object if the request was successful and the body could be decoded, <code>null</code> otherwise
     */
    @Nullable
    public static ObjectNode requestJSON(final String uri, @Nullable final Parameters params) {
        final HttpResponse response = request("GET", uri, params, new Parameters("Accept", "application/json, text/javascript, */*; q=0.01"), null);
        final String responseData = getResponseData(response, false);
        if (responseData != null) {
            try {
                return (ObjectNode) JsonUtils.reader.readTree(responseData);
            } catch (final IOException e) {
                Log.w("requestJSON", e);
            }
        }

        return null;
    }

    /**
     * Get the input stream corresponding to a HTTP response if it exists.
     *
     * @param response a HTTP response, which can be null
     * @return the input stream if the HTTP request is successful, <code>null</code> otherwise
     */
    @Nullable
    public static InputStream getResponseStream(@Nullable final HttpResponse response) {
        if (!isSuccess(response)) {
            return null;
        }
        assert(response != null);
        final HttpEntity entity = response.getEntity();
        if (entity == null) {
            return null;
        }
        try {
            return entity.getContent();
        } catch (final IOException e) {
            Log.e("Network.getResponseStream", e);
            return null;
        }
    }

    @Nullable
    private static String getResponseDataNoError(final HttpResponse response, boolean replaceWhitespace) {
        try {
            String data = EntityUtils.toString(response.getEntity(), CharEncoding.UTF_8);
            return replaceWhitespace ? TextUtils.replaceWhitespace(data) : data;
        } catch (Exception e) {
            Log.e("getResponseData", e);
            return null;
        }
    }

    /**
     * Get the body of a HTTP response.
     *
     * {@link TextUtils#replaceWhitespace(String)} will be called on the result
     *
     * @param response a HTTP response, which can be null
     * @return the body if the response comes from a successful HTTP request, <code>null</code> otherwise
     */
    @Nullable
    public static String getResponseData(@Nullable final HttpResponse response) {
        return getResponseData(response, true);
    }

    @Nullable
    public static String getResponseDataAlways(@Nullable final HttpResponse response) {
        return response != null ? getResponseDataNoError(response, false) : null;
    }

    /**
     * Get the body of a HTTP response.
     *
     * @param response a HTTP response, which can be null
     * @param replaceWhitespace <code>true</code> if {@link TextUtils#replaceWhitespace(String)}
     *                          should be called on the body
     * @return the body if the response comes from a successful HTTP request, <code>null</code> otherwise
     */
    @Nullable
    public static String getResponseData(@Nullable final HttpResponse response, boolean replaceWhitespace) {
        if (!isSuccess(response)) {
            return null;
        }
        assert response != null; // Caught above
        return getResponseDataNoError(response, replaceWhitespace);
    }

    @Nullable
    public static String rfc3986URLEncode(String text) {
        final String encoded = encode(text);
        return encoded != null ? StringUtils.replace(encoded.replace("+", "%20"), "%7E", "~") : null;
    }

    @Nullable
    public static String decode(final String text) {
        try {
            return URLDecoder.decode(text, CharEncoding.UTF_8);
        } catch (UnsupportedEncodingException e) {
            Log.e("Network.decode", e);
        }
        return null;
    }

    @Nullable
    public static String encode(final String text) {
        try {
            return URLEncoder.encode(text, CharEncoding.UTF_8);
        } catch (UnsupportedEncodingException e) {
            Log.e("Network.encode", e);
        }
        return null;
    }

    /**
     * Checks if the device has network connection.
     *
     * @param context
     *            context of the application, cannot be null
     *
     * @return <code>true</code> if the device is connected to the network.
     */
    public static boolean isNetworkConnected(Context context) {
        ConnectivityManager conMan = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
        NetworkInfo activeNetwork = conMan.getActiveNetworkInfo();

        return activeNetwork != null && activeNetwork.isConnected();
    }

}
!@#$%
20190527_004634,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_a15724
package cgeo.geocaching.network;

import cgeo.geocaching.files.LocalStorage;
import cgeo.geocaching.settings.Settings;
import cgeo.geocaching.utils.Log;
import cgeo.geocaching.utils.TextUtils;

import ch.boye.httpclientandroidlib.HttpEntity;
import ch.boye.httpclientandroidlib.HttpResponse;
import ch.boye.httpclientandroidlib.NameValuePair;
import ch.boye.httpclientandroidlib.client.HttpClient;
import ch.boye.httpclientandroidlib.client.entity.UrlEncodedFormEntity;
import ch.boye.httpclientandroidlib.client.methods.HttpGet;
import ch.boye.httpclientandroidlib.client.methods.HttpPost;
import ch.boye.httpclientandroidlib.client.methods.HttpRequestBase;
import ch.boye.httpclientandroidlib.client.params.ClientPNames;
import ch.boye.httpclientandroidlib.entity.StringEntity;
import ch.boye.httpclientandroidlib.entity.mime.MultipartEntity;
import ch.boye.httpclientandroidlib.entity.mime.content.FileBody;
import ch.boye.httpclientandroidlib.entity.mime.content.StringBody;
import ch.boye.httpclientandroidlib.impl.client.DecompressingHttpClient;
import ch.boye.httpclientandroidlib.impl.client.DefaultHttpClient;
import ch.boye.httpclientandroidlib.impl.client.LaxRedirectStrategy;
import ch.boye.httpclientandroidlib.params.BasicHttpParams;
import ch.boye.httpclientandroidlib.params.CoreConnectionPNames;
import ch.boye.httpclientandroidlib.params.CoreProtocolPNames;
import ch.boye.httpclientandroidlib.params.HttpParams;
import ch.boye.httpclientandroidlib.util.EntityUtils;
import org.apache.commons.lang3.CharEncoding;
import org.apache.commons.lang3.StringUtils;
import org.eclipse.jdt.annotation.Nullable;
import org.json.JSONException;
import org.json.JSONObject;

import android.content.Context;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.net.Uri;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.net.URLEncoder;

public abstract class Network {

    /** User agent id */
    private final static String PC_USER_AGENT = "Mozilla/5.0 (X11; Linux x86_64; rv:9.0.1) Gecko/20100101 Firefox/9.0.1";
    /** Native user agent, taken from a Android 2.2 Nexus **/
    private final static String NATIVE_USER_AGENT = "Mozilla/5.0 (Linux; U; Android 2.2; en-us; Nexus One Build/FRF91) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1";

    private static final String PATTERN_PASSWORD = "(?<=[\\?&])[Pp]ass(w(or)?d)?=[^&#$]+";

    private final static HttpParams clientParams = new BasicHttpParams();

    static {
        clientParams.setParameter(CoreProtocolPNames.HTTP_CONTENT_CHARSET, CharEncoding.UTF_8);
        clientParams.setParameter(CoreConnectionPNames.CONNECTION_TIMEOUT, 30000);
        clientParams.setParameter(CoreConnectionPNames.SO_TIMEOUT, 90000);
        clientParams.setParameter(ClientPNames.HANDLE_REDIRECTS,  true);
    }

    private static String hidePassword(final String message) {
        return message.replaceAll(PATTERN_PASSWORD, "password=***");
    }

    private static HttpClient getHttpClient() {
        final DefaultHttpClient client = new DefaultHttpClient();
        client.setCookieStore(Cookies.cookieStore);
        client.setParams(clientParams);
        client.setRedirectStrategy(new LaxRedirectStrategy());
        return new DecompressingHttpClient(client);
    }

    /**
     * POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @return the HTTP response, or null in case of an encoding error params
     */
    @Nullable
    public static HttpResponse postRequest(final String uri, final Parameters params) {
        return request("POST", uri, params, null, null);
    }

    /**
     * POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @params headers the headers to add to the request
     * @return the HTTP response, or null in case of an encoding error params
     */
    @Nullable
    public static HttpResponse postRequest(final String uri, final Parameters params, final Parameters headers) {
        return request("POST", uri, params, headers, null);
    }

    /**
     *  POST HTTP request with Json POST DATA
     *
     * @param uri the URI to request
     * @param json the json object to add to the POST request
     * @return the HTTP response, or null in case of an encoding error params
     */
    @Nullable
    public static HttpResponse postJsonRequest(final String uri, final JSONObject json) {
        HttpPost request = new HttpPost(uri);
        request.addHeader("Content-Type", "application/json; charset=utf-8");
        if (json != null) {
            try {
                request.setEntity(new StringEntity(json.toString(), CharEncoding.UTF_8));
            } catch (UnsupportedEncodingException e) {
                Log.e("postJsonRequest:JSON Entity: UnsupportedEncodingException");
                return null;
            }
        }
        return doLogRequest(request);
    }

    /**
     * Multipart POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @param fileFieldName the name of the file field name
     * @param fileContentType the content-type of the file
     * @param file the file to include in the request
     * @return the HTTP response, or null in case of an encoding error param
     */
    @Nullable
    public static HttpResponse postRequest(final String uri, final Parameters params,
            final String fileFieldName, final String fileContentType, final File file) {
        final MultipartEntity entity = new MultipartEntity();
        for (final NameValuePair param : params) {
            try {
                entity.addPart(param.getName(), new StringBody(param.getValue(), TextUtils.CHARSET_UTF8));
            } catch (final UnsupportedEncodingException e) {
                Log.e("Network.postRequest: unsupported encoding for parameter " + param.getName(), e);
                return null;
            }
        }
        entity.addPart(fileFieldName, new FileBody(file, fileContentType));

        final HttpPost request = new HttpPost(uri);
        request.setEntity(entity);

        addHeaders(request, null, null);
        return doLogRequest(request);
    }

    /**
     * Make an HTTP request
     *
     * @param method
     *            the HTTP method to use ("GET" or "POST")
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add to the URI
     * @param headers
     *            the headers to add to the request
     * @param cacheFile
     *            the cache file used to cache this query
     * @return the HTTP response, or null in case of an encoding error in a POST request arguments
     */
    @Nullable
    private static HttpResponse request(final String method, final String uri,
                                        @Nullable final Parameters params, @Nullable final Parameters headers, @Nullable final File cacheFile) {
        HttpRequestBase request;
        if (method.equals("GET")) {
            final String fullUri = params == null ? uri : Uri.parse(uri).buildUpon().encodedQuery(params.toString()).build().toString();
            request = new HttpGet(fullUri);
        } else {
            request = new HttpPost(uri);
            if (params != null) {
                try {
                    ((HttpPost) request).setEntity(new UrlEncodedFormEntity(params, CharEncoding.UTF_8));
                } catch (final UnsupportedEncodingException e) {
                    Log.e("request", e);
                    return null;
                }
            }
        }

        addHeaders(request, headers, cacheFile);

        return doLogRequest(request);
    }

    /**
     * Add headers to HTTP request.
     * @param request
     *            the request to add headers to
     * @param headers
     *            the headers to add (in addition to the standard headers), can be null
     * @param cacheFile
     *            if non-null, the file to take ETag and If-Modified-Since information from
     */
    private static void addHeaders(final HttpRequestBase request, @Nullable final Parameters headers, @Nullable final File cacheFile) {
        for (final NameValuePair header : Parameters.extend(Parameters.merge(headers, cacheHeaders(cacheFile)),
                "Accept-Charset", "utf-8,iso-8859-1;q=0.8,utf-16;q=0.8,*;q=0.7",
                "Accept-Language", "en-US,*;q=0.9",
                "X-Requested-With", "XMLHttpRequest")) {
            request.setHeader(header.getName(), header.getValue());
        }
        request.getParams().setParameter(CoreProtocolPNames.USER_AGENT,
                Settings.getUseNativeUa() ? NATIVE_USER_AGENT : PC_USER_AGENT);
    }

    /**
     * Perform an HTTP request and log it.
     *
     * @param request
     *            the request to try
     * @return
     *            the response, or null if there has been a failure
     */
    @Nullable
    private static HttpResponse doLogRequest(final HttpRequestBase request) {
        final String reqLogStr = request.getMethod() + " " + hidePassword(request.getURI().toString());
        Log.d(reqLogStr);

        final HttpClient client = getHttpClient();
        final long before = System.currentTimeMillis();
        try {
            final HttpResponse response = client.execute(request);
            int status = response.getStatusLine().getStatusCode();
            if (status == 200) {
                Log.d(status + formatTimeSpan(before) + reqLogStr);
            } else {
                Log.w(status + " [" + response.getStatusLine().getReasonPhrase() + "]" + formatTimeSpan(before) + reqLogStr);
            }
            return response;
        } catch (final IOException e) {
            final String timeSpan = formatTimeSpan(before);
            Log.w("Failure" + timeSpan + reqLogStr + " (" + e.toString() + ")");
        }

        return null;
    }

    @Nullable
    private static Parameters cacheHeaders(@Nullable final File cacheFile) {
        if (cacheFile == null || !cacheFile.exists()) {
            return null;
        }

        final String etag = LocalStorage.getSavedHeader(cacheFile, LocalStorage.HEADER_ETAG);
        if (etag != null) {
            // The ETag is a more robust check than a timestamp. If we have an ETag, it is enough
            // to identify the right version of the resource.
            return new Parameters("If-None-Match", etag);
        }

        final String lastModified = LocalStorage.getSavedHeader(cacheFile, LocalStorage.HEADER_LAST_MODIFIED);
        if (lastModified != null) {
            return new Parameters("If-Modified-Since", lastModified);
        }

        return null;
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @param cacheFile
     *            the name of the file storing the cached resource, or null not to use one
     * @return the HTTP response
     */
    @Nullable
    public static HttpResponse getRequest(final String uri, @Nullable final Parameters params, @Nullable final File cacheFile) {
        return request("GET", uri, params, null, cacheFile);
    }


    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @return the HTTP response
     */
    @Nullable
    public static HttpResponse getRequest(final String uri, @Nullable final Parameters params) {
        return request("GET", uri, params, null, null);
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @param headers
     *            the headers to add to the GET request
     * @return the HTTP response
     */
    @Nullable
    public static HttpResponse getRequest(final String uri, @Nullable final Parameters params, @Nullable final Parameters headers) {
        return request("GET", uri, params, headers, null);
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @return the HTTP response
     */
    @Nullable
    public static HttpResponse getRequest(final String uri) {
        return request("GET", uri, null, null, null);
    }

    private static String formatTimeSpan(final long before) {
        // don't use String.format in a pure logging routine, it has very bad performance
        return " (" + (System.currentTimeMillis() - before) + " ms) ";
    }

    static public boolean isSuccess(@Nullable final HttpResponse response) {
        return response != null && response.getStatusLine().getStatusCode() == 200;
    }

    static public boolean isPageNotFound(@Nullable final HttpResponse response) {
        return response != null && response.getStatusLine().getStatusCode() == 404;
    }

    /**
     * Get the result of a GET HTTP request returning a JSON body.
     *
     * @param uri the base URI of the GET HTTP request
     * @param params the query parameters, or <code>null</code> if there are none
     * @return a JSON object if the request was successful and the body could be decoded, <code>null</code> otherwise
     */
    @Nullable
    public static JSONObject requestJSON(final String uri, @Nullable final Parameters params) {
        final HttpResponse response = request("GET", uri, params, new Parameters("Accept", "application/json, text/javascript, */*; q=0.01"), null);
        final String responseData = getResponseData(response, false);
        if (responseData != null) {
            try {
                return new JSONObject(responseData);
            } catch (final JSONException e) {
                Log.w("Network.requestJSON", e);
            }
        }

        return null;
    }

    /**
     * Get the input stream corresponding to a HTTP response if it exists.
     *
     * @param response a HTTP response, which can be null
     * @return the input stream if the HTTP request is successful, <code>null</code> otherwise
     */
    @Nullable
    public static InputStream getResponseStream(@Nullable final HttpResponse response) {
        if (!isSuccess(response)) {
            return null;
        }
        assert(response != null);
        final HttpEntity entity = response.getEntity();
        if (entity == null) {
            return null;
        }
        try {
            return entity.getContent();
        } catch (final IOException e) {
            Log.e("Network.getResponseStream", e);
            return null;
        }
    }

    @Nullable
    private static String getResponseDataNoError(final HttpResponse response, boolean replaceWhitespace) {
        try {
            String data = EntityUtils.toString(response.getEntity(), CharEncoding.UTF_8);
            return replaceWhitespace ? TextUtils.replaceWhitespace(data) : data;
        } catch (Exception e) {
            Log.e("getResponseData", e);
            return null;
        }
    }

    /**
     * Get the body of a HTTP response.
     *
     * {@link TextUtils#replaceWhitespace(String)} will be called on the result
     *
     * @param response a HTTP response, which can be null
     * @return the body if the response comes from a successful HTTP request, <code>null</code> otherwise
     */
    @Nullable
    public static String getResponseData(@Nullable final HttpResponse response) {
        return getResponseData(response, true);
    }

    @Nullable
    public static String getResponseDataAlways(@Nullable final HttpResponse response) {
        return response != null ? getResponseDataNoError(response, false) : null;
    }

    /**
     * Get the body of a HTTP response.
     *
     * @param response a HTTP response, which can be null
     * @param replaceWhitespace <code>true</code> if {@link TextUtils#replaceWhitespace(String)}
     *                          should be called on the body
     * @return the body if the response comes from a successful HTTP request, <code>null</code> otherwise
     */
    @Nullable
    public static String getResponseData(@Nullable final HttpResponse response, boolean replaceWhitespace) {
        if (!isSuccess(response)) {
            return null;
        }
        assert response != null; // Caught above
        return getResponseDataNoError(response, replaceWhitespace);
    }

    @Nullable
    public static String rfc3986URLEncode(String text) {
        final String encoded = encode(text);
        return encoded != null ? StringUtils.replace(encoded.replace("+", "%20"), "%7E", "~") : null;
    }

    @Nullable
    public static String decode(final String text) {
        try {
            return URLDecoder.decode(text, CharEncoding.UTF_8);
        } catch (UnsupportedEncodingException e) {
            Log.e("Network.decode", e);
        }
        return null;
    }

    @Nullable
    public static String encode(final String text) {
        try {
            return URLEncoder.encode(text, CharEncoding.UTF_8);
        } catch (UnsupportedEncodingException e) {
            Log.e("Network.encode", e);
        }
        return null;
    }

    /**
     * Checks if the device has network connection.
     *
     * @param context
     *            context of the application, cannot be null
     *
     * @return <code>true</code> if the device is connected to the network.
     */
    public static boolean isNetworkConnected(Context context) {
        ConnectivityManager conMan = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
        NetworkInfo activeNetwork = conMan.getActiveNetworkInfo();

        return activeNetwork != null && activeNetwork.isConnected();
    }

}
!@#$%
20190527_004634,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_c15724
package cgeo.geocaching.network;

import cgeo.geocaching.files.LocalStorage;
import cgeo.geocaching.settings.Settings;
import cgeo.geocaching.utils.Log;
import cgeo.geocaching.utils.TextUtils;

import ch.boye.httpclientandroidlib.HttpEntity;
import ch.boye.httpclientandroidlib.HttpResponse;
import ch.boye.httpclientandroidlib.NameValuePair;
import ch.boye.httpclientandroidlib.client.HttpClient;
import ch.boye.httpclientandroidlib.client.entity.UrlEncodedFormEntity;
import ch.boye.httpclientandroidlib.client.methods.HttpGet;
import ch.boye.httpclientandroidlib.client.methods.HttpPost;
import ch.boye.httpclientandroidlib.client.methods.HttpRequestBase;
import ch.boye.httpclientandroidlib.client.params.ClientPNames;
import ch.boye.httpclientandroidlib.entity.StringEntity;
import ch.boye.httpclientandroidlib.entity.mime.MultipartEntity;
import ch.boye.httpclientandroidlib.entity.mime.content.FileBody;
import ch.boye.httpclientandroidlib.entity.mime.content.StringBody;
import ch.boye.httpclientandroidlib.impl.client.DecompressingHttpClient;
import ch.boye.httpclientandroidlib.impl.client.DefaultHttpClient;
import ch.boye.httpclientandroidlib.impl.client.LaxRedirectStrategy;
import ch.boye.httpclientandroidlib.params.BasicHttpParams;
import ch.boye.httpclientandroidlib.params.CoreConnectionPNames;
import ch.boye.httpclientandroidlib.params.CoreProtocolPNames;
import ch.boye.httpclientandroidlib.params.HttpParams;
import ch.boye.httpclientandroidlib.util.EntityUtils;
import org.apache.commons.lang3.CharEncoding;
import org.apache.commons.lang3.StringUtils;
import org.eclipse.jdt.annotation.Nullable;
import org.json.JSONException;
import org.json.JSONObject;

import android.content.Context;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.net.Uri;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.net.URLEncoder;

public abstract class Network {

    /** User agent id */
    private final static String PC_USER_AGENT = "Mozilla/5.0 (X11; Linux x86_64; rv:9.0.1) Gecko/20100101 Firefox/9.0.1";
    /** Native user agent, taken from a Android 2.2 Nexus **/
    private final static String NATIVE_USER_AGENT = "Mozilla/5.0 (Linux; U; Android 2.2; en-us; Nexus One Build/FRF91) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1";

    private static final String PATTERN_PASSWORD = "(?<=[\\?&])[Pp]ass(w(or)?d)?=[^&#$]+";

    private final static HttpParams clientParams = new BasicHttpParams();

    static {
        clientParams.setParameter(CoreProtocolPNames.HTTP_CONTENT_CHARSET, CharEncoding.UTF_8);
        clientParams.setParameter(CoreConnectionPNames.CONNECTION_TIMEOUT, 30000);
        clientParams.setParameter(CoreConnectionPNames.SO_TIMEOUT, 90000);
        clientParams.setParameter(ClientPNames.HANDLE_REDIRECTS,  true);
    }

    private static String hidePassword(final String message) {
        return message.replaceAll(PATTERN_PASSWORD, "password=***");
    }

    private static HttpClient getHttpClient() {
        final DefaultHttpClient client = new DefaultHttpClient();
        client.setCookieStore(Cookies.cookieStore);
        client.setParams(clientParams);
        client.setRedirectStrategy(new LaxRedirectStrategy());
        return new DecompressingHttpClient(client);
    }

    /**
     * POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @return the HTTP response, or null in case of an encoding error params
     */
    @Nullable
    public static HttpResponse postRequest(final String uri, final Parameters params) {
        return request("POST", uri, params, null, null);
    }

    /**
     * POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @params headers the headers to add to the request
     * @return the HTTP response, or null in case of an encoding error params
     */
    @Nullable
    public static HttpResponse postRequest(final String uri, final Parameters params, final Parameters headers) {
        return request("POST", uri, params, headers, null);
    }

    /**
     *  POST HTTP request with Json POST DATA
     *
     * @param uri the URI to request
     * @param json the json object to add to the POST request
     * @return the HTTP response, or null in case of an encoding error params
     */
    @Nullable
    public static HttpResponse postJsonRequest(final String uri, final JSONObject json) {
        HttpPost request = new HttpPost(uri);
        request.addHeader("Content-Type", "application/json; charset=utf-8");
        if (json != null) {
            try {
                request.setEntity(new StringEntity(json.toString(), CharEncoding.UTF_8));
            } catch (UnsupportedEncodingException e) {
                Log.e("postJsonRequest:JSON Entity: UnsupportedEncodingException");
                return null;
            }
        }
        return doLogRequest(request);
    }

    /**
     * Multipart POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @param fileFieldName the name of the file field name
     * @param fileContentType the content-type of the file
     * @param file the file to include in the request
     * @return the HTTP response, or null in case of an encoding error param
     */
    @Nullable
    public static HttpResponse postRequest(final String uri, final Parameters params,
            final String fileFieldName, final String fileContentType, final File file) {
        final MultipartEntity entity = new MultipartEntity();
        for (final NameValuePair param : params) {
            try {
                entity.addPart(param.getName(), new StringBody(param.getValue(), TextUtils.CHARSET_UTF8));
            } catch (final UnsupportedEncodingException e) {
                Log.e("Network.postRequest: unsupported encoding for parameter " + param.getName(), e);
                return null;
            }
        }
        entity.addPart(fileFieldName, new FileBody(file, fileContentType));

        final HttpPost request = new HttpPost(uri);
        request.setEntity(entity);

        addHeaders(request, null, null);
        return doLogRequest(request);
    }

    /**
     * Make an HTTP request
     *
     * @param method
     *            the HTTP method to use ("GET" or "POST")
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add to the URI
     * @param headers
     *            the headers to add to the request
     * @param cacheFile
     *            the cache file used to cache this query
     * @return the HTTP response, or null in case of an encoding error in a POST request arguments
     */
    @Nullable
    private static HttpResponse request(final String method, final String uri,
                                        @Nullable final Parameters params, @Nullable final Parameters headers, @Nullable final File cacheFile) {
        HttpRequestBase request;
        if (method.equals("GET")) {
            final String fullUri = params == null ? uri : Uri.parse(uri).buildUpon().encodedQuery(params.toString()).build().toString();
            request = new HttpGet(fullUri);
        } else {
            request = new HttpPost(uri);
            if (params != null) {
                try {
                    ((HttpPost) request).setEntity(new UrlEncodedFormEntity(params, CharEncoding.UTF_8));
                } catch (final UnsupportedEncodingException e) {
                    Log.e("request", e);
                    return null;
                }
            }
        }

        addHeaders(request, headers, cacheFile);

        return doLogRequest(request);
    }

    /**
     * Add headers to HTTP request.
     * @param request
     *            the request to add headers to
     * @param headers
     *            the headers to add (in addition to the standard headers), can be null
     * @param cacheFile
     *            if non-null, the file to take ETag and If-Modified-Since information from
     */
    private static void addHeaders(final HttpRequestBase request, @Nullable final Parameters headers, @Nullable final File cacheFile) {
        for (final NameValuePair header : Parameters.extend(Parameters.merge(headers, cacheHeaders(cacheFile)),
                "Accept-Charset", "utf-8,iso-8859-1;q=0.8,utf-16;q=0.8,*;q=0.7",
                "Accept-Language", "en-US,*;q=0.9",
                "X-Requested-With", "XMLHttpRequest")) {
            request.setHeader(header.getName(), header.getValue());
        }
        request.getParams().setParameter(CoreProtocolPNames.USER_AGENT,
                Settings.getUseNativeUa() ? NATIVE_USER_AGENT : PC_USER_AGENT);
    }

    /**
     * Perform an HTTP request and log it.
     *
     * @param request
     *            the request to try
     * @return
     *            the response, or null if there has been a failure
     */
    @Nullable
    private static HttpResponse doLogRequest(final HttpRequestBase request) {
        final String reqLogStr = request.getMethod() + " " + hidePassword(request.getURI().toString());
        Log.d(reqLogStr);

        final HttpClient client = getHttpClient();
        final long before = System.currentTimeMillis();
        try {
            final HttpResponse response = client.execute(request);
            int status = response.getStatusLine().getStatusCode();
            if (status == 200) {
                Log.d(status + formatTimeSpan(before) + reqLogStr);
            } else {
                Log.w(status + " [" + response.getStatusLine().getReasonPhrase() + "]" + formatTimeSpan(before) + reqLogStr);
            }
            return response;
        } catch (final Exception e) {
            final String timeSpan = formatTimeSpan(before);
            Log.w("Failure" + timeSpan + reqLogStr + " (" + e.toString() + ")");
        }

        return null;
    }

    @Nullable
    private static Parameters cacheHeaders(@Nullable final File cacheFile) {
        if (cacheFile == null || !cacheFile.exists()) {
            return null;
        }

        final String etag = LocalStorage.getSavedHeader(cacheFile, LocalStorage.HEADER_ETAG);
        if (etag != null) {
            // The ETag is a more robust check than a timestamp. If we have an ETag, it is enough
            // to identify the right version of the resource.
            return new Parameters("If-None-Match", etag);
        }

        final String lastModified = LocalStorage.getSavedHeader(cacheFile, LocalStorage.HEADER_LAST_MODIFIED);
        if (lastModified != null) {
            return new Parameters("If-Modified-Since", lastModified);
        }

        return null;
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @param cacheFile
     *            the name of the file storing the cached resource, or null not to use one
     * @return the HTTP response
     */
    @Nullable
    public static HttpResponse getRequest(final String uri, @Nullable final Parameters params, @Nullable final File cacheFile) {
        return request("GET", uri, params, null, cacheFile);
    }


    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @return the HTTP response
     */
    @Nullable
    public static HttpResponse getRequest(final String uri, @Nullable final Parameters params) {
        return request("GET", uri, params, null, null);
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @param headers
     *            the headers to add to the GET request
     * @return the HTTP response
     */
    @Nullable
    public static HttpResponse getRequest(final String uri, @Nullable final Parameters params, @Nullable final Parameters headers) {
        return request("GET", uri, params, headers, null);
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @return the HTTP response
     */
    @Nullable
    public static HttpResponse getRequest(final String uri) {
        return request("GET", uri, null, null, null);
    }

    private static String formatTimeSpan(final long before) {
        // don't use String.format in a pure logging routine, it has very bad performance
        return " (" + (System.currentTimeMillis() - before) + " ms) ";
    }

    static public boolean isSuccess(@Nullable final HttpResponse response) {
        return response != null && response.getStatusLine().getStatusCode() == 200;
    }

    static public boolean isPageNotFound(@Nullable final HttpResponse response) {
        return response != null && response.getStatusLine().getStatusCode() == 404;
    }

    /**
     * Get the result of a GET HTTP request returning a JSON body.
     *
     * @param uri the base URI of the GET HTTP request
     * @param params the query parameters, or <code>null</code> if there are none
     * @return a JSON object if the request was successful and the body could be decoded, <code>null</code> otherwise
     */
    @Nullable
    public static JSONObject requestJSON(final String uri, @Nullable final Parameters params) {
        final HttpResponse response = request("GET", uri, params, new Parameters("Accept", "application/json, text/javascript, */*; q=0.01"), null);
        final String responseData = getResponseData(response, false);
        if (responseData != null) {
            try {
                return new JSONObject(responseData);
            } catch (final JSONException e) {
                Log.w("Network.requestJSON", e);
            }
        }

        return null;
    }

    /**
     * Get the input stream corresponding to a HTTP response if it exists.
     *
     * @param response a HTTP response, which can be null
     * @return the input stream if the HTTP request is successful, <code>null</code> otherwise
     */
    @Nullable
    public static InputStream getResponseStream(@Nullable final HttpResponse response) {
        if (!isSuccess(response)) {
            return null;
        }
        assert(response != null);
        final HttpEntity entity = response.getEntity();
        if (entity == null) {
            return null;
        }
        try {
            return entity.getContent();
        } catch (final IOException e) {
            Log.e("Network.getResponseStream", e);
            return null;
        }
    }

    @Nullable
    private static String getResponseDataNoError(final HttpResponse response, boolean replaceWhitespace) {
        try {
            String data = EntityUtils.toString(response.getEntity(), CharEncoding.UTF_8);
            return replaceWhitespace ? TextUtils.replaceWhitespace(data) : data;
        } catch (Exception e) {
            Log.e("getResponseData", e);
            return null;
        }
    }

    /**
     * Get the body of a HTTP response.
     *
     * {@link TextUtils#replaceWhitespace(String)} will be called on the result
     *
     * @param response a HTTP response, which can be null
     * @return the body if the response comes from a successful HTTP request, <code>null</code> otherwise
     */
    @Nullable
    public static String getResponseData(@Nullable final HttpResponse response) {
        return getResponseData(response, true);
    }

    @Nullable
    public static String getResponseDataAlways(@Nullable final HttpResponse response) {
        return response != null ? getResponseDataNoError(response, false) : null;
    }

    /**
     * Get the body of a HTTP response.
     *
     * @param response a HTTP response, which can be null
     * @param replaceWhitespace <code>true</code> if {@link TextUtils#replaceWhitespace(String)}
     *                          should be called on the body
     * @return the body if the response comes from a successful HTTP request, <code>null</code> otherwise
     */
    @Nullable
    public static String getResponseData(@Nullable final HttpResponse response, boolean replaceWhitespace) {
        if (!isSuccess(response)) {
            return null;
        }
        assert response != null; // Caught above
        return getResponseDataNoError(response, replaceWhitespace);
    }

    @Nullable
    public static String rfc3986URLEncode(String text) {
        final String encoded = encode(text);
        return encoded != null ? StringUtils.replace(encoded.replace("+", "%20"), "%7E", "~") : null;
    }

    @Nullable
    public static String decode(final String text) {
        try {
            return URLDecoder.decode(text, CharEncoding.UTF_8);
        } catch (UnsupportedEncodingException e) {
            Log.e("Network.decode", e);
        }
        return null;
    }

    @Nullable
    public static String encode(final String text) {
        try {
            return URLEncoder.encode(text, CharEncoding.UTF_8);
        } catch (UnsupportedEncodingException e) {
            Log.e("Network.encode", e);
        }
        return null;
    }

    /**
     * Checks if the device has network connection.
     *
     * @param context
     *            context of the application, cannot be null
     *
     * @return <code>true</code> if the device is connected to the network.
     */
    public static boolean isNetworkConnected(Context context) {
        ConnectivityManager conMan = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
        NetworkInfo activeNetwork = conMan.getActiveNetworkInfo();

        return activeNetwork != null && activeNetwork.isConnected();
    }

}
!@#$%
20190527_005119,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_b21232
package cgeo.geocaching.connector.gc;

import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.R;
import cgeo.geocaching.connector.AbstractLogin;
import cgeo.geocaching.enumerations.StatusCode;
import cgeo.geocaching.network.Cookies;
import cgeo.geocaching.network.HtmlImage;
import cgeo.geocaching.network.Network;
import cgeo.geocaching.network.Parameters;
import cgeo.geocaching.settings.Settings;
import cgeo.geocaching.utils.Log;
import cgeo.geocaching.utils.MatcherWrapper;
import cgeo.geocaching.utils.TextUtils;

import ch.boye.httpclientandroidlib.HttpResponse;

import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;

import rx.Observable;

import android.graphics.drawable.Drawable;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

public class GCLogin extends AbstractLogin {

    private static final String DEFAULT_CUSTOM_DATE_FORMAT = "MM/dd/yyyy";

    private final static String ENGLISH = "<a href=\"#\">English &#9660;</a>";

    private final static Map<String, SimpleDateFormat> GC_CUSTOM_DATE_FORMATS;
    public static final String LANGUAGE_CHANGE_URI = "http://www.geocaching.com/my/souvenirs.aspx";

    static {
        final String[] formats = new String[] {
                DEFAULT_CUSTOM_DATE_FORMAT,
                "yyyy-MM-dd",
                "yyyy/MM/dd",
                "dd.MM.yyyy",
                "dd/MMM/yyyy",
                "dd.MMM.yyyy",
                "MMM/dd/yyyy",
                "dd MMM yy",
                "dd/MM/yyyy"
        };

        final Map<String, SimpleDateFormat> map = new HashMap<>();

        for (final String format : formats) {
            map.put(format, new SimpleDateFormat(format, Locale.ENGLISH));
        }

        GC_CUSTOM_DATE_FORMATS = Collections.unmodifiableMap(map);
    }

    private GCLogin() {
        // singleton
    }

    public static GCLogin getInstance() {
        return SingletonHolder.INSTANCE;
    }

    private static class SingletonHolder {
        private static final GCLogin INSTANCE = new GCLogin();
    }

    @Override
    protected StatusCode login(boolean retry) {
        final ImmutablePair<String, String> credentials = Settings.getGcCredentials();
        final String username = credentials.left;
        final String password = credentials.right;

        if (StringUtils.isEmpty(username) || StringUtils.isEmpty(password)) {
            clearLoginInfo();
            Log.e("Login.login: No login information stored");
            return StatusCode.NO_LOGIN_INFO_STORED;
        }

        setActualStatus(CgeoApplication.getInstance().getString(R.string.init_login_popup_working));
        HttpResponse loginResponse = Network.getRequest("https://www.geocaching.com/login/default.aspx");
        String loginData = Network.getResponseData(loginResponse);
        if (loginResponse != null && loginResponse.getStatusLine().getStatusCode() == 503 && TextUtils.matches(loginData, GCConstants.PATTERN_MAINTENANCE)) {
            return StatusCode.MAINTENANCE;
        }

        if (StringUtils.isBlank(loginData)) {
            Log.e("Login.login: Failed to retrieve login page (1st)");
            return StatusCode.CONNECTION_FAILED; // no login page
        }

        if (getLoginStatus(loginData)) {
            Log.i("Already logged in Geocaching.com as " + username + " (" + Settings.getGCMemberStatus() + ')');
            if (switchToEnglish(loginData) && retry) {
                return login(false);
            }
            return StatusCode.NO_ERROR; // logged in
        }

        Cookies.clearCookies();
        Settings.setCookieStore(null);

        final Parameters params = new Parameters(
                "__EVENTTARGET", "",
                "__EVENTARGUMENT", "",
                "ctl00$ContentBody$tbUsername", username,
                "ctl00$ContentBody$tbPassword", password,
                "ctl00$ContentBody$cbRememberMe", "on",
                "ctl00$ContentBody$btnSignIn", "Login");
        final String[] viewstates = GCLogin.getViewstates(loginData);
        if (isEmpty(viewstates)) {
            Log.e("Login.login: Failed to find viewstates");
            return StatusCode.LOGIN_PARSE_ERROR; // no viewstates
        }
        GCLogin.putViewstates(params, viewstates);

        loginResponse = Network.postRequest("https://www.geocaching.com/login/default.aspx", params);
        loginData = Network.getResponseData(loginResponse);

        if (StringUtils.isBlank(loginData)) {
            Log.e("Login.login: Failed to retrieve login page (2nd)");
            // FIXME: should it be CONNECTION_FAILED to match the first attempt?
            return StatusCode.COMMUNICATION_ERROR; // no login page
        }
        assert loginData != null;  // Caught above

        if (getLoginStatus(loginData)) {
            if (switchToEnglish(loginData) && retry) {
                return login(false);
            }
            Log.i("Successfully logged in Geocaching.com as " + username + " (" + Settings.getGCMemberStatus() + ')');
            Settings.setCookieStore(Cookies.dumpCookieStore());
            return StatusCode.NO_ERROR; // logged in
        }

        if (loginData.contains("Your username/password combination does not match.")) {
            Log.i("Failed to log in Geocaching.com as " + username + " because of wrong username/password");
            return StatusCode.WRONG_LOGIN_DATA; // wrong login
        }

        if (loginData.contains("You must validate your account before you can log in.")) {
            Log.i("Failed to log in Geocaching.com as " + username + " because account needs to be validated first");
            return StatusCode.UNVALIDATED_ACCOUNT;
        }

        Log.i("Failed to log in Geocaching.com as " + username + " for some unknown reason");
        if (retry) {
            switchToEnglish(loginData);
            return login(false);
        }

        return StatusCode.UNKNOWN_ERROR; // can't login
    }

    public StatusCode logout() {
        final HttpResponse logoutResponse = Network.getRequest("https://www.geocaching.com/login/default.aspx?RESET=Y&redir=http%3a%2f%2fwww.geocaching.com%2fdefault.aspx%3f");
        final String logoutData = Network.getResponseData(logoutResponse);
        if (logoutResponse != null && logoutResponse.getStatusLine().getStatusCode() == 503 && TextUtils.matches(logoutData, GCConstants.PATTERN_MAINTENANCE)) {
            return StatusCode.MAINTENANCE;
        }

        resetLoginStatus();

        return StatusCode.NO_ERROR;
    }

    private static String removeDotAndComma(final String str) {
        return StringUtils.replaceChars(str, ".,", null);
    }

    /**
     * Check if the user has been logged in when he retrieved the data.
     *
     * @param page
     * @return <code>true</code> if user is logged in, <code>false</code> otherwise
     */
    public boolean getLoginStatus(@Nullable final String page) {
        if (StringUtils.isBlank(page)) {
            Log.e("Login.checkLogin: No page given");
            return false;
        }
        assert page != null;

        if (TextUtils.matches(page, GCConstants.PATTERN_MAP_LOGGED_IN)) {
            return true;
        }

        setActualStatus(CgeoApplication.getInstance().getString(R.string.init_login_popup_ok));

        // on every page except login page
        setActualLoginStatus(TextUtils.matches(page, GCConstants.PATTERN_LOGIN_NAME));
        if (isActualLoginStatus()) {
            setActualUserName(TextUtils.getMatch(page, GCConstants.PATTERN_LOGIN_NAME, true, "???"));
            int cachesCount = 0;
            try {
                cachesCount = Integer.parseInt(removeDotAndComma(TextUtils.getMatch(page, GCConstants.PATTERN_CACHES_FOUND, true, "0")));
            } catch (final NumberFormatException e) {
                Log.e("getLoginStatus: bad cache count", e);
            }
            setActualCachesFound(cachesCount);
            Settings.setGCMemberStatus(TextUtils.getMatch(page, GCConstants.PATTERN_MEMBER_STATUS, true, null));
            if (page.contains(GCConstants.MEMBER_STATUS_RENEW)) {
                Settings.setGCMemberStatus(GCConstants.MEMBER_STATUS_PM);
            }
            return true;
        }

        // login page
        setActualLoginStatus(TextUtils.matches(page, GCConstants.PATTERN_LOGIN_NAME_LOGIN_PAGE));
        if (isActualLoginStatus()) {
            setActualUserName(Settings.getUsername());
            // number of caches found is not part of this page
            return true;
        }

        setActualStatus(CgeoApplication.getInstance().getString(R.string.init_login_popup_failed));
        return false;
    }

    /**
     * Ensure that the web site is in English.
     *
     * @param previousPage the content of the last loaded page
     * @return <code>true</code> if a switch was necessary and succesfully performed (non-English -> English)
     */
    private boolean switchToEnglish(String previousPage) {
        if (previousPage != null && previousPage.contains(ENGLISH)) {
            Log.i("Geocaching.com language already set to English");
            // get find count
            getLoginStatus(Network.getResponseData(Network.getRequest("http://www.geocaching.com/email/")));
        } else {
            final String page = Network.getResponseData(Network.getRequest(LANGUAGE_CHANGE_URI));
            getLoginStatus(page);
            if (page == null) {
                Log.e("Failed to read viewstates to set geocaching.com language");
            }
            final Parameters params = new Parameters(
                    "__EVENTTARGET", "ctl00$uxLocaleList$uxLocaleList$ctl00$uxLocaleItem", // switch to english
                    "__EVENTARGUMENT", "");
            GCLogin.transferViewstates(page, params);
            final HttpResponse response = Network.postRequest(LANGUAGE_CHANGE_URI, params, new Parameters("Referer", LANGUAGE_CHANGE_URI));
            if (Network.isSuccess(response)) {
                Log.i("changed language on geocaching.com to English");
                return true;
            }
            Log.e("Failed to set geocaching.com language to English");
        }
        return false;
    }

    public Observable<Drawable> downloadAvatarAndGetMemberStatus() {
        try {
            final String responseData = StringUtils.defaultString(Network.getResponseData(Network.getRequest("http://www.geocaching.com/my/")));
            final String profile = TextUtils.replaceWhitespace(responseData);

            Settings.setGCMemberStatus(TextUtils.getMatch(profile, GCConstants.PATTERN_MEMBER_STATUS, true, null));
            if (profile.contains(GCConstants.MEMBER_STATUS_RENEW)) {
                Settings.setGCMemberStatus(GCConstants.MEMBER_STATUS_PM);
            }

            setActualCachesFound(Integer.parseInt(removeDotAndComma(TextUtils.getMatch(profile, GCConstants.PATTERN_CACHES_FOUND, true, "-1"))));

            final String avatarURL = TextUtils.getMatch(profile, GCConstants.PATTERN_AVATAR_IMAGE_PROFILE_PAGE, false, null);
            if (avatarURL != null) {
                final HtmlImage imgGetter = new HtmlImage("", false, 0, false);
                return imgGetter.fetchDrawable(avatarURL.replace("avatar", "user/large")).cast(Drawable.class);
            }
            // No match? There may be no avatar set by user.
            Log.d("No avatar set for user");
        } catch (final Exception e) {
            Log.w("Error when retrieving user avatar", e);
        }
        return null;
    }

    /**
     * Detect user date settings on geocaching.com
     */
    public static void detectGcCustomDate() {

        final String result = Network.getResponseData(Network.getRequest("http://www.geocaching.com/account/ManagePreferences.aspx"));

        if (null == result) {
            Log.w("Login.detectGcCustomDate: result is null");
            return;
        }

        final String customDate = TextUtils.getMatch(result, GCConstants.PATTERN_CUSTOMDATE, true, null);
        if (null != customDate) {
            Settings.setGcCustomDate(customDate);
        }
    }

    public static Date parseGcCustomDate(final String input, final String format) throws ParseException {
        if (StringUtils.isBlank(input)) {
            throw new ParseException("Input is null", 0);
        }

        final String trimmed = input.trim();

        if (GC_CUSTOM_DATE_FORMATS.containsKey(format)) {
            try {
                return GC_CUSTOM_DATE_FORMATS.get(format).parse(trimmed);
            } catch (final ParseException ignored) {
            }
        }

        for (final SimpleDateFormat sdf : GC_CUSTOM_DATE_FORMATS.values()) {
            try {
                return sdf.parse(trimmed);
            } catch (final ParseException ignored) {
            }
        }

        throw new ParseException("No matching pattern", 0);
    }

    public static Date parseGcCustomDate(final String input) throws ParseException {
        return parseGcCustomDate(input, Settings.getGcCustomDate());
    }

    public static SimpleDateFormat getCustomGcDateFormat() {
        final String format = Settings.getGcCustomDate();
        if (GC_CUSTOM_DATE_FORMATS.containsKey(format)) {
            return GC_CUSTOM_DATE_FORMATS.get(format);
        }

        return GC_CUSTOM_DATE_FORMATS.get(DEFAULT_CUSTOM_DATE_FORMAT);
    }

    /**
     * checks if an Array of Strings is empty or not. Empty means:
     * - Array is null
     * - or all elements are null or empty strings
     */
    public static boolean isEmpty(String[] a) {
        if (a == null) {
            return true;
        }

        for (final String s : a) {
            if (StringUtils.isNotEmpty(s)) {
                return false;
            }
        }
        return true;
    }

    /**
     * read all viewstates from page
     *
     * @return String[] with all view states
     */
    public static String[] getViewstates(String page) {
        // Get the number of viewstates.
        // If there is only one viewstate, __VIEWSTATEFIELDCOUNT is not present

        if (page == null) { // no network access
            return null;
        }

        int count = 1;
        final MatcherWrapper matcherViewstateCount = new MatcherWrapper(GCConstants.PATTERN_VIEWSTATEFIELDCOUNT, page);
        if (matcherViewstateCount.find()) {
            try {
                count = Integer.parseInt(matcherViewstateCount.group(1));
            } catch (final NumberFormatException e) {
                Log.e("getViewStates", e);
            }
        }

        final String[] viewstates = new String[count];

        // Get the viewstates
        final MatcherWrapper matcherViewstates = new MatcherWrapper(GCConstants.PATTERN_VIEWSTATES, page);
        while (matcherViewstates.find()) {
            final String sno = matcherViewstates.group(1); // number of viewstate
            int no;
            if (StringUtils.isEmpty(sno)) {
                no = 0;
            } else {
                try {
                    no = Integer.parseInt(sno);
                } catch (final NumberFormatException e) {
                    Log.e("getViewStates", e);
                    no = 0;
                }
            }
            viewstates[no] = matcherViewstates.group(2);
        }

        if (viewstates.length != 1 || viewstates[0] != null) {
            return viewstates;
        }
        // no viewstates were present
        return null;
    }

    /**
     * put viewstates into request parameters
     */
    public static void putViewstates(final Parameters params, final String[] viewstates) {
        if (ArrayUtils.isEmpty(viewstates)) {
            return;
        }
        params.put("__VIEWSTATE", viewstates[0]);
        if (viewstates.length > 1) {
            for (int i = 1; i < viewstates.length; i++) {
                params.put("__VIEWSTATE" + i, viewstates[i]);
            }
            params.put("__VIEWSTATEFIELDCOUNT", String.valueOf(viewstates.length));
        }
    }

    /**
     * transfers the viewstates variables from a page (response) to parameters
     * (next request)
     */
    public static void transferViewstates(final String page, final Parameters params) {
        putViewstates(params, getViewstates(page));
    }

    /**
     * POST HTTP request. Do the request a second time if the user is not logged in
     *
     * @param uri
     * @return
     */
    public String postRequestLogged(final String uri, final Parameters params) {
        final String data = Network.getResponseData(Network.postRequest(uri, params));

        if (getLoginStatus(data)) {
            return data;
        }

        if (login() == StatusCode.NO_ERROR) {
            return Network.getResponseData(Network.postRequest(uri, params));
        }

        Log.i("Working as guest.");
        return data;
    }

    /**
     * GET HTTP request. Do the request a second time if the user is not logged in
     *
     * @param uri
     * @param params
     * @return
     */
    @Nullable
    public String getRequestLogged(@NonNull final String uri, @Nullable final Parameters params) {
        final HttpResponse response = Network.getRequest(uri, params);
        final String data = Network.getResponseData(response, canRemoveWhitespace(uri));

        // A page not found will not be found if the user logs in either
        if (Network.isPageNotFound(response) || getLoginStatus(data)) {
            return data;
        }

        if (login() == StatusCode.NO_ERROR) {
            return Network.getResponseData(Network.getRequest(uri, params), canRemoveWhitespace(uri));
        }

        Log.w("Working as guest.");
        return data;
    }

    /**
     * Unfortunately the cache details page contains user generated whitespace in the personal note, therefore we cannot
     * remove the white space from cache details pages.
     *
     * @param uri
     * @return
     */
    private static boolean canRemoveWhitespace(final String uri) {
        return !StringUtils.contains(uri, "cache_details");
    }

    /**
     * Get user session & session token from the Live Map. Needed for following requests.
     *
     * @return first is user session, second is session token
     */
    public @NonNull
    MapTokens getMapTokens() {
        final String data = getRequestLogged(GCConstants.URL_LIVE_MAP, null);
        final String userSession = TextUtils.getMatch(data, GCConstants.PATTERN_USERSESSION, "");
        final String sessionToken = TextUtils.getMatch(data, GCConstants.PATTERN_SESSIONTOKEN, "");
        return new MapTokens(userSession, sessionToken);
    }

}
!@#$%
20190527_005119,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_a21232
package cgeo.geocaching.connector.gc;

import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.R;
import cgeo.geocaching.connector.AbstractLogin;
import cgeo.geocaching.enumerations.StatusCode;
import cgeo.geocaching.network.Cookies;
import cgeo.geocaching.network.HtmlImage;
import cgeo.geocaching.network.Network;
import cgeo.geocaching.network.Parameters;
import cgeo.geocaching.settings.Settings;
import cgeo.geocaching.utils.Log;
import cgeo.geocaching.utils.MatcherWrapper;
import cgeo.geocaching.utils.TextUtils;

import ch.boye.httpclientandroidlib.HttpResponse;

import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;

import rx.Observable;

import android.graphics.drawable.Drawable;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

public class GCLogin extends AbstractLogin {

    private static final String DEFAULT_CUSTOM_DATE_FORMAT = "MM/dd/yyyy";

    private final static String ENGLISH = "<a href=\"#\">English &#9660;</a>";

    private final static Map<String, SimpleDateFormat> GC_CUSTOM_DATE_FORMATS;
    public static final String LANGUAGE_CHANGE_URI = "http://www.geocaching.com/my/souvenirs.aspx";

    static {
        final String[] formats = new String[] {
                DEFAULT_CUSTOM_DATE_FORMAT,
                "yyyy-MM-dd",
                "yyyy/MM/dd",
                "dd.MM.yyyy",
                "dd/MMM/yyyy",
                "dd.MMM.yyyy",
                "MMM/dd/yyyy",
                "dd MMM yy",
                "dd/MM/yyyy"
        };

        final Map<String, SimpleDateFormat> map = new HashMap<>();

        for (final String format : formats) {
            map.put(format, new SimpleDateFormat(format, Locale.ENGLISH));
        }

        GC_CUSTOM_DATE_FORMATS = Collections.unmodifiableMap(map);
    }

    private GCLogin() {
        // singleton
    }

    public static GCLogin getInstance() {
        return SingletonHolder.INSTANCE;
    }

    private static class SingletonHolder {
        private static final GCLogin INSTANCE = new GCLogin();
    }

    @Override
    protected StatusCode login(boolean retry) {
        final ImmutablePair<String, String> credentials = Settings.getGcCredentials();
        final String username = credentials.left;
        final String password = credentials.right;

        if (StringUtils.isEmpty(username) || StringUtils.isEmpty(password)) {
            clearLoginInfo();
            Log.e("Login.login: No login information stored");
            return StatusCode.NO_LOGIN_INFO_STORED;
        }

        setActualStatus(CgeoApplication.getInstance().getString(R.string.init_login_popup_working));
        HttpResponse loginResponse = Network.getRequest("https://www.geocaching.com/login/default.aspx");
        String loginData = Network.getResponseData(loginResponse);
        if (loginResponse != null && loginResponse.getStatusLine().getStatusCode() == 503 && TextUtils.matches(loginData, GCConstants.PATTERN_MAINTENANCE)) {
            return StatusCode.MAINTENANCE;
        }

        if (StringUtils.isBlank(loginData)) {
            Log.e("Login.login: Failed to retrieve login page (1st)");
            return StatusCode.CONNECTION_FAILED; // no login page
        }

        if (getLoginStatus(loginData)) {
            Log.i("Already logged in Geocaching.com as " + username + " (" + Settings.getGCMemberStatus() + ')');
            if (switchToEnglish(loginData) && retry) {
                return login(false);
            }
            return StatusCode.NO_ERROR; // logged in
        }

        Cookies.clearCookies();
        Settings.setCookieStore(null);

        final Parameters params = new Parameters(
                "__EVENTTARGET", "",
                "__EVENTARGUMENT", "",
                "ctl00$ContentBody$tbUsername", username,
                "ctl00$ContentBody$tbPassword", password,
                "ctl00$ContentBody$cbRememberMe", "on",
                "ctl00$ContentBody$btnSignIn", "Login");
        final String[] viewstates = GCLogin.getViewstates(loginData);
        if (isEmpty(viewstates)) {
            Log.e("Login.login: Failed to find viewstates");
            return StatusCode.LOGIN_PARSE_ERROR; // no viewstates
        }
        GCLogin.putViewstates(params, viewstates);

        loginResponse = Network.postRequest("https://www.geocaching.com/login/default.aspx", params);
        loginData = Network.getResponseData(loginResponse);

        if (StringUtils.isBlank(loginData)) {
            Log.e("Login.login: Failed to retrieve login page (2nd)");
            // FIXME: should it be CONNECTION_FAILED to match the first attempt?
            return StatusCode.COMMUNICATION_ERROR; // no login page
        }
        assert loginData != null;  // Caught above

        if (getLoginStatus(loginData)) {
            if (switchToEnglish(loginData) && retry) {
                return login(false);
            }
            Log.i("Successfully logged in Geocaching.com as " + username + " (" + Settings.getGCMemberStatus() + ')');
            Settings.setCookieStore(Cookies.dumpCookieStore());
            return StatusCode.NO_ERROR; // logged in
        }

        if (loginData.contains("Your username/password combination does not match.")) {
            Log.i("Failed to log in Geocaching.com as " + username + " because of wrong username/password");
            return StatusCode.WRONG_LOGIN_DATA; // wrong login
        }

        if (loginData.contains("You must validate your account before you can log in.")) {
            Log.i("Failed to log in Geocaching.com as " + username + " because account needs to be validated first");
            return StatusCode.UNVALIDATED_ACCOUNT;
        }

        Log.i("Failed to log in Geocaching.com as " + username + " for some unknown reason");
        if (retry) {
            switchToEnglish(loginData);
            return login(false);
        }

        return StatusCode.UNKNOWN_ERROR; // can't login
    }

    public StatusCode logout() {
        final HttpResponse logoutResponse = Network.getRequest("https://www.geocaching.com/login/default.aspx?RESET=Y&redir=http%3a%2f%2fwww.geocaching.com%2fdefault.aspx%3f");
        final String logoutData = Network.getResponseData(logoutResponse);
        if (logoutResponse != null && logoutResponse.getStatusLine().getStatusCode() == 503 && TextUtils.matches(logoutData, GCConstants.PATTERN_MAINTENANCE)) {
            return StatusCode.MAINTENANCE;
        }

        resetLoginStatus();

        return StatusCode.NO_ERROR;
    }


    /**
     * Check if the user has been logged in when he retrieved the data.
     *
     * @param page
     * @return <code>true</code> if user is logged in, <code>false</code> otherwise
     */
    public boolean getLoginStatus(@Nullable final String page) {
        if (StringUtils.isBlank(page)) {
            Log.e("Login.checkLogin: No page given");
            return false;
        }
        assert page != null;

        if (TextUtils.matches(page, GCConstants.PATTERN_MAP_LOGGED_IN)) {
            return true;
        }

        setActualStatus(CgeoApplication.getInstance().getString(R.string.init_login_popup_ok));

        // on every page except login page
        setActualLoginStatus(TextUtils.matches(page, GCConstants.PATTERN_LOGIN_NAME));
        if (isActualLoginStatus()) {
            setActualUserName(TextUtils.getMatch(page, GCConstants.PATTERN_LOGIN_NAME, true, "???"));
            int cachesCount = 0;
            try {
                cachesCount = Integer.parseInt(TextUtils.getMatch(page, GCConstants.PATTERN_CACHES_FOUND, true, "0").replaceAll("[,.]", ""));
            } catch (final NumberFormatException e) {
                Log.e("getLoginStatus: bad cache count", e);
            }
            setActualCachesFound(cachesCount);
            Settings.setGCMemberStatus(TextUtils.getMatch(page, GCConstants.PATTERN_MEMBER_STATUS, true, null));
            if (page.contains(GCConstants.MEMBER_STATUS_RENEW)) {
                Settings.setGCMemberStatus(GCConstants.MEMBER_STATUS_PM);
            }
            return true;
        }

        // login page
        setActualLoginStatus(TextUtils.matches(page, GCConstants.PATTERN_LOGIN_NAME_LOGIN_PAGE));
        if (isActualLoginStatus()) {
            setActualUserName(Settings.getUsername());
            // number of caches found is not part of this page
            return true;
        }

        setActualStatus(CgeoApplication.getInstance().getString(R.string.init_login_popup_failed));
        return false;
    }

    /**
     * Ensure that the web site is in English.
     *
     * @param previousPage the content of the last loaded page
     * @return <code>true</code> if a switch was necessary and succesfully performed (non-English -> English)
     */
    private boolean switchToEnglish(String previousPage) {
        if (previousPage != null && previousPage.contains(ENGLISH)) {
            Log.i("Geocaching.com language already set to English");
            // get find count
            getLoginStatus(Network.getResponseData(Network.getRequest("http://www.geocaching.com/email/")));
        } else {
            final String page = Network.getResponseData(Network.getRequest(LANGUAGE_CHANGE_URI));
            getLoginStatus(page);
            if (page == null) {
                Log.e("Failed to read viewstates to set geocaching.com language");
            }
            final Parameters params = new Parameters(
                    "__EVENTTARGET", "ctl00$uxLocaleList$uxLocaleList$ctl00$uxLocaleItem", // switch to english
                    "__EVENTARGUMENT", "");
            GCLogin.transferViewstates(page, params);
            final HttpResponse response = Network.postRequest(LANGUAGE_CHANGE_URI, params, new Parameters("Referer", LANGUAGE_CHANGE_URI));
            if (Network.isSuccess(response)) {
                Log.i("changed language on geocaching.com to English");
                return true;
            }
            Log.e("Failed to set geocaching.com language to English");
        }
        return false;
    }

    public Observable<Drawable> downloadAvatarAndGetMemberStatus() {
        try {
            final String responseData = StringUtils.defaultString(Network.getResponseData(Network.getRequest("http://www.geocaching.com/my/")));
            final String profile = TextUtils.replaceWhitespace(responseData);

            Settings.setGCMemberStatus(TextUtils.getMatch(profile, GCConstants.PATTERN_MEMBER_STATUS, true, null));
            if (profile.contains(GCConstants.MEMBER_STATUS_RENEW)) {
                Settings.setGCMemberStatus(GCConstants.MEMBER_STATUS_PM);
            }

            setActualCachesFound(Integer.parseInt(TextUtils.getMatch(profile, GCConstants.PATTERN_CACHES_FOUND, true, "-1").replaceAll("[,.]", "")));

            final String avatarURL = TextUtils.getMatch(profile, GCConstants.PATTERN_AVATAR_IMAGE_PROFILE_PAGE, false, null);
            if (avatarURL != null) {
                final HtmlImage imgGetter = new HtmlImage("", false, 0, false);
                return imgGetter.fetchDrawable(avatarURL.replace("avatar", "user/large")).cast(Drawable.class);
            }
            // No match? There may be no avatar set by user.
            Log.d("No avatar set for user");
        } catch (final Exception e) {
            Log.w("Error when retrieving user avatar", e);
        }
        return null;
    }

    /**
     * Detect user date settings on geocaching.com
     */
    public static void detectGcCustomDate() {

        final String result = Network.getResponseData(Network.getRequest("http://www.geocaching.com/account/ManagePreferences.aspx"));

        if (null == result) {
            Log.w("Login.detectGcCustomDate: result is null");
            return;
        }

        final String customDate = TextUtils.getMatch(result, GCConstants.PATTERN_CUSTOMDATE, true, null);
        if (null != customDate) {
            Settings.setGcCustomDate(customDate);
        }
    }

    public static Date parseGcCustomDate(final String input, final String format) throws ParseException {
        if (StringUtils.isBlank(input)) {
            throw new ParseException("Input is null", 0);
        }

        final String trimmed = input.trim();

        if (GC_CUSTOM_DATE_FORMATS.containsKey(format)) {
            try {
                return GC_CUSTOM_DATE_FORMATS.get(format).parse(trimmed);
            } catch (final ParseException e) {
            }
        }

        for (final SimpleDateFormat sdf : GC_CUSTOM_DATE_FORMATS.values()) {
            try {
                return sdf.parse(trimmed);
            } catch (final ParseException e) {
            }
        }

        throw new ParseException("No matching pattern", 0);
    }

    public static Date parseGcCustomDate(final String input) throws ParseException {
        return parseGcCustomDate(input, Settings.getGcCustomDate());
    }

    public static SimpleDateFormat getCustomGcDateFormat() {
        final String format = Settings.getGcCustomDate();
        if (GC_CUSTOM_DATE_FORMATS.containsKey(format)) {
            return GC_CUSTOM_DATE_FORMATS.get(format);
        }

        return GC_CUSTOM_DATE_FORMATS.get(DEFAULT_CUSTOM_DATE_FORMAT);
    }

    /**
     * checks if an Array of Strings is empty or not. Empty means:
     * - Array is null
     * - or all elements are null or empty strings
     */
    public static boolean isEmpty(String[] a) {
        if (a == null) {
            return true;
        }

        for (final String s : a) {
            if (StringUtils.isNotEmpty(s)) {
                return false;
            }
        }
        return true;
    }

    /**
     * read all viewstates from page
     *
     * @return String[] with all view states
     */
    public static String[] getViewstates(String page) {
        // Get the number of viewstates.
        // If there is only one viewstate, __VIEWSTATEFIELDCOUNT is not present

        if (page == null) { // no network access
            return null;
        }

        int count = 1;
        final MatcherWrapper matcherViewstateCount = new MatcherWrapper(GCConstants.PATTERN_VIEWSTATEFIELDCOUNT, page);
        if (matcherViewstateCount.find()) {
            try {
                count = Integer.parseInt(matcherViewstateCount.group(1));
            } catch (final NumberFormatException e) {
                Log.e("getViewStates", e);
            }
        }

        final String[] viewstates = new String[count];

        // Get the viewstates
        final MatcherWrapper matcherViewstates = new MatcherWrapper(GCConstants.PATTERN_VIEWSTATES, page);
        while (matcherViewstates.find()) {
            final String sno = matcherViewstates.group(1); // number of viewstate
            int no;
            if (StringUtils.isEmpty(sno)) {
                no = 0;
            } else {
                try {
                    no = Integer.parseInt(sno);
                } catch (final NumberFormatException e) {
                    Log.e("getViewStates", e);
                    no = 0;
                }
            }
            viewstates[no] = matcherViewstates.group(2);
        }

        if (viewstates.length != 1 || viewstates[0] != null) {
            return viewstates;
        }
        // no viewstates were present
        return null;
    }

    /**
     * put viewstates into request parameters
     */
    public static void putViewstates(final Parameters params, final String[] viewstates) {
        if (ArrayUtils.isEmpty(viewstates)) {
            return;
        }
        params.put("__VIEWSTATE", viewstates[0]);
        if (viewstates.length > 1) {
            for (int i = 1; i < viewstates.length; i++) {
                params.put("__VIEWSTATE" + i, viewstates[i]);
            }
            params.put("__VIEWSTATEFIELDCOUNT", String.valueOf(viewstates.length));
        }
    }

    /**
     * transfers the viewstates variables from a page (response) to parameters
     * (next request)
     */
    public static void transferViewstates(final String page, final Parameters params) {
        putViewstates(params, getViewstates(page));
    }

    /**
     * POST HTTP request. Do the request a second time if the user is not logged in
     *
     * @param uri
     * @return
     */
    public String postRequestLogged(final String uri, final Parameters params) {
        final String data = Network.getResponseData(Network.postRequest(uri, params));

        if (getLoginStatus(data)) {
            return data;
        }

        if (login() == StatusCode.NO_ERROR) {
            return Network.getResponseData(Network.postRequest(uri, params));
        }

        Log.i("Working as guest.");
        return data;
    }

    /**
     * GET HTTP request. Do the request a second time if the user is not logged in
     *
     * @param uri
     * @param params
     * @return
     */
    @Nullable
    public String getRequestLogged(@NonNull final String uri, @Nullable final Parameters params) {
        final HttpResponse response = Network.getRequest(uri, params);
        final String data = Network.getResponseData(response, canRemoveWhitespace(uri));

        // A page not found will not be found if the user logs in either
        if (Network.isPageNotFound(response) || getLoginStatus(data)) {
            return data;
        }

        if (login() == StatusCode.NO_ERROR) {
            return Network.getResponseData(Network.getRequest(uri, params), canRemoveWhitespace(uri));
        }

        Log.w("Working as guest.");
        return data;
    }

    /**
     * Unfortunately the cache details page contains user generated whitespace in the personal note, therefore we cannot
     * remove the white space from cache details pages.
     *
     * @param uri
     * @return
     */
    private static boolean canRemoveWhitespace(final String uri) {
        return !StringUtils.contains(uri, "cache_details");
    }

    /**
     * Get user session & session token from the Live Map. Needed for following requests.
     *
     * @return first is user session, second is session token
     */
    public @NonNull
    MapTokens getMapTokens() {
        final String data = getRequestLogged(GCConstants.URL_LIVE_MAP, null);
        final String userSession = TextUtils.getMatch(data, GCConstants.PATTERN_USERSESSION, "");
        final String sessionToken = TextUtils.getMatch(data, GCConstants.PATTERN_SESSIONTOKEN, "");
        return new MapTokens(userSession, sessionToken);
    }

}
!@#$%
20190527_005119,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_c21232
package cgeo.geocaching.connector.gc;

import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.R;
import cgeo.geocaching.connector.AbstractLogin;
import cgeo.geocaching.enumerations.StatusCode;
import cgeo.geocaching.network.Cookies;
import cgeo.geocaching.network.HtmlImage;
import cgeo.geocaching.network.Network;
import cgeo.geocaching.network.Parameters;
import cgeo.geocaching.settings.Settings;
import cgeo.geocaching.utils.Log;
import cgeo.geocaching.utils.MatcherWrapper;
import cgeo.geocaching.utils.TextUtils;

import ch.boye.httpclientandroidlib.HttpResponse;

import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;

import rx.Observable;

import android.graphics.drawable.Drawable;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.GregorianCalendar;

public class GCLogin extends AbstractLogin {

    private final static String ENGLISH = "<a href=\"#\">English &#9660;</a>";

    public static final String LANGUAGE_CHANGE_URI = "http://www.geocaching.com/my/souvenirs.aspx";

    private GCLogin() {
        // singleton
    }

    public static GCLogin getInstance() {
        return SingletonHolder.INSTANCE;
    }

    private static class SingletonHolder {
        private static final GCLogin INSTANCE = new GCLogin();
    }

    private static StatusCode resetGcCustomDate(final StatusCode statusCode) {
        Settings.setGcCustomDate("MM/dd/yyyy");
        return statusCode;
    }

    @Override
    protected StatusCode login(boolean retry) {
        final ImmutablePair<String, String> credentials = Settings.getGcCredentials();
        final String username = credentials.left;
        final String password = credentials.right;

        if (StringUtils.isEmpty(username) || StringUtils.isEmpty(password)) {
            clearLoginInfo();
            Log.e("Login.login: No login information stored");
            return resetGcCustomDate(StatusCode.NO_LOGIN_INFO_STORED);
        }

        setActualStatus(CgeoApplication.getInstance().getString(R.string.init_login_popup_working));
        HttpResponse loginResponse = Network.getRequest("https://www.geocaching.com/login/default.aspx");
        String loginData = Network.getResponseData(loginResponse);
        if (loginResponse != null && loginResponse.getStatusLine().getStatusCode() == 503 && TextUtils.matches(loginData, GCConstants.PATTERN_MAINTENANCE)) {
            return StatusCode.MAINTENANCE;
        }

        if (StringUtils.isBlank(loginData)) {
            Log.e("Login.login: Failed to retrieve login page (1st)");
            return StatusCode.CONNECTION_FAILED; // no login page
        }

        if (getLoginStatus(loginData)) {
            Log.i("Already logged in Geocaching.com as " + username + " (" + Settings.getGCMemberStatus() + ')');
            if (switchToEnglish(loginData) && retry) {
                return login(false);
            }
            detectGcCustomDate();
            return StatusCode.NO_ERROR; // logged in
        }

        Cookies.clearCookies();
        Settings.setCookieStore(null);

        final Parameters params = new Parameters(
                "__EVENTTARGET", "",
                "__EVENTARGUMENT", "",
                "ctl00$ContentBody$tbUsername", username,
                "ctl00$ContentBody$tbPassword", password,
                "ctl00$ContentBody$cbRememberMe", "on",
                "ctl00$ContentBody$btnSignIn", "Login");
        final String[] viewstates = GCLogin.getViewstates(loginData);
        if (isEmpty(viewstates)) {
            Log.e("Login.login: Failed to find viewstates");
            return StatusCode.LOGIN_PARSE_ERROR; // no viewstates
        }
        GCLogin.putViewstates(params, viewstates);

        loginResponse = Network.postRequest("https://www.geocaching.com/login/default.aspx", params);
        loginData = Network.getResponseData(loginResponse);

        if (StringUtils.isBlank(loginData)) {
            Log.e("Login.login: Failed to retrieve login page (2nd)");
            // FIXME: should it be CONNECTION_FAILED to match the first attempt?
            return StatusCode.COMMUNICATION_ERROR; // no login page
        }
        assert loginData != null;  // Caught above

        if (getLoginStatus(loginData)) {
            if (switchToEnglish(loginData) && retry) {
                return login(false);
            }
            Log.i("Successfully logged in Geocaching.com as " + username + " (" + Settings.getGCMemberStatus() + ')');
            Settings.setCookieStore(Cookies.dumpCookieStore());
            detectGcCustomDate();
            return StatusCode.NO_ERROR; // logged in
        }

        if (loginData.contains("Your username/password combination does not match.")) {
            Log.i("Failed to log in Geocaching.com as " + username + " because of wrong username/password");
            return resetGcCustomDate(StatusCode.WRONG_LOGIN_DATA); // wrong login
        }

        if (loginData.contains("You must validate your account before you can log in.")) {
            Log.i("Failed to log in Geocaching.com as " + username + " because account needs to be validated first");
            return resetGcCustomDate(StatusCode.UNVALIDATED_ACCOUNT);
        }

        Log.i("Failed to log in Geocaching.com as " + username + " for some unknown reason");
        if (retry) {
            switchToEnglish(loginData);
            return login(false);
        }

        return resetGcCustomDate(StatusCode.UNKNOWN_ERROR); // can't login
    }

    public StatusCode logout() {
        final HttpResponse logoutResponse = Network.getRequest("https://www.geocaching.com/login/default.aspx?RESET=Y&redir=http%3a%2f%2fwww.geocaching.com%2fdefault.aspx%3f");
        final String logoutData = Network.getResponseData(logoutResponse);
        if (logoutResponse != null && logoutResponse.getStatusLine().getStatusCode() == 503 && TextUtils.matches(logoutData, GCConstants.PATTERN_MAINTENANCE)) {
            return StatusCode.MAINTENANCE;
        }

        resetLoginStatus();

        return StatusCode.NO_ERROR;
    }


    /**
     * Check if the user has been logged in when he retrieved the data.
     *
     * @param page
     * @return <code>true</code> if user is logged in, <code>false</code> otherwise
     */
    public boolean getLoginStatus(@Nullable final String page) {
        if (StringUtils.isBlank(page)) {
            Log.e("Login.checkLogin: No page given");
            return false;
        }
        assert page != null;

        if (TextUtils.matches(page, GCConstants.PATTERN_MAP_LOGGED_IN)) {
            return true;
        }

        setActualStatus(CgeoApplication.getInstance().getString(R.string.init_login_popup_ok));

        // on every page except login page
        setActualLoginStatus(TextUtils.matches(page, GCConstants.PATTERN_LOGIN_NAME));
        if (isActualLoginStatus()) {
            setActualUserName(TextUtils.getMatch(page, GCConstants.PATTERN_LOGIN_NAME, true, "???"));
            int cachesCount = 0;
            try {
                cachesCount = Integer.parseInt(TextUtils.getMatch(page, GCConstants.PATTERN_CACHES_FOUND, true, "0").replaceAll("[,.]", ""));
            } catch (final NumberFormatException e) {
                Log.e("getLoginStatus: bad cache count", e);
            }
            setActualCachesFound(cachesCount);
            Settings.setGCMemberStatus(TextUtils.getMatch(page, GCConstants.PATTERN_MEMBER_STATUS, true, null));
            if (page.contains(GCConstants.MEMBER_STATUS_RENEW)) {
                Settings.setGCMemberStatus(GCConstants.MEMBER_STATUS_PM);
            }
            return true;
        }

        // login page
        setActualLoginStatus(TextUtils.matches(page, GCConstants.PATTERN_LOGIN_NAME_LOGIN_PAGE));
        if (isActualLoginStatus()) {
            setActualUserName(Settings.getUsername());
            // number of caches found is not part of this page
            return true;
        }

        setActualStatus(CgeoApplication.getInstance().getString(R.string.init_login_popup_failed));
        return false;
    }

    /**
     * Ensure that the web site is in English.
     *
     * @param previousPage the content of the last loaded page
     * @return <code>true</code> if a switch was necessary and succesfully performed (non-English -> English)
     */
    private boolean switchToEnglish(String previousPage) {
        if (previousPage != null && previousPage.contains(ENGLISH)) {
            Log.i("Geocaching.com language already set to English");
            // get find count
            getLoginStatus(Network.getResponseData(Network.getRequest("http://www.geocaching.com/email/")));
        } else {
            final String page = Network.getResponseData(Network.getRequest(LANGUAGE_CHANGE_URI));
            getLoginStatus(page);
            if (page == null) {
                Log.e("Failed to read viewstates to set geocaching.com language");
            }
            final Parameters params = new Parameters(
                    "__EVENTTARGET", "ctl00$uxLocaleList$uxLocaleList$ctl00$uxLocaleItem", // switch to english
                    "__EVENTARGUMENT", "");
            GCLogin.transferViewstates(page, params);
            final HttpResponse response = Network.postRequest(LANGUAGE_CHANGE_URI, params, new Parameters("Referer", LANGUAGE_CHANGE_URI));
            if (Network.isSuccess(response)) {
                Log.i("changed language on geocaching.com to English");
                return true;
            }
            Log.e("Failed to set geocaching.com language to English");
        }
        return false;
    }

    public Observable<Drawable> downloadAvatarAndGetMemberStatus() {
        try {
            final String responseData = StringUtils.defaultString(Network.getResponseData(Network.getRequest("http://www.geocaching.com/my/")));
            final String profile = TextUtils.replaceWhitespace(responseData);

            Settings.setGCMemberStatus(TextUtils.getMatch(profile, GCConstants.PATTERN_MEMBER_STATUS, true, null));
            if (profile.contains(GCConstants.MEMBER_STATUS_RENEW)) {
                Settings.setGCMemberStatus(GCConstants.MEMBER_STATUS_PM);
            }

            setActualCachesFound(Integer.parseInt(TextUtils.getMatch(profile, GCConstants.PATTERN_CACHES_FOUND, true, "-1").replaceAll("[,.]", "")));

            final String avatarURL = TextUtils.getMatch(profile, GCConstants.PATTERN_AVATAR_IMAGE_PROFILE_PAGE, false, null);
            if (avatarURL != null) {
                final HtmlImage imgGetter = new HtmlImage("", false, 0, false);
                return imgGetter.fetchDrawable(avatarURL.replace("avatar", "user/large")).cast(Drawable.class);
            }
            // No match? There may be no avatar set by user.
            Log.d("No avatar set for user");
        } catch (final Exception e) {
            Log.w("Error when retrieving user avatar", e);
        }
        return null;
    }

    /**
     * Detect user date settings on geocaching.com
     */
    private static void detectGcCustomDate() {

        final String result = Network.getResponseData(Network.getRequest("https://www.geocaching.com/myaccount/settings/preferences"));

        if (null == result) {
            Log.w("Login.detectGcCustomDate: result is null");
            return;
        }

        final String customDate = TextUtils.getMatch(result, GCConstants.PATTERN_CUSTOMDATE, true, null);
        if (null != customDate) {
            Settings.setGcCustomDate(customDate);
        }
    }

    public static Date parseGcCustomDate(final String input, final String format) throws ParseException {
        return new SimpleDateFormat(format).parse(input.trim());
    }

    public static Date parseGcCustomDate(final String input) throws ParseException {
        return parseGcCustomDate(input, Settings.getGcCustomDate());
    }

    public static String formatGcCustomDate(int year, int month, int day) {
        return new SimpleDateFormat(Settings.getGcCustomDate()).format(new GregorianCalendar(year, month - 1, day).getTime());
    }

    /**
     * checks if an Array of Strings is empty or not. Empty means:
     * - Array is null
     * - or all elements are null or empty strings
     */
    public static boolean isEmpty(String[] a) {
        if (a == null) {
            return true;
        }

        for (final String s : a) {
            if (StringUtils.isNotEmpty(s)) {
                return false;
            }
        }
        return true;
    }

    /**
     * read all viewstates from page
     *
     * @return String[] with all view states
     */
    public static String[] getViewstates(String page) {
        // Get the number of viewstates.
        // If there is only one viewstate, __VIEWSTATEFIELDCOUNT is not present

        if (page == null) { // no network access
            return null;
        }

        int count = 1;
        final MatcherWrapper matcherViewstateCount = new MatcherWrapper(GCConstants.PATTERN_VIEWSTATEFIELDCOUNT, page);
        if (matcherViewstateCount.find()) {
            try {
                count = Integer.parseInt(matcherViewstateCount.group(1));
            } catch (final NumberFormatException e) {
                Log.e("getViewStates", e);
            }
        }

        final String[] viewstates = new String[count];

        // Get the viewstates
        final MatcherWrapper matcherViewstates = new MatcherWrapper(GCConstants.PATTERN_VIEWSTATES, page);
        while (matcherViewstates.find()) {
            final String sno = matcherViewstates.group(1); // number of viewstate
            int no;
            if (StringUtils.isEmpty(sno)) {
                no = 0;
            } else {
                try {
                    no = Integer.parseInt(sno);
                } catch (final NumberFormatException e) {
                    Log.e("getViewStates", e);
                    no = 0;
                }
            }
            viewstates[no] = matcherViewstates.group(2);
        }

        if (viewstates.length != 1 || viewstates[0] != null) {
            return viewstates;
        }
        // no viewstates were present
        return null;
    }

    /**
     * put viewstates into request parameters
     */
    public static void putViewstates(final Parameters params, final String[] viewstates) {
        if (ArrayUtils.isEmpty(viewstates)) {
            return;
        }
        params.put("__VIEWSTATE", viewstates[0]);
        if (viewstates.length > 1) {
            for (int i = 1; i < viewstates.length; i++) {
                params.put("__VIEWSTATE" + i, viewstates[i]);
            }
            params.put("__VIEWSTATEFIELDCOUNT", String.valueOf(viewstates.length));
        }
    }

    /**
     * transfers the viewstates variables from a page (response) to parameters
     * (next request)
     */
    public static void transferViewstates(final String page, final Parameters params) {
        putViewstates(params, getViewstates(page));
    }

    /**
     * POST HTTP request. Do the request a second time if the user is not logged in
     *
     * @param uri
     * @return
     */
    public String postRequestLogged(final String uri, final Parameters params) {
        final String data = Network.getResponseData(Network.postRequest(uri, params));

        if (getLoginStatus(data)) {
            return data;
        }

        if (login() == StatusCode.NO_ERROR) {
            return Network.getResponseData(Network.postRequest(uri, params));
        }

        Log.i("Working as guest.");
        return data;
    }

    /**
     * GET HTTP request. Do the request a second time if the user is not logged in
     *
     * @param uri
     * @param params
     * @return
     */
    @Nullable
    public String getRequestLogged(@NonNull final String uri, @Nullable final Parameters params) {
        final HttpResponse response = Network.getRequest(uri, params);
        final String data = Network.getResponseData(response, canRemoveWhitespace(uri));

        // A page not found will not be found if the user logs in either
        if (Network.isPageNotFound(response) || getLoginStatus(data)) {
            return data;
        }

        if (login() == StatusCode.NO_ERROR) {
            return Network.getResponseData(Network.getRequest(uri, params), canRemoveWhitespace(uri));
        }

        Log.w("Working as guest.");
        return data;
    }

    /**
     * Unfortunately the cache details page contains user generated whitespace in the personal note, therefore we cannot
     * remove the white space from cache details pages.
     *
     * @param uri
     * @return
     */
    private static boolean canRemoveWhitespace(final String uri) {
        return !StringUtils.contains(uri, "cache_details");
    }

    /**
     * Get user session & session token from the Live Map. Needed for following requests.
     *
     * @return first is user session, second is session token
     */
    public @NonNull
    MapTokens getMapTokens() {
        final String data = getRequestLogged(GCConstants.URL_LIVE_MAP, null);
        final String userSession = TextUtils.getMatch(data, GCConstants.PATTERN_USERSESSION, "");
        final String sessionToken = TextUtils.getMatch(data, GCConstants.PATTERN_SESSIONTOKEN, "");
        return new MapTokens(userSession, sessionToken);
    }

}
!@#$%
20190527_005151,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_b14320
package cgeo.geocaching.settings;

import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.R;
import cgeo.geocaching.apps.cache.navi.NavigationAppFactory.NavigationAppsEnum;
import cgeo.geocaching.connector.capability.ICredentials;
import cgeo.geocaching.connector.gc.GCConnector;
import cgeo.geocaching.connector.gc.GCConstants;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.LiveMapStrategy.Strategy;
import cgeo.geocaching.enumerations.LogType;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.list.StoredList;
import cgeo.geocaching.maps.CGeoMap.MapMode;
import cgeo.geocaching.maps.MapProviderFactory;
import cgeo.geocaching.maps.google.v1.GoogleMapProvider;
import cgeo.geocaching.maps.interfaces.GeoPointImpl;
import cgeo.geocaching.maps.interfaces.MapProvider;
import cgeo.geocaching.maps.interfaces.MapSource;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider.OfflineMapSource;
import cgeo.geocaching.utils.CryptUtils;
import cgeo.geocaching.utils.FileUtils;
import cgeo.geocaching.utils.FileUtils.FileSelector;
import cgeo.geocaching.utils.Log;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.os.Build;
import android.os.Environment;
import android.preference.PreferenceManager;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;

/**
 * General c:geo preferences/settings set by the user
 */
public class Settings {

    /**
     * On opening a map, we limit the _initial_ zoom. The user can still zoom out afterwards.
     */
    private static final int INITIAL_MAP_ZOOM_LIMIT = 16;
    private static final char HISTORY_SEPARATOR = ',';
    public static final int SHOW_WP_THRESHOLD_DEFAULT = 10;
    public static final int SHOW_WP_THRESHOLD_MAX = 50;
    private static final int MAP_SOURCE_DEFAULT = GoogleMapProvider.GOOGLE_MAP_ID.hashCode();

    public static final boolean HW_ACCEL_DISABLED_BY_DEFAULT =
            Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1 ||
            StringUtils.equals(Build.MODEL, "HTC One X") ||    // HTC One X
            StringUtils.equals(Build.MODEL, "HTC One S") ||    // HTC One S
            StringUtils.equals(Build.MODEL, "GT-I8190")  ||    // Samsung S3 mini
            StringUtils.equals(Build.MODEL, "GT-S6310L") ||    // Samsung Galaxy Young
            StringUtils.equals(Build.MODEL, "GT-P5210")  ||    // Samsung Galaxy Tab 3
            StringUtils.equals(Build.MODEL, "GT-S7580")  ||    // Samsung Galaxy Trend Plus
            StringUtils.equals(Build.MODEL, "GT-I9105P") ||    // Samsung Galaxy SII Plus
            StringUtils.equals(Build.MODEL, "ST25i")     ||    // Sony Xperia U
            StringUtils.equals(Build.MODEL, "bq Aquaris 5");   // bq Aquaris 5

    private final static int unitsMetric = 1;

    // twitter api keys
    private final static @NonNull String keyConsumerPublic = CryptUtils.rot13("ESnsCvAv3kEupF1GCR3jGj");
    private final static @NonNull String keyConsumerSecret = CryptUtils.rot13("7vQWceACV9umEjJucmlpFe9FCMZSeqIqfkQ2BnhV9x");

    public enum CoordInputFormatEnum {
        Plain,
        Deg,
        Min,
        Sec;

        static final int DEFAULT_INT_VALUE = Min.ordinal();

        public static CoordInputFormatEnum fromInt(final int id) {
            final CoordInputFormatEnum[] values = CoordInputFormatEnum.values();
            if (id < 0 || id >= values.length) {
                return Min;
            }
            return values[id];
        }
    }

    private static final SharedPreferences sharedPrefs = PreferenceManager
            .getDefaultSharedPreferences(CgeoApplication.getInstance().getBaseContext());
    static {
        migrateSettings();
        final boolean isDebug = sharedPrefs.getBoolean(getKey(R.string.pref_debug), false);
        Log.setDebug(isDebug);
        CgeoApplication.dumpOnOutOfMemory(isDebug);
    }

    /**
     * Cache the mapsource locally. If that is an offline map source, each request would potentially access the
     * underlying map file, leading to delays.
     */
    private static MapSource mapSource;

    protected Settings() {
        throw new InstantiationError();
    }

    private static void migrateSettings() {
        final int LATEST_PREFERENCES_VERSION = 2;
        final int currentVersion = getInt(R.string.pref_settingsversion, 0);

        // No need to migrate if we are up to date.
        if (currentVersion == LATEST_PREFERENCES_VERSION) {
            return;
        }

        // No need to migrate if we don't have older settings, defaults will be used instead.
        final String preferencesNameV0 = "cgeo.pref";
        final SharedPreferences prefsV0 = CgeoApplication.getInstance().getSharedPreferences(preferencesNameV0, Context.MODE_PRIVATE);
        if (currentVersion == 0 && prefsV0.getAll().isEmpty()) {
            final Editor e = sharedPrefs.edit();
            e.putInt(getKey(R.string.pref_settingsversion), LATEST_PREFERENCES_VERSION);
            e.commit();
            return;
        }

        if (currentVersion < 1) {
            // migrate from non standard file location and integer based boolean types
            final Editor e = sharedPrefs.edit();

            e.putString(getKey(R.string.pref_temp_twitter_token_secret), prefsV0.getString(getKey(R.string.pref_temp_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_temp_twitter_token_public), prefsV0.getString(getKey(R.string.pref_temp_twitter_token_public), null));
            e.putBoolean(getKey(R.string.pref_help_shown), prefsV0.getInt(getKey(R.string.pref_help_shown), 0) != 0);
            e.putFloat(getKey(R.string.pref_anylongitude), prefsV0.getFloat(getKey(R.string.pref_anylongitude), 0));
            e.putFloat(getKey(R.string.pref_anylatitude), prefsV0.getFloat(getKey(R.string.pref_anylatitude), 0));
            e.putBoolean(getKey(R.string.pref_offlinemaps), 0 != prefsV0.getInt(getKey(R.string.pref_offlinemaps), 1));
            e.putBoolean(getKey(R.string.pref_offlinewpmaps), 0 != prefsV0.getInt(getKey(R.string.pref_offlinewpmaps), 0));
            e.putString(getKey(R.string.pref_webDeviceCode), prefsV0.getString(getKey(R.string.pref_webDeviceCode), null));
            e.putString(getKey(R.string.pref_webDeviceName), prefsV0.getString(getKey(R.string.pref_webDeviceName), null));
            e.putBoolean(getKey(R.string.pref_maplive), prefsV0.getInt(getKey(R.string.pref_maplive), 1) != 0);
            e.putInt(getKey(R.string.pref_mapsource), prefsV0.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT));
            e.putBoolean(getKey(R.string.pref_twitter), 0 != prefsV0.getInt(getKey(R.string.pref_twitter), 0));
            e.putBoolean(getKey(R.string.pref_showaddress), 0 != prefsV0.getInt(getKey(R.string.pref_showaddress), 1));
            e.putBoolean(getKey(R.string.pref_showcaptcha), prefsV0.getBoolean(getKey(R.string.pref_showcaptcha), false));
            e.putBoolean(getKey(R.string.pref_maptrail), prefsV0.getInt(getKey(R.string.pref_maptrail), 1) != 0);
            e.putInt(getKey(R.string.pref_lastmapzoom), prefsV0.getInt(getKey(R.string.pref_lastmapzoom), 14));
            e.putBoolean(getKey(R.string.pref_livelist), 0 != prefsV0.getInt(getKey(R.string.pref_livelist), 1));
            e.putBoolean(getKey(R.string.pref_units_imperial), prefsV0.getInt(getKey(R.string.pref_units_imperial), unitsMetric) != unitsMetric);
            e.putBoolean(getKey(R.string.pref_skin), prefsV0.getInt(getKey(R.string.pref_skin), 0) != 0);
            e.putInt(getKey(R.string.pref_lastusedlist), prefsV0.getInt(getKey(R.string.pref_lastusedlist), StoredList.STANDARD_LIST_ID));
            e.putString(getKey(R.string.pref_cachetype), prefsV0.getString(getKey(R.string.pref_cachetype), CacheType.ALL.id));
            e.putString(getKey(R.string.pref_twitter_token_secret), prefsV0.getString(getKey(R.string.pref_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_twitter_token_public), prefsV0.getString(getKey(R.string.pref_twitter_token_public), null));
            e.putInt(getKey(R.string.pref_version), prefsV0.getInt(getKey(R.string.pref_version), 0));
            e.putBoolean(getKey(R.string.pref_autoloaddesc), 0 != prefsV0.getInt(getKey(R.string.pref_autoloaddesc), 1));
            e.putBoolean(getKey(R.string.pref_ratingwanted), prefsV0.getBoolean(getKey(R.string.pref_ratingwanted), true));
            e.putBoolean(getKey(R.string.pref_friendlogswanted), prefsV0.getBoolean(getKey(R.string.pref_friendlogswanted), true));
            e.putBoolean(getKey(R.string.pref_useenglish), prefsV0.getBoolean(getKey(R.string.pref_useenglish), false));
            e.putBoolean(getKey(R.string.pref_usecompass), 0 != prefsV0.getInt(getKey(R.string.pref_usecompass), 1));
            e.putBoolean(getKey(R.string.pref_trackautovisit), prefsV0.getBoolean(getKey(R.string.pref_trackautovisit), false));
            e.putBoolean(getKey(R.string.pref_sigautoinsert), prefsV0.getBoolean(getKey(R.string.pref_sigautoinsert), false));
            e.putBoolean(getKey(R.string.pref_logimages), prefsV0.getBoolean(getKey(R.string.pref_logimages), false));
            e.putBoolean(getKey(R.string.pref_excludedisabled), 0 != prefsV0.getInt(getKey(R.string.pref_excludedisabled), 0));
            e.putBoolean(getKey(R.string.pref_excludemine), 0 != prefsV0.getInt(getKey(R.string.pref_excludemine), 0));
            e.putString(getKey(R.string.pref_mapfile), prefsV0.getString(getKey(R.string.pref_mapfile), null));
            e.putString(getKey(R.string.pref_signature), prefsV0.getString(getKey(R.string.pref_signature), null));
            e.putString(getKey(R.string.pref_pass_vote), prefsV0.getString(getKey(R.string.pref_pass_vote), null));
            e.putString(getKey(R.string.pref_password), prefsV0.getString(getKey(R.string.pref_password), null));
            e.putString(getKey(R.string.pref_username), prefsV0.getString(getKey(R.string.pref_username), null));
            e.putString(getKey(R.string.pref_memberstatus), prefsV0.getString(getKey(R.string.pref_memberstatus), ""));
            e.putInt(getKey(R.string.pref_coordinputformat), prefsV0.getInt(getKey(R.string.pref_coordinputformat), CoordInputFormatEnum.DEFAULT_INT_VALUE));
            e.putBoolean(getKey(R.string.pref_log_offline), prefsV0.getBoolean(getKey(R.string.pref_log_offline), false));
            e.putBoolean(getKey(R.string.pref_choose_list), prefsV0.getBoolean(getKey(R.string.pref_choose_list), true));
            e.putBoolean(getKey(R.string.pref_loaddirectionimg), prefsV0.getBoolean(getKey(R.string.pref_loaddirectionimg), true));
            e.putString(getKey(R.string.pref_gccustomdate), prefsV0.getString(getKey(R.string.pref_gccustomdate), null));
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), prefsV0.getInt(getKey(R.string.pref_showwaypointsthreshold), SHOW_WP_THRESHOLD_DEFAULT));
            e.putString(getKey(R.string.pref_cookiestore), prefsV0.getString(getKey(R.string.pref_cookiestore), null));
            e.putBoolean(getKey(R.string.pref_opendetailslastpage), prefsV0.getBoolean(getKey(R.string.pref_opendetailslastpage), false));
            e.putInt(getKey(R.string.pref_lastdetailspage), prefsV0.getInt(getKey(R.string.pref_lastdetailspage), 1));
            e.putInt(getKey(R.string.pref_defaultNavigationTool), prefsV0.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id));
            e.putInt(getKey(R.string.pref_defaultNavigationTool2), prefsV0.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id));
            e.putInt(getKey(R.string.pref_livemapstrategy), prefsV0.getInt(getKey(R.string.pref_livemapstrategy), Strategy.AUTO.id));
            e.putBoolean(getKey(R.string.pref_debug), prefsV0.getBoolean(getKey(R.string.pref_debug), false));
            e.putInt(getKey(R.string.pref_livemaphintshowcount), prefsV0.getInt(getKey(R.string.pref_livemaphintshowcount), 0));

            e.putInt(getKey(R.string.pref_settingsversion), 1); // mark migrated
            e.commit();
        }

        // changes for new settings dialog
        if (currentVersion < 2) {
            final Editor e = sharedPrefs.edit();

            e.putBoolean(getKey(R.string.pref_units_imperial), useImperialUnits());

            // show waypoints threshold now as a slider
            int wpThreshold = getWayPointsThreshold();
            if (wpThreshold < 0) {
                wpThreshold = 0;
            } else if (wpThreshold > SHOW_WP_THRESHOLD_MAX) {
                wpThreshold = SHOW_WP_THRESHOLD_MAX;
            }
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), wpThreshold);

            // KEY_MAP_SOURCE must be string, because it is the key for a ListPreference now
            final int ms = sharedPrefs.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT);
            e.remove(getKey(R.string.pref_mapsource));
            e.putString(getKey(R.string.pref_mapsource), String.valueOf(ms));

            // navigation tool ids must be string, because ListPreference uses strings as keys
            final int dnt1 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id);
            final int dnt2 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id);
            e.remove(getKey(R.string.pref_defaultNavigationTool));
            e.remove(getKey(R.string.pref_defaultNavigationTool2));
            e.putString(getKey(R.string.pref_defaultNavigationTool), String.valueOf(dnt1));
            e.putString(getKey(R.string.pref_defaultNavigationTool2), String.valueOf(dnt2));

            // defaults for gpx directories
            e.putString(getKey(R.string.pref_gpxImportDir), getGpxImportDir());
            e.putString(getKey(R.string.pref_gpxExportDir), getGpxExportDir());

            e.putInt(getKey(R.string.pref_settingsversion), 2); // mark migrated
            e.commit();
        }
    }

    private static String getKey(final int prefKeyId) {
        return CgeoApplication.getInstance().getString(prefKeyId);
    }

    static String getString(final int prefKeyId, final String defaultValue) {
        return sharedPrefs.getString(getKey(prefKeyId), defaultValue);
    }

    private static int getInt(final int prefKeyId, final int defaultValue) {
        return sharedPrefs.getInt(getKey(prefKeyId), defaultValue);
    }

    private static long getLong(final int prefKeyId, final long defaultValue) {
        return sharedPrefs.getLong(getKey(prefKeyId), defaultValue);
    }

    private static boolean getBoolean(final int prefKeyId, final boolean defaultValue) {
        return sharedPrefs.getBoolean(getKey(prefKeyId), defaultValue);
    }

    private static float getFloat(final int prefKeyId, final float defaultValue) {
        return sharedPrefs.getFloat(getKey(prefKeyId), defaultValue);
    }

    protected static boolean putString(final int prefKeyId, final String value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putString(getKey(prefKeyId), value);
        return edit.commit();
    }

    protected static boolean putBoolean(final int prefKeyId, final boolean value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putBoolean(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putInt(final int prefKeyId, final int value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putInt(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putLong(final int prefKeyId, final long value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putLong(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putFloat(final int prefKeyId, final float value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putFloat(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean remove(final int prefKeyId) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.remove(getKey(prefKeyId));
        return edit.commit();
    }

    private static boolean contains(final int prefKeyId) {
        return sharedPrefs.contains(getKey(prefKeyId));
    }

    public static void setLanguage(final boolean useEnglish) {
        final Configuration config = new Configuration();
        config.locale = useEnglish ? Locale.ENGLISH : Locale.getDefault();
        final Resources resources = CgeoApplication.getInstance().getResources();
        resources.updateConfiguration(config, resources.getDisplayMetrics());
    }

    public static boolean isLogin() {
        final String preUsername = getString(R.string.pref_username, null);
        final String prePassword = getString(R.string.pref_password, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    /**
     * Get login and password information of Geocaching.com.
     *
     * @return a pair either with (login, password) or (empty, empty) if no valid information is stored
     */
    public static ImmutablePair<String, String> getGcCredentials() {
        return getCredentials(GCConnector.getInstance());
    }

    /**
     * Get login and password information.
     *
     * @return a pair either with (login, password) or (empty, empty) if no valid information is stored
     */
    public static ImmutablePair<String, String> getCredentials(final @NonNull ICredentials connector) {
        final String username = getString(connector.getUsernamePreferenceKey(), null);
        final String password = getString(connector.getPasswordPreferenceKey(), null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return new ImmutablePair<>(StringUtils.EMPTY, StringUtils.EMPTY);
        }

        return new ImmutablePair<>(username, password);
    }

    public static String getUsername() {
        return getString(R.string.pref_username, null);
    }

    public static boolean isGCConnectorActive() {
        return getBoolean(R.string.pref_connectorGCActive, true);
    }

    public static boolean isECConnectorActive() {
        return getBoolean(R.string.pref_connectorECActive, false);
    }

    public static boolean isOXConnectorActive() {
        return getBoolean(R.string.pref_connectorOXActive, false);
    }

    public static boolean isGCPremiumMember() {
        // Basic Member, Premium Member, ???
        return GCConstants.MEMBER_STATUS_PM.equalsIgnoreCase(Settings.getGCMemberStatus());
    }

    public static String getGCMemberStatus() {
        return getString(R.string.pref_memberstatus, "");
    }

    public static boolean setGCMemberStatus(final String memberStatus) {
        if (StringUtils.isBlank(memberStatus)) {
            return remove(R.string.pref_memberstatus);
        }
        return putString(R.string.pref_memberstatus, memberStatus);
    }

    public static ImmutablePair<String, String> getTokenPair(final int tokenPublicPrefKey, final int tokenSecretPrefKey) {
        return new ImmutablePair<>(getString(tokenPublicPrefKey, null), getString(tokenSecretPrefKey, null));
    }

    public static void setTokens(final int tokenPublicPrefKey, @Nullable final String tokenPublic, final int tokenSecretPrefKey, @Nullable final String tokenSecret) {
        if (tokenPublic == null) {
            remove(tokenPublicPrefKey);
        } else {
            putString(tokenPublicPrefKey, tokenPublic);
        }
        if (tokenSecret == null) {
            remove(tokenSecretPrefKey);
        } else {
            putString(tokenSecretPrefKey, tokenSecret);
        }
    }

    public static boolean isOCConnectorActive(final int isActivePrefKeyId) {
        return getBoolean(isActivePrefKeyId, false);
    }

    public static boolean hasOCAuthorization(final int tokenPublicPrefKeyId, final int tokenSecretPrefKeyId) {
        return StringUtils.isNotBlank(getString(tokenPublicPrefKeyId, ""))
                && StringUtils.isNotBlank(getString(tokenSecretPrefKeyId, ""));
    }

    public static boolean isGCvoteLogin() {
        final String preUsername = getString(R.string.pref_username, null);
        final String prePassword = getString(R.string.pref_pass_vote, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    public static ImmutablePair<String, String> getGCvoteLogin() {
        final String username = getString(R.string.pref_username, null);
        final String password = getString(R.string.pref_pass_vote, null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return null;
        }

        return new ImmutablePair<>(username, password);
    }

    public static String getSignature() {
        return getString(R.string.pref_signature, StringUtils.EMPTY);
    }

    public static boolean setCookieStore(final String cookies) {
        if (StringUtils.isBlank(cookies)) {
            // erase cookies
            return remove(R.string.pref_cookiestore);
        }
        // save cookies
        return putString(R.string.pref_cookiestore, cookies);
    }

    public static String getCookieStore() {
        return getString(R.string.pref_cookiestore, null);
    }

    public static boolean useGooglePlayServices() {
        return CgeoApplication.getInstance().isGooglePlayServicesAvailable() && getBoolean(R.string.pref_googleplayservices, true);
    }

    public static boolean useLowPowerMode() {
        return getBoolean(R.string.pref_lowpowermode, false);
    }

    /**
     * @param cacheType
     *            The cache type used for future filtering
     */
    public static void setCacheType(final CacheType cacheType) {
        if (cacheType == null) {
            remove(R.string.pref_cachetype);
        } else {
            putString(R.string.pref_cachetype, cacheType.id);
        }
    }

    public static int getLastList() {
        return getInt(R.string.pref_lastusedlist, StoredList.STANDARD_LIST_ID);
    }

    public static void saveLastList(final int listId) {
        putInt(R.string.pref_lastusedlist, listId);
    }

    public static void setWebNameCode(final String name, final String code) {
        putString(R.string.pref_webDeviceName, name);
        putString(R.string.pref_webDeviceCode, code);
    }

    public static MapProvider getMapProvider() {
        return getMapSource().getMapProvider();
    }

    public static String getMapFile() {
        return getString(R.string.pref_mapfile, null);
    }

    public static boolean setMapFile(final String mapFile) {
        final boolean result = putString(R.string.pref_mapfile, mapFile);
        if (mapFile != null) {
            setMapFileDirectory(new File(mapFile).getParent());
        }
        return result;
    }

    public static String getMapFileDirectory() {
        final String mapDir = getString(R.string.pref_mapDirectory, null);
        if (mapDir != null) {
            return mapDir;
        }
        final String mapFile = getMapFile();
        if (mapFile != null) {
            return new File(mapFile).getParent();
        }
        return null;
    }

    public static boolean setMapFileDirectory(final String mapFileDirectory) {
        final boolean result = putString(R.string.pref_mapDirectory, mapFileDirectory);
        MapsforgeMapProvider.getInstance().updateOfflineMaps();
        return result;
    }

    public static boolean isValidMapFile() {
        return isValidMapFile(getMapFile());
    }

    public static boolean isValidMapFile(final String mapFileIn) {
        return MapsforgeMapProvider.isValidMapFile(mapFileIn);
    }

    public static boolean isScaleMapsforgeText() {
        return getBoolean(R.string.pref_mapsforge_scale_text, true);
    }

    public static CoordInputFormatEnum getCoordInputFormat() {
        return CoordInputFormatEnum.fromInt(getInt(R.string.pref_coordinputformat, CoordInputFormatEnum.DEFAULT_INT_VALUE));
    }

    public static void setCoordInputFormat(final CoordInputFormatEnum format) {
        putInt(R.string.pref_coordinputformat, format.ordinal());
    }

    public static boolean getLogOffline() {
        return getBoolean(R.string.pref_log_offline, false);
    }

    public static boolean getChooseList() {
        return getBoolean(R.string.pref_choose_list, false);
    }

    public static boolean getLoadDirImg() {
        return !isGCPremiumMember() && getBoolean(R.string.pref_loaddirectionimg, true);
    }

    public static void setGcCustomDate(final String format) {
        putString(R.string.pref_gccustomdate, format);
    }

    /**
     * @return User selected date format on GC.com
     */
    public static String getGcCustomDate() {
        return getString(R.string.pref_gccustomdate, null);
    }

    public static boolean isExcludeMyCaches() {
        return getBoolean(R.string.pref_excludemine, false);
    }

    public static boolean isUseEnglish() {
        return getBoolean(R.string.pref_useenglish, false);
    }

    public static boolean isShowAddress() {
        return getBoolean(R.string.pref_showaddress, true);
    }

    public static boolean isShowCaptcha() {
        return !isGCPremiumMember() && getBoolean(R.string.pref_showcaptcha, false);
    }

    public static boolean isExcludeDisabledCaches() {
        return getBoolean(R.string.pref_excludedisabled, false);
    }

    public static boolean isStoreOfflineMaps() {
        return getBoolean(R.string.pref_offlinemaps, true);
    }

    public static boolean isStoreOfflineWpMaps() {
        return getBoolean(R.string.pref_offlinewpmaps, false);
    }

    public static boolean isStoreLogImages() {
        return getBoolean(R.string.pref_logimages, false);
    }

    public static boolean isAutoLoadDescription() {
        return getBoolean(R.string.pref_autoloaddesc, true);
    }

    public static boolean isRatingWanted() {
        return getBoolean(R.string.pref_ratingwanted, true);
    }

    public static boolean isFriendLogsWanted() {
        if (!isLogin()) {
            // don't show a friends log if the user is anonymous
            return false;
        }
        return getBoolean(R.string.pref_friendlogswanted, true);
    }

    public static boolean isLiveList() {
        return getBoolean(R.string.pref_livelist, true);
    }

    public static boolean isTrackableAutoVisit() {
        return getBoolean(R.string.pref_trackautovisit, false);
    }

    public static boolean isAutoInsertSignature() {
        return getBoolean(R.string.pref_sigautoinsert, false);
    }

    public static void setUseImperialUnits(final boolean useImperialUnits) {
        putBoolean(R.string.pref_units_imperial, useImperialUnits);
    }

    public static boolean useImperialUnits() {
        return getBoolean(R.string.pref_units_imperial, useImperialUnitsByDefault());
    }

    static boolean useImperialUnitsByDefault() {
        final String countryCode = Locale.getDefault().getCountry();
        return "US".equals(countryCode)  // USA
            || "LR".equals(countryCode)  // Liberia
            || "MM".equals(countryCode); // Burma
    }

    public static boolean isLiveMap() {
        return getBoolean(R.string.pref_maplive, true);
    }

    public static void setLiveMap(final boolean live) {
        putBoolean(R.string.pref_maplive, live);
    }

    public static boolean isMapTrail() {
        return getBoolean(R.string.pref_maptrail, true);
    }

    public static void setMapTrail(final boolean showTrail) {
        putBoolean(R.string.pref_maptrail, showTrail);
    }

    /**
     * Get last used zoom of the internal map. Differentiate between two use cases for a map of multiple caches (e.g.
     * live map) and the map of a single cache (which is often zoomed in more deep).
     *
     * @param mapMode
     * @return
     */
    public static int getMapZoom(final MapMode mapMode) {
        if (mapMode == MapMode.SINGLE || mapMode == MapMode.COORDS) {
            return getCacheZoom();
        }
        return getMapZoom();
    }

    public static void setMapZoom(final MapMode mapMode, final int zoomLevel) {
        if (mapMode == MapMode.SINGLE || mapMode == MapMode.COORDS) {
            setCacheZoom(zoomLevel);
        }
        else {
            setMapZoom(zoomLevel);
        }
    }

    /**
     * @return zoom used for the (live) map
     */
    private static int getMapZoom() {
        return Math.max(getInt(R.string.pref_lastmapzoom, 14), INITIAL_MAP_ZOOM_LIMIT);
    }

    private static void setMapZoom(final int mapZoomLevel) {
        putInt(R.string.pref_lastmapzoom, mapZoomLevel);
    }

    /**
     * @return zoom used for the map of a single cache
     */
    private static int getCacheZoom() {
        return Math.max(getInt(R.string.pref_cache_zoom, 14), INITIAL_MAP_ZOOM_LIMIT);
    }

    private static void setCacheZoom(final int zoomLevel) {
        putInt(R.string.pref_cache_zoom, zoomLevel);
    }

    public static GeoPointImpl getMapCenter() {
        return getMapProvider().getMapItemFactory()
                .getGeoPointBase(new Geopoint(getInt(R.string.pref_lastmaplat, 0) / 1e6,
                        getInt(R.string.pref_lastmaplon, 0) / 1e6));
    }

    public static void setMapCenter(final GeoPointImpl mapViewCenter) {
        putInt(R.string.pref_lastmaplat, mapViewCenter.getLatitudeE6());
        putInt(R.string.pref_lastmaplon, mapViewCenter.getLongitudeE6());
    }

    @NonNull
    public static synchronized MapSource getMapSource() {
        if (mapSource != null) {
            return mapSource;
        }
        final int id = getConvertedMapId();
        mapSource = MapProviderFactory.getMapSource(id);
        if (mapSource != null) {
            // don't use offline maps if the map file is not valid
            if (!(mapSource instanceof OfflineMapSource) || isValidMapFile()) {
                return mapSource;
            }
        }
        // fallback to first available map
        return MapProviderFactory.getDefaultSource();
    }

    private final static int GOOGLEMAP_BASEID = 30;
    private final static int MAP = 1;
    private final static int SATELLITE = 2;

    private final static int MFMAP_BASEID = 40;
    private final static int MAPNIK = 1;
    private final static int CYCLEMAP = 3;
    private final static int OFFLINE = 4;
    private static final int HISTORY_SIZE = 10;

    /**
     * convert old preference ids for maps (based on constant values) into new hash based ids
     *
     * @return
     */
    private static int getConvertedMapId() {
        final int id = Integer.parseInt(getString(R.string.pref_mapsource,
                String.valueOf(MAP_SOURCE_DEFAULT)));
        switch (id) {
            case GOOGLEMAP_BASEID + MAP:
                return GoogleMapProvider.GOOGLE_MAP_ID.hashCode();
            case GOOGLEMAP_BASEID + SATELLITE:
                return GoogleMapProvider.GOOGLE_SATELLITE_ID.hashCode();
            case MFMAP_BASEID + MAPNIK:
                return MapsforgeMapProvider.MAPSFORGE_MAPNIK_ID.hashCode();
            case MFMAP_BASEID + CYCLEMAP:
                return MapsforgeMapProvider.MAPSFORGE_CYCLEMAP_ID.hashCode();
            case MFMAP_BASEID + OFFLINE: {
                final String mapFile = Settings.getMapFile();
                if (StringUtils.isNotEmpty(mapFile)) {
                    return mapFile.hashCode();
                }
                break;
            }
            default:
                break;
        }
        return id;
    }

    public static void setMapSource(final MapSource newMapSource) {
        putString(R.string.pref_mapsource, String.valueOf(newMapSource.getNumericalId()));
        if (newMapSource instanceof OfflineMapSource) {
            setMapFile(((OfflineMapSource) newMapSource).getFileName());
        }
        // cache the value
        mapSource = newMapSource;
    }

    public static void setAnyCoordinates(final Geopoint coords) {
        if (null != coords) {
            putFloat(R.string.pref_anylatitude, (float) coords.getLatitude());
            putFloat(R.string.pref_anylongitude, (float) coords.getLongitude());
        } else {
            remove(R.string.pref_anylatitude);
            remove(R.string.pref_anylongitude);
        }
    }

    public static Geopoint getAnyCoordinates() {
        if (contains(R.string.pref_anylatitude) && contains(R.string.pref_anylongitude)) {
            final float lat = getFloat(R.string.pref_anylatitude, 0);
            final float lon = getFloat(R.string.pref_anylongitude, 0);
            return new Geopoint(lat, lon);
        }
        return null;
    }

    public static boolean isUseCompass() {
        return getBoolean(R.string.pref_usecompass, true);
    }

    public static void setUseCompass(final boolean useCompass) {
        putBoolean(R.string.pref_usecompass, useCompass);
    }

    public static boolean isLightSkin() {
        return getBoolean(R.string.pref_skin, false);
    }

    @NonNull
    public static String getKeyConsumerPublic() {
        return keyConsumerPublic;
    }

    @NonNull
    public static String getKeyConsumerSecret() {
        return keyConsumerSecret;
    }

    public static String getWebDeviceCode() {
        return getString(R.string.pref_webDeviceCode, null);
    }

    public static boolean isRegisteredForSend2cgeo() {
        return getWebDeviceCode() != null;
    }

    public static String getWebDeviceName() {
        return getString(R.string.pref_webDeviceName, android.os.Build.MODEL);
    }

    /**
     * @return The cache type used for filtering or ALL if no filter is active.
     *         Returns never null
     */
    public static CacheType getCacheType() {
        return CacheType.getById(getString(R.string.pref_cachetype, CacheType.ALL.id));
    }

    /**
     * The Threshold for the showing of child waypoints
     */
    public static int getWayPointsThreshold() {
        return getInt(R.string.pref_showwaypointsthreshold, SHOW_WP_THRESHOLD_DEFAULT);
    }

    public static void setShowWaypointsThreshold(final int threshold) {
        putInt(R.string.pref_showwaypointsthreshold, threshold);
    }

    public static boolean isUseTwitter() {
        return getBoolean(R.string.pref_twitter, false);
    }

    public static void setUseTwitter(final boolean useTwitter) {
        putBoolean(R.string.pref_twitter, useTwitter);
    }

    public static boolean isTwitterLoginValid() {
        return !StringUtils.isBlank(getTokenPublic())
                && !StringUtils.isBlank(getTokenSecret());
    }

    public static String getTokenPublic() {
        return getString(R.string.pref_twitter_token_public, null);
    }

    public static String getTokenSecret() {
        return getString(R.string.pref_twitter_token_secret, null);

    }

    public static boolean hasTwitterAuthorization() {
        return StringUtils.isNotBlank(getTokenPublic())
                && StringUtils.isNotBlank(getTokenSecret());
    }

    public static void setTwitterTokens(@Nullable final String tokenPublic,
            @Nullable final String tokenSecret, final boolean enableTwitter) {
        putString(R.string.pref_twitter_token_public, tokenPublic);
        putString(R.string.pref_twitter_token_secret, tokenSecret);
        if (tokenPublic != null) {
            remove(R.string.pref_temp_twitter_token_public);
            remove(R.string.pref_temp_twitter_token_secret);
        }
        setUseTwitter(enableTwitter);
    }

    public static void setTwitterTempTokens(@Nullable final String tokenPublic,
            @Nullable final String tokenSecret) {
        putString(R.string.pref_temp_twitter_token_public, tokenPublic);
        putString(R.string.pref_temp_twitter_token_secret, tokenSecret);
    }

    public static ImmutablePair<String, String> getTempToken() {
        final String tokenPublic = getString(R.string.pref_temp_twitter_token_public, null);
        final String tokenSecret = getString(R.string.pref_temp_twitter_token_secret, null);
        return new ImmutablePair<>(tokenPublic, tokenSecret);
    }

    public static int getVersion() {
        return getInt(R.string.pref_version, 0);
    }

    public static void setVersion(final int version) {
        putInt(R.string.pref_version, version);
    }

    public static boolean isOpenLastDetailsPage() {
        return getBoolean(R.string.pref_opendetailslastpage, false);
    }

    public static int getLastDetailsPage() {
        return getInt(R.string.pref_lastdetailspage, 1);
    }

    public static void setLastDetailsPage(final int index) {
        putInt(R.string.pref_lastdetailspage, index);
    }

    public static int getDefaultNavigationTool() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool,
                String.valueOf(NavigationAppsEnum.COMPASS.id)));
    }

    public static int getDefaultNavigationTool2() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool2,
                String.valueOf(NavigationAppsEnum.INTERNAL_MAP.id)));
    }

    public static Strategy getLiveMapStrategy() {
        return Strategy.getById(getInt(R.string.pref_livemapstrategy, Strategy.AUTO.id));
    }

    public static void setLiveMapStrategy(final Strategy strategy) {
        putInt(R.string.pref_livemapstrategy, strategy.id);
    }

    public static boolean isDebug() {
        return Log.isDebug();
    }

    public static int getLiveMapHintShowCount() {
        return getInt(R.string.pref_livemaphintshowcount, 0);
    }

    public static void setLiveMapHintShowCount(final int showCount) {
        putInt(R.string.pref_livemaphintshowcount, showCount);
    }

    public static boolean isDbOnSDCard() {
        return getBoolean(R.string.pref_dbonsdcard, false);
    }

    public static void setDbOnSDCard(final boolean dbOnSDCard) {
        putBoolean(R.string.pref_dbonsdcard, dbOnSDCard);
    }

    public static String getGpxExportDir() {
        return getString(R.string.pref_gpxExportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static String getGpxImportDir() {
        return getString(R.string.pref_gpxImportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static boolean getShareAfterExport() {
        return getBoolean(R.string.pref_shareafterexport, true);
    }

    public static void setShareAfterExport(final boolean shareAfterExport) {
        putBoolean(R.string.pref_shareafterexport, shareAfterExport);
    }

    public static int getTrackableAction() {
        return getInt(R.string.pref_trackableaction, LogType.RETRIEVED_IT.id);
    }

    public static void setTrackableAction(final int trackableAction) {
        putInt(R.string.pref_trackableaction, trackableAction);
    }

    public static String getCustomRenderThemeBaseFolder() {
        return getString(R.string.pref_renderthemepath, "");
    }

    public static String getCustomRenderThemeFilePath() {
        return getString(R.string.pref_renderthemefile, "");
    }

    public static void setCustomRenderThemeFile(final String customRenderThemeFile) {
        putString(R.string.pref_renderthemefile, customRenderThemeFile);
    }

    public static File[] getMapThemeFiles() {
        final File directory = new File(Settings.getCustomRenderThemeBaseFolder());
        final List<File> result = new ArrayList<>();
        FileUtils.listDir(result, directory, new ExtensionsBasedFileSelector(new String[] { "xml" }), null);

        return result.toArray(new File[result.size()]);
    }

    private static class ExtensionsBasedFileSelector extends FileSelector {
        private final String[] extensions;
        public ExtensionsBasedFileSelector(final String[] extensions) {
            this.extensions = extensions;
        }
        @Override
        public boolean isSelected(final File file) {
            final String filename = file.getName();
            for (final String ext : extensions) {
                if (StringUtils.endsWithIgnoreCase(filename, ext)) {
                    return true;
                }
            }
            return false;
        }
        @Override
        public boolean shouldEnd() {
            return false;
        }
    }

    public static boolean getPlainLogs() {
        return getBoolean(R.string.pref_plainLogs, false);
    }

    public static boolean getUseNativeUa() {
        return getBoolean(R.string.pref_nativeUa, false);
    }

    public static String getCacheTwitterMessage() {
        return getString(R.string.pref_twitter_cache_message, "I found [NAME] ([URL]).");
    }

    public static String getTrackableTwitterMessage() {
        return getString(R.string.pref_twitter_trackable_message, "I touched [NAME] ([URL]).");
    }

    public static int getLogImageScale() {
        return getInt(R.string.pref_logImageScale, -1);
    }

    public static void setLogImageScale(final int scale) {
        putInt(R.string.pref_logImageScale, scale);
    }

    public static void setExcludeMine(final boolean exclude) {
        putBoolean(R.string.pref_excludemine, exclude);
    }

    static void setLogin(final String username, final String password) {
        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            // erase username and password
            remove(R.string.pref_username);
            remove(R.string.pref_password);
            return;
        }
        // save username and password
        putString(R.string.pref_username, username);
        putString(R.string.pref_password, password);
    }

    public static long getFieldnoteExportDate() {
        return getLong(R.string.pref_fieldNoteExportDate, 0);
    }

    /**
     * remember date of last field note export
     *
     * @param date
     */
    public static void setFieldnoteExportDate(final long date) {
        putLong(R.string.pref_fieldNoteExportDate, date);
    }

    public static boolean isUseNavigationApp(final NavigationAppsEnum navApp) {
        return getBoolean(navApp.preferenceKey, true);
    }

    /**
     * remember the state of the "Upload" checkbox in the field notes export dialog
     *
     * @param upload
     */
    public static void setFieldNoteExportUpload(final boolean upload) {
        putBoolean(R.string.pref_fieldNoteExportUpload, upload);
    }

    public static boolean getFieldNoteExportUpload() {
        return getBoolean(R.string.pref_fieldNoteExportUpload, true);
    }

    /**
     * remember the state of the "Only new" checkbox in the field notes export dialog
     *
     * @param onlyNew
     */
    public static void setFieldNoteExportOnlyNew(final boolean onlyNew) {
        putBoolean(R.string.pref_fieldNoteExportOnlyNew, onlyNew);
    }

    public static boolean getFieldNoteExportOnlyNew() {
        return getBoolean(R.string.pref_fieldNoteExportOnlyNew, false);
    }

    public static String getECIconSet() {
        return getString(R.string.pref_ec_icons, "1");
    }

    /* Store last checksum of changelog for changelog display */
    public static long getLastChangelogChecksum() {
        return getLong(R.string.pref_changelog_last_checksum, 0);
    }

    public static void setLastChangelogChecksum(final long checksum) {
        putLong(R.string.pref_changelog_last_checksum, checksum);
    }

    public static List<String> getLastOpenedCaches() {
        final List<String> history = Arrays.asList(StringUtils.split(getString(R.string.pref_caches_history, StringUtils.EMPTY), HISTORY_SEPARATOR));
        return history.subList(0, Math.min(HISTORY_SIZE, history.size()));
    }

    public static void addCacheToHistory(@NonNull final String geocode) {
        final ArrayList<String> history = new ArrayList<>(getLastOpenedCaches());
        // bring entry to front, if it already existed
        history.remove(geocode);
        history.add(0, geocode);
        putString(R.string.pref_caches_history, StringUtils.join(history, HISTORY_SEPARATOR));
    }

    public static boolean useHardwareAcceleration() {
        return getBoolean(R.string.pref_hardware_acceleration, !HW_ACCEL_DISABLED_BY_DEFAULT);
    }

    public static boolean setUseHardwareAcceleration(final boolean useHardwareAcceleration) {
        return putBoolean(R.string.pref_hardware_acceleration, useHardwareAcceleration);
    }

    public static String getLastCacheLog() {
        return getString(R.string.pref_last_cache_log, StringUtils.EMPTY);
    }

    public static void setLastCacheLog(final String log) {
        putString(R.string.pref_last_cache_log, log);
    }

    public static String getLastTrackableLog() {
        return getString(R.string.pref_last_trackable_log, StringUtils.EMPTY);
    }

    public static void setLastTrackableLog(final String log) {
        putString(R.string.pref_last_trackable_log, log);
    }
}
!@#$%
20190527_005151,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_a14320
package cgeo.geocaching.settings;

import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.R;
import cgeo.geocaching.apps.cache.navi.NavigationAppFactory.NavigationAppsEnum;
import cgeo.geocaching.connector.capability.ICredentials;
import cgeo.geocaching.connector.gc.GCConnector;
import cgeo.geocaching.connector.gc.GCConstants;
import cgeo.geocaching.connector.gc.GCLogin;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.LiveMapStrategy.Strategy;
import cgeo.geocaching.enumerations.LogType;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.list.StoredList;
import cgeo.geocaching.maps.MapProviderFactory;
import cgeo.geocaching.maps.google.v1.GoogleMapProvider;
import cgeo.geocaching.maps.interfaces.GeoPointImpl;
import cgeo.geocaching.maps.interfaces.MapProvider;
import cgeo.geocaching.maps.interfaces.MapSource;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider.OfflineMapSource;
import cgeo.geocaching.utils.CryptUtils;
import cgeo.geocaching.utils.FileUtils;
import cgeo.geocaching.utils.FileUtils.FileSelector;
import cgeo.geocaching.utils.Log;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.os.Build;
import android.os.Environment;
import android.preference.PreferenceManager;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;

/**
 * General c:geo preferences/settings set by the user
 */
public class Settings {

    private static final char HISTORY_SEPARATOR = ',';
    public static final int SHOW_WP_THRESHOLD_DEFAULT = 10;
    public static final int SHOW_WP_THRESHOLD_MAX = 50;
    private static final int MAP_SOURCE_DEFAULT = GoogleMapProvider.GOOGLE_MAP_ID.hashCode();

    public static final boolean HW_ACCEL_DISABLED_BY_DEFAULT =
            Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1 ||
            StringUtils.equals(Build.MODEL, "HTC One X") ||    // HTC One X
            StringUtils.equals(Build.MODEL, "HTC One S") ||    // HTC One S
            StringUtils.equals(Build.MODEL, "GT-I8190")  ||    // Samsung S3 mini
            StringUtils.equals(Build.MODEL, "GT-S6310L") ||    // Samsung Galaxy Young
            StringUtils.equals(Build.MODEL, "GT-P5210")  ||    // Samsung Galaxy Tab 3
            StringUtils.equals(Build.MODEL, "GT-S7580")  ||    // Samsung Galaxy Trend Plus
            StringUtils.equals(Build.MODEL, "GT-I9105P") ||    // Samsung Galaxy SII Plus
            StringUtils.equals(Build.MODEL, "ST25i")     ||    // Sony Xperia U
            StringUtils.equals(Build.MODEL, "bq Aquaris 5");   // bq Aquaris 5

    private final static int unitsMetric = 1;

    // twitter api keys
    private final static @NonNull String keyConsumerPublic = CryptUtils.rot13("ESnsCvAv3kEupF1GCR3jGj");
    private final static @NonNull String keyConsumerSecret = CryptUtils.rot13("7vQWceACV9umEjJucmlpFe9FCMZSeqIqfkQ2BnhV9x");

    public enum CoordInputFormatEnum {
        Plain,
        Deg,
        Min,
        Sec;

        static int DEFAULT_INT_VALUE = Min.ordinal();

        public static CoordInputFormatEnum fromInt(final int id) {
            final CoordInputFormatEnum[] values = CoordInputFormatEnum.values();
            if (id < 0 || id >= values.length) {
                return Min;
            }
            return values[id];
        }
    }

    private static final SharedPreferences sharedPrefs = PreferenceManager
            .getDefaultSharedPreferences(CgeoApplication.getInstance().getBaseContext());
    static {
        migrateSettings();
        final boolean isDebug = sharedPrefs.getBoolean(getKey(R.string.pref_debug), false);
        Log.setDebug(isDebug);
        CgeoApplication.dumpOnOutOfMemory(isDebug);
    }

    /**
     * Cache the mapsource locally. If that is an offline map source, each request would potentially access the
     * underlying map file, leading to delays.
     */
    private static MapSource mapSource;

    protected Settings() {
        throw new InstantiationError();
    }

    private static void migrateSettings() {
        // migrate from non standard file location and integer based boolean types
        final int oldVersion = getInt(R.string.pref_settingsversion, 0);
        if (oldVersion < 1) {
            final String oldPreferencesName = "cgeo.pref";
            final SharedPreferences old = CgeoApplication.getInstance().getSharedPreferences(oldPreferencesName, Context.MODE_PRIVATE);
            final Editor e = sharedPrefs.edit();

            e.putString(getKey(R.string.pref_temp_twitter_token_secret), old.getString(getKey(R.string.pref_temp_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_temp_twitter_token_public), old.getString(getKey(R.string.pref_temp_twitter_token_public), null));
            e.putBoolean(getKey(R.string.pref_help_shown), old.getInt(getKey(R.string.pref_help_shown), 0) != 0);
            e.putFloat(getKey(R.string.pref_anylongitude), old.getFloat(getKey(R.string.pref_anylongitude), 0));
            e.putFloat(getKey(R.string.pref_anylatitude), old.getFloat(getKey(R.string.pref_anylatitude), 0));
            e.putBoolean(getKey(R.string.pref_offlinemaps), 0 != old.getInt(getKey(R.string.pref_offlinemaps), 1));
            e.putBoolean(getKey(R.string.pref_offlinewpmaps), 0 != old.getInt(getKey(R.string.pref_offlinewpmaps), 0));
            e.putString(getKey(R.string.pref_webDeviceCode), old.getString(getKey(R.string.pref_webDeviceCode), null));
            e.putString(getKey(R.string.pref_webDeviceName), old.getString(getKey(R.string.pref_webDeviceName), null));
            e.putBoolean(getKey(R.string.pref_maplive), old.getInt(getKey(R.string.pref_maplive), 1) != 0);
            e.putInt(getKey(R.string.pref_mapsource), old.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT));
            e.putBoolean(getKey(R.string.pref_twitter), 0 != old.getInt(getKey(R.string.pref_twitter), 0));
            e.putBoolean(getKey(R.string.pref_showaddress), 0 != old.getInt(getKey(R.string.pref_showaddress), 1));
            e.putBoolean(getKey(R.string.pref_showcaptcha), old.getBoolean(getKey(R.string.pref_showcaptcha), false));
            e.putBoolean(getKey(R.string.pref_maptrail), old.getInt(getKey(R.string.pref_maptrail), 1) != 0);
            e.putInt(getKey(R.string.pref_lastmapzoom), old.getInt(getKey(R.string.pref_lastmapzoom), 14));
            e.putBoolean(getKey(R.string.pref_livelist), 0 != old.getInt(getKey(R.string.pref_livelist), 1));
            e.putBoolean(getKey(R.string.pref_units), old.getInt(getKey(R.string.pref_units), unitsMetric) == unitsMetric);
            e.putBoolean(getKey(R.string.pref_skin), old.getInt(getKey(R.string.pref_skin), 0) != 0);
            e.putInt(getKey(R.string.pref_lastusedlist), old.getInt(getKey(R.string.pref_lastusedlist), StoredList.STANDARD_LIST_ID));
            e.putString(getKey(R.string.pref_cachetype), old.getString(getKey(R.string.pref_cachetype), CacheType.ALL.id));
            e.putString(getKey(R.string.pref_twitter_token_secret), old.getString(getKey(R.string.pref_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_twitter_token_public), old.getString(getKey(R.string.pref_twitter_token_public), null));
            e.putInt(getKey(R.string.pref_version), old.getInt(getKey(R.string.pref_version), 0));
            e.putBoolean(getKey(R.string.pref_autoloaddesc), 0 != old.getInt(getKey(R.string.pref_autoloaddesc), 1));
            e.putBoolean(getKey(R.string.pref_ratingwanted), old.getBoolean(getKey(R.string.pref_ratingwanted), true));
            e.putBoolean(getKey(R.string.pref_friendlogswanted), old.getBoolean(getKey(R.string.pref_friendlogswanted), true));
            e.putBoolean(getKey(R.string.pref_useenglish), old.getBoolean(getKey(R.string.pref_useenglish), false));
            e.putBoolean(getKey(R.string.pref_usecompass), 0 != old.getInt(getKey(R.string.pref_usecompass), 1));
            e.putBoolean(getKey(R.string.pref_trackautovisit), old.getBoolean(getKey(R.string.pref_trackautovisit), false));
            e.putBoolean(getKey(R.string.pref_sigautoinsert), old.getBoolean(getKey(R.string.pref_sigautoinsert), false));
            e.putBoolean(getKey(R.string.pref_logimages), old.getBoolean(getKey(R.string.pref_logimages), false));
            e.putBoolean(getKey(R.string.pref_excludedisabled), 0 != old.getInt(getKey(R.string.pref_excludedisabled), 0));
            e.putBoolean(getKey(R.string.pref_excludemine), 0 != old.getInt(getKey(R.string.pref_excludemine), 0));
            e.putString(getKey(R.string.pref_mapfile), old.getString(getKey(R.string.pref_mapfile), null));
            e.putString(getKey(R.string.pref_signature), old.getString(getKey(R.string.pref_signature), null));
            e.putString(getKey(R.string.pref_pass_vote), old.getString(getKey(R.string.pref_pass_vote), null));
            e.putString(getKey(R.string.pref_password), old.getString(getKey(R.string.pref_password), null));
            e.putString(getKey(R.string.pref_username), old.getString(getKey(R.string.pref_username), null));
            e.putString(getKey(R.string.pref_memberstatus), old.getString(getKey(R.string.pref_memberstatus), ""));
            e.putInt(getKey(R.string.pref_coordinputformat), old.getInt(getKey(R.string.pref_coordinputformat), CoordInputFormatEnum.DEFAULT_INT_VALUE));
            e.putBoolean(getKey(R.string.pref_log_offline), old.getBoolean(getKey(R.string.pref_log_offline), false));
            e.putBoolean(getKey(R.string.pref_choose_list), old.getBoolean(getKey(R.string.pref_choose_list), true));
            e.putBoolean(getKey(R.string.pref_loaddirectionimg), old.getBoolean(getKey(R.string.pref_loaddirectionimg), true));
            e.putString(getKey(R.string.pref_gccustomdate), old.getString(getKey(R.string.pref_gccustomdate), null));
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), old.getInt(getKey(R.string.pref_showwaypointsthreshold), SHOW_WP_THRESHOLD_DEFAULT));
            e.putString(getKey(R.string.pref_cookiestore), old.getString(getKey(R.string.pref_cookiestore), null));
            e.putBoolean(getKey(R.string.pref_opendetailslastpage), old.getBoolean(getKey(R.string.pref_opendetailslastpage), false));
            e.putInt(getKey(R.string.pref_lastdetailspage), old.getInt(getKey(R.string.pref_lastdetailspage), 1));
            e.putInt(getKey(R.string.pref_defaultNavigationTool), old.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id));
            e.putInt(getKey(R.string.pref_defaultNavigationTool2), old.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id));
            e.putInt(getKey(R.string.pref_livemapstrategy), old.getInt(getKey(R.string.pref_livemapstrategy), Strategy.AUTO.id));
            e.putBoolean(getKey(R.string.pref_debug), old.getBoolean(getKey(R.string.pref_debug), false));
            e.putBoolean(getKey(R.string.pref_hidelivemaphint), old.getInt(getKey(R.string.pref_hidelivemaphint), 0) != 0);
            e.putInt(getKey(R.string.pref_livemaphintshowcount), old.getInt(getKey(R.string.pref_livemaphintshowcount), 0));

            e.putInt(getKey(R.string.pref_settingsversion), 1); // mark migrated
            e.commit();
        }

        // changes for new settings dialog
        if (oldVersion < 2) {
            final Editor e = sharedPrefs.edit();

            e.putBoolean(getKey(R.string.pref_units), !isUseImperialUnits());

            // show waypoints threshold now as a slider
            int wpThreshold = getWayPointsThreshold();
            if (wpThreshold < 0) {
                wpThreshold = 0;
            } else if (wpThreshold > SHOW_WP_THRESHOLD_MAX) {
                wpThreshold = SHOW_WP_THRESHOLD_MAX;
            }
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), wpThreshold);

            // KEY_MAP_SOURCE must be string, because it is the key for a ListPreference now
            final int ms = sharedPrefs.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT);
            e.remove(getKey(R.string.pref_mapsource));
            e.putString(getKey(R.string.pref_mapsource), String.valueOf(ms));

            // navigation tool ids must be string, because ListPreference uses strings as keys
            final int dnt1 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id);
            final int dnt2 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id);
            e.remove(getKey(R.string.pref_defaultNavigationTool));
            e.remove(getKey(R.string.pref_defaultNavigationTool2));
            e.putString(getKey(R.string.pref_defaultNavigationTool), String.valueOf(dnt1));
            e.putString(getKey(R.string.pref_defaultNavigationTool2), String.valueOf(dnt2));

            // defaults for gpx directories
            e.putString(getKey(R.string.pref_gpxImportDir), getGpxImportDir());
            e.putString(getKey(R.string.pref_gpxExportDir), getGpxExportDir());

            e.putInt(getKey(R.string.pref_settingsversion), 2); // mark migrated
            e.commit();
        }
    }

    private static String getKey(final int prefKeyId) {
        return CgeoApplication.getInstance().getString(prefKeyId);
    }

    static String getString(final int prefKeyId, final String defaultValue) {
        return sharedPrefs.getString(getKey(prefKeyId), defaultValue);
    }

    private static int getInt(final int prefKeyId, final int defaultValue) {
        return sharedPrefs.getInt(getKey(prefKeyId), defaultValue);
    }

    private static long getLong(final int prefKeyId, final long defaultValue) {
        return sharedPrefs.getLong(getKey(prefKeyId), defaultValue);
    }

    private static boolean getBoolean(final int prefKeyId, final boolean defaultValue) {
        return sharedPrefs.getBoolean(getKey(prefKeyId), defaultValue);
    }

    private static float getFloat(final int prefKeyId, final float defaultValue) {
        return sharedPrefs.getFloat(getKey(prefKeyId), defaultValue);
    }

    protected static boolean putString(final int prefKeyId, final String value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putString(getKey(prefKeyId), value);
        return edit.commit();
    }

    protected static boolean putBoolean(final int prefKeyId, final boolean value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putBoolean(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putInt(final int prefKeyId, final int value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putInt(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putLong(final int prefKeyId, final long value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putLong(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putFloat(final int prefKeyId, final float value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putFloat(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean remove(final int prefKeyId) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.remove(getKey(prefKeyId));
        return edit.commit();
    }

    private static boolean contains(final int prefKeyId) {
        return sharedPrefs.contains(getKey(prefKeyId));
    }

    public static void setLanguage(final boolean useEnglish) {
        final Configuration config = new Configuration();
        config.locale = useEnglish ? Locale.ENGLISH : Locale.getDefault();
        final Resources resources = CgeoApplication.getInstance().getResources();
        resources.updateConfiguration(config, resources.getDisplayMetrics());
    }

    public static boolean isLogin() {
        final String preUsername = getString(R.string.pref_username, null);
        final String prePassword = getString(R.string.pref_password, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    /**
     * Get login and password information of Geocaching.com.
     *
     * @return a pair either with (login, password) or (empty, empty) if no valid information is stored
     */
    public static ImmutablePair<String, String> getGcCredentials() {
        return getCredentials(GCConnector.getInstance());
    }

    /**
     * Get login and password information.
     *
     * @return a pair either with (login, password) or (empty, empty) if no valid information is stored
     */
    public static ImmutablePair<String, String> getCredentials(final @NonNull ICredentials connector) {
        final String username = getString(connector.getUsernamePreferenceKey(), null);
        final String password = getString(connector.getPasswordPreferenceKey(), null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return new ImmutablePair<>(StringUtils.EMPTY, StringUtils.EMPTY);
        }

        return new ImmutablePair<>(username, password);
    }

    public static String getUsername() {
        return getString(R.string.pref_username, null);
    }

    public static boolean isGCConnectorActive() {
        return getBoolean(R.string.pref_connectorGCActive, true);
    }

    public static boolean isECConnectorActive() {
        return getBoolean(R.string.pref_connectorECActive, false);
    }

    public static boolean isOXConnectorActive() {
        return getBoolean(R.string.pref_connectorOXActive, false);
    }

    public static boolean isGCPremiumMember() {
        // Basic Member, Premium Member, ???
        return GCConstants.MEMBER_STATUS_PM.equalsIgnoreCase(Settings.getGCMemberStatus());
    }

    public static String getGCMemberStatus() {
        return getString(R.string.pref_memberstatus, "");
    }

    public static boolean setGCMemberStatus(final String memberStatus) {
        if (StringUtils.isBlank(memberStatus)) {
            return remove(R.string.pref_memberstatus);
        }
        return putString(R.string.pref_memberstatus, memberStatus);
    }

    public static ImmutablePair<String, String> getTokenPair(final int tokenPublicPrefKey, final int tokenSecretPrefKey) {
        return new ImmutablePair<>(getString(tokenPublicPrefKey, null), getString(tokenSecretPrefKey, null));
    }

    public static void setTokens(final int tokenPublicPrefKey, @Nullable final String tokenPublic, final int tokenSecretPrefKey, @Nullable final String tokenSecret) {
        if (tokenPublic == null) {
            remove(tokenPublicPrefKey);
        } else {
            putString(tokenPublicPrefKey, tokenPublic);
        }
        if (tokenSecret == null) {
            remove(tokenSecretPrefKey);
        } else {
            putString(tokenSecretPrefKey, tokenSecret);
        }
    }

    public static boolean isOCConnectorActive(final int isActivePrefKeyId) {
        return getBoolean(isActivePrefKeyId, false);
    }

    public static boolean hasOCAuthorization(final int tokenPublicPrefKeyId, final int tokenSecretPrefKeyId) {
        return StringUtils.isNotBlank(getString(tokenPublicPrefKeyId, ""))
                && StringUtils.isNotBlank(getString(tokenSecretPrefKeyId, ""));
    }

    public static boolean isGCvoteLogin() {
        final String preUsername = getString(R.string.pref_username, null);
        final String prePassword = getString(R.string.pref_pass_vote, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    public static ImmutablePair<String, String> getGCvoteLogin() {
        final String username = getString(R.string.pref_username, null);
        final String password = getString(R.string.pref_pass_vote, null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return null;
        }

        return new ImmutablePair<>(username, password);
    }

    public static String getSignature() {
        return getString(R.string.pref_signature, StringUtils.EMPTY);
    }

    public static boolean setCookieStore(final String cookies) {
        if (StringUtils.isBlank(cookies)) {
            // erase cookies
            return remove(R.string.pref_cookiestore);
        }
        // save cookies
        return putString(R.string.pref_cookiestore, cookies);
    }

    public static String getCookieStore() {
        return getString(R.string.pref_cookiestore, null);
    }

    /**
     * @param cacheType
     *            The cache type used for future filtering
     */
    public static void setCacheType(final CacheType cacheType) {
        if (cacheType == null) {
            remove(R.string.pref_cachetype);
        } else {
            putString(R.string.pref_cachetype, cacheType.id);
        }
    }

    public static int getLastList() {
        return getInt(R.string.pref_lastusedlist, StoredList.STANDARD_LIST_ID);
    }

    public static void saveLastList(final int listId) {
        putInt(R.string.pref_lastusedlist, listId);
    }

    public static void setWebNameCode(final String name, final String code) {
        putString(R.string.pref_webDeviceName, name);
        putString(R.string.pref_webDeviceCode, code);
    }

    public static MapProvider getMapProvider() {
        return getMapSource().getMapProvider();
    }

    public static String getMapFile() {
        return getString(R.string.pref_mapfile, null);
    }

    public static boolean setMapFile(final String mapFile) {
        final boolean result = putString(R.string.pref_mapfile, mapFile);
        if (mapFile != null) {
            setMapFileDirectory(new File(mapFile).getParent());
        }
        return result;
    }

    public static String getMapFileDirectory() {
        final String mapDir = getString(R.string.pref_mapDirectory, null);
        if (mapDir != null) {
            return mapDir;
        }
        final String mapFile = getMapFile();
        if (mapFile != null) {
            return new File(mapFile).getParent();
        }
        return null;
    }

    public static boolean setMapFileDirectory(final String mapFileDirectory) {
        final boolean result = putString(R.string.pref_mapDirectory, mapFileDirectory);
        MapsforgeMapProvider.getInstance().updateOfflineMaps();
        return result;
    }

    public static boolean isValidMapFile() {
        return isValidMapFile(getMapFile());
    }

    public static boolean isValidMapFile(final String mapFileIn) {
        return MapsforgeMapProvider.isValidMapFile(mapFileIn);
    }

    public static boolean isScaleMapsforgeText() {
        return getBoolean(R.string.pref_mapsforge_scale_text, true);
    }

    public static CoordInputFormatEnum getCoordInputFormat() {
        return CoordInputFormatEnum.fromInt(getInt(R.string.pref_coordinputformat, CoordInputFormatEnum.DEFAULT_INT_VALUE));
    }

    public static void setCoordInputFormat(final CoordInputFormatEnum format) {
        putInt(R.string.pref_coordinputformat, format.ordinal());
    }

    public static boolean getLogOffline() {
        return getBoolean(R.string.pref_log_offline, false);
    }

    public static boolean getChooseList() {
        return getBoolean(R.string.pref_choose_list, false);
    }

    public static boolean getLoadDirImg() {
        return !isGCPremiumMember() && getBoolean(R.string.pref_loaddirectionimg, true);
    }

    public static void setGcCustomDate(final String format) {
        putString(R.string.pref_gccustomdate, format);
    }

    /**
     * @return User selected date format on GC.com
     * @see GCLogin#GC_CUSTOM_DATE_FORMATS
     */
    public static String getGcCustomDate() {
        return getString(R.string.pref_gccustomdate, null);
    }

    public static boolean isExcludeMyCaches() {
        return getBoolean(R.string.pref_excludemine, false);
    }

    public static boolean isUseEnglish() {
        return getBoolean(R.string.pref_useenglish, false);
    }

    public static boolean isShowAddress() {
        return getBoolean(R.string.pref_showaddress, true);
    }

    public static boolean isShowCaptcha() {
        return !isGCPremiumMember() && getBoolean(R.string.pref_showcaptcha, false);
    }

    public static boolean isExcludeDisabledCaches() {
        return getBoolean(R.string.pref_excludedisabled, false);
    }

    public static boolean isStoreOfflineMaps() {
        return getBoolean(R.string.pref_offlinemaps, true);
    }

    public static boolean isStoreOfflineWpMaps() {
        return getBoolean(R.string.pref_offlinewpmaps, false);
    }

    public static boolean isStoreLogImages() {
        return getBoolean(R.string.pref_logimages, false);
    }

    public static boolean isAutoLoadDescription() {
        return getBoolean(R.string.pref_autoloaddesc, true);
    }

    public static boolean isRatingWanted() {
        return getBoolean(R.string.pref_ratingwanted, true);
    }

    public static boolean isFriendLogsWanted() {
        if (!isLogin()) {
            // don't show a friends log if the user is anonymous
            return false;
        }
        return getBoolean(R.string.pref_friendlogswanted, true);
    }

    public static boolean isLiveList() {
        return getBoolean(R.string.pref_livelist, true);
    }

    public static boolean isTrackableAutoVisit() {
        return getBoolean(R.string.pref_trackautovisit, false);
    }

    public static boolean isAutoInsertSignature() {
        return getBoolean(R.string.pref_sigautoinsert, false);
    }

    public static boolean isUseImperialUnits() {
        return getBoolean(R.string.pref_units, getImperialUnitsDefault());
    }

    static boolean getImperialUnitsDefault() {
        final String countryCode = Locale.getDefault().getCountry();
        return "US".equals(countryCode)  // USA
            || "LR".equals(countryCode)  // Liberia
            || "MM".equals(countryCode); // Burma
    }

    public static boolean isLiveMap() {
        return getBoolean(R.string.pref_maplive, true);
    }

    public static void setLiveMap(final boolean live) {
        putBoolean(R.string.pref_maplive, live);
    }

    public static boolean isMapTrail() {
        return getBoolean(R.string.pref_maptrail, true);
    }

    public static void setMapTrail(final boolean showTrail) {
        putBoolean(R.string.pref_maptrail, showTrail);
    }

    public static int getMapZoom() {
        return getInt(R.string.pref_lastmapzoom, 14);
    }

    public static void setMapZoom(final int mapZoomLevel) {
        putInt(R.string.pref_lastmapzoom, mapZoomLevel);
    }

    public static GeoPointImpl getMapCenter() {
        return getMapProvider().getMapItemFactory()
                .getGeoPointBase(new Geopoint(getInt(R.string.pref_lastmaplat, 0) / 1e6,
                        getInt(R.string.pref_lastmaplon, 0) / 1e6));
    }

    public static void setMapCenter(final GeoPointImpl mapViewCenter) {
        putInt(R.string.pref_lastmaplat, mapViewCenter.getLatitudeE6());
        putInt(R.string.pref_lastmaplon, mapViewCenter.getLongitudeE6());
    }

    @NonNull
    public static synchronized MapSource getMapSource() {
        if (mapSource != null) {
            return mapSource;
        }
        final int id = getConvertedMapId();
        mapSource = MapProviderFactory.getMapSource(id);
        if (mapSource != null) {
            // don't use offline maps if the map file is not valid
            if ((!(mapSource instanceof OfflineMapSource)) || (isValidMapFile())) {
                return mapSource;
            }
        }
        // fallback to first available map
        return MapProviderFactory.getDefaultSource();
    }

    private final static int GOOGLEMAP_BASEID = 30;
    private final static int MAP = 1;
    private final static int SATELLITE = 2;

    private final static int MFMAP_BASEID = 40;
    private final static int MAPNIK = 1;
    private final static int CYCLEMAP = 3;
    private final static int OFFLINE = 4;
    private static final int HISTORY_SIZE = 10;

    /**
     * convert old preference ids for maps (based on constant values) into new hash based ids
     *
     * @return
     */
    private static int getConvertedMapId() {
        final int id = Integer.parseInt(getString(R.string.pref_mapsource,
                String.valueOf(MAP_SOURCE_DEFAULT)));
        switch (id) {
            case GOOGLEMAP_BASEID + MAP:
                return GoogleMapProvider.GOOGLE_MAP_ID.hashCode();
            case GOOGLEMAP_BASEID + SATELLITE:
                return GoogleMapProvider.GOOGLE_SATELLITE_ID.hashCode();
            case MFMAP_BASEID + MAPNIK:
                return MapsforgeMapProvider.MAPSFORGE_MAPNIK_ID.hashCode();
            case MFMAP_BASEID + CYCLEMAP:
                return MapsforgeMapProvider.MAPSFORGE_CYCLEMAP_ID.hashCode();
            case MFMAP_BASEID + OFFLINE: {
                final String mapFile = Settings.getMapFile();
                if (StringUtils.isNotEmpty(mapFile)) {
                    return mapFile.hashCode();
                }
                break;
            }
            default:
                break;
        }
        return id;
    }

    public static void setMapSource(final MapSource newMapSource) {
        putString(R.string.pref_mapsource, String.valueOf(newMapSource.getNumericalId()));
        if (newMapSource instanceof OfflineMapSource) {
            setMapFile(((OfflineMapSource) newMapSource).getFileName());
        }
        // cache the value
        mapSource = newMapSource;
    }

    public static void setAnyCoordinates(final Geopoint coords) {
        if (null != coords) {
            putFloat(R.string.pref_anylatitude, (float) coords.getLatitude());
            putFloat(R.string.pref_anylongitude, (float) coords.getLongitude());
        } else {
            remove(R.string.pref_anylatitude);
            remove(R.string.pref_anylongitude);
        }
    }

    public static Geopoint getAnyCoordinates() {
        if (contains(R.string.pref_anylatitude) && contains(R.string.pref_anylongitude)) {
            final float lat = getFloat(R.string.pref_anylatitude, 0);
            final float lon = getFloat(R.string.pref_anylongitude, 0);
            return new Geopoint(lat, lon);
        }
        return null;
    }

    public static boolean isUseCompass() {
        return getBoolean(R.string.pref_usecompass, true);
    }

    public static void setUseCompass(final boolean useCompass) {
        putBoolean(R.string.pref_usecompass, useCompass);
    }

    public static boolean isLightSkin() {
        return getBoolean(R.string.pref_skin, false);
    }

    @NonNull
    public static String getKeyConsumerPublic() {
        return keyConsumerPublic;
    }

    @NonNull
    public static String getKeyConsumerSecret() {
        return keyConsumerSecret;
    }

    public static String getWebDeviceCode() {
        return getString(R.string.pref_webDeviceCode, null);
    }

    public static boolean isRegisteredForSend2cgeo() {
        return getWebDeviceCode() != null;
    }

    public static String getWebDeviceName() {
        return getString(R.string.pref_webDeviceName, android.os.Build.MODEL);
    }

    /**
     * @return The cache type used for filtering or ALL if no filter is active.
     *         Returns never null
     */
    public static CacheType getCacheType() {
        return CacheType.getById(getString(R.string.pref_cachetype, CacheType.ALL.id));
    }

    /**
     * The Threshold for the showing of child waypoints
     */
    public static int getWayPointsThreshold() {
        return getInt(R.string.pref_showwaypointsthreshold, SHOW_WP_THRESHOLD_DEFAULT);
    }

    public static void setShowWaypointsThreshold(final int threshold) {
        putInt(R.string.pref_showwaypointsthreshold, threshold);
    }

    public static boolean isUseTwitter() {
        return getBoolean(R.string.pref_twitter, false);
    }

    public static void setUseTwitter(final boolean useTwitter) {
        putBoolean(R.string.pref_twitter, useTwitter);
    }

    public static boolean isTwitterLoginValid() {
        return !StringUtils.isBlank(getTokenPublic())
                && !StringUtils.isBlank(getTokenSecret());
    }

    public static String getTokenPublic() {
        return getString(R.string.pref_twitter_token_public, null);
    }

    public static String getTokenSecret() {
        return getString(R.string.pref_twitter_token_secret, null);

    }

    public static boolean hasTwitterAuthorization() {
        return StringUtils.isNotBlank(getTokenPublic())
                && StringUtils.isNotBlank(getTokenSecret());
    }

    public static void setTwitterTokens(@Nullable final String tokenPublic,
            @Nullable final String tokenSecret, final boolean enableTwitter) {
        putString(R.string.pref_twitter_token_public, tokenPublic);
        putString(R.string.pref_twitter_token_secret, tokenSecret);
        if (tokenPublic != null) {
            remove(R.string.pref_temp_twitter_token_public);
            remove(R.string.pref_temp_twitter_token_secret);
        }
        setUseTwitter(enableTwitter);
    }

    public static void setTwitterTempTokens(@Nullable final String tokenPublic,
            @Nullable final String tokenSecret) {
        putString(R.string.pref_temp_twitter_token_public, tokenPublic);
        putString(R.string.pref_temp_twitter_token_secret, tokenSecret);
    }

    public static ImmutablePair<String, String> getTempToken() {
        final String tokenPublic = getString(R.string.pref_temp_twitter_token_public, null);
        final String tokenSecret = getString(R.string.pref_temp_twitter_token_secret, null);
        return new ImmutablePair<>(tokenPublic, tokenSecret);
    }

    public static int getVersion() {
        return getInt(R.string.pref_version, 0);
    }

    public static void setVersion(final int version) {
        putInt(R.string.pref_version, version);
    }

    public static boolean isOpenLastDetailsPage() {
        return getBoolean(R.string.pref_opendetailslastpage, false);
    }

    public static int getLastDetailsPage() {
        return getInt(R.string.pref_lastdetailspage, 1);
    }

    public static void setLastDetailsPage(final int index) {
        putInt(R.string.pref_lastdetailspage, index);
    }

    public static int getDefaultNavigationTool() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool,
                String.valueOf(NavigationAppsEnum.COMPASS.id)));
    }

    public static int getDefaultNavigationTool2() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool2,
                String.valueOf(NavigationAppsEnum.INTERNAL_MAP.id)));
    }

    public static Strategy getLiveMapStrategy() {
        return Strategy.getById(getInt(R.string.pref_livemapstrategy, Strategy.AUTO.id));
    }

    public static void setLiveMapStrategy(final Strategy strategy) {
        putInt(R.string.pref_livemapstrategy, strategy.id);
    }

    public static boolean isDebug() {
        return Log.isDebug();
    }

    public static boolean getHideLiveMapHint() {
        return getBoolean(R.string.pref_hidelivemaphint, false);
    }

    public static void setHideLiveHint(final boolean hide) {
        putBoolean(R.string.pref_hidelivemaphint, hide);
    }

    public static int getLiveMapHintShowCount() {
        return getInt(R.string.pref_livemaphintshowcount, 0);
    }

    public static void setLiveMapHintShowCount(final int showCount) {
        putInt(R.string.pref_livemaphintshowcount, showCount);
    }

    public static boolean isDbOnSDCard() {
        return getBoolean(R.string.pref_dbonsdcard, false);
    }

    public static void setDbOnSDCard(final boolean dbOnSDCard) {
        putBoolean(R.string.pref_dbonsdcard, dbOnSDCard);
    }

    public static String getGpxExportDir() {
        return getString(R.string.pref_gpxExportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static String getGpxImportDir() {
        return getString(R.string.pref_gpxImportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static boolean getShareAfterExport() {
        return getBoolean(R.string.pref_shareafterexport, true);
    }

    public static void setShareAfterExport(final boolean shareAfterExport) {
        putBoolean(R.string.pref_shareafterexport, shareAfterExport);
    }

    public static int getTrackableAction() {
        return getInt(R.string.pref_trackableaction, LogType.RETRIEVED_IT.id);
    }

    public static void setTrackableAction(final int trackableAction) {
        putInt(R.string.pref_trackableaction, trackableAction);
    }

    public static String getCustomRenderThemeBaseFolder() {
        return getString(R.string.pref_renderthemepath, "");
    }

    public static String getCustomRenderThemeFilePath() {
        return getString(R.string.pref_renderthemefile, "");
    }

    public static void setCustomRenderThemeFile(final String customRenderThemeFile) {
        putString(R.string.pref_renderthemefile, customRenderThemeFile);
    }

    public static File[] getMapThemeFiles() {
        final File directory = new File(Settings.getCustomRenderThemeBaseFolder());
        final List<File> result = new ArrayList<>();
        FileUtils.listDir(result, directory, new ExtensionsBasedFileSelector(new String[] { "xml" }), null);

        return result.toArray(new File[result.size()]);
    }

    private static class ExtensionsBasedFileSelector extends FileSelector {
        private final String[] extensions;
        public ExtensionsBasedFileSelector(final String[] extensions) {
            this.extensions = extensions;
        }
        @Override
        public boolean isSelected(final File file) {
            final String filename = file.getName();
            for (final String ext : extensions) {
                if (StringUtils.endsWithIgnoreCase(filename, ext)) {
                    return true;
                }
            }
            return false;
        }
        @Override
        public boolean shouldEnd() {
            return false;
        }
    }

    public static boolean getPlainLogs() {
        return getBoolean(R.string.pref_plainLogs, false);
    }

    public static boolean getUseNativeUa() {
        return getBoolean(R.string.pref_nativeUa, false);
    }

    public static String getCacheTwitterMessage() {
        return getString(R.string.pref_twitter_cache_message, "I found [NAME] ([URL]).");
    }

    public static String getTrackableTwitterMessage() {
        return getString(R.string.pref_twitter_trackable_message, "I touched [NAME] ([URL]).");
    }

    public static int getLogImageScale() {
        return getInt(R.string.pref_logImageScale, -1);
    }

    public static void setLogImageScale(final int scale) {
        putInt(R.string.pref_logImageScale, scale);
    }

    public static void setExcludeMine(final boolean exclude) {
        putBoolean(R.string.pref_excludemine, exclude);
    }

    static void setLogin(final String username, final String password) {
        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            // erase username and password
            remove(R.string.pref_username);
            remove(R.string.pref_password);
            return;
        }
        // save username and password
        putString(R.string.pref_username, username);
        putString(R.string.pref_password, password);
    }

    public static long getFieldnoteExportDate() {
        return getLong(R.string.pref_fieldNoteExportDate, 0);
    }

    /**
     * remember date of last field note export
     *
     * @param date
     */
    public static void setFieldnoteExportDate(final long date) {
        putLong(R.string.pref_fieldNoteExportDate, date);
    }

    public static boolean isUseNavigationApp(final NavigationAppsEnum navApp) {
        return getBoolean(navApp.preferenceKey, true);
    }

    /**
     * remember the state of the "Upload" checkbox in the field notes export dialog
     *
     * @param upload
     */
    public static void setFieldNoteExportUpload(final boolean upload) {
        putBoolean(R.string.pref_fieldNoteExportUpload, upload);
    }

    public static boolean getFieldNoteExportUpload() {
        return getBoolean(R.string.pref_fieldNoteExportUpload, true);
    }

    /**
     * remember the state of the "Only new" checkbox in the field notes export dialog
     *
     * @param onlyNew
     */
    public static void setFieldNoteExportOnlyNew(final boolean onlyNew) {
        putBoolean(R.string.pref_fieldNoteExportOnlyNew, onlyNew);
    }

    public static boolean getFieldNoteExportOnlyNew() {
        return getBoolean(R.string.pref_fieldNoteExportOnlyNew, false);
    }

    public static String getECIconSet() {
        return getString(R.string.pref_ec_icons, "1");
    }

    /* Store last checksum of changelog for changelog display */
    public static long getLastChangelogChecksum() {
        return getLong(R.string.pref_changelog_last_checksum, 0);
    }

    public static void setLastChangelogChecksum(final long checksum) {
        putLong(R.string.pref_changelog_last_checksum, checksum);
    }

    public static List<String> getLastOpenedCaches() {
        final List<String> history = Arrays.asList(StringUtils.split(getString(R.string.pref_caches_history, StringUtils.EMPTY), HISTORY_SEPARATOR));
        return history.subList(0, Math.min(HISTORY_SIZE, history.size()));
    }

    public static void addCacheToHistory(@NonNull final String geocode) {
        final ArrayList<String> history = new ArrayList<>(getLastOpenedCaches());
        // bring entry to front, if it already existed
        history.remove(geocode);
        history.add(0, geocode);
        putString(R.string.pref_caches_history, StringUtils.join(history, HISTORY_SEPARATOR));
    }

    public static boolean useHardwareAcceleration() {
        return getBoolean(R.string.pref_hardware_acceleration, !HW_ACCEL_DISABLED_BY_DEFAULT);
    }

    public static boolean setUseHardwareAcceleration(final boolean useHardwareAcceleration) {
        return putBoolean(R.string.pref_hardware_acceleration, useHardwareAcceleration);
    }
}
!@#$%
20190527_005151,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_c14320
package cgeo.geocaching.settings;

import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.R;
import cgeo.geocaching.apps.cache.navi.NavigationAppFactory.NavigationAppsEnum;
import cgeo.geocaching.connector.capability.ICredentials;
import cgeo.geocaching.connector.gc.GCConnector;
import cgeo.geocaching.connector.gc.GCConstants;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.LiveMapStrategy.Strategy;
import cgeo.geocaching.enumerations.LogType;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.list.StoredList;
import cgeo.geocaching.maps.MapProviderFactory;
import cgeo.geocaching.maps.google.v1.GoogleMapProvider;
import cgeo.geocaching.maps.interfaces.GeoPointImpl;
import cgeo.geocaching.maps.interfaces.MapProvider;
import cgeo.geocaching.maps.interfaces.MapSource;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider.OfflineMapSource;
import cgeo.geocaching.utils.CryptUtils;
import cgeo.geocaching.utils.FileUtils;
import cgeo.geocaching.utils.FileUtils.FileSelector;
import cgeo.geocaching.utils.Log;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.os.Build;
import android.os.Environment;
import android.preference.PreferenceManager;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;

/**
 * General c:geo preferences/settings set by the user
 */
public class Settings {

    private static final char HISTORY_SEPARATOR = ',';
    public static final int SHOW_WP_THRESHOLD_DEFAULT = 10;
    public static final int SHOW_WP_THRESHOLD_MAX = 50;
    private static final int MAP_SOURCE_DEFAULT = GoogleMapProvider.GOOGLE_MAP_ID.hashCode();

    public static final boolean HW_ACCEL_DISABLED_BY_DEFAULT =
            Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1 ||
            StringUtils.equals(Build.MODEL, "HTC One X") ||    // HTC One X
            StringUtils.equals(Build.MODEL, "HTC One S") ||    // HTC One S
            StringUtils.equals(Build.MODEL, "GT-I8190")  ||    // Samsung S3 mini
            StringUtils.equals(Build.MODEL, "GT-S6310L") ||    // Samsung Galaxy Young
            StringUtils.equals(Build.MODEL, "GT-P5210")  ||    // Samsung Galaxy Tab 3
            StringUtils.equals(Build.MODEL, "GT-S7580")  ||    // Samsung Galaxy Trend Plus
            StringUtils.equals(Build.MODEL, "GT-I9105P") ||    // Samsung Galaxy SII Plus
            StringUtils.equals(Build.MODEL, "ST25i")     ||    // Sony Xperia U
            StringUtils.equals(Build.MODEL, "bq Aquaris 5");   // bq Aquaris 5

    private final static int unitsMetric = 1;

    // twitter api keys
    private final static @NonNull String keyConsumerPublic = CryptUtils.rot13("ESnsCvAv3kEupF1GCR3jGj");
    private final static @NonNull String keyConsumerSecret = CryptUtils.rot13("7vQWceACV9umEjJucmlpFe9FCMZSeqIqfkQ2BnhV9x");

    public enum CoordInputFormatEnum {
        Plain,
        Deg,
        Min,
        Sec;

        static int DEFAULT_INT_VALUE = Min.ordinal();

        public static CoordInputFormatEnum fromInt(final int id) {
            final CoordInputFormatEnum[] values = CoordInputFormatEnum.values();
            if (id < 0 || id >= values.length) {
                return Min;
            }
            return values[id];
        }
    }

    private static final SharedPreferences sharedPrefs = PreferenceManager
            .getDefaultSharedPreferences(CgeoApplication.getInstance().getBaseContext());
    static {
        migrateSettings();
        final boolean isDebug = sharedPrefs.getBoolean(getKey(R.string.pref_debug), false);
        Log.setDebug(isDebug);
        CgeoApplication.dumpOnOutOfMemory(isDebug);
    }

    /**
     * Cache the mapsource locally. If that is an offline map source, each request would potentially access the
     * underlying map file, leading to delays.
     */
    private static MapSource mapSource;

    protected Settings() {
        throw new InstantiationError();
    }

    private static void migrateSettings() {
        // migrate from non standard file location and integer based boolean types
        final int oldVersion = getInt(R.string.pref_settingsversion, 0);
        if (oldVersion < 1) {
            final String oldPreferencesName = "cgeo.pref";
            final SharedPreferences old = CgeoApplication.getInstance().getSharedPreferences(oldPreferencesName, Context.MODE_PRIVATE);
            final Editor e = sharedPrefs.edit();

            e.putString(getKey(R.string.pref_temp_twitter_token_secret), old.getString(getKey(R.string.pref_temp_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_temp_twitter_token_public), old.getString(getKey(R.string.pref_temp_twitter_token_public), null));
            e.putBoolean(getKey(R.string.pref_help_shown), old.getInt(getKey(R.string.pref_help_shown), 0) != 0);
            e.putFloat(getKey(R.string.pref_anylongitude), old.getFloat(getKey(R.string.pref_anylongitude), 0));
            e.putFloat(getKey(R.string.pref_anylatitude), old.getFloat(getKey(R.string.pref_anylatitude), 0));
            e.putBoolean(getKey(R.string.pref_offlinemaps), 0 != old.getInt(getKey(R.string.pref_offlinemaps), 1));
            e.putBoolean(getKey(R.string.pref_offlinewpmaps), 0 != old.getInt(getKey(R.string.pref_offlinewpmaps), 0));
            e.putString(getKey(R.string.pref_webDeviceCode), old.getString(getKey(R.string.pref_webDeviceCode), null));
            e.putString(getKey(R.string.pref_webDeviceName), old.getString(getKey(R.string.pref_webDeviceName), null));
            e.putBoolean(getKey(R.string.pref_maplive), old.getInt(getKey(R.string.pref_maplive), 1) != 0);
            e.putInt(getKey(R.string.pref_mapsource), old.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT));
            e.putBoolean(getKey(R.string.pref_twitter), 0 != old.getInt(getKey(R.string.pref_twitter), 0));
            e.putBoolean(getKey(R.string.pref_showaddress), 0 != old.getInt(getKey(R.string.pref_showaddress), 1));
            e.putBoolean(getKey(R.string.pref_showcaptcha), old.getBoolean(getKey(R.string.pref_showcaptcha), false));
            e.putBoolean(getKey(R.string.pref_maptrail), old.getInt(getKey(R.string.pref_maptrail), 1) != 0);
            e.putInt(getKey(R.string.pref_lastmapzoom), old.getInt(getKey(R.string.pref_lastmapzoom), 14));
            e.putBoolean(getKey(R.string.pref_livelist), 0 != old.getInt(getKey(R.string.pref_livelist), 1));
            e.putBoolean(getKey(R.string.pref_units), old.getInt(getKey(R.string.pref_units), unitsMetric) == unitsMetric);
            e.putBoolean(getKey(R.string.pref_skin), old.getInt(getKey(R.string.pref_skin), 0) != 0);
            e.putInt(getKey(R.string.pref_lastusedlist), old.getInt(getKey(R.string.pref_lastusedlist), StoredList.STANDARD_LIST_ID));
            e.putString(getKey(R.string.pref_cachetype), old.getString(getKey(R.string.pref_cachetype), CacheType.ALL.id));
            e.putString(getKey(R.string.pref_twitter_token_secret), old.getString(getKey(R.string.pref_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_twitter_token_public), old.getString(getKey(R.string.pref_twitter_token_public), null));
            e.putInt(getKey(R.string.pref_version), old.getInt(getKey(R.string.pref_version), 0));
            e.putBoolean(getKey(R.string.pref_autoloaddesc), 0 != old.getInt(getKey(R.string.pref_autoloaddesc), 1));
            e.putBoolean(getKey(R.string.pref_ratingwanted), old.getBoolean(getKey(R.string.pref_ratingwanted), true));
            e.putBoolean(getKey(R.string.pref_friendlogswanted), old.getBoolean(getKey(R.string.pref_friendlogswanted), true));
            e.putBoolean(getKey(R.string.pref_useenglish), old.getBoolean(getKey(R.string.pref_useenglish), false));
            e.putBoolean(getKey(R.string.pref_usecompass), 0 != old.getInt(getKey(R.string.pref_usecompass), 1));
            e.putBoolean(getKey(R.string.pref_trackautovisit), old.getBoolean(getKey(R.string.pref_trackautovisit), false));
            e.putBoolean(getKey(R.string.pref_sigautoinsert), old.getBoolean(getKey(R.string.pref_sigautoinsert), false));
            e.putBoolean(getKey(R.string.pref_logimages), old.getBoolean(getKey(R.string.pref_logimages), false));
            e.putBoolean(getKey(R.string.pref_excludedisabled), 0 != old.getInt(getKey(R.string.pref_excludedisabled), 0));
            e.putBoolean(getKey(R.string.pref_excludemine), 0 != old.getInt(getKey(R.string.pref_excludemine), 0));
            e.putString(getKey(R.string.pref_mapfile), old.getString(getKey(R.string.pref_mapfile), null));
            e.putString(getKey(R.string.pref_signature), old.getString(getKey(R.string.pref_signature), null));
            e.putString(getKey(R.string.pref_pass_vote), old.getString(getKey(R.string.pref_pass_vote), null));
            e.putString(getKey(R.string.pref_password), old.getString(getKey(R.string.pref_password), null));
            e.putString(getKey(R.string.pref_username), old.getString(getKey(R.string.pref_username), null));
            e.putString(getKey(R.string.pref_memberstatus), old.getString(getKey(R.string.pref_memberstatus), ""));
            e.putInt(getKey(R.string.pref_coordinputformat), old.getInt(getKey(R.string.pref_coordinputformat), CoordInputFormatEnum.DEFAULT_INT_VALUE));
            e.putBoolean(getKey(R.string.pref_log_offline), old.getBoolean(getKey(R.string.pref_log_offline), false));
            e.putBoolean(getKey(R.string.pref_choose_list), old.getBoolean(getKey(R.string.pref_choose_list), true));
            e.putBoolean(getKey(R.string.pref_loaddirectionimg), old.getBoolean(getKey(R.string.pref_loaddirectionimg), true));
            e.putString(getKey(R.string.pref_gccustomdate), old.getString(getKey(R.string.pref_gccustomdate), null));
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), old.getInt(getKey(R.string.pref_showwaypointsthreshold), SHOW_WP_THRESHOLD_DEFAULT));
            e.putString(getKey(R.string.pref_cookiestore), old.getString(getKey(R.string.pref_cookiestore), null));
            e.putBoolean(getKey(R.string.pref_opendetailslastpage), old.getBoolean(getKey(R.string.pref_opendetailslastpage), false));
            e.putInt(getKey(R.string.pref_lastdetailspage), old.getInt(getKey(R.string.pref_lastdetailspage), 1));
            e.putInt(getKey(R.string.pref_defaultNavigationTool), old.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id));
            e.putInt(getKey(R.string.pref_defaultNavigationTool2), old.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id));
            e.putInt(getKey(R.string.pref_livemapstrategy), old.getInt(getKey(R.string.pref_livemapstrategy), Strategy.AUTO.id));
            e.putBoolean(getKey(R.string.pref_debug), old.getBoolean(getKey(R.string.pref_debug), false));
            e.putBoolean(getKey(R.string.pref_hidelivemaphint), old.getInt(getKey(R.string.pref_hidelivemaphint), 0) != 0);
            e.putInt(getKey(R.string.pref_livemaphintshowcount), old.getInt(getKey(R.string.pref_livemaphintshowcount), 0));

            e.putInt(getKey(R.string.pref_settingsversion), 1); // mark migrated
            e.commit();
        }

        // changes for new settings dialog
        if (oldVersion < 2) {
            final Editor e = sharedPrefs.edit();

            e.putBoolean(getKey(R.string.pref_units), !isUseImperialUnits());

            // show waypoints threshold now as a slider
            int wpThreshold = getWayPointsThreshold();
            if (wpThreshold < 0) {
                wpThreshold = 0;
            } else if (wpThreshold > SHOW_WP_THRESHOLD_MAX) {
                wpThreshold = SHOW_WP_THRESHOLD_MAX;
            }
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), wpThreshold);

            // KEY_MAP_SOURCE must be string, because it is the key for a ListPreference now
            final int ms = sharedPrefs.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT);
            e.remove(getKey(R.string.pref_mapsource));
            e.putString(getKey(R.string.pref_mapsource), String.valueOf(ms));

            // navigation tool ids must be string, because ListPreference uses strings as keys
            final int dnt1 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id);
            final int dnt2 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id);
            e.remove(getKey(R.string.pref_defaultNavigationTool));
            e.remove(getKey(R.string.pref_defaultNavigationTool2));
            e.putString(getKey(R.string.pref_defaultNavigationTool), String.valueOf(dnt1));
            e.putString(getKey(R.string.pref_defaultNavigationTool2), String.valueOf(dnt2));

            // defaults for gpx directories
            e.putString(getKey(R.string.pref_gpxImportDir), getGpxImportDir());
            e.putString(getKey(R.string.pref_gpxExportDir), getGpxExportDir());

            e.putInt(getKey(R.string.pref_settingsversion), 2); // mark migrated
            e.commit();
        }
    }

    private static String getKey(final int prefKeyId) {
        return CgeoApplication.getInstance().getString(prefKeyId);
    }

    static String getString(final int prefKeyId, final String defaultValue) {
        return sharedPrefs.getString(getKey(prefKeyId), defaultValue);
    }

    private static int getInt(final int prefKeyId, final int defaultValue) {
        return sharedPrefs.getInt(getKey(prefKeyId), defaultValue);
    }

    private static long getLong(final int prefKeyId, final long defaultValue) {
        return sharedPrefs.getLong(getKey(prefKeyId), defaultValue);
    }

    private static boolean getBoolean(final int prefKeyId, final boolean defaultValue) {
        return sharedPrefs.getBoolean(getKey(prefKeyId), defaultValue);
    }

    private static float getFloat(final int prefKeyId, final float defaultValue) {
        return sharedPrefs.getFloat(getKey(prefKeyId), defaultValue);
    }

    protected static boolean putString(final int prefKeyId, final String value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putString(getKey(prefKeyId), value);
        return edit.commit();
    }

    protected static boolean putBoolean(final int prefKeyId, final boolean value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putBoolean(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putInt(final int prefKeyId, final int value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putInt(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putLong(final int prefKeyId, final long value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putLong(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putFloat(final int prefKeyId, final float value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putFloat(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean remove(final int prefKeyId) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.remove(getKey(prefKeyId));
        return edit.commit();
    }

    private static boolean contains(final int prefKeyId) {
        return sharedPrefs.contains(getKey(prefKeyId));
    }

    public static void setLanguage(final boolean useEnglish) {
        final Configuration config = new Configuration();
        config.locale = useEnglish ? Locale.ENGLISH : Locale.getDefault();
        final Resources resources = CgeoApplication.getInstance().getResources();
        resources.updateConfiguration(config, resources.getDisplayMetrics());
    }

    public static boolean isLogin() {
        final String preUsername = getString(R.string.pref_username, null);
        final String prePassword = getString(R.string.pref_password, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    /**
     * Get login and password information of Geocaching.com.
     *
     * @return a pair either with (login, password) or (empty, empty) if no valid information is stored
     */
    public static ImmutablePair<String, String> getGcCredentials() {
        return getCredentials(GCConnector.getInstance());
    }

    /**
     * Get login and password information.
     *
     * @return a pair either with (login, password) or (empty, empty) if no valid information is stored
     */
    public static ImmutablePair<String, String> getCredentials(final @NonNull ICredentials connector) {
        final String username = getString(connector.getUsernamePreferenceKey(), null);
        final String password = getString(connector.getPasswordPreferenceKey(), null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return new ImmutablePair<>(StringUtils.EMPTY, StringUtils.EMPTY);
        }

        return new ImmutablePair<>(username, password);
    }

    public static String getUsername() {
        return getString(R.string.pref_username, null);
    }

    public static boolean isGCConnectorActive() {
        return getBoolean(R.string.pref_connectorGCActive, true);
    }

    public static boolean isECConnectorActive() {
        return getBoolean(R.string.pref_connectorECActive, false);
    }

    public static boolean isOXConnectorActive() {
        return getBoolean(R.string.pref_connectorOXActive, false);
    }

    public static boolean isGCPremiumMember() {
        // Basic Member, Premium Member, ???
        return GCConstants.MEMBER_STATUS_PM.equalsIgnoreCase(Settings.getGCMemberStatus());
    }

    public static String getGCMemberStatus() {
        return getString(R.string.pref_memberstatus, "");
    }

    public static boolean setGCMemberStatus(final String memberStatus) {
        if (StringUtils.isBlank(memberStatus)) {
            return remove(R.string.pref_memberstatus);
        }
        return putString(R.string.pref_memberstatus, memberStatus);
    }

    public static ImmutablePair<String, String> getTokenPair(final int tokenPublicPrefKey, final int tokenSecretPrefKey) {
        return new ImmutablePair<>(getString(tokenPublicPrefKey, null), getString(tokenSecretPrefKey, null));
    }

    public static void setTokens(final int tokenPublicPrefKey, @Nullable final String tokenPublic, final int tokenSecretPrefKey, @Nullable final String tokenSecret) {
        if (tokenPublic == null) {
            remove(tokenPublicPrefKey);
        } else {
            putString(tokenPublicPrefKey, tokenPublic);
        }
        if (tokenSecret == null) {
            remove(tokenSecretPrefKey);
        } else {
            putString(tokenSecretPrefKey, tokenSecret);
        }
    }

    public static boolean isOCConnectorActive(final int isActivePrefKeyId) {
        return getBoolean(isActivePrefKeyId, false);
    }

    public static boolean hasOCAuthorization(final int tokenPublicPrefKeyId, final int tokenSecretPrefKeyId) {
        return StringUtils.isNotBlank(getString(tokenPublicPrefKeyId, ""))
                && StringUtils.isNotBlank(getString(tokenSecretPrefKeyId, ""));
    }

    public static boolean isGCvoteLogin() {
        final String preUsername = getString(R.string.pref_username, null);
        final String prePassword = getString(R.string.pref_pass_vote, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    public static ImmutablePair<String, String> getGCvoteLogin() {
        final String username = getString(R.string.pref_username, null);
        final String password = getString(R.string.pref_pass_vote, null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return null;
        }

        return new ImmutablePair<>(username, password);
    }

    public static String getSignature() {
        return getString(R.string.pref_signature, StringUtils.EMPTY);
    }

    public static boolean setCookieStore(final String cookies) {
        if (StringUtils.isBlank(cookies)) {
            // erase cookies
            return remove(R.string.pref_cookiestore);
        }
        // save cookies
        return putString(R.string.pref_cookiestore, cookies);
    }

    public static String getCookieStore() {
        return getString(R.string.pref_cookiestore, null);
    }

    /**
     * @param cacheType
     *            The cache type used for future filtering
     */
    public static void setCacheType(final CacheType cacheType) {
        if (cacheType == null) {
            remove(R.string.pref_cachetype);
        } else {
            putString(R.string.pref_cachetype, cacheType.id);
        }
    }

    public static int getLastList() {
        return getInt(R.string.pref_lastusedlist, StoredList.STANDARD_LIST_ID);
    }

    public static void saveLastList(final int listId) {
        putInt(R.string.pref_lastusedlist, listId);
    }

    public static void setWebNameCode(final String name, final String code) {
        putString(R.string.pref_webDeviceName, name);
        putString(R.string.pref_webDeviceCode, code);
    }

    public static MapProvider getMapProvider() {
        return getMapSource().getMapProvider();
    }

    public static String getMapFile() {
        return getString(R.string.pref_mapfile, null);
    }

    public static boolean setMapFile(final String mapFile) {
        final boolean result = putString(R.string.pref_mapfile, mapFile);
        if (mapFile != null) {
            setMapFileDirectory(new File(mapFile).getParent());
        }
        return result;
    }

    public static String getMapFileDirectory() {
        final String mapDir = getString(R.string.pref_mapDirectory, null);
        if (mapDir != null) {
            return mapDir;
        }
        final String mapFile = getMapFile();
        if (mapFile != null) {
            return new File(mapFile).getParent();
        }
        return null;
    }

    public static boolean setMapFileDirectory(final String mapFileDirectory) {
        final boolean result = putString(R.string.pref_mapDirectory, mapFileDirectory);
        MapsforgeMapProvider.getInstance().updateOfflineMaps();
        return result;
    }

    public static boolean isValidMapFile() {
        return isValidMapFile(getMapFile());
    }

    public static boolean isValidMapFile(final String mapFileIn) {
        return MapsforgeMapProvider.isValidMapFile(mapFileIn);
    }

    public static boolean isScaleMapsforgeText() {
        return getBoolean(R.string.pref_mapsforge_scale_text, true);
    }

    public static CoordInputFormatEnum getCoordInputFormat() {
        return CoordInputFormatEnum.fromInt(getInt(R.string.pref_coordinputformat, CoordInputFormatEnum.DEFAULT_INT_VALUE));
    }

    public static void setCoordInputFormat(final CoordInputFormatEnum format) {
        putInt(R.string.pref_coordinputformat, format.ordinal());
    }

    public static boolean getLogOffline() {
        return getBoolean(R.string.pref_log_offline, false);
    }

    public static boolean getChooseList() {
        return getBoolean(R.string.pref_choose_list, false);
    }

    public static boolean getLoadDirImg() {
        return !isGCPremiumMember() && getBoolean(R.string.pref_loaddirectionimg, true);
    }

    public static void setGcCustomDate(final String format) {
        putString(R.string.pref_gccustomdate, format);
    }

    /**
     * @return User selected date format on GC.com
     */
    public static String getGcCustomDate() {
        return getString(R.string.pref_gccustomdate, null);
    }

    public static boolean isExcludeMyCaches() {
        return getBoolean(R.string.pref_excludemine, false);
    }

    public static boolean isUseEnglish() {
        return getBoolean(R.string.pref_useenglish, false);
    }

    public static boolean isShowAddress() {
        return getBoolean(R.string.pref_showaddress, true);
    }

    public static boolean isShowCaptcha() {
        return !isGCPremiumMember() && getBoolean(R.string.pref_showcaptcha, false);
    }

    public static boolean isExcludeDisabledCaches() {
        return getBoolean(R.string.pref_excludedisabled, false);
    }

    public static boolean isStoreOfflineMaps() {
        return getBoolean(R.string.pref_offlinemaps, true);
    }

    public static boolean isStoreOfflineWpMaps() {
        return getBoolean(R.string.pref_offlinewpmaps, false);
    }

    public static boolean isStoreLogImages() {
        return getBoolean(R.string.pref_logimages, false);
    }

    public static boolean isAutoLoadDescription() {
        return getBoolean(R.string.pref_autoloaddesc, true);
    }

    public static boolean isRatingWanted() {
        return getBoolean(R.string.pref_ratingwanted, true);
    }

    public static boolean isFriendLogsWanted() {
        if (!isLogin()) {
            // don't show a friends log if the user is anonymous
            return false;
        }
        return getBoolean(R.string.pref_friendlogswanted, true);
    }

    public static boolean isLiveList() {
        return getBoolean(R.string.pref_livelist, true);
    }

    public static boolean isTrackableAutoVisit() {
        return getBoolean(R.string.pref_trackautovisit, false);
    }

    public static boolean isAutoInsertSignature() {
        return getBoolean(R.string.pref_sigautoinsert, false);
    }

    public static boolean isUseImperialUnits() {
        return getBoolean(R.string.pref_units, getImperialUnitsDefault());
    }

    static boolean getImperialUnitsDefault() {
        final String countryCode = Locale.getDefault().getCountry();
        return "US".equals(countryCode)  // USA
            || "LR".equals(countryCode)  // Liberia
            || "MM".equals(countryCode); // Burma
    }

    public static boolean isLiveMap() {
        return getBoolean(R.string.pref_maplive, true);
    }

    public static void setLiveMap(final boolean live) {
        putBoolean(R.string.pref_maplive, live);
    }

    public static boolean isMapTrail() {
        return getBoolean(R.string.pref_maptrail, true);
    }

    public static void setMapTrail(final boolean showTrail) {
        putBoolean(R.string.pref_maptrail, showTrail);
    }

    public static int getMapZoom() {
        return getInt(R.string.pref_lastmapzoom, 14);
    }

    public static void setMapZoom(final int mapZoomLevel) {
        putInt(R.string.pref_lastmapzoom, mapZoomLevel);
    }

    public static GeoPointImpl getMapCenter() {
        return getMapProvider().getMapItemFactory()
                .getGeoPointBase(new Geopoint(getInt(R.string.pref_lastmaplat, 0) / 1e6,
                        getInt(R.string.pref_lastmaplon, 0) / 1e6));
    }

    public static void setMapCenter(final GeoPointImpl mapViewCenter) {
        putInt(R.string.pref_lastmaplat, mapViewCenter.getLatitudeE6());
        putInt(R.string.pref_lastmaplon, mapViewCenter.getLongitudeE6());
    }

    @NonNull
    public static synchronized MapSource getMapSource() {
        if (mapSource != null) {
            return mapSource;
        }
        final int id = getConvertedMapId();
        mapSource = MapProviderFactory.getMapSource(id);
        if (mapSource != null) {
            // don't use offline maps if the map file is not valid
            if ((!(mapSource instanceof OfflineMapSource)) || (isValidMapFile())) {
                return mapSource;
            }
        }
        // fallback to first available map
        return MapProviderFactory.getDefaultSource();
    }

    private final static int GOOGLEMAP_BASEID = 30;
    private final static int MAP = 1;
    private final static int SATELLITE = 2;

    private final static int MFMAP_BASEID = 40;
    private final static int MAPNIK = 1;
    private final static int CYCLEMAP = 3;
    private final static int OFFLINE = 4;
    private static final int HISTORY_SIZE = 10;

    /**
     * convert old preference ids for maps (based on constant values) into new hash based ids
     *
     * @return
     */
    private static int getConvertedMapId() {
        final int id = Integer.parseInt(getString(R.string.pref_mapsource,
                String.valueOf(MAP_SOURCE_DEFAULT)));
        switch (id) {
            case GOOGLEMAP_BASEID + MAP:
                return GoogleMapProvider.GOOGLE_MAP_ID.hashCode();
            case GOOGLEMAP_BASEID + SATELLITE:
                return GoogleMapProvider.GOOGLE_SATELLITE_ID.hashCode();
            case MFMAP_BASEID + MAPNIK:
                return MapsforgeMapProvider.MAPSFORGE_MAPNIK_ID.hashCode();
            case MFMAP_BASEID + CYCLEMAP:
                return MapsforgeMapProvider.MAPSFORGE_CYCLEMAP_ID.hashCode();
            case MFMAP_BASEID + OFFLINE: {
                final String mapFile = Settings.getMapFile();
                if (StringUtils.isNotEmpty(mapFile)) {
                    return mapFile.hashCode();
                }
                break;
            }
            default:
                break;
        }
        return id;
    }

    public static void setMapSource(final MapSource newMapSource) {
        putString(R.string.pref_mapsource, String.valueOf(newMapSource.getNumericalId()));
        if (newMapSource instanceof OfflineMapSource) {
            setMapFile(((OfflineMapSource) newMapSource).getFileName());
        }
        // cache the value
        mapSource = newMapSource;
    }

    public static void setAnyCoordinates(final Geopoint coords) {
        if (null != coords) {
            putFloat(R.string.pref_anylatitude, (float) coords.getLatitude());
            putFloat(R.string.pref_anylongitude, (float) coords.getLongitude());
        } else {
            remove(R.string.pref_anylatitude);
            remove(R.string.pref_anylongitude);
        }
    }

    public static Geopoint getAnyCoordinates() {
        if (contains(R.string.pref_anylatitude) && contains(R.string.pref_anylongitude)) {
            final float lat = getFloat(R.string.pref_anylatitude, 0);
            final float lon = getFloat(R.string.pref_anylongitude, 0);
            return new Geopoint(lat, lon);
        }
        return null;
    }

    public static boolean isUseCompass() {
        return getBoolean(R.string.pref_usecompass, true);
    }

    public static void setUseCompass(final boolean useCompass) {
        putBoolean(R.string.pref_usecompass, useCompass);
    }

    public static boolean isLightSkin() {
        return getBoolean(R.string.pref_skin, false);
    }

    @NonNull
    public static String getKeyConsumerPublic() {
        return keyConsumerPublic;
    }

    @NonNull
    public static String getKeyConsumerSecret() {
        return keyConsumerSecret;
    }

    public static String getWebDeviceCode() {
        return getString(R.string.pref_webDeviceCode, null);
    }

    public static boolean isRegisteredForSend2cgeo() {
        return getWebDeviceCode() != null;
    }

    public static String getWebDeviceName() {
        return getString(R.string.pref_webDeviceName, android.os.Build.MODEL);
    }

    /**
     * @return The cache type used for filtering or ALL if no filter is active.
     *         Returns never null
     */
    public static CacheType getCacheType() {
        return CacheType.getById(getString(R.string.pref_cachetype, CacheType.ALL.id));
    }

    /**
     * The Threshold for the showing of child waypoints
     */
    public static int getWayPointsThreshold() {
        return getInt(R.string.pref_showwaypointsthreshold, SHOW_WP_THRESHOLD_DEFAULT);
    }

    public static void setShowWaypointsThreshold(final int threshold) {
        putInt(R.string.pref_showwaypointsthreshold, threshold);
    }

    public static boolean isUseTwitter() {
        return getBoolean(R.string.pref_twitter, false);
    }

    public static void setUseTwitter(final boolean useTwitter) {
        putBoolean(R.string.pref_twitter, useTwitter);
    }

    public static boolean isTwitterLoginValid() {
        return !StringUtils.isBlank(getTokenPublic())
                && !StringUtils.isBlank(getTokenSecret());
    }

    public static String getTokenPublic() {
        return getString(R.string.pref_twitter_token_public, null);
    }

    public static String getTokenSecret() {
        return getString(R.string.pref_twitter_token_secret, null);

    }

    public static boolean hasTwitterAuthorization() {
        return StringUtils.isNotBlank(getTokenPublic())
                && StringUtils.isNotBlank(getTokenSecret());
    }

    public static void setTwitterTokens(@Nullable final String tokenPublic,
            @Nullable final String tokenSecret, final boolean enableTwitter) {
        putString(R.string.pref_twitter_token_public, tokenPublic);
        putString(R.string.pref_twitter_token_secret, tokenSecret);
        if (tokenPublic != null) {
            remove(R.string.pref_temp_twitter_token_public);
            remove(R.string.pref_temp_twitter_token_secret);
        }
        setUseTwitter(enableTwitter);
    }

    public static void setTwitterTempTokens(@Nullable final String tokenPublic,
            @Nullable final String tokenSecret) {
        putString(R.string.pref_temp_twitter_token_public, tokenPublic);
        putString(R.string.pref_temp_twitter_token_secret, tokenSecret);
    }

    public static ImmutablePair<String, String> getTempToken() {
        final String tokenPublic = getString(R.string.pref_temp_twitter_token_public, null);
        final String tokenSecret = getString(R.string.pref_temp_twitter_token_secret, null);
        return new ImmutablePair<>(tokenPublic, tokenSecret);
    }

    public static int getVersion() {
        return getInt(R.string.pref_version, 0);
    }

    public static void setVersion(final int version) {
        putInt(R.string.pref_version, version);
    }

    public static boolean isOpenLastDetailsPage() {
        return getBoolean(R.string.pref_opendetailslastpage, false);
    }

    public static int getLastDetailsPage() {
        return getInt(R.string.pref_lastdetailspage, 1);
    }

    public static void setLastDetailsPage(final int index) {
        putInt(R.string.pref_lastdetailspage, index);
    }

    public static int getDefaultNavigationTool() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool,
                String.valueOf(NavigationAppsEnum.COMPASS.id)));
    }

    public static int getDefaultNavigationTool2() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool2,
                String.valueOf(NavigationAppsEnum.INTERNAL_MAP.id)));
    }

    public static Strategy getLiveMapStrategy() {
        return Strategy.getById(getInt(R.string.pref_livemapstrategy, Strategy.AUTO.id));
    }

    public static void setLiveMapStrategy(final Strategy strategy) {
        putInt(R.string.pref_livemapstrategy, strategy.id);
    }

    public static boolean isDebug() {
        return Log.isDebug();
    }

    public static boolean getHideLiveMapHint() {
        return getBoolean(R.string.pref_hidelivemaphint, false);
    }

    public static void setHideLiveHint(final boolean hide) {
        putBoolean(R.string.pref_hidelivemaphint, hide);
    }

    public static int getLiveMapHintShowCount() {
        return getInt(R.string.pref_livemaphintshowcount, 0);
    }

    public static void setLiveMapHintShowCount(final int showCount) {
        putInt(R.string.pref_livemaphintshowcount, showCount);
    }

    public static boolean isDbOnSDCard() {
        return getBoolean(R.string.pref_dbonsdcard, false);
    }

    public static void setDbOnSDCard(final boolean dbOnSDCard) {
        putBoolean(R.string.pref_dbonsdcard, dbOnSDCard);
    }

    public static String getGpxExportDir() {
        return getString(R.string.pref_gpxExportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static String getGpxImportDir() {
        return getString(R.string.pref_gpxImportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static boolean getShareAfterExport() {
        return getBoolean(R.string.pref_shareafterexport, true);
    }

    public static void setShareAfterExport(final boolean shareAfterExport) {
        putBoolean(R.string.pref_shareafterexport, shareAfterExport);
    }

    public static int getTrackableAction() {
        return getInt(R.string.pref_trackableaction, LogType.RETRIEVED_IT.id);
    }

    public static void setTrackableAction(final int trackableAction) {
        putInt(R.string.pref_trackableaction, trackableAction);
    }

    public static String getCustomRenderThemeBaseFolder() {
        return getString(R.string.pref_renderthemepath, "");
    }

    public static String getCustomRenderThemeFilePath() {
        return getString(R.string.pref_renderthemefile, "");
    }

    public static void setCustomRenderThemeFile(final String customRenderThemeFile) {
        putString(R.string.pref_renderthemefile, customRenderThemeFile);
    }

    public static File[] getMapThemeFiles() {
        final File directory = new File(Settings.getCustomRenderThemeBaseFolder());
        final List<File> result = new ArrayList<>();
        FileUtils.listDir(result, directory, new ExtensionsBasedFileSelector(new String[] { "xml" }), null);

        return result.toArray(new File[result.size()]);
    }

    private static class ExtensionsBasedFileSelector extends FileSelector {
        private final String[] extensions;
        public ExtensionsBasedFileSelector(final String[] extensions) {
            this.extensions = extensions;
        }
        @Override
        public boolean isSelected(final File file) {
            final String filename = file.getName();
            for (final String ext : extensions) {
                if (StringUtils.endsWithIgnoreCase(filename, ext)) {
                    return true;
                }
            }
            return false;
        }
        @Override
        public boolean shouldEnd() {
            return false;
        }
    }

    public static boolean getPlainLogs() {
        return getBoolean(R.string.pref_plainLogs, false);
    }

    public static boolean getUseNativeUa() {
        return getBoolean(R.string.pref_nativeUa, false);
    }

    public static String getCacheTwitterMessage() {
        return getString(R.string.pref_twitter_cache_message, "I found [NAME] ([URL]).");
    }

    public static String getTrackableTwitterMessage() {
        return getString(R.string.pref_twitter_trackable_message, "I touched [NAME] ([URL]).");
    }

    public static int getLogImageScale() {
        return getInt(R.string.pref_logImageScale, -1);
    }

    public static void setLogImageScale(final int scale) {
        putInt(R.string.pref_logImageScale, scale);
    }

    public static void setExcludeMine(final boolean exclude) {
        putBoolean(R.string.pref_excludemine, exclude);
    }

    static void setLogin(final String username, final String password) {
        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            // erase username and password
            remove(R.string.pref_username);
            remove(R.string.pref_password);
            return;
        }
        // save username and password
        putString(R.string.pref_username, username);
        putString(R.string.pref_password, password);
    }

    public static long getFieldnoteExportDate() {
        return getLong(R.string.pref_fieldNoteExportDate, 0);
    }

    /**
     * remember date of last field note export
     *
     * @param date
     */
    public static void setFieldnoteExportDate(final long date) {
        putLong(R.string.pref_fieldNoteExportDate, date);
    }

    public static boolean isUseNavigationApp(final NavigationAppsEnum navApp) {
        return getBoolean(navApp.preferenceKey, true);
    }

    /**
     * remember the state of the "Upload" checkbox in the field notes export dialog
     *
     * @param upload
     */
    public static void setFieldNoteExportUpload(final boolean upload) {
        putBoolean(R.string.pref_fieldNoteExportUpload, upload);
    }

    public static boolean getFieldNoteExportUpload() {
        return getBoolean(R.string.pref_fieldNoteExportUpload, true);
    }

    /**
     * remember the state of the "Only new" checkbox in the field notes export dialog
     *
     * @param onlyNew
     */
    public static void setFieldNoteExportOnlyNew(final boolean onlyNew) {
        putBoolean(R.string.pref_fieldNoteExportOnlyNew, onlyNew);
    }

    public static boolean getFieldNoteExportOnlyNew() {
        return getBoolean(R.string.pref_fieldNoteExportOnlyNew, false);
    }

    public static String getECIconSet() {
        return getString(R.string.pref_ec_icons, "1");
    }

    /* Store last checksum of changelog for changelog display */
    public static long getLastChangelogChecksum() {
        return getLong(R.string.pref_changelog_last_checksum, 0);
    }

    public static void setLastChangelogChecksum(final long checksum) {
        putLong(R.string.pref_changelog_last_checksum, checksum);
    }

    public static List<String> getLastOpenedCaches() {
        final List<String> history = Arrays.asList(StringUtils.split(getString(R.string.pref_caches_history, StringUtils.EMPTY), HISTORY_SEPARATOR));
        return history.subList(0, Math.min(HISTORY_SIZE, history.size()));
    }

    public static void addCacheToHistory(@NonNull final String geocode) {
        final ArrayList<String> history = new ArrayList<>(getLastOpenedCaches());
        // bring entry to front, if it already existed
        history.remove(geocode);
        history.add(0, geocode);
        putString(R.string.pref_caches_history, StringUtils.join(history, HISTORY_SEPARATOR));
    }

    public static boolean useHardwareAcceleration() {
        return getBoolean(R.string.pref_hardware_acceleration, !HW_ACCEL_DISABLED_BY_DEFAULT);
    }

    public static boolean setUseHardwareAcceleration(final boolean useHardwareAcceleration) {
        return putBoolean(R.string.pref_hardware_acceleration, useHardwareAcceleration);
    }
}
!@#$%
20190527_005314,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_b09244
package cgeo.geocaching.settings;

import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.R;
import cgeo.geocaching.apps.cache.navi.NavigationAppFactory.NavigationAppsEnum;
import cgeo.geocaching.connector.capability.ICredentials;
import cgeo.geocaching.connector.gc.GCConnector;
import cgeo.geocaching.connector.gc.GCConstants;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.LiveMapStrategy.Strategy;
import cgeo.geocaching.enumerations.LogType;
import cgeo.geocaching.list.StoredList;
import cgeo.geocaching.location.Geopoint;
import cgeo.geocaching.maps.CGeoMap.MapMode;
import cgeo.geocaching.maps.MapProviderFactory;
import cgeo.geocaching.maps.google.v1.GoogleMapProvider;
import cgeo.geocaching.maps.interfaces.GeoPointImpl;
import cgeo.geocaching.maps.interfaces.MapProvider;
import cgeo.geocaching.maps.interfaces.MapSource;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider.OfflineMapSource;
import cgeo.geocaching.utils.CryptUtils;
import cgeo.geocaching.utils.FileUtils;
import cgeo.geocaching.utils.FileUtils.FileSelector;
import cgeo.geocaching.utils.Log;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.os.Build;
import android.os.Environment;
import android.preference.PreferenceManager;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;

/**
 * General c:geo preferences/settings set by the user
 */
public class Settings {

    /**
     * On opening a map, we limit the _initial_ zoom. The user can still zoom out afterwards.
     */
    private static final int INITIAL_MAP_ZOOM_LIMIT = 16;
    private static final char HISTORY_SEPARATOR = ',';
    public static final int SHOW_WP_THRESHOLD_DEFAULT = 10;
    public static final int SHOW_WP_THRESHOLD_MAX = 50;
    private static final int MAP_SOURCE_DEFAULT = GoogleMapProvider.GOOGLE_MAP_ID.hashCode();

    public static final boolean HW_ACCEL_DISABLED_BY_DEFAULT =
            Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1 ||
            StringUtils.equals(Build.MODEL, "HTC One X") ||    // HTC One X
            StringUtils.equals(Build.MODEL, "HTC One S") ||    // HTC One S
            StringUtils.equals(Build.MODEL, "GT-I8190")  ||    // Samsung S3 mini
            StringUtils.equals(Build.MODEL, "GT-S6310L") ||    // Samsung Galaxy Young
            StringUtils.equals(Build.MODEL, "GT-P5210")  ||    // Samsung Galaxy Tab 3
            StringUtils.equals(Build.MODEL, "GT-S7580")  ||    // Samsung Galaxy Trend Plus
            StringUtils.equals(Build.MODEL, "GT-I9105P") ||    // Samsung Galaxy SII Plus
            StringUtils.equals(Build.MODEL, "ST25i")     ||    // Sony Xperia U
            StringUtils.equals(Build.MODEL, "bq Aquaris 5");   // bq Aquaris 5

    private final static int unitsMetric = 1;

    // twitter api keys
    private final static @NonNull String keyConsumerPublic = CryptUtils.rot13("ESnsCvAv3kEupF1GCR3jGj");
    private final static @NonNull String keyConsumerSecret = CryptUtils.rot13("7vQWceACV9umEjJucmlpFe9FCMZSeqIqfkQ2BnhV9x");

    public enum CoordInputFormatEnum {
        Plain,
        Deg,
        Min,
        Sec;

        static final int DEFAULT_INT_VALUE = Min.ordinal();

        public static CoordInputFormatEnum fromInt(final int id) {
            final CoordInputFormatEnum[] values = CoordInputFormatEnum.values();
            if (id < 0 || id >= values.length) {
                return Min;
            }
            return values[id];
        }
    }

    private static final SharedPreferences sharedPrefs = PreferenceManager
            .getDefaultSharedPreferences(CgeoApplication.getInstance().getBaseContext());
    static {
        migrateSettings();
        final boolean isDebug = sharedPrefs.getBoolean(getKey(R.string.pref_debug), false);
        Log.setDebug(isDebug);
        CgeoApplication.dumpOnOutOfMemory(isDebug);
    }

    /**
     * Cache the mapsource locally. If that is an offline map source, each request would potentially access the
     * underlying map file, leading to delays.
     */
    private static MapSource mapSource;

    protected Settings() {
        throw new InstantiationError();
    }

    private static void migrateSettings() {
        final int LATEST_PREFERENCES_VERSION = 2;
        final int currentVersion = getInt(R.string.pref_settingsversion, 0);

        // No need to migrate if we are up to date.
        if (currentVersion == LATEST_PREFERENCES_VERSION) {
            return;
        }

        // No need to migrate if we don't have older settings, defaults will be used instead.
        final String preferencesNameV0 = "cgeo.pref";
        final SharedPreferences prefsV0 = CgeoApplication.getInstance().getSharedPreferences(preferencesNameV0, Context.MODE_PRIVATE);
        if (currentVersion == 0 && prefsV0.getAll().isEmpty()) {
            final Editor e = sharedPrefs.edit();
            e.putInt(getKey(R.string.pref_settingsversion), LATEST_PREFERENCES_VERSION);
            e.commit();
            return;
        }

        if (currentVersion < 1) {
            // migrate from non standard file location and integer based boolean types
            final Editor e = sharedPrefs.edit();

            e.putString(getKey(R.string.pref_temp_twitter_token_secret), prefsV0.getString(getKey(R.string.pref_temp_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_temp_twitter_token_public), prefsV0.getString(getKey(R.string.pref_temp_twitter_token_public), null));
            e.putBoolean(getKey(R.string.pref_help_shown), prefsV0.getInt(getKey(R.string.pref_help_shown), 0) != 0);
            e.putFloat(getKey(R.string.pref_anylongitude), prefsV0.getFloat(getKey(R.string.pref_anylongitude), 0));
            e.putFloat(getKey(R.string.pref_anylatitude), prefsV0.getFloat(getKey(R.string.pref_anylatitude), 0));
            e.putBoolean(getKey(R.string.pref_offlinemaps), 0 != prefsV0.getInt(getKey(R.string.pref_offlinemaps), 1));
            e.putBoolean(getKey(R.string.pref_offlinewpmaps), 0 != prefsV0.getInt(getKey(R.string.pref_offlinewpmaps), 0));
            e.putString(getKey(R.string.pref_webDeviceCode), prefsV0.getString(getKey(R.string.pref_webDeviceCode), null));
            e.putString(getKey(R.string.pref_webDeviceName), prefsV0.getString(getKey(R.string.pref_webDeviceName), null));
            e.putBoolean(getKey(R.string.pref_maplive), prefsV0.getInt(getKey(R.string.pref_maplive), 1) != 0);
            e.putInt(getKey(R.string.pref_mapsource), prefsV0.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT));
            e.putBoolean(getKey(R.string.pref_twitter), 0 != prefsV0.getInt(getKey(R.string.pref_twitter), 0));
            e.putBoolean(getKey(R.string.pref_showaddress), 0 != prefsV0.getInt(getKey(R.string.pref_showaddress), 1));
            e.putBoolean(getKey(R.string.pref_showcaptcha), prefsV0.getBoolean(getKey(R.string.pref_showcaptcha), false));
            e.putBoolean(getKey(R.string.pref_maptrail), prefsV0.getInt(getKey(R.string.pref_maptrail), 1) != 0);
            e.putInt(getKey(R.string.pref_lastmapzoom), prefsV0.getInt(getKey(R.string.pref_lastmapzoom), 14));
            e.putBoolean(getKey(R.string.pref_livelist), 0 != prefsV0.getInt(getKey(R.string.pref_livelist), 1));
            e.putBoolean(getKey(R.string.pref_units_imperial), prefsV0.getInt(getKey(R.string.pref_units_imperial), unitsMetric) != unitsMetric);
            e.putBoolean(getKey(R.string.pref_skin), prefsV0.getInt(getKey(R.string.pref_skin), 0) != 0);
            e.putInt(getKey(R.string.pref_lastusedlist), prefsV0.getInt(getKey(R.string.pref_lastusedlist), StoredList.STANDARD_LIST_ID));
            e.putString(getKey(R.string.pref_cachetype), prefsV0.getString(getKey(R.string.pref_cachetype), CacheType.ALL.id));
            e.putString(getKey(R.string.pref_twitter_token_secret), prefsV0.getString(getKey(R.string.pref_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_twitter_token_public), prefsV0.getString(getKey(R.string.pref_twitter_token_public), null));
            e.putInt(getKey(R.string.pref_version), prefsV0.getInt(getKey(R.string.pref_version), 0));
            e.putBoolean(getKey(R.string.pref_autoloaddesc), 0 != prefsV0.getInt(getKey(R.string.pref_autoloaddesc), 1));
            e.putBoolean(getKey(R.string.pref_ratingwanted), prefsV0.getBoolean(getKey(R.string.pref_ratingwanted), true));
            e.putBoolean(getKey(R.string.pref_friendlogswanted), prefsV0.getBoolean(getKey(R.string.pref_friendlogswanted), true));
            e.putBoolean(getKey(R.string.pref_useenglish), prefsV0.getBoolean(getKey(R.string.pref_useenglish), false));
            e.putBoolean(getKey(R.string.pref_usecompass), 0 != prefsV0.getInt(getKey(R.string.pref_usecompass), 1));
            e.putBoolean(getKey(R.string.pref_trackautovisit), prefsV0.getBoolean(getKey(R.string.pref_trackautovisit), false));
            e.putBoolean(getKey(R.string.pref_sigautoinsert), prefsV0.getBoolean(getKey(R.string.pref_sigautoinsert), false));
            e.putBoolean(getKey(R.string.pref_logimages), prefsV0.getBoolean(getKey(R.string.pref_logimages), false));
            e.putBoolean(getKey(R.string.pref_excludedisabled), 0 != prefsV0.getInt(getKey(R.string.pref_excludedisabled), 0));
            e.putBoolean(getKey(R.string.pref_excludemine), 0 != prefsV0.getInt(getKey(R.string.pref_excludemine), 0));
            e.putString(getKey(R.string.pref_mapfile), prefsV0.getString(getKey(R.string.pref_mapfile), null));
            e.putString(getKey(R.string.pref_signature), prefsV0.getString(getKey(R.string.pref_signature), null));
            e.putString(getKey(R.string.pref_pass_vote), prefsV0.getString(getKey(R.string.pref_pass_vote), null));
            e.putString(getKey(R.string.pref_password), prefsV0.getString(getKey(R.string.pref_password), null));
            e.putString(getKey(R.string.pref_username), prefsV0.getString(getKey(R.string.pref_username), null));
            e.putString(getKey(R.string.pref_memberstatus), prefsV0.getString(getKey(R.string.pref_memberstatus), ""));
            e.putInt(getKey(R.string.pref_coordinputformat), prefsV0.getInt(getKey(R.string.pref_coordinputformat), CoordInputFormatEnum.DEFAULT_INT_VALUE));
            e.putBoolean(getKey(R.string.pref_log_offline), prefsV0.getBoolean(getKey(R.string.pref_log_offline), false));
            e.putBoolean(getKey(R.string.pref_choose_list), prefsV0.getBoolean(getKey(R.string.pref_choose_list), true));
            e.putBoolean(getKey(R.string.pref_loaddirectionimg), prefsV0.getBoolean(getKey(R.string.pref_loaddirectionimg), true));
            e.putString(getKey(R.string.pref_gccustomdate), prefsV0.getString(getKey(R.string.pref_gccustomdate), null));
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), prefsV0.getInt(getKey(R.string.pref_showwaypointsthreshold), SHOW_WP_THRESHOLD_DEFAULT));
            e.putString(getKey(R.string.pref_cookiestore), prefsV0.getString(getKey(R.string.pref_cookiestore), null));
            e.putBoolean(getKey(R.string.pref_opendetailslastpage), prefsV0.getBoolean(getKey(R.string.pref_opendetailslastpage), false));
            e.putInt(getKey(R.string.pref_lastdetailspage), prefsV0.getInt(getKey(R.string.pref_lastdetailspage), 1));
            e.putInt(getKey(R.string.pref_defaultNavigationTool), prefsV0.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id));
            e.putInt(getKey(R.string.pref_defaultNavigationTool2), prefsV0.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id));
            e.putInt(getKey(R.string.pref_livemapstrategy), prefsV0.getInt(getKey(R.string.pref_livemapstrategy), Strategy.AUTO.id));
            e.putBoolean(getKey(R.string.pref_debug), prefsV0.getBoolean(getKey(R.string.pref_debug), false));
            e.putInt(getKey(R.string.pref_livemaphintshowcount), prefsV0.getInt(getKey(R.string.pref_livemaphintshowcount), 0));

            e.putInt(getKey(R.string.pref_settingsversion), 1); // mark migrated
            e.commit();
        }

        // changes for new settings dialog
        if (currentVersion < 2) {
            final Editor e = sharedPrefs.edit();

            e.putBoolean(getKey(R.string.pref_units_imperial), useImperialUnits());

            // show waypoints threshold now as a slider
            int wpThreshold = getWayPointsThreshold();
            if (wpThreshold < 0) {
                wpThreshold = 0;
            } else if (wpThreshold > SHOW_WP_THRESHOLD_MAX) {
                wpThreshold = SHOW_WP_THRESHOLD_MAX;
            }
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), wpThreshold);

            // KEY_MAP_SOURCE must be string, because it is the key for a ListPreference now
            final int ms = sharedPrefs.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT);
            e.remove(getKey(R.string.pref_mapsource));
            e.putString(getKey(R.string.pref_mapsource), String.valueOf(ms));

            // navigation tool ids must be string, because ListPreference uses strings as keys
            final int dnt1 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id);
            final int dnt2 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id);
            e.remove(getKey(R.string.pref_defaultNavigationTool));
            e.remove(getKey(R.string.pref_defaultNavigationTool2));
            e.putString(getKey(R.string.pref_defaultNavigationTool), String.valueOf(dnt1));
            e.putString(getKey(R.string.pref_defaultNavigationTool2), String.valueOf(dnt2));

            // defaults for gpx directories
            e.putString(getKey(R.string.pref_gpxImportDir), getGpxImportDir());
            e.putString(getKey(R.string.pref_gpxExportDir), getGpxExportDir());

            e.putInt(getKey(R.string.pref_settingsversion), 2); // mark migrated
            e.commit();
        }
    }

    private static String getKey(final int prefKeyId) {
        return CgeoApplication.getInstance().getString(prefKeyId);
    }

    static String getString(final int prefKeyId, final String defaultValue) {
        return sharedPrefs.getString(getKey(prefKeyId), defaultValue);
    }

    private static int getInt(final int prefKeyId, final int defaultValue) {
        return sharedPrefs.getInt(getKey(prefKeyId), defaultValue);
    }

    private static long getLong(final int prefKeyId, final long defaultValue) {
        return sharedPrefs.getLong(getKey(prefKeyId), defaultValue);
    }

    private static boolean getBoolean(final int prefKeyId, final boolean defaultValue) {
        return sharedPrefs.getBoolean(getKey(prefKeyId), defaultValue);
    }

    private static float getFloat(final int prefKeyId, final float defaultValue) {
        return sharedPrefs.getFloat(getKey(prefKeyId), defaultValue);
    }

    protected static boolean putString(final int prefKeyId, final String value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putString(getKey(prefKeyId), value);
        return edit.commit();
    }

    protected static boolean putBoolean(final int prefKeyId, final boolean value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putBoolean(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putInt(final int prefKeyId, final int value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putInt(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putLong(final int prefKeyId, final long value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putLong(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putFloat(final int prefKeyId, final float value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putFloat(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean remove(final int prefKeyId) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.remove(getKey(prefKeyId));
        return edit.commit();
    }

    private static boolean contains(final int prefKeyId) {
        return sharedPrefs.contains(getKey(prefKeyId));
    }

    public static void setLanguage(final boolean useEnglish) {
        final Configuration config = new Configuration();
        config.locale = useEnglish ? Locale.ENGLISH : Locale.getDefault();
        final Resources resources = CgeoApplication.getInstance().getResources();
        resources.updateConfiguration(config, resources.getDisplayMetrics());
    }

    public static boolean isLogin() {
        final String preUsername = getString(R.string.pref_username, null);
        final String prePassword = getString(R.string.pref_password, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    /**
     * Get login and password information of Geocaching.com.
     *
     * @return a pair either with (login, password) or (empty, empty) if no valid information is stored
     */
    public static ImmutablePair<String, String> getGcCredentials() {
        return getCredentials(GCConnector.getInstance());
    }

    /**
     * Get login and password information.
     *
     * @return a pair either with (login, password) or (empty, empty) if no valid information is stored
     */
    public static ImmutablePair<String, String> getCredentials(final @NonNull ICredentials connector) {
        final String username = getString(connector.getUsernamePreferenceKey(), null);
        final String password = getString(connector.getPasswordPreferenceKey(), null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return new ImmutablePair<>(StringUtils.EMPTY, StringUtils.EMPTY);
        }

        return new ImmutablePair<>(username, password);
    }

    public static String getUsername() {
        return getString(R.string.pref_username, null);
    }

    public static boolean isGCConnectorActive() {
        return getBoolean(R.string.pref_connectorGCActive, true);
    }

    public static boolean isECConnectorActive() {
        return getBoolean(R.string.pref_connectorECActive, false);
    }

    public static boolean isOXConnectorActive() {
        return getBoolean(R.string.pref_connectorOXActive, false);
    }

    public static boolean isGCPremiumMember() {
        // Basic Member, Premium Member, ???
        return GCConstants.MEMBER_STATUS_PM.equalsIgnoreCase(Settings.getGCMemberStatus());
    }

    public static String getGCMemberStatus() {
        return getString(R.string.pref_memberstatus, "");
    }

    public static boolean setGCMemberStatus(final String memberStatus) {
        if (StringUtils.isBlank(memberStatus)) {
            return remove(R.string.pref_memberstatus);
        }
        return putString(R.string.pref_memberstatus, memberStatus);
    }

    public static ImmutablePair<String, String> getTokenPair(final int tokenPublicPrefKey, final int tokenSecretPrefKey) {
        return new ImmutablePair<>(getString(tokenPublicPrefKey, null), getString(tokenSecretPrefKey, null));
    }

    public static void setTokens(final int tokenPublicPrefKey, @Nullable final String tokenPublic, final int tokenSecretPrefKey, @Nullable final String tokenSecret) {
        if (tokenPublic == null) {
            remove(tokenPublicPrefKey);
        } else {
            putString(tokenPublicPrefKey, tokenPublic);
        }
        if (tokenSecret == null) {
            remove(tokenSecretPrefKey);
        } else {
            putString(tokenSecretPrefKey, tokenSecret);
        }
    }

    public static boolean isOCConnectorActive(final int isActivePrefKeyId) {
        return getBoolean(isActivePrefKeyId, false);
    }

    public static boolean hasOCAuthorization(final int tokenPublicPrefKeyId, final int tokenSecretPrefKeyId) {
        return StringUtils.isNotBlank(getString(tokenPublicPrefKeyId, ""))
                && StringUtils.isNotBlank(getString(tokenSecretPrefKeyId, ""));
    }

    public static boolean isGCvoteLogin() {
        final String preUsername = getString(R.string.pref_username, null);
        final String prePassword = getString(R.string.pref_pass_vote, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    public static ImmutablePair<String, String> getGCvoteLogin() {
        final String username = getString(R.string.pref_username, null);
        final String password = getString(R.string.pref_pass_vote, null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return null;
        }

        return new ImmutablePair<>(username, password);
    }

    public static String getSignature() {
        return getString(R.string.pref_signature, StringUtils.EMPTY);
    }

    public static boolean setCookieStore(final String cookies) {
        if (StringUtils.isBlank(cookies)) {
            // erase cookies
            return remove(R.string.pref_cookiestore);
        }
        // save cookies
        return putString(R.string.pref_cookiestore, cookies);
    }

    public static String getCookieStore() {
        return getString(R.string.pref_cookiestore, null);
    }

    public static boolean useGooglePlayServices() {
        return CgeoApplication.getInstance().isGooglePlayServicesAvailable() && getBoolean(R.string.pref_googleplayservices, true);
    }

    public static boolean useLowPowerMode() {
        return getBoolean(R.string.pref_lowpowermode, false);
    }

    /**
     * @param cacheType
     *            The cache type used for future filtering
     */
    public static void setCacheType(final CacheType cacheType) {
        if (cacheType == null) {
            remove(R.string.pref_cachetype);
        } else {
            putString(R.string.pref_cachetype, cacheType.id);
        }
    }

    public static int getLastList() {
        return getInt(R.string.pref_lastusedlist, StoredList.STANDARD_LIST_ID);
    }

    public static void saveLastList(final int listId) {
        putInt(R.string.pref_lastusedlist, listId);
    }

    public static void setWebNameCode(final String name, final String code) {
        putString(R.string.pref_webDeviceName, name);
        putString(R.string.pref_webDeviceCode, code);
    }

    public static MapProvider getMapProvider() {
        return getMapSource().getMapProvider();
    }

    public static String getMapFile() {
        return getString(R.string.pref_mapfile, null);
    }

    public static boolean setMapFile(final String mapFile) {
        final boolean result = putString(R.string.pref_mapfile, mapFile);
        if (mapFile != null) {
            setMapFileDirectory(new File(mapFile).getParent());
        }
        return result;
    }

    public static String getMapFileDirectory() {
        final String mapDir = getString(R.string.pref_mapDirectory, null);
        if (mapDir != null) {
            return mapDir;
        }
        final String mapFile = getMapFile();
        if (mapFile != null) {
            return new File(mapFile).getParent();
        }
        return null;
    }

    public static boolean setMapFileDirectory(final String mapFileDirectory) {
        final boolean result = putString(R.string.pref_mapDirectory, mapFileDirectory);
        MapsforgeMapProvider.getInstance().updateOfflineMaps();
        return result;
    }

    public static boolean isValidMapFile() {
        return isValidMapFile(getMapFile());
    }

    public static boolean isValidMapFile(final String mapFileIn) {
        return MapsforgeMapProvider.isValidMapFile(mapFileIn);
    }

    public static boolean isScaleMapsforgeText() {
        return getBoolean(R.string.pref_mapsforge_scale_text, true);
    }

    public static CoordInputFormatEnum getCoordInputFormat() {
        return CoordInputFormatEnum.fromInt(getInt(R.string.pref_coordinputformat, CoordInputFormatEnum.DEFAULT_INT_VALUE));
    }

    public static void setCoordInputFormat(final CoordInputFormatEnum format) {
        putInt(R.string.pref_coordinputformat, format.ordinal());
    }

    public static boolean getLogOffline() {
        return getBoolean(R.string.pref_log_offline, false);
    }

    public static boolean getChooseList() {
        return getBoolean(R.string.pref_choose_list, false);
    }

    public static boolean getLoadDirImg() {
        return !isGCPremiumMember() && getBoolean(R.string.pref_loaddirectionimg, true);
    }

    public static void setGcCustomDate(final String format) {
        putString(R.string.pref_gccustomdate, format);
    }

    /**
     * @return User selected date format on GC.com
     */
    public static String getGcCustomDate() {
        return getString(R.string.pref_gccustomdate, null);
    }

    public static boolean isExcludeMyCaches() {
        return getBoolean(R.string.pref_excludemine, false);
    }

    public static boolean isUseEnglish() {
        return getBoolean(R.string.pref_useenglish, false);
    }

    public static boolean isShowAddress() {
        return getBoolean(R.string.pref_showaddress, true);
    }

    public static boolean isShowCaptcha() {
        return !isGCPremiumMember() && getBoolean(R.string.pref_showcaptcha, false);
    }

    public static boolean isExcludeDisabledCaches() {
        return getBoolean(R.string.pref_excludedisabled, false);
    }

    public static boolean isStoreOfflineMaps() {
        return getBoolean(R.string.pref_offlinemaps, true);
    }

    public static boolean isStoreOfflineWpMaps() {
        return getBoolean(R.string.pref_offlinewpmaps, false);
    }

    public static boolean isStoreLogImages() {
        return getBoolean(R.string.pref_logimages, false);
    }

    public static boolean isAutoLoadDescription() {
        return getBoolean(R.string.pref_autoloaddesc, true);
    }

    public static boolean isRatingWanted() {
        return getBoolean(R.string.pref_ratingwanted, true);
    }

    public static boolean isFriendLogsWanted() {
        if (!isLogin()) {
            // don't show a friends log if the user is anonymous
            return false;
        }
        return getBoolean(R.string.pref_friendlogswanted, true);
    }

    public static boolean isLiveList() {
        return getBoolean(R.string.pref_livelist, true);
    }

    public static boolean isTrackableAutoVisit() {
        return getBoolean(R.string.pref_trackautovisit, false);
    }

    public static boolean isAutoInsertSignature() {
        return getBoolean(R.string.pref_sigautoinsert, false);
    }

    public static void setUseImperialUnits(final boolean useImperialUnits) {
        putBoolean(R.string.pref_units_imperial, useImperialUnits);
    }

    public static boolean useImperialUnits() {
        return getBoolean(R.string.pref_units_imperial, useImperialUnitsByDefault());
    }

    static boolean useImperialUnitsByDefault() {
        final String countryCode = Locale.getDefault().getCountry();
        return "US".equals(countryCode)  // USA
            || "LR".equals(countryCode)  // Liberia
            || "MM".equals(countryCode); // Burma
    }

    public static boolean isLiveMap() {
        return getBoolean(R.string.pref_maplive, true);
    }

    public static void setLiveMap(final boolean live) {
        putBoolean(R.string.pref_maplive, live);
    }

    public static boolean isMapTrail() {
        return getBoolean(R.string.pref_maptrail, true);
    }

    public static void setMapTrail(final boolean showTrail) {
        putBoolean(R.string.pref_maptrail, showTrail);
    }

    /**
     * Get last used zoom of the internal map. Differentiate between two use cases for a map of multiple caches (e.g.
     * live map) and the map of a single cache (which is often zoomed in more deep).
     *
     * @param mapMode
     * @return
     */
    public static int getMapZoom(final MapMode mapMode) {
        if (mapMode == MapMode.SINGLE || mapMode == MapMode.COORDS) {
            return getCacheZoom();
        }
        return getMapZoom();
    }

    public static void setMapZoom(final MapMode mapMode, final int zoomLevel) {
        if (mapMode == MapMode.SINGLE || mapMode == MapMode.COORDS) {
            setCacheZoom(zoomLevel);
        }
        else {
            setMapZoom(zoomLevel);
        }
    }

    /**
     * @return zoom used for the (live) map
     */
    private static int getMapZoom() {
        return Math.max(getInt(R.string.pref_lastmapzoom, 14), INITIAL_MAP_ZOOM_LIMIT);
    }

    private static void setMapZoom(final int mapZoomLevel) {
        putInt(R.string.pref_lastmapzoom, mapZoomLevel);
    }

    /**
     * @return zoom used for the map of a single cache
     */
    private static int getCacheZoom() {
        return Math.max(getInt(R.string.pref_cache_zoom, 14), INITIAL_MAP_ZOOM_LIMIT);
    }

    private static void setCacheZoom(final int zoomLevel) {
        putInt(R.string.pref_cache_zoom, zoomLevel);
    }

    public static GeoPointImpl getMapCenter() {
        return getMapProvider().getMapItemFactory()
                .getGeoPointBase(new Geopoint(getInt(R.string.pref_lastmaplat, 0) / 1e6,
                        getInt(R.string.pref_lastmaplon, 0) / 1e6));
    }

    public static void setMapCenter(final GeoPointImpl mapViewCenter) {
        putInt(R.string.pref_lastmaplat, mapViewCenter.getLatitudeE6());
        putInt(R.string.pref_lastmaplon, mapViewCenter.getLongitudeE6());
    }

    @NonNull
    public static synchronized MapSource getMapSource() {
        if (mapSource != null) {
            return mapSource;
        }
        final int id = getConvertedMapId();
        mapSource = MapProviderFactory.getMapSource(id);
        if (mapSource != null) {
            // don't use offline maps if the map file is not valid
            if (!(mapSource instanceof OfflineMapSource) || isValidMapFile()) {
                return mapSource;
            }
        }
        // fallback to first available map
        return MapProviderFactory.getDefaultSource();
    }

    private final static int GOOGLEMAP_BASEID = 30;
    private final static int MAP = 1;
    private final static int SATELLITE = 2;

    private final static int MFMAP_BASEID = 40;
    private final static int MAPNIK = 1;
    private final static int CYCLEMAP = 3;
    private final static int OFFLINE = 4;
    private static final int HISTORY_SIZE = 10;

    /**
     * convert old preference ids for maps (based on constant values) into new hash based ids
     *
     * @return
     */
    private static int getConvertedMapId() {
        final int id = Integer.parseInt(getString(R.string.pref_mapsource,
                String.valueOf(MAP_SOURCE_DEFAULT)));
        switch (id) {
            case GOOGLEMAP_BASEID + MAP:
                return GoogleMapProvider.GOOGLE_MAP_ID.hashCode();
            case GOOGLEMAP_BASEID + SATELLITE:
                return GoogleMapProvider.GOOGLE_SATELLITE_ID.hashCode();
            case MFMAP_BASEID + MAPNIK:
                return MapsforgeMapProvider.MAPSFORGE_MAPNIK_ID.hashCode();
            case MFMAP_BASEID + CYCLEMAP:
                return MapsforgeMapProvider.MAPSFORGE_CYCLEMAP_ID.hashCode();
            case MFMAP_BASEID + OFFLINE: {
                final String mapFile = Settings.getMapFile();
                if (StringUtils.isNotEmpty(mapFile)) {
                    return mapFile.hashCode();
                }
                break;
            }
            default:
                break;
        }
        return id;
    }

    public static void setMapSource(final MapSource newMapSource) {
        putString(R.string.pref_mapsource, String.valueOf(newMapSource.getNumericalId()));
        if (newMapSource instanceof OfflineMapSource) {
            setMapFile(((OfflineMapSource) newMapSource).getFileName());
        }
        // cache the value
        mapSource = newMapSource;
    }

    public static void setAnyCoordinates(final Geopoint coords) {
        if (null != coords) {
            putFloat(R.string.pref_anylatitude, (float) coords.getLatitude());
            putFloat(R.string.pref_anylongitude, (float) coords.getLongitude());
        } else {
            remove(R.string.pref_anylatitude);
            remove(R.string.pref_anylongitude);
        }
    }

    public static Geopoint getAnyCoordinates() {
        if (contains(R.string.pref_anylatitude) && contains(R.string.pref_anylongitude)) {
            final float lat = getFloat(R.string.pref_anylatitude, 0);
            final float lon = getFloat(R.string.pref_anylongitude, 0);
            return new Geopoint(lat, lon);
        }
        return null;
    }

    public static boolean isUseCompass() {
        return getBoolean(R.string.pref_usecompass, true);
    }

    public static void setUseCompass(final boolean useCompass) {
        putBoolean(R.string.pref_usecompass, useCompass);
    }

    public static boolean isLightSkin() {
        return getBoolean(R.string.pref_skin, false);
    }

    @NonNull
    public static String getKeyConsumerPublic() {
        return keyConsumerPublic;
    }

    @NonNull
    public static String getKeyConsumerSecret() {
        return keyConsumerSecret;
    }

    public static String getWebDeviceCode() {
        return getString(R.string.pref_webDeviceCode, null);
    }

    public static boolean isRegisteredForSend2cgeo() {
        return getWebDeviceCode() != null;
    }

    public static String getWebDeviceName() {
        return getString(R.string.pref_webDeviceName, android.os.Build.MODEL);
    }

    /**
     * @return The cache type used for filtering or ALL if no filter is active.
     *         Returns never null
     */
    public static CacheType getCacheType() {
        return CacheType.getById(getString(R.string.pref_cachetype, CacheType.ALL.id));
    }

    /**
     * The Threshold for the showing of child waypoints
     */
    public static int getWayPointsThreshold() {
        return getInt(R.string.pref_showwaypointsthreshold, SHOW_WP_THRESHOLD_DEFAULT);
    }

    public static void setShowWaypointsThreshold(final int threshold) {
        putInt(R.string.pref_showwaypointsthreshold, threshold);
    }

    public static boolean isUseTwitter() {
        return getBoolean(R.string.pref_twitter, false);
    }

    public static void setUseTwitter(final boolean useTwitter) {
        putBoolean(R.string.pref_twitter, useTwitter);
    }

    public static boolean isTwitterLoginValid() {
        return !StringUtils.isBlank(getTokenPublic())
                && !StringUtils.isBlank(getTokenSecret());
    }

    public static String getTokenPublic() {
        return getString(R.string.pref_twitter_token_public, null);
    }

    public static String getTokenSecret() {
        return getString(R.string.pref_twitter_token_secret, null);

    }

    public static boolean hasTwitterAuthorization() {
        return StringUtils.isNotBlank(getTokenPublic())
                && StringUtils.isNotBlank(getTokenSecret());
    }

    public static void setTwitterTokens(@Nullable final String tokenPublic,
            @Nullable final String tokenSecret, final boolean enableTwitter) {
        putString(R.string.pref_twitter_token_public, tokenPublic);
        putString(R.string.pref_twitter_token_secret, tokenSecret);
        if (tokenPublic != null) {
            remove(R.string.pref_temp_twitter_token_public);
            remove(R.string.pref_temp_twitter_token_secret);
        }
        setUseTwitter(enableTwitter);
    }

    public static void setTwitterTempTokens(@Nullable final String tokenPublic,
            @Nullable final String tokenSecret) {
        putString(R.string.pref_temp_twitter_token_public, tokenPublic);
        putString(R.string.pref_temp_twitter_token_secret, tokenSecret);
    }

    public static ImmutablePair<String, String> getTempToken() {
        final String tokenPublic = getString(R.string.pref_temp_twitter_token_public, null);
        final String tokenSecret = getString(R.string.pref_temp_twitter_token_secret, null);
        return new ImmutablePair<>(tokenPublic, tokenSecret);
    }

    public static int getVersion() {
        return getInt(R.string.pref_version, 0);
    }

    public static void setVersion(final int version) {
        putInt(R.string.pref_version, version);
    }

    public static boolean isOpenLastDetailsPage() {
        return getBoolean(R.string.pref_opendetailslastpage, false);
    }

    public static int getLastDetailsPage() {
        return getInt(R.string.pref_lastdetailspage, 1);
    }

    public static void setLastDetailsPage(final int index) {
        putInt(R.string.pref_lastdetailspage, index);
    }

    public static int getDefaultNavigationTool() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool,
                String.valueOf(NavigationAppsEnum.COMPASS.id)));
    }

    public static int getDefaultNavigationTool2() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool2,
                String.valueOf(NavigationAppsEnum.INTERNAL_MAP.id)));
    }

    public static Strategy getLiveMapStrategy() {
        return Strategy.getById(getInt(R.string.pref_livemapstrategy, Strategy.AUTO.id));
    }

    public static void setLiveMapStrategy(final Strategy strategy) {
        putInt(R.string.pref_livemapstrategy, strategy.id);
    }

    public static boolean isDebug() {
        return Log.isDebug();
    }

    public static int getLiveMapHintShowCount() {
        return getInt(R.string.pref_livemaphintshowcount, 0);
    }

    public static void setLiveMapHintShowCount(final int showCount) {
        putInt(R.string.pref_livemaphintshowcount, showCount);
    }

    public static boolean isDbOnSDCard() {
        return getBoolean(R.string.pref_dbonsdcard, false);
    }

    public static void setDbOnSDCard(final boolean dbOnSDCard) {
        putBoolean(R.string.pref_dbonsdcard, dbOnSDCard);
    }

    public static String getGpxExportDir() {
        return getString(R.string.pref_gpxExportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static String getGpxImportDir() {
        return getString(R.string.pref_gpxImportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static boolean getShareAfterExport() {
        return getBoolean(R.string.pref_shareafterexport, true);
    }

    public static void setShareAfterExport(final boolean shareAfterExport) {
        putBoolean(R.string.pref_shareafterexport, shareAfterExport);
    }

    public static int getTrackableAction() {
        return getInt(R.string.pref_trackableaction, LogType.RETRIEVED_IT.id);
    }

    public static void setTrackableAction(final int trackableAction) {
        putInt(R.string.pref_trackableaction, trackableAction);
    }

    public static String getCustomRenderThemeBaseFolder() {
        return getString(R.string.pref_renderthemepath, "");
    }

    public static String getCustomRenderThemeFilePath() {
        return getString(R.string.pref_renderthemefile, "");
    }

    public static void setCustomRenderThemeFile(final String customRenderThemeFile) {
        putString(R.string.pref_renderthemefile, customRenderThemeFile);
    }

    public static File[] getMapThemeFiles() {
        final File directory = new File(Settings.getCustomRenderThemeBaseFolder());
        final List<File> result = new ArrayList<>();
        FileUtils.listDir(result, directory, new ExtensionsBasedFileSelector(new String[] { "xml" }), null);

        return result.toArray(new File[result.size()]);
    }

    private static class ExtensionsBasedFileSelector extends FileSelector {
        private final String[] extensions;
        public ExtensionsBasedFileSelector(final String[] extensions) {
            this.extensions = extensions;
        }
        @Override
        public boolean isSelected(final File file) {
            final String filename = file.getName();
            for (final String ext : extensions) {
                if (StringUtils.endsWithIgnoreCase(filename, ext)) {
                    return true;
                }
            }
            return false;
        }
        @Override
        public boolean shouldEnd() {
            return false;
        }
    }

    public static boolean getPlainLogs() {
        return getBoolean(R.string.pref_plainLogs, false);
    }

    public static boolean getUseNativeUa() {
        return getBoolean(R.string.pref_nativeUa, false);
    }

    public static String getCacheTwitterMessage() {
        return getString(R.string.pref_twitter_cache_message, "I found [NAME] ([URL]).");
    }

    public static String getTrackableTwitterMessage() {
        return getString(R.string.pref_twitter_trackable_message, "I touched [NAME] ([URL]).");
    }

    public static int getLogImageScale() {
        return getInt(R.string.pref_logImageScale, -1);
    }

    public static void setLogImageScale(final int scale) {
        putInt(R.string.pref_logImageScale, scale);
    }

    public static void setExcludeMine(final boolean exclude) {
        putBoolean(R.string.pref_excludemine, exclude);
    }

    static void setLogin(final String username, final String password) {
        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            // erase username and password
            remove(R.string.pref_username);
            remove(R.string.pref_password);
            return;
        }
        // save username and password
        putString(R.string.pref_username, username);
        putString(R.string.pref_password, password);
    }

    public static long getFieldnoteExportDate() {
        return getLong(R.string.pref_fieldNoteExportDate, 0);
    }

    /**
     * remember date of last field note export
     *
     * @param date
     */
    public static void setFieldnoteExportDate(final long date) {
        putLong(R.string.pref_fieldNoteExportDate, date);
    }

    public static boolean isUseNavigationApp(final NavigationAppsEnum navApp) {
        return getBoolean(navApp.preferenceKey, true);
    }

    /**
     * remember the state of the "Upload" checkbox in the field notes export dialog
     *
     * @param upload
     */
    public static void setFieldNoteExportUpload(final boolean upload) {
        putBoolean(R.string.pref_fieldNoteExportUpload, upload);
    }

    public static boolean getFieldNoteExportUpload() {
        return getBoolean(R.string.pref_fieldNoteExportUpload, true);
    }

    /**
     * remember the state of the "Only new" checkbox in the field notes export dialog
     *
     * @param onlyNew
     */
    public static void setFieldNoteExportOnlyNew(final boolean onlyNew) {
        putBoolean(R.string.pref_fieldNoteExportOnlyNew, onlyNew);
    }

    public static boolean getFieldNoteExportOnlyNew() {
        return getBoolean(R.string.pref_fieldNoteExportOnlyNew, false);
    }

    public static String getECIconSet() {
        return getString(R.string.pref_ec_icons, "1");
    }

    /* Store last checksum of changelog for changelog display */
    public static long getLastChangelogChecksum() {
        return getLong(R.string.pref_changelog_last_checksum, 0);
    }

    public static void setLastChangelogChecksum(final long checksum) {
        putLong(R.string.pref_changelog_last_checksum, checksum);
    }

    public static List<String> getLastOpenedCaches() {
        final List<String> history = Arrays.asList(StringUtils.split(getString(R.string.pref_caches_history, StringUtils.EMPTY), HISTORY_SEPARATOR));
        return history.subList(0, Math.min(HISTORY_SIZE, history.size()));
    }

    public static void addCacheToHistory(@NonNull final String geocode) {
        final ArrayList<String> history = new ArrayList<>(getLastOpenedCaches());
        // bring entry to front, if it already existed
        history.remove(geocode);
        history.add(0, geocode);
        putString(R.string.pref_caches_history, StringUtils.join(history, HISTORY_SEPARATOR));
    }

    public static boolean useHardwareAcceleration() {
        return getBoolean(R.string.pref_hardware_acceleration, !HW_ACCEL_DISABLED_BY_DEFAULT);
    }

    public static boolean setUseHardwareAcceleration(final boolean useHardwareAcceleration) {
        return putBoolean(R.string.pref_hardware_acceleration, useHardwareAcceleration);
    }

    public static String getLastCacheLog() {
        return getString(R.string.pref_last_cache_log, StringUtils.EMPTY);
    }

    public static void setLastCacheLog(final String log) {
        putString(R.string.pref_last_cache_log, log);
    }

    public static String getLastTrackableLog() {
        return getString(R.string.pref_last_trackable_log, StringUtils.EMPTY);
    }

    public static void setLastTrackableLog(final String log) {
        putString(R.string.pref_last_trackable_log, log);
    }
}
!@#$%
20190527_005314,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_a09244
package cgeo.geocaching.settings;

import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.R;
import cgeo.geocaching.apps.cache.navi.NavigationAppFactory.NavigationAppsEnum;
import cgeo.geocaching.connector.capability.ICredentials;
import cgeo.geocaching.connector.gc.GCConnector;
import cgeo.geocaching.connector.gc.GCConstants;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.LiveMapStrategy.Strategy;
import cgeo.geocaching.enumerations.LogType;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.list.StoredList;
import cgeo.geocaching.maps.MapProviderFactory;
import cgeo.geocaching.maps.google.v1.GoogleMapProvider;
import cgeo.geocaching.maps.interfaces.GeoPointImpl;
import cgeo.geocaching.maps.interfaces.MapProvider;
import cgeo.geocaching.maps.interfaces.MapSource;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider.OfflineMapSource;
import cgeo.geocaching.utils.CryptUtils;
import cgeo.geocaching.utils.FileUtils;
import cgeo.geocaching.utils.FileUtils.FileSelector;
import cgeo.geocaching.utils.Log;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.os.Build;
import android.os.Environment;
import android.preference.PreferenceManager;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;

/**
 * General c:geo preferences/settings set by the user
 */
public class Settings {

    private static final char HISTORY_SEPARATOR = ',';
    public static final int SHOW_WP_THRESHOLD_DEFAULT = 10;
    public static final int SHOW_WP_THRESHOLD_MAX = 50;
    private static final int MAP_SOURCE_DEFAULT = GoogleMapProvider.GOOGLE_MAP_ID.hashCode();

    public static final boolean HW_ACCEL_DISABLED_BY_DEFAULT =
            Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1 ||
            StringUtils.equals(Build.MODEL, "HTC One X") ||    // HTC One X
            StringUtils.equals(Build.MODEL, "HTC One S") ||    // HTC One S
            StringUtils.equals(Build.MODEL, "GT-I8190")  ||    // Samsung S3 mini
            StringUtils.equals(Build.MODEL, "GT-S6310L") ||    // Samsung Galaxy Young
            StringUtils.equals(Build.MODEL, "GT-P5210")  ||    // Samsung Galaxy Tab 3
            StringUtils.equals(Build.MODEL, "GT-S7580")  ||    // Samsung Galaxy Trend Plus
            StringUtils.equals(Build.MODEL, "GT-I9105P") ||    // Samsung Galaxy SII Plus
            StringUtils.equals(Build.MODEL, "ST25i")     ||    // Sony Xperia U
            StringUtils.equals(Build.MODEL, "bq Aquaris 5");   // bq Aquaris 5

    private final static int unitsMetric = 1;

    // twitter api keys
    private final static @NonNull String keyConsumerPublic = CryptUtils.rot13("ESnsCvAv3kEupF1GCR3jGj");
    private final static @NonNull String keyConsumerSecret = CryptUtils.rot13("7vQWceACV9umEjJucmlpFe9FCMZSeqIqfkQ2BnhV9x");

    public enum CoordInputFormatEnum {
        Plain,
        Deg,
        Min,
        Sec;

        static int DEFAULT_INT_VALUE = Min.ordinal();

        public static CoordInputFormatEnum fromInt(final int id) {
            final CoordInputFormatEnum[] values = CoordInputFormatEnum.values();
            if (id < 0 || id >= values.length) {
                return Min;
            }
            return values[id];
        }
    }

    private static final SharedPreferences sharedPrefs = PreferenceManager
            .getDefaultSharedPreferences(CgeoApplication.getInstance().getBaseContext());
    static {
        migrateSettings();
        final boolean isDebug = sharedPrefs.getBoolean(getKey(R.string.pref_debug), false);
        Log.setDebug(isDebug);
        CgeoApplication.dumpOnOutOfMemory(isDebug);
    }

    /**
     * Cache the mapsource locally. If that is an offline map source, each request would potentially access the
     * underlying map file, leading to delays.
     */
    private static MapSource mapSource;

    protected Settings() {
        throw new InstantiationError();
    }

    private static void migrateSettings() {
        // migrate from non standard file location and integer based boolean types
        final int oldVersion = getInt(R.string.pref_settingsversion, 0);
        if (oldVersion < 1) {
            final String oldPreferencesName = "cgeo.pref";
            final SharedPreferences old = CgeoApplication.getInstance().getSharedPreferences(oldPreferencesName, Context.MODE_PRIVATE);
            final Editor e = sharedPrefs.edit();

            e.putString(getKey(R.string.pref_temp_twitter_token_secret), old.getString(getKey(R.string.pref_temp_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_temp_twitter_token_public), old.getString(getKey(R.string.pref_temp_twitter_token_public), null));
            e.putBoolean(getKey(R.string.pref_help_shown), old.getInt(getKey(R.string.pref_help_shown), 0) != 0);
            e.putFloat(getKey(R.string.pref_anylongitude), old.getFloat(getKey(R.string.pref_anylongitude), 0));
            e.putFloat(getKey(R.string.pref_anylatitude), old.getFloat(getKey(R.string.pref_anylatitude), 0));
            e.putBoolean(getKey(R.string.pref_offlinemaps), 0 != old.getInt(getKey(R.string.pref_offlinemaps), 1));
            e.putBoolean(getKey(R.string.pref_offlinewpmaps), 0 != old.getInt(getKey(R.string.pref_offlinewpmaps), 0));
            e.putString(getKey(R.string.pref_webDeviceCode), old.getString(getKey(R.string.pref_webDeviceCode), null));
            e.putString(getKey(R.string.pref_webDeviceName), old.getString(getKey(R.string.pref_webDeviceName), null));
            e.putBoolean(getKey(R.string.pref_maplive), old.getInt(getKey(R.string.pref_maplive), 1) != 0);
            e.putInt(getKey(R.string.pref_mapsource), old.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT));
            e.putBoolean(getKey(R.string.pref_twitter), 0 != old.getInt(getKey(R.string.pref_twitter), 0));
            e.putBoolean(getKey(R.string.pref_showaddress), 0 != old.getInt(getKey(R.string.pref_showaddress), 1));
            e.putBoolean(getKey(R.string.pref_showcaptcha), old.getBoolean(getKey(R.string.pref_showcaptcha), false));
            e.putBoolean(getKey(R.string.pref_maptrail), old.getInt(getKey(R.string.pref_maptrail), 1) != 0);
            e.putInt(getKey(R.string.pref_lastmapzoom), old.getInt(getKey(R.string.pref_lastmapzoom), 14));
            e.putBoolean(getKey(R.string.pref_livelist), 0 != old.getInt(getKey(R.string.pref_livelist), 1));
            e.putBoolean(getKey(R.string.pref_units), old.getInt(getKey(R.string.pref_units), unitsMetric) == unitsMetric);
            e.putBoolean(getKey(R.string.pref_skin), old.getInt(getKey(R.string.pref_skin), 0) != 0);
            e.putInt(getKey(R.string.pref_lastusedlist), old.getInt(getKey(R.string.pref_lastusedlist), StoredList.STANDARD_LIST_ID));
            e.putString(getKey(R.string.pref_cachetype), old.getString(getKey(R.string.pref_cachetype), CacheType.ALL.id));
            e.putString(getKey(R.string.pref_twitter_token_secret), old.getString(getKey(R.string.pref_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_twitter_token_public), old.getString(getKey(R.string.pref_twitter_token_public), null));
            e.putInt(getKey(R.string.pref_version), old.getInt(getKey(R.string.pref_version), 0));
            e.putBoolean(getKey(R.string.pref_autoloaddesc), 0 != old.getInt(getKey(R.string.pref_autoloaddesc), 1));
            e.putBoolean(getKey(R.string.pref_ratingwanted), old.getBoolean(getKey(R.string.pref_ratingwanted), true));
            e.putBoolean(getKey(R.string.pref_friendlogswanted), old.getBoolean(getKey(R.string.pref_friendlogswanted), true));
            e.putBoolean(getKey(R.string.pref_useenglish), old.getBoolean(getKey(R.string.pref_useenglish), false));
            e.putBoolean(getKey(R.string.pref_usecompass), 0 != old.getInt(getKey(R.string.pref_usecompass), 1));
            e.putBoolean(getKey(R.string.pref_trackautovisit), old.getBoolean(getKey(R.string.pref_trackautovisit), false));
            e.putBoolean(getKey(R.string.pref_sigautoinsert), old.getBoolean(getKey(R.string.pref_sigautoinsert), false));
            e.putBoolean(getKey(R.string.pref_logimages), old.getBoolean(getKey(R.string.pref_logimages), false));
            e.putBoolean(getKey(R.string.pref_excludedisabled), 0 != old.getInt(getKey(R.string.pref_excludedisabled), 0));
            e.putBoolean(getKey(R.string.pref_excludemine), 0 != old.getInt(getKey(R.string.pref_excludemine), 0));
            e.putString(getKey(R.string.pref_mapfile), old.getString(getKey(R.string.pref_mapfile), null));
            e.putString(getKey(R.string.pref_signature), old.getString(getKey(R.string.pref_signature), null));
            e.putString(getKey(R.string.pref_pass_vote), old.getString(getKey(R.string.pref_pass_vote), null));
            e.putString(getKey(R.string.pref_password), old.getString(getKey(R.string.pref_password), null));
            e.putString(getKey(R.string.pref_username), old.getString(getKey(R.string.pref_username), null));
            e.putString(getKey(R.string.pref_memberstatus), old.getString(getKey(R.string.pref_memberstatus), ""));
            e.putInt(getKey(R.string.pref_coordinputformat), old.getInt(getKey(R.string.pref_coordinputformat), CoordInputFormatEnum.DEFAULT_INT_VALUE));
            e.putBoolean(getKey(R.string.pref_log_offline), old.getBoolean(getKey(R.string.pref_log_offline), false));
            e.putBoolean(getKey(R.string.pref_choose_list), old.getBoolean(getKey(R.string.pref_choose_list), true));
            e.putBoolean(getKey(R.string.pref_loaddirectionimg), old.getBoolean(getKey(R.string.pref_loaddirectionimg), true));
            e.putString(getKey(R.string.pref_gccustomdate), old.getString(getKey(R.string.pref_gccustomdate), null));
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), old.getInt(getKey(R.string.pref_showwaypointsthreshold), SHOW_WP_THRESHOLD_DEFAULT));
            e.putString(getKey(R.string.pref_cookiestore), old.getString(getKey(R.string.pref_cookiestore), null));
            e.putBoolean(getKey(R.string.pref_opendetailslastpage), old.getBoolean(getKey(R.string.pref_opendetailslastpage), false));
            e.putInt(getKey(R.string.pref_lastdetailspage), old.getInt(getKey(R.string.pref_lastdetailspage), 1));
            e.putInt(getKey(R.string.pref_defaultNavigationTool), old.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id));
            e.putInt(getKey(R.string.pref_defaultNavigationTool2), old.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id));
            e.putInt(getKey(R.string.pref_livemapstrategy), old.getInt(getKey(R.string.pref_livemapstrategy), Strategy.AUTO.id));
            e.putBoolean(getKey(R.string.pref_debug), old.getBoolean(getKey(R.string.pref_debug), false));
            e.putBoolean(getKey(R.string.pref_hidelivemaphint), old.getInt(getKey(R.string.pref_hidelivemaphint), 0) != 0);
            e.putInt(getKey(R.string.pref_livemaphintshowcount), old.getInt(getKey(R.string.pref_livemaphintshowcount), 0));

            e.putInt(getKey(R.string.pref_settingsversion), 1); // mark migrated
            e.commit();
        }

        // changes for new settings dialog
        if (oldVersion < 2) {
            final Editor e = sharedPrefs.edit();

            e.putBoolean(getKey(R.string.pref_units), !isUseImperialUnits());

            // show waypoints threshold now as a slider
            int wpThreshold = getWayPointsThreshold();
            if (wpThreshold < 0) {
                wpThreshold = 0;
            } else if (wpThreshold > SHOW_WP_THRESHOLD_MAX) {
                wpThreshold = SHOW_WP_THRESHOLD_MAX;
            }
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), wpThreshold);

            // KEY_MAP_SOURCE must be string, because it is the key for a ListPreference now
            final int ms = sharedPrefs.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT);
            e.remove(getKey(R.string.pref_mapsource));
            e.putString(getKey(R.string.pref_mapsource), String.valueOf(ms));

            // navigation tool ids must be string, because ListPreference uses strings as keys
            final int dnt1 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id);
            final int dnt2 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id);
            e.remove(getKey(R.string.pref_defaultNavigationTool));
            e.remove(getKey(R.string.pref_defaultNavigationTool2));
            e.putString(getKey(R.string.pref_defaultNavigationTool), String.valueOf(dnt1));
            e.putString(getKey(R.string.pref_defaultNavigationTool2), String.valueOf(dnt2));

            // defaults for gpx directories
            e.putString(getKey(R.string.pref_gpxImportDir), getGpxImportDir());
            e.putString(getKey(R.string.pref_gpxExportDir), getGpxExportDir());

            e.putInt(getKey(R.string.pref_settingsversion), 2); // mark migrated
            e.commit();
        }
    }

    private static String getKey(final int prefKeyId) {
        return CgeoApplication.getInstance().getString(prefKeyId);
    }

    static String getString(final int prefKeyId, final String defaultValue) {
        return sharedPrefs.getString(getKey(prefKeyId), defaultValue);
    }

    private static int getInt(final int prefKeyId, final int defaultValue) {
        return sharedPrefs.getInt(getKey(prefKeyId), defaultValue);
    }

    private static long getLong(final int prefKeyId, final long defaultValue) {
        return sharedPrefs.getLong(getKey(prefKeyId), defaultValue);
    }

    private static boolean getBoolean(final int prefKeyId, final boolean defaultValue) {
        return sharedPrefs.getBoolean(getKey(prefKeyId), defaultValue);
    }

    private static float getFloat(final int prefKeyId, final float defaultValue) {
        return sharedPrefs.getFloat(getKey(prefKeyId), defaultValue);
    }

    protected static boolean putString(final int prefKeyId, final String value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putString(getKey(prefKeyId), value);
        return edit.commit();
    }

    protected static boolean putBoolean(final int prefKeyId, final boolean value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putBoolean(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putInt(final int prefKeyId, final int value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putInt(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putLong(final int prefKeyId, final long value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putLong(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putFloat(final int prefKeyId, final float value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putFloat(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean remove(final int prefKeyId) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.remove(getKey(prefKeyId));
        return edit.commit();
    }

    private static boolean contains(final int prefKeyId) {
        return sharedPrefs.contains(getKey(prefKeyId));
    }

    public static void setLanguage(final boolean useEnglish) {
        final Configuration config = new Configuration();
        config.locale = useEnglish ? Locale.ENGLISH : Locale.getDefault();
        final Resources resources = CgeoApplication.getInstance().getResources();
        resources.updateConfiguration(config, resources.getDisplayMetrics());
    }

    public static boolean isLogin() {
        final String preUsername = getString(R.string.pref_username, null);
        final String prePassword = getString(R.string.pref_password, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    /**
     * Get login and password information of Geocaching.com.
     *
     * @return a pair either with (login, password) or (empty, empty) if no valid information is stored
     */
    public static ImmutablePair<String, String> getGcCredentials() {
        return getCredentials(GCConnector.getInstance());
    }

    /**
     * Get login and password information.
     *
     * @return a pair either with (login, password) or (empty, empty) if no valid information is stored
     */
    public static ImmutablePair<String, String> getCredentials(final @NonNull ICredentials connector) {
        final String username = getString(connector.getUsernamePreferenceKey(), null);
        final String password = getString(connector.getPasswordPreferenceKey(), null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return new ImmutablePair<>(StringUtils.EMPTY, StringUtils.EMPTY);
        }

        return new ImmutablePair<>(username, password);
    }

    public static String getUsername() {
        return getString(R.string.pref_username, null);
    }

    public static boolean isGCConnectorActive() {
        return getBoolean(R.string.pref_connectorGCActive, true);
    }

    public static boolean isECConnectorActive() {
        return getBoolean(R.string.pref_connectorECActive, false);
    }

    public static boolean isOXConnectorActive() {
        return getBoolean(R.string.pref_connectorOXActive, false);
    }

    public static boolean isGCPremiumMember() {
        // Basic Member, Premium Member, ???
        return GCConstants.MEMBER_STATUS_PM.equalsIgnoreCase(Settings.getGCMemberStatus());
    }

    public static String getGCMemberStatus() {
        return getString(R.string.pref_memberstatus, "");
    }

    public static boolean setGCMemberStatus(final String memberStatus) {
        if (StringUtils.isBlank(memberStatus)) {
            return remove(R.string.pref_memberstatus);
        }
        return putString(R.string.pref_memberstatus, memberStatus);
    }

    public static ImmutablePair<String, String> getTokenPair(final int tokenPublicPrefKey, final int tokenSecretPrefKey) {
        return new ImmutablePair<>(getString(tokenPublicPrefKey, null), getString(tokenSecretPrefKey, null));
    }

    public static void setTokens(final int tokenPublicPrefKey, @Nullable final String tokenPublic, final int tokenSecretPrefKey, @Nullable final String tokenSecret) {
        if (tokenPublic == null) {
            remove(tokenPublicPrefKey);
        } else {
            putString(tokenPublicPrefKey, tokenPublic);
        }
        if (tokenSecret == null) {
            remove(tokenSecretPrefKey);
        } else {
            putString(tokenSecretPrefKey, tokenSecret);
        }
    }

    public static boolean isOCConnectorActive(final int isActivePrefKeyId) {
        return getBoolean(isActivePrefKeyId, false);
    }

    public static boolean hasOCAuthorization(final int tokenPublicPrefKeyId, final int tokenSecretPrefKeyId) {
        return StringUtils.isNotBlank(getString(tokenPublicPrefKeyId, ""))
                && StringUtils.isNotBlank(getString(tokenSecretPrefKeyId, ""));
    }

    public static boolean isGCvoteLogin() {
        final String preUsername = getString(R.string.pref_username, null);
        final String prePassword = getString(R.string.pref_pass_vote, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    public static ImmutablePair<String, String> getGCvoteLogin() {
        final String username = getString(R.string.pref_username, null);
        final String password = getString(R.string.pref_pass_vote, null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return null;
        }

        return new ImmutablePair<>(username, password);
    }

    public static String getSignature() {
        return getString(R.string.pref_signature, StringUtils.EMPTY);
    }

    public static boolean setCookieStore(final String cookies) {
        if (StringUtils.isBlank(cookies)) {
            // erase cookies
            return remove(R.string.pref_cookiestore);
        }
        // save cookies
        return putString(R.string.pref_cookiestore, cookies);
    }

    public static String getCookieStore() {
        return getString(R.string.pref_cookiestore, null);
    }

    /**
     * @param cacheType
     *            The cache type used for future filtering
     */
    public static void setCacheType(final CacheType cacheType) {
        if (cacheType == null) {
            remove(R.string.pref_cachetype);
        } else {
            putString(R.string.pref_cachetype, cacheType.id);
        }
    }

    public static int getLastList() {
        return getInt(R.string.pref_lastusedlist, StoredList.STANDARD_LIST_ID);
    }

    public static void saveLastList(final int listId) {
        putInt(R.string.pref_lastusedlist, listId);
    }

    public static void setWebNameCode(final String name, final String code) {
        putString(R.string.pref_webDeviceName, name);
        putString(R.string.pref_webDeviceCode, code);
    }

    public static MapProvider getMapProvider() {
        return getMapSource().getMapProvider();
    }

    public static String getMapFile() {
        return getString(R.string.pref_mapfile, null);
    }

    public static boolean setMapFile(final String mapFile) {
        final boolean result = putString(R.string.pref_mapfile, mapFile);
        if (mapFile != null) {
            setMapFileDirectory(new File(mapFile).getParent());
        }
        return result;
    }

    public static String getMapFileDirectory() {
        final String mapDir = getString(R.string.pref_mapDirectory, null);
        if (mapDir != null) {
            return mapDir;
        }
        final String mapFile = getMapFile();
        if (mapFile != null) {
            return new File(mapFile).getParent();
        }
        return null;
    }

    public static boolean setMapFileDirectory(final String mapFileDirectory) {
        final boolean result = putString(R.string.pref_mapDirectory, mapFileDirectory);
        MapsforgeMapProvider.getInstance().updateOfflineMaps();
        return result;
    }

    public static boolean isValidMapFile() {
        return isValidMapFile(getMapFile());
    }

    public static boolean isValidMapFile(final String mapFileIn) {
        return MapsforgeMapProvider.isValidMapFile(mapFileIn);
    }

    public static boolean isScaleMapsforgeText() {
        return getBoolean(R.string.pref_mapsforge_scale_text, true);
    }

    public static CoordInputFormatEnum getCoordInputFormat() {
        return CoordInputFormatEnum.fromInt(getInt(R.string.pref_coordinputformat, CoordInputFormatEnum.DEFAULT_INT_VALUE));
    }

    public static void setCoordInputFormat(final CoordInputFormatEnum format) {
        putInt(R.string.pref_coordinputformat, format.ordinal());
    }

    public static boolean getLogOffline() {
        return getBoolean(R.string.pref_log_offline, false);
    }

    public static boolean getChooseList() {
        return getBoolean(R.string.pref_choose_list, false);
    }

    public static boolean getLoadDirImg() {
        return !isGCPremiumMember() && getBoolean(R.string.pref_loaddirectionimg, true);
    }

    public static void setGcCustomDate(final String format) {
        putString(R.string.pref_gccustomdate, format);
    }

    /**
     * @return User selected date format on GC.com
     */
    public static String getGcCustomDate() {
        return getString(R.string.pref_gccustomdate, null);
    }

    public static boolean isExcludeMyCaches() {
        return getBoolean(R.string.pref_excludemine, false);
    }

    public static boolean isUseEnglish() {
        return getBoolean(R.string.pref_useenglish, false);
    }

    public static boolean isShowAddress() {
        return getBoolean(R.string.pref_showaddress, true);
    }

    public static boolean isShowCaptcha() {
        return !isGCPremiumMember() && getBoolean(R.string.pref_showcaptcha, false);
    }

    public static boolean isExcludeDisabledCaches() {
        return getBoolean(R.string.pref_excludedisabled, false);
    }

    public static boolean isStoreOfflineMaps() {
        return getBoolean(R.string.pref_offlinemaps, true);
    }

    public static boolean isStoreOfflineWpMaps() {
        return getBoolean(R.string.pref_offlinewpmaps, false);
    }

    public static boolean isStoreLogImages() {
        return getBoolean(R.string.pref_logimages, false);
    }

    public static boolean isAutoLoadDescription() {
        return getBoolean(R.string.pref_autoloaddesc, true);
    }

    public static boolean isRatingWanted() {
        return getBoolean(R.string.pref_ratingwanted, true);
    }

    public static boolean isFriendLogsWanted() {
        if (!isLogin()) {
            // don't show a friends log if the user is anonymous
            return false;
        }
        return getBoolean(R.string.pref_friendlogswanted, true);
    }

    public static boolean isLiveList() {
        return getBoolean(R.string.pref_livelist, true);
    }

    public static boolean isTrackableAutoVisit() {
        return getBoolean(R.string.pref_trackautovisit, false);
    }

    public static boolean isAutoInsertSignature() {
        return getBoolean(R.string.pref_sigautoinsert, false);
    }

    public static boolean isUseImperialUnits() {
        return getBoolean(R.string.pref_units, getImperialUnitsDefault());
    }

    static boolean getImperialUnitsDefault() {
        final String countryCode = Locale.getDefault().getCountry();
        return "US".equals(countryCode)  // USA
            || "LR".equals(countryCode)  // Liberia
            || "MM".equals(countryCode); // Burma
    }

    public static boolean isLiveMap() {
        return getBoolean(R.string.pref_maplive, true);
    }

    public static void setLiveMap(final boolean live) {
        putBoolean(R.string.pref_maplive, live);
    }

    public static boolean isMapTrail() {
        return getBoolean(R.string.pref_maptrail, true);
    }

    public static void setMapTrail(final boolean showTrail) {
        putBoolean(R.string.pref_maptrail, showTrail);
    }

    public static int getMapZoom() {
        return getInt(R.string.pref_lastmapzoom, 14);
    }

    public static void setMapZoom(final int mapZoomLevel) {
        putInt(R.string.pref_lastmapzoom, mapZoomLevel);
    }

    public static GeoPointImpl getMapCenter() {
        return getMapProvider().getMapItemFactory()
                .getGeoPointBase(new Geopoint(getInt(R.string.pref_lastmaplat, 0) / 1e6,
                        getInt(R.string.pref_lastmaplon, 0) / 1e6));
    }

    public static void setMapCenter(final GeoPointImpl mapViewCenter) {
        putInt(R.string.pref_lastmaplat, mapViewCenter.getLatitudeE6());
        putInt(R.string.pref_lastmaplon, mapViewCenter.getLongitudeE6());
    }

    @NonNull
    public static synchronized MapSource getMapSource() {
        if (mapSource != null) {
            return mapSource;
        }
        final int id = getConvertedMapId();
        mapSource = MapProviderFactory.getMapSource(id);
        if (mapSource != null) {
            // don't use offline maps if the map file is not valid
            if ((!(mapSource instanceof OfflineMapSource)) || (isValidMapFile())) {
                return mapSource;
            }
        }
        // fallback to first available map
        return MapProviderFactory.getDefaultSource();
    }

    private final static int GOOGLEMAP_BASEID = 30;
    private final static int MAP = 1;
    private final static int SATELLITE = 2;

    private final static int MFMAP_BASEID = 40;
    private final static int MAPNIK = 1;
    private final static int CYCLEMAP = 3;
    private final static int OFFLINE = 4;
    private static final int HISTORY_SIZE = 10;

    /**
     * convert old preference ids for maps (based on constant values) into new hash based ids
     *
     * @return
     */
    private static int getConvertedMapId() {
        final int id = Integer.parseInt(getString(R.string.pref_mapsource,
                String.valueOf(MAP_SOURCE_DEFAULT)));
        switch (id) {
            case GOOGLEMAP_BASEID + MAP:
                return GoogleMapProvider.GOOGLE_MAP_ID.hashCode();
            case GOOGLEMAP_BASEID + SATELLITE:
                return GoogleMapProvider.GOOGLE_SATELLITE_ID.hashCode();
            case MFMAP_BASEID + MAPNIK:
                return MapsforgeMapProvider.MAPSFORGE_MAPNIK_ID.hashCode();
            case MFMAP_BASEID + CYCLEMAP:
                return MapsforgeMapProvider.MAPSFORGE_CYCLEMAP_ID.hashCode();
            case MFMAP_BASEID + OFFLINE: {
                final String mapFile = Settings.getMapFile();
                if (StringUtils.isNotEmpty(mapFile)) {
                    return mapFile.hashCode();
                }
                break;
            }
            default:
                break;
        }
        return id;
    }

    public static void setMapSource(final MapSource newMapSource) {
        putString(R.string.pref_mapsource, String.valueOf(newMapSource.getNumericalId()));
        if (newMapSource instanceof OfflineMapSource) {
            setMapFile(((OfflineMapSource) newMapSource).getFileName());
        }
        // cache the value
        mapSource = newMapSource;
    }

    public static void setAnyCoordinates(final Geopoint coords) {
        if (null != coords) {
            putFloat(R.string.pref_anylatitude, (float) coords.getLatitude());
            putFloat(R.string.pref_anylongitude, (float) coords.getLongitude());
        } else {
            remove(R.string.pref_anylatitude);
            remove(R.string.pref_anylongitude);
        }
    }

    public static Geopoint getAnyCoordinates() {
        if (contains(R.string.pref_anylatitude) && contains(R.string.pref_anylongitude)) {
            final float lat = getFloat(R.string.pref_anylatitude, 0);
            final float lon = getFloat(R.string.pref_anylongitude, 0);
            return new Geopoint(lat, lon);
        }
        return null;
    }

    public static boolean isUseCompass() {
        return getBoolean(R.string.pref_usecompass, true);
    }

    public static void setUseCompass(final boolean useCompass) {
        putBoolean(R.string.pref_usecompass, useCompass);
    }

    public static boolean isLightSkin() {
        return getBoolean(R.string.pref_skin, false);
    }

    @NonNull
    public static String getKeyConsumerPublic() {
        return keyConsumerPublic;
    }

    @NonNull
    public static String getKeyConsumerSecret() {
        return keyConsumerSecret;
    }

    public static String getWebDeviceCode() {
        return getString(R.string.pref_webDeviceCode, null);
    }

    public static boolean isRegisteredForSend2cgeo() {
        return getWebDeviceCode() != null;
    }

    public static String getWebDeviceName() {
        return getString(R.string.pref_webDeviceName, android.os.Build.MODEL);
    }

    /**
     * @return The cache type used for filtering or ALL if no filter is active.
     *         Returns never null
     */
    public static CacheType getCacheType() {
        return CacheType.getById(getString(R.string.pref_cachetype, CacheType.ALL.id));
    }

    /**
     * The Threshold for the showing of child waypoints
     */
    public static int getWayPointsThreshold() {
        return getInt(R.string.pref_showwaypointsthreshold, SHOW_WP_THRESHOLD_DEFAULT);
    }

    public static void setShowWaypointsThreshold(final int threshold) {
        putInt(R.string.pref_showwaypointsthreshold, threshold);
    }

    public static boolean isUseTwitter() {
        return getBoolean(R.string.pref_twitter, false);
    }

    public static void setUseTwitter(final boolean useTwitter) {
        putBoolean(R.string.pref_twitter, useTwitter);
    }

    public static boolean isTwitterLoginValid() {
        return !StringUtils.isBlank(getTokenPublic())
                && !StringUtils.isBlank(getTokenSecret());
    }

    public static String getTokenPublic() {
        return getString(R.string.pref_twitter_token_public, null);
    }

    public static String getTokenSecret() {
        return getString(R.string.pref_twitter_token_secret, null);

    }

    public static boolean hasTwitterAuthorization() {
        return StringUtils.isNotBlank(getTokenPublic())
                && StringUtils.isNotBlank(getTokenSecret());
    }

    public static void setTwitterTokens(@Nullable final String tokenPublic,
            @Nullable final String tokenSecret, final boolean enableTwitter) {
        putString(R.string.pref_twitter_token_public, tokenPublic);
        putString(R.string.pref_twitter_token_secret, tokenSecret);
        if (tokenPublic != null) {
            remove(R.string.pref_temp_twitter_token_public);
            remove(R.string.pref_temp_twitter_token_secret);
        }
        setUseTwitter(enableTwitter);
    }

    public static void setTwitterTempTokens(@Nullable final String tokenPublic,
            @Nullable final String tokenSecret) {
        putString(R.string.pref_temp_twitter_token_public, tokenPublic);
        putString(R.string.pref_temp_twitter_token_secret, tokenSecret);
    }

    public static ImmutablePair<String, String> getTempToken() {
        final String tokenPublic = getString(R.string.pref_temp_twitter_token_public, null);
        final String tokenSecret = getString(R.string.pref_temp_twitter_token_secret, null);
        return new ImmutablePair<>(tokenPublic, tokenSecret);
    }

    public static int getVersion() {
        return getInt(R.string.pref_version, 0);
    }

    public static void setVersion(final int version) {
        putInt(R.string.pref_version, version);
    }

    public static boolean isOpenLastDetailsPage() {
        return getBoolean(R.string.pref_opendetailslastpage, false);
    }

    public static int getLastDetailsPage() {
        return getInt(R.string.pref_lastdetailspage, 1);
    }

    public static void setLastDetailsPage(final int index) {
        putInt(R.string.pref_lastdetailspage, index);
    }

    public static int getDefaultNavigationTool() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool,
                String.valueOf(NavigationAppsEnum.COMPASS.id)));
    }

    public static int getDefaultNavigationTool2() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool2,
                String.valueOf(NavigationAppsEnum.INTERNAL_MAP.id)));
    }

    public static Strategy getLiveMapStrategy() {
        return Strategy.getById(getInt(R.string.pref_livemapstrategy, Strategy.AUTO.id));
    }

    public static void setLiveMapStrategy(final Strategy strategy) {
        putInt(R.string.pref_livemapstrategy, strategy.id);
    }

    public static boolean isDebug() {
        return Log.isDebug();
    }

    public static boolean getHideLiveMapHint() {
        return getBoolean(R.string.pref_hidelivemaphint, false);
    }

    public static void setHideLiveHint(final boolean hide) {
        putBoolean(R.string.pref_hidelivemaphint, hide);
    }

    public static int getLiveMapHintShowCount() {
        return getInt(R.string.pref_livemaphintshowcount, 0);
    }

    public static void setLiveMapHintShowCount(final int showCount) {
        putInt(R.string.pref_livemaphintshowcount, showCount);
    }

    public static boolean isDbOnSDCard() {
        return getBoolean(R.string.pref_dbonsdcard, false);
    }

    public static void setDbOnSDCard(final boolean dbOnSDCard) {
        putBoolean(R.string.pref_dbonsdcard, dbOnSDCard);
    }

    public static String getGpxExportDir() {
        return getString(R.string.pref_gpxExportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static String getGpxImportDir() {
        return getString(R.string.pref_gpxImportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static boolean getShareAfterExport() {
        return getBoolean(R.string.pref_shareafterexport, true);
    }

    public static void setShareAfterExport(final boolean shareAfterExport) {
        putBoolean(R.string.pref_shareafterexport, shareAfterExport);
    }

    public static int getTrackableAction() {
        return getInt(R.string.pref_trackableaction, LogType.RETRIEVED_IT.id);
    }

    public static void setTrackableAction(final int trackableAction) {
        putInt(R.string.pref_trackableaction, trackableAction);
    }

    public static String getCustomRenderThemeBaseFolder() {
        return getString(R.string.pref_renderthemepath, "");
    }

    public static String getCustomRenderThemeFilePath() {
        return getString(R.string.pref_renderthemefile, "");
    }

    public static void setCustomRenderThemeFile(final String customRenderThemeFile) {
        putString(R.string.pref_renderthemefile, customRenderThemeFile);
    }

    public static File[] getMapThemeFiles() {
        final File directory = new File(Settings.getCustomRenderThemeBaseFolder());
        final List<File> result = new ArrayList<>();
        FileUtils.listDir(result, directory, new ExtensionsBasedFileSelector(new String[] { "xml" }), null);

        return result.toArray(new File[result.size()]);
    }

    private static class ExtensionsBasedFileSelector extends FileSelector {
        private final String[] extensions;
        public ExtensionsBasedFileSelector(final String[] extensions) {
            this.extensions = extensions;
        }
        @Override
        public boolean isSelected(final File file) {
            final String filename = file.getName();
            for (final String ext : extensions) {
                if (StringUtils.endsWithIgnoreCase(filename, ext)) {
                    return true;
                }
            }
            return false;
        }
        @Override
        public boolean shouldEnd() {
            return false;
        }
    }

    public static boolean getPlainLogs() {
        return getBoolean(R.string.pref_plainLogs, false);
    }

    public static boolean getUseNativeUa() {
        return getBoolean(R.string.pref_nativeUa, false);
    }

    public static String getCacheTwitterMessage() {
        return getString(R.string.pref_twitter_cache_message, "I found [NAME] ([URL]).");
    }

    public static String getTrackableTwitterMessage() {
        return getString(R.string.pref_twitter_trackable_message, "I touched [NAME] ([URL]).");
    }

    public static int getLogImageScale() {
        return getInt(R.string.pref_logImageScale, -1);
    }

    public static void setLogImageScale(final int scale) {
        putInt(R.string.pref_logImageScale, scale);
    }

    public static void setExcludeMine(final boolean exclude) {
        putBoolean(R.string.pref_excludemine, exclude);
    }

    static void setLogin(final String username, final String password) {
        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            // erase username and password
            remove(R.string.pref_username);
            remove(R.string.pref_password);
            return;
        }
        // save username and password
        putString(R.string.pref_username, username);
        putString(R.string.pref_password, password);
    }

    public static long getFieldnoteExportDate() {
        return getLong(R.string.pref_fieldNoteExportDate, 0);
    }

    /**
     * remember date of last field note export
     *
     * @param date
     */
    public static void setFieldnoteExportDate(final long date) {
        putLong(R.string.pref_fieldNoteExportDate, date);
    }

    public static boolean isUseNavigationApp(final NavigationAppsEnum navApp) {
        return getBoolean(navApp.preferenceKey, true);
    }

    /**
     * remember the state of the "Upload" checkbox in the field notes export dialog
     *
     * @param upload
     */
    public static void setFieldNoteExportUpload(final boolean upload) {
        putBoolean(R.string.pref_fieldNoteExportUpload, upload);
    }

    public static boolean getFieldNoteExportUpload() {
        return getBoolean(R.string.pref_fieldNoteExportUpload, true);
    }

    /**
     * remember the state of the "Only new" checkbox in the field notes export dialog
     *
     * @param onlyNew
     */
    public static void setFieldNoteExportOnlyNew(final boolean onlyNew) {
        putBoolean(R.string.pref_fieldNoteExportOnlyNew, onlyNew);
    }

    public static boolean getFieldNoteExportOnlyNew() {
        return getBoolean(R.string.pref_fieldNoteExportOnlyNew, false);
    }

    public static String getECIconSet() {
        return getString(R.string.pref_ec_icons, "1");
    }

    /* Store last checksum of changelog for changelog display */
    public static long getLastChangelogChecksum() {
        return getLong(R.string.pref_changelog_last_checksum, 0);
    }

    public static void setLastChangelogChecksum(final long checksum) {
        putLong(R.string.pref_changelog_last_checksum, checksum);
    }

    public static List<String> getLastOpenedCaches() {
        final List<String> history = Arrays.asList(StringUtils.split(getString(R.string.pref_caches_history, StringUtils.EMPTY), HISTORY_SEPARATOR));
        return history.subList(0, Math.min(HISTORY_SIZE, history.size()));
    }

    public static void addCacheToHistory(@NonNull final String geocode) {
        final ArrayList<String> history = new ArrayList<>(getLastOpenedCaches());
        // bring entry to front, if it already existed
        history.remove(geocode);
        history.add(0, geocode);
        putString(R.string.pref_caches_history, StringUtils.join(history, HISTORY_SEPARATOR));
    }

    public static boolean useHardwareAcceleration() {
        return getBoolean(R.string.pref_hardware_acceleration, !HW_ACCEL_DISABLED_BY_DEFAULT);
    }

    public static boolean setUseHardwareAcceleration(final boolean useHardwareAcceleration) {
        return putBoolean(R.string.pref_hardware_acceleration, useHardwareAcceleration);
    }
}
!@#$%
20190527_005314,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_c09244
package cgeo.geocaching.settings;

import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.R;
import cgeo.geocaching.apps.cache.navi.NavigationAppFactory.NavigationAppsEnum;
import cgeo.geocaching.connector.capability.ICredentials;
import cgeo.geocaching.connector.gc.GCConnector;
import cgeo.geocaching.connector.gc.GCConstants;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.LiveMapStrategy.Strategy;
import cgeo.geocaching.enumerations.LogType;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.list.StoredList;
import cgeo.geocaching.maps.MapProviderFactory;
import cgeo.geocaching.maps.google.v1.GoogleMapProvider;
import cgeo.geocaching.maps.interfaces.GeoPointImpl;
import cgeo.geocaching.maps.interfaces.MapProvider;
import cgeo.geocaching.maps.interfaces.MapSource;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider.OfflineMapSource;
import cgeo.geocaching.utils.CryptUtils;
import cgeo.geocaching.utils.FileUtils;
import cgeo.geocaching.utils.FileUtils.FileSelector;
import cgeo.geocaching.utils.Log;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.os.Build;
import android.os.Environment;
import android.preference.PreferenceManager;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;

/**
 * General c:geo preferences/settings set by the user
 */
public class Settings {

    private static final char HISTORY_SEPARATOR = ',';
    public static final int SHOW_WP_THRESHOLD_DEFAULT = 10;
    public static final int SHOW_WP_THRESHOLD_MAX = 50;
    private static final int MAP_SOURCE_DEFAULT = GoogleMapProvider.GOOGLE_MAP_ID.hashCode();

    public static final boolean HW_ACCEL_DISABLED_BY_DEFAULT =
            Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1 ||
            StringUtils.equals(Build.MODEL, "HTC One X") ||    // HTC One X
            StringUtils.equals(Build.MODEL, "HTC One S") ||    // HTC One S
            StringUtils.equals(Build.MODEL, "GT-I8190")  ||    // Samsung S3 mini
            StringUtils.equals(Build.MODEL, "GT-S6310L") ||    // Samsung Galaxy Young
            StringUtils.equals(Build.MODEL, "GT-P5210")  ||    // Samsung Galaxy Tab 3
            StringUtils.equals(Build.MODEL, "GT-S7580")  ||    // Samsung Galaxy Trend Plus
            StringUtils.equals(Build.MODEL, "GT-I9105P") ||    // Samsung Galaxy SII Plus
            StringUtils.equals(Build.MODEL, "ST25i")     ||    // Sony Xperia U
            StringUtils.equals(Build.MODEL, "bq Aquaris 5");   // bq Aquaris 5

    private final static int unitsMetric = 1;

    // twitter api keys
    private final static @NonNull String keyConsumerPublic = CryptUtils.rot13("ESnsCvAv3kEupF1GCR3jGj");
    private final static @NonNull String keyConsumerSecret = CryptUtils.rot13("7vQWceACV9umEjJucmlpFe9FCMZSeqIqfkQ2BnhV9x");

    public enum CoordInputFormatEnum {
        Plain,
        Deg,
        Min,
        Sec;

        static int DEFAULT_INT_VALUE = Min.ordinal();

        public static CoordInputFormatEnum fromInt(final int id) {
            final CoordInputFormatEnum[] values = CoordInputFormatEnum.values();
            if (id < 0 || id >= values.length) {
                return Min;
            }
            return values[id];
        }
    }

    private static final SharedPreferences sharedPrefs = PreferenceManager
            .getDefaultSharedPreferences(CgeoApplication.getInstance().getBaseContext());
    static {
        migrateSettings();
        final boolean isDebug = sharedPrefs.getBoolean(getKey(R.string.pref_debug), false);
        Log.setDebug(isDebug);
        CgeoApplication.dumpOnOutOfMemory(isDebug);
    }

    /**
     * Cache the mapsource locally. If that is an offline map source, each request would potentially access the
     * underlying map file, leading to delays.
     */
    private static MapSource mapSource;

    protected Settings() {
        throw new InstantiationError();
    }

    private static void migrateSettings() {
        // migrate from non standard file location and integer based boolean types
        final int oldVersion = getInt(R.string.pref_settingsversion, 0);
        if (oldVersion < 1) {
            final String oldPreferencesName = "cgeo.pref";
            final SharedPreferences old = CgeoApplication.getInstance().getSharedPreferences(oldPreferencesName, Context.MODE_PRIVATE);
            final Editor e = sharedPrefs.edit();

            e.putString(getKey(R.string.pref_temp_twitter_token_secret), old.getString(getKey(R.string.pref_temp_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_temp_twitter_token_public), old.getString(getKey(R.string.pref_temp_twitter_token_public), null));
            e.putBoolean(getKey(R.string.pref_help_shown), old.getInt(getKey(R.string.pref_help_shown), 0) != 0);
            e.putFloat(getKey(R.string.pref_anylongitude), old.getFloat(getKey(R.string.pref_anylongitude), 0));
            e.putFloat(getKey(R.string.pref_anylatitude), old.getFloat(getKey(R.string.pref_anylatitude), 0));
            e.putBoolean(getKey(R.string.pref_offlinemaps), 0 != old.getInt(getKey(R.string.pref_offlinemaps), 1));
            e.putBoolean(getKey(R.string.pref_offlinewpmaps), 0 != old.getInt(getKey(R.string.pref_offlinewpmaps), 0));
            e.putString(getKey(R.string.pref_webDeviceCode), old.getString(getKey(R.string.pref_webDeviceCode), null));
            e.putString(getKey(R.string.pref_webDeviceName), old.getString(getKey(R.string.pref_webDeviceName), null));
            e.putBoolean(getKey(R.string.pref_maplive), old.getInt(getKey(R.string.pref_maplive), 1) != 0);
            e.putInt(getKey(R.string.pref_mapsource), old.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT));
            e.putBoolean(getKey(R.string.pref_twitter), 0 != old.getInt(getKey(R.string.pref_twitter), 0));
            e.putBoolean(getKey(R.string.pref_showaddress), 0 != old.getInt(getKey(R.string.pref_showaddress), 1));
            e.putBoolean(getKey(R.string.pref_showcaptcha), old.getBoolean(getKey(R.string.pref_showcaptcha), false));
            e.putBoolean(getKey(R.string.pref_maptrail), old.getInt(getKey(R.string.pref_maptrail), 1) != 0);
            e.putInt(getKey(R.string.pref_lastmapzoom), old.getInt(getKey(R.string.pref_lastmapzoom), 14));
            e.putBoolean(getKey(R.string.pref_livelist), 0 != old.getInt(getKey(R.string.pref_livelist), 1));
            e.putBoolean(getKey(R.string.pref_units), old.getInt(getKey(R.string.pref_units), unitsMetric) == unitsMetric);
            e.putBoolean(getKey(R.string.pref_skin), old.getInt(getKey(R.string.pref_skin), 0) != 0);
            e.putInt(getKey(R.string.pref_lastusedlist), old.getInt(getKey(R.string.pref_lastusedlist), StoredList.STANDARD_LIST_ID));
            e.putString(getKey(R.string.pref_cachetype), old.getString(getKey(R.string.pref_cachetype), CacheType.ALL.id));
            e.putString(getKey(R.string.pref_twitter_token_secret), old.getString(getKey(R.string.pref_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_twitter_token_public), old.getString(getKey(R.string.pref_twitter_token_public), null));
            e.putInt(getKey(R.string.pref_version), old.getInt(getKey(R.string.pref_version), 0));
            e.putBoolean(getKey(R.string.pref_autoloaddesc), 0 != old.getInt(getKey(R.string.pref_autoloaddesc), 1));
            e.putBoolean(getKey(R.string.pref_ratingwanted), old.getBoolean(getKey(R.string.pref_ratingwanted), true));
            e.putBoolean(getKey(R.string.pref_friendlogswanted), old.getBoolean(getKey(R.string.pref_friendlogswanted), true));
            e.putBoolean(getKey(R.string.pref_useenglish), old.getBoolean(getKey(R.string.pref_useenglish), false));
            e.putBoolean(getKey(R.string.pref_usecompass), 0 != old.getInt(getKey(R.string.pref_usecompass), 1));
            e.putBoolean(getKey(R.string.pref_trackautovisit), old.getBoolean(getKey(R.string.pref_trackautovisit), false));
            e.putBoolean(getKey(R.string.pref_sigautoinsert), old.getBoolean(getKey(R.string.pref_sigautoinsert), false));
            e.putBoolean(getKey(R.string.pref_logimages), old.getBoolean(getKey(R.string.pref_logimages), false));
            e.putBoolean(getKey(R.string.pref_excludedisabled), 0 != old.getInt(getKey(R.string.pref_excludedisabled), 0));
            e.putBoolean(getKey(R.string.pref_excludemine), 0 != old.getInt(getKey(R.string.pref_excludemine), 0));
            e.putString(getKey(R.string.pref_mapfile), old.getString(getKey(R.string.pref_mapfile), null));
            e.putString(getKey(R.string.pref_signature), old.getString(getKey(R.string.pref_signature), null));
            e.putString(getKey(R.string.pref_pass_vote), old.getString(getKey(R.string.pref_pass_vote), null));
            e.putString(getKey(R.string.pref_password), old.getString(getKey(R.string.pref_password), null));
            e.putString(getKey(R.string.pref_username), old.getString(getKey(R.string.pref_username), null));
            e.putString(getKey(R.string.pref_memberstatus), old.getString(getKey(R.string.pref_memberstatus), ""));
            e.putInt(getKey(R.string.pref_coordinputformat), old.getInt(getKey(R.string.pref_coordinputformat), CoordInputFormatEnum.DEFAULT_INT_VALUE));
            e.putBoolean(getKey(R.string.pref_log_offline), old.getBoolean(getKey(R.string.pref_log_offline), false));
            e.putBoolean(getKey(R.string.pref_choose_list), old.getBoolean(getKey(R.string.pref_choose_list), true));
            e.putBoolean(getKey(R.string.pref_loaddirectionimg), old.getBoolean(getKey(R.string.pref_loaddirectionimg), true));
            e.putString(getKey(R.string.pref_gccustomdate), old.getString(getKey(R.string.pref_gccustomdate), GCConstants.DEFAULT_GC_DATE));
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), old.getInt(getKey(R.string.pref_showwaypointsthreshold), SHOW_WP_THRESHOLD_DEFAULT));
            e.putString(getKey(R.string.pref_cookiestore), old.getString(getKey(R.string.pref_cookiestore), null));
            e.putBoolean(getKey(R.string.pref_opendetailslastpage), old.getBoolean(getKey(R.string.pref_opendetailslastpage), false));
            e.putInt(getKey(R.string.pref_lastdetailspage), old.getInt(getKey(R.string.pref_lastdetailspage), 1));
            e.putInt(getKey(R.string.pref_defaultNavigationTool), old.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id));
            e.putInt(getKey(R.string.pref_defaultNavigationTool2), old.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id));
            e.putInt(getKey(R.string.pref_livemapstrategy), old.getInt(getKey(R.string.pref_livemapstrategy), Strategy.AUTO.id));
            e.putBoolean(getKey(R.string.pref_debug), old.getBoolean(getKey(R.string.pref_debug), false));
            e.putBoolean(getKey(R.string.pref_hidelivemaphint), old.getInt(getKey(R.string.pref_hidelivemaphint), 0) != 0);
            e.putInt(getKey(R.string.pref_livemaphintshowcount), old.getInt(getKey(R.string.pref_livemaphintshowcount), 0));

            e.putInt(getKey(R.string.pref_settingsversion), 1); // mark migrated
            e.commit();
        }

        // changes for new settings dialog
        if (oldVersion < 2) {
            final Editor e = sharedPrefs.edit();

            e.putBoolean(getKey(R.string.pref_units), !isUseImperialUnits());

            // show waypoints threshold now as a slider
            int wpThreshold = getWayPointsThreshold();
            if (wpThreshold < 0) {
                wpThreshold = 0;
            } else if (wpThreshold > SHOW_WP_THRESHOLD_MAX) {
                wpThreshold = SHOW_WP_THRESHOLD_MAX;
            }
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), wpThreshold);

            // KEY_MAP_SOURCE must be string, because it is the key for a ListPreference now
            final int ms = sharedPrefs.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT);
            e.remove(getKey(R.string.pref_mapsource));
            e.putString(getKey(R.string.pref_mapsource), String.valueOf(ms));

            // navigation tool ids must be string, because ListPreference uses strings as keys
            final int dnt1 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id);
            final int dnt2 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id);
            e.remove(getKey(R.string.pref_defaultNavigationTool));
            e.remove(getKey(R.string.pref_defaultNavigationTool2));
            e.putString(getKey(R.string.pref_defaultNavigationTool), String.valueOf(dnt1));
            e.putString(getKey(R.string.pref_defaultNavigationTool2), String.valueOf(dnt2));

            // defaults for gpx directories
            e.putString(getKey(R.string.pref_gpxImportDir), getGpxImportDir());
            e.putString(getKey(R.string.pref_gpxExportDir), getGpxExportDir());

            e.putInt(getKey(R.string.pref_settingsversion), 2); // mark migrated
            e.commit();
        }
    }

    private static String getKey(final int prefKeyId) {
        return CgeoApplication.getInstance().getString(prefKeyId);
    }

    static String getString(final int prefKeyId, final String defaultValue) {
        return sharedPrefs.getString(getKey(prefKeyId), defaultValue);
    }

    private static int getInt(final int prefKeyId, final int defaultValue) {
        return sharedPrefs.getInt(getKey(prefKeyId), defaultValue);
    }

    private static long getLong(final int prefKeyId, final long defaultValue) {
        return sharedPrefs.getLong(getKey(prefKeyId), defaultValue);
    }

    private static boolean getBoolean(final int prefKeyId, final boolean defaultValue) {
        return sharedPrefs.getBoolean(getKey(prefKeyId), defaultValue);
    }

    private static float getFloat(final int prefKeyId, final float defaultValue) {
        return sharedPrefs.getFloat(getKey(prefKeyId), defaultValue);
    }

    protected static boolean putString(final int prefKeyId, final String value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putString(getKey(prefKeyId), value);
        return edit.commit();
    }

    protected static boolean putBoolean(final int prefKeyId, final boolean value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putBoolean(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putInt(final int prefKeyId, final int value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putInt(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putLong(final int prefKeyId, final long value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putLong(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putFloat(final int prefKeyId, final float value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putFloat(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean remove(final int prefKeyId) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.remove(getKey(prefKeyId));
        return edit.commit();
    }

    private static boolean contains(final int prefKeyId) {
        return sharedPrefs.contains(getKey(prefKeyId));
    }

    public static void setLanguage(final boolean useEnglish) {
        final Configuration config = new Configuration();
        config.locale = useEnglish ? Locale.ENGLISH : Locale.getDefault();
        final Resources resources = CgeoApplication.getInstance().getResources();
        resources.updateConfiguration(config, resources.getDisplayMetrics());
    }

    public static boolean isLogin() {
        final String preUsername = getString(R.string.pref_username, null);
        final String prePassword = getString(R.string.pref_password, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    /**
     * Get login and password information of Geocaching.com.
     *
     * @return a pair either with (login, password) or (empty, empty) if no valid information is stored
     */
    public static ImmutablePair<String, String> getGcCredentials() {
        return getCredentials(GCConnector.getInstance());
    }

    /**
     * Get login and password information.
     *
     * @return a pair either with (login, password) or (empty, empty) if no valid information is stored
     */
    public static ImmutablePair<String, String> getCredentials(final @NonNull ICredentials connector) {
        final String username = getString(connector.getUsernamePreferenceKey(), null);
        final String password = getString(connector.getPasswordPreferenceKey(), null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return new ImmutablePair<>(StringUtils.EMPTY, StringUtils.EMPTY);
        }

        return new ImmutablePair<>(username, password);
    }

    public static String getUsername() {
        return getString(R.string.pref_username, null);
    }

    public static boolean isGCConnectorActive() {
        return getBoolean(R.string.pref_connectorGCActive, true);
    }

    public static boolean isECConnectorActive() {
        return getBoolean(R.string.pref_connectorECActive, false);
    }

    public static boolean isOXConnectorActive() {
        return getBoolean(R.string.pref_connectorOXActive, false);
    }

    public static boolean isGCPremiumMember() {
        // Basic Member, Premium Member, ???
        return GCConstants.MEMBER_STATUS_PM.equalsIgnoreCase(Settings.getGCMemberStatus());
    }

    public static String getGCMemberStatus() {
        return getString(R.string.pref_memberstatus, "");
    }

    public static boolean setGCMemberStatus(final String memberStatus) {
        if (StringUtils.isBlank(memberStatus)) {
            return remove(R.string.pref_memberstatus);
        }
        return putString(R.string.pref_memberstatus, memberStatus);
    }

    public static ImmutablePair<String, String> getTokenPair(final int tokenPublicPrefKey, final int tokenSecretPrefKey) {
        return new ImmutablePair<>(getString(tokenPublicPrefKey, null), getString(tokenSecretPrefKey, null));
    }

    public static void setTokens(final int tokenPublicPrefKey, @Nullable final String tokenPublic, final int tokenSecretPrefKey, @Nullable final String tokenSecret) {
        if (tokenPublic == null) {
            remove(tokenPublicPrefKey);
        } else {
            putString(tokenPublicPrefKey, tokenPublic);
        }
        if (tokenSecret == null) {
            remove(tokenSecretPrefKey);
        } else {
            putString(tokenSecretPrefKey, tokenSecret);
        }
    }

    public static boolean isOCConnectorActive(final int isActivePrefKeyId) {
        return getBoolean(isActivePrefKeyId, false);
    }

    public static boolean hasOCAuthorization(final int tokenPublicPrefKeyId, final int tokenSecretPrefKeyId) {
        return StringUtils.isNotBlank(getString(tokenPublicPrefKeyId, ""))
                && StringUtils.isNotBlank(getString(tokenSecretPrefKeyId, ""));
    }

    public static boolean isGCvoteLogin() {
        final String preUsername = getString(R.string.pref_username, null);
        final String prePassword = getString(R.string.pref_pass_vote, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    public static ImmutablePair<String, String> getGCvoteLogin() {
        final String username = getString(R.string.pref_username, null);
        final String password = getString(R.string.pref_pass_vote, null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return null;
        }

        return new ImmutablePair<>(username, password);
    }

    public static String getSignature() {
        return getString(R.string.pref_signature, StringUtils.EMPTY);
    }

    public static boolean setCookieStore(final String cookies) {
        if (StringUtils.isBlank(cookies)) {
            // erase cookies
            return remove(R.string.pref_cookiestore);
        }
        // save cookies
        return putString(R.string.pref_cookiestore, cookies);
    }

    public static String getCookieStore() {
        return getString(R.string.pref_cookiestore, null);
    }

    /**
     * @param cacheType
     *            The cache type used for future filtering
     */
    public static void setCacheType(final CacheType cacheType) {
        if (cacheType == null) {
            remove(R.string.pref_cachetype);
        } else {
            putString(R.string.pref_cachetype, cacheType.id);
        }
    }

    public static int getLastList() {
        return getInt(R.string.pref_lastusedlist, StoredList.STANDARD_LIST_ID);
    }

    public static void saveLastList(final int listId) {
        putInt(R.string.pref_lastusedlist, listId);
    }

    public static void setWebNameCode(final String name, final String code) {
        putString(R.string.pref_webDeviceName, name);
        putString(R.string.pref_webDeviceCode, code);
    }

    public static MapProvider getMapProvider() {
        return getMapSource().getMapProvider();
    }

    public static String getMapFile() {
        return getString(R.string.pref_mapfile, null);
    }

    public static boolean setMapFile(final String mapFile) {
        final boolean result = putString(R.string.pref_mapfile, mapFile);
        if (mapFile != null) {
            setMapFileDirectory(new File(mapFile).getParent());
        }
        return result;
    }

    public static String getMapFileDirectory() {
        final String mapDir = getString(R.string.pref_mapDirectory, null);
        if (mapDir != null) {
            return mapDir;
        }
        final String mapFile = getMapFile();
        if (mapFile != null) {
            return new File(mapFile).getParent();
        }
        return null;
    }

    public static boolean setMapFileDirectory(final String mapFileDirectory) {
        final boolean result = putString(R.string.pref_mapDirectory, mapFileDirectory);
        MapsforgeMapProvider.getInstance().updateOfflineMaps();
        return result;
    }

    public static boolean isValidMapFile() {
        return isValidMapFile(getMapFile());
    }

    public static boolean isValidMapFile(final String mapFileIn) {
        return MapsforgeMapProvider.isValidMapFile(mapFileIn);
    }

    public static boolean isScaleMapsforgeText() {
        return getBoolean(R.string.pref_mapsforge_scale_text, true);
    }

    public static CoordInputFormatEnum getCoordInputFormat() {
        return CoordInputFormatEnum.fromInt(getInt(R.string.pref_coordinputformat, CoordInputFormatEnum.DEFAULT_INT_VALUE));
    }

    public static void setCoordInputFormat(final CoordInputFormatEnum format) {
        putInt(R.string.pref_coordinputformat, format.ordinal());
    }

    public static boolean getLogOffline() {
        return getBoolean(R.string.pref_log_offline, false);
    }

    public static boolean getChooseList() {
        return getBoolean(R.string.pref_choose_list, false);
    }

    public static boolean getLoadDirImg() {
        return !isGCPremiumMember() && getBoolean(R.string.pref_loaddirectionimg, true);
    }

    public static void setGcCustomDate(final String format) {
        putString(R.string.pref_gccustomdate, format);
    }

    /**
     * @return User selected date format on GC.com
     */
    public static String getGcCustomDate() {
        // We might have some users whose stored value is null, which is invalid. In this case, we use the default.
        return StringUtils.defaultString(getString(R.string.pref_gccustomdate, GCConstants.DEFAULT_GC_DATE),
                GCConstants.DEFAULT_GC_DATE);
    }

    public static boolean isExcludeMyCaches() {
        return getBoolean(R.string.pref_excludemine, false);
    }

    public static boolean isUseEnglish() {
        return getBoolean(R.string.pref_useenglish, false);
    }

    public static boolean isShowAddress() {
        return getBoolean(R.string.pref_showaddress, true);
    }

    public static boolean isShowCaptcha() {
        return !isGCPremiumMember() && getBoolean(R.string.pref_showcaptcha, false);
    }

    public static boolean isExcludeDisabledCaches() {
        return getBoolean(R.string.pref_excludedisabled, false);
    }

    public static boolean isStoreOfflineMaps() {
        return getBoolean(R.string.pref_offlinemaps, true);
    }

    public static boolean isStoreOfflineWpMaps() {
        return getBoolean(R.string.pref_offlinewpmaps, false);
    }

    public static boolean isStoreLogImages() {
        return getBoolean(R.string.pref_logimages, false);
    }

    public static boolean isAutoLoadDescription() {
        return getBoolean(R.string.pref_autoloaddesc, true);
    }

    public static boolean isRatingWanted() {
        return getBoolean(R.string.pref_ratingwanted, true);
    }

    public static boolean isFriendLogsWanted() {
        if (!isLogin()) {
            // don't show a friends log if the user is anonymous
            return false;
        }
        return getBoolean(R.string.pref_friendlogswanted, true);
    }

    public static boolean isLiveList() {
        return getBoolean(R.string.pref_livelist, true);
    }

    public static boolean isTrackableAutoVisit() {
        return getBoolean(R.string.pref_trackautovisit, false);
    }

    public static boolean isAutoInsertSignature() {
        return getBoolean(R.string.pref_sigautoinsert, false);
    }

    public static boolean isUseImperialUnits() {
        return getBoolean(R.string.pref_units, getImperialUnitsDefault());
    }

    static boolean getImperialUnitsDefault() {
        final String countryCode = Locale.getDefault().getCountry();
        return "US".equals(countryCode)  // USA
            || "LR".equals(countryCode)  // Liberia
            || "MM".equals(countryCode); // Burma
    }

    public static boolean isLiveMap() {
        return getBoolean(R.string.pref_maplive, true);
    }

    public static void setLiveMap(final boolean live) {
        putBoolean(R.string.pref_maplive, live);
    }

    public static boolean isMapTrail() {
        return getBoolean(R.string.pref_maptrail, true);
    }

    public static void setMapTrail(final boolean showTrail) {
        putBoolean(R.string.pref_maptrail, showTrail);
    }

    public static int getMapZoom() {
        return getInt(R.string.pref_lastmapzoom, 14);
    }

    public static void setMapZoom(final int mapZoomLevel) {
        putInt(R.string.pref_lastmapzoom, mapZoomLevel);
    }

    public static GeoPointImpl getMapCenter() {
        return getMapProvider().getMapItemFactory()
                .getGeoPointBase(new Geopoint(getInt(R.string.pref_lastmaplat, 0) / 1e6,
                        getInt(R.string.pref_lastmaplon, 0) / 1e6));
    }

    public static void setMapCenter(final GeoPointImpl mapViewCenter) {
        putInt(R.string.pref_lastmaplat, mapViewCenter.getLatitudeE6());
        putInt(R.string.pref_lastmaplon, mapViewCenter.getLongitudeE6());
    }

    @NonNull
    public static synchronized MapSource getMapSource() {
        if (mapSource != null) {
            return mapSource;
        }
        final int id = getConvertedMapId();
        mapSource = MapProviderFactory.getMapSource(id);
        if (mapSource != null) {
            // don't use offline maps if the map file is not valid
            if ((!(mapSource instanceof OfflineMapSource)) || (isValidMapFile())) {
                return mapSource;
            }
        }
        // fallback to first available map
        return MapProviderFactory.getDefaultSource();
    }

    private final static int GOOGLEMAP_BASEID = 30;
    private final static int MAP = 1;
    private final static int SATELLITE = 2;

    private final static int MFMAP_BASEID = 40;
    private final static int MAPNIK = 1;
    private final static int CYCLEMAP = 3;
    private final static int OFFLINE = 4;
    private static final int HISTORY_SIZE = 10;

    /**
     * convert old preference ids for maps (based on constant values) into new hash based ids
     *
     * @return
     */
    private static int getConvertedMapId() {
        final int id = Integer.parseInt(getString(R.string.pref_mapsource,
                String.valueOf(MAP_SOURCE_DEFAULT)));
        switch (id) {
            case GOOGLEMAP_BASEID + MAP:
                return GoogleMapProvider.GOOGLE_MAP_ID.hashCode();
            case GOOGLEMAP_BASEID + SATELLITE:
                return GoogleMapProvider.GOOGLE_SATELLITE_ID.hashCode();
            case MFMAP_BASEID + MAPNIK:
                return MapsforgeMapProvider.MAPSFORGE_MAPNIK_ID.hashCode();
            case MFMAP_BASEID + CYCLEMAP:
                return MapsforgeMapProvider.MAPSFORGE_CYCLEMAP_ID.hashCode();
            case MFMAP_BASEID + OFFLINE: {
                final String mapFile = Settings.getMapFile();
                if (StringUtils.isNotEmpty(mapFile)) {
                    return mapFile.hashCode();
                }
                break;
            }
            default:
                break;
        }
        return id;
    }

    public static void setMapSource(final MapSource newMapSource) {
        putString(R.string.pref_mapsource, String.valueOf(newMapSource.getNumericalId()));
        if (newMapSource instanceof OfflineMapSource) {
            setMapFile(((OfflineMapSource) newMapSource).getFileName());
        }
        // cache the value
        mapSource = newMapSource;
    }

    public static void setAnyCoordinates(final Geopoint coords) {
        if (null != coords) {
            putFloat(R.string.pref_anylatitude, (float) coords.getLatitude());
            putFloat(R.string.pref_anylongitude, (float) coords.getLongitude());
        } else {
            remove(R.string.pref_anylatitude);
            remove(R.string.pref_anylongitude);
        }
    }

    public static Geopoint getAnyCoordinates() {
        if (contains(R.string.pref_anylatitude) && contains(R.string.pref_anylongitude)) {
            final float lat = getFloat(R.string.pref_anylatitude, 0);
            final float lon = getFloat(R.string.pref_anylongitude, 0);
            return new Geopoint(lat, lon);
        }
        return null;
    }

    public static boolean isUseCompass() {
        return getBoolean(R.string.pref_usecompass, true);
    }

    public static void setUseCompass(final boolean useCompass) {
        putBoolean(R.string.pref_usecompass, useCompass);
    }

    public static boolean isLightSkin() {
        return getBoolean(R.string.pref_skin, false);
    }

    @NonNull
    public static String getKeyConsumerPublic() {
        return keyConsumerPublic;
    }

    @NonNull
    public static String getKeyConsumerSecret() {
        return keyConsumerSecret;
    }

    public static String getWebDeviceCode() {
        return getString(R.string.pref_webDeviceCode, null);
    }

    public static boolean isRegisteredForSend2cgeo() {
        return getWebDeviceCode() != null;
    }

    public static String getWebDeviceName() {
        return getString(R.string.pref_webDeviceName, android.os.Build.MODEL);
    }

    /**
     * @return The cache type used for filtering or ALL if no filter is active.
     *         Returns never null
     */
    public static CacheType getCacheType() {
        return CacheType.getById(getString(R.string.pref_cachetype, CacheType.ALL.id));
    }

    /**
     * The Threshold for the showing of child waypoints
     */
    public static int getWayPointsThreshold() {
        return getInt(R.string.pref_showwaypointsthreshold, SHOW_WP_THRESHOLD_DEFAULT);
    }

    public static void setShowWaypointsThreshold(final int threshold) {
        putInt(R.string.pref_showwaypointsthreshold, threshold);
    }

    public static boolean isUseTwitter() {
        return getBoolean(R.string.pref_twitter, false);
    }

    public static void setUseTwitter(final boolean useTwitter) {
        putBoolean(R.string.pref_twitter, useTwitter);
    }

    public static boolean isTwitterLoginValid() {
        return !StringUtils.isBlank(getTokenPublic())
                && !StringUtils.isBlank(getTokenSecret());
    }

    public static String getTokenPublic() {
        return getString(R.string.pref_twitter_token_public, null);
    }

    public static String getTokenSecret() {
        return getString(R.string.pref_twitter_token_secret, null);

    }

    public static boolean hasTwitterAuthorization() {
        return StringUtils.isNotBlank(getTokenPublic())
                && StringUtils.isNotBlank(getTokenSecret());
    }

    public static void setTwitterTokens(@Nullable final String tokenPublic,
            @Nullable final String tokenSecret, final boolean enableTwitter) {
        putString(R.string.pref_twitter_token_public, tokenPublic);
        putString(R.string.pref_twitter_token_secret, tokenSecret);
        if (tokenPublic != null) {
            remove(R.string.pref_temp_twitter_token_public);
            remove(R.string.pref_temp_twitter_token_secret);
        }
        setUseTwitter(enableTwitter);
    }

    public static void setTwitterTempTokens(@Nullable final String tokenPublic,
            @Nullable final String tokenSecret) {
        putString(R.string.pref_temp_twitter_token_public, tokenPublic);
        putString(R.string.pref_temp_twitter_token_secret, tokenSecret);
    }

    public static ImmutablePair<String, String> getTempToken() {
        final String tokenPublic = getString(R.string.pref_temp_twitter_token_public, null);
        final String tokenSecret = getString(R.string.pref_temp_twitter_token_secret, null);
        return new ImmutablePair<>(tokenPublic, tokenSecret);
    }

    public static int getVersion() {
        return getInt(R.string.pref_version, 0);
    }

    public static void setVersion(final int version) {
        putInt(R.string.pref_version, version);
    }

    public static boolean isOpenLastDetailsPage() {
        return getBoolean(R.string.pref_opendetailslastpage, false);
    }

    public static int getLastDetailsPage() {
        return getInt(R.string.pref_lastdetailspage, 1);
    }

    public static void setLastDetailsPage(final int index) {
        putInt(R.string.pref_lastdetailspage, index);
    }

    public static int getDefaultNavigationTool() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool,
                String.valueOf(NavigationAppsEnum.COMPASS.id)));
    }

    public static int getDefaultNavigationTool2() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool2,
                String.valueOf(NavigationAppsEnum.INTERNAL_MAP.id)));
    }

    public static Strategy getLiveMapStrategy() {
        return Strategy.getById(getInt(R.string.pref_livemapstrategy, Strategy.AUTO.id));
    }

    public static void setLiveMapStrategy(final Strategy strategy) {
        putInt(R.string.pref_livemapstrategy, strategy.id);
    }

    public static boolean isDebug() {
        return Log.isDebug();
    }

    public static boolean getHideLiveMapHint() {
        return getBoolean(R.string.pref_hidelivemaphint, false);
    }

    public static void setHideLiveHint(final boolean hide) {
        putBoolean(R.string.pref_hidelivemaphint, hide);
    }

    public static int getLiveMapHintShowCount() {
        return getInt(R.string.pref_livemaphintshowcount, 0);
    }

    public static void setLiveMapHintShowCount(final int showCount) {
        putInt(R.string.pref_livemaphintshowcount, showCount);
    }

    public static boolean isDbOnSDCard() {
        return getBoolean(R.string.pref_dbonsdcard, false);
    }

    public static void setDbOnSDCard(final boolean dbOnSDCard) {
        putBoolean(R.string.pref_dbonsdcard, dbOnSDCard);
    }

    public static String getGpxExportDir() {
        return getString(R.string.pref_gpxExportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static String getGpxImportDir() {
        return getString(R.string.pref_gpxImportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static boolean getShareAfterExport() {
        return getBoolean(R.string.pref_shareafterexport, true);
    }

    public static void setShareAfterExport(final boolean shareAfterExport) {
        putBoolean(R.string.pref_shareafterexport, shareAfterExport);
    }

    public static int getTrackableAction() {
        return getInt(R.string.pref_trackableaction, LogType.RETRIEVED_IT.id);
    }

    public static void setTrackableAction(final int trackableAction) {
        putInt(R.string.pref_trackableaction, trackableAction);
    }

    public static String getCustomRenderThemeBaseFolder() {
        return getString(R.string.pref_renderthemepath, "");
    }

    public static String getCustomRenderThemeFilePath() {
        return getString(R.string.pref_renderthemefile, "");
    }

    public static void setCustomRenderThemeFile(final String customRenderThemeFile) {
        putString(R.string.pref_renderthemefile, customRenderThemeFile);
    }

    public static File[] getMapThemeFiles() {
        final File directory = new File(Settings.getCustomRenderThemeBaseFolder());
        final List<File> result = new ArrayList<>();
        FileUtils.listDir(result, directory, new ExtensionsBasedFileSelector(new String[] { "xml" }), null);

        return result.toArray(new File[result.size()]);
    }

    private static class ExtensionsBasedFileSelector extends FileSelector {
        private final String[] extensions;
        public ExtensionsBasedFileSelector(final String[] extensions) {
            this.extensions = extensions;
        }
        @Override
        public boolean isSelected(final File file) {
            final String filename = file.getName();
            for (final String ext : extensions) {
                if (StringUtils.endsWithIgnoreCase(filename, ext)) {
                    return true;
                }
            }
            return false;
        }
        @Override
        public boolean shouldEnd() {
            return false;
        }
    }

    public static boolean getPlainLogs() {
        return getBoolean(R.string.pref_plainLogs, false);
    }

    public static boolean getUseNativeUa() {
        return getBoolean(R.string.pref_nativeUa, false);
    }

    public static String getCacheTwitterMessage() {
        return getString(R.string.pref_twitter_cache_message, "I found [NAME] ([URL]).");
    }

    public static String getTrackableTwitterMessage() {
        return getString(R.string.pref_twitter_trackable_message, "I touched [NAME] ([URL]).");
    }

    public static int getLogImageScale() {
        return getInt(R.string.pref_logImageScale, -1);
    }

    public static void setLogImageScale(final int scale) {
        putInt(R.string.pref_logImageScale, scale);
    }

    public static void setExcludeMine(final boolean exclude) {
        putBoolean(R.string.pref_excludemine, exclude);
    }

    static void setLogin(final String username, final String password) {
        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            // erase username and password
            remove(R.string.pref_username);
            remove(R.string.pref_password);
            return;
        }
        // save username and password
        putString(R.string.pref_username, username);
        putString(R.string.pref_password, password);
    }

    public static long getFieldnoteExportDate() {
        return getLong(R.string.pref_fieldNoteExportDate, 0);
    }

    /**
     * remember date of last field note export
     *
     * @param date
     */
    public static void setFieldnoteExportDate(final long date) {
        putLong(R.string.pref_fieldNoteExportDate, date);
    }

    public static boolean isUseNavigationApp(final NavigationAppsEnum navApp) {
        return getBoolean(navApp.preferenceKey, true);
    }

    /**
     * remember the state of the "Upload" checkbox in the field notes export dialog
     *
     * @param upload
     */
    public static void setFieldNoteExportUpload(final boolean upload) {
        putBoolean(R.string.pref_fieldNoteExportUpload, upload);
    }

    public static boolean getFieldNoteExportUpload() {
        return getBoolean(R.string.pref_fieldNoteExportUpload, true);
    }

    /**
     * remember the state of the "Only new" checkbox in the field notes export dialog
     *
     * @param onlyNew
     */
    public static void setFieldNoteExportOnlyNew(final boolean onlyNew) {
        putBoolean(R.string.pref_fieldNoteExportOnlyNew, onlyNew);
    }

    public static boolean getFieldNoteExportOnlyNew() {
        return getBoolean(R.string.pref_fieldNoteExportOnlyNew, false);
    }

    public static String getECIconSet() {
        return getString(R.string.pref_ec_icons, "1");
    }

    /* Store last checksum of changelog for changelog display */
    public static long getLastChangelogChecksum() {
        return getLong(R.string.pref_changelog_last_checksum, 0);
    }

    public static void setLastChangelogChecksum(final long checksum) {
        putLong(R.string.pref_changelog_last_checksum, checksum);
    }

    public static List<String> getLastOpenedCaches() {
        final List<String> history = Arrays.asList(StringUtils.split(getString(R.string.pref_caches_history, StringUtils.EMPTY), HISTORY_SEPARATOR));
        return history.subList(0, Math.min(HISTORY_SIZE, history.size()));
    }

    public static void addCacheToHistory(@NonNull final String geocode) {
        final ArrayList<String> history = new ArrayList<>(getLastOpenedCaches());
        // bring entry to front, if it already existed
        history.remove(geocode);
        history.add(0, geocode);
        putString(R.string.pref_caches_history, StringUtils.join(history, HISTORY_SEPARATOR));
    }

    public static boolean useHardwareAcceleration() {
        return getBoolean(R.string.pref_hardware_acceleration, !HW_ACCEL_DISABLED_BY_DEFAULT);
    }

    public static boolean setUseHardwareAcceleration(final boolean useHardwareAcceleration) {
        return putBoolean(R.string.pref_hardware_acceleration, useHardwareAcceleration);
    }
}
!@#$%
20190527_005351,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_b04176
package cgeo.geocaching.settings;

import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.R;
import cgeo.geocaching.apps.cache.navi.NavigationAppFactory.NavigationAppsEnum;
import cgeo.geocaching.connector.capability.ICredentials;
import cgeo.geocaching.connector.gc.GCConnector;
import cgeo.geocaching.connector.gc.GCConstants;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.LiveMapStrategy.Strategy;
import cgeo.geocaching.enumerations.LogType;
import cgeo.geocaching.list.StoredList;
import cgeo.geocaching.location.Geopoint;
import cgeo.geocaching.maps.CGeoMap.MapMode;
import cgeo.geocaching.maps.MapProviderFactory;
import cgeo.geocaching.maps.google.v1.GoogleMapProvider;
import cgeo.geocaching.maps.interfaces.GeoPointImpl;
import cgeo.geocaching.maps.interfaces.MapProvider;
import cgeo.geocaching.maps.interfaces.MapSource;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider.OfflineMapSource;
import cgeo.geocaching.utils.CryptUtils;
import cgeo.geocaching.utils.FileUtils;
import cgeo.geocaching.utils.FileUtils.FileSelector;
import cgeo.geocaching.utils.Log;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.os.Build;
import android.os.Environment;
import android.preference.PreferenceManager;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;

/**
 * General c:geo preferences/settings set by the user
 */
public class Settings {

    /**
     * On opening a map, we limit the _initial_ zoom. The user can still zoom out afterwards.
     */
    private static final int INITIAL_MAP_ZOOM_LIMIT = 16;
    private static final char HISTORY_SEPARATOR = ',';
    public static final int SHOW_WP_THRESHOLD_DEFAULT = 10;
    public static final int SHOW_WP_THRESHOLD_MAX = 50;
    private static final int MAP_SOURCE_DEFAULT = GoogleMapProvider.GOOGLE_MAP_ID.hashCode();

    public static final boolean HW_ACCEL_DISABLED_BY_DEFAULT =
            Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1 ||
            StringUtils.equals(Build.MODEL, "HTC One X") ||    // HTC One X
            StringUtils.equals(Build.MODEL, "HTC One S") ||    // HTC One S
            StringUtils.equals(Build.MODEL, "GT-I8190")  ||    // Samsung S3 mini
            StringUtils.equals(Build.MODEL, "GT-S6310L") ||    // Samsung Galaxy Young
            StringUtils.equals(Build.MODEL, "GT-P5210")  ||    // Samsung Galaxy Tab 3
            StringUtils.equals(Build.MODEL, "GT-S7580")  ||    // Samsung Galaxy Trend Plus
            StringUtils.equals(Build.MODEL, "GT-I9105P") ||    // Samsung Galaxy SII Plus
            StringUtils.equals(Build.MODEL, "ST25i")     ||    // Sony Xperia U
            StringUtils.equals(Build.MODEL, "bq Aquaris 5");   // bq Aquaris 5

    private final static int unitsMetric = 1;

    // twitter api keys
    private final static @NonNull String keyConsumerPublic = CryptUtils.rot13("ESnsCvAv3kEupF1GCR3jGj");
    private final static @NonNull String keyConsumerSecret = CryptUtils.rot13("7vQWceACV9umEjJucmlpFe9FCMZSeqIqfkQ2BnhV9x");

    public enum CoordInputFormatEnum {
        Plain,
        Deg,
        Min,
        Sec;

        static final int DEFAULT_INT_VALUE = Min.ordinal();

        public static CoordInputFormatEnum fromInt(final int id) {
            final CoordInputFormatEnum[] values = CoordInputFormatEnum.values();
            if (id < 0 || id >= values.length) {
                return Min;
            }
            return values[id];
        }
    }

    private static final SharedPreferences sharedPrefs = PreferenceManager
            .getDefaultSharedPreferences(CgeoApplication.getInstance().getBaseContext());
    static {
        migrateSettings();
        final boolean isDebug = sharedPrefs.getBoolean(getKey(R.string.pref_debug), false);
        Log.setDebug(isDebug);
        CgeoApplication.dumpOnOutOfMemory(isDebug);
    }

    /**
     * Cache the mapsource locally. If that is an offline map source, each request would potentially access the
     * underlying map file, leading to delays.
     */
    private static MapSource mapSource;

    protected Settings() {
        throw new InstantiationError();
    }

    private static void migrateSettings() {
        final int LATEST_PREFERENCES_VERSION = 2;
        final int currentVersion = getInt(R.string.pref_settingsversion, 0);

        // No need to migrate if we are up to date.
        if (currentVersion == LATEST_PREFERENCES_VERSION) {
            return;
        }

        // No need to migrate if we don't have older settings, defaults will be used instead.
        final String preferencesNameV0 = "cgeo.pref";
        final SharedPreferences prefsV0 = CgeoApplication.getInstance().getSharedPreferences(preferencesNameV0, Context.MODE_PRIVATE);
        if (currentVersion == 0 && prefsV0.getAll().isEmpty()) {
            final Editor e = sharedPrefs.edit();
            e.putInt(getKey(R.string.pref_settingsversion), LATEST_PREFERENCES_VERSION);
            e.commit();
            return;
        }

        if (currentVersion < 1) {
            // migrate from non standard file location and integer based boolean types
            final Editor e = sharedPrefs.edit();

            e.putString(getKey(R.string.pref_temp_twitter_token_secret), prefsV0.getString(getKey(R.string.pref_temp_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_temp_twitter_token_public), prefsV0.getString(getKey(R.string.pref_temp_twitter_token_public), null));
            e.putBoolean(getKey(R.string.pref_help_shown), prefsV0.getInt(getKey(R.string.pref_help_shown), 0) != 0);
            e.putFloat(getKey(R.string.pref_anylongitude), prefsV0.getFloat(getKey(R.string.pref_anylongitude), 0));
            e.putFloat(getKey(R.string.pref_anylatitude), prefsV0.getFloat(getKey(R.string.pref_anylatitude), 0));
            e.putBoolean(getKey(R.string.pref_offlinemaps), 0 != prefsV0.getInt(getKey(R.string.pref_offlinemaps), 1));
            e.putBoolean(getKey(R.string.pref_offlinewpmaps), 0 != prefsV0.getInt(getKey(R.string.pref_offlinewpmaps), 0));
            e.putString(getKey(R.string.pref_webDeviceCode), prefsV0.getString(getKey(R.string.pref_webDeviceCode), null));
            e.putString(getKey(R.string.pref_webDeviceName), prefsV0.getString(getKey(R.string.pref_webDeviceName), null));
            e.putBoolean(getKey(R.string.pref_maplive), prefsV0.getInt(getKey(R.string.pref_maplive), 1) != 0);
            e.putInt(getKey(R.string.pref_mapsource), prefsV0.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT));
            e.putBoolean(getKey(R.string.pref_twitter), 0 != prefsV0.getInt(getKey(R.string.pref_twitter), 0));
            e.putBoolean(getKey(R.string.pref_showaddress), 0 != prefsV0.getInt(getKey(R.string.pref_showaddress), 1));
            e.putBoolean(getKey(R.string.pref_showcaptcha), prefsV0.getBoolean(getKey(R.string.pref_showcaptcha), false));
            e.putBoolean(getKey(R.string.pref_maptrail), prefsV0.getInt(getKey(R.string.pref_maptrail), 1) != 0);
            e.putInt(getKey(R.string.pref_lastmapzoom), prefsV0.getInt(getKey(R.string.pref_lastmapzoom), 14));
            e.putBoolean(getKey(R.string.pref_livelist), 0 != prefsV0.getInt(getKey(R.string.pref_livelist), 1));
            e.putBoolean(getKey(R.string.pref_units_imperial), prefsV0.getInt(getKey(R.string.pref_units_imperial), unitsMetric) != unitsMetric);
            e.putBoolean(getKey(R.string.pref_skin), prefsV0.getInt(getKey(R.string.pref_skin), 0) != 0);
            e.putInt(getKey(R.string.pref_lastusedlist), prefsV0.getInt(getKey(R.string.pref_lastusedlist), StoredList.STANDARD_LIST_ID));
            e.putString(getKey(R.string.pref_cachetype), prefsV0.getString(getKey(R.string.pref_cachetype), CacheType.ALL.id));
            e.putString(getKey(R.string.pref_twitter_token_secret), prefsV0.getString(getKey(R.string.pref_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_twitter_token_public), prefsV0.getString(getKey(R.string.pref_twitter_token_public), null));
            e.putInt(getKey(R.string.pref_version), prefsV0.getInt(getKey(R.string.pref_version), 0));
            e.putBoolean(getKey(R.string.pref_autoloaddesc), 0 != prefsV0.getInt(getKey(R.string.pref_autoloaddesc), 1));
            e.putBoolean(getKey(R.string.pref_ratingwanted), prefsV0.getBoolean(getKey(R.string.pref_ratingwanted), true));
            e.putBoolean(getKey(R.string.pref_friendlogswanted), prefsV0.getBoolean(getKey(R.string.pref_friendlogswanted), true));
            e.putBoolean(getKey(R.string.pref_useenglish), prefsV0.getBoolean(getKey(R.string.pref_useenglish), false));
            e.putBoolean(getKey(R.string.pref_usecompass), 0 != prefsV0.getInt(getKey(R.string.pref_usecompass), 1));
            e.putBoolean(getKey(R.string.pref_trackautovisit), prefsV0.getBoolean(getKey(R.string.pref_trackautovisit), false));
            e.putBoolean(getKey(R.string.pref_sigautoinsert), prefsV0.getBoolean(getKey(R.string.pref_sigautoinsert), false));
            e.putBoolean(getKey(R.string.pref_logimages), prefsV0.getBoolean(getKey(R.string.pref_logimages), false));
            e.putBoolean(getKey(R.string.pref_excludedisabled), 0 != prefsV0.getInt(getKey(R.string.pref_excludedisabled), 0));
            e.putBoolean(getKey(R.string.pref_excludemine), 0 != prefsV0.getInt(getKey(R.string.pref_excludemine), 0));
            e.putString(getKey(R.string.pref_mapfile), prefsV0.getString(getKey(R.string.pref_mapfile), null));
            e.putString(getKey(R.string.pref_signature), prefsV0.getString(getKey(R.string.pref_signature), null));
            e.putString(getKey(R.string.pref_pass_vote), prefsV0.getString(getKey(R.string.pref_pass_vote), null));
            e.putString(getKey(R.string.pref_password), prefsV0.getString(getKey(R.string.pref_password), null));
            e.putString(getKey(R.string.pref_username), prefsV0.getString(getKey(R.string.pref_username), null));
            e.putString(getKey(R.string.pref_memberstatus), prefsV0.getString(getKey(R.string.pref_memberstatus), ""));
            e.putInt(getKey(R.string.pref_coordinputformat), prefsV0.getInt(getKey(R.string.pref_coordinputformat), CoordInputFormatEnum.DEFAULT_INT_VALUE));
            e.putBoolean(getKey(R.string.pref_log_offline), prefsV0.getBoolean(getKey(R.string.pref_log_offline), false));
            e.putBoolean(getKey(R.string.pref_choose_list), prefsV0.getBoolean(getKey(R.string.pref_choose_list), true));
            e.putBoolean(getKey(R.string.pref_loaddirectionimg), prefsV0.getBoolean(getKey(R.string.pref_loaddirectionimg), true));
            e.putString(getKey(R.string.pref_gccustomdate), prefsV0.getString(getKey(R.string.pref_gccustomdate), GCConstants.DEFAULT_GC_DATE));
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), prefsV0.getInt(getKey(R.string.pref_showwaypointsthreshold), SHOW_WP_THRESHOLD_DEFAULT));
            e.putString(getKey(R.string.pref_cookiestore), prefsV0.getString(getKey(R.string.pref_cookiestore), null));
            e.putBoolean(getKey(R.string.pref_opendetailslastpage), prefsV0.getBoolean(getKey(R.string.pref_opendetailslastpage), false));
            e.putInt(getKey(R.string.pref_lastdetailspage), prefsV0.getInt(getKey(R.string.pref_lastdetailspage), 1));
            e.putInt(getKey(R.string.pref_defaultNavigationTool), prefsV0.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id));
            e.putInt(getKey(R.string.pref_defaultNavigationTool2), prefsV0.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id));
            e.putInt(getKey(R.string.pref_livemapstrategy), prefsV0.getInt(getKey(R.string.pref_livemapstrategy), Strategy.AUTO.id));
            e.putBoolean(getKey(R.string.pref_debug), prefsV0.getBoolean(getKey(R.string.pref_debug), false));
            e.putInt(getKey(R.string.pref_livemaphintshowcount), prefsV0.getInt(getKey(R.string.pref_livemaphintshowcount), 0));

            e.putInt(getKey(R.string.pref_settingsversion), 1); // mark migrated
            e.commit();
        }

        // changes for new settings dialog
        if (currentVersion < 2) {
            final Editor e = sharedPrefs.edit();

            e.putBoolean(getKey(R.string.pref_units_imperial), useImperialUnits());

            // show waypoints threshold now as a slider
            int wpThreshold = getWayPointsThreshold();
            if (wpThreshold < 0) {
                wpThreshold = 0;
            } else if (wpThreshold > SHOW_WP_THRESHOLD_MAX) {
                wpThreshold = SHOW_WP_THRESHOLD_MAX;
            }
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), wpThreshold);

            // KEY_MAP_SOURCE must be string, because it is the key for a ListPreference now
            final int ms = sharedPrefs.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT);
            e.remove(getKey(R.string.pref_mapsource));
            e.putString(getKey(R.string.pref_mapsource), String.valueOf(ms));

            // navigation tool ids must be string, because ListPreference uses strings as keys
            final int dnt1 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id);
            final int dnt2 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id);
            e.remove(getKey(R.string.pref_defaultNavigationTool));
            e.remove(getKey(R.string.pref_defaultNavigationTool2));
            e.putString(getKey(R.string.pref_defaultNavigationTool), String.valueOf(dnt1));
            e.putString(getKey(R.string.pref_defaultNavigationTool2), String.valueOf(dnt2));

            // defaults for gpx directories
            e.putString(getKey(R.string.pref_gpxImportDir), getGpxImportDir());
            e.putString(getKey(R.string.pref_gpxExportDir), getGpxExportDir());

            e.putInt(getKey(R.string.pref_settingsversion), 2); // mark migrated
            e.commit();
        }
    }

    private static String getKey(final int prefKeyId) {
        return CgeoApplication.getInstance().getString(prefKeyId);
    }

    static String getString(final int prefKeyId, final String defaultValue) {
        return sharedPrefs.getString(getKey(prefKeyId), defaultValue);
    }

    private static int getInt(final int prefKeyId, final int defaultValue) {
        return sharedPrefs.getInt(getKey(prefKeyId), defaultValue);
    }

    private static long getLong(final int prefKeyId, final long defaultValue) {
        return sharedPrefs.getLong(getKey(prefKeyId), defaultValue);
    }

    private static boolean getBoolean(final int prefKeyId, final boolean defaultValue) {
        return sharedPrefs.getBoolean(getKey(prefKeyId), defaultValue);
    }

    private static float getFloat(final int prefKeyId, final float defaultValue) {
        return sharedPrefs.getFloat(getKey(prefKeyId), defaultValue);
    }

    protected static boolean putString(final int prefKeyId, final String value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putString(getKey(prefKeyId), value);
        return edit.commit();
    }

    protected static boolean putBoolean(final int prefKeyId, final boolean value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putBoolean(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putInt(final int prefKeyId, final int value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putInt(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putLong(final int prefKeyId, final long value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putLong(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putFloat(final int prefKeyId, final float value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putFloat(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean remove(final int prefKeyId) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.remove(getKey(prefKeyId));
        return edit.commit();
    }

    private static boolean contains(final int prefKeyId) {
        return sharedPrefs.contains(getKey(prefKeyId));
    }

    public static void setLanguage(final boolean useEnglish) {
        final Configuration config = new Configuration();
        config.locale = useEnglish ? Locale.ENGLISH : Locale.getDefault();
        final Resources resources = CgeoApplication.getInstance().getResources();
        resources.updateConfiguration(config, resources.getDisplayMetrics());
    }

    public static boolean isLogin() {
        final String preUsername = getString(R.string.pref_username, null);
        final String prePassword = getString(R.string.pref_password, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    /**
     * Get login and password information of Geocaching.com.
     *
     * @return a pair either with (login, password) or (empty, empty) if no valid information is stored
     */
    public static ImmutablePair<String, String> getGcCredentials() {
        return getCredentials(GCConnector.getInstance());
    }

    /**
     * Get login and password information.
     *
     * @return a pair either with (login, password) or (empty, empty) if no valid information is stored
     */
    public static ImmutablePair<String, String> getCredentials(final @NonNull ICredentials connector) {
        final String username = getString(connector.getUsernamePreferenceKey(), null);
        final String password = getString(connector.getPasswordPreferenceKey(), null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return new ImmutablePair<>(StringUtils.EMPTY, StringUtils.EMPTY);
        }

        return new ImmutablePair<>(username, password);
    }

    public static String getUsername() {
        return getString(R.string.pref_username, null);
    }

    public static boolean isGCConnectorActive() {
        return getBoolean(R.string.pref_connectorGCActive, true);
    }

    public static boolean isECConnectorActive() {
        return getBoolean(R.string.pref_connectorECActive, false);
    }

    public static boolean isOXConnectorActive() {
        return getBoolean(R.string.pref_connectorOXActive, false);
    }

    public static boolean isGCPremiumMember() {
        // Basic Member, Premium Member, ???
        return GCConstants.MEMBER_STATUS_PM.equalsIgnoreCase(Settings.getGCMemberStatus());
    }

    public static String getGCMemberStatus() {
        return getString(R.string.pref_memberstatus, "");
    }

    public static boolean setGCMemberStatus(final String memberStatus) {
        if (StringUtils.isBlank(memberStatus)) {
            return remove(R.string.pref_memberstatus);
        }
        return putString(R.string.pref_memberstatus, memberStatus);
    }

    public static ImmutablePair<String, String> getTokenPair(final int tokenPublicPrefKey, final int tokenSecretPrefKey) {
        return new ImmutablePair<>(getString(tokenPublicPrefKey, null), getString(tokenSecretPrefKey, null));
    }

    public static void setTokens(final int tokenPublicPrefKey, @Nullable final String tokenPublic, final int tokenSecretPrefKey, @Nullable final String tokenSecret) {
        if (tokenPublic == null) {
            remove(tokenPublicPrefKey);
        } else {
            putString(tokenPublicPrefKey, tokenPublic);
        }
        if (tokenSecret == null) {
            remove(tokenSecretPrefKey);
        } else {
            putString(tokenSecretPrefKey, tokenSecret);
        }
    }

    public static boolean isOCConnectorActive(final int isActivePrefKeyId) {
        return getBoolean(isActivePrefKeyId, false);
    }

    public static boolean hasOCAuthorization(final int tokenPublicPrefKeyId, final int tokenSecretPrefKeyId) {
        return StringUtils.isNotBlank(getString(tokenPublicPrefKeyId, ""))
                && StringUtils.isNotBlank(getString(tokenSecretPrefKeyId, ""));
    }

    public static boolean isGCvoteLogin() {
        final String preUsername = getString(R.string.pref_username, null);
        final String prePassword = getString(R.string.pref_pass_vote, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    public static ImmutablePair<String, String> getGCvoteLogin() {
        final String username = getString(R.string.pref_username, null);
        final String password = getString(R.string.pref_pass_vote, null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return null;
        }

        return new ImmutablePair<>(username, password);
    }

    public static String getSignature() {
        return getString(R.string.pref_signature, StringUtils.EMPTY);
    }

    public static boolean setCookieStore(final String cookies) {
        if (StringUtils.isBlank(cookies)) {
            // erase cookies
            return remove(R.string.pref_cookiestore);
        }
        // save cookies
        return putString(R.string.pref_cookiestore, cookies);
    }

    public static String getCookieStore() {
        return getString(R.string.pref_cookiestore, null);
    }

    public static boolean useGooglePlayServices() {
        return CgeoApplication.getInstance().isGooglePlayServicesAvailable() && getBoolean(R.string.pref_googleplayservices, true);
    }

    public static boolean useLowPowerMode() {
        return getBoolean(R.string.pref_lowpowermode, false);
    }

    /**
     * @param cacheType
     *            The cache type used for future filtering
     */
    public static void setCacheType(final CacheType cacheType) {
        if (cacheType == null) {
            remove(R.string.pref_cachetype);
        } else {
            putString(R.string.pref_cachetype, cacheType.id);
        }
    }

    public static int getLastList() {
        return getInt(R.string.pref_lastusedlist, StoredList.STANDARD_LIST_ID);
    }

    public static void saveLastList(final int listId) {
        putInt(R.string.pref_lastusedlist, listId);
    }

    public static void setWebNameCode(final String name, final String code) {
        putString(R.string.pref_webDeviceName, name);
        putString(R.string.pref_webDeviceCode, code);
    }

    public static MapProvider getMapProvider() {
        return getMapSource().getMapProvider();
    }

    public static String getMapFile() {
        return getString(R.string.pref_mapfile, null);
    }

    public static boolean setMapFile(final String mapFile) {
        final boolean result = putString(R.string.pref_mapfile, mapFile);
        if (mapFile != null) {
            setMapFileDirectory(new File(mapFile).getParent());
        }
        return result;
    }

    public static String getMapFileDirectory() {
        final String mapDir = getString(R.string.pref_mapDirectory, null);
        if (mapDir != null) {
            return mapDir;
        }
        final String mapFile = getMapFile();
        if (mapFile != null) {
            return new File(mapFile).getParent();
        }
        return null;
    }

    public static boolean setMapFileDirectory(final String mapFileDirectory) {
        final boolean result = putString(R.string.pref_mapDirectory, mapFileDirectory);
        MapsforgeMapProvider.getInstance().updateOfflineMaps();
        return result;
    }

    public static boolean isValidMapFile() {
        return isValidMapFile(getMapFile());
    }

    public static boolean isValidMapFile(final String mapFileIn) {
        return MapsforgeMapProvider.isValidMapFile(mapFileIn);
    }

    public static boolean isScaleMapsforgeText() {
        return getBoolean(R.string.pref_mapsforge_scale_text, true);
    }

    public static CoordInputFormatEnum getCoordInputFormat() {
        return CoordInputFormatEnum.fromInt(getInt(R.string.pref_coordinputformat, CoordInputFormatEnum.DEFAULT_INT_VALUE));
    }

    public static void setCoordInputFormat(final CoordInputFormatEnum format) {
        putInt(R.string.pref_coordinputformat, format.ordinal());
    }

    public static boolean getLogOffline() {
        return getBoolean(R.string.pref_log_offline, false);
    }

    public static boolean getChooseList() {
        return getBoolean(R.string.pref_choose_list, false);
    }

    public static boolean getLoadDirImg() {
        return !isGCPremiumMember() && getBoolean(R.string.pref_loaddirectionimg, true);
    }

    public static void setGcCustomDate(final String format) {
        putString(R.string.pref_gccustomdate, format);
    }

    /**
     * @return User selected date format on GC.com
     */
    public static String getGcCustomDate() {
        // We might have some users whose stored value is null, which is invalid. In this case, we use the default.
        return StringUtils.defaultString(getString(R.string.pref_gccustomdate, GCConstants.DEFAULT_GC_DATE),
                GCConstants.DEFAULT_GC_DATE);
    }

    public static boolean isExcludeMyCaches() {
        return getBoolean(R.string.pref_excludemine, false);
    }

    public static boolean isUseEnglish() {
        return getBoolean(R.string.pref_useenglish, false);
    }

    public static boolean isShowAddress() {
        return getBoolean(R.string.pref_showaddress, true);
    }

    public static boolean isShowCaptcha() {
        return !isGCPremiumMember() && getBoolean(R.string.pref_showcaptcha, false);
    }

    public static boolean isExcludeDisabledCaches() {
        return getBoolean(R.string.pref_excludedisabled, false);
    }

    public static boolean isStoreOfflineMaps() {
        return getBoolean(R.string.pref_offlinemaps, true);
    }

    public static boolean isStoreOfflineWpMaps() {
        return getBoolean(R.string.pref_offlinewpmaps, false);
    }

    public static boolean isStoreLogImages() {
        return getBoolean(R.string.pref_logimages, false);
    }

    public static boolean isAutoLoadDescription() {
        return getBoolean(R.string.pref_autoloaddesc, true);
    }

    public static boolean isRatingWanted() {
        return getBoolean(R.string.pref_ratingwanted, true);
    }

    public static boolean isFriendLogsWanted() {
        if (!isLogin()) {
            // don't show a friends log if the user is anonymous
            return false;
        }
        return getBoolean(R.string.pref_friendlogswanted, true);
    }

    public static boolean isLiveList() {
        return getBoolean(R.string.pref_livelist, true);
    }

    public static boolean isTrackableAutoVisit() {
        return getBoolean(R.string.pref_trackautovisit, false);
    }

    public static boolean isAutoInsertSignature() {
        return getBoolean(R.string.pref_sigautoinsert, false);
    }

    public static void setUseImperialUnits(final boolean useImperialUnits) {
        putBoolean(R.string.pref_units_imperial, useImperialUnits);
    }

    public static boolean useImperialUnits() {
        return getBoolean(R.string.pref_units_imperial, useImperialUnitsByDefault());
    }

    static boolean useImperialUnitsByDefault() {
        final String countryCode = Locale.getDefault().getCountry();
        return "US".equals(countryCode)  // USA
            || "LR".equals(countryCode)  // Liberia
            || "MM".equals(countryCode); // Burma
    }

    public static boolean isLiveMap() {
        return getBoolean(R.string.pref_maplive, true);
    }

    public static void setLiveMap(final boolean live) {
        putBoolean(R.string.pref_maplive, live);
    }

    public static boolean isMapTrail() {
        return getBoolean(R.string.pref_maptrail, true);
    }

    public static void setMapTrail(final boolean showTrail) {
        putBoolean(R.string.pref_maptrail, showTrail);
    }

    /**
     * Get last used zoom of the internal map. Differentiate between two use cases for a map of multiple caches (e.g.
     * live map) and the map of a single cache (which is often zoomed in more deep).
     *
     * @param mapMode
     * @return
     */
    public static int getMapZoom(final MapMode mapMode) {
        if (mapMode == MapMode.SINGLE || mapMode == MapMode.COORDS) {
            return getCacheZoom();
        }
        return getMapZoom();
    }

    public static void setMapZoom(final MapMode mapMode, final int zoomLevel) {
        if (mapMode == MapMode.SINGLE || mapMode == MapMode.COORDS) {
            setCacheZoom(zoomLevel);
        }
        else {
            setMapZoom(zoomLevel);
        }
    }

    /**
     * @return zoom used for the (live) map
     */
    private static int getMapZoom() {
        return Math.max(getInt(R.string.pref_lastmapzoom, 14), INITIAL_MAP_ZOOM_LIMIT);
    }

    private static void setMapZoom(final int mapZoomLevel) {
        putInt(R.string.pref_lastmapzoom, mapZoomLevel);
    }

    /**
     * @return zoom used for the map of a single cache
     */
    private static int getCacheZoom() {
        return Math.max(getInt(R.string.pref_cache_zoom, 14), INITIAL_MAP_ZOOM_LIMIT);
    }

    private static void setCacheZoom(final int zoomLevel) {
        putInt(R.string.pref_cache_zoom, zoomLevel);
    }

    public static GeoPointImpl getMapCenter() {
        return getMapProvider().getMapItemFactory()
                .getGeoPointBase(new Geopoint(getInt(R.string.pref_lastmaplat, 0) / 1e6,
                        getInt(R.string.pref_lastmaplon, 0) / 1e6));
    }

    public static void setMapCenter(final GeoPointImpl mapViewCenter) {
        putInt(R.string.pref_lastmaplat, mapViewCenter.getLatitudeE6());
        putInt(R.string.pref_lastmaplon, mapViewCenter.getLongitudeE6());
    }

    @NonNull
    public static synchronized MapSource getMapSource() {
        if (mapSource != null) {
            return mapSource;
        }
        final int id = getConvertedMapId();
        mapSource = MapProviderFactory.getMapSource(id);
        if (mapSource != null) {
            // don't use offline maps if the map file is not valid
            if (!(mapSource instanceof OfflineMapSource) || isValidMapFile()) {
                return mapSource;
            }
        }
        // fallback to first available map
        return MapProviderFactory.getDefaultSource();
    }

    private final static int GOOGLEMAP_BASEID = 30;
    private final static int MAP = 1;
    private final static int SATELLITE = 2;

    private final static int MFMAP_BASEID = 40;
    private final static int MAPNIK = 1;
    private final static int CYCLEMAP = 3;
    private final static int OFFLINE = 4;
    private static final int HISTORY_SIZE = 10;

    /**
     * convert old preference ids for maps (based on constant values) into new hash based ids
     *
     * @return
     */
    private static int getConvertedMapId() {
        final int id = Integer.parseInt(getString(R.string.pref_mapsource,
                String.valueOf(MAP_SOURCE_DEFAULT)));
        switch (id) {
            case GOOGLEMAP_BASEID + MAP:
                return GoogleMapProvider.GOOGLE_MAP_ID.hashCode();
            case GOOGLEMAP_BASEID + SATELLITE:
                return GoogleMapProvider.GOOGLE_SATELLITE_ID.hashCode();
            case MFMAP_BASEID + MAPNIK:
                return MapsforgeMapProvider.MAPSFORGE_MAPNIK_ID.hashCode();
            case MFMAP_BASEID + CYCLEMAP:
                return MapsforgeMapProvider.MAPSFORGE_CYCLEMAP_ID.hashCode();
            case MFMAP_BASEID + OFFLINE: {
                final String mapFile = Settings.getMapFile();
                if (StringUtils.isNotEmpty(mapFile)) {
                    return mapFile.hashCode();
                }
                break;
            }
            default:
                break;
        }
        return id;
    }

    public static void setMapSource(final MapSource newMapSource) {
        putString(R.string.pref_mapsource, String.valueOf(newMapSource.getNumericalId()));
        if (newMapSource instanceof OfflineMapSource) {
            setMapFile(((OfflineMapSource) newMapSource).getFileName());
        }
        // cache the value
        mapSource = newMapSource;
    }

    public static void setAnyCoordinates(final Geopoint coords) {
        if (null != coords) {
            putFloat(R.string.pref_anylatitude, (float) coords.getLatitude());
            putFloat(R.string.pref_anylongitude, (float) coords.getLongitude());
        } else {
            remove(R.string.pref_anylatitude);
            remove(R.string.pref_anylongitude);
        }
    }

    public static Geopoint getAnyCoordinates() {
        if (contains(R.string.pref_anylatitude) && contains(R.string.pref_anylongitude)) {
            final float lat = getFloat(R.string.pref_anylatitude, 0);
            final float lon = getFloat(R.string.pref_anylongitude, 0);
            return new Geopoint(lat, lon);
        }
        return null;
    }

    public static boolean isUseCompass() {
        return getBoolean(R.string.pref_usecompass, true);
    }

    public static void setUseCompass(final boolean useCompass) {
        putBoolean(R.string.pref_usecompass, useCompass);
    }

    public static boolean isLightSkin() {
        return getBoolean(R.string.pref_skin, false);
    }

    @NonNull
    public static String getKeyConsumerPublic() {
        return keyConsumerPublic;
    }

    @NonNull
    public static String getKeyConsumerSecret() {
        return keyConsumerSecret;
    }

    public static String getWebDeviceCode() {
        return getString(R.string.pref_webDeviceCode, null);
    }

    public static boolean isRegisteredForSend2cgeo() {
        return getWebDeviceCode() != null;
    }

    public static String getWebDeviceName() {
        return getString(R.string.pref_webDeviceName, android.os.Build.MODEL);
    }

    /**
     * @return The cache type used for filtering or ALL if no filter is active.
     *         Returns never null
     */
    public static CacheType getCacheType() {
        return CacheType.getById(getString(R.string.pref_cachetype, CacheType.ALL.id));
    }

    /**
     * The Threshold for the showing of child waypoints
     */
    public static int getWayPointsThreshold() {
        return getInt(R.string.pref_showwaypointsthreshold, SHOW_WP_THRESHOLD_DEFAULT);
    }

    public static void setShowWaypointsThreshold(final int threshold) {
        putInt(R.string.pref_showwaypointsthreshold, threshold);
    }

    public static boolean isUseTwitter() {
        return getBoolean(R.string.pref_twitter, false);
    }

    public static void setUseTwitter(final boolean useTwitter) {
        putBoolean(R.string.pref_twitter, useTwitter);
    }

    public static boolean isTwitterLoginValid() {
        return !StringUtils.isBlank(getTokenPublic())
                && !StringUtils.isBlank(getTokenSecret());
    }

    public static String getTokenPublic() {
        return getString(R.string.pref_twitter_token_public, null);
    }

    public static String getTokenSecret() {
        return getString(R.string.pref_twitter_token_secret, null);

    }

    public static boolean hasTwitterAuthorization() {
        return StringUtils.isNotBlank(getTokenPublic())
                && StringUtils.isNotBlank(getTokenSecret());
    }

    public static void setTwitterTokens(@Nullable final String tokenPublic,
            @Nullable final String tokenSecret, final boolean enableTwitter) {
        putString(R.string.pref_twitter_token_public, tokenPublic);
        putString(R.string.pref_twitter_token_secret, tokenSecret);
        if (tokenPublic != null) {
            remove(R.string.pref_temp_twitter_token_public);
            remove(R.string.pref_temp_twitter_token_secret);
        }
        setUseTwitter(enableTwitter);
    }

    public static void setTwitterTempTokens(@Nullable final String tokenPublic,
            @Nullable final String tokenSecret) {
        putString(R.string.pref_temp_twitter_token_public, tokenPublic);
        putString(R.string.pref_temp_twitter_token_secret, tokenSecret);
    }

    public static ImmutablePair<String, String> getTempToken() {
        final String tokenPublic = getString(R.string.pref_temp_twitter_token_public, null);
        final String tokenSecret = getString(R.string.pref_temp_twitter_token_secret, null);
        return new ImmutablePair<>(tokenPublic, tokenSecret);
    }

    public static int getVersion() {
        return getInt(R.string.pref_version, 0);
    }

    public static void setVersion(final int version) {
        putInt(R.string.pref_version, version);
    }

    public static boolean isOpenLastDetailsPage() {
        return getBoolean(R.string.pref_opendetailslastpage, false);
    }

    public static int getLastDetailsPage() {
        return getInt(R.string.pref_lastdetailspage, 1);
    }

    public static void setLastDetailsPage(final int index) {
        putInt(R.string.pref_lastdetailspage, index);
    }

    public static int getDefaultNavigationTool() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool,
                String.valueOf(NavigationAppsEnum.COMPASS.id)));
    }

    public static int getDefaultNavigationTool2() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool2,
                String.valueOf(NavigationAppsEnum.INTERNAL_MAP.id)));
    }

    public static Strategy getLiveMapStrategy() {
        return Strategy.getById(getInt(R.string.pref_livemapstrategy, Strategy.AUTO.id));
    }

    public static void setLiveMapStrategy(final Strategy strategy) {
        putInt(R.string.pref_livemapstrategy, strategy.id);
    }

    public static boolean isDebug() {
        return Log.isDebug();
    }

    public static int getLiveMapHintShowCount() {
        return getInt(R.string.pref_livemaphintshowcount, 0);
    }

    public static void setLiveMapHintShowCount(final int showCount) {
        putInt(R.string.pref_livemaphintshowcount, showCount);
    }

    public static boolean isDbOnSDCard() {
        return getBoolean(R.string.pref_dbonsdcard, false);
    }

    public static void setDbOnSDCard(final boolean dbOnSDCard) {
        putBoolean(R.string.pref_dbonsdcard, dbOnSDCard);
    }

    public static String getGpxExportDir() {
        return getString(R.string.pref_gpxExportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static String getGpxImportDir() {
        return getString(R.string.pref_gpxImportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static boolean getShareAfterExport() {
        return getBoolean(R.string.pref_shareafterexport, true);
    }

    public static void setShareAfterExport(final boolean shareAfterExport) {
        putBoolean(R.string.pref_shareafterexport, shareAfterExport);
    }

    public static int getTrackableAction() {
        return getInt(R.string.pref_trackableaction, LogType.RETRIEVED_IT.id);
    }

    public static void setTrackableAction(final int trackableAction) {
        putInt(R.string.pref_trackableaction, trackableAction);
    }

    public static String getCustomRenderThemeBaseFolder() {
        return getString(R.string.pref_renderthemepath, "");
    }

    public static String getCustomRenderThemeFilePath() {
        return getString(R.string.pref_renderthemefile, "");
    }

    public static void setCustomRenderThemeFile(final String customRenderThemeFile) {
        putString(R.string.pref_renderthemefile, customRenderThemeFile);
    }

    public static File[] getMapThemeFiles() {
        final File directory = new File(Settings.getCustomRenderThemeBaseFolder());
        final List<File> result = new ArrayList<>();
        FileUtils.listDir(result, directory, new ExtensionsBasedFileSelector(new String[] { "xml" }), null);

        return result.toArray(new File[result.size()]);
    }

    private static class ExtensionsBasedFileSelector extends FileSelector {
        private final String[] extensions;
        public ExtensionsBasedFileSelector(final String[] extensions) {
            this.extensions = extensions;
        }
        @Override
        public boolean isSelected(final File file) {
            final String filename = file.getName();
            for (final String ext : extensions) {
                if (StringUtils.endsWithIgnoreCase(filename, ext)) {
                    return true;
                }
            }
            return false;
        }
        @Override
        public boolean shouldEnd() {
            return false;
        }
    }

    public static boolean getPlainLogs() {
        return getBoolean(R.string.pref_plainLogs, false);
    }

    public static boolean getUseNativeUa() {
        return getBoolean(R.string.pref_nativeUa, false);
    }

    public static String getCacheTwitterMessage() {
        return getString(R.string.pref_twitter_cache_message, "I found [NAME] ([URL]).");
    }

    public static String getTrackableTwitterMessage() {
        return getString(R.string.pref_twitter_trackable_message, "I touched [NAME] ([URL]).");
    }

    public static int getLogImageScale() {
        return getInt(R.string.pref_logImageScale, -1);
    }

    public static void setLogImageScale(final int scale) {
        putInt(R.string.pref_logImageScale, scale);
    }

    public static void setExcludeMine(final boolean exclude) {
        putBoolean(R.string.pref_excludemine, exclude);
    }

    static void setLogin(final String username, final String password) {
        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            // erase username and password
            remove(R.string.pref_username);
            remove(R.string.pref_password);
            return;
        }
        // save username and password
        putString(R.string.pref_username, username);
        putString(R.string.pref_password, password);
    }

    public static long getFieldnoteExportDate() {
        return getLong(R.string.pref_fieldNoteExportDate, 0);
    }

    /**
     * remember date of last field note export
     *
     * @param date
     */
    public static void setFieldnoteExportDate(final long date) {
        putLong(R.string.pref_fieldNoteExportDate, date);
    }

    public static boolean isUseNavigationApp(final NavigationAppsEnum navApp) {
        return getBoolean(navApp.preferenceKey, true);
    }

    /**
     * remember the state of the "Upload" checkbox in the field notes export dialog
     *
     * @param upload
     */
    public static void setFieldNoteExportUpload(final boolean upload) {
        putBoolean(R.string.pref_fieldNoteExportUpload, upload);
    }

    public static boolean getFieldNoteExportUpload() {
        return getBoolean(R.string.pref_fieldNoteExportUpload, true);
    }

    /**
     * remember the state of the "Only new" checkbox in the field notes export dialog
     *
     * @param onlyNew
     */
    public static void setFieldNoteExportOnlyNew(final boolean onlyNew) {
        putBoolean(R.string.pref_fieldNoteExportOnlyNew, onlyNew);
    }

    public static boolean getFieldNoteExportOnlyNew() {
        return getBoolean(R.string.pref_fieldNoteExportOnlyNew, false);
    }

    public static String getECIconSet() {
        return getString(R.string.pref_ec_icons, "1");
    }

    /* Store last checksum of changelog for changelog display */
    public static long getLastChangelogChecksum() {
        return getLong(R.string.pref_changelog_last_checksum, 0);
    }

    public static void setLastChangelogChecksum(final long checksum) {
        putLong(R.string.pref_changelog_last_checksum, checksum);
    }

    public static List<String> getLastOpenedCaches() {
        final List<String> history = Arrays.asList(StringUtils.split(getString(R.string.pref_caches_history, StringUtils.EMPTY), HISTORY_SEPARATOR));
        return history.subList(0, Math.min(HISTORY_SIZE, history.size()));
    }

    public static void addCacheToHistory(@NonNull final String geocode) {
        final ArrayList<String> history = new ArrayList<>(getLastOpenedCaches());
        // bring entry to front, if it already existed
        history.remove(geocode);
        history.add(0, geocode);
        putString(R.string.pref_caches_history, StringUtils.join(history, HISTORY_SEPARATOR));
    }

    public static boolean useHardwareAcceleration() {
        return getBoolean(R.string.pref_hardware_acceleration, !HW_ACCEL_DISABLED_BY_DEFAULT);
    }

    public static boolean setUseHardwareAcceleration(final boolean useHardwareAcceleration) {
        return putBoolean(R.string.pref_hardware_acceleration, useHardwareAcceleration);
    }

    public static String getLastCacheLog() {
        return getString(R.string.pref_last_cache_log, StringUtils.EMPTY);
    }

    public static void setLastCacheLog(final String log) {
        putString(R.string.pref_last_cache_log, log);
    }

    public static String getLastTrackableLog() {
        return getString(R.string.pref_last_trackable_log, StringUtils.EMPTY);
    }

    public static void setLastTrackableLog(final String log) {
        putString(R.string.pref_last_trackable_log, log);
    }
}
!@#$%
20190527_005351,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_a04176
package cgeo.geocaching.settings;

import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.R;
import cgeo.geocaching.apps.cache.navi.NavigationAppFactory.NavigationAppsEnum;
import cgeo.geocaching.connector.capability.ICredentials;
import cgeo.geocaching.connector.gc.GCConnector;
import cgeo.geocaching.connector.gc.GCConstants;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.LiveMapStrategy.Strategy;
import cgeo.geocaching.enumerations.LogType;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.list.StoredList;
import cgeo.geocaching.maps.MapProviderFactory;
import cgeo.geocaching.maps.google.v1.GoogleMapProvider;
import cgeo.geocaching.maps.interfaces.GeoPointImpl;
import cgeo.geocaching.maps.interfaces.MapProvider;
import cgeo.geocaching.maps.interfaces.MapSource;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider.OfflineMapSource;
import cgeo.geocaching.utils.CryptUtils;
import cgeo.geocaching.utils.FileUtils;
import cgeo.geocaching.utils.FileUtils.FileSelector;
import cgeo.geocaching.utils.Log;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.os.Build;
import android.os.Environment;
import android.preference.PreferenceManager;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;

/**
 * General c:geo preferences/settings set by the user
 */
public class Settings {

    private static final char HISTORY_SEPARATOR = ',';
    public static final int SHOW_WP_THRESHOLD_DEFAULT = 10;
    public static final int SHOW_WP_THRESHOLD_MAX = 50;
    private static final int MAP_SOURCE_DEFAULT = GoogleMapProvider.GOOGLE_MAP_ID.hashCode();

    public static final boolean HW_ACCEL_DISABLED_BY_DEFAULT =
            Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1 ||
            StringUtils.equals(Build.MODEL, "HTC One X") ||    // HTC One X
            StringUtils.equals(Build.MODEL, "HTC One S") ||    // HTC One S
            StringUtils.equals(Build.MODEL, "GT-I8190")  ||    // Samsung S3 mini
            StringUtils.equals(Build.MODEL, "GT-S6310L") ||    // Samsung Galaxy Young
            StringUtils.equals(Build.MODEL, "GT-P5210")  ||    // Samsung Galaxy Tab 3
            StringUtils.equals(Build.MODEL, "GT-S7580")  ||    // Samsung Galaxy Trend Plus
            StringUtils.equals(Build.MODEL, "GT-I9105P") ||    // Samsung Galaxy SII Plus
            StringUtils.equals(Build.MODEL, "ST25i")     ||    // Sony Xperia U
            StringUtils.equals(Build.MODEL, "bq Aquaris 5");   // bq Aquaris 5

    private final static int unitsMetric = 1;

    // twitter api keys
    private final static @NonNull String keyConsumerPublic = CryptUtils.rot13("ESnsCvAv3kEupF1GCR3jGj");
    private final static @NonNull String keyConsumerSecret = CryptUtils.rot13("7vQWceACV9umEjJucmlpFe9FCMZSeqIqfkQ2BnhV9x");

    public enum CoordInputFormatEnum {
        Plain,
        Deg,
        Min,
        Sec;

        static int DEFAULT_INT_VALUE = Min.ordinal();

        public static CoordInputFormatEnum fromInt(final int id) {
            final CoordInputFormatEnum[] values = CoordInputFormatEnum.values();
            if (id < 0 || id >= values.length) {
                return Min;
            }
            return values[id];
        }
    }

    private static final SharedPreferences sharedPrefs = PreferenceManager
            .getDefaultSharedPreferences(CgeoApplication.getInstance().getBaseContext());
    static {
        migrateSettings();
        final boolean isDebug = sharedPrefs.getBoolean(getKey(R.string.pref_debug), false);
        Log.setDebug(isDebug);
        CgeoApplication.dumpOnOutOfMemory(isDebug);
    }

    /**
     * Cache the mapsource locally. If that is an offline map source, each request would potentially access the
     * underlying map file, leading to delays.
     */
    private static MapSource mapSource;

    protected Settings() {
        throw new InstantiationError();
    }

    private static void migrateSettings() {
        // migrate from non standard file location and integer based boolean types
        final int oldVersion = getInt(R.string.pref_settingsversion, 0);
        if (oldVersion < 1) {
            final String oldPreferencesName = "cgeo.pref";
            final SharedPreferences old = CgeoApplication.getInstance().getSharedPreferences(oldPreferencesName, Context.MODE_PRIVATE);
            final Editor e = sharedPrefs.edit();

            e.putString(getKey(R.string.pref_temp_twitter_token_secret), old.getString(getKey(R.string.pref_temp_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_temp_twitter_token_public), old.getString(getKey(R.string.pref_temp_twitter_token_public), null));
            e.putBoolean(getKey(R.string.pref_help_shown), old.getInt(getKey(R.string.pref_help_shown), 0) != 0);
            e.putFloat(getKey(R.string.pref_anylongitude), old.getFloat(getKey(R.string.pref_anylongitude), 0));
            e.putFloat(getKey(R.string.pref_anylatitude), old.getFloat(getKey(R.string.pref_anylatitude), 0));
            e.putBoolean(getKey(R.string.pref_offlinemaps), 0 != old.getInt(getKey(R.string.pref_offlinemaps), 1));
            e.putBoolean(getKey(R.string.pref_offlinewpmaps), 0 != old.getInt(getKey(R.string.pref_offlinewpmaps), 0));
            e.putString(getKey(R.string.pref_webDeviceCode), old.getString(getKey(R.string.pref_webDeviceCode), null));
            e.putString(getKey(R.string.pref_webDeviceName), old.getString(getKey(R.string.pref_webDeviceName), null));
            e.putBoolean(getKey(R.string.pref_maplive), old.getInt(getKey(R.string.pref_maplive), 1) != 0);
            e.putInt(getKey(R.string.pref_mapsource), old.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT));
            e.putBoolean(getKey(R.string.pref_twitter), 0 != old.getInt(getKey(R.string.pref_twitter), 0));
            e.putBoolean(getKey(R.string.pref_showaddress), 0 != old.getInt(getKey(R.string.pref_showaddress), 1));
            e.putBoolean(getKey(R.string.pref_showcaptcha), old.getBoolean(getKey(R.string.pref_showcaptcha), false));
            e.putBoolean(getKey(R.string.pref_maptrail), old.getInt(getKey(R.string.pref_maptrail), 1) != 0);
            e.putInt(getKey(R.string.pref_lastmapzoom), old.getInt(getKey(R.string.pref_lastmapzoom), 14));
            e.putBoolean(getKey(R.string.pref_livelist), 0 != old.getInt(getKey(R.string.pref_livelist), 1));
            e.putBoolean(getKey(R.string.pref_units), old.getInt(getKey(R.string.pref_units), unitsMetric) == unitsMetric);
            e.putBoolean(getKey(R.string.pref_skin), old.getInt(getKey(R.string.pref_skin), 0) != 0);
            e.putInt(getKey(R.string.pref_lastusedlist), old.getInt(getKey(R.string.pref_lastusedlist), StoredList.STANDARD_LIST_ID));
            e.putString(getKey(R.string.pref_cachetype), old.getString(getKey(R.string.pref_cachetype), CacheType.ALL.id));
            e.putString(getKey(R.string.pref_twitter_token_secret), old.getString(getKey(R.string.pref_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_twitter_token_public), old.getString(getKey(R.string.pref_twitter_token_public), null));
            e.putInt(getKey(R.string.pref_version), old.getInt(getKey(R.string.pref_version), 0));
            e.putBoolean(getKey(R.string.pref_autoloaddesc), 0 != old.getInt(getKey(R.string.pref_autoloaddesc), 1));
            e.putBoolean(getKey(R.string.pref_ratingwanted), old.getBoolean(getKey(R.string.pref_ratingwanted), true));
            e.putBoolean(getKey(R.string.pref_friendlogswanted), old.getBoolean(getKey(R.string.pref_friendlogswanted), true));
            e.putBoolean(getKey(R.string.pref_useenglish), old.getBoolean(getKey(R.string.pref_useenglish), false));
            e.putBoolean(getKey(R.string.pref_usecompass), 0 != old.getInt(getKey(R.string.pref_usecompass), 1));
            e.putBoolean(getKey(R.string.pref_trackautovisit), old.getBoolean(getKey(R.string.pref_trackautovisit), false));
            e.putBoolean(getKey(R.string.pref_sigautoinsert), old.getBoolean(getKey(R.string.pref_sigautoinsert), false));
            e.putBoolean(getKey(R.string.pref_logimages), old.getBoolean(getKey(R.string.pref_logimages), false));
            e.putBoolean(getKey(R.string.pref_excludedisabled), 0 != old.getInt(getKey(R.string.pref_excludedisabled), 0));
            e.putBoolean(getKey(R.string.pref_excludemine), 0 != old.getInt(getKey(R.string.pref_excludemine), 0));
            e.putString(getKey(R.string.pref_mapfile), old.getString(getKey(R.string.pref_mapfile), null));
            e.putString(getKey(R.string.pref_signature), old.getString(getKey(R.string.pref_signature), null));
            e.putString(getKey(R.string.pref_pass_vote), old.getString(getKey(R.string.pref_pass_vote), null));
            e.putString(getKey(R.string.pref_password), old.getString(getKey(R.string.pref_password), null));
            e.putString(getKey(R.string.pref_username), old.getString(getKey(R.string.pref_username), null));
            e.putString(getKey(R.string.pref_memberstatus), old.getString(getKey(R.string.pref_memberstatus), ""));
            e.putInt(getKey(R.string.pref_coordinputformat), old.getInt(getKey(R.string.pref_coordinputformat), CoordInputFormatEnum.DEFAULT_INT_VALUE));
            e.putBoolean(getKey(R.string.pref_log_offline), old.getBoolean(getKey(R.string.pref_log_offline), false));
            e.putBoolean(getKey(R.string.pref_choose_list), old.getBoolean(getKey(R.string.pref_choose_list), true));
            e.putBoolean(getKey(R.string.pref_loaddirectionimg), old.getBoolean(getKey(R.string.pref_loaddirectionimg), true));
            e.putString(getKey(R.string.pref_gccustomdate), old.getString(getKey(R.string.pref_gccustomdate), GCConstants.DEFAULT_GC_DATE));
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), old.getInt(getKey(R.string.pref_showwaypointsthreshold), SHOW_WP_THRESHOLD_DEFAULT));
            e.putString(getKey(R.string.pref_cookiestore), old.getString(getKey(R.string.pref_cookiestore), null));
            e.putBoolean(getKey(R.string.pref_opendetailslastpage), old.getBoolean(getKey(R.string.pref_opendetailslastpage), false));
            e.putInt(getKey(R.string.pref_lastdetailspage), old.getInt(getKey(R.string.pref_lastdetailspage), 1));
            e.putInt(getKey(R.string.pref_defaultNavigationTool), old.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id));
            e.putInt(getKey(R.string.pref_defaultNavigationTool2), old.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id));
            e.putInt(getKey(R.string.pref_livemapstrategy), old.getInt(getKey(R.string.pref_livemapstrategy), Strategy.AUTO.id));
            e.putBoolean(getKey(R.string.pref_debug), old.getBoolean(getKey(R.string.pref_debug), false));
            e.putBoolean(getKey(R.string.pref_hidelivemaphint), old.getInt(getKey(R.string.pref_hidelivemaphint), 0) != 0);
            e.putInt(getKey(R.string.pref_livemaphintshowcount), old.getInt(getKey(R.string.pref_livemaphintshowcount), 0));

            e.putInt(getKey(R.string.pref_settingsversion), 1); // mark migrated
            e.commit();
        }

        // changes for new settings dialog
        if (oldVersion < 2) {
            final Editor e = sharedPrefs.edit();

            e.putBoolean(getKey(R.string.pref_units), !isUseImperialUnits());

            // show waypoints threshold now as a slider
            int wpThreshold = getWayPointsThreshold();
            if (wpThreshold < 0) {
                wpThreshold = 0;
            } else if (wpThreshold > SHOW_WP_THRESHOLD_MAX) {
                wpThreshold = SHOW_WP_THRESHOLD_MAX;
            }
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), wpThreshold);

            // KEY_MAP_SOURCE must be string, because it is the key for a ListPreference now
            final int ms = sharedPrefs.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT);
            e.remove(getKey(R.string.pref_mapsource));
            e.putString(getKey(R.string.pref_mapsource), String.valueOf(ms));

            // navigation tool ids must be string, because ListPreference uses strings as keys
            final int dnt1 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id);
            final int dnt2 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id);
            e.remove(getKey(R.string.pref_defaultNavigationTool));
            e.remove(getKey(R.string.pref_defaultNavigationTool2));
            e.putString(getKey(R.string.pref_defaultNavigationTool), String.valueOf(dnt1));
            e.putString(getKey(R.string.pref_defaultNavigationTool2), String.valueOf(dnt2));

            // defaults for gpx directories
            e.putString(getKey(R.string.pref_gpxImportDir), getGpxImportDir());
            e.putString(getKey(R.string.pref_gpxExportDir), getGpxExportDir());

            e.putInt(getKey(R.string.pref_settingsversion), 2); // mark migrated
            e.commit();
        }
    }

    private static String getKey(final int prefKeyId) {
        return CgeoApplication.getInstance().getString(prefKeyId);
    }

    static String getString(final int prefKeyId, final String defaultValue) {
        return sharedPrefs.getString(getKey(prefKeyId), defaultValue);
    }

    private static int getInt(final int prefKeyId, final int defaultValue) {
        return sharedPrefs.getInt(getKey(prefKeyId), defaultValue);
    }

    private static long getLong(final int prefKeyId, final long defaultValue) {
        return sharedPrefs.getLong(getKey(prefKeyId), defaultValue);
    }

    private static boolean getBoolean(final int prefKeyId, final boolean defaultValue) {
        return sharedPrefs.getBoolean(getKey(prefKeyId), defaultValue);
    }

    private static float getFloat(final int prefKeyId, final float defaultValue) {
        return sharedPrefs.getFloat(getKey(prefKeyId), defaultValue);
    }

    protected static boolean putString(final int prefKeyId, final String value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putString(getKey(prefKeyId), value);
        return edit.commit();
    }

    protected static boolean putBoolean(final int prefKeyId, final boolean value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putBoolean(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putInt(final int prefKeyId, final int value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putInt(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putLong(final int prefKeyId, final long value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putLong(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putFloat(final int prefKeyId, final float value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putFloat(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean remove(final int prefKeyId) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.remove(getKey(prefKeyId));
        return edit.commit();
    }

    private static boolean contains(final int prefKeyId) {
        return sharedPrefs.contains(getKey(prefKeyId));
    }

    public static void setLanguage(final boolean useEnglish) {
        final Configuration config = new Configuration();
        config.locale = useEnglish ? Locale.ENGLISH : Locale.getDefault();
        final Resources resources = CgeoApplication.getInstance().getResources();
        resources.updateConfiguration(config, resources.getDisplayMetrics());
    }

    public static boolean isLogin() {
        final String preUsername = getString(R.string.pref_username, null);
        final String prePassword = getString(R.string.pref_password, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    /**
     * Get login and password information of Geocaching.com.
     *
     * @return a pair either with (login, password) or (empty, empty) if no valid information is stored
     */
    public static ImmutablePair<String, String> getGcCredentials() {
        return getCredentials(GCConnector.getInstance());
    }

    /**
     * Get login and password information.
     *
     * @return a pair either with (login, password) or (empty, empty) if no valid information is stored
     */
    public static ImmutablePair<String, String> getCredentials(final @NonNull ICredentials connector) {
        final String username = getString(connector.getUsernamePreferenceKey(), null);
        final String password = getString(connector.getPasswordPreferenceKey(), null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return new ImmutablePair<>(StringUtils.EMPTY, StringUtils.EMPTY);
        }

        return new ImmutablePair<>(username, password);
    }

    public static String getUsername() {
        return getString(R.string.pref_username, null);
    }

    public static boolean isGCConnectorActive() {
        return getBoolean(R.string.pref_connectorGCActive, true);
    }

    public static boolean isECConnectorActive() {
        return getBoolean(R.string.pref_connectorECActive, false);
    }

    public static boolean isOXConnectorActive() {
        return getBoolean(R.string.pref_connectorOXActive, false);
    }

    public static boolean isGCPremiumMember() {
        // Basic Member, Premium Member, ???
        return GCConstants.MEMBER_STATUS_PM.equalsIgnoreCase(Settings.getGCMemberStatus());
    }

    public static String getGCMemberStatus() {
        return getString(R.string.pref_memberstatus, "");
    }

    public static boolean setGCMemberStatus(final String memberStatus) {
        if (StringUtils.isBlank(memberStatus)) {
            return remove(R.string.pref_memberstatus);
        }
        return putString(R.string.pref_memberstatus, memberStatus);
    }

    public static ImmutablePair<String, String> getTokenPair(final int tokenPublicPrefKey, final int tokenSecretPrefKey) {
        return new ImmutablePair<>(getString(tokenPublicPrefKey, null), getString(tokenSecretPrefKey, null));
    }

    public static void setTokens(final int tokenPublicPrefKey, @Nullable final String tokenPublic, final int tokenSecretPrefKey, @Nullable final String tokenSecret) {
        if (tokenPublic == null) {
            remove(tokenPublicPrefKey);
        } else {
            putString(tokenPublicPrefKey, tokenPublic);
        }
        if (tokenSecret == null) {
            remove(tokenSecretPrefKey);
        } else {
            putString(tokenSecretPrefKey, tokenSecret);
        }
    }

    public static boolean isOCConnectorActive(final int isActivePrefKeyId) {
        return getBoolean(isActivePrefKeyId, false);
    }

    public static boolean hasOCAuthorization(final int tokenPublicPrefKeyId, final int tokenSecretPrefKeyId) {
        return StringUtils.isNotBlank(getString(tokenPublicPrefKeyId, ""))
                && StringUtils.isNotBlank(getString(tokenSecretPrefKeyId, ""));
    }

    public static boolean isGCvoteLogin() {
        final String preUsername = getString(R.string.pref_username, null);
        final String prePassword = getString(R.string.pref_pass_vote, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    public static ImmutablePair<String, String> getGCvoteLogin() {
        final String username = getString(R.string.pref_username, null);
        final String password = getString(R.string.pref_pass_vote, null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return null;
        }

        return new ImmutablePair<>(username, password);
    }

    public static String getSignature() {
        return getString(R.string.pref_signature, StringUtils.EMPTY);
    }

    public static boolean setCookieStore(final String cookies) {
        if (StringUtils.isBlank(cookies)) {
            // erase cookies
            return remove(R.string.pref_cookiestore);
        }
        // save cookies
        return putString(R.string.pref_cookiestore, cookies);
    }

    public static String getCookieStore() {
        return getString(R.string.pref_cookiestore, null);
    }

    /**
     * @param cacheType
     *            The cache type used for future filtering
     */
    public static void setCacheType(final CacheType cacheType) {
        if (cacheType == null) {
            remove(R.string.pref_cachetype);
        } else {
            putString(R.string.pref_cachetype, cacheType.id);
        }
    }

    public static int getLastList() {
        return getInt(R.string.pref_lastusedlist, StoredList.STANDARD_LIST_ID);
    }

    public static void saveLastList(final int listId) {
        putInt(R.string.pref_lastusedlist, listId);
    }

    public static void setWebNameCode(final String name, final String code) {
        putString(R.string.pref_webDeviceName, name);
        putString(R.string.pref_webDeviceCode, code);
    }

    public static MapProvider getMapProvider() {
        return getMapSource().getMapProvider();
    }

    public static String getMapFile() {
        return getString(R.string.pref_mapfile, null);
    }

    public static boolean setMapFile(final String mapFile) {
        final boolean result = putString(R.string.pref_mapfile, mapFile);
        if (mapFile != null) {
            setMapFileDirectory(new File(mapFile).getParent());
        }
        return result;
    }

    public static String getMapFileDirectory() {
        final String mapDir = getString(R.string.pref_mapDirectory, null);
        if (mapDir != null) {
            return mapDir;
        }
        final String mapFile = getMapFile();
        if (mapFile != null) {
            return new File(mapFile).getParent();
        }
        return null;
    }

    public static boolean setMapFileDirectory(final String mapFileDirectory) {
        final boolean result = putString(R.string.pref_mapDirectory, mapFileDirectory);
        MapsforgeMapProvider.getInstance().updateOfflineMaps();
        return result;
    }

    public static boolean isValidMapFile() {
        return isValidMapFile(getMapFile());
    }

    public static boolean isValidMapFile(final String mapFileIn) {
        return MapsforgeMapProvider.isValidMapFile(mapFileIn);
    }

    public static boolean isScaleMapsforgeText() {
        return getBoolean(R.string.pref_mapsforge_scale_text, true);
    }

    public static CoordInputFormatEnum getCoordInputFormat() {
        return CoordInputFormatEnum.fromInt(getInt(R.string.pref_coordinputformat, CoordInputFormatEnum.DEFAULT_INT_VALUE));
    }

    public static void setCoordInputFormat(final CoordInputFormatEnum format) {
        putInt(R.string.pref_coordinputformat, format.ordinal());
    }

    public static boolean getLogOffline() {
        return getBoolean(R.string.pref_log_offline, false);
    }

    public static boolean getChooseList() {
        return getBoolean(R.string.pref_choose_list, false);
    }

    public static boolean getLoadDirImg() {
        return !isGCPremiumMember() && getBoolean(R.string.pref_loaddirectionimg, true);
    }

    public static void setGcCustomDate(final String format) {
        putString(R.string.pref_gccustomdate, format);
    }

    /**
     * @return User selected date format on GC.com
     */
    public static String getGcCustomDate() {
        // We might have some users whose stored value is null, which is invalid. In this case, we use the default.
        return StringUtils.defaultString(getString(R.string.pref_gccustomdate, GCConstants.DEFAULT_GC_DATE),
                GCConstants.DEFAULT_GC_DATE);
    }

    public static boolean isExcludeMyCaches() {
        return getBoolean(R.string.pref_excludemine, false);
    }

    public static boolean isUseEnglish() {
        return getBoolean(R.string.pref_useenglish, false);
    }

    public static boolean isShowAddress() {
        return getBoolean(R.string.pref_showaddress, true);
    }

    public static boolean isShowCaptcha() {
        return !isGCPremiumMember() && getBoolean(R.string.pref_showcaptcha, false);
    }

    public static boolean isExcludeDisabledCaches() {
        return getBoolean(R.string.pref_excludedisabled, false);
    }

    public static boolean isStoreOfflineMaps() {
        return getBoolean(R.string.pref_offlinemaps, true);
    }

    public static boolean isStoreOfflineWpMaps() {
        return getBoolean(R.string.pref_offlinewpmaps, false);
    }

    public static boolean isStoreLogImages() {
        return getBoolean(R.string.pref_logimages, false);
    }

    public static boolean isAutoLoadDescription() {
        return getBoolean(R.string.pref_autoloaddesc, true);
    }

    public static boolean isRatingWanted() {
        return getBoolean(R.string.pref_ratingwanted, true);
    }

    public static boolean isFriendLogsWanted() {
        if (!isLogin()) {
            // don't show a friends log if the user is anonymous
            return false;
        }
        return getBoolean(R.string.pref_friendlogswanted, true);
    }

    public static boolean isLiveList() {
        return getBoolean(R.string.pref_livelist, true);
    }

    public static boolean isTrackableAutoVisit() {
        return getBoolean(R.string.pref_trackautovisit, false);
    }

    public static boolean isAutoInsertSignature() {
        return getBoolean(R.string.pref_sigautoinsert, false);
    }

    public static boolean isUseImperialUnits() {
        return getBoolean(R.string.pref_units, getImperialUnitsDefault());
    }

    static boolean getImperialUnitsDefault() {
        final String countryCode = Locale.getDefault().getCountry();
        return "US".equals(countryCode)  // USA
            || "LR".equals(countryCode)  // Liberia
            || "MM".equals(countryCode); // Burma
    }

    public static boolean isLiveMap() {
        return getBoolean(R.string.pref_maplive, true);
    }

    public static void setLiveMap(final boolean live) {
        putBoolean(R.string.pref_maplive, live);
    }

    public static boolean isMapTrail() {
        return getBoolean(R.string.pref_maptrail, true);
    }

    public static void setMapTrail(final boolean showTrail) {
        putBoolean(R.string.pref_maptrail, showTrail);
    }

    public static int getMapZoom() {
        return getInt(R.string.pref_lastmapzoom, 14);
    }

    public static void setMapZoom(final int mapZoomLevel) {
        putInt(R.string.pref_lastmapzoom, mapZoomLevel);
    }

    public static GeoPointImpl getMapCenter() {
        return getMapProvider().getMapItemFactory()
                .getGeoPointBase(new Geopoint(getInt(R.string.pref_lastmaplat, 0) / 1e6,
                        getInt(R.string.pref_lastmaplon, 0) / 1e6));
    }

    public static void setMapCenter(final GeoPointImpl mapViewCenter) {
        putInt(R.string.pref_lastmaplat, mapViewCenter.getLatitudeE6());
        putInt(R.string.pref_lastmaplon, mapViewCenter.getLongitudeE6());
    }

    @NonNull
    public static synchronized MapSource getMapSource() {
        if (mapSource != null) {
            return mapSource;
        }
        final int id = getConvertedMapId();
        mapSource = MapProviderFactory.getMapSource(id);
        if (mapSource != null) {
            // don't use offline maps if the map file is not valid
            if ((!(mapSource instanceof OfflineMapSource)) || (isValidMapFile())) {
                return mapSource;
            }
        }
        // fallback to first available map
        return MapProviderFactory.getDefaultSource();
    }

    private final static int GOOGLEMAP_BASEID = 30;
    private final static int MAP = 1;
    private final static int SATELLITE = 2;

    private final static int MFMAP_BASEID = 40;
    private final static int MAPNIK = 1;
    private final static int CYCLEMAP = 3;
    private final static int OFFLINE = 4;
    private static final int HISTORY_SIZE = 10;

    /**
     * convert old preference ids for maps (based on constant values) into new hash based ids
     *
     * @return
     */
    private static int getConvertedMapId() {
        final int id = Integer.parseInt(getString(R.string.pref_mapsource,
                String.valueOf(MAP_SOURCE_DEFAULT)));
        switch (id) {
            case GOOGLEMAP_BASEID + MAP:
                return GoogleMapProvider.GOOGLE_MAP_ID.hashCode();
            case GOOGLEMAP_BASEID + SATELLITE:
                return GoogleMapProvider.GOOGLE_SATELLITE_ID.hashCode();
            case MFMAP_BASEID + MAPNIK:
                return MapsforgeMapProvider.MAPSFORGE_MAPNIK_ID.hashCode();
            case MFMAP_BASEID + CYCLEMAP:
                return MapsforgeMapProvider.MAPSFORGE_CYCLEMAP_ID.hashCode();
            case MFMAP_BASEID + OFFLINE: {
                final String mapFile = Settings.getMapFile();
                if (StringUtils.isNotEmpty(mapFile)) {
                    return mapFile.hashCode();
                }
                break;
            }
            default:
                break;
        }
        return id;
    }

    public static void setMapSource(final MapSource newMapSource) {
        putString(R.string.pref_mapsource, String.valueOf(newMapSource.getNumericalId()));
        if (newMapSource instanceof OfflineMapSource) {
            setMapFile(((OfflineMapSource) newMapSource).getFileName());
        }
        // cache the value
        mapSource = newMapSource;
    }

    public static void setAnyCoordinates(final Geopoint coords) {
        if (null != coords) {
            putFloat(R.string.pref_anylatitude, (float) coords.getLatitude());
            putFloat(R.string.pref_anylongitude, (float) coords.getLongitude());
        } else {
            remove(R.string.pref_anylatitude);
            remove(R.string.pref_anylongitude);
        }
    }

    public static Geopoint getAnyCoordinates() {
        if (contains(R.string.pref_anylatitude) && contains(R.string.pref_anylongitude)) {
            final float lat = getFloat(R.string.pref_anylatitude, 0);
            final float lon = getFloat(R.string.pref_anylongitude, 0);
            return new Geopoint(lat, lon);
        }
        return null;
    }

    public static boolean isUseCompass() {
        return getBoolean(R.string.pref_usecompass, true);
    }

    public static void setUseCompass(final boolean useCompass) {
        putBoolean(R.string.pref_usecompass, useCompass);
    }

    public static boolean isLightSkin() {
        return getBoolean(R.string.pref_skin, false);
    }

    @NonNull
    public static String getKeyConsumerPublic() {
        return keyConsumerPublic;
    }

    @NonNull
    public static String getKeyConsumerSecret() {
        return keyConsumerSecret;
    }

    public static String getWebDeviceCode() {
        return getString(R.string.pref_webDeviceCode, null);
    }

    public static boolean isRegisteredForSend2cgeo() {
        return getWebDeviceCode() != null;
    }

    public static String getWebDeviceName() {
        return getString(R.string.pref_webDeviceName, android.os.Build.MODEL);
    }

    /**
     * @return The cache type used for filtering or ALL if no filter is active.
     *         Returns never null
     */
    public static CacheType getCacheType() {
        return CacheType.getById(getString(R.string.pref_cachetype, CacheType.ALL.id));
    }

    /**
     * The Threshold for the showing of child waypoints
     */
    public static int getWayPointsThreshold() {
        return getInt(R.string.pref_showwaypointsthreshold, SHOW_WP_THRESHOLD_DEFAULT);
    }

    public static void setShowWaypointsThreshold(final int threshold) {
        putInt(R.string.pref_showwaypointsthreshold, threshold);
    }

    public static boolean isUseTwitter() {
        return getBoolean(R.string.pref_twitter, false);
    }

    public static void setUseTwitter(final boolean useTwitter) {
        putBoolean(R.string.pref_twitter, useTwitter);
    }

    public static boolean isTwitterLoginValid() {
        return !StringUtils.isBlank(getTokenPublic())
                && !StringUtils.isBlank(getTokenSecret());
    }

    public static String getTokenPublic() {
        return getString(R.string.pref_twitter_token_public, null);
    }

    public static String getTokenSecret() {
        return getString(R.string.pref_twitter_token_secret, null);

    }

    public static boolean hasTwitterAuthorization() {
        return StringUtils.isNotBlank(getTokenPublic())
                && StringUtils.isNotBlank(getTokenSecret());
    }

    public static void setTwitterTokens(@Nullable final String tokenPublic,
            @Nullable final String tokenSecret, final boolean enableTwitter) {
        putString(R.string.pref_twitter_token_public, tokenPublic);
        putString(R.string.pref_twitter_token_secret, tokenSecret);
        if (tokenPublic != null) {
            remove(R.string.pref_temp_twitter_token_public);
            remove(R.string.pref_temp_twitter_token_secret);
        }
        setUseTwitter(enableTwitter);
    }

    public static void setTwitterTempTokens(@Nullable final String tokenPublic,
            @Nullable final String tokenSecret) {
        putString(R.string.pref_temp_twitter_token_public, tokenPublic);
        putString(R.string.pref_temp_twitter_token_secret, tokenSecret);
    }

    public static ImmutablePair<String, String> getTempToken() {
        final String tokenPublic = getString(R.string.pref_temp_twitter_token_public, null);
        final String tokenSecret = getString(R.string.pref_temp_twitter_token_secret, null);
        return new ImmutablePair<>(tokenPublic, tokenSecret);
    }

    public static int getVersion() {
        return getInt(R.string.pref_version, 0);
    }

    public static void setVersion(final int version) {
        putInt(R.string.pref_version, version);
    }

    public static boolean isOpenLastDetailsPage() {
        return getBoolean(R.string.pref_opendetailslastpage, false);
    }

    public static int getLastDetailsPage() {
        return getInt(R.string.pref_lastdetailspage, 1);
    }

    public static void setLastDetailsPage(final int index) {
        putInt(R.string.pref_lastdetailspage, index);
    }

    public static int getDefaultNavigationTool() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool,
                String.valueOf(NavigationAppsEnum.COMPASS.id)));
    }

    public static int getDefaultNavigationTool2() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool2,
                String.valueOf(NavigationAppsEnum.INTERNAL_MAP.id)));
    }

    public static Strategy getLiveMapStrategy() {
        return Strategy.getById(getInt(R.string.pref_livemapstrategy, Strategy.AUTO.id));
    }

    public static void setLiveMapStrategy(final Strategy strategy) {
        putInt(R.string.pref_livemapstrategy, strategy.id);
    }

    public static boolean isDebug() {
        return Log.isDebug();
    }

    public static boolean getHideLiveMapHint() {
        return getBoolean(R.string.pref_hidelivemaphint, false);
    }

    public static void setHideLiveHint(final boolean hide) {
        putBoolean(R.string.pref_hidelivemaphint, hide);
    }

    public static int getLiveMapHintShowCount() {
        return getInt(R.string.pref_livemaphintshowcount, 0);
    }

    public static void setLiveMapHintShowCount(final int showCount) {
        putInt(R.string.pref_livemaphintshowcount, showCount);
    }

    public static boolean isDbOnSDCard() {
        return getBoolean(R.string.pref_dbonsdcard, false);
    }

    public static void setDbOnSDCard(final boolean dbOnSDCard) {
        putBoolean(R.string.pref_dbonsdcard, dbOnSDCard);
    }

    public static String getGpxExportDir() {
        return getString(R.string.pref_gpxExportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static String getGpxImportDir() {
        return getString(R.string.pref_gpxImportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static boolean getShareAfterExport() {
        return getBoolean(R.string.pref_shareafterexport, true);
    }

    public static void setShareAfterExport(final boolean shareAfterExport) {
        putBoolean(R.string.pref_shareafterexport, shareAfterExport);
    }

    public static int getTrackableAction() {
        return getInt(R.string.pref_trackableaction, LogType.RETRIEVED_IT.id);
    }

    public static void setTrackableAction(final int trackableAction) {
        putInt(R.string.pref_trackableaction, trackableAction);
    }

    public static String getCustomRenderThemeBaseFolder() {
        return getString(R.string.pref_renderthemepath, "");
    }

    public static String getCustomRenderThemeFilePath() {
        return getString(R.string.pref_renderthemefile, "");
    }

    public static void setCustomRenderThemeFile(final String customRenderThemeFile) {
        putString(R.string.pref_renderthemefile, customRenderThemeFile);
    }

    public static File[] getMapThemeFiles() {
        final File directory = new File(Settings.getCustomRenderThemeBaseFolder());
        final List<File> result = new ArrayList<>();
        FileUtils.listDir(result, directory, new ExtensionsBasedFileSelector(new String[] { "xml" }), null);

        return result.toArray(new File[result.size()]);
    }

    private static class ExtensionsBasedFileSelector extends FileSelector {
        private final String[] extensions;
        public ExtensionsBasedFileSelector(final String[] extensions) {
            this.extensions = extensions;
        }
        @Override
        public boolean isSelected(final File file) {
            final String filename = file.getName();
            for (final String ext : extensions) {
                if (StringUtils.endsWithIgnoreCase(filename, ext)) {
                    return true;
                }
            }
            return false;
        }
        @Override
        public boolean shouldEnd() {
            return false;
        }
    }

    public static boolean getPlainLogs() {
        return getBoolean(R.string.pref_plainLogs, false);
    }

    public static boolean getUseNativeUa() {
        return getBoolean(R.string.pref_nativeUa, false);
    }

    public static String getCacheTwitterMessage() {
        return getString(R.string.pref_twitter_cache_message, "I found [NAME] ([URL]).");
    }

    public static String getTrackableTwitterMessage() {
        return getString(R.string.pref_twitter_trackable_message, "I touched [NAME] ([URL]).");
    }

    public static int getLogImageScale() {
        return getInt(R.string.pref_logImageScale, -1);
    }

    public static void setLogImageScale(final int scale) {
        putInt(R.string.pref_logImageScale, scale);
    }

    public static void setExcludeMine(final boolean exclude) {
        putBoolean(R.string.pref_excludemine, exclude);
    }

    static void setLogin(final String username, final String password) {
        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            // erase username and password
            remove(R.string.pref_username);
            remove(R.string.pref_password);
            return;
        }
        // save username and password
        putString(R.string.pref_username, username);
        putString(R.string.pref_password, password);
    }

    public static long getFieldnoteExportDate() {
        return getLong(R.string.pref_fieldNoteExportDate, 0);
    }

    /**
     * remember date of last field note export
     *
     * @param date
     */
    public static void setFieldnoteExportDate(final long date) {
        putLong(R.string.pref_fieldNoteExportDate, date);
    }

    public static boolean isUseNavigationApp(final NavigationAppsEnum navApp) {
        return getBoolean(navApp.preferenceKey, true);
    }

    /**
     * remember the state of the "Upload" checkbox in the field notes export dialog
     *
     * @param upload
     */
    public static void setFieldNoteExportUpload(final boolean upload) {
        putBoolean(R.string.pref_fieldNoteExportUpload, upload);
    }

    public static boolean getFieldNoteExportUpload() {
        return getBoolean(R.string.pref_fieldNoteExportUpload, true);
    }

    /**
     * remember the state of the "Only new" checkbox in the field notes export dialog
     *
     * @param onlyNew
     */
    public static void setFieldNoteExportOnlyNew(final boolean onlyNew) {
        putBoolean(R.string.pref_fieldNoteExportOnlyNew, onlyNew);
    }

    public static boolean getFieldNoteExportOnlyNew() {
        return getBoolean(R.string.pref_fieldNoteExportOnlyNew, false);
    }

    public static String getECIconSet() {
        return getString(R.string.pref_ec_icons, "1");
    }

    /* Store last checksum of changelog for changelog display */
    public static long getLastChangelogChecksum() {
        return getLong(R.string.pref_changelog_last_checksum, 0);
    }

    public static void setLastChangelogChecksum(final long checksum) {
        putLong(R.string.pref_changelog_last_checksum, checksum);
    }

    public static List<String> getLastOpenedCaches() {
        final List<String> history = Arrays.asList(StringUtils.split(getString(R.string.pref_caches_history, StringUtils.EMPTY), HISTORY_SEPARATOR));
        return history.subList(0, Math.min(HISTORY_SIZE, history.size()));
    }

    public static void addCacheToHistory(@NonNull final String geocode) {
        final ArrayList<String> history = new ArrayList<>(getLastOpenedCaches());
        // bring entry to front, if it already existed
        history.remove(geocode);
        history.add(0, geocode);
        putString(R.string.pref_caches_history, StringUtils.join(history, HISTORY_SEPARATOR));
    }

    public static boolean useHardwareAcceleration() {
        return getBoolean(R.string.pref_hardware_acceleration, !HW_ACCEL_DISABLED_BY_DEFAULT);
    }

    public static boolean setUseHardwareAcceleration(final boolean useHardwareAcceleration) {
        return putBoolean(R.string.pref_hardware_acceleration, useHardwareAcceleration);
    }
}
!@#$%
20190527_005351,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_c04176
package cgeo.geocaching.settings;

import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.R;
import cgeo.geocaching.apps.cache.navi.NavigationAppFactory.NavigationAppsEnum;
import cgeo.geocaching.connector.capability.ICredentials;
import cgeo.geocaching.connector.gc.GCConnector;
import cgeo.geocaching.connector.gc.GCConstants;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.LiveMapStrategy.Strategy;
import cgeo.geocaching.enumerations.LogType;
import cgeo.geocaching.geopoint.Geopoint;
import cgeo.geocaching.list.StoredList;
import cgeo.geocaching.maps.MapProviderFactory;
import cgeo.geocaching.maps.google.v1.GoogleMapProvider;
import cgeo.geocaching.maps.interfaces.GeoPointImpl;
import cgeo.geocaching.maps.interfaces.MapProvider;
import cgeo.geocaching.maps.interfaces.MapSource;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider.OfflineMapSource;
import cgeo.geocaching.utils.CryptUtils;
import cgeo.geocaching.utils.FileUtils;
import cgeo.geocaching.utils.FileUtils.FileSelector;
import cgeo.geocaching.utils.Log;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.os.Build;
import android.os.Environment;
import android.preference.PreferenceManager;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;

/**
 * General c:geo preferences/settings set by the user
 */
public class Settings {

    private static final char HISTORY_SEPARATOR = ',';
    public static final int SHOW_WP_THRESHOLD_DEFAULT = 10;
    public static final int SHOW_WP_THRESHOLD_MAX = 50;
    private static final int MAP_SOURCE_DEFAULT = GoogleMapProvider.GOOGLE_MAP_ID.hashCode();

    public static final boolean HW_ACCEL_DISABLED_BY_DEFAULT =
            Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1 ||
            StringUtils.equals(Build.MODEL, "HTC One X") ||    // HTC One X
            StringUtils.equals(Build.MODEL, "HTC One S") ||    // HTC One S
            StringUtils.equals(Build.MODEL, "GT-I8190")  ||    // Samsung S3 mini
            StringUtils.equals(Build.MODEL, "GT-S6310L") ||    // Samsung Galaxy Young
            StringUtils.equals(Build.MODEL, "GT-P5210")  ||    // Samsung Galaxy Tab 3
            StringUtils.equals(Build.MODEL, "GT-S7580")  ||    // Samsung Galaxy Trend Plus
            StringUtils.equals(Build.MODEL, "GT-I9105P") ||    // Samsung Galaxy SII Plus
            StringUtils.equals(Build.MODEL, "ST25i")     ||    // Sony Xperia U
            StringUtils.equals(Build.MODEL, "bq Aquaris 5");   // bq Aquaris 5

    private final static int unitsMetric = 1;

    // twitter api keys
    private final static @NonNull String keyConsumerPublic = CryptUtils.rot13("ESnsCvAv3kEupF1GCR3jGj");
    private final static @NonNull String keyConsumerSecret = CryptUtils.rot13("7vQWceACV9umEjJucmlpFe9FCMZSeqIqfkQ2BnhV9x");

    public enum CoordInputFormatEnum {
        Plain,
        Deg,
        Min,
        Sec;

        static int DEFAULT_INT_VALUE = Min.ordinal();

        public static CoordInputFormatEnum fromInt(final int id) {
            final CoordInputFormatEnum[] values = CoordInputFormatEnum.values();
            if (id < 0 || id >= values.length) {
                return Min;
            }
            return values[id];
        }
    }

    private static final SharedPreferences sharedPrefs = PreferenceManager
            .getDefaultSharedPreferences(CgeoApplication.getInstance().getBaseContext());
    static {
        migrateSettings();
        final boolean isDebug = sharedPrefs.getBoolean(getKey(R.string.pref_debug), false);
        Log.setDebug(isDebug);
        CgeoApplication.dumpOnOutOfMemory(isDebug);
    }

    /**
     * Cache the mapsource locally. If that is an offline map source, each request would potentially access the
     * underlying map file, leading to delays.
     */
    private static MapSource mapSource;

    protected Settings() {
        throw new InstantiationError();
    }

    private static void migrateSettings() {
        // migrate from non standard file location and integer based boolean types
        final int oldVersion = getInt(R.string.pref_settingsversion, 0);
        if (oldVersion < 1) {
            final String oldPreferencesName = "cgeo.pref";
            final SharedPreferences old = CgeoApplication.getInstance().getSharedPreferences(oldPreferencesName, Context.MODE_PRIVATE);
            final Editor e = sharedPrefs.edit();

            e.putString(getKey(R.string.pref_temp_twitter_token_secret), old.getString(getKey(R.string.pref_temp_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_temp_twitter_token_public), old.getString(getKey(R.string.pref_temp_twitter_token_public), null));
            e.putBoolean(getKey(R.string.pref_help_shown), old.getInt(getKey(R.string.pref_help_shown), 0) != 0);
            e.putFloat(getKey(R.string.pref_anylongitude), old.getFloat(getKey(R.string.pref_anylongitude), 0));
            e.putFloat(getKey(R.string.pref_anylatitude), old.getFloat(getKey(R.string.pref_anylatitude), 0));
            e.putBoolean(getKey(R.string.pref_offlinemaps), 0 != old.getInt(getKey(R.string.pref_offlinemaps), 1));
            e.putBoolean(getKey(R.string.pref_offlinewpmaps), 0 != old.getInt(getKey(R.string.pref_offlinewpmaps), 0));
            e.putString(getKey(R.string.pref_webDeviceCode), old.getString(getKey(R.string.pref_webDeviceCode), null));
            e.putString(getKey(R.string.pref_webDeviceName), old.getString(getKey(R.string.pref_webDeviceName), null));
            e.putBoolean(getKey(R.string.pref_maplive), old.getInt(getKey(R.string.pref_maplive), 1) != 0);
            e.putInt(getKey(R.string.pref_mapsource), old.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT));
            e.putBoolean(getKey(R.string.pref_twitter), 0 != old.getInt(getKey(R.string.pref_twitter), 0));
            e.putBoolean(getKey(R.string.pref_showaddress), 0 != old.getInt(getKey(R.string.pref_showaddress), 1));
            e.putBoolean(getKey(R.string.pref_showcaptcha), old.getBoolean(getKey(R.string.pref_showcaptcha), false));
            e.putBoolean(getKey(R.string.pref_maptrail), old.getInt(getKey(R.string.pref_maptrail), 1) != 0);
            e.putInt(getKey(R.string.pref_lastmapzoom), old.getInt(getKey(R.string.pref_lastmapzoom), 14));
            e.putBoolean(getKey(R.string.pref_livelist), 0 != old.getInt(getKey(R.string.pref_livelist), 1));
            e.putBoolean(getKey(R.string.pref_units), old.getInt(getKey(R.string.pref_units), unitsMetric) == unitsMetric);
            e.putBoolean(getKey(R.string.pref_skin), old.getInt(getKey(R.string.pref_skin), 0) != 0);
            e.putInt(getKey(R.string.pref_lastusedlist), old.getInt(getKey(R.string.pref_lastusedlist), StoredList.STANDARD_LIST_ID));
            e.putString(getKey(R.string.pref_cachetype), old.getString(getKey(R.string.pref_cachetype), CacheType.ALL.id));
            e.putString(getKey(R.string.pref_twitter_token_secret), old.getString(getKey(R.string.pref_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_twitter_token_public), old.getString(getKey(R.string.pref_twitter_token_public), null));
            e.putInt(getKey(R.string.pref_version), old.getInt(getKey(R.string.pref_version), 0));
            e.putBoolean(getKey(R.string.pref_autoloaddesc), 0 != old.getInt(getKey(R.string.pref_autoloaddesc), 1));
            e.putBoolean(getKey(R.string.pref_ratingwanted), old.getBoolean(getKey(R.string.pref_ratingwanted), true));
            e.putBoolean(getKey(R.string.pref_friendlogswanted), old.getBoolean(getKey(R.string.pref_friendlogswanted), true));
            e.putBoolean(getKey(R.string.pref_useenglish), old.getBoolean(getKey(R.string.pref_useenglish), false));
            e.putBoolean(getKey(R.string.pref_usecompass), 0 != old.getInt(getKey(R.string.pref_usecompass), 1));
            e.putBoolean(getKey(R.string.pref_trackautovisit), old.getBoolean(getKey(R.string.pref_trackautovisit), false));
            e.putBoolean(getKey(R.string.pref_sigautoinsert), old.getBoolean(getKey(R.string.pref_sigautoinsert), false));
            e.putBoolean(getKey(R.string.pref_logimages), old.getBoolean(getKey(R.string.pref_logimages), false));
            e.putBoolean(getKey(R.string.pref_excludedisabled), 0 != old.getInt(getKey(R.string.pref_excludedisabled), 0));
            e.putBoolean(getKey(R.string.pref_excludemine), 0 != old.getInt(getKey(R.string.pref_excludemine), 0));
            e.putString(getKey(R.string.pref_mapfile), old.getString(getKey(R.string.pref_mapfile), null));
            e.putString(getKey(R.string.pref_signature), old.getString(getKey(R.string.pref_signature), null));
            e.putString(getKey(R.string.pref_pass_vote), old.getString(getKey(R.string.pref_pass_vote), null));
            e.putString(getKey(R.string.pref_password), old.getString(getKey(R.string.pref_password), null));
            e.putString(getKey(R.string.pref_username), old.getString(getKey(R.string.pref_username), null));
            e.putString(getKey(R.string.pref_memberstatus), old.getString(getKey(R.string.pref_memberstatus), ""));
            e.putInt(getKey(R.string.pref_coordinputformat), old.getInt(getKey(R.string.pref_coordinputformat), CoordInputFormatEnum.DEFAULT_INT_VALUE));
            e.putBoolean(getKey(R.string.pref_log_offline), old.getBoolean(getKey(R.string.pref_log_offline), false));
            e.putBoolean(getKey(R.string.pref_choose_list), old.getBoolean(getKey(R.string.pref_choose_list), true));
            e.putBoolean(getKey(R.string.pref_loaddirectionimg), old.getBoolean(getKey(R.string.pref_loaddirectionimg), true));
            e.putString(getKey(R.string.pref_gccustomdate), old.getString(getKey(R.string.pref_gccustomdate), GCConstants.DEFAULT_GC_DATE));
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), old.getInt(getKey(R.string.pref_showwaypointsthreshold), SHOW_WP_THRESHOLD_DEFAULT));
            e.putString(getKey(R.string.pref_cookiestore), old.getString(getKey(R.string.pref_cookiestore), null));
            e.putBoolean(getKey(R.string.pref_opendetailslastpage), old.getBoolean(getKey(R.string.pref_opendetailslastpage), false));
            e.putInt(getKey(R.string.pref_lastdetailspage), old.getInt(getKey(R.string.pref_lastdetailspage), 1));
            e.putInt(getKey(R.string.pref_defaultNavigationTool), old.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id));
            e.putInt(getKey(R.string.pref_defaultNavigationTool2), old.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id));
            e.putInt(getKey(R.string.pref_livemapstrategy), old.getInt(getKey(R.string.pref_livemapstrategy), Strategy.AUTO.id));
            e.putBoolean(getKey(R.string.pref_debug), old.getBoolean(getKey(R.string.pref_debug), false));
            e.putBoolean(getKey(R.string.pref_hidelivemaphint), old.getInt(getKey(R.string.pref_hidelivemaphint), 0) != 0);
            e.putInt(getKey(R.string.pref_livemaphintshowcount), old.getInt(getKey(R.string.pref_livemaphintshowcount), 0));

            e.putInt(getKey(R.string.pref_settingsversion), 1); // mark migrated
            e.commit();
        }

        // changes for new settings dialog
        if (oldVersion < 2) {
            final Editor e = sharedPrefs.edit();

            e.putBoolean(getKey(R.string.pref_units), !isUseImperialUnits());

            // show waypoints threshold now as a slider
            int wpThreshold = getWayPointsThreshold();
            if (wpThreshold < 0) {
                wpThreshold = 0;
            } else if (wpThreshold > SHOW_WP_THRESHOLD_MAX) {
                wpThreshold = SHOW_WP_THRESHOLD_MAX;
            }
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), wpThreshold);

            // KEY_MAP_SOURCE must be string, because it is the key for a ListPreference now
            final int ms = sharedPrefs.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT);
            e.remove(getKey(R.string.pref_mapsource));
            e.putString(getKey(R.string.pref_mapsource), String.valueOf(ms));

            // navigation tool ids must be string, because ListPreference uses strings as keys
            final int dnt1 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id);
            final int dnt2 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id);
            e.remove(getKey(R.string.pref_defaultNavigationTool));
            e.remove(getKey(R.string.pref_defaultNavigationTool2));
            e.putString(getKey(R.string.pref_defaultNavigationTool), String.valueOf(dnt1));
            e.putString(getKey(R.string.pref_defaultNavigationTool2), String.valueOf(dnt2));

            // defaults for gpx directories
            e.putString(getKey(R.string.pref_gpxImportDir), getGpxImportDir());
            e.putString(getKey(R.string.pref_gpxExportDir), getGpxExportDir());

            e.putInt(getKey(R.string.pref_settingsversion), 2); // mark migrated
            e.commit();
        }
    }

    private static String getKey(final int prefKeyId) {
        return CgeoApplication.getInstance().getString(prefKeyId);
    }

    static String getString(final int prefKeyId, final String defaultValue) {
        return sharedPrefs.getString(getKey(prefKeyId), defaultValue);
    }

    private static int getInt(final int prefKeyId, final int defaultValue) {
        return sharedPrefs.getInt(getKey(prefKeyId), defaultValue);
    }

    private static long getLong(final int prefKeyId, final long defaultValue) {
        return sharedPrefs.getLong(getKey(prefKeyId), defaultValue);
    }

    private static boolean getBoolean(final int prefKeyId, final boolean defaultValue) {
        return sharedPrefs.getBoolean(getKey(prefKeyId), defaultValue);
    }

    private static float getFloat(final int prefKeyId, final float defaultValue) {
        return sharedPrefs.getFloat(getKey(prefKeyId), defaultValue);
    }

    protected static boolean putString(final int prefKeyId, final String value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putString(getKey(prefKeyId), value);
        return edit.commit();
    }

    protected static boolean putBoolean(final int prefKeyId, final boolean value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putBoolean(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putInt(final int prefKeyId, final int value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putInt(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putLong(final int prefKeyId, final long value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putLong(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean putFloat(final int prefKeyId, final float value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putFloat(getKey(prefKeyId), value);
        return edit.commit();
    }

    private static boolean remove(final int prefKeyId) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.remove(getKey(prefKeyId));
        return edit.commit();
    }

    private static boolean contains(final int prefKeyId) {
        return sharedPrefs.contains(getKey(prefKeyId));
    }

    public static void setLanguage(final boolean useEnglish) {
        final Configuration config = new Configuration();
        config.locale = useEnglish ? Locale.ENGLISH : Locale.getDefault();
        final Resources resources = CgeoApplication.getInstance().getResources();
        resources.updateConfiguration(config, resources.getDisplayMetrics());
    }

    public static boolean isLogin() {
        final String preUsername = getString(R.string.pref_username, null);
        final String prePassword = getString(R.string.pref_password, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    /**
     * Get login and password information of Geocaching.com.
     *
     * @return a pair either with (login, password) or (empty, empty) if no valid information is stored
     */
    public static ImmutablePair<String, String> getGcCredentials() {
        return getCredentials(GCConnector.getInstance());
    }

    /**
     * Get login and password information.
     *
     * @return a pair either with (login, password) or (empty, empty) if no valid information is stored
     */
    public static ImmutablePair<String, String> getCredentials(final @NonNull ICredentials connector) {
        final String username = getString(connector.getUsernamePreferenceKey(), null);
        final String password = getString(connector.getPasswordPreferenceKey(), null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return new ImmutablePair<>(StringUtils.EMPTY, StringUtils.EMPTY);
        }

        return new ImmutablePair<>(username, password);
    }

    public static String getUsername() {
        return getString(R.string.pref_username, null);
    }

    public static boolean isGCConnectorActive() {
        return getBoolean(R.string.pref_connectorGCActive, true);
    }

    public static boolean isECConnectorActive() {
        return getBoolean(R.string.pref_connectorECActive, false);
    }

    public static boolean isOXConnectorActive() {
        return getBoolean(R.string.pref_connectorOXActive, false);
    }

    public static boolean isGCPremiumMember() {
        final String memberStatus = Settings.getGCMemberStatus();
        return StringUtils.equalsIgnoreCase(memberStatus, GCConstants.MEMBER_STATUS_PREMIUM) ||
                StringUtils.equalsIgnoreCase(memberStatus, GCConstants.MEMBER_STATUS_CHARTER);
    }

    public static String getGCMemberStatus() {
        return getString(R.string.pref_memberstatus, "");
    }

    public static boolean setGCMemberStatus(final String memberStatus) {
        if (StringUtils.isBlank(memberStatus)) {
            return remove(R.string.pref_memberstatus);
        }
        return putString(R.string.pref_memberstatus, memberStatus);
    }

    public static ImmutablePair<String, String> getTokenPair(final int tokenPublicPrefKey, final int tokenSecretPrefKey) {
        return new ImmutablePair<>(getString(tokenPublicPrefKey, null), getString(tokenSecretPrefKey, null));
    }

    public static void setTokens(final int tokenPublicPrefKey, @Nullable final String tokenPublic, final int tokenSecretPrefKey, @Nullable final String tokenSecret) {
        if (tokenPublic == null) {
            remove(tokenPublicPrefKey);
        } else {
            putString(tokenPublicPrefKey, tokenPublic);
        }
        if (tokenSecret == null) {
            remove(tokenSecretPrefKey);
        } else {
            putString(tokenSecretPrefKey, tokenSecret);
        }
    }

    public static boolean isOCConnectorActive(final int isActivePrefKeyId) {
        return getBoolean(isActivePrefKeyId, false);
    }

    public static boolean hasOCAuthorization(final int tokenPublicPrefKeyId, final int tokenSecretPrefKeyId) {
        return StringUtils.isNotBlank(getString(tokenPublicPrefKeyId, ""))
                && StringUtils.isNotBlank(getString(tokenSecretPrefKeyId, ""));
    }

    public static boolean isGCvoteLogin() {
        final String preUsername = getString(R.string.pref_username, null);
        final String prePassword = getString(R.string.pref_pass_vote, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    public static ImmutablePair<String, String> getGCvoteLogin() {
        final String username = getString(R.string.pref_username, null);
        final String password = getString(R.string.pref_pass_vote, null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return null;
        }

        return new ImmutablePair<>(username, password);
    }

    public static String getSignature() {
        return getString(R.string.pref_signature, StringUtils.EMPTY);
    }

    public static boolean setCookieStore(final String cookies) {
        if (StringUtils.isBlank(cookies)) {
            // erase cookies
            return remove(R.string.pref_cookiestore);
        }
        // save cookies
        return putString(R.string.pref_cookiestore, cookies);
    }

    public static String getCookieStore() {
        return getString(R.string.pref_cookiestore, null);
    }

    /**
     * @param cacheType
     *            The cache type used for future filtering
     */
    public static void setCacheType(final CacheType cacheType) {
        if (cacheType == null) {
            remove(R.string.pref_cachetype);
        } else {
            putString(R.string.pref_cachetype, cacheType.id);
        }
    }

    public static int getLastList() {
        return getInt(R.string.pref_lastusedlist, StoredList.STANDARD_LIST_ID);
    }

    public static void saveLastList(final int listId) {
        putInt(R.string.pref_lastusedlist, listId);
    }

    public static void setWebNameCode(final String name, final String code) {
        putString(R.string.pref_webDeviceName, name);
        putString(R.string.pref_webDeviceCode, code);
    }

    public static MapProvider getMapProvider() {
        return getMapSource().getMapProvider();
    }

    public static String getMapFile() {
        return getString(R.string.pref_mapfile, null);
    }

    public static boolean setMapFile(final String mapFile) {
        final boolean result = putString(R.string.pref_mapfile, mapFile);
        if (mapFile != null) {
            setMapFileDirectory(new File(mapFile).getParent());
        }
        return result;
    }

    public static String getMapFileDirectory() {
        final String mapDir = getString(R.string.pref_mapDirectory, null);
        if (mapDir != null) {
            return mapDir;
        }
        final String mapFile = getMapFile();
        if (mapFile != null) {
            return new File(mapFile).getParent();
        }
        return null;
    }

    public static boolean setMapFileDirectory(final String mapFileDirectory) {
        final boolean result = putString(R.string.pref_mapDirectory, mapFileDirectory);
        MapsforgeMapProvider.getInstance().updateOfflineMaps();
        return result;
    }

    public static boolean isValidMapFile() {
        return isValidMapFile(getMapFile());
    }

    public static boolean isValidMapFile(final String mapFileIn) {
        return MapsforgeMapProvider.isValidMapFile(mapFileIn);
    }

    public static boolean isScaleMapsforgeText() {
        return getBoolean(R.string.pref_mapsforge_scale_text, true);
    }

    public static CoordInputFormatEnum getCoordInputFormat() {
        return CoordInputFormatEnum.fromInt(getInt(R.string.pref_coordinputformat, CoordInputFormatEnum.DEFAULT_INT_VALUE));
    }

    public static void setCoordInputFormat(final CoordInputFormatEnum format) {
        putInt(R.string.pref_coordinputformat, format.ordinal());
    }

    public static boolean getLogOffline() {
        return getBoolean(R.string.pref_log_offline, false);
    }

    public static boolean getChooseList() {
        return getBoolean(R.string.pref_choose_list, false);
    }

    public static boolean getLoadDirImg() {
        return !isGCPremiumMember() && getBoolean(R.string.pref_loaddirectionimg, true);
    }

    public static void setGcCustomDate(final String format) {
        putString(R.string.pref_gccustomdate, format);
    }

    /**
     * @return User selected date format on GC.com
     */
    public static String getGcCustomDate() {
        // We might have some users whose stored value is null, which is invalid. In this case, we use the default.
        return StringUtils.defaultString(getString(R.string.pref_gccustomdate, GCConstants.DEFAULT_GC_DATE),
                GCConstants.DEFAULT_GC_DATE);
    }

    public static boolean isExcludeMyCaches() {
        return getBoolean(R.string.pref_excludemine, false);
    }

    public static boolean isUseEnglish() {
        return getBoolean(R.string.pref_useenglish, false);
    }

    public static boolean isShowAddress() {
        return getBoolean(R.string.pref_showaddress, true);
    }

    public static boolean isShowCaptcha() {
        return !isGCPremiumMember() && getBoolean(R.string.pref_showcaptcha, false);
    }

    public static boolean isExcludeDisabledCaches() {
        return getBoolean(R.string.pref_excludedisabled, false);
    }

    public static boolean isStoreOfflineMaps() {
        return getBoolean(R.string.pref_offlinemaps, true);
    }

    public static boolean isStoreOfflineWpMaps() {
        return getBoolean(R.string.pref_offlinewpmaps, false);
    }

    public static boolean isStoreLogImages() {
        return getBoolean(R.string.pref_logimages, false);
    }

    public static boolean isAutoLoadDescription() {
        return getBoolean(R.string.pref_autoloaddesc, true);
    }

    public static boolean isRatingWanted() {
        return getBoolean(R.string.pref_ratingwanted, true);
    }

    public static boolean isFriendLogsWanted() {
        if (!isLogin()) {
            // don't show a friends log if the user is anonymous
            return false;
        }
        return getBoolean(R.string.pref_friendlogswanted, true);
    }

    public static boolean isLiveList() {
        return getBoolean(R.string.pref_livelist, true);
    }

    public static boolean isTrackableAutoVisit() {
        return getBoolean(R.string.pref_trackautovisit, false);
    }

    public static boolean isAutoInsertSignature() {
        return getBoolean(R.string.pref_sigautoinsert, false);
    }

    public static boolean isUseImperialUnits() {
        return getBoolean(R.string.pref_units, getImperialUnitsDefault());
    }

    static boolean getImperialUnitsDefault() {
        final String countryCode = Locale.getDefault().getCountry();
        return "US".equals(countryCode)  // USA
            || "LR".equals(countryCode)  // Liberia
            || "MM".equals(countryCode); // Burma
    }

    public static boolean isLiveMap() {
        return getBoolean(R.string.pref_maplive, true);
    }

    public static void setLiveMap(final boolean live) {
        putBoolean(R.string.pref_maplive, live);
    }

    public static boolean isMapTrail() {
        return getBoolean(R.string.pref_maptrail, true);
    }

    public static void setMapTrail(final boolean showTrail) {
        putBoolean(R.string.pref_maptrail, showTrail);
    }

    public static int getMapZoom() {
        return getInt(R.string.pref_lastmapzoom, 14);
    }

    public static void setMapZoom(final int mapZoomLevel) {
        putInt(R.string.pref_lastmapzoom, mapZoomLevel);
    }

    public static GeoPointImpl getMapCenter() {
        return getMapProvider().getMapItemFactory()
                .getGeoPointBase(new Geopoint(getInt(R.string.pref_lastmaplat, 0) / 1e6,
                        getInt(R.string.pref_lastmaplon, 0) / 1e6));
    }

    public static void setMapCenter(final GeoPointImpl mapViewCenter) {
        putInt(R.string.pref_lastmaplat, mapViewCenter.getLatitudeE6());
        putInt(R.string.pref_lastmaplon, mapViewCenter.getLongitudeE6());
    }

    @NonNull
    public static synchronized MapSource getMapSource() {
        if (mapSource != null) {
            return mapSource;
        }
        final int id = getConvertedMapId();
        mapSource = MapProviderFactory.getMapSource(id);
        if (mapSource != null) {
            // don't use offline maps if the map file is not valid
            if ((!(mapSource instanceof OfflineMapSource)) || (isValidMapFile())) {
                return mapSource;
            }
        }
        // fallback to first available map
        return MapProviderFactory.getDefaultSource();
    }

    private final static int GOOGLEMAP_BASEID = 30;
    private final static int MAP = 1;
    private final static int SATELLITE = 2;

    private final static int MFMAP_BASEID = 40;
    private final static int MAPNIK = 1;
    private final static int CYCLEMAP = 3;
    private final static int OFFLINE = 4;
    private static final int HISTORY_SIZE = 10;

    /**
     * convert old preference ids for maps (based on constant values) into new hash based ids
     *
     * @return
     */
    private static int getConvertedMapId() {
        final int id = Integer.parseInt(getString(R.string.pref_mapsource,
                String.valueOf(MAP_SOURCE_DEFAULT)));
        switch (id) {
            case GOOGLEMAP_BASEID + MAP:
                return GoogleMapProvider.GOOGLE_MAP_ID.hashCode();
            case GOOGLEMAP_BASEID + SATELLITE:
                return GoogleMapProvider.GOOGLE_SATELLITE_ID.hashCode();
            case MFMAP_BASEID + MAPNIK:
                return MapsforgeMapProvider.MAPSFORGE_MAPNIK_ID.hashCode();
            case MFMAP_BASEID + CYCLEMAP:
                return MapsforgeMapProvider.MAPSFORGE_CYCLEMAP_ID.hashCode();
            case MFMAP_BASEID + OFFLINE: {
                final String mapFile = Settings.getMapFile();
                if (StringUtils.isNotEmpty(mapFile)) {
                    return mapFile.hashCode();
                }
                break;
            }
            default:
                break;
        }
        return id;
    }

    public static void setMapSource(final MapSource newMapSource) {
        putString(R.string.pref_mapsource, String.valueOf(newMapSource.getNumericalId()));
        if (newMapSource instanceof OfflineMapSource) {
            setMapFile(((OfflineMapSource) newMapSource).getFileName());
        }
        // cache the value
        mapSource = newMapSource;
    }

    public static void setAnyCoordinates(final Geopoint coords) {
        if (null != coords) {
            putFloat(R.string.pref_anylatitude, (float) coords.getLatitude());
            putFloat(R.string.pref_anylongitude, (float) coords.getLongitude());
        } else {
            remove(R.string.pref_anylatitude);
            remove(R.string.pref_anylongitude);
        }
    }

    public static Geopoint getAnyCoordinates() {
        if (contains(R.string.pref_anylatitude) && contains(R.string.pref_anylongitude)) {
            final float lat = getFloat(R.string.pref_anylatitude, 0);
            final float lon = getFloat(R.string.pref_anylongitude, 0);
            return new Geopoint(lat, lon);
        }
        return null;
    }

    public static boolean isUseCompass() {
        return getBoolean(R.string.pref_usecompass, true);
    }

    public static void setUseCompass(final boolean useCompass) {
        putBoolean(R.string.pref_usecompass, useCompass);
    }

    public static boolean isLightSkin() {
        return getBoolean(R.string.pref_skin, false);
    }

    @NonNull
    public static String getKeyConsumerPublic() {
        return keyConsumerPublic;
    }

    @NonNull
    public static String getKeyConsumerSecret() {
        return keyConsumerSecret;
    }

    public static String getWebDeviceCode() {
        return getString(R.string.pref_webDeviceCode, null);
    }

    public static boolean isRegisteredForSend2cgeo() {
        return getWebDeviceCode() != null;
    }

    public static String getWebDeviceName() {
        return getString(R.string.pref_webDeviceName, android.os.Build.MODEL);
    }

    /**
     * @return The cache type used for filtering or ALL if no filter is active.
     *         Returns never null
     */
    public static CacheType getCacheType() {
        return CacheType.getById(getString(R.string.pref_cachetype, CacheType.ALL.id));
    }

    /**
     * The Threshold for the showing of child waypoints
     */
    public static int getWayPointsThreshold() {
        return getInt(R.string.pref_showwaypointsthreshold, SHOW_WP_THRESHOLD_DEFAULT);
    }

    public static void setShowWaypointsThreshold(final int threshold) {
        putInt(R.string.pref_showwaypointsthreshold, threshold);
    }

    public static boolean isUseTwitter() {
        return getBoolean(R.string.pref_twitter, false);
    }

    public static void setUseTwitter(final boolean useTwitter) {
        putBoolean(R.string.pref_twitter, useTwitter);
    }

    public static boolean isTwitterLoginValid() {
        return !StringUtils.isBlank(getTokenPublic())
                && !StringUtils.isBlank(getTokenSecret());
    }

    public static String getTokenPublic() {
        return getString(R.string.pref_twitter_token_public, null);
    }

    public static String getTokenSecret() {
        return getString(R.string.pref_twitter_token_secret, null);

    }

    public static boolean hasTwitterAuthorization() {
        return StringUtils.isNotBlank(getTokenPublic())
                && StringUtils.isNotBlank(getTokenSecret());
    }

    public static void setTwitterTokens(@Nullable final String tokenPublic,
            @Nullable final String tokenSecret, final boolean enableTwitter) {
        putString(R.string.pref_twitter_token_public, tokenPublic);
        putString(R.string.pref_twitter_token_secret, tokenSecret);
        if (tokenPublic != null) {
            remove(R.string.pref_temp_twitter_token_public);
            remove(R.string.pref_temp_twitter_token_secret);
        }
        setUseTwitter(enableTwitter);
    }

    public static void setTwitterTempTokens(@Nullable final String tokenPublic,
            @Nullable final String tokenSecret) {
        putString(R.string.pref_temp_twitter_token_public, tokenPublic);
        putString(R.string.pref_temp_twitter_token_secret, tokenSecret);
    }

    public static ImmutablePair<String, String> getTempToken() {
        final String tokenPublic = getString(R.string.pref_temp_twitter_token_public, null);
        final String tokenSecret = getString(R.string.pref_temp_twitter_token_secret, null);
        return new ImmutablePair<>(tokenPublic, tokenSecret);
    }

    public static int getVersion() {
        return getInt(R.string.pref_version, 0);
    }

    public static void setVersion(final int version) {
        putInt(R.string.pref_version, version);
    }

    public static boolean isOpenLastDetailsPage() {
        return getBoolean(R.string.pref_opendetailslastpage, false);
    }

    public static int getLastDetailsPage() {
        return getInt(R.string.pref_lastdetailspage, 1);
    }

    public static void setLastDetailsPage(final int index) {
        putInt(R.string.pref_lastdetailspage, index);
    }

    public static int getDefaultNavigationTool() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool,
                String.valueOf(NavigationAppsEnum.COMPASS.id)));
    }

    public static int getDefaultNavigationTool2() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool2,
                String.valueOf(NavigationAppsEnum.INTERNAL_MAP.id)));
    }

    public static Strategy getLiveMapStrategy() {
        return Strategy.getById(getInt(R.string.pref_livemapstrategy, Strategy.AUTO.id));
    }

    public static void setLiveMapStrategy(final Strategy strategy) {
        putInt(R.string.pref_livemapstrategy, strategy.id);
    }

    public static boolean isDebug() {
        return Log.isDebug();
    }

    public static boolean getHideLiveMapHint() {
        return getBoolean(R.string.pref_hidelivemaphint, false);
    }

    public static void setHideLiveHint(final boolean hide) {
        putBoolean(R.string.pref_hidelivemaphint, hide);
    }

    public static int getLiveMapHintShowCount() {
        return getInt(R.string.pref_livemaphintshowcount, 0);
    }

    public static void setLiveMapHintShowCount(final int showCount) {
        putInt(R.string.pref_livemaphintshowcount, showCount);
    }

    public static boolean isDbOnSDCard() {
        return getBoolean(R.string.pref_dbonsdcard, false);
    }

    public static void setDbOnSDCard(final boolean dbOnSDCard) {
        putBoolean(R.string.pref_dbonsdcard, dbOnSDCard);
    }

    public static String getGpxExportDir() {
        return getString(R.string.pref_gpxExportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static String getGpxImportDir() {
        return getString(R.string.pref_gpxImportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static boolean getShareAfterExport() {
        return getBoolean(R.string.pref_shareafterexport, true);
    }

    public static void setShareAfterExport(final boolean shareAfterExport) {
        putBoolean(R.string.pref_shareafterexport, shareAfterExport);
    }

    public static int getTrackableAction() {
        return getInt(R.string.pref_trackableaction, LogType.RETRIEVED_IT.id);
    }

    public static void setTrackableAction(final int trackableAction) {
        putInt(R.string.pref_trackableaction, trackableAction);
    }

    public static String getCustomRenderThemeBaseFolder() {
        return getString(R.string.pref_renderthemepath, "");
    }

    public static String getCustomRenderThemeFilePath() {
        return getString(R.string.pref_renderthemefile, "");
    }

    public static void setCustomRenderThemeFile(final String customRenderThemeFile) {
        putString(R.string.pref_renderthemefile, customRenderThemeFile);
    }

    public static File[] getMapThemeFiles() {
        final File directory = new File(Settings.getCustomRenderThemeBaseFolder());
        final List<File> result = new ArrayList<>();
        FileUtils.listDir(result, directory, new ExtensionsBasedFileSelector(new String[] { "xml" }), null);

        return result.toArray(new File[result.size()]);
    }

    private static class ExtensionsBasedFileSelector extends FileSelector {
        private final String[] extensions;
        public ExtensionsBasedFileSelector(final String[] extensions) {
            this.extensions = extensions;
        }
        @Override
        public boolean isSelected(final File file) {
            final String filename = file.getName();
            for (final String ext : extensions) {
                if (StringUtils.endsWithIgnoreCase(filename, ext)) {
                    return true;
                }
            }
            return false;
        }
        @Override
        public boolean shouldEnd() {
            return false;
        }
    }

    public static boolean getPlainLogs() {
        return getBoolean(R.string.pref_plainLogs, false);
    }

    public static boolean getUseNativeUa() {
        return getBoolean(R.string.pref_nativeUa, false);
    }

    public static String getCacheTwitterMessage() {
        return getString(R.string.pref_twitter_cache_message, "I found [NAME] ([URL]).");
    }

    public static String getTrackableTwitterMessage() {
        return getString(R.string.pref_twitter_trackable_message, "I touched [NAME] ([URL]).");
    }

    public static int getLogImageScale() {
        return getInt(R.string.pref_logImageScale, -1);
    }

    public static void setLogImageScale(final int scale) {
        putInt(R.string.pref_logImageScale, scale);
    }

    public static void setExcludeMine(final boolean exclude) {
        putBoolean(R.string.pref_excludemine, exclude);
    }

    static void setLogin(final String username, final String password) {
        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            // erase username and password
            remove(R.string.pref_username);
            remove(R.string.pref_password);
            return;
        }
        // save username and password
        putString(R.string.pref_username, username);
        putString(R.string.pref_password, password);
    }

    public static long getFieldnoteExportDate() {
        return getLong(R.string.pref_fieldNoteExportDate, 0);
    }

    /**
     * remember date of last field note export
     *
     * @param date
     */
    public static void setFieldnoteExportDate(final long date) {
        putLong(R.string.pref_fieldNoteExportDate, date);
    }

    public static boolean isUseNavigationApp(final NavigationAppsEnum navApp) {
        return getBoolean(navApp.preferenceKey, true);
    }

    /**
     * remember the state of the "Upload" checkbox in the field notes export dialog
     *
     * @param upload
     */
    public static void setFieldNoteExportUpload(final boolean upload) {
        putBoolean(R.string.pref_fieldNoteExportUpload, upload);
    }

    public static boolean getFieldNoteExportUpload() {
        return getBoolean(R.string.pref_fieldNoteExportUpload, true);
    }

    /**
     * remember the state of the "Only new" checkbox in the field notes export dialog
     *
     * @param onlyNew
     */
    public static void setFieldNoteExportOnlyNew(final boolean onlyNew) {
        putBoolean(R.string.pref_fieldNoteExportOnlyNew, onlyNew);
    }

    public static boolean getFieldNoteExportOnlyNew() {
        return getBoolean(R.string.pref_fieldNoteExportOnlyNew, false);
    }

    public static String getECIconSet() {
        return getString(R.string.pref_ec_icons, "1");
    }

    /* Store last checksum of changelog for changelog display */
    public static long getLastChangelogChecksum() {
        return getLong(R.string.pref_changelog_last_checksum, 0);
    }

    public static void setLastChangelogChecksum(final long checksum) {
        putLong(R.string.pref_changelog_last_checksum, checksum);
    }

    public static List<String> getLastOpenedCaches() {
        final List<String> history = Arrays.asList(StringUtils.split(getString(R.string.pref_caches_history, StringUtils.EMPTY), HISTORY_SEPARATOR));
        return history.subList(0, Math.min(HISTORY_SIZE, history.size()));
    }

    public static void addCacheToHistory(@NonNull final String geocode) {
        final ArrayList<String> history = new ArrayList<>(getLastOpenedCaches());
        // bring entry to front, if it already existed
        history.remove(geocode);
        history.add(0, geocode);
        putString(R.string.pref_caches_history, StringUtils.join(history, HISTORY_SEPARATOR));
    }

    public static boolean useHardwareAcceleration() {
        return getBoolean(R.string.pref_hardware_acceleration, !HW_ACCEL_DISABLED_BY_DEFAULT);
    }

    public static boolean setUseHardwareAcceleration(final boolean useHardwareAcceleration) {
        return putBoolean(R.string.pref_hardware_acceleration, useHardwareAcceleration);
    }
}
!@#$%
20190527_005402,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_b17384
package cgeo.geocaching.network;

import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.files.LocalStorage;
import cgeo.geocaching.settings.Settings;
import cgeo.geocaching.utils.JsonUtils;
import cgeo.geocaching.utils.Log;
import cgeo.geocaching.utils.TextUtils;

import ch.boye.httpclientandroidlib.HttpEntity;
import ch.boye.httpclientandroidlib.HttpResponse;
import ch.boye.httpclientandroidlib.NameValuePair;
import ch.boye.httpclientandroidlib.client.HttpClient;
import ch.boye.httpclientandroidlib.client.entity.UrlEncodedFormEntity;
import ch.boye.httpclientandroidlib.client.methods.HttpGet;
import ch.boye.httpclientandroidlib.client.methods.HttpPost;
import ch.boye.httpclientandroidlib.client.methods.HttpRequestBase;
import ch.boye.httpclientandroidlib.client.params.ClientPNames;
import ch.boye.httpclientandroidlib.entity.StringEntity;
import ch.boye.httpclientandroidlib.entity.mime.MultipartEntity;
import ch.boye.httpclientandroidlib.entity.mime.content.FileBody;
import ch.boye.httpclientandroidlib.entity.mime.content.StringBody;
import ch.boye.httpclientandroidlib.impl.client.DecompressingHttpClient;
import ch.boye.httpclientandroidlib.impl.client.DefaultHttpClient;
import ch.boye.httpclientandroidlib.impl.client.LaxRedirectStrategy;
import ch.boye.httpclientandroidlib.params.BasicHttpParams;
import ch.boye.httpclientandroidlib.params.CoreConnectionPNames;
import ch.boye.httpclientandroidlib.params.CoreProtocolPNames;
import ch.boye.httpclientandroidlib.params.HttpParams;
import ch.boye.httpclientandroidlib.util.EntityUtils;

import com.fasterxml.jackson.databind.node.ObjectNode;

import org.apache.commons.lang3.CharEncoding;
import org.apache.commons.lang3.StringUtils;
import org.eclipse.jdt.annotation.Nullable;

import android.content.Context;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.net.Uri;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.util.regex.Pattern;

public abstract class Network {

    /** User agent id */
    private final static String PC_USER_AGENT = "Mozilla/5.0 (X11; Linux x86_64; rv:9.0.1) Gecko/20100101 Firefox/9.0.1";
    /** Native user agent, taken from a Android 2.2 Nexus **/
    private final static String NATIVE_USER_AGENT = "Mozilla/5.0 (Linux; U; Android 2.2; en-us; Nexus One Build/FRF91) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1";

    private static final Pattern PATTERN_PASSWORD = Pattern.compile("(?<=[\\?&])[Pp]ass(w(or)?d)?=[^&#$]+");

    private final static HttpParams clientParams = new BasicHttpParams();

    static {
        clientParams.setParameter(CoreProtocolPNames.HTTP_CONTENT_CHARSET, CharEncoding.UTF_8);
        clientParams.setParameter(CoreConnectionPNames.CONNECTION_TIMEOUT, 30000);
        clientParams.setParameter(CoreConnectionPNames.SO_TIMEOUT, 90000);
        clientParams.setParameter(ClientPNames.HANDLE_REDIRECTS,  true);
    }

    private static String hidePassword(final String message) {
        return PATTERN_PASSWORD.matcher(message).replaceAll("password=***");
    }

    private static HttpClient getHttpClient() {
        final DefaultHttpClient client = new DefaultHttpClient();
        client.setCookieStore(Cookies.cookieStore);
        client.setParams(clientParams);
        client.setRedirectStrategy(new LaxRedirectStrategy());
        return new DecompressingHttpClient(client);
    }

    /**
     * POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @return the HTTP response, or null in case of an encoding error params
     */
    @Nullable
    public static HttpResponse postRequest(final String uri, final Parameters params) {
        return request("POST", uri, params, null, null);
    }

    /**
     * POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @params headers the headers to add to the request
     * @return the HTTP response, or null in case of an encoding error params
     */
    @Nullable
    public static HttpResponse postRequest(final String uri, final Parameters params, final Parameters headers) {
        return request("POST", uri, params, headers, null);
    }

    /**
     *  POST HTTP request with Json POST DATA
     *
     * @param uri the URI to request
     * @param json the json object to add to the POST request
     * @return the HTTP response, or null in case of an encoding error params
     */
    @Nullable
    public static HttpResponse postJsonRequest(final String uri, final ObjectNode json) {
        final HttpPost request = new HttpPost(uri);
        request.addHeader("Content-Type", "application/json; charset=utf-8");
        if (json != null) {
            try {
                request.setEntity(new StringEntity(json.toString(), CharEncoding.UTF_8));
            } catch (final UnsupportedEncodingException e) {
                Log.e("postJsonRequest:JSON Entity: UnsupportedEncodingException", e);
                return null;
            }
        }
        return doLogRequest(request);
    }

    /**
     * Multipart POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @param fileFieldName the name of the file field name
     * @param fileContentType the content-type of the file
     * @param file the file to include in the request
     * @return the HTTP response, or null in case of an encoding error param
     */
    @Nullable
    public static HttpResponse postRequest(final String uri, final Parameters params,
            final String fileFieldName, final String fileContentType, final File file) {
        final MultipartEntity entity = new MultipartEntity();
        for (final NameValuePair param : params) {
            try {
                entity.addPart(param.getName(), new StringBody(param.getValue(), TextUtils.CHARSET_UTF8));
            } catch (final UnsupportedEncodingException e) {
                Log.e("Network.postRequest: unsupported encoding for parameter " + param.getName(), e);
                return null;
            }
        }
        entity.addPart(fileFieldName, new FileBody(file, fileContentType));

        final HttpPost request = new HttpPost(uri);
        request.setEntity(entity);

        addHeaders(request, null, null);
        return doLogRequest(request);
    }

    /**
     * Make an HTTP request
     *
     * @param method
     *            the HTTP method to use ("GET" or "POST")
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add to the URI
     * @param headers
     *            the headers to add to the request
     * @param cacheFile
     *            the cache file used to cache this query
     * @return the HTTP response, or null in case of an encoding error in a POST request arguments
     */
    @Nullable
    private static HttpResponse request(final String method, final String uri,
                                        @Nullable final Parameters params, @Nullable final Parameters headers, @Nullable final File cacheFile) {
        HttpRequestBase request;
        if (method.equals("GET")) {
            final String fullUri = params == null ? uri : Uri.parse(uri).buildUpon().encodedQuery(params.toString()).build().toString();
            request = new HttpGet(fullUri);
        } else {
            request = new HttpPost(uri);
            if (params != null) {
                try {
                    ((HttpPost) request).setEntity(new UrlEncodedFormEntity(params, CharEncoding.UTF_8));
                } catch (final UnsupportedEncodingException e) {
                    Log.e("request", e);
                    return null;
                }
            }
        }

        addHeaders(request, headers, cacheFile);

        return doLogRequest(request);
    }

    /**
     * Add headers to HTTP request.
     * @param request
     *            the request to add headers to
     * @param headers
     *            the headers to add (in addition to the standard headers), can be null
     * @param cacheFile
     *            if non-null, the file to take ETag and If-Modified-Since information from
     */
    private static void addHeaders(final HttpRequestBase request, @Nullable final Parameters headers, @Nullable final File cacheFile) {
        for (final NameValuePair header : Parameters.extend(Parameters.merge(headers, cacheHeaders(cacheFile)),
                "Accept-Charset", "utf-8,iso-8859-1;q=0.8,utf-16;q=0.8,*;q=0.7",
                "Accept-Language", "en-US,*;q=0.9",
                "X-Requested-With", "XMLHttpRequest")) {
            request.setHeader(header.getName(), header.getValue());
        }
        request.getParams().setParameter(CoreProtocolPNames.USER_AGENT,
                Settings.getUseNativeUa() ? NATIVE_USER_AGENT : PC_USER_AGENT);
    }

    /**
     * Perform an HTTP request and log it.
     *
     * @param request
     *            the request to try
     * @return
     *            the response, or null if there has been a failure
     */
    @Nullable
    private static HttpResponse doLogRequest(final HttpRequestBase request) {
        final String reqLogStr = request.getMethod() + " " + hidePassword(request.getURI().toString());
        Log.d(reqLogStr);

        final HttpClient client = getHttpClient();
        final long before = System.currentTimeMillis();
        try {
            final HttpResponse response = client.execute(request);
            final int status = response.getStatusLine().getStatusCode();
            if (status == 200) {
                Log.d(status + formatTimeSpan(before) + reqLogStr);
            } else {
                Log.w(status + " [" + response.getStatusLine().getReasonPhrase() + "]" + formatTimeSpan(before) + reqLogStr);
            }
            return response;
        } catch (final Exception e) {
            final String timeSpan = formatTimeSpan(before);
            Log.w("Failure" + timeSpan + reqLogStr + " (" + e.toString() + ")");
        }

        return null;
    }

    @Nullable
    private static Parameters cacheHeaders(@Nullable final File cacheFile) {
        if (cacheFile == null || !cacheFile.exists()) {
            return null;
        }

        final String etag = LocalStorage.getSavedHeader(cacheFile, LocalStorage.HEADER_ETAG);
        if (etag != null) {
            // The ETag is a more robust check than a timestamp. If we have an ETag, it is enough
            // to identify the right version of the resource.
            return new Parameters("If-None-Match", etag);
        }

        final String lastModified = LocalStorage.getSavedHeader(cacheFile, LocalStorage.HEADER_LAST_MODIFIED);
        if (lastModified != null) {
            return new Parameters("If-Modified-Since", lastModified);
        }

        return null;
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @param cacheFile
     *            the name of the file storing the cached resource, or null not to use one
     * @return the HTTP response
     */
    @Nullable
    public static HttpResponse getRequest(final String uri, @Nullable final Parameters params, @Nullable final File cacheFile) {
        return request("GET", uri, params, null, cacheFile);
    }


    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @return the HTTP response
     */
    @Nullable
    public static HttpResponse getRequest(final String uri, @Nullable final Parameters params) {
        return request("GET", uri, params, null, null);
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @param headers
     *            the headers to add to the GET request
     * @return the HTTP response
     */
    @Nullable
    public static HttpResponse getRequest(final String uri, @Nullable final Parameters params, @Nullable final Parameters headers) {
        return request("GET", uri, params, headers, null);
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @return the HTTP response
     */
    @Nullable
    public static HttpResponse getRequest(final String uri) {
        return request("GET", uri, null, null, null);
    }

    private static String formatTimeSpan(final long before) {
        // don't use String.format in a pure logging routine, it has very bad performance
        return " (" + (System.currentTimeMillis() - before) + " ms) ";
    }

    static public boolean isSuccess(@Nullable final HttpResponse response) {
        return response != null && response.getStatusLine().getStatusCode() == 200;
    }

    static public boolean isPageNotFound(@Nullable final HttpResponse response) {
        return response != null && response.getStatusLine().getStatusCode() == 404;
    }

    /**
     * Get the result of a GET HTTP request returning a JSON body.
     *
     * @param uri the base URI of the GET HTTP request
     * @param params the query parameters, or <code>null</code> if there are none
     * @return a JSON object if the request was successful and the body could be decoded, <code>null</code> otherwise
     */
    @Nullable
    public static ObjectNode requestJSON(final String uri, @Nullable final Parameters params) {
        final HttpResponse response = request("GET", uri, params, new Parameters("Accept", "application/json, text/javascript, */*; q=0.01"), null);
        final String responseData = getResponseData(response, false);
        if (responseData != null) {
            try {
                return (ObjectNode) JsonUtils.reader.readTree(responseData);
            } catch (final IOException e) {
                Log.w("requestJSON", e);
            }
        }

        return null;
    }

    /**
     * Get the input stream corresponding to a HTTP response if it exists.
     *
     * @param response a HTTP response, which can be null
     * @return the input stream if the HTTP request is successful, <code>null</code> otherwise
     */
    @Nullable
    public static InputStream getResponseStream(@Nullable final HttpResponse response) {
        if (!isSuccess(response)) {
            return null;
        }
        assert(response != null);
        final HttpEntity entity = response.getEntity();
        if (entity == null) {
            return null;
        }
        try {
            return entity.getContent();
        } catch (final IOException e) {
            Log.e("Network.getResponseStream", e);
            return null;
        }
    }

    @Nullable
    private static String getResponseDataNoError(final HttpResponse response, final boolean replaceWhitespace) {
        try {
            final String data = EntityUtils.toString(response.getEntity(), CharEncoding.UTF_8);
            return replaceWhitespace ? TextUtils.replaceWhitespace(data) : data;
        } catch (final Exception e) {
            Log.e("getResponseData", e);
            return null;
        }
    }

    /**
     * Get the body of a HTTP response.
     *
     * {@link TextUtils#replaceWhitespace(String)} will be called on the result
     *
     * @param response a HTTP response, which can be null
     * @return the body if the response comes from a successful HTTP request, <code>null</code> otherwise
     */
    @Nullable
    public static String getResponseData(@Nullable final HttpResponse response) {
        return getResponseData(response, true);
    }

    @Nullable
    public static String getResponseDataAlways(@Nullable final HttpResponse response) {
        return response != null ? getResponseDataNoError(response, false) : null;
    }

    /**
     * Get the body of a HTTP response.
     *
     * @param response a HTTP response, which can be null
     * @param replaceWhitespace <code>true</code> if {@link TextUtils#replaceWhitespace(String)}
     *                          should be called on the body
     * @return the body if the response comes from a successful HTTP request, <code>null</code> otherwise
     */
    @Nullable
    public static String getResponseData(@Nullable final HttpResponse response, final boolean replaceWhitespace) {
        if (!isSuccess(response)) {
            return null;
        }
        assert response != null; // Caught above
        return getResponseDataNoError(response, replaceWhitespace);
    }

    @Nullable
    public static String rfc3986URLEncode(final String text) {
        final String encoded = encode(text);
        return encoded != null ? StringUtils.replace(encoded.replace("+", "%20"), "%7E", "~") : null;
    }

    @Nullable
    public static String decode(final String text) {
        try {
            return URLDecoder.decode(text, CharEncoding.UTF_8);
        } catch (final UnsupportedEncodingException e) {
            Log.e("Network.decode", e);
        }
        return null;
    }

    @Nullable
    public static String encode(final String text) {
        try {
            return URLEncoder.encode(text, CharEncoding.UTF_8);
        } catch (final UnsupportedEncodingException e) {
            Log.e("Network.encode", e);
        }
        return null;
    }

    private static ConnectivityManager connectivityManager = null;

    /**
     * Checks if the device has network connection.
     *
     * @return <code>true</code> if the device is connected to the network.
     */
    public static boolean isNetworkConnected() {
        if (connectivityManager == null) {
            // Concurrent assignment would not hurt
            connectivityManager = (ConnectivityManager) CgeoApplication.getInstance().getApplicationContext().getSystemService(Context.CONNECTIVITY_SERVICE);
        }
        final NetworkInfo activeNetworkInfo = connectivityManager.getActiveNetworkInfo();
        return activeNetworkInfo != null && activeNetworkInfo.isConnected();
    }

}
!@#$%
20190527_005402,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_a17384
package cgeo.geocaching.network;

import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.files.LocalStorage;
import cgeo.geocaching.settings.Settings;
import cgeo.geocaching.utils.JsonUtils;
import cgeo.geocaching.utils.Log;
import cgeo.geocaching.utils.TextUtils;

import ch.boye.httpclientandroidlib.HttpEntity;
import ch.boye.httpclientandroidlib.HttpResponse;
import ch.boye.httpclientandroidlib.NameValuePair;
import ch.boye.httpclientandroidlib.client.HttpClient;
import ch.boye.httpclientandroidlib.client.entity.UrlEncodedFormEntity;
import ch.boye.httpclientandroidlib.client.methods.HttpGet;
import ch.boye.httpclientandroidlib.client.methods.HttpPost;
import ch.boye.httpclientandroidlib.client.methods.HttpRequestBase;
import ch.boye.httpclientandroidlib.client.params.ClientPNames;
import ch.boye.httpclientandroidlib.entity.StringEntity;
import ch.boye.httpclientandroidlib.entity.mime.MultipartEntity;
import ch.boye.httpclientandroidlib.entity.mime.content.FileBody;
import ch.boye.httpclientandroidlib.entity.mime.content.StringBody;
import ch.boye.httpclientandroidlib.impl.client.DecompressingHttpClient;
import ch.boye.httpclientandroidlib.impl.client.DefaultHttpClient;
import ch.boye.httpclientandroidlib.impl.client.LaxRedirectStrategy;
import ch.boye.httpclientandroidlib.params.BasicHttpParams;
import ch.boye.httpclientandroidlib.params.CoreConnectionPNames;
import ch.boye.httpclientandroidlib.params.CoreProtocolPNames;
import ch.boye.httpclientandroidlib.params.HttpParams;
import ch.boye.httpclientandroidlib.util.EntityUtils;

import com.fasterxml.jackson.databind.node.ObjectNode;

import org.apache.commons.lang3.CharEncoding;
import org.apache.commons.lang3.StringUtils;
import org.eclipse.jdt.annotation.Nullable;

import android.content.Context;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.net.Uri;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.util.regex.Pattern;

public abstract class Network {

    /** User agent id */
    private final static String PC_USER_AGENT = "Mozilla/5.0 (X11; Linux x86_64; rv:9.0.1) Gecko/20100101 Firefox/9.0.1";
    /** Native user agent, taken from a Android 2.2 Nexus **/
    private final static String NATIVE_USER_AGENT = "Mozilla/5.0 (Linux; U; Android 2.2; en-us; Nexus One Build/FRF91) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1";

    private static final Pattern PATTERN_PASSWORD = Pattern.compile("(?<=[\\?&])[Pp]ass(w(or)?d)?=[^&#$]+");

    private final static HttpParams clientParams = new BasicHttpParams();

    static {
        clientParams.setParameter(CoreProtocolPNames.HTTP_CONTENT_CHARSET, CharEncoding.UTF_8);
        clientParams.setParameter(CoreConnectionPNames.CONNECTION_TIMEOUT, 30000);
        clientParams.setParameter(CoreConnectionPNames.SO_TIMEOUT, 90000);
        clientParams.setParameter(ClientPNames.HANDLE_REDIRECTS,  true);
    }

    private static String hidePassword(final String message) {
        return PATTERN_PASSWORD.matcher(message).replaceAll("password=***");
    }

    private static HttpClient getHttpClient() {
        final DefaultHttpClient client = new DefaultHttpClient();
        client.setCookieStore(Cookies.cookieStore);
        client.setParams(clientParams);
        client.setRedirectStrategy(new LaxRedirectStrategy());
        return new DecompressingHttpClient(client);
    }

    /**
     * POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @return the HTTP response, or null in case of an encoding error params
     */
    @Nullable
    public static HttpResponse postRequest(final String uri, final Parameters params) {
        return request("POST", uri, params, null, null);
    }

    /**
     * POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @params headers the headers to add to the request
     * @return the HTTP response, or null in case of an encoding error params
     */
    @Nullable
    public static HttpResponse postRequest(final String uri, final Parameters params, final Parameters headers) {
        return request("POST", uri, params, headers, null);
    }

    /**
     *  POST HTTP request with Json POST DATA
     *
     * @param uri the URI to request
     * @param json the json object to add to the POST request
     * @return the HTTP response, or null in case of an encoding error params
     */
    @Nullable
    public static HttpResponse postJsonRequest(final String uri, final ObjectNode json) {
        HttpPost request = new HttpPost(uri);
        request.addHeader("Content-Type", "application/json; charset=utf-8");
        if (json != null) {
            try {
                request.setEntity(new StringEntity(json.toString(), CharEncoding.UTF_8));
            } catch (UnsupportedEncodingException e) {
                Log.e("postJsonRequest:JSON Entity: UnsupportedEncodingException", e);
                return null;
            }
        }
        return doLogRequest(request);
    }

    /**
     * Multipart POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @param fileFieldName the name of the file field name
     * @param fileContentType the content-type of the file
     * @param file the file to include in the request
     * @return the HTTP response, or null in case of an encoding error param
     */
    @Nullable
    public static HttpResponse postRequest(final String uri, final Parameters params,
            final String fileFieldName, final String fileContentType, final File file) {
        final MultipartEntity entity = new MultipartEntity();
        for (final NameValuePair param : params) {
            try {
                entity.addPart(param.getName(), new StringBody(param.getValue(), TextUtils.CHARSET_UTF8));
            } catch (final UnsupportedEncodingException e) {
                Log.e("Network.postRequest: unsupported encoding for parameter " + param.getName(), e);
                return null;
            }
        }
        entity.addPart(fileFieldName, new FileBody(file, fileContentType));

        final HttpPost request = new HttpPost(uri);
        request.setEntity(entity);

        addHeaders(request, null, null);
        return doLogRequest(request);
    }

    /**
     * Make an HTTP request
     *
     * @param method
     *            the HTTP method to use ("GET" or "POST")
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add to the URI
     * @param headers
     *            the headers to add to the request
     * @param cacheFile
     *            the cache file used to cache this query
     * @return the HTTP response, or null in case of an encoding error in a POST request arguments
     */
    @Nullable
    private static HttpResponse request(final String method, final String uri,
                                        @Nullable final Parameters params, @Nullable final Parameters headers, @Nullable final File cacheFile) {
        HttpRequestBase request;
        if (method.equals("GET")) {
            final String fullUri = params == null ? uri : Uri.parse(uri).buildUpon().encodedQuery(params.toString()).build().toString();
            request = new HttpGet(fullUri);
        } else {
            request = new HttpPost(uri);
            if (params != null) {
                try {
                    ((HttpPost) request).setEntity(new UrlEncodedFormEntity(params, CharEncoding.UTF_8));
                } catch (final UnsupportedEncodingException e) {
                    Log.e("request", e);
                    return null;
                }
            }
        }

        addHeaders(request, headers, cacheFile);

        return doLogRequest(request);
    }

    /**
     * Add headers to HTTP request.
     * @param request
     *            the request to add headers to
     * @param headers
     *            the headers to add (in addition to the standard headers), can be null
     * @param cacheFile
     *            if non-null, the file to take ETag and If-Modified-Since information from
     */
    private static void addHeaders(final HttpRequestBase request, @Nullable final Parameters headers, @Nullable final File cacheFile) {
        for (final NameValuePair header : Parameters.extend(Parameters.merge(headers, cacheHeaders(cacheFile)),
                "Accept-Charset", "utf-8,iso-8859-1;q=0.8,utf-16;q=0.8,*;q=0.7",
                "Accept-Language", "en-US,*;q=0.9",
                "X-Requested-With", "XMLHttpRequest")) {
            request.setHeader(header.getName(), header.getValue());
        }
        request.getParams().setParameter(CoreProtocolPNames.USER_AGENT,
                Settings.getUseNativeUa() ? NATIVE_USER_AGENT : PC_USER_AGENT);
    }

    /**
     * Perform an HTTP request and log it.
     *
     * @param request
     *            the request to try
     * @return
     *            the response, or null if there has been a failure
     */
    @Nullable
    private static HttpResponse doLogRequest(final HttpRequestBase request) {
        final String reqLogStr = request.getMethod() + " " + hidePassword(request.getURI().toString());
        Log.d(reqLogStr);

        final HttpClient client = getHttpClient();
        final long before = System.currentTimeMillis();
        try {
            final HttpResponse response = client.execute(request);
            int status = response.getStatusLine().getStatusCode();
            if (status == 200) {
                Log.d(status + formatTimeSpan(before) + reqLogStr);
            } else {
                Log.w(status + " [" + response.getStatusLine().getReasonPhrase() + "]" + formatTimeSpan(before) + reqLogStr);
            }
            return response;
        } catch (final Exception e) {
            final String timeSpan = formatTimeSpan(before);
            Log.w("Failure" + timeSpan + reqLogStr + " (" + e.toString() + ")");
        }

        return null;
    }

    @Nullable
    private static Parameters cacheHeaders(@Nullable final File cacheFile) {
        if (cacheFile == null || !cacheFile.exists()) {
            return null;
        }

        final String etag = LocalStorage.getSavedHeader(cacheFile, LocalStorage.HEADER_ETAG);
        if (etag != null) {
            // The ETag is a more robust check than a timestamp. If we have an ETag, it is enough
            // to identify the right version of the resource.
            return new Parameters("If-None-Match", etag);
        }

        final String lastModified = LocalStorage.getSavedHeader(cacheFile, LocalStorage.HEADER_LAST_MODIFIED);
        if (lastModified != null) {
            return new Parameters("If-Modified-Since", lastModified);
        }

        return null;
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @param cacheFile
     *            the name of the file storing the cached resource, or null not to use one
     * @return the HTTP response
     */
    @Nullable
    public static HttpResponse getRequest(final String uri, @Nullable final Parameters params, @Nullable final File cacheFile) {
        return request("GET", uri, params, null, cacheFile);
    }


    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @return the HTTP response
     */
    @Nullable
    public static HttpResponse getRequest(final String uri, @Nullable final Parameters params) {
        return request("GET", uri, params, null, null);
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @param headers
     *            the headers to add to the GET request
     * @return the HTTP response
     */
    @Nullable
    public static HttpResponse getRequest(final String uri, @Nullable final Parameters params, @Nullable final Parameters headers) {
        return request("GET", uri, params, headers, null);
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @return the HTTP response
     */
    @Nullable
    public static HttpResponse getRequest(final String uri) {
        return request("GET", uri, null, null, null);
    }

    private static String formatTimeSpan(final long before) {
        // don't use String.format in a pure logging routine, it has very bad performance
        return " (" + (System.currentTimeMillis() - before) + " ms) ";
    }

    static public boolean isSuccess(@Nullable final HttpResponse response) {
        return response != null && response.getStatusLine().getStatusCode() == 200;
    }

    static public boolean isPageNotFound(@Nullable final HttpResponse response) {
        return response != null && response.getStatusLine().getStatusCode() == 404;
    }

    /**
     * Get the result of a GET HTTP request returning a JSON body.
     *
     * @param uri the base URI of the GET HTTP request
     * @param params the query parameters, or <code>null</code> if there are none
     * @return a JSON object if the request was successful and the body could be decoded, <code>null</code> otherwise
     */
    @Nullable
    public static ObjectNode requestJSON(final String uri, @Nullable final Parameters params) {
        final HttpResponse response = request("GET", uri, params, new Parameters("Accept", "application/json, text/javascript, */*; q=0.01"), null);
        final String responseData = getResponseData(response, false);
        if (responseData != null) {
            try {
                return (ObjectNode) JsonUtils.reader.readTree(responseData);
            } catch (final IOException e) {
                Log.w("requestJSON", e);
            }
        }

        return null;
    }

    /**
     * Get the input stream corresponding to a HTTP response if it exists.
     *
     * @param response a HTTP response, which can be null
     * @return the input stream if the HTTP request is successful, <code>null</code> otherwise
     */
    @Nullable
    public static InputStream getResponseStream(@Nullable final HttpResponse response) {
        if (!isSuccess(response)) {
            return null;
        }
        assert(response != null);
        final HttpEntity entity = response.getEntity();
        if (entity == null) {
            return null;
        }
        try {
            return entity.getContent();
        } catch (final IOException e) {
            Log.e("Network.getResponseStream", e);
            return null;
        }
    }

    @Nullable
    private static String getResponseDataNoError(final HttpResponse response, boolean replaceWhitespace) {
        try {
            String data = EntityUtils.toString(response.getEntity(), CharEncoding.UTF_8);
            return replaceWhitespace ? TextUtils.replaceWhitespace(data) : data;
        } catch (Exception e) {
            Log.e("getResponseData", e);
            return null;
        }
    }

    /**
     * Get the body of a HTTP response.
     *
     * {@link TextUtils#replaceWhitespace(String)} will be called on the result
     *
     * @param response a HTTP response, which can be null
     * @return the body if the response comes from a successful HTTP request, <code>null</code> otherwise
     */
    @Nullable
    public static String getResponseData(@Nullable final HttpResponse response) {
        return getResponseData(response, true);
    }

    @Nullable
    public static String getResponseDataAlways(@Nullable final HttpResponse response) {
        return response != null ? getResponseDataNoError(response, false) : null;
    }

    /**
     * Get the body of a HTTP response.
     *
     * @param response a HTTP response, which can be null
     * @param replaceWhitespace <code>true</code> if {@link TextUtils#replaceWhitespace(String)}
     *                          should be called on the body
     * @return the body if the response comes from a successful HTTP request, <code>null</code> otherwise
     */
    @Nullable
    public static String getResponseData(@Nullable final HttpResponse response, boolean replaceWhitespace) {
        if (!isSuccess(response)) {
            return null;
        }
        assert response != null; // Caught above
        return getResponseDataNoError(response, replaceWhitespace);
    }

    @Nullable
    public static String rfc3986URLEncode(String text) {
        final String encoded = encode(text);
        return encoded != null ? StringUtils.replace(encoded.replace("+", "%20"), "%7E", "~") : null;
    }

    @Nullable
    public static String decode(final String text) {
        try {
            return URLDecoder.decode(text, CharEncoding.UTF_8);
        } catch (UnsupportedEncodingException e) {
            Log.e("Network.decode", e);
        }
        return null;
    }

    @Nullable
    public static String encode(final String text) {
        try {
            return URLEncoder.encode(text, CharEncoding.UTF_8);
        } catch (UnsupportedEncodingException e) {
            Log.e("Network.encode", e);
        }
        return null;
    }

    /**
     * Checks if the device has network connection.
     *
     * @return <code>true</code> if the device is connected to the network.
     */
    private static ConnectivityManager connectivityManager = null;
    public static boolean isNetworkConnected() {
        if (connectivityManager == null) {
            // Concurrent assignment would not hurt
            connectivityManager = (ConnectivityManager) CgeoApplication.getInstance().getApplicationContext().getSystemService(Context.CONNECTIVITY_SERVICE);
        }
        final NetworkInfo activeNetworkInfo = connectivityManager.getActiveNetworkInfo();
        return activeNetworkInfo != null && activeNetworkInfo.isConnected();
    }

}
!@#$%
20190527_005402,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_c17384
package cgeo.geocaching.network;

import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.files.LocalStorage;
import cgeo.geocaching.settings.Settings;
import cgeo.geocaching.utils.JsonUtils;
import cgeo.geocaching.utils.Log;
import cgeo.geocaching.utils.TextUtils;

import ch.boye.httpclientandroidlib.HttpEntity;
import ch.boye.httpclientandroidlib.HttpResponse;
import ch.boye.httpclientandroidlib.NameValuePair;
import ch.boye.httpclientandroidlib.client.HttpClient;
import ch.boye.httpclientandroidlib.client.entity.UrlEncodedFormEntity;
import ch.boye.httpclientandroidlib.client.methods.HttpGet;
import ch.boye.httpclientandroidlib.client.methods.HttpPost;
import ch.boye.httpclientandroidlib.client.methods.HttpRequestBase;
import ch.boye.httpclientandroidlib.client.params.ClientPNames;
import ch.boye.httpclientandroidlib.entity.StringEntity;
import ch.boye.httpclientandroidlib.entity.mime.MultipartEntity;
import ch.boye.httpclientandroidlib.entity.mime.content.FileBody;
import ch.boye.httpclientandroidlib.entity.mime.content.StringBody;
import ch.boye.httpclientandroidlib.impl.client.DecompressingHttpClient;
import ch.boye.httpclientandroidlib.impl.client.DefaultHttpClient;
import ch.boye.httpclientandroidlib.impl.client.LaxRedirectStrategy;
import ch.boye.httpclientandroidlib.params.BasicHttpParams;
import ch.boye.httpclientandroidlib.params.CoreConnectionPNames;
import ch.boye.httpclientandroidlib.params.CoreProtocolPNames;
import ch.boye.httpclientandroidlib.params.HttpParams;
import ch.boye.httpclientandroidlib.util.EntityUtils;

import com.fasterxml.jackson.databind.node.ObjectNode;

import org.apache.commons.lang3.CharEncoding;
import org.apache.commons.lang3.StringUtils;
import org.eclipse.jdt.annotation.Nullable;

import android.content.Context;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.net.Uri;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.util.regex.Pattern;

public abstract class Network {

    /** User agent id */
    private final static String PC_USER_AGENT = "Mozilla/5.0 (X11; Linux x86_64; rv:9.0.1) Gecko/20100101 Firefox/9.0.1";
    /** Native user agent, taken from a Android 2.2 Nexus **/
    private final static String NATIVE_USER_AGENT = "Mozilla/5.0 (Linux; U; Android 2.2; en-us; Nexus One Build/FRF91) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1";

    private static final Pattern PATTERN_PASSWORD = Pattern.compile("(?<=[\\?&])[Pp]ass(w(or)?d)?=[^&#$]+");

    private final static HttpParams clientParams = new BasicHttpParams();

    static {
        clientParams.setParameter(CoreProtocolPNames.HTTP_CONTENT_CHARSET, CharEncoding.UTF_8);
        clientParams.setParameter(CoreConnectionPNames.CONNECTION_TIMEOUT, 30000);
        clientParams.setParameter(CoreConnectionPNames.SO_TIMEOUT, 90000);
        clientParams.setParameter(ClientPNames.HANDLE_REDIRECTS,  true);
    }

    private static String hidePassword(final String message) {
        return PATTERN_PASSWORD.matcher(message).replaceAll("password=***");
    }

    private static HttpClient getHttpClient() {
        final DefaultHttpClient client = new DefaultHttpClient();
        client.setCookieStore(Cookies.cookieStore);
        client.setParams(clientParams);
        client.setRedirectStrategy(new LaxRedirectStrategy());
        return new DecompressingHttpClient(client);
    }

    /**
     * POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @return the HTTP response, or null in case of an encoding error params
     */
    @Nullable
    public static HttpResponse postRequest(final String uri, final Parameters params) {
        return request("POST", uri, params, null, null);
    }

    /**
     * POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @params headers the headers to add to the request
     * @return the HTTP response, or null in case of an encoding error params
     */
    @Nullable
    public static HttpResponse postRequest(final String uri, final Parameters params, final Parameters headers) {
        return request("POST", uri, params, headers, null);
    }

    /**
     *  POST HTTP request with Json POST DATA
     *
     * @param uri the URI to request
     * @param json the json object to add to the POST request
     * @return the HTTP response, or null in case of an encoding error params
     */
    @Nullable
    public static HttpResponse postJsonRequest(final String uri, final ObjectNode json) {
        HttpPost request = new HttpPost(uri);
        request.addHeader("Content-Type", "application/json; charset=utf-8");
        if (json != null) {
            try {
                request.setEntity(new StringEntity(json.toString(), CharEncoding.UTF_8));
            } catch (UnsupportedEncodingException e) {
                Log.e("postJsonRequest:JSON Entity: UnsupportedEncodingException", e);
                return null;
            }
        }
        return doLogRequest(request);
    }

    /**
     * Multipart POST HTTP request
     *
     * @param uri the URI to request
     * @param params the parameters to add to the POST request
     * @param fileFieldName the name of the file field name
     * @param fileContentType the content-type of the file
     * @param file the file to include in the request
     * @return the HTTP response, or null in case of an encoding error param
     */
    @Nullable
    public static HttpResponse postRequest(final String uri, final Parameters params,
            final String fileFieldName, final String fileContentType, final File file) {
        final MultipartEntity entity = new MultipartEntity();
        for (final NameValuePair param : params) {
            try {
                entity.addPart(param.getName(), new StringBody(param.getValue(), TextUtils.CHARSET_UTF8));
            } catch (final UnsupportedEncodingException e) {
                Log.e("Network.postRequest: unsupported encoding for parameter " + param.getName(), e);
                return null;
            }
        }
        entity.addPart(fileFieldName, new FileBody(file, fileContentType));

        final HttpPost request = new HttpPost(uri);
        request.setEntity(entity);

        addHeaders(request, null, null);
        return doLogRequest(request);
    }

    /**
     * Make an HTTP request
     *
     * @param method
     *            the HTTP method to use ("GET" or "POST")
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add to the URI
     * @param headers
     *            the headers to add to the request
     * @param cacheFile
     *            the cache file used to cache this query
     * @return the HTTP response, or null in case of an encoding error in a POST request arguments
     */
    @Nullable
    private static HttpResponse request(final String method, final String uri,
                                        @Nullable final Parameters params, @Nullable final Parameters headers, @Nullable final File cacheFile) {
        HttpRequestBase request;
        if (method.equals("GET")) {
            final String fullUri = params == null ? uri : Uri.parse(uri).buildUpon().encodedQuery(params.toString()).build().toString();
            request = new HttpGet(fullUri);
        } else {
            request = new HttpPost(uri);
            if (params != null) {
                try {
                    ((HttpPost) request).setEntity(new UrlEncodedFormEntity(params, CharEncoding.UTF_8));
                } catch (final UnsupportedEncodingException e) {
                    Log.e("request", e);
                    return null;
                }
            }
        }

        addHeaders(request, headers, cacheFile);

        return doLogRequest(request);
    }

    /**
     * Add headers to HTTP request.
     * @param request
     *            the request to add headers to
     * @param headers
     *            the headers to add (in addition to the standard headers), can be null
     * @param cacheFile
     *            if non-null, the file to take ETag and If-Modified-Since information from
     */
    private static void addHeaders(final HttpRequestBase request, @Nullable final Parameters headers, @Nullable final File cacheFile) {
        for (final NameValuePair header : Parameters.extend(Parameters.merge(headers, cacheHeaders(cacheFile)),
                "Accept-Charset", "utf-8,iso-8859-1;q=0.8,utf-16;q=0.8,*;q=0.7",
                "Accept-Language", "en-US,*;q=0.9",
                "X-Requested-With", "XMLHttpRequest")) {
            request.setHeader(header.getName(), header.getValue());
        }
        request.getParams().setParameter(CoreProtocolPNames.USER_AGENT,
                Settings.getUseNativeUa() ? NATIVE_USER_AGENT : PC_USER_AGENT);
    }

    /**
     * Perform an HTTP request and log it.
     *
     * @param request
     *            the request to try
     * @return
     *            the response, or null if there has been a failure
     */
    @Nullable
    private static HttpResponse doLogRequest(final HttpRequestBase request) {
        if (!isNetworkConnected()) {
            return null;
        }

        final String reqLogStr = request.getMethod() + " " + hidePassword(request.getURI().toString());
        Log.d(reqLogStr);

        final HttpClient client = getHttpClient();
        final long before = System.currentTimeMillis();
        try {
            final HttpResponse response = client.execute(request);
            int status = response.getStatusLine().getStatusCode();
            if (status == 200) {
                Log.d(status + formatTimeSpan(before) + reqLogStr);
            } else {
                Log.w(status + " [" + response.getStatusLine().getReasonPhrase() + "]" + formatTimeSpan(before) + reqLogStr);
            }
            return response;
        } catch (final Exception e) {
            final String timeSpan = formatTimeSpan(before);
            Log.w("Failure" + timeSpan + reqLogStr + " (" + e.toString() + ")");
        }

        return null;
    }

    @Nullable
    private static Parameters cacheHeaders(@Nullable final File cacheFile) {
        if (cacheFile == null || !cacheFile.exists()) {
            return null;
        }

        final String etag = LocalStorage.getSavedHeader(cacheFile, LocalStorage.HEADER_ETAG);
        if (etag != null) {
            // The ETag is a more robust check than a timestamp. If we have an ETag, it is enough
            // to identify the right version of the resource.
            return new Parameters("If-None-Match", etag);
        }

        final String lastModified = LocalStorage.getSavedHeader(cacheFile, LocalStorage.HEADER_LAST_MODIFIED);
        if (lastModified != null) {
            return new Parameters("If-Modified-Since", lastModified);
        }

        return null;
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @param cacheFile
     *            the name of the file storing the cached resource, or null not to use one
     * @return the HTTP response
     */
    @Nullable
    public static HttpResponse getRequest(final String uri, @Nullable final Parameters params, @Nullable final File cacheFile) {
        return request("GET", uri, params, null, cacheFile);
    }


    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @return the HTTP response
     */
    @Nullable
    public static HttpResponse getRequest(final String uri, @Nullable final Parameters params) {
        return request("GET", uri, params, null, null);
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @param params
     *            the parameters to add the the GET request
     * @param headers
     *            the headers to add to the GET request
     * @return the HTTP response
     */
    @Nullable
    public static HttpResponse getRequest(final String uri, @Nullable final Parameters params, @Nullable final Parameters headers) {
        return request("GET", uri, params, headers, null);
    }

    /**
     * GET HTTP request
     *
     * @param uri
     *            the URI to request
     * @return the HTTP response
     */
    @Nullable
    public static HttpResponse getRequest(final String uri) {
        return request("GET", uri, null, null, null);
    }

    private static String formatTimeSpan(final long before) {
        // don't use String.format in a pure logging routine, it has very bad performance
        return " (" + (System.currentTimeMillis() - before) + " ms) ";
    }

    static public boolean isSuccess(@Nullable final HttpResponse response) {
        return response != null && response.getStatusLine().getStatusCode() == 200;
    }

    static public boolean isPageNotFound(@Nullable final HttpResponse response) {
        return response != null && response.getStatusLine().getStatusCode() == 404;
    }

    /**
     * Get the result of a GET HTTP request returning a JSON body.
     *
     * @param uri the base URI of the GET HTTP request
     * @param params the query parameters, or <code>null</code> if there are none
     * @return a JSON object if the request was successful and the body could be decoded, <code>null</code> otherwise
     */
    @Nullable
    public static ObjectNode requestJSON(final String uri, @Nullable final Parameters params) {
        final HttpResponse response = request("GET", uri, params, new Parameters("Accept", "application/json, text/javascript, */*; q=0.01"), null);
        final String responseData = getResponseData(response, false);
        if (responseData != null) {
            try {
                return (ObjectNode) JsonUtils.reader.readTree(responseData);
            } catch (final IOException e) {
                Log.w("requestJSON", e);
            }
        }

        return null;
    }

    /**
     * Get the input stream corresponding to a HTTP response if it exists.
     *
     * @param response a HTTP response, which can be null
     * @return the input stream if the HTTP request is successful, <code>null</code> otherwise
     */
    @Nullable
    public static InputStream getResponseStream(@Nullable final HttpResponse response) {
        if (!isSuccess(response)) {
            return null;
        }
        assert(response != null);
        final HttpEntity entity = response.getEntity();
        if (entity == null) {
            return null;
        }
        try {
            return entity.getContent();
        } catch (final IOException e) {
            Log.e("Network.getResponseStream", e);
            return null;
        }
    }

    @Nullable
    private static String getResponseDataNoError(final HttpResponse response, boolean replaceWhitespace) {
        try {
            String data = EntityUtils.toString(response.getEntity(), CharEncoding.UTF_8);
            return replaceWhitespace ? TextUtils.replaceWhitespace(data) : data;
        } catch (Exception e) {
            Log.e("getResponseData", e);
            return null;
        }
    }

    /**
     * Get the body of a HTTP response.
     *
     * {@link TextUtils#replaceWhitespace(String)} will be called on the result
     *
     * @param response a HTTP response, which can be null
     * @return the body if the response comes from a successful HTTP request, <code>null</code> otherwise
     */
    @Nullable
    public static String getResponseData(@Nullable final HttpResponse response) {
        return getResponseData(response, true);
    }

    @Nullable
    public static String getResponseDataAlways(@Nullable final HttpResponse response) {
        return response != null ? getResponseDataNoError(response, false) : null;
    }

    /**
     * Get the body of a HTTP response.
     *
     * @param response a HTTP response, which can be null
     * @param replaceWhitespace <code>true</code> if {@link TextUtils#replaceWhitespace(String)}
     *                          should be called on the body
     * @return the body if the response comes from a successful HTTP request, <code>null</code> otherwise
     */
    @Nullable
    public static String getResponseData(@Nullable final HttpResponse response, boolean replaceWhitespace) {
        if (!isSuccess(response)) {
            return null;
        }
        assert response != null; // Caught above
        return getResponseDataNoError(response, replaceWhitespace);
    }

    @Nullable
    public static String rfc3986URLEncode(String text) {
        final String encoded = encode(text);
        return encoded != null ? StringUtils.replace(encoded.replace("+", "%20"), "%7E", "~") : null;
    }

    @Nullable
    public static String decode(final String text) {
        try {
            return URLDecoder.decode(text, CharEncoding.UTF_8);
        } catch (UnsupportedEncodingException e) {
            Log.e("Network.decode", e);
        }
        return null;
    }

    @Nullable
    public static String encode(final String text) {
        try {
            return URLEncoder.encode(text, CharEncoding.UTF_8);
        } catch (UnsupportedEncodingException e) {
            Log.e("Network.encode", e);
        }
        return null;
    }

    /**
     * Checks if the device has network connection.
     *
     * @return <code>true</code> if the device is connected to the network.
     */
    private static ConnectivityManager connectivityManager = null;
    public static boolean isNetworkConnected() {
        if (connectivityManager == null) {
            // Concurrent assignment would not hurt
            connectivityManager = (ConnectivityManager) CgeoApplication.getInstance().getApplicationContext().getSystemService(Context.CONNECTIVITY_SERVICE);
        }
        final NetworkInfo activeNetworkInfo = connectivityManager.getActiveNetworkInfo();
        return activeNetworkInfo != null && activeNetworkInfo.isConnected();
    }

}
!@#$%
20190527_010215,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_b08976
package cgeo.geocaching.settings;

import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.R;
import cgeo.geocaching.apps.cache.navi.NavigationAppFactory.NavigationAppsEnum;
import cgeo.geocaching.connector.capability.ICredentials;
import cgeo.geocaching.connector.gc.GCConnector;
import cgeo.geocaching.connector.gc.GCConstants;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.LogTypeTrackable;
import cgeo.geocaching.list.StoredList;
import cgeo.geocaching.location.Geopoint;
import cgeo.geocaching.maps.CGeoMap.MapMode;
import cgeo.geocaching.maps.MapProviderFactory;
import cgeo.geocaching.maps.LivemapStrategy;
import cgeo.geocaching.maps.google.v1.GoogleMapProvider;
import cgeo.geocaching.maps.interfaces.GeoPointImpl;
import cgeo.geocaching.maps.interfaces.MapProvider;
import cgeo.geocaching.maps.interfaces.MapSource;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider.OfflineMapSource;
import cgeo.geocaching.utils.CryptUtils;
import cgeo.geocaching.utils.FileUtils;
import cgeo.geocaching.utils.FileUtils.FileSelector;
import cgeo.geocaching.utils.Log;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.os.Build;
import android.os.Build.VERSION;
import android.os.Build.VERSION_CODES;
import android.os.Environment;
import android.preference.PreferenceManager;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;

/**
 * General c:geo preferences/settings set by the user
 */
public class Settings {

    /**
     * On opening a map, we limit the _initial_ zoom. The user can still zoom out afterwards.
     */
    private static final int INITIAL_MAP_ZOOM_LIMIT = 16;
    private static final char HISTORY_SEPARATOR = ',';
    public static final int SHOW_WP_THRESHOLD_DEFAULT = 10;
    public static final int SHOW_WP_THRESHOLD_MAX = 50;
    private static final int MAP_SOURCE_DEFAULT = GoogleMapProvider.GOOGLE_MAP_ID.hashCode();

    public static final boolean HW_ACCEL_DISABLED_BY_DEFAULT =
            Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1 ||
            StringUtils.equals(Build.MODEL, "HTC One X") ||    // HTC One X
            StringUtils.equals(Build.MODEL, "HTC One S") ||    // HTC One S
            StringUtils.equals(Build.MODEL, "GT-I8190")  ||    // Samsung S3 mini
            StringUtils.equals(Build.MODEL, "GT-S6310L") ||    // Samsung Galaxy Young
            StringUtils.equals(Build.MODEL, "GT-P5210")  ||    // Samsung Galaxy Tab 3
            StringUtils.equals(Build.MODEL, "GT-S7580")  ||    // Samsung Galaxy Trend Plus
            StringUtils.equals(Build.MODEL, "GT-I9105P") ||    // Samsung Galaxy SII Plus
            StringUtils.equals(Build.MODEL, "ST25i")     ||    // Sony Xperia U
            StringUtils.equals(Build.MODEL, "bq Aquaris 5");   // bq Aquaris 5

    // twitter api keys
    private final static @NonNull String TWITTER_KEY_CONSUMER_PUBLIC = CryptUtils.rot13("ESnsCvAv3kEupF1GCR3jGj");
    private final static @NonNull String TWITTER_KEY_CONSUMER_SECRET = CryptUtils.rot13("7vQWceACV9umEjJucmlpFe9FCMZSeqIqfkQ2BnhV9x");

    private static boolean useCompass = true;

    public enum CoordInputFormatEnum {
        Plain,
        Deg,
        Min,
        Sec;

        static final int DEFAULT_INT_VALUE = Min.ordinal();

        public static CoordInputFormatEnum fromInt(final int id) {
            final CoordInputFormatEnum[] values = CoordInputFormatEnum.values();
            if (id < 0 || id >= values.length) {
                return Min;
            }
            return values[id];
        }
    }

    private static final SharedPreferences sharedPrefs = PreferenceManager
            .getDefaultSharedPreferences(CgeoApplication.getInstance().getBaseContext());
    static {
        migrateSettings();
        final boolean isDebug = sharedPrefs.getBoolean(getKey(R.string.pref_debug), false);
        Log.setDebug(isDebug);
        CgeoApplication.dumpOnOutOfMemory(isDebug);
    }

    /**
     * Cache the mapsource locally. If that is an offline map source, each request would potentially access the
     * underlying map file, leading to delays.
     */
    private static MapSource mapSource;

    protected Settings() {
        throw new InstantiationError();
    }

    private static void migrateSettings() {
        final int LATEST_PREFERENCES_VERSION = 2;
        final int currentVersion = getInt(R.string.pref_settingsversion, 0);

        // No need to migrate if we are up to date.
        if (currentVersion == LATEST_PREFERENCES_VERSION) {
            return;
        }

        // No need to migrate if we don't have older settings, defaults will be used instead.
        final String preferencesNameV0 = "cgeo.pref";
        final SharedPreferences prefsV0 = CgeoApplication.getInstance().getSharedPreferences(preferencesNameV0, Context.MODE_PRIVATE);
        if (currentVersion == 0 && prefsV0.getAll().isEmpty()) {
            final Editor e = sharedPrefs.edit();
            e.putInt(getKey(R.string.pref_settingsversion), LATEST_PREFERENCES_VERSION);
            e.apply();
            return;
        }

        if (currentVersion < 1) {
            // migrate from non standard file location and integer based boolean types
            final Editor e = sharedPrefs.edit();

            e.putString(getKey(R.string.pref_temp_twitter_token_secret), prefsV0.getString(getKey(R.string.pref_temp_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_temp_twitter_token_public), prefsV0.getString(getKey(R.string.pref_temp_twitter_token_public), null));
            e.putBoolean(getKey(R.string.pref_help_shown), prefsV0.getInt(getKey(R.string.pref_help_shown), 0) != 0);
            e.putFloat(getKey(R.string.pref_anylongitude), prefsV0.getFloat(getKey(R.string.pref_anylongitude), 0));
            e.putFloat(getKey(R.string.pref_anylatitude), prefsV0.getFloat(getKey(R.string.pref_anylatitude), 0));
            e.putBoolean(getKey(R.string.pref_offlinemaps), 0 != prefsV0.getInt(getKey(R.string.pref_offlinemaps), 1));
            e.putBoolean(getKey(R.string.pref_offlinewpmaps), 0 != prefsV0.getInt(getKey(R.string.pref_offlinewpmaps), 0));
            e.putString(getKey(R.string.pref_webDeviceCode), prefsV0.getString(getKey(R.string.pref_webDeviceCode), null));
            e.putString(getKey(R.string.pref_webDeviceName), prefsV0.getString(getKey(R.string.pref_webDeviceName), null));
            e.putBoolean(getKey(R.string.pref_maplive), prefsV0.getInt(getKey(R.string.pref_maplive), 1) != 0);
            e.putInt(getKey(R.string.pref_mapsource), prefsV0.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT));
            e.putBoolean(getKey(R.string.pref_twitter), 0 != prefsV0.getInt(getKey(R.string.pref_twitter), 0));
            e.putBoolean(getKey(R.string.pref_showaddress), 0 != prefsV0.getInt(getKey(R.string.pref_showaddress), 1));
            e.putBoolean(getKey(R.string.pref_showcaptcha), prefsV0.getBoolean(getKey(R.string.pref_showcaptcha), false));
            e.putBoolean(getKey(R.string.pref_maptrail), prefsV0.getInt(getKey(R.string.pref_maptrail), 1) != 0);
            e.putInt(getKey(R.string.pref_lastmapzoom), prefsV0.getInt(getKey(R.string.pref_lastmapzoom), 14));
            e.putBoolean(getKey(R.string.pref_livelist), 0 != prefsV0.getInt(getKey(R.string.pref_livelist), 1));
            e.putBoolean(getKey(R.string.pref_units_imperial), prefsV0.getInt(getKey(R.string.pref_units_imperial), 1) != 1);
            e.putBoolean(getKey(R.string.pref_skin), prefsV0.getInt(getKey(R.string.pref_skin), 0) != 0);
            e.putInt(getKey(R.string.pref_lastusedlist), prefsV0.getInt(getKey(R.string.pref_lastusedlist), StoredList.STANDARD_LIST_ID));
            e.putString(getKey(R.string.pref_cachetype), prefsV0.getString(getKey(R.string.pref_cachetype), CacheType.ALL.id));
            e.putString(getKey(R.string.pref_twitter_token_secret), prefsV0.getString(getKey(R.string.pref_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_twitter_token_public), prefsV0.getString(getKey(R.string.pref_twitter_token_public), null));
            e.putInt(getKey(R.string.pref_version), prefsV0.getInt(getKey(R.string.pref_version), 0));
            e.putBoolean(getKey(R.string.pref_autoloaddesc), 0 != prefsV0.getInt(getKey(R.string.pref_autoloaddesc), 1));
            e.putBoolean(getKey(R.string.pref_ratingwanted), prefsV0.getBoolean(getKey(R.string.pref_ratingwanted), true));
            e.putBoolean(getKey(R.string.pref_friendlogswanted), prefsV0.getBoolean(getKey(R.string.pref_friendlogswanted), true));
            e.putBoolean(getKey(R.string.pref_useenglish), prefsV0.getBoolean(getKey(R.string.pref_useenglish), false));
            e.putBoolean(getKey(R.string.pref_usecompass), 0 != prefsV0.getInt(getKey(R.string.pref_usecompass), 1));
            e.putBoolean(getKey(R.string.pref_trackautovisit), prefsV0.getBoolean(getKey(R.string.pref_trackautovisit), false));
            e.putBoolean(getKey(R.string.pref_sigautoinsert), prefsV0.getBoolean(getKey(R.string.pref_sigautoinsert), false));
            e.putBoolean(getKey(R.string.pref_logimages), prefsV0.getBoolean(getKey(R.string.pref_logimages), false));
            e.putBoolean(getKey(R.string.pref_excludedisabled), 0 != prefsV0.getInt(getKey(R.string.pref_excludedisabled), 0));
            e.putBoolean(getKey(R.string.pref_excludemine), 0 != prefsV0.getInt(getKey(R.string.pref_excludemine), 0));
            e.putString(getKey(R.string.pref_mapfile), prefsV0.getString(getKey(R.string.pref_mapfile), null));
            e.putString(getKey(R.string.pref_signature), prefsV0.getString(getKey(R.string.pref_signature), null));
            e.putString(getKey(R.string.pref_pass_vote), prefsV0.getString(getKey(R.string.pref_pass_vote), null));
            e.putString(getKey(R.string.pref_password), prefsV0.getString(getKey(R.string.pref_password), null));
            e.putString(getKey(R.string.pref_username), prefsV0.getString(getKey(R.string.pref_username), null));
            e.putString(getKey(R.string.pref_memberstatus), prefsV0.getString(getKey(R.string.pref_memberstatus), ""));
            e.putInt(getKey(R.string.pref_coordinputformat), prefsV0.getInt(getKey(R.string.pref_coordinputformat), CoordInputFormatEnum.DEFAULT_INT_VALUE));
            e.putBoolean(getKey(R.string.pref_log_offline), prefsV0.getBoolean(getKey(R.string.pref_log_offline), false));
            e.putBoolean(getKey(R.string.pref_choose_list), prefsV0.getBoolean(getKey(R.string.pref_choose_list), true));
            e.putBoolean(getKey(R.string.pref_loaddirectionimg), prefsV0.getBoolean(getKey(R.string.pref_loaddirectionimg), true));
            e.putString(getKey(R.string.pref_gccustomdate), prefsV0.getString(getKey(R.string.pref_gccustomdate), GCConstants.DEFAULT_GC_DATE));
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), prefsV0.getInt(getKey(R.string.pref_showwaypointsthreshold), SHOW_WP_THRESHOLD_DEFAULT));
            e.putString(getKey(R.string.pref_cookiestore), prefsV0.getString(getKey(R.string.pref_cookiestore), null));
            e.putBoolean(getKey(R.string.pref_opendetailslastpage), prefsV0.getBoolean(getKey(R.string.pref_opendetailslastpage), false));
            e.putInt(getKey(R.string.pref_lastdetailspage), prefsV0.getInt(getKey(R.string.pref_lastdetailspage), 1));
            e.putInt(getKey(R.string.pref_defaultNavigationTool), prefsV0.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id));
            e.putInt(getKey(R.string.pref_defaultNavigationTool2), prefsV0.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id));
            e.putInt(getKey(R.string.pref_livemapstrategy), prefsV0.getInt(getKey(R.string.pref_livemapstrategy), LivemapStrategy.AUTO.id));
            e.putBoolean(getKey(R.string.pref_debug), prefsV0.getBoolean(getKey(R.string.pref_debug), false));
            e.putInt(getKey(R.string.pref_livemaphintshowcount), prefsV0.getInt(getKey(R.string.pref_livemaphintshowcount), 0));

            e.putInt(getKey(R.string.pref_settingsversion), 1); // mark migrated
            e.apply();
        }

        // changes for new settings dialog
        if (currentVersion < 2) {
            final Editor e = sharedPrefs.edit();

            e.putBoolean(getKey(R.string.pref_units_imperial), useImperialUnits());

            // show waypoints threshold now as a slider
            int wpThreshold = getWayPointsThreshold();
            if (wpThreshold < 0) {
                wpThreshold = 0;
            } else if (wpThreshold > SHOW_WP_THRESHOLD_MAX) {
                wpThreshold = SHOW_WP_THRESHOLD_MAX;
            }
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), wpThreshold);

            // KEY_MAP_SOURCE must be string, because it is the key for a ListPreference now
            final int ms = sharedPrefs.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT);
            e.remove(getKey(R.string.pref_mapsource));
            e.putString(getKey(R.string.pref_mapsource), String.valueOf(ms));

            // navigation tool ids must be string, because ListPreference uses strings as keys
            final int dnt1 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id);
            final int dnt2 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id);
            e.remove(getKey(R.string.pref_defaultNavigationTool));
            e.remove(getKey(R.string.pref_defaultNavigationTool2));
            e.putString(getKey(R.string.pref_defaultNavigationTool), String.valueOf(dnt1));
            e.putString(getKey(R.string.pref_defaultNavigationTool2), String.valueOf(dnt2));

            // defaults for gpx directories
            e.putString(getKey(R.string.pref_gpxImportDir), getGpxImportDir());
            e.putString(getKey(R.string.pref_gpxExportDir), getGpxExportDir());

            e.putInt(getKey(R.string.pref_settingsversion), 2); // mark migrated
            e.apply();
        }
    }

    private static String getKey(final int prefKeyId) {
        return CgeoApplication.getInstance().getString(prefKeyId);
    }

    static String getString(final int prefKeyId, final String defaultValue) {
        return sharedPrefs.getString(getKey(prefKeyId), defaultValue);
    }

    private static int getInt(final int prefKeyId, final int defaultValue) {
        return sharedPrefs.getInt(getKey(prefKeyId), defaultValue);
    }

    private static long getLong(final int prefKeyId, final long defaultValue) {
        return sharedPrefs.getLong(getKey(prefKeyId), defaultValue);
    }

    private static boolean getBoolean(final int prefKeyId, final boolean defaultValue) {
        return sharedPrefs.getBoolean(getKey(prefKeyId), defaultValue);
    }

    private static float getFloat(final int prefKeyId, final float defaultValue) {
        return sharedPrefs.getFloat(getKey(prefKeyId), defaultValue);
    }

    protected static void putString(final int prefKeyId, final String value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putString(getKey(prefKeyId), value);
        edit.apply();
    }

    protected static void putBoolean(final int prefKeyId, final boolean value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putBoolean(getKey(prefKeyId), value);
        edit.apply();
    }

    private static void putInt(final int prefKeyId, final int value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putInt(getKey(prefKeyId), value);
        edit.apply();
    }

    private static void putLong(final int prefKeyId, final long value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putLong(getKey(prefKeyId), value);
        edit.apply();
    }

    private static void putFloat(final int prefKeyId, final float value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putFloat(getKey(prefKeyId), value);
        edit.apply();
    }

    private static void remove(final int prefKeyId) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.remove(getKey(prefKeyId));
        edit.apply();
    }

    private static boolean contains(final int prefKeyId) {
        return sharedPrefs.contains(getKey(prefKeyId));
    }

    public static void setLanguage(final boolean useEnglish) {
        final Configuration config = new Configuration();
        config.locale = useEnglish ? Locale.ENGLISH : Locale.getDefault();
        final Resources resources = CgeoApplication.getInstance().getResources();
        resources.updateConfiguration(config, resources.getDisplayMetrics());
    }

    public static boolean hasGCCredentials() {
        final String preUsername = getString(R.string.pref_username, null);
        final String prePassword = getString(R.string.pref_password, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    /**
     * Get login and password information of Geocaching.com.
     *
     * @return a pair either with (login, password) or (empty, empty) if no valid information is stored
     */
    public static ImmutablePair<String, String> getGcCredentials() {
        return getCredentials(GCConnector.getInstance());
    }

    /**
     * Get login and password information.
     *
     * @return a pair either with (login, password) or (empty, empty) if no valid information is stored
     */
    public static ImmutablePair<String, String> getCredentials(final @NonNull ICredentials connector) {
        final String username = getString(connector.getUsernamePreferenceKey(), null);
        final String password = getString(connector.getPasswordPreferenceKey(), null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return new ImmutablePair<>(StringUtils.EMPTY, StringUtils.EMPTY);
        }

        return new ImmutablePair<>(username, password);
    }

    public static String getUsername() {
        return getString(R.string.pref_username, StringUtils.EMPTY);
    }

    public static boolean isGCConnectorActive() {
        return getBoolean(R.string.pref_connectorGCActive, true);
    }

    public static boolean isECConnectorActive() {
        return getBoolean(R.string.pref_connectorECActive, false);
    }

    public static boolean isOXConnectorActive() {
        return getBoolean(R.string.pref_connectorOXActive, false);
    }

    public static boolean isGCPremiumMember() {
        final String memberStatus = Settings.getGCMemberStatus();
        return StringUtils.equalsIgnoreCase(memberStatus, GCConstants.MEMBER_STATUS_PREMIUM) ||
                StringUtils.equalsIgnoreCase(memberStatus, GCConstants.MEMBER_STATUS_CHARTER);
    }

    public static String getGCMemberStatus() {
        return getString(R.string.pref_memberstatus, "");
    }

    public static void setGCMemberStatus(final String memberStatus) {
        if (StringUtils.isBlank(memberStatus)) {
            remove(R.string.pref_memberstatus);
        }
        putString(R.string.pref_memberstatus, memberStatus);
    }

    public static ImmutablePair<String, String> getTokenPair(final int tokenPublicPrefKey, final int tokenSecretPrefKey) {
        return new ImmutablePair<>(getString(tokenPublicPrefKey, null), getString(tokenSecretPrefKey, null));
    }

    public static void setTokens(final int tokenPublicPrefKey, @Nullable final String tokenPublic, final int tokenSecretPrefKey, @Nullable final String tokenSecret) {
        if (tokenPublic == null) {
            remove(tokenPublicPrefKey);
        } else {
            putString(tokenPublicPrefKey, tokenPublic);
        }
        if (tokenSecret == null) {
            remove(tokenSecretPrefKey);
        } else {
            putString(tokenSecretPrefKey, tokenSecret);
        }
    }

    public static boolean isOCConnectorActive(final int isActivePrefKeyId) {
        return getBoolean(isActivePrefKeyId, false);
    }

    public static boolean hasOCAuthorization(final int tokenPublicPrefKeyId, final int tokenSecretPrefKeyId) {
        return StringUtils.isNotBlank(getString(tokenPublicPrefKeyId, ""))
                && StringUtils.isNotBlank(getString(tokenSecretPrefKeyId, ""));
    }

    public static boolean isGCvoteLogin() {
        return getGCvoteLogin() != null;
    }

    public static ImmutablePair<String, String> getGCvoteLogin() {
        final String username = getString(R.string.pref_username, null);
        final String password = getString(R.string.pref_pass_vote, null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return null;
        }

        return new ImmutablePair<>(username, password);
    }

    public static String getSignature() {
        return getString(R.string.pref_signature, StringUtils.EMPTY);
    }

    public static void setCookieStore(final String cookies) {
        if (StringUtils.isBlank(cookies)) {
            // erase cookies
            remove(R.string.pref_cookiestore);
        }
        // save cookies
        putString(R.string.pref_cookiestore, cookies);
    }

    public static String getCookieStore() {
        return getString(R.string.pref_cookiestore, null);
    }

    public static void setUseGooglePlayServices(final boolean value) {
        putBoolean(R.string.pref_googleplayservices, value);
    }

    public static boolean useGooglePlayServices() {
        // By defaut, enable play services starting from ICS.
        return CgeoApplication.getInstance().isGooglePlayServicesAvailable() &&
                getBoolean(R.string.pref_googleplayservices, VERSION.SDK_INT >= VERSION_CODES.ICE_CREAM_SANDWICH);
    }

    public static boolean useLowPowerMode() {
        return getBoolean(R.string.pref_lowpowermode, false);
    }

    /**
     * @param cacheType
     *            The cache type used for future filtering
     */
    public static void setCacheType(final CacheType cacheType) {
        if (cacheType == null) {
            remove(R.string.pref_cachetype);
        } else {
            putString(R.string.pref_cachetype, cacheType.id);
        }
    }

    public static int getLastList() {
        return getInt(R.string.pref_lastusedlist, StoredList.STANDARD_LIST_ID);
    }

    public static void saveLastList(final int listId) {
        putInt(R.string.pref_lastusedlist, listId);
    }

    public static void setWebNameCode(final String name, final String code) {
        putString(R.string.pref_webDeviceName, name);
        putString(R.string.pref_webDeviceCode, code);
    }

    public static MapProvider getMapProvider() {
        return getMapSource().getMapProvider();
    }

    public static String getMapFile() {
        return getString(R.string.pref_mapfile, null);
    }

    public static void setMapFile(final String mapFile) {
        putString(R.string.pref_mapfile, mapFile);
        if (mapFile != null) {
            setMapFileDirectory(new File(mapFile).getParent());
        }
    }

    public static String getMapFileDirectory() {
        final String mapDir = getString(R.string.pref_mapDirectory, null);
        if (mapDir != null) {
            return mapDir;
        }
        final String mapFile = getMapFile();
        if (mapFile != null) {
            return new File(mapFile).getParent();
        }
        return null;
    }

    public static void setMapFileDirectory(final String mapFileDirectory) {
        putString(R.string.pref_mapDirectory, mapFileDirectory);
        MapsforgeMapProvider.getInstance().updateOfflineMaps();
    }

    public static boolean isValidMapFile() {
        return isValidMapFile(getMapFile());
    }

    public static boolean isValidMapFile(final String mapFileIn) {
        return MapsforgeMapProvider.isValidMapFile(mapFileIn);
    }

    public static boolean isScaleMapsforgeText() {
        return getBoolean(R.string.pref_mapsforge_scale_text, true);
    }

    public static CoordInputFormatEnum getCoordInputFormat() {
        return CoordInputFormatEnum.fromInt(getInt(R.string.pref_coordinputformat, CoordInputFormatEnum.DEFAULT_INT_VALUE));
    }

    public static void setCoordInputFormat(final CoordInputFormatEnum format) {
        putInt(R.string.pref_coordinputformat, format.ordinal());
    }

    public static boolean getLogOffline() {
        return getBoolean(R.string.pref_log_offline, false);
    }

    public static boolean getChooseList() {
        return getBoolean(R.string.pref_choose_list, false);
    }

    public static boolean getLoadDirImg() {
        return !isGCPremiumMember() && getBoolean(R.string.pref_loaddirectionimg, true);
    }

    public static void setGcCustomDate(final String format) {
        putString(R.string.pref_gccustomdate, format);
    }

    /**
     * @return User selected date format on GC.com
     */
    public static String getGcCustomDate() {
        // We might have some users whose stored value is null, which is invalid. In this case, we use the default.
        return StringUtils.defaultString(getString(R.string.pref_gccustomdate, GCConstants.DEFAULT_GC_DATE),
                GCConstants.DEFAULT_GC_DATE);
    }

    public static boolean isExcludeMyCaches() {
        return getBoolean(R.string.pref_excludemine, false);
    }

    public static boolean isUseEnglish() {
        return getBoolean(R.string.pref_useenglish, false);
    }

    public static boolean isShowAddress() {
        return getBoolean(R.string.pref_showaddress, true);
    }

    public static boolean isShowCaptcha() {
        return !isGCPremiumMember() && getBoolean(R.string.pref_showcaptcha, false);
    }

    public static boolean isExcludeDisabledCaches() {
        return getBoolean(R.string.pref_excludedisabled, false);
    }

    public static boolean isStoreOfflineMaps() {
        return getBoolean(R.string.pref_offlinemaps, true);
    }

    public static boolean isStoreOfflineWpMaps() {
        return getBoolean(R.string.pref_offlinewpmaps, false);
    }

    public static boolean isStoreLogImages() {
        return getBoolean(R.string.pref_logimages, false);
    }

    public static boolean isAutoLoadDescription() {
        return getBoolean(R.string.pref_autoloaddesc, true);
    }

    public static boolean isRatingWanted() {
        return getBoolean(R.string.pref_ratingwanted, true);
    }

    public static boolean isGeokretyConnectorActive() {
        return getBoolean(R.string.pref_connectorGeokretyActive, true);
    }

    public static boolean isGeokretyCacheActive() {
        return getBoolean(R.string.pref_geokrety_cache, true);
    }

    public static String getGeokretyUsername() {
        return getString(R.string.pref_geokrety_username, null);
    }

    public static String getGeokretyPassword() {
        return getString(R.string.pref_geokrety_password, null);
    }

    public static String getGeokretySecId() {
        return getString(R.string.pref_geokrety_secid, null);
    }

    public static void setGeokretySecId(final String secid) {
        putString(R.string.pref_geokrety_secid, secid);
    }

    public static boolean isRegisteredForGeokrety() {
        return getGeokretySecId() != null;
    }

    public static boolean isFriendLogsWanted() {
        if (!hasGCCredentials()) {
            // don't show a friends log if the user is anonymous
            return false;
        }
        return getBoolean(R.string.pref_friendlogswanted, true);
    }

    public static boolean isLiveList() {
        return getBoolean(R.string.pref_livelist, true);
    }

    public static boolean isTrackableAutoVisit() {
        return getBoolean(R.string.pref_trackautovisit, false);
    }

    public static boolean isAutoInsertSignature() {
        return getBoolean(R.string.pref_sigautoinsert, false);
    }

    public static void setUseImperialUnits(final boolean useImperialUnits) {
        putBoolean(R.string.pref_units_imperial, useImperialUnits);
    }

    public static boolean useImperialUnits() {
        return getBoolean(R.string.pref_units_imperial, useImperialUnitsByDefault());
    }

    static boolean useImperialUnitsByDefault() {
        final String countryCode = Locale.getDefault().getCountry();
        return "US".equals(countryCode)  // USA
            || "LR".equals(countryCode)  // Liberia
            || "MM".equals(countryCode); // Burma
    }

    public static boolean isLiveMap() {
        return getBoolean(R.string.pref_maplive, true);
    }

    public static void setLiveMap(final boolean live) {
        putBoolean(R.string.pref_maplive, live);
    }

    public static boolean isMapTrail() {
        return getBoolean(R.string.pref_maptrail, false);
    }

    public static void setMapTrail(final boolean showTrail) {
        putBoolean(R.string.pref_maptrail, showTrail);
    }

    /**
     * Get last used zoom of the internal map. Differentiate between two use cases for a map of multiple caches (e.g.
     * live map) and the map of a single cache (which is often zoomed in more deep).
     */
    public static int getMapZoom(final MapMode mapMode) {
        if (mapMode == MapMode.SINGLE || mapMode == MapMode.COORDS) {
            return getCacheZoom();
        }
        return getMapZoom();
    }

    public static void setMapZoom(final MapMode mapMode, final int zoomLevel) {
        if (mapMode == MapMode.SINGLE || mapMode == MapMode.COORDS) {
            setCacheZoom(zoomLevel);
        }
        else {
            setMapZoom(zoomLevel);
        }
    }

    /**
     * @return zoom used for the (live) map
     */
    private static int getMapZoom() {
        return Math.max(getInt(R.string.pref_lastmapzoom, 14), INITIAL_MAP_ZOOM_LIMIT);
    }

    private static void setMapZoom(final int mapZoomLevel) {
        putInt(R.string.pref_lastmapzoom, mapZoomLevel);
    }

    /**
     * @return zoom used for the map of a single cache
     */
    private static int getCacheZoom() {
        return Math.max(getInt(R.string.pref_cache_zoom, 14), INITIAL_MAP_ZOOM_LIMIT);
    }

    private static void setCacheZoom(final int zoomLevel) {
        putInt(R.string.pref_cache_zoom, zoomLevel);
    }

    public static GeoPointImpl getMapCenter() {
        return getMapProvider().getMapItemFactory()
                .getGeoPointBase(new Geopoint(getInt(R.string.pref_lastmaplat, 0) / 1e6,
                        getInt(R.string.pref_lastmaplon, 0) / 1e6));
    }

    public static void setMapCenter(final GeoPointImpl mapViewCenter) {
        putInt(R.string.pref_lastmaplat, mapViewCenter.getLatitudeE6());
        putInt(R.string.pref_lastmaplon, mapViewCenter.getLongitudeE6());
    }

    @NonNull
    public static synchronized MapSource getMapSource() {
        if (mapSource != null) {
            return mapSource;
        }
        final int id = getConvertedMapId();
        mapSource = MapProviderFactory.getMapSource(id);
        if (mapSource != null) {
            // don't use offline maps if the map file is not valid
            if (!(mapSource instanceof OfflineMapSource) || isValidMapFile()) {
                return mapSource;
            }
        }
        // fallback to first available map
        return MapProviderFactory.getDefaultSource();
    }

    private final static int GOOGLEMAP_BASEID = 30;
    private final static int MAP = 1;
    private final static int SATELLITE = 2;

    private final static int MFMAP_BASEID = 40;
    private final static int MAPNIK = 1;
    private final static int CYCLEMAP = 3;
    private final static int OFFLINE = 4;
    private static final int HISTORY_SIZE = 10;

    /**
     * Convert old preference ids for maps (based on constant values) into new hash based ids.
     */
    private static int getConvertedMapId() {
        final int id = Integer.parseInt(getString(R.string.pref_mapsource,
                String.valueOf(MAP_SOURCE_DEFAULT)));
        switch (id) {
            case GOOGLEMAP_BASEID + MAP:
                return GoogleMapProvider.GOOGLE_MAP_ID.hashCode();
            case GOOGLEMAP_BASEID + SATELLITE:
                return GoogleMapProvider.GOOGLE_SATELLITE_ID.hashCode();
            case MFMAP_BASEID + MAPNIK:
                return MapsforgeMapProvider.MAPSFORGE_MAPNIK_ID.hashCode();
            case MFMAP_BASEID + CYCLEMAP:
                return MapsforgeMapProvider.MAPSFORGE_CYCLEMAP_ID.hashCode();
            case MFMAP_BASEID + OFFLINE: {
                final String mapFile = Settings.getMapFile();
                if (StringUtils.isNotEmpty(mapFile)) {
                    return mapFile.hashCode();
                }
                break;
            }
            default:
                break;
        }
        return id;
    }

    public static synchronized void setMapSource(final MapSource newMapSource) {
        putString(R.string.pref_mapsource, String.valueOf(newMapSource.getNumericalId()));
        if (newMapSource instanceof OfflineMapSource) {
            setMapFile(((OfflineMapSource) newMapSource).getFileName());
        }
        // cache the value
        mapSource = newMapSource;
    }

    public static void setAnyCoordinates(final Geopoint coords) {
        if (null != coords) {
            putFloat(R.string.pref_anylatitude, (float) coords.getLatitude());
            putFloat(R.string.pref_anylongitude, (float) coords.getLongitude());
        } else {
            remove(R.string.pref_anylatitude);
            remove(R.string.pref_anylongitude);
        }
    }

    public static Geopoint getAnyCoordinates() {
        if (contains(R.string.pref_anylatitude) && contains(R.string.pref_anylongitude)) {
            final float lat = getFloat(R.string.pref_anylatitude, 0);
            final float lon = getFloat(R.string.pref_anylongitude, 0);
            return new Geopoint(lat, lon);
        }
        return null;
    }

    public static boolean isUseCompass() {
        return useCompass;
    }

    public static void setUseCompass(final boolean value) {
        useCompass = value;
    }

    public static boolean isLightSkin() {
        return getBoolean(R.string.pref_skin, false);
    }

    @NonNull
    public static String getTwitterKeyConsumerPublic() {
        return TWITTER_KEY_CONSUMER_PUBLIC;
    }

    @NonNull
    public static String getTwitterKeyConsumerSecret() {
        return TWITTER_KEY_CONSUMER_SECRET;
    }

    public static String getWebDeviceCode() {
        return getString(R.string.pref_webDeviceCode, null);
    }

    public static boolean isRegisteredForSend2cgeo() {
        return getWebDeviceCode() != null;
    }

    public static String getWebDeviceName() {
        return getString(R.string.pref_webDeviceName, Build.MODEL);
    }

    /**
     * @return The cache type used for filtering or ALL if no filter is active.
     *         Returns never null
     */
    @NonNull
    public static CacheType getCacheType() {
        return CacheType.getById(getString(R.string.pref_cachetype, CacheType.ALL.id));
    }

    /**
     * The Threshold for the showing of child waypoints
     */
    public static int getWayPointsThreshold() {
        return getInt(R.string.pref_showwaypointsthreshold, SHOW_WP_THRESHOLD_DEFAULT);
    }

    public static void setShowWaypointsThreshold(final int threshold) {
        putInt(R.string.pref_showwaypointsthreshold, threshold);
    }

    public static boolean isUseTwitter() {
        return getBoolean(R.string.pref_twitter, false);
    }

    public static void setUseTwitter(final boolean useTwitter) {
        putBoolean(R.string.pref_twitter, useTwitter);
    }

    public static boolean isTwitterLoginValid() {
        return !StringUtils.isBlank(getTokenPublic())
                && !StringUtils.isBlank(getTokenSecret());
    }

    public static String getTokenPublic() {
        return getString(R.string.pref_twitter_token_public, null);
    }

    public static String getTokenSecret() {
        return getString(R.string.pref_twitter_token_secret, null);

    }

    public static boolean hasTwitterAuthorization() {
        return StringUtils.isNotBlank(getTokenPublic())
                && StringUtils.isNotBlank(getTokenSecret());
    }

    public static void setTwitterTokens(@Nullable final String tokenPublic,
            @Nullable final String tokenSecret, final boolean enableTwitter) {
        putString(R.string.pref_twitter_token_public, tokenPublic);
        putString(R.string.pref_twitter_token_secret, tokenSecret);
        if (tokenPublic != null) {
            remove(R.string.pref_temp_twitter_token_public);
            remove(R.string.pref_temp_twitter_token_secret);
        }
        setUseTwitter(enableTwitter);
    }

    public static void setTwitterTempTokens(@Nullable final String tokenPublic,
            @Nullable final String tokenSecret) {
        putString(R.string.pref_temp_twitter_token_public, tokenPublic);
        putString(R.string.pref_temp_twitter_token_secret, tokenSecret);
    }

    public static ImmutablePair<String, String> getTempToken() {
        final String tokenPublic = getString(R.string.pref_temp_twitter_token_public, null);
        final String tokenSecret = getString(R.string.pref_temp_twitter_token_secret, null);
        return new ImmutablePair<>(tokenPublic, tokenSecret);
    }

    public static int getVersion() {
        return getInt(R.string.pref_version, 0);
    }

    public static void setVersion(final int version) {
        putInt(R.string.pref_version, version);
    }

    public static boolean isOpenLastDetailsPage() {
        return getBoolean(R.string.pref_opendetailslastpage, false);
    }

    public static int getLastDetailsPage() {
        return getInt(R.string.pref_lastdetailspage, 1);
    }

    public static void setLastDetailsPage(final int index) {
        putInt(R.string.pref_lastdetailspage, index);
    }

    public static int getDefaultNavigationTool() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool,
                String.valueOf(NavigationAppsEnum.COMPASS.id)));
    }

    public static int getDefaultNavigationTool2() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool2,
                String.valueOf(NavigationAppsEnum.INTERNAL_MAP.id)));
    }

    public static LivemapStrategy getLiveMapStrategy() {
        return LivemapStrategy.getById(getInt(R.string.pref_livemapstrategy, LivemapStrategy.AUTO.id));
    }

    public static void setLiveMapStrategy(final LivemapStrategy strategy) {
        putInt(R.string.pref_livemapstrategy, strategy.id);
    }

    public static boolean isDebug() {
        return Log.isDebug();
    }

    public static int getLiveMapHintShowCount() {
        return getInt(R.string.pref_livemaphintshowcount, 0);
    }

    public static void setLiveMapHintShowCount(final int showCount) {
        putInt(R.string.pref_livemaphintshowcount, showCount);
    }

    public static boolean isDbOnSDCard() {
        return getBoolean(R.string.pref_dbonsdcard, false);
    }

    public static void setDbOnSDCard(final boolean dbOnSDCard) {
        putBoolean(R.string.pref_dbonsdcard, dbOnSDCard);
    }

    public static String getGpxExportDir() {
        return getString(R.string.pref_gpxExportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static String getGpxImportDir() {
        return getString(R.string.pref_gpxImportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static boolean getShareAfterExport() {
        return getBoolean(R.string.pref_shareafterexport, true);
    }

    public static void setShareAfterExport(final boolean shareAfterExport) {
        putBoolean(R.string.pref_shareafterexport, shareAfterExport);
    }

    public static int getTrackableAction() {
        return getInt(R.string.pref_trackableaction, LogTypeTrackable.RETRIEVED_IT.id);
    }

    public static void setTrackableAction(final int trackableAction) {
        putInt(R.string.pref_trackableaction, trackableAction);
    }

    public static String getCustomRenderThemeBaseFolder() {
        return getString(R.string.pref_renderthemepath, "");
    }

    public static String getCustomRenderThemeFilePath() {
        return getString(R.string.pref_renderthemefile, "");
    }

    public static void setCustomRenderThemeFile(final String customRenderThemeFile) {
        putString(R.string.pref_renderthemefile, customRenderThemeFile);
    }

    public static File[] getMapThemeFiles() {
        final File directory = new File(Settings.getCustomRenderThemeBaseFolder());
        final List<File> result = new ArrayList<>();
        FileUtils.listDir(result, directory, new ExtensionsBasedFileSelector(new String[] { "xml" }), null);

        return result.toArray(new File[result.size()]);
    }

    private static class ExtensionsBasedFileSelector implements FileSelector {
        private final String[] extensions;
        public ExtensionsBasedFileSelector(final String[] extensions) {
            this.extensions = extensions;
        }
        @Override
        public boolean isSelected(final File file) {
            final String filename = file.getName();
            for (final String ext : extensions) {
                if (StringUtils.endsWithIgnoreCase(filename, ext)) {
                    return true;
                }
            }
            return false;
        }
        @Override
        public boolean shouldEnd() {
            return false;
        }
    }

    public static boolean getPlainLogs() {
        return getBoolean(R.string.pref_plainLogs, false);
    }

    public static boolean getUseNativeUa() {
        return getBoolean(R.string.pref_nativeUa, false);
    }

    public static String getCacheTwitterMessage() {
        return getString(R.string.pref_twitter_cache_message, "I found [NAME] ([URL]).");
    }

    public static String getTrackableTwitterMessage() {
        return getString(R.string.pref_twitter_trackable_message, "I touched [NAME] ([URL]).");
    }

    public static int getLogImageScale() {
        return getInt(R.string.pref_logImageScale, -1);
    }

    public static void setLogImageScale(final int scale) {
        putInt(R.string.pref_logImageScale, scale);
    }

    public static void setExcludeMine(final boolean exclude) {
        putBoolean(R.string.pref_excludemine, exclude);
    }

    static void setLogin(final String username, final String password) {
        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            // erase username and password
            remove(R.string.pref_username);
            remove(R.string.pref_password);
            return;
        }
        // save username and password
        putString(R.string.pref_username, username);
        putString(R.string.pref_password, password);
    }

    public static long getFieldnoteExportDate() {
        return getLong(R.string.pref_fieldNoteExportDate, 0);
    }

    /**
     * Remember date of last field note export.
     */
    public static void setFieldnoteExportDate(final long date) {
        putLong(R.string.pref_fieldNoteExportDate, date);
    }

    public static boolean isUseNavigationApp(final NavigationAppsEnum navApp) {
        return getBoolean(navApp.preferenceKey, true);
    }

    /**
     * Remember the state of the "Upload" checkbox in the field notes export dialog.
     */
    public static void setFieldNoteExportUpload(final boolean upload) {
        putBoolean(R.string.pref_fieldNoteExportUpload, upload);
    }

    public static boolean getFieldNoteExportUpload() {
        return getBoolean(R.string.pref_fieldNoteExportUpload, true);
    }

    /**
     * Remember the state of the "Only new" checkbox in the field notes export dialog.
     */
    public static void setFieldNoteExportOnlyNew(final boolean onlyNew) {
        putBoolean(R.string.pref_fieldNoteExportOnlyNew, onlyNew);
    }

    public static boolean getFieldNoteExportOnlyNew() {
        return getBoolean(R.string.pref_fieldNoteExportOnlyNew, false);
    }

    public static String getECIconSet() {
        return getString(R.string.pref_ec_icons, "1");
    }

    /* Store last checksum of changelog for changelog display */
    public static long getLastChangelogChecksum() {
        return getLong(R.string.pref_changelog_last_checksum, 0);
    }

    public static void setLastChangelogChecksum(final long checksum) {
        putLong(R.string.pref_changelog_last_checksum, checksum);
    }

    public static List<String> getLastOpenedCaches() {
        final List<String> history = Arrays.asList(StringUtils.split(getString(R.string.pref_caches_history, StringUtils.EMPTY), HISTORY_SEPARATOR));
        return history.subList(0, Math.min(HISTORY_SIZE, history.size()));
    }

    public static void addCacheToHistory(@NonNull final String geocode) {
        final ArrayList<String> history = new ArrayList<>(getLastOpenedCaches());
        // bring entry to front, if it already existed
        history.remove(geocode);
        history.add(0, geocode);
        putString(R.string.pref_caches_history, StringUtils.join(history, HISTORY_SEPARATOR));
    }

    public static boolean useHardwareAcceleration() {
        return getBoolean(R.string.pref_hardware_acceleration, !HW_ACCEL_DISABLED_BY_DEFAULT);
    }

    public static void setUseHardwareAcceleration(final boolean useHardwareAcceleration) {
        putBoolean(R.string.pref_hardware_acceleration, useHardwareAcceleration);
    }

    public static String getLastCacheLog() {
        return getString(R.string.pref_last_cache_log, StringUtils.EMPTY);
    }

    public static void setLastCacheLog(final String log) {
        putString(R.string.pref_last_cache_log, log);
    }

    public static String getLastTrackableLog() {
        return getString(R.string.pref_last_trackable_log, StringUtils.EMPTY);
    }

    public static void setLastTrackableLog(final String log) {
        putString(R.string.pref_last_trackable_log, log);
    }

    @Nullable
    public static String getHomeLocation() {
        return getString(R.string.pref_home_location, null);
    }

    public static void setHomeLocation(@NonNull final String homeLocation) {
        putString(R.string.pref_home_location, homeLocation);
    }
}
!@#$%
20190527_010215,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_a08976
package cgeo.geocaching.settings;

import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.R;
import cgeo.geocaching.apps.cache.navi.NavigationAppFactory.NavigationAppsEnum;
import cgeo.geocaching.connector.capability.ICredentials;
import cgeo.geocaching.connector.gc.GCConnector;
import cgeo.geocaching.connector.gc.GCConstants;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.LogTypeTrackable;
import cgeo.geocaching.list.StoredList;
import cgeo.geocaching.location.Geopoint;
import cgeo.geocaching.maps.CGeoMap.MapMode;
import cgeo.geocaching.maps.MapProviderFactory;
import cgeo.geocaching.maps.LivemapStrategy;
import cgeo.geocaching.maps.google.v1.GoogleMapProvider;
import cgeo.geocaching.maps.interfaces.GeoPointImpl;
import cgeo.geocaching.maps.interfaces.MapProvider;
import cgeo.geocaching.maps.interfaces.MapSource;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider.OfflineMapSource;
import cgeo.geocaching.utils.CryptUtils;
import cgeo.geocaching.utils.FileUtils;
import cgeo.geocaching.utils.FileUtils.FileSelector;
import cgeo.geocaching.utils.Log;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.os.Build;
import android.os.Build.VERSION;
import android.os.Build.VERSION_CODES;
import android.os.Environment;
import android.preference.PreferenceManager;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;

/**
 * General c:geo preferences/settings set by the user
 */
public class Settings {

    /**
     * On opening a map, we limit the _initial_ zoom. The user can still zoom out afterwards.
     */
    private static final int INITIAL_MAP_ZOOM_LIMIT = 16;
    private static final char HISTORY_SEPARATOR = ',';
    public static final int SHOW_WP_THRESHOLD_DEFAULT = 10;
    public static final int SHOW_WP_THRESHOLD_MAX = 50;
    private static final int MAP_SOURCE_DEFAULT = GoogleMapProvider.GOOGLE_MAP_ID.hashCode();

    public static final boolean HW_ACCEL_DISABLED_BY_DEFAULT =
            Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1 ||
            StringUtils.equals(Build.MODEL, "HTC One X") ||    // HTC One X
            StringUtils.equals(Build.MODEL, "HTC One S") ||    // HTC One S
            StringUtils.equals(Build.MODEL, "GT-I8190")  ||    // Samsung S3 mini
            StringUtils.equals(Build.MODEL, "GT-S6310L") ||    // Samsung Galaxy Young
            StringUtils.equals(Build.MODEL, "GT-P5210")  ||    // Samsung Galaxy Tab 3
            StringUtils.equals(Build.MODEL, "GT-S7580")  ||    // Samsung Galaxy Trend Plus
            StringUtils.equals(Build.MODEL, "GT-I9105P") ||    // Samsung Galaxy SII Plus
            StringUtils.equals(Build.MODEL, "ST25i")     ||    // Sony Xperia U
            StringUtils.equals(Build.MODEL, "bq Aquaris 5");   // bq Aquaris 5

    // twitter api keys
    private final static @NonNull String TWITTER_KEY_CONSUMER_PUBLIC = CryptUtils.rot13("ESnsCvAv3kEupF1GCR3jGj");
    private final static @NonNull String TWITTER_KEY_CONSUMER_SECRET = CryptUtils.rot13("7vQWceACV9umEjJucmlpFe9FCMZSeqIqfkQ2BnhV9x");

    private static boolean useCompass = true;

    public enum CoordInputFormatEnum {
        Plain,
        Deg,
        Min,
        Sec;

        static final int DEFAULT_INT_VALUE = Min.ordinal();

        public static CoordInputFormatEnum fromInt(final int id) {
            final CoordInputFormatEnum[] values = CoordInputFormatEnum.values();
            if (id < 0 || id >= values.length) {
                return Min;
            }
            return values[id];
        }
    }

    private static final SharedPreferences sharedPrefs = PreferenceManager
            .getDefaultSharedPreferences(CgeoApplication.getInstance().getBaseContext());
    static {
        migrateSettings();
        final boolean isDebug = sharedPrefs.getBoolean(getKey(R.string.pref_debug), false);
        Log.setDebug(isDebug);
        CgeoApplication.dumpOnOutOfMemory(isDebug);
    }

    /**
     * Cache the mapsource locally. If that is an offline map source, each request would potentially access the
     * underlying map file, leading to delays.
     */
    private static MapSource mapSource;

    protected Settings() {
        throw new InstantiationError();
    }

    private static void migrateSettings() {
        final int LATEST_PREFERENCES_VERSION = 2;
        final int currentVersion = getInt(R.string.pref_settingsversion, 0);

        // No need to migrate if we are up to date.
        if (currentVersion == LATEST_PREFERENCES_VERSION) {
            return;
        }

        // No need to migrate if we don't have older settings, defaults will be used instead.
        final String preferencesNameV0 = "cgeo.pref";
        final SharedPreferences prefsV0 = CgeoApplication.getInstance().getSharedPreferences(preferencesNameV0, Context.MODE_PRIVATE);
        if (currentVersion == 0 && prefsV0.getAll().isEmpty()) {
            final Editor e = sharedPrefs.edit();
            e.putInt(getKey(R.string.pref_settingsversion), LATEST_PREFERENCES_VERSION);
            e.apply();
            return;
        }

        if (currentVersion < 1) {
            // migrate from non standard file location and integer based boolean types
            final Editor e = sharedPrefs.edit();

            e.putString(getKey(R.string.pref_temp_twitter_token_secret), prefsV0.getString(getKey(R.string.pref_temp_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_temp_twitter_token_public), prefsV0.getString(getKey(R.string.pref_temp_twitter_token_public), null));
            e.putBoolean(getKey(R.string.pref_help_shown), prefsV0.getInt(getKey(R.string.pref_help_shown), 0) != 0);
            e.putFloat(getKey(R.string.pref_anylongitude), prefsV0.getFloat(getKey(R.string.pref_anylongitude), 0));
            e.putFloat(getKey(R.string.pref_anylatitude), prefsV0.getFloat(getKey(R.string.pref_anylatitude), 0));
            e.putBoolean(getKey(R.string.pref_offlinemaps), 0 != prefsV0.getInt(getKey(R.string.pref_offlinemaps), 1));
            e.putBoolean(getKey(R.string.pref_offlinewpmaps), 0 != prefsV0.getInt(getKey(R.string.pref_offlinewpmaps), 0));
            e.putString(getKey(R.string.pref_webDeviceCode), prefsV0.getString(getKey(R.string.pref_webDeviceCode), null));
            e.putString(getKey(R.string.pref_webDeviceName), prefsV0.getString(getKey(R.string.pref_webDeviceName), null));
            e.putBoolean(getKey(R.string.pref_maplive), prefsV0.getInt(getKey(R.string.pref_maplive), 1) != 0);
            e.putInt(getKey(R.string.pref_mapsource), prefsV0.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT));
            e.putBoolean(getKey(R.string.pref_twitter), 0 != prefsV0.getInt(getKey(R.string.pref_twitter), 0));
            e.putBoolean(getKey(R.string.pref_showaddress), 0 != prefsV0.getInt(getKey(R.string.pref_showaddress), 1));
            e.putBoolean(getKey(R.string.pref_showcaptcha), prefsV0.getBoolean(getKey(R.string.pref_showcaptcha), false));
            e.putBoolean(getKey(R.string.pref_maptrail), prefsV0.getInt(getKey(R.string.pref_maptrail), 1) != 0);
            e.putInt(getKey(R.string.pref_lastmapzoom), prefsV0.getInt(getKey(R.string.pref_lastmapzoom), 14));
            e.putBoolean(getKey(R.string.pref_livelist), 0 != prefsV0.getInt(getKey(R.string.pref_livelist), 1));
            e.putBoolean(getKey(R.string.pref_units_imperial), prefsV0.getInt(getKey(R.string.pref_units_imperial), 1) != 1);
            e.putBoolean(getKey(R.string.pref_skin), prefsV0.getInt(getKey(R.string.pref_skin), 0) != 0);
            e.putInt(getKey(R.string.pref_lastusedlist), prefsV0.getInt(getKey(R.string.pref_lastusedlist), StoredList.STANDARD_LIST_ID));
            e.putString(getKey(R.string.pref_cachetype), prefsV0.getString(getKey(R.string.pref_cachetype), CacheType.ALL.id));
            e.putString(getKey(R.string.pref_twitter_token_secret), prefsV0.getString(getKey(R.string.pref_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_twitter_token_public), prefsV0.getString(getKey(R.string.pref_twitter_token_public), null));
            e.putInt(getKey(R.string.pref_version), prefsV0.getInt(getKey(R.string.pref_version), 0));
            e.putBoolean(getKey(R.string.pref_autoloaddesc), 0 != prefsV0.getInt(getKey(R.string.pref_autoloaddesc), 1));
            e.putBoolean(getKey(R.string.pref_ratingwanted), prefsV0.getBoolean(getKey(R.string.pref_ratingwanted), true));
            e.putBoolean(getKey(R.string.pref_friendlogswanted), prefsV0.getBoolean(getKey(R.string.pref_friendlogswanted), true));
            e.putBoolean(getKey(R.string.pref_useenglish), prefsV0.getBoolean(getKey(R.string.pref_useenglish), false));
            e.putBoolean(getKey(R.string.pref_usecompass), 0 != prefsV0.getInt(getKey(R.string.pref_usecompass), 1));
            e.putBoolean(getKey(R.string.pref_trackautovisit), prefsV0.getBoolean(getKey(R.string.pref_trackautovisit), false));
            e.putBoolean(getKey(R.string.pref_sigautoinsert), prefsV0.getBoolean(getKey(R.string.pref_sigautoinsert), false));
            e.putBoolean(getKey(R.string.pref_logimages), prefsV0.getBoolean(getKey(R.string.pref_logimages), false));
            e.putBoolean(getKey(R.string.pref_excludedisabled), 0 != prefsV0.getInt(getKey(R.string.pref_excludedisabled), 0));
            e.putBoolean(getKey(R.string.pref_excludemine), 0 != prefsV0.getInt(getKey(R.string.pref_excludemine), 0));
            e.putString(getKey(R.string.pref_mapfile), prefsV0.getString(getKey(R.string.pref_mapfile), null));
            e.putString(getKey(R.string.pref_signature), prefsV0.getString(getKey(R.string.pref_signature), null));
            e.putString(getKey(R.string.pref_pass_vote), prefsV0.getString(getKey(R.string.pref_pass_vote), null));
            e.putString(getKey(R.string.pref_password), prefsV0.getString(getKey(R.string.pref_password), null));
            e.putString(getKey(R.string.pref_username), prefsV0.getString(getKey(R.string.pref_username), null));
            e.putString(getKey(R.string.pref_memberstatus), prefsV0.getString(getKey(R.string.pref_memberstatus), ""));
            e.putInt(getKey(R.string.pref_coordinputformat), prefsV0.getInt(getKey(R.string.pref_coordinputformat), CoordInputFormatEnum.DEFAULT_INT_VALUE));
            e.putBoolean(getKey(R.string.pref_log_offline), prefsV0.getBoolean(getKey(R.string.pref_log_offline), false));
            e.putBoolean(getKey(R.string.pref_choose_list), prefsV0.getBoolean(getKey(R.string.pref_choose_list), true));
            e.putBoolean(getKey(R.string.pref_loaddirectionimg), prefsV0.getBoolean(getKey(R.string.pref_loaddirectionimg), true));
            e.putString(getKey(R.string.pref_gccustomdate), prefsV0.getString(getKey(R.string.pref_gccustomdate), GCConstants.DEFAULT_GC_DATE));
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), prefsV0.getInt(getKey(R.string.pref_showwaypointsthreshold), SHOW_WP_THRESHOLD_DEFAULT));
            e.putString(getKey(R.string.pref_cookiestore), prefsV0.getString(getKey(R.string.pref_cookiestore), null));
            e.putBoolean(getKey(R.string.pref_opendetailslastpage), prefsV0.getBoolean(getKey(R.string.pref_opendetailslastpage), false));
            e.putInt(getKey(R.string.pref_lastdetailspage), prefsV0.getInt(getKey(R.string.pref_lastdetailspage), 1));
            e.putInt(getKey(R.string.pref_defaultNavigationTool), prefsV0.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id));
            e.putInt(getKey(R.string.pref_defaultNavigationTool2), prefsV0.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id));
            e.putInt(getKey(R.string.pref_livemapstrategy), prefsV0.getInt(getKey(R.string.pref_livemapstrategy), LivemapStrategy.AUTO.id));
            e.putBoolean(getKey(R.string.pref_debug), prefsV0.getBoolean(getKey(R.string.pref_debug), false));
            e.putInt(getKey(R.string.pref_livemaphintshowcount), prefsV0.getInt(getKey(R.string.pref_livemaphintshowcount), 0));

            e.putInt(getKey(R.string.pref_settingsversion), 1); // mark migrated
            e.apply();
        }

        // changes for new settings dialog
        if (currentVersion < 2) {
            final Editor e = sharedPrefs.edit();

            e.putBoolean(getKey(R.string.pref_units_imperial), useImperialUnits());

            // show waypoints threshold now as a slider
            int wpThreshold = getWayPointsThreshold();
            if (wpThreshold < 0) {
                wpThreshold = 0;
            } else if (wpThreshold > SHOW_WP_THRESHOLD_MAX) {
                wpThreshold = SHOW_WP_THRESHOLD_MAX;
            }
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), wpThreshold);

            // KEY_MAP_SOURCE must be string, because it is the key for a ListPreference now
            final int ms = sharedPrefs.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT);
            e.remove(getKey(R.string.pref_mapsource));
            e.putString(getKey(R.string.pref_mapsource), String.valueOf(ms));

            // navigation tool ids must be string, because ListPreference uses strings as keys
            final int dnt1 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id);
            final int dnt2 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id);
            e.remove(getKey(R.string.pref_defaultNavigationTool));
            e.remove(getKey(R.string.pref_defaultNavigationTool2));
            e.putString(getKey(R.string.pref_defaultNavigationTool), String.valueOf(dnt1));
            e.putString(getKey(R.string.pref_defaultNavigationTool2), String.valueOf(dnt2));

            // defaults for gpx directories
            e.putString(getKey(R.string.pref_gpxImportDir), getGpxImportDir());
            e.putString(getKey(R.string.pref_gpxExportDir), getGpxExportDir());

            e.putInt(getKey(R.string.pref_settingsversion), 2); // mark migrated
            e.apply();
        }
    }

    private static String getKey(final int prefKeyId) {
        return CgeoApplication.getInstance().getString(prefKeyId);
    }

    static String getString(final int prefKeyId, final String defaultValue) {
        return sharedPrefs.getString(getKey(prefKeyId), defaultValue);
    }

    private static int getInt(final int prefKeyId, final int defaultValue) {
        return sharedPrefs.getInt(getKey(prefKeyId), defaultValue);
    }

    private static long getLong(final int prefKeyId, final long defaultValue) {
        return sharedPrefs.getLong(getKey(prefKeyId), defaultValue);
    }

    private static boolean getBoolean(final int prefKeyId, final boolean defaultValue) {
        return sharedPrefs.getBoolean(getKey(prefKeyId), defaultValue);
    }

    private static float getFloat(final int prefKeyId, final float defaultValue) {
        return sharedPrefs.getFloat(getKey(prefKeyId), defaultValue);
    }

    protected static void putString(final int prefKeyId, final String value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putString(getKey(prefKeyId), value);
        edit.apply();
    }

    protected static void putBoolean(final int prefKeyId, final boolean value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putBoolean(getKey(prefKeyId), value);
        edit.apply();
    }

    private static void putInt(final int prefKeyId, final int value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putInt(getKey(prefKeyId), value);
        edit.apply();
    }

    private static void putLong(final int prefKeyId, final long value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putLong(getKey(prefKeyId), value);
        edit.apply();
    }

    private static void putFloat(final int prefKeyId, final float value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putFloat(getKey(prefKeyId), value);
        edit.apply();
    }

    private static void remove(final int prefKeyId) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.remove(getKey(prefKeyId));
        edit.apply();
    }

    private static boolean contains(final int prefKeyId) {
        return sharedPrefs.contains(getKey(prefKeyId));
    }

    public static void setLanguage(final boolean useEnglish) {
        final Configuration config = new Configuration();
        config.locale = useEnglish ? Locale.ENGLISH : Locale.getDefault();
        final Resources resources = CgeoApplication.getInstance().getResources();
        resources.updateConfiguration(config, resources.getDisplayMetrics());
    }

    public static boolean hasGCCredentials() {
        final String preUsername = getString(R.string.pref_username, null);
        final String prePassword = getString(R.string.pref_password, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    /**
     * Get login and password information of Geocaching.com.
     *
     * @return a pair either with (login, password) or (empty, empty) if no valid information is stored
     */
    public static ImmutablePair<String, String> getGcCredentials() {
        return getCredentials(GCConnector.getInstance());
    }

    /**
     * Get login and password information.
     *
     * @return a pair either with (login, password) or (empty, empty) if no valid information is stored
     */
    public static ImmutablePair<String, String> getCredentials(final @NonNull ICredentials connector) {
        final String username = getString(connector.getUsernamePreferenceKey(), null);
        final String password = getString(connector.getPasswordPreferenceKey(), null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return new ImmutablePair<>(StringUtils.EMPTY, StringUtils.EMPTY);
        }

        return new ImmutablePair<>(username, password);
    }

    public static String getUsername() {
        return getString(R.string.pref_username, StringUtils.EMPTY);
    }

    public static boolean isGCConnectorActive() {
        return getBoolean(R.string.pref_connectorGCActive, true);
    }

    public static boolean isECConnectorActive() {
        return getBoolean(R.string.pref_connectorECActive, false);
    }

    public static boolean isOXConnectorActive() {
        return getBoolean(R.string.pref_connectorOXActive, false);
    }

    public static boolean isGCPremiumMember() {
        final String memberStatus = Settings.getGCMemberStatus();
        return StringUtils.equalsIgnoreCase(memberStatus, GCConstants.MEMBER_STATUS_PREMIUM) ||
                StringUtils.equalsIgnoreCase(memberStatus, GCConstants.MEMBER_STATUS_CHARTER);
    }

    public static String getGCMemberStatus() {
        return getString(R.string.pref_memberstatus, "");
    }

    public static void setGCMemberStatus(final String memberStatus) {
        if (StringUtils.isBlank(memberStatus)) {
            remove(R.string.pref_memberstatus);
        }
        putString(R.string.pref_memberstatus, memberStatus);
    }

    public static ImmutablePair<String, String> getTokenPair(final int tokenPublicPrefKey, final int tokenSecretPrefKey) {
        return new ImmutablePair<>(getString(tokenPublicPrefKey, null), getString(tokenSecretPrefKey, null));
    }

    public static void setTokens(final int tokenPublicPrefKey, @Nullable final String tokenPublic, final int tokenSecretPrefKey, @Nullable final String tokenSecret) {
        if (tokenPublic == null) {
            remove(tokenPublicPrefKey);
        } else {
            putString(tokenPublicPrefKey, tokenPublic);
        }
        if (tokenSecret == null) {
            remove(tokenSecretPrefKey);
        } else {
            putString(tokenSecretPrefKey, tokenSecret);
        }
    }

    public static boolean isOCConnectorActive(final int isActivePrefKeyId) {
        return getBoolean(isActivePrefKeyId, false);
    }

    public static boolean hasOCAuthorization(final int tokenPublicPrefKeyId, final int tokenSecretPrefKeyId) {
        return StringUtils.isNotBlank(getString(tokenPublicPrefKeyId, ""))
                && StringUtils.isNotBlank(getString(tokenSecretPrefKeyId, ""));
    }

    public static boolean isGCvoteLogin() {
        return getGCvoteLogin() != null;
    }

    public static ImmutablePair<String, String> getGCvoteLogin() {
        final String username = getString(R.string.pref_username, null);
        final String password = getString(R.string.pref_pass_vote, null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return null;
        }

        return new ImmutablePair<>(username, password);
    }

    public static String getSignature() {
        return getString(R.string.pref_signature, StringUtils.EMPTY);
    }

    public static void setCookieStore(final String cookies) {
        if (StringUtils.isBlank(cookies)) {
            // erase cookies
            remove(R.string.pref_cookiestore);
        }
        // save cookies
        putString(R.string.pref_cookiestore, cookies);
    }

    public static String getCookieStore() {
        return getString(R.string.pref_cookiestore, null);
    }

    public static void setUseGooglePlayServices(final boolean value) {
        putBoolean(R.string.pref_googleplayservices, value);
    }

    public static boolean useGooglePlayServices() {
        // By defaut, enable play services starting from ICS.
        return CgeoApplication.getInstance().isGooglePlayServicesAvailable() &&
                getBoolean(R.string.pref_googleplayservices, VERSION.SDK_INT >= VERSION_CODES.ICE_CREAM_SANDWICH);
    }

    public static boolean useLowPowerMode() {
        return getBoolean(R.string.pref_lowpowermode, false);
    }

    /**
     * @param cacheType
     *            The cache type used for future filtering
     */
    public static void setCacheType(final CacheType cacheType) {
        if (cacheType == null) {
            remove(R.string.pref_cachetype);
        } else {
            putString(R.string.pref_cachetype, cacheType.id);
        }
    }

    public static int getLastList() {
        return getInt(R.string.pref_lastusedlist, StoredList.STANDARD_LIST_ID);
    }

    public static void saveLastList(final int listId) {
        putInt(R.string.pref_lastusedlist, listId);
    }

    public static void setWebNameCode(final String name, final String code) {
        putString(R.string.pref_webDeviceName, name);
        putString(R.string.pref_webDeviceCode, code);
    }

    public static MapProvider getMapProvider() {
        return getMapSource().getMapProvider();
    }

    public static String getMapFile() {
        return getString(R.string.pref_mapfile, null);
    }

    public static void setMapFile(final String mapFile) {
        putString(R.string.pref_mapfile, mapFile);
        if (mapFile != null) {
            setMapFileDirectory(new File(mapFile).getParent());
        }
    }

    public static String getMapFileDirectory() {
        final String mapDir = getString(R.string.pref_mapDirectory, null);
        if (mapDir != null) {
            return mapDir;
        }
        final String mapFile = getMapFile();
        if (mapFile != null) {
            return new File(mapFile).getParent();
        }
        return null;
    }

    public static void setMapFileDirectory(final String mapFileDirectory) {
        putString(R.string.pref_mapDirectory, mapFileDirectory);
        MapsforgeMapProvider.getInstance().updateOfflineMaps();
    }

    public static boolean isValidMapFile() {
        return isValidMapFile(getMapFile());
    }

    public static boolean isValidMapFile(final String mapFileIn) {
        return MapsforgeMapProvider.isValidMapFile(mapFileIn);
    }

    public static boolean isScaleMapsforgeText() {
        return getBoolean(R.string.pref_mapsforge_scale_text, true);
    }

    public static CoordInputFormatEnum getCoordInputFormat() {
        return CoordInputFormatEnum.fromInt(getInt(R.string.pref_coordinputformat, CoordInputFormatEnum.DEFAULT_INT_VALUE));
    }

    public static void setCoordInputFormat(final CoordInputFormatEnum format) {
        putInt(R.string.pref_coordinputformat, format.ordinal());
    }

    public static boolean getLogOffline() {
        return getBoolean(R.string.pref_log_offline, false);
    }

    public static boolean getChooseList() {
        return getBoolean(R.string.pref_choose_list, false);
    }

    public static boolean getLoadDirImg() {
        return !isGCPremiumMember() && getBoolean(R.string.pref_loaddirectionimg, true);
    }

    public static void setGcCustomDate(final String format) {
        putString(R.string.pref_gccustomdate, format);
    }

    /**
     * @return User selected date format on GC.com
     */
    public static String getGcCustomDate() {
        // We might have some users whose stored value is null, which is invalid. In this case, we use the default.
        return StringUtils.defaultString(getString(R.string.pref_gccustomdate, GCConstants.DEFAULT_GC_DATE),
                GCConstants.DEFAULT_GC_DATE);
    }

    public static boolean isExcludeMyCaches() {
        return getBoolean(R.string.pref_excludemine, false);
    }

    public static boolean isUseEnglish() {
        return getBoolean(R.string.pref_useenglish, false);
    }

    public static boolean isShowAddress() {
        return getBoolean(R.string.pref_showaddress, true);
    }

    public static boolean isShowCaptcha() {
        return !isGCPremiumMember() && getBoolean(R.string.pref_showcaptcha, false);
    }

    public static boolean isExcludeDisabledCaches() {
        return getBoolean(R.string.pref_excludedisabled, false);
    }

    public static boolean isStoreOfflineMaps() {
        return getBoolean(R.string.pref_offlinemaps, true);
    }

    public static boolean isStoreOfflineWpMaps() {
        return getBoolean(R.string.pref_offlinewpmaps, false);
    }

    public static boolean isStoreLogImages() {
        return getBoolean(R.string.pref_logimages, false);
    }

    public static boolean isAutoLoadDescription() {
        return getBoolean(R.string.pref_autoloaddesc, true);
    }

    public static boolean isRatingWanted() {
        return getBoolean(R.string.pref_ratingwanted, true);
    }

    public static boolean isGeokretyConnectorActive() {
        return getBoolean(R.string.pref_connectorGeokretyActive, true);
    }

    public static boolean isGeokretyCacheActive() {
        return getBoolean(R.string.pref_geokrety_cache, true);
    }

    public static String getGeokretyUsername() {
        return getString(R.string.pref_geokrety_username, null);
    }

    public static String getGeokretyPassword() {
        return getString(R.string.pref_geokrety_password, null);
    }

    public static String getGeokretySecId() {
        return getString(R.string.pref_geokrety_secid, null);
    }

    public static void setGeokretySecId(final String secid) {
        putString(R.string.pref_geokrety_secid, secid);
    }

    public static boolean isRegisteredForGeokrety() {
        return getGeokretySecId() != null;
    }

    public static boolean isFriendLogsWanted() {
        if (!hasGCCredentials()) {
            // don't show a friends log if the user is anonymous
            return false;
        }
        return getBoolean(R.string.pref_friendlogswanted, true);
    }

    public static boolean isLiveList() {
        return getBoolean(R.string.pref_livelist, true);
    }

    public static boolean isTrackableAutoVisit() {
        return getBoolean(R.string.pref_trackautovisit, false);
    }

    public static boolean isAutoInsertSignature() {
        return getBoolean(R.string.pref_sigautoinsert, false);
    }

    public static void setUseImperialUnits(final boolean useImperialUnits) {
        putBoolean(R.string.pref_units_imperial, useImperialUnits);
    }

    public static boolean useImperialUnits() {
        return getBoolean(R.string.pref_units_imperial, useImperialUnitsByDefault());
    }

    static boolean useImperialUnitsByDefault() {
        final String countryCode = Locale.getDefault().getCountry();
        return "US".equals(countryCode)  // USA
            || "LR".equals(countryCode)  // Liberia
            || "MM".equals(countryCode); // Burma
    }

    public static boolean isLiveMap() {
        return getBoolean(R.string.pref_maplive, true);
    }

    public static void setLiveMap(final boolean live) {
        putBoolean(R.string.pref_maplive, live);
    }

    public static boolean isMapTrail() {
        return getBoolean(R.string.pref_maptrail, false);
    }

    public static void setMapTrail(final boolean showTrail) {
        putBoolean(R.string.pref_maptrail, showTrail);
    }

    /**
     * Get last used zoom of the internal map. Differentiate between two use cases for a map of multiple caches (e.g.
     * live map) and the map of a single cache (which is often zoomed in more deep).
     */
    public static int getMapZoom(final MapMode mapMode) {
        if (mapMode == MapMode.SINGLE || mapMode == MapMode.COORDS) {
            return getCacheZoom();
        }
        return getMapZoom();
    }

    public static void setMapZoom(final MapMode mapMode, final int zoomLevel) {
        if (mapMode == MapMode.SINGLE || mapMode == MapMode.COORDS) {
            setCacheZoom(zoomLevel);
        }
        else {
            setMapZoom(zoomLevel);
        }
    }

    /**
     * @return zoom used for the (live) map
     */
    private static int getMapZoom() {
        return Math.max(getInt(R.string.pref_lastmapzoom, 14), INITIAL_MAP_ZOOM_LIMIT);
    }

    private static void setMapZoom(final int mapZoomLevel) {
        putInt(R.string.pref_lastmapzoom, mapZoomLevel);
    }

    /**
     * @return zoom used for the map of a single cache
     */
    private static int getCacheZoom() {
        return Math.max(getInt(R.string.pref_cache_zoom, 14), INITIAL_MAP_ZOOM_LIMIT);
    }

    private static void setCacheZoom(final int zoomLevel) {
        putInt(R.string.pref_cache_zoom, zoomLevel);
    }

    public static GeoPointImpl getMapCenter() {
        return getMapProvider().getMapItemFactory()
                .getGeoPointBase(new Geopoint(getInt(R.string.pref_lastmaplat, 0) / 1e6,
                        getInt(R.string.pref_lastmaplon, 0) / 1e6));
    }

    public static void setMapCenter(final GeoPointImpl mapViewCenter) {
        putInt(R.string.pref_lastmaplat, mapViewCenter.getLatitudeE6());
        putInt(R.string.pref_lastmaplon, mapViewCenter.getLongitudeE6());
    }

    @NonNull
    public static synchronized MapSource getMapSource() {
        if (mapSource != null) {
            return mapSource;
        }
        final int id = getConvertedMapId();
        mapSource = MapProviderFactory.getMapSource(id);
        if (mapSource != null) {
            // don't use offline maps if the map file is not valid
            if (!(mapSource instanceof OfflineMapSource) || isValidMapFile()) {
                return mapSource;
            }
        }
        // fallback to first available map
        return MapProviderFactory.getDefaultSource();
    }

    private final static int GOOGLEMAP_BASEID = 30;
    private final static int MAP = 1;
    private final static int SATELLITE = 2;

    private final static int MFMAP_BASEID = 40;
    private final static int MAPNIK = 1;
    private final static int CYCLEMAP = 3;
    private final static int OFFLINE = 4;
    private static final int HISTORY_SIZE = 10;

    /**
     * Convert old preference ids for maps (based on constant values) into new hash based ids.
     */
    private static int getConvertedMapId() {
        final int id = Integer.parseInt(getString(R.string.pref_mapsource,
                String.valueOf(MAP_SOURCE_DEFAULT)));
        switch (id) {
            case GOOGLEMAP_BASEID + MAP:
                return GoogleMapProvider.GOOGLE_MAP_ID.hashCode();
            case GOOGLEMAP_BASEID + SATELLITE:
                return GoogleMapProvider.GOOGLE_SATELLITE_ID.hashCode();
            case MFMAP_BASEID + MAPNIK:
                return MapsforgeMapProvider.MAPSFORGE_MAPNIK_ID.hashCode();
            case MFMAP_BASEID + CYCLEMAP:
                return MapsforgeMapProvider.MAPSFORGE_CYCLEMAP_ID.hashCode();
            case MFMAP_BASEID + OFFLINE: {
                final String mapFile = Settings.getMapFile();
                if (StringUtils.isNotEmpty(mapFile)) {
                    return mapFile.hashCode();
                }
                break;
            }
            default:
                break;
        }
        return id;
    }

    public static synchronized void setMapSource(final MapSource newMapSource) {
        putString(R.string.pref_mapsource, String.valueOf(newMapSource.getNumericalId()));
        if (newMapSource instanceof OfflineMapSource) {
            setMapFile(((OfflineMapSource) newMapSource).getFileName());
        }
        // cache the value
        mapSource = newMapSource;
    }

    public static void setAnyCoordinates(final Geopoint coords) {
        if (null != coords) {
            putFloat(R.string.pref_anylatitude, (float) coords.getLatitude());
            putFloat(R.string.pref_anylongitude, (float) coords.getLongitude());
        } else {
            remove(R.string.pref_anylatitude);
            remove(R.string.pref_anylongitude);
        }
    }

    public static Geopoint getAnyCoordinates() {
        if (contains(R.string.pref_anylatitude) && contains(R.string.pref_anylongitude)) {
            final float lat = getFloat(R.string.pref_anylatitude, 0);
            final float lon = getFloat(R.string.pref_anylongitude, 0);
            return new Geopoint(lat, lon);
        }
        return null;
    }

    public static boolean isUseCompass() {
        return useCompass;
    }

    public static void setUseCompass(final boolean value) {
        useCompass = value;
    }

    public static boolean isLightSkin() {
        return getBoolean(R.string.pref_skin, false);
    }

    @NonNull
    public static String getTwitterKeyConsumerPublic() {
        return TWITTER_KEY_CONSUMER_PUBLIC;
    }

    @NonNull
    public static String getTwitterKeyConsumerSecret() {
        return TWITTER_KEY_CONSUMER_SECRET;
    }

    public static String getWebDeviceCode() {
        return getString(R.string.pref_webDeviceCode, null);
    }

    public static boolean isRegisteredForSend2cgeo() {
        return getWebDeviceCode() != null;
    }

    public static String getWebDeviceName() {
        return getString(R.string.pref_webDeviceName, Build.MODEL);
    }

    /**
     * @return The cache type used for filtering or ALL if no filter is active.
     *         Returns never null
     */
    @NonNull
    public static CacheType getCacheType() {
        return CacheType.getById(getString(R.string.pref_cachetype, CacheType.ALL.id));
    }

    /**
     * The Threshold for the showing of child waypoints
     */
    public static int getWayPointsThreshold() {
        return getInt(R.string.pref_showwaypointsthreshold, SHOW_WP_THRESHOLD_DEFAULT);
    }

    public static void setShowWaypointsThreshold(final int threshold) {
        putInt(R.string.pref_showwaypointsthreshold, threshold);
    }

    public static boolean isUseTwitter() {
        return getBoolean(R.string.pref_twitter, false);
    }

    public static void setUseTwitter(final boolean useTwitter) {
        putBoolean(R.string.pref_twitter, useTwitter);
    }

    public static boolean isTwitterLoginValid() {
        return !StringUtils.isBlank(getTokenPublic())
                && !StringUtils.isBlank(getTokenSecret());
    }

    public static String getTokenPublic() {
        return getString(R.string.pref_twitter_token_public, null);
    }

    public static String getTokenSecret() {
        return getString(R.string.pref_twitter_token_secret, null);

    }

    public static boolean hasTwitterAuthorization() {
        return StringUtils.isNotBlank(getTokenPublic())
                && StringUtils.isNotBlank(getTokenSecret());
    }

    public static void setTwitterTokens(@Nullable final String tokenPublic,
            @Nullable final String tokenSecret, final boolean enableTwitter) {
        putString(R.string.pref_twitter_token_public, tokenPublic);
        putString(R.string.pref_twitter_token_secret, tokenSecret);
        if (tokenPublic != null) {
            remove(R.string.pref_temp_twitter_token_public);
            remove(R.string.pref_temp_twitter_token_secret);
        }
        setUseTwitter(enableTwitter);
    }

    public static void setTwitterTempTokens(@Nullable final String tokenPublic,
            @Nullable final String tokenSecret) {
        putString(R.string.pref_temp_twitter_token_public, tokenPublic);
        putString(R.string.pref_temp_twitter_token_secret, tokenSecret);
    }

    public static ImmutablePair<String, String> getTempToken() {
        final String tokenPublic = getString(R.string.pref_temp_twitter_token_public, null);
        final String tokenSecret = getString(R.string.pref_temp_twitter_token_secret, null);
        return new ImmutablePair<>(tokenPublic, tokenSecret);
    }

    public static int getVersion() {
        return getInt(R.string.pref_version, 0);
    }

    public static void setVersion(final int version) {
        putInt(R.string.pref_version, version);
    }

    public static boolean isOpenLastDetailsPage() {
        return getBoolean(R.string.pref_opendetailslastpage, false);
    }

    public static int getLastDetailsPage() {
        return getInt(R.string.pref_lastdetailspage, 1);
    }

    public static void setLastDetailsPage(final int index) {
        putInt(R.string.pref_lastdetailspage, index);
    }

    public static int getDefaultNavigationTool() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool,
                String.valueOf(NavigationAppsEnum.COMPASS.id)));
    }

    public static int getDefaultNavigationTool2() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool2,
                String.valueOf(NavigationAppsEnum.INTERNAL_MAP.id)));
    }

    public static LivemapStrategy getLiveMapStrategy() {
        return LivemapStrategy.getById(getInt(R.string.pref_livemapstrategy, LivemapStrategy.AUTO.id));
    }

    public static void setLiveMapStrategy(final LivemapStrategy strategy) {
        putInt(R.string.pref_livemapstrategy, strategy.id);
    }

    public static boolean isDebug() {
        return Log.isDebug();
    }

    public static int getLiveMapHintShowCount() {
        return getInt(R.string.pref_livemaphintshowcount, 0);
    }

    public static void setLiveMapHintShowCount(final int showCount) {
        putInt(R.string.pref_livemaphintshowcount, showCount);
    }

    public static boolean isDbOnSDCard() {
        return getBoolean(R.string.pref_dbonsdcard, false);
    }

    public static void setDbOnSDCard(final boolean dbOnSDCard) {
        putBoolean(R.string.pref_dbonsdcard, dbOnSDCard);
    }

    public static String getGpxExportDir() {
        return getString(R.string.pref_gpxExportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static String getGpxImportDir() {
        return getString(R.string.pref_gpxImportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static boolean getShareAfterExport() {
        return getBoolean(R.string.pref_shareafterexport, true);
    }

    public static void setShareAfterExport(final boolean shareAfterExport) {
        putBoolean(R.string.pref_shareafterexport, shareAfterExport);
    }

    public static int getTrackableAction() {
        return getInt(R.string.pref_trackableaction, LogTypeTrackable.RETRIEVED_IT.id);
    }

    public static void setTrackableAction(final int trackableAction) {
        putInt(R.string.pref_trackableaction, trackableAction);
    }

    public static String getCustomRenderThemeBaseFolder() {
        return getString(R.string.pref_renderthemepath, "");
    }

    public static String getCustomRenderThemeFilePath() {
        return getString(R.string.pref_renderthemefile, "");
    }

    public static void setCustomRenderThemeFile(final String customRenderThemeFile) {
        putString(R.string.pref_renderthemefile, customRenderThemeFile);
    }

    public static File[] getMapThemeFiles() {
        final File directory = new File(Settings.getCustomRenderThemeBaseFolder());
        final List<File> result = new ArrayList<>();
        FileUtils.listDir(result, directory, new ExtensionsBasedFileSelector(new String[] { "xml" }), null);

        return result.toArray(new File[result.size()]);
    }

    private static class ExtensionsBasedFileSelector extends FileSelector {
        private final String[] extensions;
        public ExtensionsBasedFileSelector(final String[] extensions) {
            this.extensions = extensions;
        }
        @Override
        public boolean isSelected(final File file) {
            final String filename = file.getName();
            for (final String ext : extensions) {
                if (StringUtils.endsWithIgnoreCase(filename, ext)) {
                    return true;
                }
            }
            return false;
        }
        @Override
        public boolean shouldEnd() {
            return false;
        }
    }

    public static boolean getPlainLogs() {
        return getBoolean(R.string.pref_plainLogs, false);
    }

    public static boolean getUseNativeUa() {
        return getBoolean(R.string.pref_nativeUa, false);
    }

    public static String getCacheTwitterMessage() {
        return getString(R.string.pref_twitter_cache_message, "I found [NAME] ([URL]).");
    }

    public static String getTrackableTwitterMessage() {
        return getString(R.string.pref_twitter_trackable_message, "I touched [NAME] ([URL]).");
    }

    public static int getLogImageScale() {
        return getInt(R.string.pref_logImageScale, -1);
    }

    public static void setLogImageScale(final int scale) {
        putInt(R.string.pref_logImageScale, scale);
    }

    public static void setExcludeMine(final boolean exclude) {
        putBoolean(R.string.pref_excludemine, exclude);
    }

    static void setLogin(final String username, final String password) {
        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            // erase username and password
            remove(R.string.pref_username);
            remove(R.string.pref_password);
            return;
        }
        // save username and password
        putString(R.string.pref_username, username);
        putString(R.string.pref_password, password);
    }

    public static long getFieldnoteExportDate() {
        return getLong(R.string.pref_fieldNoteExportDate, 0);
    }

    /**
     * Remember date of last field note export.
     */
    public static void setFieldnoteExportDate(final long date) {
        putLong(R.string.pref_fieldNoteExportDate, date);
    }

    public static boolean isUseNavigationApp(final NavigationAppsEnum navApp) {
        return getBoolean(navApp.preferenceKey, true);
    }

    /**
     * Remember the state of the "Upload" checkbox in the field notes export dialog.
     */
    public static void setFieldNoteExportUpload(final boolean upload) {
        putBoolean(R.string.pref_fieldNoteExportUpload, upload);
    }

    public static boolean getFieldNoteExportUpload() {
        return getBoolean(R.string.pref_fieldNoteExportUpload, true);
    }

    /**
     * Remember the state of the "Only new" checkbox in the field notes export dialog.
     */
    public static void setFieldNoteExportOnlyNew(final boolean onlyNew) {
        putBoolean(R.string.pref_fieldNoteExportOnlyNew, onlyNew);
    }

    public static boolean getFieldNoteExportOnlyNew() {
        return getBoolean(R.string.pref_fieldNoteExportOnlyNew, false);
    }

    public static String getECIconSet() {
        return getString(R.string.pref_ec_icons, "1");
    }

    /* Store last checksum of changelog for changelog display */
    public static long getLastChangelogChecksum() {
        return getLong(R.string.pref_changelog_last_checksum, 0);
    }

    public static void setLastChangelogChecksum(final long checksum) {
        putLong(R.string.pref_changelog_last_checksum, checksum);
    }

    public static List<String> getLastOpenedCaches() {
        final List<String> history = Arrays.asList(StringUtils.split(getString(R.string.pref_caches_history, StringUtils.EMPTY), HISTORY_SEPARATOR));
        return history.subList(0, Math.min(HISTORY_SIZE, history.size()));
    }

    public static void addCacheToHistory(@NonNull final String geocode) {
        final ArrayList<String> history = new ArrayList<>(getLastOpenedCaches());
        // bring entry to front, if it already existed
        history.remove(geocode);
        history.add(0, geocode);
        putString(R.string.pref_caches_history, StringUtils.join(history, HISTORY_SEPARATOR));
    }

    public static boolean useHardwareAcceleration() {
        return getBoolean(R.string.pref_hardware_acceleration, !HW_ACCEL_DISABLED_BY_DEFAULT);
    }

    public static void setUseHardwareAcceleration(final boolean useHardwareAcceleration) {
        putBoolean(R.string.pref_hardware_acceleration, useHardwareAcceleration);
    }

    public static String getLastCacheLog() {
        return getString(R.string.pref_last_cache_log, StringUtils.EMPTY);
    }

    public static void setLastCacheLog(final String log) {
        putString(R.string.pref_last_cache_log, log);
    }

    public static String getLastTrackableLog() {
        return getString(R.string.pref_last_trackable_log, StringUtils.EMPTY);
    }

    public static void setLastTrackableLog(final String log) {
        putString(R.string.pref_last_trackable_log, log);
    }

    @Nullable
    public static String getHomeLocation() {
        return getString(R.string.pref_home_location, null);
    }

    public static void setHomeLocation(@NonNull final String homeLocation) {
        putString(R.string.pref_home_location, homeLocation);
    }
}
!@#$%
20190527_010215,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_c08976
package cgeo.geocaching.settings;

import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.R;
import cgeo.geocaching.apps.cache.navi.NavigationAppFactory.NavigationAppsEnum;
import cgeo.geocaching.connector.capability.ICredentials;
import cgeo.geocaching.connector.gc.GCConnector;
import cgeo.geocaching.connector.gc.GCConstants;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.LogTypeTrackable;
import cgeo.geocaching.list.StoredList;
import cgeo.geocaching.location.Geopoint;
import cgeo.geocaching.maps.CGeoMap.MapMode;
import cgeo.geocaching.maps.MapProviderFactory;
import cgeo.geocaching.maps.LivemapStrategy;
import cgeo.geocaching.maps.google.v1.GoogleMapProvider;
import cgeo.geocaching.maps.interfaces.GeoPointImpl;
import cgeo.geocaching.maps.interfaces.MapProvider;
import cgeo.geocaching.maps.interfaces.MapSource;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider.OfflineMapSource;
import cgeo.geocaching.utils.CryptUtils;
import cgeo.geocaching.utils.FileUtils;
import cgeo.geocaching.utils.FileUtils.FileSelector;
import cgeo.geocaching.utils.Log;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.os.Build;
import android.os.Build.VERSION;
import android.os.Build.VERSION_CODES;
import android.os.Environment;
import android.preference.PreferenceManager;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;

/**
 * General c:geo preferences/settings set by the user
 */
public class Settings {

    /**
     * On opening a map, we limit the _initial_ zoom. The user can still zoom out afterwards.
     */
    private static final int INITIAL_MAP_ZOOM_LIMIT = 16;
    private static final char HISTORY_SEPARATOR = ',';
    public static final int SHOW_WP_THRESHOLD_DEFAULT = 10;
    public static final int SHOW_WP_THRESHOLD_MAX = 50;
    private static final int MAP_SOURCE_DEFAULT = GoogleMapProvider.GOOGLE_MAP_ID.hashCode();

    public static final boolean HW_ACCEL_DISABLED_BY_DEFAULT =
            Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1 ||
            StringUtils.equals(Build.MODEL, "HTC One X") ||    // HTC One X
            StringUtils.equals(Build.MODEL, "HTC One S") ||    // HTC One S
            StringUtils.equals(Build.MODEL, "GT-I8190")  ||    // Samsung S3 mini
            StringUtils.equals(Build.MODEL, "GT-S6310L") ||    // Samsung Galaxy Young
            StringUtils.equals(Build.MODEL, "GT-P5210")  ||    // Samsung Galaxy Tab 3
            StringUtils.equals(Build.MODEL, "GT-S7580")  ||    // Samsung Galaxy Trend Plus
            StringUtils.equals(Build.MODEL, "GT-I9105P") ||    // Samsung Galaxy SII Plus
            StringUtils.equals(Build.MODEL, "ST25i")     ||    // Sony Xperia U
            StringUtils.equals(Build.MODEL, "bq Aquaris 5");   // bq Aquaris 5

    // twitter api keys
    private final static @NonNull String TWITTER_KEY_CONSUMER_PUBLIC = CryptUtils.rot13("ESnsCvAv3kEupF1GCR3jGj");
    private final static @NonNull String TWITTER_KEY_CONSUMER_SECRET = CryptUtils.rot13("7vQWceACV9umEjJucmlpFe9FCMZSeqIqfkQ2BnhV9x");

    private static boolean useCompass = true;

    public enum CoordInputFormatEnum {
        Plain,
        Deg,
        Min,
        Sec;

        static final int DEFAULT_INT_VALUE = Min.ordinal();

        public static CoordInputFormatEnum fromInt(final int id) {
            final CoordInputFormatEnum[] values = CoordInputFormatEnum.values();
            if (id < 0 || id >= values.length) {
                return Min;
            }
            return values[id];
        }
    }

    private static final SharedPreferences sharedPrefs = PreferenceManager
            .getDefaultSharedPreferences(CgeoApplication.getInstance().getBaseContext());
    static {
        migrateSettings();
        final boolean isDebug = sharedPrefs.getBoolean(getKey(R.string.pref_debug), false);
        Log.setDebug(isDebug);
        CgeoApplication.dumpOnOutOfMemory(isDebug);
    }

    /**
     * Cache the mapsource locally. If that is an offline map source, each request would potentially access the
     * underlying map file, leading to delays.
     */
    private static MapSource mapSource;

    protected Settings() {
        throw new InstantiationError();
    }

    private static void migrateSettings() {
        final int LATEST_PREFERENCES_VERSION = 2;
        final int currentVersion = getInt(R.string.pref_settingsversion, 0);

        // No need to migrate if we are up to date.
        if (currentVersion == LATEST_PREFERENCES_VERSION) {
            return;
        }

        // No need to migrate if we don't have older settings, defaults will be used instead.
        final String preferencesNameV0 = "cgeo.pref";
        final SharedPreferences prefsV0 = CgeoApplication.getInstance().getSharedPreferences(preferencesNameV0, Context.MODE_PRIVATE);
        if (currentVersion == 0 && prefsV0.getAll().isEmpty()) {
            final Editor e = sharedPrefs.edit();
            e.putInt(getKey(R.string.pref_settingsversion), LATEST_PREFERENCES_VERSION);
            e.apply();
            return;
        }

        if (currentVersion < 1) {
            // migrate from non standard file location and integer based boolean types
            final Editor e = sharedPrefs.edit();

            e.putString(getKey(R.string.pref_temp_twitter_token_secret), prefsV0.getString(getKey(R.string.pref_temp_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_temp_twitter_token_public), prefsV0.getString(getKey(R.string.pref_temp_twitter_token_public), null));
            e.putBoolean(getKey(R.string.pref_help_shown), prefsV0.getInt(getKey(R.string.pref_help_shown), 0) != 0);
            e.putFloat(getKey(R.string.pref_anylongitude), prefsV0.getFloat(getKey(R.string.pref_anylongitude), 0));
            e.putFloat(getKey(R.string.pref_anylatitude), prefsV0.getFloat(getKey(R.string.pref_anylatitude), 0));
            e.putBoolean(getKey(R.string.pref_offlinemaps), 0 != prefsV0.getInt(getKey(R.string.pref_offlinemaps), 1));
            e.putBoolean(getKey(R.string.pref_offlinewpmaps), 0 != prefsV0.getInt(getKey(R.string.pref_offlinewpmaps), 0));
            e.putString(getKey(R.string.pref_webDeviceCode), prefsV0.getString(getKey(R.string.pref_webDeviceCode), null));
            e.putString(getKey(R.string.pref_webDeviceName), prefsV0.getString(getKey(R.string.pref_webDeviceName), null));
            e.putBoolean(getKey(R.string.pref_maplive), prefsV0.getInt(getKey(R.string.pref_maplive), 1) != 0);
            e.putInt(getKey(R.string.pref_mapsource), prefsV0.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT));
            e.putBoolean(getKey(R.string.pref_twitter), 0 != prefsV0.getInt(getKey(R.string.pref_twitter), 0));
            e.putBoolean(getKey(R.string.pref_showaddress), 0 != prefsV0.getInt(getKey(R.string.pref_showaddress), 1));
            e.putBoolean(getKey(R.string.pref_showcaptcha), prefsV0.getBoolean(getKey(R.string.pref_showcaptcha), false));
            e.putBoolean(getKey(R.string.pref_maptrail), prefsV0.getInt(getKey(R.string.pref_maptrail), 1) != 0);
            e.putInt(getKey(R.string.pref_lastmapzoom), prefsV0.getInt(getKey(R.string.pref_lastmapzoom), 14));
            e.putBoolean(getKey(R.string.pref_livelist), 0 != prefsV0.getInt(getKey(R.string.pref_livelist), 1));
            e.putBoolean(getKey(R.string.pref_units_imperial), prefsV0.getInt(getKey(R.string.pref_units_imperial), 1) != 1);
            e.putBoolean(getKey(R.string.pref_skin), prefsV0.getInt(getKey(R.string.pref_skin), 0) != 0);
            e.putInt(getKey(R.string.pref_lastusedlist), prefsV0.getInt(getKey(R.string.pref_lastusedlist), StoredList.STANDARD_LIST_ID));
            e.putString(getKey(R.string.pref_cachetype), prefsV0.getString(getKey(R.string.pref_cachetype), CacheType.ALL.id));
            e.putString(getKey(R.string.pref_twitter_token_secret), prefsV0.getString(getKey(R.string.pref_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_twitter_token_public), prefsV0.getString(getKey(R.string.pref_twitter_token_public), null));
            e.putInt(getKey(R.string.pref_version), prefsV0.getInt(getKey(R.string.pref_version), 0));
            e.putBoolean(getKey(R.string.pref_autoloaddesc), 0 != prefsV0.getInt(getKey(R.string.pref_autoloaddesc), 1));
            e.putBoolean(getKey(R.string.pref_ratingwanted), prefsV0.getBoolean(getKey(R.string.pref_ratingwanted), true));
            e.putBoolean(getKey(R.string.pref_friendlogswanted), prefsV0.getBoolean(getKey(R.string.pref_friendlogswanted), true));
            e.putBoolean(getKey(R.string.pref_useenglish), prefsV0.getBoolean(getKey(R.string.pref_useenglish), false));
            e.putBoolean(getKey(R.string.pref_usecompass), 0 != prefsV0.getInt(getKey(R.string.pref_usecompass), 1));
            e.putBoolean(getKey(R.string.pref_trackautovisit), prefsV0.getBoolean(getKey(R.string.pref_trackautovisit), false));
            e.putBoolean(getKey(R.string.pref_sigautoinsert), prefsV0.getBoolean(getKey(R.string.pref_sigautoinsert), false));
            e.putBoolean(getKey(R.string.pref_logimages), prefsV0.getBoolean(getKey(R.string.pref_logimages), false));
            e.putBoolean(getKey(R.string.pref_excludedisabled), 0 != prefsV0.getInt(getKey(R.string.pref_excludedisabled), 0));
            e.putBoolean(getKey(R.string.pref_excludemine), 0 != prefsV0.getInt(getKey(R.string.pref_excludemine), 0));
            e.putString(getKey(R.string.pref_mapfile), prefsV0.getString(getKey(R.string.pref_mapfile), null));
            e.putString(getKey(R.string.pref_signature), prefsV0.getString(getKey(R.string.pref_signature), null));
            e.putString(getKey(R.string.pref_pass_vote), prefsV0.getString(getKey(R.string.pref_pass_vote), null));
            e.putString(getKey(R.string.pref_password), prefsV0.getString(getKey(R.string.pref_password), null));
            e.putString(getKey(R.string.pref_username), prefsV0.getString(getKey(R.string.pref_username), null));
            e.putString(getKey(R.string.pref_memberstatus), prefsV0.getString(getKey(R.string.pref_memberstatus), ""));
            e.putInt(getKey(R.string.pref_coordinputformat), prefsV0.getInt(getKey(R.string.pref_coordinputformat), CoordInputFormatEnum.DEFAULT_INT_VALUE));
            e.putBoolean(getKey(R.string.pref_log_offline), prefsV0.getBoolean(getKey(R.string.pref_log_offline), false));
            e.putBoolean(getKey(R.string.pref_choose_list), prefsV0.getBoolean(getKey(R.string.pref_choose_list), true));
            e.putBoolean(getKey(R.string.pref_loaddirectionimg), prefsV0.getBoolean(getKey(R.string.pref_loaddirectionimg), true));
            e.putString(getKey(R.string.pref_gccustomdate), prefsV0.getString(getKey(R.string.pref_gccustomdate), GCConstants.DEFAULT_GC_DATE));
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), prefsV0.getInt(getKey(R.string.pref_showwaypointsthreshold), SHOW_WP_THRESHOLD_DEFAULT));
            e.putString(getKey(R.string.pref_cookiestore), prefsV0.getString(getKey(R.string.pref_cookiestore), null));
            e.putBoolean(getKey(R.string.pref_opendetailslastpage), prefsV0.getBoolean(getKey(R.string.pref_opendetailslastpage), false));
            e.putInt(getKey(R.string.pref_lastdetailspage), prefsV0.getInt(getKey(R.string.pref_lastdetailspage), 1));
            e.putInt(getKey(R.string.pref_defaultNavigationTool), prefsV0.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id));
            e.putInt(getKey(R.string.pref_defaultNavigationTool2), prefsV0.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id));
            e.putInt(getKey(R.string.pref_livemapstrategy), prefsV0.getInt(getKey(R.string.pref_livemapstrategy), LivemapStrategy.AUTO.id));
            e.putBoolean(getKey(R.string.pref_debug), prefsV0.getBoolean(getKey(R.string.pref_debug), false));
            e.putInt(getKey(R.string.pref_livemaphintshowcount), prefsV0.getInt(getKey(R.string.pref_livemaphintshowcount), 0));

            e.putInt(getKey(R.string.pref_settingsversion), 1); // mark migrated
            e.apply();
        }

        // changes for new settings dialog
        if (currentVersion < 2) {
            final Editor e = sharedPrefs.edit();

            e.putBoolean(getKey(R.string.pref_units_imperial), useImperialUnits());

            // show waypoints threshold now as a slider
            int wpThreshold = getWayPointsThreshold();
            if (wpThreshold < 0) {
                wpThreshold = 0;
            } else if (wpThreshold > SHOW_WP_THRESHOLD_MAX) {
                wpThreshold = SHOW_WP_THRESHOLD_MAX;
            }
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), wpThreshold);

            // KEY_MAP_SOURCE must be string, because it is the key for a ListPreference now
            final int ms = sharedPrefs.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT);
            e.remove(getKey(R.string.pref_mapsource));
            e.putString(getKey(R.string.pref_mapsource), String.valueOf(ms));

            // navigation tool ids must be string, because ListPreference uses strings as keys
            final int dnt1 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id);
            final int dnt2 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id);
            e.remove(getKey(R.string.pref_defaultNavigationTool));
            e.remove(getKey(R.string.pref_defaultNavigationTool2));
            e.putString(getKey(R.string.pref_defaultNavigationTool), String.valueOf(dnt1));
            e.putString(getKey(R.string.pref_defaultNavigationTool2), String.valueOf(dnt2));

            // defaults for gpx directories
            e.putString(getKey(R.string.pref_gpxImportDir), getGpxImportDir());
            e.putString(getKey(R.string.pref_gpxExportDir), getGpxExportDir());

            e.putInt(getKey(R.string.pref_settingsversion), 2); // mark migrated
            e.apply();
        }
    }

    private static String getKey(final int prefKeyId) {
        return CgeoApplication.getInstance().getString(prefKeyId);
    }

    static String getString(final int prefKeyId, final String defaultValue) {
        return sharedPrefs.getString(getKey(prefKeyId), defaultValue);
    }

    private static int getInt(final int prefKeyId, final int defaultValue) {
        return sharedPrefs.getInt(getKey(prefKeyId), defaultValue);
    }

    private static long getLong(final int prefKeyId, final long defaultValue) {
        return sharedPrefs.getLong(getKey(prefKeyId), defaultValue);
    }

    private static boolean getBoolean(final int prefKeyId, final boolean defaultValue) {
        return sharedPrefs.getBoolean(getKey(prefKeyId), defaultValue);
    }

    private static float getFloat(final int prefKeyId, final float defaultValue) {
        return sharedPrefs.getFloat(getKey(prefKeyId), defaultValue);
    }

    protected static void putString(final int prefKeyId, final String value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putString(getKey(prefKeyId), value);
        edit.apply();
    }

    protected static void putBoolean(final int prefKeyId, final boolean value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putBoolean(getKey(prefKeyId), value);
        edit.apply();
    }

    private static void putInt(final int prefKeyId, final int value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putInt(getKey(prefKeyId), value);
        edit.apply();
    }

    private static void putLong(final int prefKeyId, final long value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putLong(getKey(prefKeyId), value);
        edit.apply();
    }

    private static void putFloat(final int prefKeyId, final float value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putFloat(getKey(prefKeyId), value);
        edit.apply();
    }

    private static void remove(final int prefKeyId) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.remove(getKey(prefKeyId));
        edit.apply();
    }

    private static boolean contains(final int prefKeyId) {
        return sharedPrefs.contains(getKey(prefKeyId));
    }

    public static void setLanguage(final boolean useEnglish) {
        final Configuration config = new Configuration();
        config.locale = useEnglish ? Locale.ENGLISH : Locale.getDefault();
        final Resources resources = CgeoApplication.getInstance().getResources();
        resources.updateConfiguration(config, resources.getDisplayMetrics());
    }

    public static Locale getLanguage() {
        final Configuration config = new Configuration();
        final Resources resources = CgeoApplication.getInstance().getResources();
        return resources.getConfiguration().locale;
    }

    public static boolean hasGCCredentials() {
        final String preUsername = getString(R.string.pref_username, null);
        final String prePassword = getString(R.string.pref_password, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    /**
     * Get login and password information of Geocaching.com.
     *
     * @return a pair either with (login, password) or (empty, empty) if no valid information is stored
     */
    public static ImmutablePair<String, String> getGcCredentials() {
        return getCredentials(GCConnector.getInstance());
    }

    /**
     * Get login and password information.
     *
     * @return a pair either with (login, password) or (empty, empty) if no valid information is stored
     */
    public static ImmutablePair<String, String> getCredentials(final @NonNull ICredentials connector) {
        final String username = getString(connector.getUsernamePreferenceKey(), null);
        final String password = getString(connector.getPasswordPreferenceKey(), null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return new ImmutablePair<>(StringUtils.EMPTY, StringUtils.EMPTY);
        }

        return new ImmutablePair<>(username, password);
    }

    public static String getUsername() {
        return getString(R.string.pref_username, StringUtils.EMPTY);
    }

    public static boolean isGCConnectorActive() {
        return getBoolean(R.string.pref_connectorGCActive, true);
    }

    public static boolean isECConnectorActive() {
        return getBoolean(R.string.pref_connectorECActive, false);
    }

    public static boolean isOXConnectorActive() {
        return getBoolean(R.string.pref_connectorOXActive, false);
    }

    public static boolean isGCPremiumMember() {
        final String memberStatus = Settings.getGCMemberStatus();
        return StringUtils.equalsIgnoreCase(memberStatus, GCConstants.MEMBER_STATUS_PREMIUM) ||
                StringUtils.equalsIgnoreCase(memberStatus, GCConstants.MEMBER_STATUS_CHARTER);
    }

    public static String getGCMemberStatus() {
        return getString(R.string.pref_memberstatus, "");
    }

    public static void setGCMemberStatus(final String memberStatus) {
        if (StringUtils.isBlank(memberStatus)) {
            remove(R.string.pref_memberstatus);
        }
        putString(R.string.pref_memberstatus, memberStatus);
    }

    public static ImmutablePair<String, String> getTokenPair(final int tokenPublicPrefKey, final int tokenSecretPrefKey) {
        return new ImmutablePair<>(getString(tokenPublicPrefKey, null), getString(tokenSecretPrefKey, null));
    }

    public static void setTokens(final int tokenPublicPrefKey, @Nullable final String tokenPublic, final int tokenSecretPrefKey, @Nullable final String tokenSecret) {
        if (tokenPublic == null) {
            remove(tokenPublicPrefKey);
        } else {
            putString(tokenPublicPrefKey, tokenPublic);
        }
        if (tokenSecret == null) {
            remove(tokenSecretPrefKey);
        } else {
            putString(tokenSecretPrefKey, tokenSecret);
        }
    }

    public static boolean isOCConnectorActive(final int isActivePrefKeyId) {
        return getBoolean(isActivePrefKeyId, false);
    }

    public static boolean hasOCAuthorization(final int tokenPublicPrefKeyId, final int tokenSecretPrefKeyId) {
        return StringUtils.isNotBlank(getString(tokenPublicPrefKeyId, ""))
                && StringUtils.isNotBlank(getString(tokenSecretPrefKeyId, ""));
    }

    public static boolean isGCvoteLogin() {
        return getGCvoteLogin() != null;
    }

    public static ImmutablePair<String, String> getGCvoteLogin() {
        final String username = getString(R.string.pref_username, null);
        final String password = getString(R.string.pref_pass_vote, null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return null;
        }

        return new ImmutablePair<>(username, password);
    }

    public static String getSignature() {
        return getString(R.string.pref_signature, StringUtils.EMPTY);
    }

    public static void setCookieStore(final String cookies) {
        if (StringUtils.isBlank(cookies)) {
            // erase cookies
            remove(R.string.pref_cookiestore);
        }
        // save cookies
        putString(R.string.pref_cookiestore, cookies);
    }

    public static String getCookieStore() {
        return getString(R.string.pref_cookiestore, null);
    }

    public static void setUseGooglePlayServices(final boolean value) {
        putBoolean(R.string.pref_googleplayservices, value);
    }

    public static boolean useGooglePlayServices() {
        // By defaut, enable play services starting from ICS.
        return CgeoApplication.getInstance().isGooglePlayServicesAvailable() &&
                getBoolean(R.string.pref_googleplayservices, VERSION.SDK_INT >= VERSION_CODES.ICE_CREAM_SANDWICH);
    }

    public static boolean useLowPowerMode() {
        return getBoolean(R.string.pref_lowpowermode, false);
    }

    /**
     * @param cacheType
     *            The cache type used for future filtering
     */
    public static void setCacheType(final CacheType cacheType) {
        if (cacheType == null) {
            remove(R.string.pref_cachetype);
        } else {
            putString(R.string.pref_cachetype, cacheType.id);
        }
    }

    public static int getLastList() {
        return getInt(R.string.pref_lastusedlist, StoredList.STANDARD_LIST_ID);
    }

    public static void saveLastList(final int listId) {
        putInt(R.string.pref_lastusedlist, listId);
    }

    public static void setWebNameCode(final String name, final String code) {
        putString(R.string.pref_webDeviceName, name);
        putString(R.string.pref_webDeviceCode, code);
    }

    public static MapProvider getMapProvider() {
        return getMapSource().getMapProvider();
    }

    public static String getMapFile() {
        return getString(R.string.pref_mapfile, null);
    }

    public static void setMapFile(final String mapFile) {
        putString(R.string.pref_mapfile, mapFile);
        if (mapFile != null) {
            setMapFileDirectory(new File(mapFile).getParent());
        }
    }

    public static String getMapFileDirectory() {
        final String mapDir = getString(R.string.pref_mapDirectory, null);
        if (mapDir != null) {
            return mapDir;
        }
        final String mapFile = getMapFile();
        if (mapFile != null) {
            return new File(mapFile).getParent();
        }
        return null;
    }

    public static void setMapFileDirectory(final String mapFileDirectory) {
        putString(R.string.pref_mapDirectory, mapFileDirectory);
        MapsforgeMapProvider.getInstance().updateOfflineMaps();
    }

    public static boolean isValidMapFile() {
        return isValidMapFile(getMapFile());
    }

    public static boolean isValidMapFile(final String mapFileIn) {
        return MapsforgeMapProvider.isValidMapFile(mapFileIn);
    }

    public static boolean isScaleMapsforgeText() {
        return getBoolean(R.string.pref_mapsforge_scale_text, true);
    }

    public static CoordInputFormatEnum getCoordInputFormat() {
        return CoordInputFormatEnum.fromInt(getInt(R.string.pref_coordinputformat, CoordInputFormatEnum.DEFAULT_INT_VALUE));
    }

    public static void setCoordInputFormat(final CoordInputFormatEnum format) {
        putInt(R.string.pref_coordinputformat, format.ordinal());
    }

    public static boolean getLogOffline() {
        return getBoolean(R.string.pref_log_offline, false);
    }

    public static boolean getChooseList() {
        return getBoolean(R.string.pref_choose_list, false);
    }

    public static boolean getLoadDirImg() {
        return !isGCPremiumMember() && getBoolean(R.string.pref_loaddirectionimg, true);
    }

    public static void setGcCustomDate(final String format) {
        putString(R.string.pref_gccustomdate, format);
    }

    /**
     * @return User selected date format on GC.com
     */
    public static String getGcCustomDate() {
        // We might have some users whose stored value is null, which is invalid. In this case, we use the default.
        return StringUtils.defaultString(getString(R.string.pref_gccustomdate, GCConstants.DEFAULT_GC_DATE),
                GCConstants.DEFAULT_GC_DATE);
    }

    public static boolean isExcludeMyCaches() {
        return getBoolean(R.string.pref_excludemine, false);
    }

    public static boolean isUseEnglish() {
        return getBoolean(R.string.pref_useenglish, false);
    }

    public static boolean isShowAddress() {
        return getBoolean(R.string.pref_showaddress, true);
    }

    public static boolean isShowCaptcha() {
        return !isGCPremiumMember() && getBoolean(R.string.pref_showcaptcha, false);
    }

    public static boolean isExcludeDisabledCaches() {
        return getBoolean(R.string.pref_excludedisabled, false);
    }

    public static boolean isStoreOfflineMaps() {
        return getBoolean(R.string.pref_offlinemaps, true);
    }

    public static boolean isStoreOfflineWpMaps() {
        return getBoolean(R.string.pref_offlinewpmaps, false);
    }

    public static boolean isStoreLogImages() {
        return getBoolean(R.string.pref_logimages, false);
    }

    public static boolean isAutoLoadDescription() {
        return getBoolean(R.string.pref_autoloaddesc, true);
    }

    public static boolean isRatingWanted() {
        return getBoolean(R.string.pref_ratingwanted, true);
    }

    public static boolean isGeokretyConnectorActive() {
        return getBoolean(R.string.pref_connectorGeokretyActive, true);
    }

    public static boolean isGeokretyCacheActive() {
        return getBoolean(R.string.pref_geokrety_cache, true);
    }

    public static String getGeokretyUsername() {
        return getString(R.string.pref_geokrety_username, null);
    }

    public static String getGeokretyPassword() {
        return getString(R.string.pref_geokrety_password, null);
    }

    public static String getGeokretySecId() {
        return getString(R.string.pref_geokrety_secid, null);
    }

    public static void setGeokretySecId(final String secid) {
        putString(R.string.pref_geokrety_secid, secid);
    }

    public static boolean isRegisteredForGeokrety() {
        return getGeokretySecId() != null;
    }

    public static boolean isFriendLogsWanted() {
        if (!hasGCCredentials()) {
            // don't show a friends log if the user is anonymous
            return false;
        }
        return getBoolean(R.string.pref_friendlogswanted, true);
    }

    public static boolean isLiveList() {
        return getBoolean(R.string.pref_livelist, true);
    }

    public static boolean isTrackableAutoVisit() {
        return getBoolean(R.string.pref_trackautovisit, false);
    }

    public static boolean isAutoInsertSignature() {
        return getBoolean(R.string.pref_sigautoinsert, false);
    }

    public static void setUseImperialUnits(final boolean useImperialUnits) {
        putBoolean(R.string.pref_units_imperial, useImperialUnits);
    }

    public static boolean useImperialUnits() {
        return getBoolean(R.string.pref_units_imperial, useImperialUnitsByDefault());
    }

    static boolean useImperialUnitsByDefault() {
        final String countryCode = Locale.getDefault().getCountry();
        return "US".equals(countryCode)  // USA
            || "LR".equals(countryCode)  // Liberia
            || "MM".equals(countryCode); // Burma
    }

    public static boolean isLiveMap() {
        return getBoolean(R.string.pref_maplive, true);
    }

    public static void setLiveMap(final boolean live) {
        putBoolean(R.string.pref_maplive, live);
    }

    public static boolean isMapTrail() {
        return getBoolean(R.string.pref_maptrail, false);
    }

    public static void setMapTrail(final boolean showTrail) {
        putBoolean(R.string.pref_maptrail, showTrail);
    }

    /**
     * Get last used zoom of the internal map. Differentiate between two use cases for a map of multiple caches (e.g.
     * live map) and the map of a single cache (which is often zoomed in more deep).
     */
    public static int getMapZoom(final MapMode mapMode) {
        if (mapMode == MapMode.SINGLE || mapMode == MapMode.COORDS) {
            return getCacheZoom();
        }
        return getMapZoom();
    }

    public static void setMapZoom(final MapMode mapMode, final int zoomLevel) {
        if (mapMode == MapMode.SINGLE || mapMode == MapMode.COORDS) {
            setCacheZoom(zoomLevel);
        }
        else {
            setMapZoom(zoomLevel);
        }
    }

    /**
     * @return zoom used for the (live) map
     */
    private static int getMapZoom() {
        return Math.max(getInt(R.string.pref_lastmapzoom, 14), INITIAL_MAP_ZOOM_LIMIT);
    }

    private static void setMapZoom(final int mapZoomLevel) {
        putInt(R.string.pref_lastmapzoom, mapZoomLevel);
    }

    /**
     * @return zoom used for the map of a single cache
     */
    private static int getCacheZoom() {
        return Math.max(getInt(R.string.pref_cache_zoom, 14), INITIAL_MAP_ZOOM_LIMIT);
    }

    private static void setCacheZoom(final int zoomLevel) {
        putInt(R.string.pref_cache_zoom, zoomLevel);
    }

    public static GeoPointImpl getMapCenter() {
        return getMapProvider().getMapItemFactory()
                .getGeoPointBase(new Geopoint(getInt(R.string.pref_lastmaplat, 0) / 1e6,
                        getInt(R.string.pref_lastmaplon, 0) / 1e6));
    }

    public static void setMapCenter(final GeoPointImpl mapViewCenter) {
        putInt(R.string.pref_lastmaplat, mapViewCenter.getLatitudeE6());
        putInt(R.string.pref_lastmaplon, mapViewCenter.getLongitudeE6());
    }

    @NonNull
    public static synchronized MapSource getMapSource() {
        if (mapSource != null) {
            return mapSource;
        }
        final int id = getConvertedMapId();
        mapSource = MapProviderFactory.getMapSource(id);
        if (mapSource != null) {
            // don't use offline maps if the map file is not valid
            if (!(mapSource instanceof OfflineMapSource) || isValidMapFile()) {
                return mapSource;
            }
        }
        // fallback to first available map
        return MapProviderFactory.getDefaultSource();
    }

    private final static int GOOGLEMAP_BASEID = 30;
    private final static int MAP = 1;
    private final static int SATELLITE = 2;

    private final static int MFMAP_BASEID = 40;
    private final static int MAPNIK = 1;
    private final static int CYCLEMAP = 3;
    private final static int OFFLINE = 4;
    private static final int HISTORY_SIZE = 10;

    /**
     * Convert old preference ids for maps (based on constant values) into new hash based ids.
     */
    private static int getConvertedMapId() {
        final int id = Integer.parseInt(getString(R.string.pref_mapsource,
                String.valueOf(MAP_SOURCE_DEFAULT)));
        switch (id) {
            case GOOGLEMAP_BASEID + MAP:
                return GoogleMapProvider.GOOGLE_MAP_ID.hashCode();
            case GOOGLEMAP_BASEID + SATELLITE:
                return GoogleMapProvider.GOOGLE_SATELLITE_ID.hashCode();
            case MFMAP_BASEID + MAPNIK:
                return MapsforgeMapProvider.MAPSFORGE_MAPNIK_ID.hashCode();
            case MFMAP_BASEID + CYCLEMAP:
                return MapsforgeMapProvider.MAPSFORGE_CYCLEMAP_ID.hashCode();
            case MFMAP_BASEID + OFFLINE: {
                final String mapFile = Settings.getMapFile();
                if (StringUtils.isNotEmpty(mapFile)) {
                    return mapFile.hashCode();
                }
                break;
            }
            default:
                break;
        }
        return id;
    }

    public static synchronized void setMapSource(final MapSource newMapSource) {
        putString(R.string.pref_mapsource, String.valueOf(newMapSource.getNumericalId()));
        if (newMapSource instanceof OfflineMapSource) {
            setMapFile(((OfflineMapSource) newMapSource).getFileName());
        }
        // cache the value
        mapSource = newMapSource;
    }

    public static void setAnyCoordinates(final Geopoint coords) {
        if (null != coords) {
            putFloat(R.string.pref_anylatitude, (float) coords.getLatitude());
            putFloat(R.string.pref_anylongitude, (float) coords.getLongitude());
        } else {
            remove(R.string.pref_anylatitude);
            remove(R.string.pref_anylongitude);
        }
    }

    public static Geopoint getAnyCoordinates() {
        if (contains(R.string.pref_anylatitude) && contains(R.string.pref_anylongitude)) {
            final float lat = getFloat(R.string.pref_anylatitude, 0);
            final float lon = getFloat(R.string.pref_anylongitude, 0);
            return new Geopoint(lat, lon);
        }
        return null;
    }

    public static boolean isUseCompass() {
        return useCompass;
    }

    public static void setUseCompass(final boolean value) {
        useCompass = value;
    }

    public static boolean isLightSkin() {
        return getBoolean(R.string.pref_skin, false);
    }

    @NonNull
    public static String getTwitterKeyConsumerPublic() {
        return TWITTER_KEY_CONSUMER_PUBLIC;
    }

    @NonNull
    public static String getTwitterKeyConsumerSecret() {
        return TWITTER_KEY_CONSUMER_SECRET;
    }

    public static String getWebDeviceCode() {
        return getString(R.string.pref_webDeviceCode, null);
    }

    public static boolean isRegisteredForSend2cgeo() {
        return getWebDeviceCode() != null;
    }

    public static String getWebDeviceName() {
        return getString(R.string.pref_webDeviceName, Build.MODEL);
    }

    /**
     * @return The cache type used for filtering or ALL if no filter is active.
     *         Returns never null
     */
    @NonNull
    public static CacheType getCacheType() {
        return CacheType.getById(getString(R.string.pref_cachetype, CacheType.ALL.id));
    }

    /**
     * The Threshold for the showing of child waypoints
     */
    public static int getWayPointsThreshold() {
        return getInt(R.string.pref_showwaypointsthreshold, SHOW_WP_THRESHOLD_DEFAULT);
    }

    public static void setShowWaypointsThreshold(final int threshold) {
        putInt(R.string.pref_showwaypointsthreshold, threshold);
    }

    public static boolean isUseTwitter() {
        return getBoolean(R.string.pref_twitter, false);
    }

    public static void setUseTwitter(final boolean useTwitter) {
        putBoolean(R.string.pref_twitter, useTwitter);
    }

    public static boolean isTwitterLoginValid() {
        return !StringUtils.isBlank(getTokenPublic())
                && !StringUtils.isBlank(getTokenSecret());
    }

    public static String getTokenPublic() {
        return getString(R.string.pref_twitter_token_public, null);
    }

    public static String getTokenSecret() {
        return getString(R.string.pref_twitter_token_secret, null);

    }

    public static boolean hasTwitterAuthorization() {
        return StringUtils.isNotBlank(getTokenPublic())
                && StringUtils.isNotBlank(getTokenSecret());
    }

    public static void setTwitterTokens(@Nullable final String tokenPublic,
            @Nullable final String tokenSecret, final boolean enableTwitter) {
        putString(R.string.pref_twitter_token_public, tokenPublic);
        putString(R.string.pref_twitter_token_secret, tokenSecret);
        if (tokenPublic != null) {
            remove(R.string.pref_temp_twitter_token_public);
            remove(R.string.pref_temp_twitter_token_secret);
        }
        setUseTwitter(enableTwitter);
    }

    public static void setTwitterTempTokens(@Nullable final String tokenPublic,
            @Nullable final String tokenSecret) {
        putString(R.string.pref_temp_twitter_token_public, tokenPublic);
        putString(R.string.pref_temp_twitter_token_secret, tokenSecret);
    }

    public static ImmutablePair<String, String> getTempToken() {
        final String tokenPublic = getString(R.string.pref_temp_twitter_token_public, null);
        final String tokenSecret = getString(R.string.pref_temp_twitter_token_secret, null);
        return new ImmutablePair<>(tokenPublic, tokenSecret);
    }

    public static int getVersion() {
        return getInt(R.string.pref_version, 0);
    }

    public static void setVersion(final int version) {
        putInt(R.string.pref_version, version);
    }

    public static boolean isOpenLastDetailsPage() {
        return getBoolean(R.string.pref_opendetailslastpage, false);
    }

    public static int getLastDetailsPage() {
        return getInt(R.string.pref_lastdetailspage, 1);
    }

    public static void setLastDetailsPage(final int index) {
        putInt(R.string.pref_lastdetailspage, index);
    }

    public static int getDefaultNavigationTool() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool,
                String.valueOf(NavigationAppsEnum.COMPASS.id)));
    }

    public static int getDefaultNavigationTool2() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool2,
                String.valueOf(NavigationAppsEnum.INTERNAL_MAP.id)));
    }

    public static LivemapStrategy getLiveMapStrategy() {
        return LivemapStrategy.getById(getInt(R.string.pref_livemapstrategy, LivemapStrategy.AUTO.id));
    }

    public static void setLiveMapStrategy(final LivemapStrategy strategy) {
        putInt(R.string.pref_livemapstrategy, strategy.id);
    }

    public static boolean isDebug() {
        return Log.isDebug();
    }

    public static int getLiveMapHintShowCount() {
        return getInt(R.string.pref_livemaphintshowcount, 0);
    }

    public static void setLiveMapHintShowCount(final int showCount) {
        putInt(R.string.pref_livemaphintshowcount, showCount);
    }

    public static boolean isDbOnSDCard() {
        return getBoolean(R.string.pref_dbonsdcard, false);
    }

    public static void setDbOnSDCard(final boolean dbOnSDCard) {
        putBoolean(R.string.pref_dbonsdcard, dbOnSDCard);
    }

    public static String getGpxExportDir() {
        return getString(R.string.pref_gpxExportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static String getGpxImportDir() {
        return getString(R.string.pref_gpxImportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static boolean getShareAfterExport() {
        return getBoolean(R.string.pref_shareafterexport, true);
    }

    public static void setShareAfterExport(final boolean shareAfterExport) {
        putBoolean(R.string.pref_shareafterexport, shareAfterExport);
    }

    public static int getTrackableAction() {
        return getInt(R.string.pref_trackableaction, LogTypeTrackable.RETRIEVED_IT.id);
    }

    public static void setTrackableAction(final int trackableAction) {
        putInt(R.string.pref_trackableaction, trackableAction);
    }

    public static String getCustomRenderThemeBaseFolder() {
        return getString(R.string.pref_renderthemepath, "");
    }

    public static String getCustomRenderThemeFilePath() {
        return getString(R.string.pref_renderthemefile, "");
    }

    public static void setCustomRenderThemeFile(final String customRenderThemeFile) {
        putString(R.string.pref_renderthemefile, customRenderThemeFile);
    }

    public static File[] getMapThemeFiles() {
        final File directory = new File(Settings.getCustomRenderThemeBaseFolder());
        final List<File> result = new ArrayList<>();
        FileUtils.listDir(result, directory, new ExtensionsBasedFileSelector(new String[] { "xml" }), null);

        return result.toArray(new File[result.size()]);
    }

    private static class ExtensionsBasedFileSelector extends FileSelector {
        private final String[] extensions;
        public ExtensionsBasedFileSelector(final String[] extensions) {
            this.extensions = extensions;
        }
        @Override
        public boolean isSelected(final File file) {
            final String filename = file.getName();
            for (final String ext : extensions) {
                if (StringUtils.endsWithIgnoreCase(filename, ext)) {
                    return true;
                }
            }
            return false;
        }
        @Override
        public boolean shouldEnd() {
            return false;
        }
    }

    public static boolean getPlainLogs() {
        return getBoolean(R.string.pref_plainLogs, false);
    }

    public static boolean getUseNativeUa() {
        return getBoolean(R.string.pref_nativeUa, false);
    }

    public static String getCacheTwitterMessage() {
        return getString(R.string.pref_twitter_cache_message, "I found [NAME] ([URL]).");
    }

    public static String getTrackableTwitterMessage() {
        return getString(R.string.pref_twitter_trackable_message, "I touched [NAME] ([URL]).");
    }

    public static int getLogImageScale() {
        return getInt(R.string.pref_logImageScale, -1);
    }

    public static void setLogImageScale(final int scale) {
        putInt(R.string.pref_logImageScale, scale);
    }

    public static void setExcludeMine(final boolean exclude) {
        putBoolean(R.string.pref_excludemine, exclude);
    }

    static void setLogin(final String username, final String password) {
        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            // erase username and password
            remove(R.string.pref_username);
            remove(R.string.pref_password);
            return;
        }
        // save username and password
        putString(R.string.pref_username, username);
        putString(R.string.pref_password, password);
    }

    public static long getFieldnoteExportDate() {
        return getLong(R.string.pref_fieldNoteExportDate, 0);
    }

    /**
     * Remember date of last field note export.
     */
    public static void setFieldnoteExportDate(final long date) {
        putLong(R.string.pref_fieldNoteExportDate, date);
    }

    public static boolean isUseNavigationApp(final NavigationAppsEnum navApp) {
        return getBoolean(navApp.preferenceKey, true);
    }

    /**
     * Remember the state of the "Upload" checkbox in the field notes export dialog.
     */
    public static void setFieldNoteExportUpload(final boolean upload) {
        putBoolean(R.string.pref_fieldNoteExportUpload, upload);
    }

    public static boolean getFieldNoteExportUpload() {
        return getBoolean(R.string.pref_fieldNoteExportUpload, true);
    }

    /**
     * Remember the state of the "Only new" checkbox in the field notes export dialog.
     */
    public static void setFieldNoteExportOnlyNew(final boolean onlyNew) {
        putBoolean(R.string.pref_fieldNoteExportOnlyNew, onlyNew);
    }

    public static boolean getFieldNoteExportOnlyNew() {
        return getBoolean(R.string.pref_fieldNoteExportOnlyNew, false);
    }

    public static String getECIconSet() {
        return getString(R.string.pref_ec_icons, "1");
    }

    /* Store last checksum of changelog for changelog display */
    public static long getLastChangelogChecksum() {
        return getLong(R.string.pref_changelog_last_checksum, 0);
    }

    public static void setLastChangelogChecksum(final long checksum) {
        putLong(R.string.pref_changelog_last_checksum, checksum);
    }

    public static List<String> getLastOpenedCaches() {
        final List<String> history = Arrays.asList(StringUtils.split(getString(R.string.pref_caches_history, StringUtils.EMPTY), HISTORY_SEPARATOR));
        return history.subList(0, Math.min(HISTORY_SIZE, history.size()));
    }

    public static void addCacheToHistory(@NonNull final String geocode) {
        final ArrayList<String> history = new ArrayList<>(getLastOpenedCaches());
        // bring entry to front, if it already existed
        history.remove(geocode);
        history.add(0, geocode);
        putString(R.string.pref_caches_history, StringUtils.join(history, HISTORY_SEPARATOR));
    }

    public static boolean useHardwareAcceleration() {
        return getBoolean(R.string.pref_hardware_acceleration, !HW_ACCEL_DISABLED_BY_DEFAULT);
    }

    public static void setUseHardwareAcceleration(final boolean useHardwareAcceleration) {
        putBoolean(R.string.pref_hardware_acceleration, useHardwareAcceleration);
    }

    public static String getLastCacheLog() {
        return getString(R.string.pref_last_cache_log, StringUtils.EMPTY);
    }

    public static void setLastCacheLog(final String log) {
        putString(R.string.pref_last_cache_log, log);
    }

    public static String getLastTrackableLog() {
        return getString(R.string.pref_last_trackable_log, StringUtils.EMPTY);
    }

    public static void setLastTrackableLog(final String log) {
        putString(R.string.pref_last_trackable_log, log);
    }

    @Nullable
    public static String getHomeLocation() {
        return getString(R.string.pref_home_location, null);
    }

    public static void setHomeLocation(@NonNull final String homeLocation) {
        putString(R.string.pref_home_location, homeLocation);
    }
}
!@#$%
20190527_010908,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_b21452
package cgeo.geocaching.settings;

import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.R;
import cgeo.geocaching.apps.navi.NavigationAppFactory.NavigationAppsEnum;
import cgeo.geocaching.connector.capability.ICredentials;
import cgeo.geocaching.connector.gc.GCConnector;
import cgeo.geocaching.connector.gc.GCConstants;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.LogTypeTrackable;
import cgeo.geocaching.list.StoredList;
import cgeo.geocaching.location.Geopoint;
import cgeo.geocaching.maps.CGeoMap.MapMode;
import cgeo.geocaching.maps.LivemapStrategy;
import cgeo.geocaching.maps.MapProviderFactory;
import cgeo.geocaching.maps.google.v1.GoogleMapProvider;
import cgeo.geocaching.maps.interfaces.GeoPointImpl;
import cgeo.geocaching.maps.interfaces.MapProvider;
import cgeo.geocaching.maps.interfaces.MapSource;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider.OfflineMapSource;
import cgeo.geocaching.utils.CryptUtils;
import cgeo.geocaching.utils.FileUtils;
import cgeo.geocaching.utils.FileUtils.FileSelector;
import cgeo.geocaching.utils.Log;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.os.Build;
import android.os.Build.VERSION;
import android.os.Build.VERSION_CODES;
import android.os.Environment;
import android.preference.PreferenceManager;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;

/**
 * General c:geo preferences/settings set by the user
 */
public class Settings {

    /**
     * On opening a map, we limit the _initial_ zoom. The user can still zoom out afterwards.
     */
    private static final int INITIAL_MAP_ZOOM_LIMIT = 16;
    private static final char HISTORY_SEPARATOR = ',';
    private static final int SHOW_WP_THRESHOLD_DEFAULT = 10;
    public static final int SHOW_WP_THRESHOLD_MAX = 50;
    private static final int MAP_SOURCE_DEFAULT = GoogleMapProvider.GOOGLE_MAP_ID.hashCode();

    public static final boolean HW_ACCEL_DISABLED_BY_DEFAULT =
            Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1 ||
            StringUtils.equals(Build.MODEL, "HTC One X") ||    // HTC One X
            StringUtils.equals(Build.MODEL, "HTC One S") ||    // HTC One S
            StringUtils.equals(Build.MODEL, "GT-I8190")  ||    // Samsung S3 mini
            StringUtils.equals(Build.MODEL, "GT-S6310L") ||    // Samsung Galaxy Young
            StringUtils.equals(Build.MODEL, "GT-P5210")  ||    // Samsung Galaxy Tab 3
            StringUtils.equals(Build.MODEL, "GT-S7580")  ||    // Samsung Galaxy Trend Plus
            StringUtils.equals(Build.MODEL, "GT-I9105P") ||    // Samsung Galaxy SII Plus
            StringUtils.equals(Build.MODEL, "ST25i")     ||    // Sony Xperia U
            StringUtils.equals(Build.MODEL, "bq Aquaris 5") || // bq Aquaris 5
            StringUtils.equals(Build.MODEL, "A1-810")    ||    // Unknown A1-810
            StringUtils.equals(Build.MODEL, "GT-I9195")  ||    // Samsung S4 mini
            StringUtils.equals(Build.MODEL, "GT-I8200N");      // Samsung S3 mini

    // twitter api keys
    private final static @NonNull String TWITTER_KEY_CONSUMER_PUBLIC = CryptUtils.rot13("ESnsCvAv3kEupF1GCR3jGj");
    private final static @NonNull String TWITTER_KEY_CONSUMER_SECRET = CryptUtils.rot13("7vQWceACV9umEjJucmlpFe9FCMZSeqIqfkQ2BnhV9x");

    private static boolean useCompass = true;

    public enum CoordInputFormatEnum {
        Plain,
        Deg,
        Min,
        Sec;

        static final int DEFAULT_INT_VALUE = Min.ordinal();

        public static CoordInputFormatEnum fromInt(final int id) {
            final CoordInputFormatEnum[] values = CoordInputFormatEnum.values();
            if (id < 0 || id >= values.length) {
                return Min;
            }
            return values[id];
        }
    }

    private static final SharedPreferences sharedPrefs = PreferenceManager
            .getDefaultSharedPreferences(CgeoApplication.getInstance().getBaseContext());
    static {
        migrateSettings();
        final boolean isDebug = sharedPrefs.getBoolean(getKey(R.string.pref_debug), false);
        Log.setDebug(isDebug);
        CgeoApplication.dumpOnOutOfMemory(isDebug);
    }

    /**
     * Cache the mapsource locally. If that is an offline map source, each request would potentially access the
     * underlying map file, leading to delays.
     */
    private static MapSource mapSource;

    protected Settings() {
        throw new InstantiationError();
    }

    private static void migrateSettings() {
        final int LATEST_PREFERENCES_VERSION = 2;
        final int currentVersion = getInt(R.string.pref_settingsversion, 0);

        // No need to migrate if we are up to date.
        if (currentVersion == LATEST_PREFERENCES_VERSION) {
            return;
        }

        // No need to migrate if we don't have older settings, defaults will be used instead.
        final String preferencesNameV0 = "cgeo.pref";
        final SharedPreferences prefsV0 = CgeoApplication.getInstance().getSharedPreferences(preferencesNameV0, Context.MODE_PRIVATE);
        if (currentVersion == 0 && prefsV0.getAll().isEmpty()) {
            final Editor e = sharedPrefs.edit();
            e.putInt(getKey(R.string.pref_settingsversion), LATEST_PREFERENCES_VERSION);
            e.apply();
            return;
        }

        if (currentVersion < 1) {
            // migrate from non standard file location and integer based boolean types
            final Editor e = sharedPrefs.edit();

            e.putString(getKey(R.string.pref_temp_twitter_token_secret), prefsV0.getString(getKey(R.string.pref_temp_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_temp_twitter_token_public), prefsV0.getString(getKey(R.string.pref_temp_twitter_token_public), null));
            e.putBoolean(getKey(R.string.pref_help_shown), prefsV0.getInt(getKey(R.string.pref_help_shown), 0) != 0);
            e.putFloat(getKey(R.string.pref_anylongitude), prefsV0.getFloat(getKey(R.string.pref_anylongitude), 0));
            e.putFloat(getKey(R.string.pref_anylatitude), prefsV0.getFloat(getKey(R.string.pref_anylatitude), 0));
            e.putBoolean(getKey(R.string.pref_offlinemaps), 0 != prefsV0.getInt(getKey(R.string.pref_offlinemaps), 1));
            e.putBoolean(getKey(R.string.pref_offlinewpmaps), 0 != prefsV0.getInt(getKey(R.string.pref_offlinewpmaps), 0));
            e.putString(getKey(R.string.pref_webDeviceCode), prefsV0.getString(getKey(R.string.pref_webDeviceCode), null));
            e.putString(getKey(R.string.pref_webDeviceName), prefsV0.getString(getKey(R.string.pref_webDeviceName), null));
            e.putBoolean(getKey(R.string.pref_maplive), prefsV0.getInt(getKey(R.string.pref_maplive), 1) != 0);
            e.putInt(getKey(R.string.pref_mapsource), prefsV0.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT));
            e.putBoolean(getKey(R.string.pref_twitter), 0 != prefsV0.getInt(getKey(R.string.pref_twitter), 0));
            e.putBoolean(getKey(R.string.pref_showaddress), 0 != prefsV0.getInt(getKey(R.string.pref_showaddress), 1));
            e.putBoolean(getKey(R.string.pref_showcaptcha), prefsV0.getBoolean(getKey(R.string.pref_showcaptcha), false));
            e.putBoolean(getKey(R.string.pref_maptrail), prefsV0.getInt(getKey(R.string.pref_maptrail), 1) != 0);
            e.putInt(getKey(R.string.pref_lastmapzoom), prefsV0.getInt(getKey(R.string.pref_lastmapzoom), 14));
            e.putBoolean(getKey(R.string.pref_livelist), 0 != prefsV0.getInt(getKey(R.string.pref_livelist), 1));
            e.putBoolean(getKey(R.string.pref_units_imperial), prefsV0.getInt(getKey(R.string.pref_units_imperial), 1) != 1);
            e.putBoolean(getKey(R.string.pref_skin), prefsV0.getInt(getKey(R.string.pref_skin), 0) != 0);
            e.putInt(getKey(R.string.pref_lastusedlist), prefsV0.getInt(getKey(R.string.pref_lastusedlist), StoredList.STANDARD_LIST_ID));
            e.putString(getKey(R.string.pref_cachetype), prefsV0.getString(getKey(R.string.pref_cachetype), CacheType.ALL.id));
            e.putString(getKey(R.string.pref_twitter_token_secret), prefsV0.getString(getKey(R.string.pref_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_twitter_token_public), prefsV0.getString(getKey(R.string.pref_twitter_token_public), null));
            e.putInt(getKey(R.string.pref_version), prefsV0.getInt(getKey(R.string.pref_version), 0));
            e.putBoolean(getKey(R.string.pref_autoloaddesc), 0 != prefsV0.getInt(getKey(R.string.pref_autoloaddesc), 1));
            e.putBoolean(getKey(R.string.pref_ratingwanted), prefsV0.getBoolean(getKey(R.string.pref_ratingwanted), true));
            e.putBoolean(getKey(R.string.pref_friendlogswanted), prefsV0.getBoolean(getKey(R.string.pref_friendlogswanted), true));
            e.putBoolean(getKey(R.string.pref_useenglish), prefsV0.getBoolean(getKey(R.string.pref_useenglish), false));
            e.putBoolean(getKey(R.string.pref_usecompass), 0 != prefsV0.getInt(getKey(R.string.pref_usecompass), 1));
            e.putBoolean(getKey(R.string.pref_trackautovisit), prefsV0.getBoolean(getKey(R.string.pref_trackautovisit), false));
            e.putBoolean(getKey(R.string.pref_sigautoinsert), prefsV0.getBoolean(getKey(R.string.pref_sigautoinsert), false));
            e.putBoolean(getKey(R.string.pref_logimages), prefsV0.getBoolean(getKey(R.string.pref_logimages), false));
            e.putBoolean(getKey(R.string.pref_excludedisabled), 0 != prefsV0.getInt(getKey(R.string.pref_excludedisabled), 0));
            e.putBoolean(getKey(R.string.pref_excludemine), 0 != prefsV0.getInt(getKey(R.string.pref_excludemine), 0));
            e.putString(getKey(R.string.pref_mapfile), prefsV0.getString(getKey(R.string.pref_mapfile), null));
            e.putString(getKey(R.string.pref_signature), prefsV0.getString(getKey(R.string.pref_signature), null));
            e.putString(getKey(R.string.pref_pass_vote), prefsV0.getString(getKey(R.string.pref_pass_vote), null));
            e.putString(getKey(R.string.pref_password), prefsV0.getString(getKey(R.string.pref_password), null));
            e.putString(getKey(R.string.pref_username), prefsV0.getString(getKey(R.string.pref_username), null));
            e.putString(getKey(R.string.pref_memberstatus), prefsV0.getString(getKey(R.string.pref_memberstatus), ""));
            e.putInt(getKey(R.string.pref_coordinputformat), prefsV0.getInt(getKey(R.string.pref_coordinputformat), CoordInputFormatEnum.DEFAULT_INT_VALUE));
            e.putBoolean(getKey(R.string.pref_log_offline), prefsV0.getBoolean(getKey(R.string.pref_log_offline), false));
            e.putBoolean(getKey(R.string.pref_choose_list), prefsV0.getBoolean(getKey(R.string.pref_choose_list), true));
            e.putBoolean(getKey(R.string.pref_loaddirectionimg), prefsV0.getBoolean(getKey(R.string.pref_loaddirectionimg), true));
            e.putString(getKey(R.string.pref_gccustomdate), prefsV0.getString(getKey(R.string.pref_gccustomdate), GCConstants.DEFAULT_GC_DATE));
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), prefsV0.getInt(getKey(R.string.pref_showwaypointsthreshold), SHOW_WP_THRESHOLD_DEFAULT));
            e.putString(getKey(R.string.pref_cookiestore), prefsV0.getString(getKey(R.string.pref_cookiestore), null));
            e.putBoolean(getKey(R.string.pref_opendetailslastpage), prefsV0.getBoolean(getKey(R.string.pref_opendetailslastpage), false));
            e.putInt(getKey(R.string.pref_lastdetailspage), prefsV0.getInt(getKey(R.string.pref_lastdetailspage), 1));
            e.putInt(getKey(R.string.pref_defaultNavigationTool), prefsV0.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id));
            e.putInt(getKey(R.string.pref_defaultNavigationTool2), prefsV0.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id));
            e.putInt(getKey(R.string.pref_livemapstrategy), prefsV0.getInt(getKey(R.string.pref_livemapstrategy), LivemapStrategy.AUTO.id));
            e.putBoolean(getKey(R.string.pref_debug), prefsV0.getBoolean(getKey(R.string.pref_debug), false));
            e.putInt(getKey(R.string.pref_livemaphintshowcount), prefsV0.getInt(getKey(R.string.pref_livemaphintshowcount), 0));

            e.putInt(getKey(R.string.pref_settingsversion), 1); // mark migrated
            e.apply();
        }

        // changes for new settings dialog
        if (currentVersion < 2) {
            final Editor e = sharedPrefs.edit();

            e.putBoolean(getKey(R.string.pref_units_imperial), useImperialUnits());

            // show waypoints threshold now as a slider
            int wpThreshold = getWayPointsThreshold();
            if (wpThreshold < 0) {
                wpThreshold = 0;
            } else if (wpThreshold > SHOW_WP_THRESHOLD_MAX) {
                wpThreshold = SHOW_WP_THRESHOLD_MAX;
            }
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), wpThreshold);

            // KEY_MAP_SOURCE must be string, because it is the key for a ListPreference now
            final int ms = sharedPrefs.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT);
            e.remove(getKey(R.string.pref_mapsource));
            e.putString(getKey(R.string.pref_mapsource), String.valueOf(ms));

            // navigation tool ids must be string, because ListPreference uses strings as keys
            final int dnt1 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id);
            final int dnt2 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id);
            e.remove(getKey(R.string.pref_defaultNavigationTool));
            e.remove(getKey(R.string.pref_defaultNavigationTool2));
            e.putString(getKey(R.string.pref_defaultNavigationTool), String.valueOf(dnt1));
            e.putString(getKey(R.string.pref_defaultNavigationTool2), String.valueOf(dnt2));

            // defaults for gpx directories
            e.putString(getKey(R.string.pref_gpxImportDir), getGpxImportDir());
            e.putString(getKey(R.string.pref_gpxExportDir), getGpxExportDir());

            e.putInt(getKey(R.string.pref_settingsversion), 2); // mark migrated
            e.apply();
        }
    }

    private static String getKey(final int prefKeyId) {
        return CgeoApplication.getInstance().getString(prefKeyId);
    }

    static String getString(final int prefKeyId, final String defaultValue) {
        return sharedPrefs.getString(getKey(prefKeyId), defaultValue);
    }

    private static int getInt(final int prefKeyId, final int defaultValue) {
        return sharedPrefs.getInt(getKey(prefKeyId), defaultValue);
    }

    private static long getLong(final int prefKeyId, final long defaultValue) {
        return sharedPrefs.getLong(getKey(prefKeyId), defaultValue);
    }

    private static boolean getBoolean(final int prefKeyId, final boolean defaultValue) {
        return sharedPrefs.getBoolean(getKey(prefKeyId), defaultValue);
    }

    private static float getFloat(final int prefKeyId, final float defaultValue) {
        return sharedPrefs.getFloat(getKey(prefKeyId), defaultValue);
    }

    protected static void putString(final int prefKeyId, final String value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putString(getKey(prefKeyId), value);
        edit.apply();
    }

    protected static void putBoolean(final int prefKeyId, final boolean value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putBoolean(getKey(prefKeyId), value);
        edit.apply();
    }

    private static void putInt(final int prefKeyId, final int value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putInt(getKey(prefKeyId), value);
        edit.apply();
    }

    private static void putLong(final int prefKeyId, final long value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putLong(getKey(prefKeyId), value);
        edit.apply();
    }

    private static void putFloat(final int prefKeyId, final float value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putFloat(getKey(prefKeyId), value);
        edit.apply();
    }

    private static void remove(final int prefKeyId) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.remove(getKey(prefKeyId));
        edit.apply();
    }

    private static boolean contains(final int prefKeyId) {
        return sharedPrefs.contains(getKey(prefKeyId));
    }

    public static boolean hasGCCredentials() {
        final String preUsername = getString(R.string.pref_username, null);
        final String prePassword = getString(R.string.pref_password, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    /**
     * Get login and password information of Geocaching.com.
     *
     * @return a pair either with (login, password) or (empty, empty) if no valid information is stored
     */
    public static ImmutablePair<String, String> getGcCredentials() {
        return getCredentials(GCConnector.getInstance());
    }

    /**
     * Get login and password information.
     *
     * @return a pair either with (login, password) or (empty, empty) if no valid information is stored
     */
    public static ImmutablePair<String, String> getCredentials(final @NonNull ICredentials connector) {
        final String username = getString(connector.getUsernamePreferenceKey(), null);
        final String password = getString(connector.getPasswordPreferenceKey(), null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return new ImmutablePair<>(StringUtils.EMPTY, StringUtils.EMPTY);
        }

        return new ImmutablePair<>(username, password);
    }

    public static String getUsername() {
        return getString(R.string.pref_username, StringUtils.EMPTY);
    }

    public static boolean isGCConnectorActive() {
        return getBoolean(R.string.pref_connectorGCActive, true);
    }

    public static boolean isECConnectorActive() {
        return getBoolean(R.string.pref_connectorECActive, false);
    }

    public static boolean isOXConnectorActive() {
        return getBoolean(R.string.pref_connectorOXActive, false);
    }

    public static boolean isGCPremiumMember() {
        final String memberStatus = getGCMemberStatus();
        return StringUtils.equalsIgnoreCase(memberStatus, GCConstants.MEMBER_STATUS_PREMIUM) ||
                StringUtils.equalsIgnoreCase(memberStatus, GCConstants.MEMBER_STATUS_CHARTER);
    }

    public static String getGCMemberStatus() {
        return getString(R.string.pref_memberstatus, "");
    }

    public static void setGCMemberStatus(final String memberStatus) {
        if (StringUtils.isBlank(memberStatus)) {
            remove(R.string.pref_memberstatus);
        }
        putString(R.string.pref_memberstatus, memberStatus);
    }

    public static ImmutablePair<String, String> getTokenPair(final int tokenPublicPrefKey, final int tokenSecretPrefKey) {
        return new ImmutablePair<>(getString(tokenPublicPrefKey, null), getString(tokenSecretPrefKey, null));
    }

    public static void setTokens(final int tokenPublicPrefKey, @Nullable final String tokenPublic, final int tokenSecretPrefKey, @Nullable final String tokenSecret) {
        if (tokenPublic == null) {
            remove(tokenPublicPrefKey);
        } else {
            putString(tokenPublicPrefKey, tokenPublic);
        }
        if (tokenSecret == null) {
            remove(tokenSecretPrefKey);
        } else {
            putString(tokenSecretPrefKey, tokenSecret);
        }
    }

    public static boolean isOCConnectorActive(final int isActivePrefKeyId) {
        return getBoolean(isActivePrefKeyId, false);
    }

    public static boolean hasOCAuthorization(final int tokenPublicPrefKeyId, final int tokenSecretPrefKeyId) {
        return StringUtils.isNotBlank(getString(tokenPublicPrefKeyId, ""))
                && StringUtils.isNotBlank(getString(tokenSecretPrefKeyId, ""));
    }

    public static boolean isGCVoteLogin() {
        return getGCVoteLogin() != null;
    }

    public static ImmutablePair<String, String> getGCVoteLogin() {
        final String username = getString(R.string.pref_username, null);
        final String password = getString(R.string.pref_pass_vote, null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return null;
        }

        return new ImmutablePair<>(username, password);
    }

    public static String getSignature() {
        return getString(R.string.pref_signature, StringUtils.EMPTY);
    }

    public static void setCookieStore(final String cookies) {
        if (StringUtils.isBlank(cookies)) {
            // erase cookies
            remove(R.string.pref_cookiestore);
        }
        // save cookies
        putString(R.string.pref_cookiestore, cookies);
    }

    public static String getCookieStore() {
        return getString(R.string.pref_cookiestore, null);
    }

    public static void setUseGooglePlayServices(final boolean value) {
        putBoolean(R.string.pref_googleplayservices, value);
    }

    public static boolean useGooglePlayServices() {
        // By defaut, enable play services starting from ICS.
        return CgeoApplication.getInstance().isGooglePlayServicesAvailable() &&
                getBoolean(R.string.pref_googleplayservices, VERSION.SDK_INT >= VERSION_CODES.ICE_CREAM_SANDWICH);
    }

    public static boolean useLowPowerMode() {
        return getBoolean(R.string.pref_lowpowermode, false);
    }

    /**
     * @param cacheType
     *            The cache type used for future filtering
     */
    public static void setCacheType(final CacheType cacheType) {
        if (cacheType == null) {
            remove(R.string.pref_cachetype);
        } else {
            putString(R.string.pref_cachetype, cacheType.id);
        }
    }

    public static int getLastList() {
        return getInt(R.string.pref_lastusedlist, StoredList.STANDARD_LIST_ID);
    }

    public static void saveLastList(final int listId) {
        putInt(R.string.pref_lastusedlist, listId);
    }

    public static void setWebNameCode(final String name, final String code) {
        putString(R.string.pref_webDeviceName, name);
        putString(R.string.pref_webDeviceCode, code);
    }

    public static MapProvider getMapProvider() {
        return getMapSource().getMapProvider();
    }

    public static String getMapFile() {
        return getString(R.string.pref_mapfile, null);
    }

    static void setMapFile(final String mapFile) {
        putString(R.string.pref_mapfile, mapFile);
        if (mapFile != null) {
            setMapFileDirectory(new File(mapFile).getParent());
        }
    }

    public static String getMapFileDirectory() {
        final String mapDir = getString(R.string.pref_mapDirectory, null);
        if (mapDir != null) {
            return mapDir;
        }
        final String mapFile = getMapFile();
        if (mapFile != null) {
            return new File(mapFile).getParent();
        }
        return null;
    }

    static void setMapFileDirectory(final String mapFileDirectory) {
        putString(R.string.pref_mapDirectory, mapFileDirectory);
        MapsforgeMapProvider.getInstance().updateOfflineMaps();
    }

    private static boolean isValidMapFile() {
        return isValidMapFile(getMapFile());
    }

    public static boolean isValidMapFile(final String mapFileIn) {
        return MapsforgeMapProvider.isValidMapFile(mapFileIn);
    }

    public static boolean isScaleMapsforgeText() {
        return getBoolean(R.string.pref_mapsforge_scale_text, true);
    }

    public static CoordInputFormatEnum getCoordInputFormat() {
        return CoordInputFormatEnum.fromInt(getInt(R.string.pref_coordinputformat, CoordInputFormatEnum.DEFAULT_INT_VALUE));
    }

    public static void setCoordInputFormat(final CoordInputFormatEnum format) {
        putInt(R.string.pref_coordinputformat, format.ordinal());
    }

    public static boolean getLogOffline() {
        return getBoolean(R.string.pref_log_offline, false);
    }

    public static boolean getChooseList() {
        return getBoolean(R.string.pref_choose_list, false);
    }

    public static boolean getLoadDirImg() {
        return !isGCPremiumMember() && getBoolean(R.string.pref_loaddirectionimg, true);
    }

    public static void setGcCustomDate(final String format) {
        putString(R.string.pref_gccustomdate, format);
    }

    /**
     * @return User selected date format on GC.com
     */
    public static String getGcCustomDate() {
        // We might have some users whose stored value is null, which is invalid. In this case, we use the default.
        return StringUtils.defaultString(getString(R.string.pref_gccustomdate, GCConstants.DEFAULT_GC_DATE),
                GCConstants.DEFAULT_GC_DATE);
    }

    public static boolean isExcludeMyCaches() {
        return getBoolean(R.string.pref_excludemine, false);
    }

    public static boolean useEnglish() {
        return getBoolean(R.string.pref_useenglish, false);
    }

    public static boolean isShowAddress() {
        return getBoolean(R.string.pref_showaddress, true);
    }

    public static boolean isShowCaptcha() {
        return !isGCPremiumMember() && getBoolean(R.string.pref_showcaptcha, false);
    }

    public static boolean isExcludeDisabledCaches() {
        return getBoolean(R.string.pref_excludedisabled, false);
    }

    public static boolean isStoreOfflineMaps() {
        return getBoolean(R.string.pref_offlinemaps, true);
    }

    public static boolean isStoreOfflineWpMaps() {
        return getBoolean(R.string.pref_offlinewpmaps, false);
    }

    public static boolean isStoreLogImages() {
        return getBoolean(R.string.pref_logimages, false);
    }

    public static boolean isAutoLoadDescription() {
        return getBoolean(R.string.pref_autoloaddesc, true);
    }

    public static boolean isRatingWanted() {
        return getBoolean(R.string.pref_ratingwanted, true);
    }

    public static boolean isGeokretyConnectorActive() {
        return getBoolean(R.string.pref_connectorGeokretyActive, false);
    }

    public static boolean isGeokretyCacheActive() {
        return getBoolean(R.string.pref_geokrety_cache, true);
    }

    static boolean hasGeokretyAuthorization() {
        return StringUtils.isNotBlank(getGeokretySecId());
    }

    public static String getGeokretySecId() {
        return getString(R.string.pref_fakekey_geokrety_authorization, null);
    }

    public static void setGeokretySecId(final String secid) {
        putString(R.string.pref_fakekey_geokrety_authorization, secid);
    }

    public static boolean isRegisteredForGeokretyLogging() {
        return getGeokretySecId() != null;
    }

    /**
     * Retrieve showed popup counter for warning about logging Trackable recommend Geocode
     *
     * @return number of times the popup has appeared
     */
    public static int getLogTrackableWithoutGeocodeShowCount() {
        return getInt(R.string.pref_logtrackablewithoutgeocodeshowcount, 0);
    }

    /**
     * Store showed popup counter for warning about logging Trackable recommend Geocode
     *
     * @param showCount the count to save
     */
    public static void setLogTrackableWithoutGeocodeShowCount(final int showCount) {
        putInt(R.string.pref_logtrackablewithoutgeocodeshowcount, showCount);
    }

    public static boolean isFriendLogsWanted() {
        if (!hasGCCredentials()) {
            // don't show a friends log if the user is anonymous
            return false;
        }
        return getBoolean(R.string.pref_friendlogswanted, true);
    }

    public static boolean isLiveList() {
        return getBoolean(R.string.pref_livelist, true);
    }

    public static boolean isTrackableAutoVisit() {
        return getBoolean(R.string.pref_trackautovisit, false);
    }

    public static boolean isAutoInsertSignature() {
        return getBoolean(R.string.pref_sigautoinsert, false);
    }

    static void setUseImperialUnits(final boolean useImperialUnits) {
        putBoolean(R.string.pref_units_imperial, useImperialUnits);
    }

    public static boolean useImperialUnits() {
        return getBoolean(R.string.pref_units_imperial, useImperialUnitsByDefault());
    }

    private static boolean useImperialUnitsByDefault() {
        final String countryCode = Locale.getDefault().getCountry();
        return "US".equals(countryCode)  // USA
            || "LR".equals(countryCode)  // Liberia
            || "MM".equals(countryCode); // Burma
    }

    public static boolean isLiveMap() {
        return getBoolean(R.string.pref_maplive, true);
    }

    public static void setLiveMap(final boolean live) {
        putBoolean(R.string.pref_maplive, live);
    }

    public static boolean isMapTrail() {
        return getBoolean(R.string.pref_maptrail, false);
    }

    public static void setMapTrail(final boolean showTrail) {
        putBoolean(R.string.pref_maptrail, showTrail);
    }

    /**
     * whether to show a direction line on the map
     */
    public static boolean isMapDirection() {
        return getBoolean(R.string.pref_map_direction, true);
    }

    public static void setMapDirection(final boolean showDirection) {
        putBoolean(R.string.pref_map_direction, showDirection);
    }

    /**
     * Get last used zoom of the internal map. Differentiate between two use cases for a map of multiple caches (e.g.
     * live map) and the map of a single cache (which is often zoomed in more deep).
     */
    public static int getMapZoom(final MapMode mapMode) {
        if (mapMode == MapMode.SINGLE || mapMode == MapMode.COORDS) {
            return getCacheZoom();
        }
        return getMapZoom();
    }

    public static void setMapZoom(final MapMode mapMode, final int zoomLevel) {
        if (mapMode == MapMode.SINGLE || mapMode == MapMode.COORDS) {
            setCacheZoom(zoomLevel);
        }
        else {
            setMapZoom(zoomLevel);
        }
    }

    /**
     * @return zoom used for the (live) map
     */
    private static int getMapZoom() {
        return Math.max(getInt(R.string.pref_lastmapzoom, 14), INITIAL_MAP_ZOOM_LIMIT);
    }

    private static void setMapZoom(final int mapZoomLevel) {
        putInt(R.string.pref_lastmapzoom, mapZoomLevel);
    }

    /**
     * @return zoom used for the map of a single cache
     */
    private static int getCacheZoom() {
        return Math.max(getInt(R.string.pref_cache_zoom, 14), INITIAL_MAP_ZOOM_LIMIT);
    }

    private static void setCacheZoom(final int zoomLevel) {
        putInt(R.string.pref_cache_zoom, zoomLevel);
    }

    public static GeoPointImpl getMapCenter() {
        return getMapProvider().getMapItemFactory()
                .getGeoPointBase(new Geopoint(getInt(R.string.pref_lastmaplat, 0) / 1e6,
                        getInt(R.string.pref_lastmaplon, 0) / 1e6));
    }

    public static void setMapCenter(final GeoPointImpl mapViewCenter) {
        putInt(R.string.pref_lastmaplat, mapViewCenter.getLatitudeE6());
        putInt(R.string.pref_lastmaplon, mapViewCenter.getLongitudeE6());
    }

    @NonNull
    public static synchronized MapSource getMapSource() {
        if (mapSource != null) {
            return mapSource;
        }
        final int id = getConvertedMapId();
        mapSource = MapProviderFactory.getMapSource(id);
        if (mapSource != null) {
            // don't use offline maps if the map file is not valid
            if (!(mapSource instanceof OfflineMapSource) || isValidMapFile()) {
                return mapSource;
            }
        }
        // fallback to first available map
        return MapProviderFactory.getDefaultSource();
    }

    private final static int GOOGLEMAP_BASEID = 30;
    private final static int MAP = 1;
    private final static int SATELLITE = 2;

    private final static int MFMAP_BASEID = 40;
    private final static int MAPNIK = 1;
    private final static int CYCLEMAP = 3;
    private final static int OFFLINE = 4;
    private static final int HISTORY_SIZE = 10;

    /**
     * Convert old preference ids for maps (based on constant values) into new hash based ids.
     */
    private static int getConvertedMapId() {
        final int id = Integer.parseInt(getString(R.string.pref_mapsource,
                String.valueOf(MAP_SOURCE_DEFAULT)));
        switch (id) {
            case GOOGLEMAP_BASEID + MAP:
                return GoogleMapProvider.GOOGLE_MAP_ID.hashCode();
            case GOOGLEMAP_BASEID + SATELLITE:
                return GoogleMapProvider.GOOGLE_SATELLITE_ID.hashCode();
            case MFMAP_BASEID + MAPNIK:
                return MapsforgeMapProvider.MAPSFORGE_MAPNIK_ID.hashCode();
            case MFMAP_BASEID + CYCLEMAP:
                return MapsforgeMapProvider.MAPSFORGE_CYCLEMAP_ID.hashCode();
            case MFMAP_BASEID + OFFLINE: {
                final String mapFile = getMapFile();
                if (StringUtils.isNotEmpty(mapFile)) {
                    return mapFile.hashCode();
                }
                break;
            }
            default:
                break;
        }
        return id;
    }

    public static synchronized void setMapSource(final MapSource newMapSource) {
        putString(R.string.pref_mapsource, String.valueOf(newMapSource.getNumericalId()));
        if (newMapSource instanceof OfflineMapSource) {
            setMapFile(((OfflineMapSource) newMapSource).getFileName());
        }
        // cache the value
        mapSource = newMapSource;
    }

    public static void setAnyCoordinates(final Geopoint coords) {
        if (null != coords) {
            putFloat(R.string.pref_anylatitude, (float) coords.getLatitude());
            putFloat(R.string.pref_anylongitude, (float) coords.getLongitude());
        } else {
            remove(R.string.pref_anylatitude);
            remove(R.string.pref_anylongitude);
        }
    }

    public static Geopoint getAnyCoordinates() {
        if (contains(R.string.pref_anylatitude) && contains(R.string.pref_anylongitude)) {
            final float lat = getFloat(R.string.pref_anylatitude, 0);
            final float lon = getFloat(R.string.pref_anylongitude, 0);
            return new Geopoint(lat, lon);
        }
        return null;
    }

    public static boolean isUseCompass() {
        return useCompass;
    }

    public static void setUseCompass(final boolean value) {
        useCompass = value;
    }

    public static boolean isLightSkin() {
        return getBoolean(R.string.pref_skin, false);
    }

    @NonNull
    public static String getTwitterKeyConsumerPublic() {
        return TWITTER_KEY_CONSUMER_PUBLIC;
    }

    @NonNull
    public static String getTwitterKeyConsumerSecret() {
        return TWITTER_KEY_CONSUMER_SECRET;
    }

    public static String getWebDeviceCode() {
        return getString(R.string.pref_webDeviceCode, null);
    }

    public static boolean isRegisteredForSend2cgeo() {
        return getWebDeviceCode() != null;
    }

    static String getWebDeviceName() {
        return getString(R.string.pref_webDeviceName, Build.MODEL);
    }

    /**
     * @return The cache type used for filtering or ALL if no filter is active.
     *         Returns never null
     */
    @NonNull
    public static CacheType getCacheType() {
        return CacheType.getById(getString(R.string.pref_cachetype, CacheType.ALL.id));
    }

    /**
     * The Threshold for the showing of child waypoints
     */
    public static int getWayPointsThreshold() {
        return getInt(R.string.pref_showwaypointsthreshold, SHOW_WP_THRESHOLD_DEFAULT);
    }

    static void setShowWaypointsThreshold(final int threshold) {
        putInt(R.string.pref_showwaypointsthreshold, threshold);
    }

    public static boolean isUseTwitter() {
        return getBoolean(R.string.pref_twitter, false);
    }

    private static void setUseTwitter(final boolean useTwitter) {
        putBoolean(R.string.pref_twitter, useTwitter);
    }

    public static boolean isTwitterLoginValid() {
        return !StringUtils.isBlank(getTokenPublic())
                && !StringUtils.isBlank(getTokenSecret());
    }

    public static String getTokenPublic() {
        return getString(R.string.pref_twitter_token_public, null);
    }

    public static String getTokenSecret() {
        return getString(R.string.pref_twitter_token_secret, null);

    }

    static boolean hasTwitterAuthorization() {
        return StringUtils.isNotBlank(getTokenPublic())
                && StringUtils.isNotBlank(getTokenSecret());
    }

    public static void setTwitterTokens(@Nullable final String tokenPublic,
            @Nullable final String tokenSecret, final boolean enableTwitter) {
        putString(R.string.pref_twitter_token_public, tokenPublic);
        putString(R.string.pref_twitter_token_secret, tokenSecret);
        if (tokenPublic != null) {
            remove(R.string.pref_temp_twitter_token_public);
            remove(R.string.pref_temp_twitter_token_secret);
        }
        setUseTwitter(enableTwitter);
    }

    public static void setTwitterTempTokens(@Nullable final String tokenPublic,
            @Nullable final String tokenSecret) {
        putString(R.string.pref_temp_twitter_token_public, tokenPublic);
        putString(R.string.pref_temp_twitter_token_secret, tokenSecret);
    }

    public static ImmutablePair<String, String> getTempToken() {
        final String tokenPublic = getString(R.string.pref_temp_twitter_token_public, null);
        final String tokenSecret = getString(R.string.pref_temp_twitter_token_secret, null);
        return new ImmutablePair<>(tokenPublic, tokenSecret);
    }

    public static int getVersion() {
        return getInt(R.string.pref_version, 0);
    }

    public static void setVersion(final int version) {
        putInt(R.string.pref_version, version);
    }

    public static boolean isOpenLastDetailsPage() {
        return getBoolean(R.string.pref_opendetailslastpage, false);
    }

    public static int getLastDetailsPage() {
        return getInt(R.string.pref_lastdetailspage, 1);
    }

    public static void setLastDetailsPage(final int index) {
        putInt(R.string.pref_lastdetailspage, index);
    }

    public static int getDefaultNavigationTool() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool,
                String.valueOf(NavigationAppsEnum.COMPASS.id)));
    }

    public static int getDefaultNavigationTool2() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool2,
                String.valueOf(NavigationAppsEnum.INTERNAL_MAP.id)));
    }

    public static LivemapStrategy getLiveMapStrategy() {
        return LivemapStrategy.getById(getInt(R.string.pref_livemapstrategy, LivemapStrategy.AUTO.id));
    }

    public static void setLiveMapStrategy(final LivemapStrategy strategy) {
        putInt(R.string.pref_livemapstrategy, strategy.id);
    }

    public static boolean isDebug() {
        return Log.isDebug();
    }

    public static int getLiveMapHintShowCount() {
        return getInt(R.string.pref_livemaphintshowcount, 0);
    }

    public static void setLiveMapHintShowCount(final int showCount) {
        putInt(R.string.pref_livemaphintshowcount, showCount);
    }

    public static boolean isDbOnSDCard() {
        return getBoolean(R.string.pref_dbonsdcard, false);
    }

    public static void setDbOnSDCard(final boolean dbOnSDCard) {
        putBoolean(R.string.pref_dbonsdcard, dbOnSDCard);
    }

    public static String getGpxExportDir() {
        return getString(R.string.pref_gpxExportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static String getGpxImportDir() {
        return getString(R.string.pref_gpxImportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static boolean getShareAfterExport() {
        return getBoolean(R.string.pref_shareafterexport, true);
    }

    public static void setShareAfterExport(final boolean shareAfterExport) {
        putBoolean(R.string.pref_shareafterexport, shareAfterExport);
    }

    public static int getTrackableAction() {
        return getInt(R.string.pref_trackableaction, LogTypeTrackable.RETRIEVED_IT.id);
    }

    public static void setTrackableAction(final int trackableAction) {
        putInt(R.string.pref_trackableaction, trackableAction);
    }

    private static String getCustomRenderThemeBaseFolder() {
        return getString(R.string.pref_renderthemepath, "");
    }

    public static String getCustomRenderThemeFilePath() {
        return getString(R.string.pref_renderthemefile, "");
    }

    public static void setCustomRenderThemeFile(final String customRenderThemeFile) {
        putString(R.string.pref_renderthemefile, customRenderThemeFile);
    }

    public static File[] getMapThemeFiles() {
        final File directory = new File(getCustomRenderThemeBaseFolder());
        final List<File> result = new ArrayList<>();
        FileUtils.listDir(result, directory, new ExtensionsBasedFileSelector(new String[] { "xml" }), null);

        return result.toArray(new File[result.size()]);
    }

    private static class ExtensionsBasedFileSelector implements FileSelector {
        private final String[] extensions;
        public ExtensionsBasedFileSelector(final String[] extensions) {
            this.extensions = extensions;
        }
        @Override
        public boolean isSelected(final File file) {
            final String filename = file.getName();
            for (final String ext : extensions) {
                if (StringUtils.endsWithIgnoreCase(filename, ext)) {
                    return true;
                }
            }
            return false;
        }
        @Override
        public boolean shouldEnd() {
            return false;
        }
    }

    /**
     * @return true if plain text log wanted
     */
    public static boolean getPlainLogs() {
        return getBoolean(R.string.pref_plainLogs, false);
    }

    /**
     * Force set the plain text log preference
     *
     * @param plainLogs
     *            wanted or not
     */
    public static void setPlainLogs(final boolean plainLogs) {
        putBoolean(R.string.pref_plainLogs, plainLogs);
    }

    public static boolean getUseNativeUa() {
        return getBoolean(R.string.pref_nativeUa, false);
    }

    public static String getCacheTwitterMessage() {
        return getString(R.string.pref_twitter_cache_message, "I found [NAME] ([URL]).");
    }

    public static String getTrackableTwitterMessage() {
        return getString(R.string.pref_twitter_trackable_message, "I touched [NAME] ([URL]).");
    }

    public static int getLogImageScale() {
        return getInt(R.string.pref_logImageScale, -1);
    }

    public static void setLogImageScale(final int scale) {
        putInt(R.string.pref_logImageScale, scale);
    }

    public static void setExcludeMine(final boolean exclude) {
        putBoolean(R.string.pref_excludemine, exclude);
    }

    static void setLogin(final String username, final String password) {
        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            // erase username and password
            remove(R.string.pref_username);
            remove(R.string.pref_password);
            return;
        }
        // save username and password
        putString(R.string.pref_username, username);
        putString(R.string.pref_password, password);
    }

    public static long getFieldnoteExportDate() {
        return getLong(R.string.pref_fieldNoteExportDate, 0);
    }

    /**
     * Remember date of last field note export.
     */
    public static void setFieldnoteExportDate(final long date) {
        putLong(R.string.pref_fieldNoteExportDate, date);
    }

    public static boolean isUseNavigationApp(final NavigationAppsEnum navApp) {
        return getBoolean(navApp.preferenceKey, true);
    }

    /**
     * Remember the state of the "Upload" checkbox in the field notes export dialog.
     */
    public static void setFieldNoteExportUpload(final boolean upload) {
        putBoolean(R.string.pref_fieldNoteExportUpload, upload);
    }

    public static boolean getFieldNoteExportUpload() {
        return getBoolean(R.string.pref_fieldNoteExportUpload, true);
    }

    /**
     * Remember the state of the "Only new" checkbox in the field notes export dialog.
     */
    public static void setFieldNoteExportOnlyNew(final boolean onlyNew) {
        putBoolean(R.string.pref_fieldNoteExportOnlyNew, onlyNew);
    }

    public static boolean getFieldNoteExportOnlyNew() {
        return getBoolean(R.string.pref_fieldNoteExportOnlyNew, false);
    }

    public static String getECIconSet() {
        return getString(R.string.pref_ec_icons, "1");
    }

    /* Store last checksum of changelog for changelog display */
    public static long getLastChangelogChecksum() {
        return getLong(R.string.pref_changelog_last_checksum, 0);
    }

    public static void setLastChangelogChecksum(final long checksum) {
        putLong(R.string.pref_changelog_last_checksum, checksum);
    }

    public static List<String> getLastOpenedCaches() {
        final List<String> history = Arrays.asList(StringUtils.split(getString(R.string.pref_caches_history, StringUtils.EMPTY), HISTORY_SEPARATOR));
        return history.subList(0, Math.min(HISTORY_SIZE, history.size()));
    }

    public static void addCacheToHistory(@NonNull final String geocode) {
        final List<String> history = new ArrayList<>(getLastOpenedCaches());
        // bring entry to front, if it already existed
        history.remove(geocode);
        history.add(0, geocode);
        putString(R.string.pref_caches_history, StringUtils.join(history, HISTORY_SEPARATOR));
    }

    public static boolean useHardwareAcceleration() {
        return getBoolean(R.string.pref_hardware_acceleration, !HW_ACCEL_DISABLED_BY_DEFAULT);
    }

    static void setUseHardwareAcceleration(final boolean useHardwareAcceleration) {
        putBoolean(R.string.pref_hardware_acceleration, useHardwareAcceleration);
    }

    public static String getLastCacheLog() {
        return getString(R.string.pref_last_cache_log, StringUtils.EMPTY);
    }

    public static void setLastCacheLog(final String log) {
        putString(R.string.pref_last_cache_log, log);
    }

    public static String getLastTrackableLog() {
        return getString(R.string.pref_last_trackable_log, StringUtils.EMPTY);
    }

    public static void setLastTrackableLog(final String log) {
        putString(R.string.pref_last_trackable_log, log);
    }

    @Nullable
    public static String getHomeLocation() {
        return getString(R.string.pref_home_location, null);
    }

    public static void setHomeLocation(@NonNull final String homeLocation) {
        putString(R.string.pref_home_location, homeLocation);
    }
}
!@#$%
20190527_010908,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_a21452
package cgeo.geocaching.settings;

import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.R;
import cgeo.geocaching.apps.cache.navi.NavigationAppFactory.NavigationAppsEnum;
import cgeo.geocaching.connector.capability.ICredentials;
import cgeo.geocaching.connector.gc.GCConnector;
import cgeo.geocaching.connector.gc.GCConstants;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.LogTypeTrackable;
import cgeo.geocaching.list.StoredList;
import cgeo.geocaching.location.Geopoint;
import cgeo.geocaching.maps.CGeoMap.MapMode;
import cgeo.geocaching.maps.LivemapStrategy;
import cgeo.geocaching.maps.MapProviderFactory;
import cgeo.geocaching.maps.google.v1.GoogleMapProvider;
import cgeo.geocaching.maps.interfaces.GeoPointImpl;
import cgeo.geocaching.maps.interfaces.MapProvider;
import cgeo.geocaching.maps.interfaces.MapSource;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider.OfflineMapSource;
import cgeo.geocaching.utils.CryptUtils;
import cgeo.geocaching.utils.FileUtils;
import cgeo.geocaching.utils.FileUtils.FileSelector;
import cgeo.geocaching.utils.Log;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.os.Build;
import android.os.Build.VERSION;
import android.os.Build.VERSION_CODES;
import android.os.Environment;
import android.preference.PreferenceManager;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;

/**
 * General c:geo preferences/settings set by the user
 */
public class Settings {

    /**
     * On opening a map, we limit the _initial_ zoom. The user can still zoom out afterwards.
     */
    private static final int INITIAL_MAP_ZOOM_LIMIT = 16;
    private static final char HISTORY_SEPARATOR = ',';
    private static final int SHOW_WP_THRESHOLD_DEFAULT = 10;
    public static final int SHOW_WP_THRESHOLD_MAX = 50;
    private static final int MAP_SOURCE_DEFAULT = GoogleMapProvider.GOOGLE_MAP_ID.hashCode();

    public static final boolean HW_ACCEL_DISABLED_BY_DEFAULT =
            Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1 ||
            StringUtils.equals(Build.MODEL, "HTC One X") ||    // HTC One X
            StringUtils.equals(Build.MODEL, "HTC One S") ||    // HTC One S
            StringUtils.equals(Build.MODEL, "GT-I8190")  ||    // Samsung S3 mini
            StringUtils.equals(Build.MODEL, "GT-S6310L") ||    // Samsung Galaxy Young
            StringUtils.equals(Build.MODEL, "GT-P5210")  ||    // Samsung Galaxy Tab 3
            StringUtils.equals(Build.MODEL, "GT-S7580")  ||    // Samsung Galaxy Trend Plus
            StringUtils.equals(Build.MODEL, "GT-I9105P") ||    // Samsung Galaxy SII Plus
            StringUtils.equals(Build.MODEL, "ST25i")     ||    // Sony Xperia U
            StringUtils.equals(Build.MODEL, "bq Aquaris 5") || // bq Aquaris 5
            StringUtils.equals(Build.MODEL, "A1-810")    ||    // Unknown A1-810
            StringUtils.equals(Build.MODEL, "GT-I9195")  ||    // Samsung S4 mini
            StringUtils.equals(Build.MODEL, "GT-I8200N");      // Samsung S3 mini

    // twitter api keys
    private final static @NonNull String TWITTER_KEY_CONSUMER_PUBLIC = CryptUtils.rot13("ESnsCvAv3kEupF1GCR3jGj");
    private final static @NonNull String TWITTER_KEY_CONSUMER_SECRET = CryptUtils.rot13("7vQWceACV9umEjJucmlpFe9FCMZSeqIqfkQ2BnhV9x");

    private static boolean useCompass = true;

    public enum CoordInputFormatEnum {
        Plain,
        Deg,
        Min,
        Sec;

        static final int DEFAULT_INT_VALUE = Min.ordinal();

        public static CoordInputFormatEnum fromInt(final int id) {
            final CoordInputFormatEnum[] values = CoordInputFormatEnum.values();
            if (id < 0 || id >= values.length) {
                return Min;
            }
            return values[id];
        }
    }

    private static final SharedPreferences sharedPrefs = PreferenceManager
            .getDefaultSharedPreferences(CgeoApplication.getInstance().getBaseContext());
    static {
        migrateSettings();
        final boolean isDebug = sharedPrefs.getBoolean(getKey(R.string.pref_debug), false);
        Log.setDebug(isDebug);
        CgeoApplication.dumpOnOutOfMemory(isDebug);
    }

    /**
     * Cache the mapsource locally. If that is an offline map source, each request would potentially access the
     * underlying map file, leading to delays.
     */
    private static MapSource mapSource;

    protected Settings() {
        throw new InstantiationError();
    }

    private static void migrateSettings() {
        final int LATEST_PREFERENCES_VERSION = 2;
        final int currentVersion = getInt(R.string.pref_settingsversion, 0);

        // No need to migrate if we are up to date.
        if (currentVersion == LATEST_PREFERENCES_VERSION) {
            return;
        }

        // No need to migrate if we don't have older settings, defaults will be used instead.
        final String preferencesNameV0 = "cgeo.pref";
        final SharedPreferences prefsV0 = CgeoApplication.getInstance().getSharedPreferences(preferencesNameV0, Context.MODE_PRIVATE);
        if (currentVersion == 0 && prefsV0.getAll().isEmpty()) {
            final Editor e = sharedPrefs.edit();
            e.putInt(getKey(R.string.pref_settingsversion), LATEST_PREFERENCES_VERSION);
            e.apply();
            return;
        }

        if (currentVersion < 1) {
            // migrate from non standard file location and integer based boolean types
            final Editor e = sharedPrefs.edit();

            e.putString(getKey(R.string.pref_temp_twitter_token_secret), prefsV0.getString(getKey(R.string.pref_temp_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_temp_twitter_token_public), prefsV0.getString(getKey(R.string.pref_temp_twitter_token_public), null));
            e.putBoolean(getKey(R.string.pref_help_shown), prefsV0.getInt(getKey(R.string.pref_help_shown), 0) != 0);
            e.putFloat(getKey(R.string.pref_anylongitude), prefsV0.getFloat(getKey(R.string.pref_anylongitude), 0));
            e.putFloat(getKey(R.string.pref_anylatitude), prefsV0.getFloat(getKey(R.string.pref_anylatitude), 0));
            e.putBoolean(getKey(R.string.pref_offlinemaps), 0 != prefsV0.getInt(getKey(R.string.pref_offlinemaps), 1));
            e.putBoolean(getKey(R.string.pref_offlinewpmaps), 0 != prefsV0.getInt(getKey(R.string.pref_offlinewpmaps), 0));
            e.putString(getKey(R.string.pref_webDeviceCode), prefsV0.getString(getKey(R.string.pref_webDeviceCode), null));
            e.putString(getKey(R.string.pref_webDeviceName), prefsV0.getString(getKey(R.string.pref_webDeviceName), null));
            e.putBoolean(getKey(R.string.pref_maplive), prefsV0.getInt(getKey(R.string.pref_maplive), 1) != 0);
            e.putInt(getKey(R.string.pref_mapsource), prefsV0.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT));
            e.putBoolean(getKey(R.string.pref_twitter), 0 != prefsV0.getInt(getKey(R.string.pref_twitter), 0));
            e.putBoolean(getKey(R.string.pref_showaddress), 0 != prefsV0.getInt(getKey(R.string.pref_showaddress), 1));
            e.putBoolean(getKey(R.string.pref_showcaptcha), prefsV0.getBoolean(getKey(R.string.pref_showcaptcha), false));
            e.putBoolean(getKey(R.string.pref_maptrail), prefsV0.getInt(getKey(R.string.pref_maptrail), 1) != 0);
            e.putInt(getKey(R.string.pref_lastmapzoom), prefsV0.getInt(getKey(R.string.pref_lastmapzoom), 14));
            e.putBoolean(getKey(R.string.pref_livelist), 0 != prefsV0.getInt(getKey(R.string.pref_livelist), 1));
            e.putBoolean(getKey(R.string.pref_units_imperial), prefsV0.getInt(getKey(R.string.pref_units_imperial), 1) != 1);
            e.putBoolean(getKey(R.string.pref_skin), prefsV0.getInt(getKey(R.string.pref_skin), 0) != 0);
            e.putInt(getKey(R.string.pref_lastusedlist), prefsV0.getInt(getKey(R.string.pref_lastusedlist), StoredList.STANDARD_LIST_ID));
            e.putString(getKey(R.string.pref_cachetype), prefsV0.getString(getKey(R.string.pref_cachetype), CacheType.ALL.id));
            e.putString(getKey(R.string.pref_twitter_token_secret), prefsV0.getString(getKey(R.string.pref_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_twitter_token_public), prefsV0.getString(getKey(R.string.pref_twitter_token_public), null));
            e.putInt(getKey(R.string.pref_version), prefsV0.getInt(getKey(R.string.pref_version), 0));
            e.putBoolean(getKey(R.string.pref_autoloaddesc), 0 != prefsV0.getInt(getKey(R.string.pref_autoloaddesc), 1));
            e.putBoolean(getKey(R.string.pref_ratingwanted), prefsV0.getBoolean(getKey(R.string.pref_ratingwanted), true));
            e.putBoolean(getKey(R.string.pref_friendlogswanted), prefsV0.getBoolean(getKey(R.string.pref_friendlogswanted), true));
            e.putBoolean(getKey(R.string.pref_useenglish), prefsV0.getBoolean(getKey(R.string.pref_useenglish), false));
            e.putBoolean(getKey(R.string.pref_usecompass), 0 != prefsV0.getInt(getKey(R.string.pref_usecompass), 1));
            e.putBoolean(getKey(R.string.pref_trackautovisit), prefsV0.getBoolean(getKey(R.string.pref_trackautovisit), false));
            e.putBoolean(getKey(R.string.pref_sigautoinsert), prefsV0.getBoolean(getKey(R.string.pref_sigautoinsert), false));
            e.putBoolean(getKey(R.string.pref_logimages), prefsV0.getBoolean(getKey(R.string.pref_logimages), false));
            e.putBoolean(getKey(R.string.pref_excludedisabled), 0 != prefsV0.getInt(getKey(R.string.pref_excludedisabled), 0));
            e.putBoolean(getKey(R.string.pref_excludemine), 0 != prefsV0.getInt(getKey(R.string.pref_excludemine), 0));
            e.putString(getKey(R.string.pref_mapfile), prefsV0.getString(getKey(R.string.pref_mapfile), null));
            e.putString(getKey(R.string.pref_signature), prefsV0.getString(getKey(R.string.pref_signature), null));
            e.putString(getKey(R.string.pref_pass_vote), prefsV0.getString(getKey(R.string.pref_pass_vote), null));
            e.putString(getKey(R.string.pref_password), prefsV0.getString(getKey(R.string.pref_password), null));
            e.putString(getKey(R.string.pref_username), prefsV0.getString(getKey(R.string.pref_username), null));
            e.putString(getKey(R.string.pref_memberstatus), prefsV0.getString(getKey(R.string.pref_memberstatus), ""));
            e.putInt(getKey(R.string.pref_coordinputformat), prefsV0.getInt(getKey(R.string.pref_coordinputformat), CoordInputFormatEnum.DEFAULT_INT_VALUE));
            e.putBoolean(getKey(R.string.pref_log_offline), prefsV0.getBoolean(getKey(R.string.pref_log_offline), false));
            e.putBoolean(getKey(R.string.pref_choose_list), prefsV0.getBoolean(getKey(R.string.pref_choose_list), true));
            e.putBoolean(getKey(R.string.pref_loaddirectionimg), prefsV0.getBoolean(getKey(R.string.pref_loaddirectionimg), true));
            e.putString(getKey(R.string.pref_gccustomdate), prefsV0.getString(getKey(R.string.pref_gccustomdate), GCConstants.DEFAULT_GC_DATE));
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), prefsV0.getInt(getKey(R.string.pref_showwaypointsthreshold), SHOW_WP_THRESHOLD_DEFAULT));
            e.putString(getKey(R.string.pref_cookiestore), prefsV0.getString(getKey(R.string.pref_cookiestore), null));
            e.putBoolean(getKey(R.string.pref_opendetailslastpage), prefsV0.getBoolean(getKey(R.string.pref_opendetailslastpage), false));
            e.putInt(getKey(R.string.pref_lastdetailspage), prefsV0.getInt(getKey(R.string.pref_lastdetailspage), 1));
            e.putInt(getKey(R.string.pref_defaultNavigationTool), prefsV0.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id));
            e.putInt(getKey(R.string.pref_defaultNavigationTool2), prefsV0.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id));
            e.putInt(getKey(R.string.pref_livemapstrategy), prefsV0.getInt(getKey(R.string.pref_livemapstrategy), LivemapStrategy.AUTO.id));
            e.putBoolean(getKey(R.string.pref_debug), prefsV0.getBoolean(getKey(R.string.pref_debug), false));
            e.putInt(getKey(R.string.pref_livemaphintshowcount), prefsV0.getInt(getKey(R.string.pref_livemaphintshowcount), 0));

            e.putInt(getKey(R.string.pref_settingsversion), 1); // mark migrated
            e.apply();
        }

        // changes for new settings dialog
        if (currentVersion < 2) {
            final Editor e = sharedPrefs.edit();

            e.putBoolean(getKey(R.string.pref_units_imperial), useImperialUnits());

            // show waypoints threshold now as a slider
            int wpThreshold = getWayPointsThreshold();
            if (wpThreshold < 0) {
                wpThreshold = 0;
            } else if (wpThreshold > SHOW_WP_THRESHOLD_MAX) {
                wpThreshold = SHOW_WP_THRESHOLD_MAX;
            }
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), wpThreshold);

            // KEY_MAP_SOURCE must be string, because it is the key for a ListPreference now
            final int ms = sharedPrefs.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT);
            e.remove(getKey(R.string.pref_mapsource));
            e.putString(getKey(R.string.pref_mapsource), String.valueOf(ms));

            // navigation tool ids must be string, because ListPreference uses strings as keys
            final int dnt1 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id);
            final int dnt2 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id);
            e.remove(getKey(R.string.pref_defaultNavigationTool));
            e.remove(getKey(R.string.pref_defaultNavigationTool2));
            e.putString(getKey(R.string.pref_defaultNavigationTool), String.valueOf(dnt1));
            e.putString(getKey(R.string.pref_defaultNavigationTool2), String.valueOf(dnt2));

            // defaults for gpx directories
            e.putString(getKey(R.string.pref_gpxImportDir), getGpxImportDir());
            e.putString(getKey(R.string.pref_gpxExportDir), getGpxExportDir());

            e.putInt(getKey(R.string.pref_settingsversion), 2); // mark migrated
            e.apply();
        }
    }

    private static String getKey(final int prefKeyId) {
        return CgeoApplication.getInstance().getString(prefKeyId);
    }

    static String getString(final int prefKeyId, final String defaultValue) {
        return sharedPrefs.getString(getKey(prefKeyId), defaultValue);
    }

    private static int getInt(final int prefKeyId, final int defaultValue) {
        return sharedPrefs.getInt(getKey(prefKeyId), defaultValue);
    }

    private static long getLong(final int prefKeyId, final long defaultValue) {
        return sharedPrefs.getLong(getKey(prefKeyId), defaultValue);
    }

    private static boolean getBoolean(final int prefKeyId, final boolean defaultValue) {
        return sharedPrefs.getBoolean(getKey(prefKeyId), defaultValue);
    }

    private static float getFloat(final int prefKeyId, final float defaultValue) {
        return sharedPrefs.getFloat(getKey(prefKeyId), defaultValue);
    }

    protected static void putString(final int prefKeyId, final String value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putString(getKey(prefKeyId), value);
        edit.apply();
    }

    protected static void putBoolean(final int prefKeyId, final boolean value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putBoolean(getKey(prefKeyId), value);
        edit.apply();
    }

    private static void putInt(final int prefKeyId, final int value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putInt(getKey(prefKeyId), value);
        edit.apply();
    }

    private static void putLong(final int prefKeyId, final long value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putLong(getKey(prefKeyId), value);
        edit.apply();
    }

    private static void putFloat(final int prefKeyId, final float value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putFloat(getKey(prefKeyId), value);
        edit.apply();
    }

    private static void remove(final int prefKeyId) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.remove(getKey(prefKeyId));
        edit.apply();
    }

    private static boolean contains(final int prefKeyId) {
        return sharedPrefs.contains(getKey(prefKeyId));
    }

    public static boolean hasGCCredentials() {
        final String preUsername = getString(R.string.pref_username, null);
        final String prePassword = getString(R.string.pref_password, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    /**
     * Get login and password information of Geocaching.com.
     *
     * @return a pair either with (login, password) or (empty, empty) if no valid information is stored
     */
    public static ImmutablePair<String, String> getGcCredentials() {
        return getCredentials(GCConnector.getInstance());
    }

    /**
     * Get login and password information.
     *
     * @return a pair either with (login, password) or (empty, empty) if no valid information is stored
     */
    public static ImmutablePair<String, String> getCredentials(final @NonNull ICredentials connector) {
        final String username = getString(connector.getUsernamePreferenceKey(), null);
        final String password = getString(connector.getPasswordPreferenceKey(), null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return new ImmutablePair<>(StringUtils.EMPTY, StringUtils.EMPTY);
        }

        return new ImmutablePair<>(username, password);
    }

    public static String getUsername() {
        return getString(R.string.pref_username, StringUtils.EMPTY);
    }

    public static boolean isGCConnectorActive() {
        return getBoolean(R.string.pref_connectorGCActive, true);
    }

    public static boolean isECConnectorActive() {
        return getBoolean(R.string.pref_connectorECActive, false);
    }

    public static boolean isOXConnectorActive() {
        return getBoolean(R.string.pref_connectorOXActive, false);
    }

    public static boolean isGCPremiumMember() {
        final String memberStatus = getGCMemberStatus();
        return StringUtils.equalsIgnoreCase(memberStatus, GCConstants.MEMBER_STATUS_PREMIUM) ||
                StringUtils.equalsIgnoreCase(memberStatus, GCConstants.MEMBER_STATUS_CHARTER);
    }

    public static String getGCMemberStatus() {
        return getString(R.string.pref_memberstatus, "");
    }

    public static void setGCMemberStatus(final String memberStatus) {
        if (StringUtils.isBlank(memberStatus)) {
            remove(R.string.pref_memberstatus);
        }
        putString(R.string.pref_memberstatus, memberStatus);
    }

    public static ImmutablePair<String, String> getTokenPair(final int tokenPublicPrefKey, final int tokenSecretPrefKey) {
        return new ImmutablePair<>(getString(tokenPublicPrefKey, null), getString(tokenSecretPrefKey, null));
    }

    public static void setTokens(final int tokenPublicPrefKey, @Nullable final String tokenPublic, final int tokenSecretPrefKey, @Nullable final String tokenSecret) {
        if (tokenPublic == null) {
            remove(tokenPublicPrefKey);
        } else {
            putString(tokenPublicPrefKey, tokenPublic);
        }
        if (tokenSecret == null) {
            remove(tokenSecretPrefKey);
        } else {
            putString(tokenSecretPrefKey, tokenSecret);
        }
    }

    public static boolean isOCConnectorActive(final int isActivePrefKeyId) {
        return getBoolean(isActivePrefKeyId, false);
    }

    public static boolean hasOCAuthorization(final int tokenPublicPrefKeyId, final int tokenSecretPrefKeyId) {
        return StringUtils.isNotBlank(getString(tokenPublicPrefKeyId, ""))
                && StringUtils.isNotBlank(getString(tokenSecretPrefKeyId, ""));
    }

    public static boolean isGCVoteLogin() {
        return getGCVoteLogin() != null;
    }

    public static ImmutablePair<String, String> getGCVoteLogin() {
        final String username = getString(R.string.pref_username, null);
        final String password = getString(R.string.pref_pass_vote, null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return null;
        }

        return new ImmutablePair<>(username, password);
    }

    public static String getSignature() {
        return getString(R.string.pref_signature, StringUtils.EMPTY);
    }

    public static void setCookieStore(final String cookies) {
        if (StringUtils.isBlank(cookies)) {
            // erase cookies
            remove(R.string.pref_cookiestore);
        }
        // save cookies
        putString(R.string.pref_cookiestore, cookies);
    }

    public static String getCookieStore() {
        return getString(R.string.pref_cookiestore, null);
    }

    public static void setUseGooglePlayServices(final boolean value) {
        putBoolean(R.string.pref_googleplayservices, value);
    }

    public static boolean useGooglePlayServices() {
        // By defaut, enable play services starting from ICS.
        return CgeoApplication.getInstance().isGooglePlayServicesAvailable() &&
                getBoolean(R.string.pref_googleplayservices, VERSION.SDK_INT >= VERSION_CODES.ICE_CREAM_SANDWICH);
    }

    public static boolean useLowPowerMode() {
        return getBoolean(R.string.pref_lowpowermode, false);
    }

    /**
     * @param cacheType
     *            The cache type used for future filtering
     */
    public static void setCacheType(final CacheType cacheType) {
        if (cacheType == null) {
            remove(R.string.pref_cachetype);
        } else {
            putString(R.string.pref_cachetype, cacheType.id);
        }
    }

    public static int getLastList() {
        return getInt(R.string.pref_lastusedlist, StoredList.STANDARD_LIST_ID);
    }

    public static void saveLastList(final int listId) {
        putInt(R.string.pref_lastusedlist, listId);
    }

    public static void setWebNameCode(final String name, final String code) {
        putString(R.string.pref_webDeviceName, name);
        putString(R.string.pref_webDeviceCode, code);
    }

    public static MapProvider getMapProvider() {
        return getMapSource().getMapProvider();
    }

    public static String getMapFile() {
        return getString(R.string.pref_mapfile, null);
    }

    static void setMapFile(final String mapFile) {
        putString(R.string.pref_mapfile, mapFile);
        if (mapFile != null) {
            setMapFileDirectory(new File(mapFile).getParent());
        }
    }

    public static String getMapFileDirectory() {
        final String mapDir = getString(R.string.pref_mapDirectory, null);
        if (mapDir != null) {
            return mapDir;
        }
        final String mapFile = getMapFile();
        if (mapFile != null) {
            return new File(mapFile).getParent();
        }
        return null;
    }

    static void setMapFileDirectory(final String mapFileDirectory) {
        putString(R.string.pref_mapDirectory, mapFileDirectory);
        MapsforgeMapProvider.getInstance().updateOfflineMaps();
    }

    private static boolean isValidMapFile() {
        return isValidMapFile(getMapFile());
    }

    public static boolean isValidMapFile(final String mapFileIn) {
        return MapsforgeMapProvider.isValidMapFile(mapFileIn);
    }

    public static boolean isScaleMapsforgeText() {
        return getBoolean(R.string.pref_mapsforge_scale_text, true);
    }

    public static CoordInputFormatEnum getCoordInputFormat() {
        return CoordInputFormatEnum.fromInt(getInt(R.string.pref_coordinputformat, CoordInputFormatEnum.DEFAULT_INT_VALUE));
    }

    public static void setCoordInputFormat(final CoordInputFormatEnum format) {
        putInt(R.string.pref_coordinputformat, format.ordinal());
    }

    public static boolean getLogOffline() {
        return getBoolean(R.string.pref_log_offline, false);
    }

    public static boolean getChooseList() {
        return getBoolean(R.string.pref_choose_list, false);
    }

    public static boolean getLoadDirImg() {
        return !isGCPremiumMember() && getBoolean(R.string.pref_loaddirectionimg, true);
    }

    public static void setGcCustomDate(final String format) {
        putString(R.string.pref_gccustomdate, format);
    }

    /**
     * @return User selected date format on GC.com
     */
    public static String getGcCustomDate() {
        // We might have some users whose stored value is null, which is invalid. In this case, we use the default.
        return StringUtils.defaultString(getString(R.string.pref_gccustomdate, GCConstants.DEFAULT_GC_DATE),
                GCConstants.DEFAULT_GC_DATE);
    }

    public static boolean isExcludeMyCaches() {
        return getBoolean(R.string.pref_excludemine, false);
    }

    public static boolean useEnglish() {
        return getBoolean(R.string.pref_useenglish, false);
    }

    public static boolean isShowAddress() {
        return getBoolean(R.string.pref_showaddress, true);
    }

    public static boolean isShowCaptcha() {
        return !isGCPremiumMember() && getBoolean(R.string.pref_showcaptcha, false);
    }

    public static boolean isExcludeDisabledCaches() {
        return getBoolean(R.string.pref_excludedisabled, false);
    }

    public static boolean isStoreOfflineMaps() {
        return getBoolean(R.string.pref_offlinemaps, true);
    }

    public static boolean isStoreOfflineWpMaps() {
        return getBoolean(R.string.pref_offlinewpmaps, false);
    }

    public static boolean isStoreLogImages() {
        return getBoolean(R.string.pref_logimages, false);
    }

    public static boolean isAutoLoadDescription() {
        return getBoolean(R.string.pref_autoloaddesc, true);
    }

    public static boolean isRatingWanted() {
        return getBoolean(R.string.pref_ratingwanted, true);
    }

    public static boolean isGeokretyConnectorActive() {
        return getBoolean(R.string.pref_connectorGeokretyActive, false);
    }

    public static boolean isGeokretyCacheActive() {
        return getBoolean(R.string.pref_geokrety_cache, true);
    }

    static boolean hasGeokretyAuthorization() {
        return StringUtils.isNotBlank(getGeokretySecId());
    }

    public static String getGeokretySecId() {
        return getString(R.string.pref_fakekey_geokrety_authorization, null);
    }

    public static void setGeokretySecId(final String secid) {
        putString(R.string.pref_fakekey_geokrety_authorization, secid);
    }

    public static boolean isRegisteredForGeokretyLogging() {
        return getGeokretySecId() != null;
    }

    /**
     * Retrieve showed popup counter for warning about logging Trackable recommend Geocode
     *
     * @return number of times the popup has appeared
     */
    public static int getLogTrackableWithoutGeocodeShowCount() {
        return getInt(R.string.pref_logtrackablewithoutgeocodeshowcount, 0);
    }

    /**
     * Store showed popup counter for warning about logging Trackable recommend Geocode
     *
     * @param showCount the count to save
     */
    public static void setLogTrackableWithoutGeocodeShowCount(final int showCount) {
        putInt(R.string.pref_logtrackablewithoutgeocodeshowcount, showCount);
    }

    public static boolean isFriendLogsWanted() {
        if (!hasGCCredentials()) {
            // don't show a friends log if the user is anonymous
            return false;
        }
        return getBoolean(R.string.pref_friendlogswanted, true);
    }

    public static boolean isLiveList() {
        return getBoolean(R.string.pref_livelist, true);
    }

    public static boolean isTrackableAutoVisit() {
        return getBoolean(R.string.pref_trackautovisit, false);
    }

    public static boolean isAutoInsertSignature() {
        return getBoolean(R.string.pref_sigautoinsert, false);
    }

    static void setUseImperialUnits(final boolean useImperialUnits) {
        putBoolean(R.string.pref_units_imperial, useImperialUnits);
    }

    public static boolean useImperialUnits() {
        return getBoolean(R.string.pref_units_imperial, useImperialUnitsByDefault());
    }

    private static boolean useImperialUnitsByDefault() {
        final String countryCode = Locale.getDefault().getCountry();
        return "US".equals(countryCode)  // USA
            || "LR".equals(countryCode)  // Liberia
            || "MM".equals(countryCode); // Burma
    }

    public static boolean isLiveMap() {
        return getBoolean(R.string.pref_maplive, true);
    }

    public static void setLiveMap(final boolean live) {
        putBoolean(R.string.pref_maplive, live);
    }

    public static boolean isMapTrail() {
        return getBoolean(R.string.pref_maptrail, false);
    }

    public static void setMapTrail(final boolean showTrail) {
        putBoolean(R.string.pref_maptrail, showTrail);
    }

    /**
     * whether to show a direction line on the map
     */
    public static boolean isMapDirection() {
        return getBoolean(R.string.pref_map_direction, true);
    }

    public static void setMapDirection(final boolean showDirection) {
        putBoolean(R.string.pref_map_direction, showDirection);
    }

    /**
     * Get last used zoom of the internal map. Differentiate between two use cases for a map of multiple caches (e.g.
     * live map) and the map of a single cache (which is often zoomed in more deep).
     */
    public static int getMapZoom(final MapMode mapMode) {
        if (mapMode == MapMode.SINGLE || mapMode == MapMode.COORDS) {
            return getCacheZoom();
        }
        return getMapZoom();
    }

    public static void setMapZoom(final MapMode mapMode, final int zoomLevel) {
        if (mapMode == MapMode.SINGLE || mapMode == MapMode.COORDS) {
            setCacheZoom(zoomLevel);
        }
        else {
            setMapZoom(zoomLevel);
        }
    }

    /**
     * @return zoom used for the (live) map
     */
    private static int getMapZoom() {
        return Math.max(getInt(R.string.pref_lastmapzoom, 14), INITIAL_MAP_ZOOM_LIMIT);
    }

    private static void setMapZoom(final int mapZoomLevel) {
        putInt(R.string.pref_lastmapzoom, mapZoomLevel);
    }

    /**
     * @return zoom used for the map of a single cache
     */
    private static int getCacheZoom() {
        return Math.max(getInt(R.string.pref_cache_zoom, 14), INITIAL_MAP_ZOOM_LIMIT);
    }

    private static void setCacheZoom(final int zoomLevel) {
        putInt(R.string.pref_cache_zoom, zoomLevel);
    }

    public static GeoPointImpl getMapCenter() {
        return getMapProvider().getMapItemFactory()
                .getGeoPointBase(new Geopoint(getInt(R.string.pref_lastmaplat, 0) / 1e6,
                        getInt(R.string.pref_lastmaplon, 0) / 1e6));
    }

    public static void setMapCenter(final GeoPointImpl mapViewCenter) {
        putInt(R.string.pref_lastmaplat, mapViewCenter.getLatitudeE6());
        putInt(R.string.pref_lastmaplon, mapViewCenter.getLongitudeE6());
    }

    @NonNull
    public static synchronized MapSource getMapSource() {
        if (mapSource != null) {
            return mapSource;
        }
        final int id = getConvertedMapId();
        mapSource = MapProviderFactory.getMapSource(id);
        if (mapSource != null) {
            // don't use offline maps if the map file is not valid
            if (!(mapSource instanceof OfflineMapSource) || isValidMapFile()) {
                return mapSource;
            }
        }
        // fallback to first available map
        return MapProviderFactory.getDefaultSource();
    }

    private final static int GOOGLEMAP_BASEID = 30;
    private final static int MAP = 1;
    private final static int SATELLITE = 2;

    private final static int MFMAP_BASEID = 40;
    private final static int MAPNIK = 1;
    private final static int CYCLEMAP = 3;
    private final static int OFFLINE = 4;
    private static final int HISTORY_SIZE = 10;

    /**
     * Convert old preference ids for maps (based on constant values) into new hash based ids.
     */
    private static int getConvertedMapId() {
        final int id = Integer.parseInt(getString(R.string.pref_mapsource,
                String.valueOf(MAP_SOURCE_DEFAULT)));
        switch (id) {
            case GOOGLEMAP_BASEID + MAP:
                return GoogleMapProvider.GOOGLE_MAP_ID.hashCode();
            case GOOGLEMAP_BASEID + SATELLITE:
                return GoogleMapProvider.GOOGLE_SATELLITE_ID.hashCode();
            case MFMAP_BASEID + MAPNIK:
                return MapsforgeMapProvider.MAPSFORGE_MAPNIK_ID.hashCode();
            case MFMAP_BASEID + CYCLEMAP:
                return MapsforgeMapProvider.MAPSFORGE_CYCLEMAP_ID.hashCode();
            case MFMAP_BASEID + OFFLINE: {
                final String mapFile = getMapFile();
                if (StringUtils.isNotEmpty(mapFile)) {
                    return mapFile.hashCode();
                }
                break;
            }
            default:
                break;
        }
        return id;
    }

    public static synchronized void setMapSource(final MapSource newMapSource) {
        putString(R.string.pref_mapsource, String.valueOf(newMapSource.getNumericalId()));
        if (newMapSource instanceof OfflineMapSource) {
            setMapFile(((OfflineMapSource) newMapSource).getFileName());
        }
        // cache the value
        mapSource = newMapSource;
    }

    public static void setAnyCoordinates(final Geopoint coords) {
        if (null != coords) {
            putFloat(R.string.pref_anylatitude, (float) coords.getLatitude());
            putFloat(R.string.pref_anylongitude, (float) coords.getLongitude());
        } else {
            remove(R.string.pref_anylatitude);
            remove(R.string.pref_anylongitude);
        }
    }

    public static Geopoint getAnyCoordinates() {
        if (contains(R.string.pref_anylatitude) && contains(R.string.pref_anylongitude)) {
            final float lat = getFloat(R.string.pref_anylatitude, 0);
            final float lon = getFloat(R.string.pref_anylongitude, 0);
            return new Geopoint(lat, lon);
        }
        return null;
    }

    public static boolean isUseCompass() {
        return useCompass;
    }

    public static void setUseCompass(final boolean value) {
        useCompass = value;
    }

    public static boolean isLightSkin() {
        return getBoolean(R.string.pref_skin, false);
    }

    @NonNull
    public static String getTwitterKeyConsumerPublic() {
        return TWITTER_KEY_CONSUMER_PUBLIC;
    }

    @NonNull
    public static String getTwitterKeyConsumerSecret() {
        return TWITTER_KEY_CONSUMER_SECRET;
    }

    public static String getWebDeviceCode() {
        return getString(R.string.pref_webDeviceCode, null);
    }

    public static boolean isRegisteredForSend2cgeo() {
        return getWebDeviceCode() != null;
    }

    static String getWebDeviceName() {
        return getString(R.string.pref_webDeviceName, Build.MODEL);
    }

    /**
     * @return The cache type used for filtering or ALL if no filter is active.
     *         Returns never null
     */
    @NonNull
    public static CacheType getCacheType() {
        return CacheType.getById(getString(R.string.pref_cachetype, CacheType.ALL.id));
    }

    /**
     * The Threshold for the showing of child waypoints
     */
    public static int getWayPointsThreshold() {
        return getInt(R.string.pref_showwaypointsthreshold, SHOW_WP_THRESHOLD_DEFAULT);
    }

    static void setShowWaypointsThreshold(final int threshold) {
        putInt(R.string.pref_showwaypointsthreshold, threshold);
    }

    public static boolean isUseTwitter() {
        return getBoolean(R.string.pref_twitter, false);
    }

    private static void setUseTwitter(final boolean useTwitter) {
        putBoolean(R.string.pref_twitter, useTwitter);
    }

    public static boolean isTwitterLoginValid() {
        return !StringUtils.isBlank(getTokenPublic())
                && !StringUtils.isBlank(getTokenSecret());
    }

    public static String getTokenPublic() {
        return getString(R.string.pref_twitter_token_public, null);
    }

    public static String getTokenSecret() {
        return getString(R.string.pref_twitter_token_secret, null);

    }

    static boolean hasTwitterAuthorization() {
        return StringUtils.isNotBlank(getTokenPublic())
                && StringUtils.isNotBlank(getTokenSecret());
    }

    public static void setTwitterTokens(@Nullable final String tokenPublic,
            @Nullable final String tokenSecret, final boolean enableTwitter) {
        putString(R.string.pref_twitter_token_public, tokenPublic);
        putString(R.string.pref_twitter_token_secret, tokenSecret);
        if (tokenPublic != null) {
            remove(R.string.pref_temp_twitter_token_public);
            remove(R.string.pref_temp_twitter_token_secret);
        }
        setUseTwitter(enableTwitter);
    }

    public static void setTwitterTempTokens(@Nullable final String tokenPublic,
            @Nullable final String tokenSecret) {
        putString(R.string.pref_temp_twitter_token_public, tokenPublic);
        putString(R.string.pref_temp_twitter_token_secret, tokenSecret);
    }

    public static ImmutablePair<String, String> getTempToken() {
        final String tokenPublic = getString(R.string.pref_temp_twitter_token_public, null);
        final String tokenSecret = getString(R.string.pref_temp_twitter_token_secret, null);
        return new ImmutablePair<>(tokenPublic, tokenSecret);
    }

    public static int getVersion() {
        return getInt(R.string.pref_version, 0);
    }

    public static void setVersion(final int version) {
        putInt(R.string.pref_version, version);
    }

    public static boolean isOpenLastDetailsPage() {
        return getBoolean(R.string.pref_opendetailslastpage, false);
    }

    public static int getLastDetailsPage() {
        return getInt(R.string.pref_lastdetailspage, 1);
    }

    public static void setLastDetailsPage(final int index) {
        putInt(R.string.pref_lastdetailspage, index);
    }

    public static int getDefaultNavigationTool() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool,
                String.valueOf(NavigationAppsEnum.COMPASS.id)));
    }

    public static int getDefaultNavigationTool2() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool2,
                String.valueOf(NavigationAppsEnum.INTERNAL_MAP.id)));
    }

    public static LivemapStrategy getLiveMapStrategy() {
        return LivemapStrategy.getById(getInt(R.string.pref_livemapstrategy, LivemapStrategy.AUTO.id));
    }

    public static void setLiveMapStrategy(final LivemapStrategy strategy) {
        putInt(R.string.pref_livemapstrategy, strategy.id);
    }

    public static boolean isDebug() {
        return Log.isDebug();
    }

    public static int getLiveMapHintShowCount() {
        return getInt(R.string.pref_livemaphintshowcount, 0);
    }

    public static void setLiveMapHintShowCount(final int showCount) {
        putInt(R.string.pref_livemaphintshowcount, showCount);
    }

    public static boolean isDbOnSDCard() {
        return getBoolean(R.string.pref_dbonsdcard, false);
    }

    public static void setDbOnSDCard(final boolean dbOnSDCard) {
        putBoolean(R.string.pref_dbonsdcard, dbOnSDCard);
    }

    public static String getGpxExportDir() {
        return getString(R.string.pref_gpxExportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static String getGpxImportDir() {
        return getString(R.string.pref_gpxImportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static boolean getShareAfterExport() {
        return getBoolean(R.string.pref_shareafterexport, true);
    }

    public static void setShareAfterExport(final boolean shareAfterExport) {
        putBoolean(R.string.pref_shareafterexport, shareAfterExport);
    }

    public static int getTrackableAction() {
        return getInt(R.string.pref_trackableaction, LogTypeTrackable.RETRIEVED_IT.id);
    }

    public static void setTrackableAction(final int trackableAction) {
        putInt(R.string.pref_trackableaction, trackableAction);
    }

    private static String getCustomRenderThemeBaseFolder() {
        return getString(R.string.pref_renderthemepath, "");
    }

    public static String getCustomRenderThemeFilePath() {
        return getString(R.string.pref_renderthemefile, "");
    }

    public static void setCustomRenderThemeFile(final String customRenderThemeFile) {
        putString(R.string.pref_renderthemefile, customRenderThemeFile);
    }

    public static File[] getMapThemeFiles() {
        final File directory = new File(getCustomRenderThemeBaseFolder());
        final List<File> result = new ArrayList<>();
        FileUtils.listDir(result, directory, new ExtensionsBasedFileSelector(new String[] { "xml" }), null);

        return result.toArray(new File[result.size()]);
    }

    private static class ExtensionsBasedFileSelector implements FileSelector {
        private final String[] extensions;
        public ExtensionsBasedFileSelector(final String[] extensions) {
            this.extensions = extensions;
        }
        @Override
        public boolean isSelected(final File file) {
            final String filename = file.getName();
            for (final String ext : extensions) {
                if (StringUtils.endsWithIgnoreCase(filename, ext)) {
                    return true;
                }
            }
            return false;
        }
        @Override
        public boolean shouldEnd() {
            return false;
        }
    }

    /**
     * @return true if plain text log wanted
     */
    public static boolean getPlainLogs() {
        return getBoolean(R.string.pref_plainLogs, false);
    }

    /**
     * Force set the plain text log preference
     *
     * @param plainLogs
     *            wanted or not
     */
    public static void setPlainLogs(final boolean plainLogs) {
        putBoolean(R.string.pref_plainLogs, plainLogs);
    }

    public static boolean getUseNativeUa() {
        return getBoolean(R.string.pref_nativeUa, false);
    }

    public static String getCacheTwitterMessage() {
        return getString(R.string.pref_twitter_cache_message, "I found [NAME] ([URL]).");
    }

    public static String getTrackableTwitterMessage() {
        return getString(R.string.pref_twitter_trackable_message, "I touched [NAME] ([URL]).");
    }

    public static int getLogImageScale() {
        return getInt(R.string.pref_logImageScale, -1);
    }

    public static void setLogImageScale(final int scale) {
        putInt(R.string.pref_logImageScale, scale);
    }

    public static void setExcludeMine(final boolean exclude) {
        putBoolean(R.string.pref_excludemine, exclude);
    }

    static void setLogin(final String username, final String password) {
        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            // erase username and password
            remove(R.string.pref_username);
            remove(R.string.pref_password);
            return;
        }
        // save username and password
        putString(R.string.pref_username, username);
        putString(R.string.pref_password, password);
    }

    public static long getFieldnoteExportDate() {
        return getLong(R.string.pref_fieldNoteExportDate, 0);
    }

    /**
     * Remember date of last field note export.
     */
    public static void setFieldnoteExportDate(final long date) {
        putLong(R.string.pref_fieldNoteExportDate, date);
    }

    public static boolean isUseNavigationApp(final NavigationAppsEnum navApp) {
        return getBoolean(navApp.preferenceKey, true);
    }

    /**
     * Remember the state of the "Upload" checkbox in the field notes export dialog.
     */
    public static void setFieldNoteExportUpload(final boolean upload) {
        putBoolean(R.string.pref_fieldNoteExportUpload, upload);
    }

    public static boolean getFieldNoteExportUpload() {
        return getBoolean(R.string.pref_fieldNoteExportUpload, true);
    }

    /**
     * Remember the state of the "Only new" checkbox in the field notes export dialog.
     */
    public static void setFieldNoteExportOnlyNew(final boolean onlyNew) {
        putBoolean(R.string.pref_fieldNoteExportOnlyNew, onlyNew);
    }

    public static boolean getFieldNoteExportOnlyNew() {
        return getBoolean(R.string.pref_fieldNoteExportOnlyNew, false);
    }

    public static String getECIconSet() {
        return getString(R.string.pref_ec_icons, "1");
    }

    /* Store last checksum of changelog for changelog display */
    public static long getLastChangelogChecksum() {
        return getLong(R.string.pref_changelog_last_checksum, 0);
    }

    public static void setLastChangelogChecksum(final long checksum) {
        putLong(R.string.pref_changelog_last_checksum, checksum);
    }

    public static List<String> getLastOpenedCaches() {
        final List<String> history = Arrays.asList(StringUtils.split(getString(R.string.pref_caches_history, StringUtils.EMPTY), HISTORY_SEPARATOR));
        return history.subList(0, Math.min(HISTORY_SIZE, history.size()));
    }

    public static void addCacheToHistory(@NonNull final String geocode) {
        final List<String> history = new ArrayList<>(getLastOpenedCaches());
        // bring entry to front, if it already existed
        history.remove(geocode);
        history.add(0, geocode);
        putString(R.string.pref_caches_history, StringUtils.join(history, HISTORY_SEPARATOR));
    }

    public static boolean useHardwareAcceleration() {
        return getBoolean(R.string.pref_hardware_acceleration, !HW_ACCEL_DISABLED_BY_DEFAULT);
    }

    static void setUseHardwareAcceleration(final boolean useHardwareAcceleration) {
        putBoolean(R.string.pref_hardware_acceleration, useHardwareAcceleration);
    }

    public static String getLastCacheLog() {
        return getString(R.string.pref_last_cache_log, StringUtils.EMPTY);
    }

    public static void setLastCacheLog(final String log) {
        putString(R.string.pref_last_cache_log, log);
    }

    public static String getLastTrackableLog() {
        return getString(R.string.pref_last_trackable_log, StringUtils.EMPTY);
    }

    public static void setLastTrackableLog(final String log) {
        putString(R.string.pref_last_trackable_log, log);
    }

    @Nullable
    public static String getHomeLocation() {
        return getString(R.string.pref_home_location, null);
    }

    public static void setHomeLocation(@NonNull final String homeLocation) {
        putString(R.string.pref_home_location, homeLocation);
    }
}
!@#$%
20190527_010908,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_c21452
package cgeo.geocaching.settings;

import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.R;
import cgeo.geocaching.apps.cache.navi.NavigationAppFactory.NavigationAppsEnum;
import cgeo.geocaching.connector.capability.ICredentials;
import cgeo.geocaching.connector.gc.GCConnector;
import cgeo.geocaching.connector.gc.GCConstants;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.LogTypeTrackable;
import cgeo.geocaching.list.StoredList;
import cgeo.geocaching.location.Geopoint;
import cgeo.geocaching.maps.CGeoMap.MapMode;
import cgeo.geocaching.maps.LivemapStrategy;
import cgeo.geocaching.maps.MapProviderFactory;
import cgeo.geocaching.maps.google.v1.GoogleMapProvider;
import cgeo.geocaching.maps.interfaces.GeoPointImpl;
import cgeo.geocaching.maps.interfaces.MapProvider;
import cgeo.geocaching.maps.interfaces.MapSource;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider.OfflineMapSource;
import cgeo.geocaching.utils.CryptUtils;
import cgeo.geocaching.utils.FileUtils;
import cgeo.geocaching.utils.FileUtils.FileSelector;
import cgeo.geocaching.utils.Log;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.os.Build;
import android.os.Build.VERSION;
import android.os.Build.VERSION_CODES;
import android.os.Environment;
import android.preference.PreferenceManager;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;

/**
 * General c:geo preferences/settings set by the user
 */
public class Settings {

    /**
     * On opening a map, we limit the _initial_ zoom. The user can still zoom out afterwards.
     */
    private static final int INITIAL_MAP_ZOOM_LIMIT = 16;
    private static final char HISTORY_SEPARATOR = ',';
    private static final int SHOW_WP_THRESHOLD_DEFAULT = 10;
    public static final int SHOW_WP_THRESHOLD_MAX = 50;
    private static final int MAP_SOURCE_DEFAULT = GoogleMapProvider.GOOGLE_MAP_ID.hashCode();

    public static final boolean HW_ACCEL_DISABLED_BY_DEFAULT =
            Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1 ||
            StringUtils.equals(Build.MODEL, "HTC One X") ||    // HTC One X
            StringUtils.equals(Build.MODEL, "HTC One S") ||    // HTC One S
            StringUtils.equals(Build.MODEL, "GT-I8190")  ||    // Samsung S3 mini
            StringUtils.equals(Build.MODEL, "GT-S6310L") ||    // Samsung Galaxy Young
            StringUtils.equals(Build.MODEL, "GT-P5210")  ||    // Samsung Galaxy Tab 3
            StringUtils.equals(Build.MODEL, "GT-S7580")  ||    // Samsung Galaxy Trend Plus
            StringUtils.equals(Build.MODEL, "GT-I9105P") ||    // Samsung Galaxy SII Plus
            StringUtils.equals(Build.MODEL, "ST25i")     ||    // Sony Xperia U
            StringUtils.equals(Build.MODEL, "bq Aquaris 5") || // bq Aquaris 5
            StringUtils.equals(Build.MODEL, "A1-810")    ||    // Unknown A1-810
            StringUtils.equals(Build.MODEL, "GT-I9195")  ||    // Samsung S4 mini
            StringUtils.equals(Build.MODEL, "GT-I8200N");      // Samsung S3 mini

    // twitter api keys
    private final static @NonNull String TWITTER_KEY_CONSUMER_PUBLIC = CryptUtils.rot13("ESnsCvAv3kEupF1GCR3jGj");
    private final static @NonNull String TWITTER_KEY_CONSUMER_SECRET = CryptUtils.rot13("7vQWceACV9umEjJucmlpFe9FCMZSeqIqfkQ2BnhV9x");

    private static boolean useCompass = true;

    public enum CoordInputFormatEnum {
        Plain,
        Deg,
        Min,
        Sec;

        static final int DEFAULT_INT_VALUE = Min.ordinal();

        public static CoordInputFormatEnum fromInt(final int id) {
            final CoordInputFormatEnum[] values = CoordInputFormatEnum.values();
            if (id < 0 || id >= values.length) {
                return Min;
            }
            return values[id];
        }
    }

    private static final SharedPreferences sharedPrefs = PreferenceManager
            .getDefaultSharedPreferences(CgeoApplication.getInstance().getBaseContext());
    static {
        migrateSettings();
        final boolean isDebug = sharedPrefs.getBoolean(getKey(R.string.pref_debug), false);
        Log.setDebug(isDebug);
        CgeoApplication.dumpOnOutOfMemory(isDebug);
    }

    /**
     * Cache the mapsource locally. If that is an offline map source, each request would potentially access the
     * underlying map file, leading to delays.
     */
    private static MapSource mapSource;

    protected Settings() {
        throw new InstantiationError();
    }

    private static void migrateSettings() {
        final int LATEST_PREFERENCES_VERSION = 2;
        final int currentVersion = getInt(R.string.pref_settingsversion, 0);

        // No need to migrate if we are up to date.
        if (currentVersion == LATEST_PREFERENCES_VERSION) {
            return;
        }

        // No need to migrate if we don't have older settings, defaults will be used instead.
        final String preferencesNameV0 = "cgeo.pref";
        final SharedPreferences prefsV0 = CgeoApplication.getInstance().getSharedPreferences(preferencesNameV0, Context.MODE_PRIVATE);
        if (currentVersion == 0 && prefsV0.getAll().isEmpty()) {
            final Editor e = sharedPrefs.edit();
            e.putInt(getKey(R.string.pref_settingsversion), LATEST_PREFERENCES_VERSION);
            e.apply();
            return;
        }

        if (currentVersion < 1) {
            // migrate from non standard file location and integer based boolean types
            final Editor e = sharedPrefs.edit();

            e.putString(getKey(R.string.pref_temp_twitter_token_secret), prefsV0.getString(getKey(R.string.pref_temp_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_temp_twitter_token_public), prefsV0.getString(getKey(R.string.pref_temp_twitter_token_public), null));
            e.putBoolean(getKey(R.string.pref_help_shown), prefsV0.getInt(getKey(R.string.pref_help_shown), 0) != 0);
            e.putFloat(getKey(R.string.pref_anylongitude), prefsV0.getFloat(getKey(R.string.pref_anylongitude), 0));
            e.putFloat(getKey(R.string.pref_anylatitude), prefsV0.getFloat(getKey(R.string.pref_anylatitude), 0));
            e.putBoolean(getKey(R.string.pref_offlinemaps), 0 != prefsV0.getInt(getKey(R.string.pref_offlinemaps), 1));
            e.putBoolean(getKey(R.string.pref_offlinewpmaps), 0 != prefsV0.getInt(getKey(R.string.pref_offlinewpmaps), 0));
            e.putString(getKey(R.string.pref_webDeviceCode), prefsV0.getString(getKey(R.string.pref_webDeviceCode), null));
            e.putString(getKey(R.string.pref_webDeviceName), prefsV0.getString(getKey(R.string.pref_webDeviceName), null));
            e.putBoolean(getKey(R.string.pref_maplive), prefsV0.getInt(getKey(R.string.pref_maplive), 1) != 0);
            e.putInt(getKey(R.string.pref_mapsource), prefsV0.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT));
            e.putBoolean(getKey(R.string.pref_twitter), 0 != prefsV0.getInt(getKey(R.string.pref_twitter), 0));
            e.putBoolean(getKey(R.string.pref_showaddress), 0 != prefsV0.getInt(getKey(R.string.pref_showaddress), 1));
            e.putBoolean(getKey(R.string.pref_showcaptcha), prefsV0.getBoolean(getKey(R.string.pref_showcaptcha), false));
            e.putBoolean(getKey(R.string.pref_maptrail), prefsV0.getInt(getKey(R.string.pref_maptrail), 1) != 0);
            e.putInt(getKey(R.string.pref_lastmapzoom), prefsV0.getInt(getKey(R.string.pref_lastmapzoom), 14));
            e.putBoolean(getKey(R.string.pref_livelist), 0 != prefsV0.getInt(getKey(R.string.pref_livelist), 1));
            e.putBoolean(getKey(R.string.pref_units_imperial), prefsV0.getInt(getKey(R.string.pref_units_imperial), 1) != 1);
            e.putBoolean(getKey(R.string.pref_skin), prefsV0.getInt(getKey(R.string.pref_skin), 0) != 0);
            e.putInt(getKey(R.string.pref_lastusedlist), prefsV0.getInt(getKey(R.string.pref_lastusedlist), StoredList.STANDARD_LIST_ID));
            e.putString(getKey(R.string.pref_cachetype), prefsV0.getString(getKey(R.string.pref_cachetype), CacheType.ALL.id));
            e.putString(getKey(R.string.pref_twitter_token_secret), prefsV0.getString(getKey(R.string.pref_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_twitter_token_public), prefsV0.getString(getKey(R.string.pref_twitter_token_public), null));
            e.putInt(getKey(R.string.pref_version), prefsV0.getInt(getKey(R.string.pref_version), 0));
            e.putBoolean(getKey(R.string.pref_autoloaddesc), 0 != prefsV0.getInt(getKey(R.string.pref_autoloaddesc), 1));
            e.putBoolean(getKey(R.string.pref_ratingwanted), prefsV0.getBoolean(getKey(R.string.pref_ratingwanted), true));
            e.putBoolean(getKey(R.string.pref_friendlogswanted), prefsV0.getBoolean(getKey(R.string.pref_friendlogswanted), true));
            e.putBoolean(getKey(R.string.pref_useenglish), prefsV0.getBoolean(getKey(R.string.pref_useenglish), false));
            e.putBoolean(getKey(R.string.pref_usecompass), 0 != prefsV0.getInt(getKey(R.string.pref_usecompass), 1));
            e.putBoolean(getKey(R.string.pref_trackautovisit), prefsV0.getBoolean(getKey(R.string.pref_trackautovisit), false));
            e.putBoolean(getKey(R.string.pref_sigautoinsert), prefsV0.getBoolean(getKey(R.string.pref_sigautoinsert), false));
            e.putBoolean(getKey(R.string.pref_logimages), prefsV0.getBoolean(getKey(R.string.pref_logimages), false));
            e.putBoolean(getKey(R.string.pref_excludedisabled), 0 != prefsV0.getInt(getKey(R.string.pref_excludedisabled), 0));
            e.putBoolean(getKey(R.string.pref_excludemine), 0 != prefsV0.getInt(getKey(R.string.pref_excludemine), 0));
            e.putString(getKey(R.string.pref_mapfile), prefsV0.getString(getKey(R.string.pref_mapfile), null));
            e.putString(getKey(R.string.pref_signature), prefsV0.getString(getKey(R.string.pref_signature), null));
            e.putString(getKey(R.string.pref_pass_vote), prefsV0.getString(getKey(R.string.pref_pass_vote), null));
            e.putString(getKey(R.string.pref_password), prefsV0.getString(getKey(R.string.pref_password), null));
            e.putString(getKey(R.string.pref_username), prefsV0.getString(getKey(R.string.pref_username), null));
            e.putString(getKey(R.string.pref_memberstatus), prefsV0.getString(getKey(R.string.pref_memberstatus), ""));
            e.putInt(getKey(R.string.pref_coordinputformat), prefsV0.getInt(getKey(R.string.pref_coordinputformat), CoordInputFormatEnum.DEFAULT_INT_VALUE));
            e.putBoolean(getKey(R.string.pref_log_offline), prefsV0.getBoolean(getKey(R.string.pref_log_offline), false));
            e.putBoolean(getKey(R.string.pref_choose_list), prefsV0.getBoolean(getKey(R.string.pref_choose_list), true));
            e.putBoolean(getKey(R.string.pref_loaddirectionimg), prefsV0.getBoolean(getKey(R.string.pref_loaddirectionimg), true));
            e.putString(getKey(R.string.pref_gccustomdate), prefsV0.getString(getKey(R.string.pref_gccustomdate), GCConstants.DEFAULT_GC_DATE));
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), prefsV0.getInt(getKey(R.string.pref_showwaypointsthreshold), SHOW_WP_THRESHOLD_DEFAULT));
            e.putString(getKey(R.string.pref_cookiestore), prefsV0.getString(getKey(R.string.pref_cookiestore), null));
            e.putBoolean(getKey(R.string.pref_opendetailslastpage), prefsV0.getBoolean(getKey(R.string.pref_opendetailslastpage), false));
            e.putInt(getKey(R.string.pref_lastdetailspage), prefsV0.getInt(getKey(R.string.pref_lastdetailspage), 1));
            e.putInt(getKey(R.string.pref_defaultNavigationTool), prefsV0.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id));
            e.putInt(getKey(R.string.pref_defaultNavigationTool2), prefsV0.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id));
            e.putInt(getKey(R.string.pref_livemapstrategy), prefsV0.getInt(getKey(R.string.pref_livemapstrategy), LivemapStrategy.AUTO.id));
            e.putBoolean(getKey(R.string.pref_debug), prefsV0.getBoolean(getKey(R.string.pref_debug), false));
            e.putInt(getKey(R.string.pref_livemaphintshowcount), prefsV0.getInt(getKey(R.string.pref_livemaphintshowcount), 0));

            e.putInt(getKey(R.string.pref_settingsversion), 1); // mark migrated
            e.apply();
        }

        // changes for new settings dialog
        if (currentVersion < 2) {
            final Editor e = sharedPrefs.edit();

            e.putBoolean(getKey(R.string.pref_units_imperial), useImperialUnits());

            // show waypoints threshold now as a slider
            int wpThreshold = getWayPointsThreshold();
            if (wpThreshold < 0) {
                wpThreshold = 0;
            } else if (wpThreshold > SHOW_WP_THRESHOLD_MAX) {
                wpThreshold = SHOW_WP_THRESHOLD_MAX;
            }
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), wpThreshold);

            // KEY_MAP_SOURCE must be string, because it is the key for a ListPreference now
            final int ms = sharedPrefs.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT);
            e.remove(getKey(R.string.pref_mapsource));
            e.putString(getKey(R.string.pref_mapsource), String.valueOf(ms));

            // navigation tool ids must be string, because ListPreference uses strings as keys
            final int dnt1 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id);
            final int dnt2 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id);
            e.remove(getKey(R.string.pref_defaultNavigationTool));
            e.remove(getKey(R.string.pref_defaultNavigationTool2));
            e.putString(getKey(R.string.pref_defaultNavigationTool), String.valueOf(dnt1));
            e.putString(getKey(R.string.pref_defaultNavigationTool2), String.valueOf(dnt2));

            // defaults for gpx directories
            e.putString(getKey(R.string.pref_gpxImportDir), getGpxImportDir());
            e.putString(getKey(R.string.pref_gpxExportDir), getGpxExportDir());

            e.putInt(getKey(R.string.pref_settingsversion), 2); // mark migrated
            e.apply();
        }
    }

    private static String getKey(final int prefKeyId) {
        return CgeoApplication.getInstance().getString(prefKeyId);
    }

    static String getString(final int prefKeyId, final String defaultValue) {
        return sharedPrefs.getString(getKey(prefKeyId), defaultValue);
    }

    private static int getInt(final int prefKeyId, final int defaultValue) {
        return sharedPrefs.getInt(getKey(prefKeyId), defaultValue);
    }

    private static long getLong(final int prefKeyId, final long defaultValue) {
        return sharedPrefs.getLong(getKey(prefKeyId), defaultValue);
    }

    private static boolean getBoolean(final int prefKeyId, final boolean defaultValue) {
        return sharedPrefs.getBoolean(getKey(prefKeyId), defaultValue);
    }

    private static float getFloat(final int prefKeyId, final float defaultValue) {
        return sharedPrefs.getFloat(getKey(prefKeyId), defaultValue);
    }

    protected static void putString(final int prefKeyId, final String value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putString(getKey(prefKeyId), value);
        edit.apply();
    }

    protected static void putBoolean(final int prefKeyId, final boolean value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putBoolean(getKey(prefKeyId), value);
        edit.apply();
    }

    private static void putInt(final int prefKeyId, final int value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putInt(getKey(prefKeyId), value);
        edit.apply();
    }

    private static void putLong(final int prefKeyId, final long value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putLong(getKey(prefKeyId), value);
        edit.apply();
    }

    private static void putFloat(final int prefKeyId, final float value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putFloat(getKey(prefKeyId), value);
        edit.apply();
    }

    private static void remove(final int prefKeyId) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.remove(getKey(prefKeyId));
        edit.apply();
    }

    private static boolean contains(final int prefKeyId) {
        return sharedPrefs.contains(getKey(prefKeyId));
    }

    public static boolean hasGCCredentials() {
        final String preUsername = getString(R.string.pref_username, null);
        final String prePassword = getString(R.string.pref_password, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    /**
     * Get login and password information of Geocaching.com.
     *
     * @return a pair either with (login, password) or (empty, empty) if no valid information is stored
     */
    public static ImmutablePair<String, String> getGcCredentials() {
        return getCredentials(GCConnector.getInstance());
    }

    /**
     * Get login and password information.
     *
     * @return a pair either with (login, password) or (empty, empty) if no valid information is stored
     */
    public static ImmutablePair<String, String> getCredentials(final @NonNull ICredentials connector) {
        final String username = getString(connector.getUsernamePreferenceKey(), null);
        final String password = getString(connector.getPasswordPreferenceKey(), null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return new ImmutablePair<>(StringUtils.EMPTY, StringUtils.EMPTY);
        }

        return new ImmutablePair<>(username, password);
    }

    public static String getUsername() {
        return getString(R.string.pref_username, StringUtils.EMPTY);
    }

    public static boolean isGCConnectorActive() {
        return getBoolean(R.string.pref_connectorGCActive, true);
    }

    public static boolean isECConnectorActive() {
        return getBoolean(R.string.pref_connectorECActive, false);
    }

    public static boolean isGCPremiumMember() {
        final String memberStatus = getGCMemberStatus();
        return StringUtils.equalsIgnoreCase(memberStatus, GCConstants.MEMBER_STATUS_PREMIUM) ||
                StringUtils.equalsIgnoreCase(memberStatus, GCConstants.MEMBER_STATUS_CHARTER);
    }

    public static String getGCMemberStatus() {
        return getString(R.string.pref_memberstatus, "");
    }

    public static void setGCMemberStatus(final String memberStatus) {
        if (StringUtils.isBlank(memberStatus)) {
            remove(R.string.pref_memberstatus);
        }
        putString(R.string.pref_memberstatus, memberStatus);
    }

    public static ImmutablePair<String, String> getTokenPair(final int tokenPublicPrefKey, final int tokenSecretPrefKey) {
        return new ImmutablePair<>(getString(tokenPublicPrefKey, null), getString(tokenSecretPrefKey, null));
    }

    public static void setTokens(final int tokenPublicPrefKey, @Nullable final String tokenPublic, final int tokenSecretPrefKey, @Nullable final String tokenSecret) {
        if (tokenPublic == null) {
            remove(tokenPublicPrefKey);
        } else {
            putString(tokenPublicPrefKey, tokenPublic);
        }
        if (tokenSecret == null) {
            remove(tokenSecretPrefKey);
        } else {
            putString(tokenSecretPrefKey, tokenSecret);
        }
    }

    public static boolean isOCConnectorActive(final int isActivePrefKeyId) {
        return getBoolean(isActivePrefKeyId, false);
    }

    public static boolean hasOCAuthorization(final int tokenPublicPrefKeyId, final int tokenSecretPrefKeyId) {
        return StringUtils.isNotBlank(getString(tokenPublicPrefKeyId, ""))
                && StringUtils.isNotBlank(getString(tokenSecretPrefKeyId, ""));
    }

    public static boolean isGCVoteLogin() {
        return getGCVoteLogin() != null;
    }

    public static ImmutablePair<String, String> getGCVoteLogin() {
        final String username = getString(R.string.pref_username, null);
        final String password = getString(R.string.pref_pass_vote, null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return null;
        }

        return new ImmutablePair<>(username, password);
    }

    public static String getSignature() {
        return getString(R.string.pref_signature, StringUtils.EMPTY);
    }

    public static void setCookieStore(final String cookies) {
        if (StringUtils.isBlank(cookies)) {
            // erase cookies
            remove(R.string.pref_cookiestore);
        }
        // save cookies
        putString(R.string.pref_cookiestore, cookies);
    }

    public static String getCookieStore() {
        return getString(R.string.pref_cookiestore, null);
    }

    public static void setUseGooglePlayServices(final boolean value) {
        putBoolean(R.string.pref_googleplayservices, value);
    }

    public static boolean useGooglePlayServices() {
        // By defaut, enable play services starting from ICS.
        return CgeoApplication.getInstance().isGooglePlayServicesAvailable() &&
                getBoolean(R.string.pref_googleplayservices, VERSION.SDK_INT >= VERSION_CODES.ICE_CREAM_SANDWICH);
    }

    public static boolean useLowPowerMode() {
        return getBoolean(R.string.pref_lowpowermode, false);
    }

    /**
     * @param cacheType
     *            The cache type used for future filtering
     */
    public static void setCacheType(final CacheType cacheType) {
        if (cacheType == null) {
            remove(R.string.pref_cachetype);
        } else {
            putString(R.string.pref_cachetype, cacheType.id);
        }
    }

    public static int getLastList() {
        return getInt(R.string.pref_lastusedlist, StoredList.STANDARD_LIST_ID);
    }

    public static void saveLastList(final int listId) {
        putInt(R.string.pref_lastusedlist, listId);
    }

    public static void setWebNameCode(final String name, final String code) {
        putString(R.string.pref_webDeviceName, name);
        putString(R.string.pref_webDeviceCode, code);
    }

    public static MapProvider getMapProvider() {
        return getMapSource().getMapProvider();
    }

    public static String getMapFile() {
        return getString(R.string.pref_mapfile, null);
    }

    static void setMapFile(final String mapFile) {
        putString(R.string.pref_mapfile, mapFile);
        if (mapFile != null) {
            setMapFileDirectory(new File(mapFile).getParent());
        }
    }

    public static String getMapFileDirectory() {
        final String mapDir = getString(R.string.pref_mapDirectory, null);
        if (mapDir != null) {
            return mapDir;
        }
        final String mapFile = getMapFile();
        if (mapFile != null) {
            return new File(mapFile).getParent();
        }
        return null;
    }

    static void setMapFileDirectory(final String mapFileDirectory) {
        putString(R.string.pref_mapDirectory, mapFileDirectory);
        MapsforgeMapProvider.getInstance().updateOfflineMaps();
    }

    private static boolean isValidMapFile() {
        return isValidMapFile(getMapFile());
    }

    public static boolean isValidMapFile(final String mapFileIn) {
        return MapsforgeMapProvider.isValidMapFile(mapFileIn);
    }

    public static boolean isScaleMapsforgeText() {
        return getBoolean(R.string.pref_mapsforge_scale_text, true);
    }

    public static CoordInputFormatEnum getCoordInputFormat() {
        return CoordInputFormatEnum.fromInt(getInt(R.string.pref_coordinputformat, CoordInputFormatEnum.DEFAULT_INT_VALUE));
    }

    public static void setCoordInputFormat(final CoordInputFormatEnum format) {
        putInt(R.string.pref_coordinputformat, format.ordinal());
    }

    public static boolean getLogOffline() {
        return getBoolean(R.string.pref_log_offline, false);
    }

    public static boolean getChooseList() {
        return getBoolean(R.string.pref_choose_list, false);
    }

    public static boolean getLoadDirImg() {
        return !isGCPremiumMember() && getBoolean(R.string.pref_loaddirectionimg, true);
    }

    public static void setGcCustomDate(final String format) {
        putString(R.string.pref_gccustomdate, format);
    }

    /**
     * @return User selected date format on GC.com
     */
    public static String getGcCustomDate() {
        // We might have some users whose stored value is null, which is invalid. In this case, we use the default.
        return StringUtils.defaultString(getString(R.string.pref_gccustomdate, GCConstants.DEFAULT_GC_DATE),
                GCConstants.DEFAULT_GC_DATE);
    }

    public static boolean isExcludeMyCaches() {
        return getBoolean(R.string.pref_excludemine, false);
    }

    public static boolean useEnglish() {
        return getBoolean(R.string.pref_useenglish, false);
    }

    public static boolean isShowAddress() {
        return getBoolean(R.string.pref_showaddress, true);
    }

    public static boolean isShowCaptcha() {
        return !isGCPremiumMember() && getBoolean(R.string.pref_showcaptcha, false);
    }

    public static boolean isExcludeDisabledCaches() {
        return getBoolean(R.string.pref_excludedisabled, false);
    }

    public static boolean isStoreOfflineMaps() {
        return getBoolean(R.string.pref_offlinemaps, true);
    }

    public static boolean isStoreOfflineWpMaps() {
        return getBoolean(R.string.pref_offlinewpmaps, false);
    }

    public static boolean isStoreLogImages() {
        return getBoolean(R.string.pref_logimages, false);
    }

    public static boolean isAutoLoadDescription() {
        return getBoolean(R.string.pref_autoloaddesc, true);
    }

    public static boolean isRatingWanted() {
        return getBoolean(R.string.pref_ratingwanted, true);
    }

    public static boolean isGeokretyConnectorActive() {
        return getBoolean(R.string.pref_connectorGeokretyActive, false);
    }

    public static boolean isGeokretyCacheActive() {
        return getBoolean(R.string.pref_geokrety_cache, true);
    }

    static boolean hasGeokretyAuthorization() {
        return StringUtils.isNotBlank(getGeokretySecId());
    }

    public static String getGeokretySecId() {
        return getString(R.string.pref_fakekey_geokrety_authorization, null);
    }

    public static void setGeokretySecId(final String secid) {
        putString(R.string.pref_fakekey_geokrety_authorization, secid);
    }

    public static boolean isRegisteredForGeokretyLogging() {
        return getGeokretySecId() != null;
    }

    /**
     * Retrieve showed popup counter for warning about logging Trackable recommend Geocode
     *
     * @return number of times the popup has appeared
     */
    public static int getLogTrackableWithoutGeocodeShowCount() {
        return getInt(R.string.pref_logtrackablewithoutgeocodeshowcount, 0);
    }

    /**
     * Store showed popup counter for warning about logging Trackable recommend Geocode
     *
     * @param showCount the count to save
     */
    public static void setLogTrackableWithoutGeocodeShowCount(final int showCount) {
        putInt(R.string.pref_logtrackablewithoutgeocodeshowcount, showCount);
    }

    public static boolean isFriendLogsWanted() {
        if (!hasGCCredentials()) {
            // don't show a friends log if the user is anonymous
            return false;
        }
        return getBoolean(R.string.pref_friendlogswanted, true);
    }

    public static boolean isLiveList() {
        return getBoolean(R.string.pref_livelist, true);
    }

    public static boolean isTrackableAutoVisit() {
        return getBoolean(R.string.pref_trackautovisit, false);
    }

    public static boolean isAutoInsertSignature() {
        return getBoolean(R.string.pref_sigautoinsert, false);
    }

    static void setUseImperialUnits(final boolean useImperialUnits) {
        putBoolean(R.string.pref_units_imperial, useImperialUnits);
    }

    public static boolean useImperialUnits() {
        return getBoolean(R.string.pref_units_imperial, useImperialUnitsByDefault());
    }

    private static boolean useImperialUnitsByDefault() {
        final String countryCode = Locale.getDefault().getCountry();
        return "US".equals(countryCode)  // USA
            || "LR".equals(countryCode)  // Liberia
            || "MM".equals(countryCode); // Burma
    }

    public static boolean isLiveMap() {
        return getBoolean(R.string.pref_maplive, true);
    }

    public static void setLiveMap(final boolean live) {
        putBoolean(R.string.pref_maplive, live);
    }

    public static boolean isMapTrail() {
        return getBoolean(R.string.pref_maptrail, false);
    }

    public static void setMapTrail(final boolean showTrail) {
        putBoolean(R.string.pref_maptrail, showTrail);
    }

    /**
     * whether to show a direction line on the map
     */
    public static boolean isMapDirection() {
        return getBoolean(R.string.pref_map_direction, true);
    }

    public static void setMapDirection(final boolean showDirection) {
        putBoolean(R.string.pref_map_direction, showDirection);
    }

    /**
     * Get last used zoom of the internal map. Differentiate between two use cases for a map of multiple caches (e.g.
     * live map) and the map of a single cache (which is often zoomed in more deep).
     */
    public static int getMapZoom(final MapMode mapMode) {
        if (mapMode == MapMode.SINGLE || mapMode == MapMode.COORDS) {
            return getCacheZoom();
        }
        return getMapZoom();
    }

    public static void setMapZoom(final MapMode mapMode, final int zoomLevel) {
        if (mapMode == MapMode.SINGLE || mapMode == MapMode.COORDS) {
            setCacheZoom(zoomLevel);
        }
        else {
            setMapZoom(zoomLevel);
        }
    }

    /**
     * @return zoom used for the (live) map
     */
    private static int getMapZoom() {
        return Math.max(getInt(R.string.pref_lastmapzoom, 14), INITIAL_MAP_ZOOM_LIMIT);
    }

    private static void setMapZoom(final int mapZoomLevel) {
        putInt(R.string.pref_lastmapzoom, mapZoomLevel);
    }

    /**
     * @return zoom used for the map of a single cache
     */
    private static int getCacheZoom() {
        return Math.max(getInt(R.string.pref_cache_zoom, 14), INITIAL_MAP_ZOOM_LIMIT);
    }

    private static void setCacheZoom(final int zoomLevel) {
        putInt(R.string.pref_cache_zoom, zoomLevel);
    }

    public static GeoPointImpl getMapCenter() {
        return getMapProvider().getMapItemFactory()
                .getGeoPointBase(new Geopoint(getInt(R.string.pref_lastmaplat, 0) / 1e6,
                        getInt(R.string.pref_lastmaplon, 0) / 1e6));
    }

    public static void setMapCenter(final GeoPointImpl mapViewCenter) {
        putInt(R.string.pref_lastmaplat, mapViewCenter.getLatitudeE6());
        putInt(R.string.pref_lastmaplon, mapViewCenter.getLongitudeE6());
    }

    @NonNull
    public static synchronized MapSource getMapSource() {
        if (mapSource != null) {
            return mapSource;
        }
        final int id = getConvertedMapId();
        mapSource = MapProviderFactory.getMapSource(id);
        if (mapSource != null) {
            // don't use offline maps if the map file is not valid
            if (!(mapSource instanceof OfflineMapSource) || isValidMapFile()) {
                return mapSource;
            }
        }
        // fallback to first available map
        return MapProviderFactory.getDefaultSource();
    }

    private final static int GOOGLEMAP_BASEID = 30;
    private final static int MAP = 1;
    private final static int SATELLITE = 2;

    private final static int MFMAP_BASEID = 40;
    private final static int MAPNIK = 1;
    private final static int CYCLEMAP = 3;
    private final static int OFFLINE = 4;
    private static final int HISTORY_SIZE = 10;

    /**
     * Convert old preference ids for maps (based on constant values) into new hash based ids.
     */
    private static int getConvertedMapId() {
        final int id = Integer.parseInt(getString(R.string.pref_mapsource,
                String.valueOf(MAP_SOURCE_DEFAULT)));
        switch (id) {
            case GOOGLEMAP_BASEID + MAP:
                return GoogleMapProvider.GOOGLE_MAP_ID.hashCode();
            case GOOGLEMAP_BASEID + SATELLITE:
                return GoogleMapProvider.GOOGLE_SATELLITE_ID.hashCode();
            case MFMAP_BASEID + MAPNIK:
                return MapsforgeMapProvider.MAPSFORGE_MAPNIK_ID.hashCode();
            case MFMAP_BASEID + CYCLEMAP:
                return MapsforgeMapProvider.MAPSFORGE_CYCLEMAP_ID.hashCode();
            case MFMAP_BASEID + OFFLINE: {
                final String mapFile = getMapFile();
                if (StringUtils.isNotEmpty(mapFile)) {
                    return mapFile.hashCode();
                }
                break;
            }
            default:
                break;
        }
        return id;
    }

    public static synchronized void setMapSource(final MapSource newMapSource) {
        putString(R.string.pref_mapsource, String.valueOf(newMapSource.getNumericalId()));
        if (newMapSource instanceof OfflineMapSource) {
            setMapFile(((OfflineMapSource) newMapSource).getFileName());
        }
        // cache the value
        mapSource = newMapSource;
    }

    public static void setAnyCoordinates(final Geopoint coords) {
        if (null != coords) {
            putFloat(R.string.pref_anylatitude, (float) coords.getLatitude());
            putFloat(R.string.pref_anylongitude, (float) coords.getLongitude());
        } else {
            remove(R.string.pref_anylatitude);
            remove(R.string.pref_anylongitude);
        }
    }

    public static Geopoint getAnyCoordinates() {
        if (contains(R.string.pref_anylatitude) && contains(R.string.pref_anylongitude)) {
            final float lat = getFloat(R.string.pref_anylatitude, 0);
            final float lon = getFloat(R.string.pref_anylongitude, 0);
            return new Geopoint(lat, lon);
        }
        return null;
    }

    public static boolean isUseCompass() {
        return useCompass;
    }

    public static void setUseCompass(final boolean value) {
        useCompass = value;
    }

    public static boolean isLightSkin() {
        return getBoolean(R.string.pref_skin, false);
    }

    @NonNull
    public static String getTwitterKeyConsumerPublic() {
        return TWITTER_KEY_CONSUMER_PUBLIC;
    }

    @NonNull
    public static String getTwitterKeyConsumerSecret() {
        return TWITTER_KEY_CONSUMER_SECRET;
    }

    public static String getWebDeviceCode() {
        return getString(R.string.pref_webDeviceCode, null);
    }

    public static boolean isRegisteredForSend2cgeo() {
        return getWebDeviceCode() != null;
    }

    static String getWebDeviceName() {
        return getString(R.string.pref_webDeviceName, Build.MODEL);
    }

    /**
     * @return The cache type used for filtering or ALL if no filter is active.
     *         Returns never null
     */
    @NonNull
    public static CacheType getCacheType() {
        return CacheType.getById(getString(R.string.pref_cachetype, CacheType.ALL.id));
    }

    /**
     * The Threshold for the showing of child waypoints
     */
    public static int getWayPointsThreshold() {
        return getInt(R.string.pref_showwaypointsthreshold, SHOW_WP_THRESHOLD_DEFAULT);
    }

    static void setShowWaypointsThreshold(final int threshold) {
        putInt(R.string.pref_showwaypointsthreshold, threshold);
    }

    public static boolean isUseTwitter() {
        return getBoolean(R.string.pref_twitter, false);
    }

    private static void setUseTwitter(final boolean useTwitter) {
        putBoolean(R.string.pref_twitter, useTwitter);
    }

    public static boolean isTwitterLoginValid() {
        return !StringUtils.isBlank(getTokenPublic())
                && !StringUtils.isBlank(getTokenSecret());
    }

    public static String getTokenPublic() {
        return getString(R.string.pref_twitter_token_public, null);
    }

    public static String getTokenSecret() {
        return getString(R.string.pref_twitter_token_secret, null);

    }

    static boolean hasTwitterAuthorization() {
        return StringUtils.isNotBlank(getTokenPublic())
                && StringUtils.isNotBlank(getTokenSecret());
    }

    public static void setTwitterTokens(@Nullable final String tokenPublic,
            @Nullable final String tokenSecret, final boolean enableTwitter) {
        putString(R.string.pref_twitter_token_public, tokenPublic);
        putString(R.string.pref_twitter_token_secret, tokenSecret);
        if (tokenPublic != null) {
            remove(R.string.pref_temp_twitter_token_public);
            remove(R.string.pref_temp_twitter_token_secret);
        }
        setUseTwitter(enableTwitter);
    }

    public static void setTwitterTempTokens(@Nullable final String tokenPublic,
            @Nullable final String tokenSecret) {
        putString(R.string.pref_temp_twitter_token_public, tokenPublic);
        putString(R.string.pref_temp_twitter_token_secret, tokenSecret);
    }

    public static ImmutablePair<String, String> getTempToken() {
        final String tokenPublic = getString(R.string.pref_temp_twitter_token_public, null);
        final String tokenSecret = getString(R.string.pref_temp_twitter_token_secret, null);
        return new ImmutablePair<>(tokenPublic, tokenSecret);
    }

    public static int getVersion() {
        return getInt(R.string.pref_version, 0);
    }

    public static void setVersion(final int version) {
        putInt(R.string.pref_version, version);
    }

    public static boolean isOpenLastDetailsPage() {
        return getBoolean(R.string.pref_opendetailslastpage, false);
    }

    public static int getLastDetailsPage() {
        return getInt(R.string.pref_lastdetailspage, 1);
    }

    public static void setLastDetailsPage(final int index) {
        putInt(R.string.pref_lastdetailspage, index);
    }

    public static int getDefaultNavigationTool() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool,
                String.valueOf(NavigationAppsEnum.COMPASS.id)));
    }

    public static int getDefaultNavigationTool2() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool2,
                String.valueOf(NavigationAppsEnum.INTERNAL_MAP.id)));
    }

    public static LivemapStrategy getLiveMapStrategy() {
        return LivemapStrategy.getById(getInt(R.string.pref_livemapstrategy, LivemapStrategy.AUTO.id));
    }

    public static void setLiveMapStrategy(final LivemapStrategy strategy) {
        putInt(R.string.pref_livemapstrategy, strategy.id);
    }

    public static boolean isDebug() {
        return Log.isDebug();
    }

    public static int getLiveMapHintShowCount() {
        return getInt(R.string.pref_livemaphintshowcount, 0);
    }

    public static void setLiveMapHintShowCount(final int showCount) {
        putInt(R.string.pref_livemaphintshowcount, showCount);
    }

    public static boolean isDbOnSDCard() {
        return getBoolean(R.string.pref_dbonsdcard, false);
    }

    public static void setDbOnSDCard(final boolean dbOnSDCard) {
        putBoolean(R.string.pref_dbonsdcard, dbOnSDCard);
    }

    public static String getGpxExportDir() {
        return getString(R.string.pref_gpxExportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static String getGpxImportDir() {
        return getString(R.string.pref_gpxImportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static boolean getShareAfterExport() {
        return getBoolean(R.string.pref_shareafterexport, true);
    }

    public static void setShareAfterExport(final boolean shareAfterExport) {
        putBoolean(R.string.pref_shareafterexport, shareAfterExport);
    }

    public static int getTrackableAction() {
        return getInt(R.string.pref_trackableaction, LogTypeTrackable.RETRIEVED_IT.id);
    }

    public static void setTrackableAction(final int trackableAction) {
        putInt(R.string.pref_trackableaction, trackableAction);
    }

    private static String getCustomRenderThemeBaseFolder() {
        return getString(R.string.pref_renderthemepath, "");
    }

    public static String getCustomRenderThemeFilePath() {
        return getString(R.string.pref_renderthemefile, "");
    }

    public static void setCustomRenderThemeFile(final String customRenderThemeFile) {
        putString(R.string.pref_renderthemefile, customRenderThemeFile);
    }

    public static File[] getMapThemeFiles() {
        final File directory = new File(getCustomRenderThemeBaseFolder());
        final List<File> result = new ArrayList<>();
        FileUtils.listDir(result, directory, new ExtensionsBasedFileSelector(new String[] { "xml" }), null);

        return result.toArray(new File[result.size()]);
    }

    private static class ExtensionsBasedFileSelector implements FileSelector {
        private final String[] extensions;
        public ExtensionsBasedFileSelector(final String[] extensions) {
            this.extensions = extensions;
        }
        @Override
        public boolean isSelected(final File file) {
            final String filename = file.getName();
            for (final String ext : extensions) {
                if (StringUtils.endsWithIgnoreCase(filename, ext)) {
                    return true;
                }
            }
            return false;
        }
        @Override
        public boolean shouldEnd() {
            return false;
        }
    }

    /**
     * @return true if plain text log wanted
     */
    public static boolean getPlainLogs() {
        return getBoolean(R.string.pref_plainLogs, false);
    }

    /**
     * Force set the plain text log preference
     *
     * @param plainLogs
     *            wanted or not
     */
    public static void setPlainLogs(final boolean plainLogs) {
        putBoolean(R.string.pref_plainLogs, plainLogs);
    }

    public static boolean getUseNativeUa() {
        return getBoolean(R.string.pref_nativeUa, false);
    }

    public static String getCacheTwitterMessage() {
        return getString(R.string.pref_twitter_cache_message, "I found [NAME] ([URL]).");
    }

    public static String getTrackableTwitterMessage() {
        return getString(R.string.pref_twitter_trackable_message, "I touched [NAME] ([URL]).");
    }

    public static int getLogImageScale() {
        return getInt(R.string.pref_logImageScale, -1);
    }

    public static void setLogImageScale(final int scale) {
        putInt(R.string.pref_logImageScale, scale);
    }

    public static void setExcludeMine(final boolean exclude) {
        putBoolean(R.string.pref_excludemine, exclude);
    }

    static void setLogin(final String username, final String password) {
        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            // erase username and password
            remove(R.string.pref_username);
            remove(R.string.pref_password);
            return;
        }
        // save username and password
        putString(R.string.pref_username, username);
        putString(R.string.pref_password, password);
    }

    public static long getFieldnoteExportDate() {
        return getLong(R.string.pref_fieldNoteExportDate, 0);
    }

    /**
     * Remember date of last field note export.
     */
    public static void setFieldnoteExportDate(final long date) {
        putLong(R.string.pref_fieldNoteExportDate, date);
    }

    public static boolean isUseNavigationApp(final NavigationAppsEnum navApp) {
        return getBoolean(navApp.preferenceKey, true);
    }

    /**
     * Remember the state of the "Upload" checkbox in the field notes export dialog.
     */
    public static void setFieldNoteExportUpload(final boolean upload) {
        putBoolean(R.string.pref_fieldNoteExportUpload, upload);
    }

    public static boolean getFieldNoteExportUpload() {
        return getBoolean(R.string.pref_fieldNoteExportUpload, true);
    }

    /**
     * Remember the state of the "Only new" checkbox in the field notes export dialog.
     */
    public static void setFieldNoteExportOnlyNew(final boolean onlyNew) {
        putBoolean(R.string.pref_fieldNoteExportOnlyNew, onlyNew);
    }

    public static boolean getFieldNoteExportOnlyNew() {
        return getBoolean(R.string.pref_fieldNoteExportOnlyNew, false);
    }

    public static String getECIconSet() {
        return getString(R.string.pref_ec_icons, "1");
    }

    /* Store last checksum of changelog for changelog display */
    public static long getLastChangelogChecksum() {
        return getLong(R.string.pref_changelog_last_checksum, 0);
    }

    public static void setLastChangelogChecksum(final long checksum) {
        putLong(R.string.pref_changelog_last_checksum, checksum);
    }

    public static List<String> getLastOpenedCaches() {
        final List<String> history = Arrays.asList(StringUtils.split(getString(R.string.pref_caches_history, StringUtils.EMPTY), HISTORY_SEPARATOR));
        return history.subList(0, Math.min(HISTORY_SIZE, history.size()));
    }

    public static void addCacheToHistory(@NonNull final String geocode) {
        final List<String> history = new ArrayList<>(getLastOpenedCaches());
        // bring entry to front, if it already existed
        history.remove(geocode);
        history.add(0, geocode);
        putString(R.string.pref_caches_history, StringUtils.join(history, HISTORY_SEPARATOR));
    }

    public static boolean useHardwareAcceleration() {
        return getBoolean(R.string.pref_hardware_acceleration, !HW_ACCEL_DISABLED_BY_DEFAULT);
    }

    static void setUseHardwareAcceleration(final boolean useHardwareAcceleration) {
        putBoolean(R.string.pref_hardware_acceleration, useHardwareAcceleration);
    }

    public static String getLastCacheLog() {
        return getString(R.string.pref_last_cache_log, StringUtils.EMPTY);
    }

    public static void setLastCacheLog(final String log) {
        putString(R.string.pref_last_cache_log, log);
    }

    public static String getLastTrackableLog() {
        return getString(R.string.pref_last_trackable_log, StringUtils.EMPTY);
    }

    public static void setLastTrackableLog(final String log) {
        putString(R.string.pref_last_trackable_log, log);
    }

    @Nullable
    public static String getHomeLocation() {
        return getString(R.string.pref_home_location, null);
    }

    public static void setHomeLocation(@NonNull final String homeLocation) {
        putString(R.string.pref_home_location, homeLocation);
    }
}
!@#$%
20190527_011221,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_b18448
package cgeo.geocaching.settings;

import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.R;
import cgeo.geocaching.apps.navi.NavigationAppFactory.NavigationAppsEnum;
import cgeo.geocaching.connector.capability.ICredentials;
import cgeo.geocaching.connector.gc.GCConnector;
import cgeo.geocaching.connector.gc.GCConstants;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.LogTypeTrackable;
import cgeo.geocaching.list.StoredList;
import cgeo.geocaching.location.Geopoint;
import cgeo.geocaching.maps.CGeoMap.MapMode;
import cgeo.geocaching.maps.LivemapStrategy;
import cgeo.geocaching.maps.MapProviderFactory;
import cgeo.geocaching.maps.google.v1.GoogleMapProvider;
import cgeo.geocaching.maps.interfaces.GeoPointImpl;
import cgeo.geocaching.maps.interfaces.MapProvider;
import cgeo.geocaching.maps.interfaces.MapSource;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider.OfflineMapSource;
import cgeo.geocaching.sensors.OrientationProvider;
import cgeo.geocaching.sensors.RotationProvider;
import cgeo.geocaching.utils.CryptUtils;
import cgeo.geocaching.utils.FileUtils;
import cgeo.geocaching.utils.FileUtils.FileSelector;
import cgeo.geocaching.utils.Log;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.os.Build;
import android.os.Build.VERSION;
import android.os.Build.VERSION_CODES;
import android.os.Environment;
import android.preference.PreferenceManager;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;

/**
 * General c:geo preferences/settings set by the user
 */
public class Settings {

    /**
     * On opening a map, we limit the _initial_ zoom. The user can still zoom out afterwards.
     */
    private static final int INITIAL_MAP_ZOOM_LIMIT = 16;
    private static final char HISTORY_SEPARATOR = ',';
    private static final int SHOW_WP_THRESHOLD_DEFAULT = 10;
    public static final int SHOW_WP_THRESHOLD_MAX = 50;
    private static final int MAP_SOURCE_DEFAULT = GoogleMapProvider.GOOGLE_MAP_ID.hashCode();

    public static final boolean HW_ACCEL_DISABLED_BY_DEFAULT =
            Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1 ||
            StringUtils.equals(Build.MODEL, "HTC One X") ||    // HTC One X
            StringUtils.equals(Build.MODEL, "HTC One S") ||    // HTC One S
            StringUtils.equals(Build.MODEL, "GT-I8190")  ||    // Samsung S3 mini
            StringUtils.equals(Build.MODEL, "GT-S6310L") ||    // Samsung Galaxy Young
            StringUtils.equals(Build.MODEL, "GT-P5210")  ||    // Samsung Galaxy Tab 3
            StringUtils.equals(Build.MODEL, "GT-S7580")  ||    // Samsung Galaxy Trend Plus
            StringUtils.equals(Build.MODEL, "GT-I9105P") ||    // Samsung Galaxy SII Plus
            StringUtils.equals(Build.MODEL, "ST25i")     ||    // Sony Xperia U
            StringUtils.equals(Build.MODEL, "bq Aquaris 5") || // bq Aquaris 5
            StringUtils.equals(Build.MODEL, "A1-810")    ||    // Unknown A1-810
            StringUtils.equals(Build.MODEL, "GT-I9195")  ||    // Samsung S4 mini
            StringUtils.equals(Build.MODEL, "GT-I8200N");      // Samsung S3 mini

    // twitter api keys
    private final static @NonNull String TWITTER_KEY_CONSUMER_PUBLIC = CryptUtils.rot13("ESnsCvAv3kEupF1GCR3jGj");
    private final static @NonNull String TWITTER_KEY_CONSUMER_SECRET = CryptUtils.rot13("7vQWceACV9umEjJucmlpFe9FCMZSeqIqfkQ2BnhV9x");

    private static boolean useCompass = true;

    public enum CoordInputFormatEnum {
        Plain,
        Deg,
        Min,
        Sec;

        static final int DEFAULT_INT_VALUE = Min.ordinal();

        public static CoordInputFormatEnum fromInt(final int id) {
            final CoordInputFormatEnum[] values = CoordInputFormatEnum.values();
            if (id < 0 || id >= values.length) {
                return Min;
            }
            return values[id];
        }
    }

    private static final SharedPreferences sharedPrefs = PreferenceManager
            .getDefaultSharedPreferences(CgeoApplication.getInstance().getBaseContext());
    static {
        migrateSettings();
        final boolean isDebug = sharedPrefs.getBoolean(getKey(R.string.pref_debug), false);
        Log.setDebug(isDebug);
        CgeoApplication.dumpOnOutOfMemory(isDebug);
    }

    /**
     * Cache the mapsource locally. If that is an offline map source, each request would potentially access the
     * underlying map file, leading to delays.
     */
    private static MapSource mapSource;

    protected Settings() {
        throw new InstantiationError();
    }

    private static void migrateSettings() {
        final int LATEST_PREFERENCES_VERSION = 2;
        final int currentVersion = getInt(R.string.pref_settingsversion, 0);

        // No need to migrate if we are up to date.
        if (currentVersion == LATEST_PREFERENCES_VERSION) {
            return;
        }

        // No need to migrate if we don't have older settings, defaults will be used instead.
        final String preferencesNameV0 = "cgeo.pref";
        final SharedPreferences prefsV0 = CgeoApplication.getInstance().getSharedPreferences(preferencesNameV0, Context.MODE_PRIVATE);
        if (currentVersion == 0 && prefsV0.getAll().isEmpty()) {
            final Editor e = sharedPrefs.edit();
            e.putInt(getKey(R.string.pref_settingsversion), LATEST_PREFERENCES_VERSION);
            e.apply();
            return;
        }

        if (currentVersion < 1) {
            // migrate from non standard file location and integer based boolean types
            final Editor e = sharedPrefs.edit();

            e.putString(getKey(R.string.pref_temp_twitter_token_secret), prefsV0.getString(getKey(R.string.pref_temp_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_temp_twitter_token_public), prefsV0.getString(getKey(R.string.pref_temp_twitter_token_public), null));
            e.putBoolean(getKey(R.string.pref_help_shown), prefsV0.getInt(getKey(R.string.pref_help_shown), 0) != 0);
            e.putFloat(getKey(R.string.pref_anylongitude), prefsV0.getFloat(getKey(R.string.pref_anylongitude), 0));
            e.putFloat(getKey(R.string.pref_anylatitude), prefsV0.getFloat(getKey(R.string.pref_anylatitude), 0));
            e.putBoolean(getKey(R.string.pref_offlinemaps), 0 != prefsV0.getInt(getKey(R.string.pref_offlinemaps), 1));
            e.putBoolean(getKey(R.string.pref_offlinewpmaps), 0 != prefsV0.getInt(getKey(R.string.pref_offlinewpmaps), 0));
            e.putString(getKey(R.string.pref_webDeviceCode), prefsV0.getString(getKey(R.string.pref_webDeviceCode), null));
            e.putString(getKey(R.string.pref_webDeviceName), prefsV0.getString(getKey(R.string.pref_webDeviceName), null));
            e.putBoolean(getKey(R.string.pref_maplive), prefsV0.getInt(getKey(R.string.pref_maplive), 1) != 0);
            e.putInt(getKey(R.string.pref_mapsource), prefsV0.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT));
            e.putBoolean(getKey(R.string.pref_twitter), 0 != prefsV0.getInt(getKey(R.string.pref_twitter), 0));
            e.putBoolean(getKey(R.string.pref_showaddress), 0 != prefsV0.getInt(getKey(R.string.pref_showaddress), 1));
            e.putBoolean(getKey(R.string.pref_showcaptcha), prefsV0.getBoolean(getKey(R.string.pref_showcaptcha), false));
            e.putBoolean(getKey(R.string.pref_maptrail), prefsV0.getInt(getKey(R.string.pref_maptrail), 1) != 0);
            e.putInt(getKey(R.string.pref_lastmapzoom), prefsV0.getInt(getKey(R.string.pref_lastmapzoom), 14));
            e.putBoolean(getKey(R.string.pref_livelist), 0 != prefsV0.getInt(getKey(R.string.pref_livelist), 1));
            e.putBoolean(getKey(R.string.pref_units_imperial), prefsV0.getInt(getKey(R.string.pref_units_imperial), 1) != 1);
            e.putBoolean(getKey(R.string.pref_skin), prefsV0.getInt(getKey(R.string.pref_skin), 0) != 0);
            e.putInt(getKey(R.string.pref_lastusedlist), prefsV0.getInt(getKey(R.string.pref_lastusedlist), StoredList.STANDARD_LIST_ID));
            e.putString(getKey(R.string.pref_cachetype), prefsV0.getString(getKey(R.string.pref_cachetype), CacheType.ALL.id));
            e.putString(getKey(R.string.pref_twitter_token_secret), prefsV0.getString(getKey(R.string.pref_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_twitter_token_public), prefsV0.getString(getKey(R.string.pref_twitter_token_public), null));
            e.putInt(getKey(R.string.pref_version), prefsV0.getInt(getKey(R.string.pref_version), 0));
            e.putBoolean(getKey(R.string.pref_autoloaddesc), 0 != prefsV0.getInt(getKey(R.string.pref_autoloaddesc), 1));
            e.putBoolean(getKey(R.string.pref_ratingwanted), prefsV0.getBoolean(getKey(R.string.pref_ratingwanted), true));
            e.putBoolean(getKey(R.string.pref_friendlogswanted), prefsV0.getBoolean(getKey(R.string.pref_friendlogswanted), true));
            e.putBoolean(getKey(R.string.pref_useenglish), prefsV0.getBoolean(getKey(R.string.pref_useenglish), false));
            e.putBoolean(getKey(R.string.pref_usecompass), 0 != prefsV0.getInt(getKey(R.string.pref_usecompass), 1));
            e.putBoolean(getKey(R.string.pref_trackautovisit), prefsV0.getBoolean(getKey(R.string.pref_trackautovisit), false));
            e.putBoolean(getKey(R.string.pref_sigautoinsert), prefsV0.getBoolean(getKey(R.string.pref_sigautoinsert), false));
            e.putBoolean(getKey(R.string.pref_logimages), prefsV0.getBoolean(getKey(R.string.pref_logimages), false));
            e.putBoolean(getKey(R.string.pref_excludedisabled), 0 != prefsV0.getInt(getKey(R.string.pref_excludedisabled), 0));
            e.putBoolean(getKey(R.string.pref_excludemine), 0 != prefsV0.getInt(getKey(R.string.pref_excludemine), 0));
            e.putString(getKey(R.string.pref_mapfile), prefsV0.getString(getKey(R.string.pref_mapfile), null));
            e.putString(getKey(R.string.pref_signature), prefsV0.getString(getKey(R.string.pref_signature), null));
            e.putString(getKey(R.string.pref_pass_vote), prefsV0.getString(getKey(R.string.pref_pass_vote), null));
            e.putString(getKey(R.string.pref_password), prefsV0.getString(getKey(R.string.pref_password), null));
            e.putString(getKey(R.string.pref_username), prefsV0.getString(getKey(R.string.pref_username), null));
            e.putString(getKey(R.string.pref_memberstatus), prefsV0.getString(getKey(R.string.pref_memberstatus), ""));
            e.putInt(getKey(R.string.pref_coordinputformat), prefsV0.getInt(getKey(R.string.pref_coordinputformat), CoordInputFormatEnum.DEFAULT_INT_VALUE));
            e.putBoolean(getKey(R.string.pref_log_offline), prefsV0.getBoolean(getKey(R.string.pref_log_offline), false));
            e.putBoolean(getKey(R.string.pref_choose_list), prefsV0.getBoolean(getKey(R.string.pref_choose_list), true));
            e.putBoolean(getKey(R.string.pref_loaddirectionimg), prefsV0.getBoolean(getKey(R.string.pref_loaddirectionimg), true));
            e.putString(getKey(R.string.pref_gccustomdate), prefsV0.getString(getKey(R.string.pref_gccustomdate), GCConstants.DEFAULT_GC_DATE));
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), prefsV0.getInt(getKey(R.string.pref_showwaypointsthreshold), SHOW_WP_THRESHOLD_DEFAULT));
            e.putString(getKey(R.string.pref_cookiestore), prefsV0.getString(getKey(R.string.pref_cookiestore), null));
            e.putBoolean(getKey(R.string.pref_opendetailslastpage), prefsV0.getBoolean(getKey(R.string.pref_opendetailslastpage), false));
            e.putInt(getKey(R.string.pref_lastdetailspage), prefsV0.getInt(getKey(R.string.pref_lastdetailspage), 1));
            e.putInt(getKey(R.string.pref_defaultNavigationTool), prefsV0.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id));
            e.putInt(getKey(R.string.pref_defaultNavigationTool2), prefsV0.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id));
            e.putInt(getKey(R.string.pref_livemapstrategy), prefsV0.getInt(getKey(R.string.pref_livemapstrategy), LivemapStrategy.AUTO.id));
            e.putBoolean(getKey(R.string.pref_debug), prefsV0.getBoolean(getKey(R.string.pref_debug), false));
            e.putInt(getKey(R.string.pref_livemaphintshowcount), prefsV0.getInt(getKey(R.string.pref_livemaphintshowcount), 0));

            e.putInt(getKey(R.string.pref_settingsversion), 1); // mark migrated
            e.apply();
        }

        // changes for new settings dialog
        if (currentVersion < 2) {
            final Editor e = sharedPrefs.edit();

            e.putBoolean(getKey(R.string.pref_units_imperial), useImperialUnits());

            // show waypoints threshold now as a slider
            int wpThreshold = getWayPointsThreshold();
            if (wpThreshold < 0) {
                wpThreshold = 0;
            } else if (wpThreshold > SHOW_WP_THRESHOLD_MAX) {
                wpThreshold = SHOW_WP_THRESHOLD_MAX;
            }
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), wpThreshold);

            // KEY_MAP_SOURCE must be string, because it is the key for a ListPreference now
            final int ms = sharedPrefs.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT);
            e.remove(getKey(R.string.pref_mapsource));
            e.putString(getKey(R.string.pref_mapsource), String.valueOf(ms));

            // navigation tool ids must be string, because ListPreference uses strings as keys
            final int dnt1 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id);
            final int dnt2 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id);
            e.remove(getKey(R.string.pref_defaultNavigationTool));
            e.remove(getKey(R.string.pref_defaultNavigationTool2));
            e.putString(getKey(R.string.pref_defaultNavigationTool), String.valueOf(dnt1));
            e.putString(getKey(R.string.pref_defaultNavigationTool2), String.valueOf(dnt2));

            // defaults for gpx directories
            e.putString(getKey(R.string.pref_gpxImportDir), getGpxImportDir());
            e.putString(getKey(R.string.pref_gpxExportDir), getGpxExportDir());

            e.putInt(getKey(R.string.pref_settingsversion), 2); // mark migrated
            e.apply();
        }
    }

    private static String getKey(final int prefKeyId) {
        return CgeoApplication.getInstance().getString(prefKeyId);
    }

    static String getString(final int prefKeyId, final String defaultValue) {
        return sharedPrefs.getString(getKey(prefKeyId), defaultValue);
    }

    private static int getInt(final int prefKeyId, final int defaultValue) {
        return sharedPrefs.getInt(getKey(prefKeyId), defaultValue);
    }

    private static long getLong(final int prefKeyId, final long defaultValue) {
        return sharedPrefs.getLong(getKey(prefKeyId), defaultValue);
    }

    private static boolean getBoolean(final int prefKeyId, final boolean defaultValue) {
        return sharedPrefs.getBoolean(getKey(prefKeyId), defaultValue);
    }

    private static float getFloat(final int prefKeyId, final float defaultValue) {
        return sharedPrefs.getFloat(getKey(prefKeyId), defaultValue);
    }

    protected static void putString(final int prefKeyId, final String value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putString(getKey(prefKeyId), value);
        edit.apply();
    }

    protected static void putBoolean(final int prefKeyId, final boolean value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putBoolean(getKey(prefKeyId), value);
        edit.apply();
    }

    private static void putInt(final int prefKeyId, final int value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putInt(getKey(prefKeyId), value);
        edit.apply();
    }

    private static void putLong(final int prefKeyId, final long value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putLong(getKey(prefKeyId), value);
        edit.apply();
    }

    private static void putFloat(final int prefKeyId, final float value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putFloat(getKey(prefKeyId), value);
        edit.apply();
    }

    private static void remove(final int prefKeyId) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.remove(getKey(prefKeyId));
        edit.apply();
    }

    private static boolean contains(final int prefKeyId) {
        return sharedPrefs.contains(getKey(prefKeyId));
    }

    public static boolean hasGCCredentials() {
        return getGcCredentials().isValid();
    }

    /**
     * Get login and password information of Geocaching.com.
     *
     * @return a pair either with (login, password) or (empty, empty) if no valid information is stored
     */
    public static Credentials getGcCredentials() {
        return getCredentials(GCConnector.getInstance());
    }

    /**
     * Get login and password information.
     *
     * @param connector the connector to retrieve the login information from
     * @return the credential information
     */
    @NonNull
    public static Credentials getCredentials(final @NonNull ICredentials connector) {
        final String username = getString(connector.getUsernamePreferenceKey(), null);
        final String password = getString(connector.getPasswordPreferenceKey(), null);
        return new Credentials(username, password);
    }

    public static String getUsername() {
        return getString(R.string.pref_username, StringUtils.EMPTY);
    }

    public static boolean isGCConnectorActive() {
        return getBoolean(R.string.pref_connectorGCActive, true);
    }

    public static boolean isECConnectorActive() {
        return getBoolean(R.string.pref_connectorECActive, false);
    }

    public static boolean isGCPremiumMember() {
        final String memberStatus = getGCMemberStatus();
        return StringUtils.equalsIgnoreCase(memberStatus, GCConstants.MEMBER_STATUS_PREMIUM) ||
                StringUtils.equalsIgnoreCase(memberStatus, GCConstants.MEMBER_STATUS_CHARTER);
    }

    public static String getGCMemberStatus() {
        return getString(R.string.pref_memberstatus, "");
    }

    public static void setGCMemberStatus(final String memberStatus) {
        if (StringUtils.isBlank(memberStatus)) {
            remove(R.string.pref_memberstatus);
        }
        putString(R.string.pref_memberstatus, memberStatus);
    }

    public static ImmutablePair<String, String> getTokenPair(final int tokenPublicPrefKey, final int tokenSecretPrefKey) {
        return new ImmutablePair<>(getString(tokenPublicPrefKey, null), getString(tokenSecretPrefKey, null));
    }

    public static void setTokens(final int tokenPublicPrefKey, @Nullable final String tokenPublic, final int tokenSecretPrefKey, @Nullable final String tokenSecret) {
        if (tokenPublic == null) {
            remove(tokenPublicPrefKey);
        } else {
            putString(tokenPublicPrefKey, tokenPublic);
        }
        if (tokenSecret == null) {
            remove(tokenSecretPrefKey);
        } else {
            putString(tokenSecretPrefKey, tokenSecret);
        }
    }

    public static boolean isOCConnectorActive(final int isActivePrefKeyId) {
        return getBoolean(isActivePrefKeyId, false);
    }

    public static boolean hasOCAuthorization(final int tokenPublicPrefKeyId, final int tokenSecretPrefKeyId) {
        return StringUtils.isNotBlank(getString(tokenPublicPrefKeyId, ""))
                && StringUtils.isNotBlank(getString(tokenSecretPrefKeyId, ""));
    }

    public static boolean isGCVoteLoginValid() {
        return getGCVoteLogin().isValid();
    }

    @NonNull
    public static Credentials getGCVoteLogin() {
        final String username = getString(R.string.pref_username, null);
        final String password = getString(R.string.pref_pass_vote, null);
        return new Credentials(username, password);
    }

    @NonNull
    public static String getSignature() {
        return StringUtils.defaultString(getString(R.string.pref_signature, StringUtils.EMPTY));
    }

    public static void setCookieStore(final String cookies) {
        if (StringUtils.isBlank(cookies)) {
            // erase cookies
            remove(R.string.pref_cookiestore);
        }
        // save cookies
        putString(R.string.pref_cookiestore, cookies);
    }

    public static String getCookieStore() {
        return getString(R.string.pref_cookiestore, null);
    }

    public static void setUseGooglePlayServices(final boolean value) {
        putBoolean(R.string.pref_googleplayservices, value);
    }

    public static boolean useGooglePlayServices() {
        // By defaut, enable play services starting from ICS.
        return CgeoApplication.getInstance().isGooglePlayServicesAvailable() &&
                getBoolean(R.string.pref_googleplayservices, VERSION.SDK_INT >= VERSION_CODES.ICE_CREAM_SANDWICH);
    }

    public static boolean useLowPowerMode() {
        return getBoolean(R.string.pref_lowpowermode, false);
    }

    /**
     * @param cacheType
     *            The cache type used for future filtering
     */
    public static void setCacheType(final CacheType cacheType) {
        if (cacheType == null) {
            remove(R.string.pref_cachetype);
        } else {
            putString(R.string.pref_cachetype, cacheType.id);
        }
    }

    public static int getLastList() {
        return getInt(R.string.pref_lastusedlist, StoredList.STANDARD_LIST_ID);
    }

    public static void saveLastList(final int listId) {
        putInt(R.string.pref_lastusedlist, listId);
    }

    public static void setWebNameCode(final String name, final String code) {
        putString(R.string.pref_webDeviceName, name);
        putString(R.string.pref_webDeviceCode, code);
    }

    public static MapProvider getMapProvider() {
        return getMapSource().getMapProvider();
    }

    public static String getMapFile() {
        return getString(R.string.pref_mapfile, null);
    }

    static void setMapFile(final String mapFile) {
        putString(R.string.pref_mapfile, mapFile);
        if (mapFile != null) {
            setMapFileDirectory(new File(mapFile).getParent());
        }
    }

    public static String getMapFileDirectory() {
        final String mapDir = getString(R.string.pref_mapDirectory, null);
        if (mapDir != null) {
            return mapDir;
        }
        final String mapFile = getMapFile();
        if (mapFile != null) {
            return new File(mapFile).getParent();
        }
        return null;
    }

    static void setMapFileDirectory(final String mapFileDirectory) {
        putString(R.string.pref_mapDirectory, mapFileDirectory);
        MapsforgeMapProvider.getInstance().updateOfflineMaps();
    }

    private static boolean isValidMapFile() {
        return isValidMapFile(getMapFile());
    }

    public static boolean isValidMapFile(final String mapFileIn) {
        return MapsforgeMapProvider.isValidMapFile(mapFileIn);
    }

    public static boolean isScaleMapsforgeText() {
        return getBoolean(R.string.pref_mapsforge_scale_text, true);
    }

    public static CoordInputFormatEnum getCoordInputFormat() {
        return CoordInputFormatEnum.fromInt(getInt(R.string.pref_coordinputformat, CoordInputFormatEnum.DEFAULT_INT_VALUE));
    }

    public static void setCoordInputFormat(final CoordInputFormatEnum format) {
        putInt(R.string.pref_coordinputformat, format.ordinal());
    }

    public static boolean getLogOffline() {
        return getBoolean(R.string.pref_log_offline, false);
    }

    public static boolean getChooseList() {
        return getBoolean(R.string.pref_choose_list, false);
    }

    public static boolean getLoadDirImg() {
        return !isGCPremiumMember() && getBoolean(R.string.pref_loaddirectionimg, true);
    }

    public static void setGcCustomDate(final String format) {
        putString(R.string.pref_gccustomdate, format);
    }

    /**
     * @return User selected date format on GC.com
     */
    public static String getGcCustomDate() {
        // We might have some users whose stored value is null, which is invalid. In this case, we use the default.
        return StringUtils.defaultString(getString(R.string.pref_gccustomdate, GCConstants.DEFAULT_GC_DATE),
                GCConstants.DEFAULT_GC_DATE);
    }

    public static boolean isExcludeMyCaches() {
        return getBoolean(R.string.pref_excludemine, false);
    }

    public static boolean useEnglish() {
        return getBoolean(R.string.pref_useenglish, false);
    }

    public static boolean isShowAddress() {
        return getBoolean(R.string.pref_showaddress, true);
    }

    public static boolean isShowCaptcha() {
        return !isGCPremiumMember() && getBoolean(R.string.pref_showcaptcha, false);
    }

    public static boolean isExcludeDisabledCaches() {
        return getBoolean(R.string.pref_excludedisabled, false);
    }

    public static boolean isStoreOfflineMaps() {
        return getBoolean(R.string.pref_offlinemaps, true);
    }

    public static boolean isStoreOfflineWpMaps() {
        return getBoolean(R.string.pref_offlinewpmaps, false);
    }

    public static boolean isStoreLogImages() {
        return getBoolean(R.string.pref_logimages, false);
    }

    public static boolean isAutoLoadDescription() {
        return getBoolean(R.string.pref_autoloaddesc, true);
    }

    public static boolean isRatingWanted() {
        return getBoolean(R.string.pref_ratingwanted, true);
    }

    public static boolean isGeokretyConnectorActive() {
        return getBoolean(R.string.pref_connectorGeokretyActive, false);
    }

    public static boolean isGeokretyCacheActive() {
        return getBoolean(R.string.pref_geokrety_cache, true);
    }

    static boolean hasGeokretyAuthorization() {
        return StringUtils.isNotBlank(getGeokretySecId());
    }

    public static String getGeokretySecId() {
        return getString(R.string.pref_fakekey_geokrety_authorization, null);
    }

    public static void setGeokretySecId(final String secid) {
        putString(R.string.pref_fakekey_geokrety_authorization, secid);
    }

    public static boolean isRegisteredForGeokretyLogging() {
        return getGeokretySecId() != null;
    }

    /**
     * Retrieve showed popup counter for warning about logging Trackable recommend Geocode
     *
     * @return number of times the popup has appeared
     */
    public static int getLogTrackableWithoutGeocodeShowCount() {
        return getInt(R.string.pref_logtrackablewithoutgeocodeshowcount, 0);
    }

    /**
     * Store showed popup counter for warning about logging Trackable recommend Geocode
     *
     * @param showCount the count to save
     */
    public static void setLogTrackableWithoutGeocodeShowCount(final int showCount) {
        putInt(R.string.pref_logtrackablewithoutgeocodeshowcount, showCount);
    }

    public static boolean isFriendLogsWanted() {
        if (!hasGCCredentials()) {
            // don't show a friends log if the user is anonymous
            return false;
        }
        return getBoolean(R.string.pref_friendlogswanted, true);
    }

    public static boolean isLiveList() {
        return getBoolean(R.string.pref_livelist, true);
    }

    public static boolean isTrackableAutoVisit() {
        return getBoolean(R.string.pref_trackautovisit, false);
    }

    public static boolean isAutoInsertSignature() {
        return getBoolean(R.string.pref_sigautoinsert, false);
    }

    static void setUseImperialUnits(final boolean useImperialUnits) {
        putBoolean(R.string.pref_units_imperial, useImperialUnits);
    }

    public static boolean useImperialUnits() {
        return getBoolean(R.string.pref_units_imperial, useImperialUnitsByDefault());
    }

    private static boolean useImperialUnitsByDefault() {
        final String countryCode = Locale.getDefault().getCountry();
        return "US".equals(countryCode)  // USA
            || "LR".equals(countryCode)  // Liberia
            || "MM".equals(countryCode); // Burma
    }

    public static boolean isLiveMap() {
        return getBoolean(R.string.pref_maplive, true);
    }

    public static void setLiveMap(final boolean live) {
        putBoolean(R.string.pref_maplive, live);
    }

    public static boolean isMapTrail() {
        return getBoolean(R.string.pref_maptrail, false);
    }

    public static void setMapTrail(final boolean showTrail) {
        putBoolean(R.string.pref_maptrail, showTrail);
    }

    /**
     * whether to show a direction line on the map
     */
    public static boolean isMapDirection() {
        return getBoolean(R.string.pref_map_direction, true);
    }

    public static void setMapDirection(final boolean showDirection) {
        putBoolean(R.string.pref_map_direction, showDirection);
    }

    /**
     * Get last used zoom of the internal map. Differentiate between two use cases for a map of multiple caches (e.g.
     * live map) and the map of a single cache (which is often zoomed in more deep).
     */
    public static int getMapZoom(final MapMode mapMode) {
        if (mapMode == MapMode.SINGLE || mapMode == MapMode.COORDS) {
            return getCacheZoom();
        }
        return getMapZoom();
    }

    public static void setMapZoom(final MapMode mapMode, final int zoomLevel) {
        if (mapMode == MapMode.SINGLE || mapMode == MapMode.COORDS) {
            setCacheZoom(zoomLevel);
        }
        else {
            setMapZoom(zoomLevel);
        }
    }

    /**
     * @return zoom used for the (live) map
     */
    private static int getMapZoom() {
        return Math.max(getInt(R.string.pref_lastmapzoom, 14), INITIAL_MAP_ZOOM_LIMIT);
    }

    private static void setMapZoom(final int mapZoomLevel) {
        putInt(R.string.pref_lastmapzoom, mapZoomLevel);
    }

    /**
     * @return zoom used for the map of a single cache
     */
    private static int getCacheZoom() {
        return Math.max(getInt(R.string.pref_cache_zoom, 14), INITIAL_MAP_ZOOM_LIMIT);
    }

    private static void setCacheZoom(final int zoomLevel) {
        putInt(R.string.pref_cache_zoom, zoomLevel);
    }

    public static GeoPointImpl getMapCenter() {
        return getMapProvider().getMapItemFactory()
                .getGeoPointBase(new Geopoint(getInt(R.string.pref_lastmaplat, 0) / 1e6,
                        getInt(R.string.pref_lastmaplon, 0) / 1e6));
    }

    public static void setMapCenter(final GeoPointImpl mapViewCenter) {
        putInt(R.string.pref_lastmaplat, mapViewCenter.getLatitudeE6());
        putInt(R.string.pref_lastmaplon, mapViewCenter.getLongitudeE6());
    }

    @NonNull
    public static synchronized MapSource getMapSource() {
        if (mapSource != null) {
            return mapSource;
        }
        final int id = getConvertedMapId();
        mapSource = MapProviderFactory.getMapSource(id);
        if (mapSource != null) {
            // don't use offline maps if the map file is not valid
            if (!(mapSource instanceof OfflineMapSource) || isValidMapFile()) {
                return mapSource;
            }
        }
        // fallback to first available map
        return MapProviderFactory.getDefaultSource();
    }

    private final static int GOOGLEMAP_BASEID = 30;
    private final static int MAP = 1;
    private final static int SATELLITE = 2;

    private final static int MFMAP_BASEID = 40;
    private final static int MAPNIK = 1;
    private final static int CYCLEMAP = 3;
    private final static int OFFLINE = 4;
    private static final int HISTORY_SIZE = 10;

    /**
     * Convert old preference ids for maps (based on constant values) into new hash based ids.
     */
    private static int getConvertedMapId() {
        final int id = Integer.parseInt(getString(R.string.pref_mapsource,
                String.valueOf(MAP_SOURCE_DEFAULT)));
        switch (id) {
            case GOOGLEMAP_BASEID + MAP:
                return GoogleMapProvider.GOOGLE_MAP_ID.hashCode();
            case GOOGLEMAP_BASEID + SATELLITE:
                return GoogleMapProvider.GOOGLE_SATELLITE_ID.hashCode();
            case MFMAP_BASEID + MAPNIK:
                return MapsforgeMapProvider.MAPSFORGE_MAPNIK_ID.hashCode();
            case MFMAP_BASEID + CYCLEMAP:
                return MapsforgeMapProvider.MAPSFORGE_CYCLEMAP_ID.hashCode();
            case MFMAP_BASEID + OFFLINE: {
                final String mapFile = getMapFile();
                if (StringUtils.isNotEmpty(mapFile)) {
                    return mapFile.hashCode();
                }
                break;
            }
            default:
                break;
        }
        return id;
    }

    public static synchronized void setMapSource(final MapSource newMapSource) {
        putString(R.string.pref_mapsource, String.valueOf(newMapSource.getNumericalId()));
        if (newMapSource instanceof OfflineMapSource) {
            setMapFile(((OfflineMapSource) newMapSource).getFileName());
        }
        // cache the value
        mapSource = newMapSource;
    }

    public static void setAnyCoordinates(final Geopoint coords) {
        if (null != coords) {
            putFloat(R.string.pref_anylatitude, (float) coords.getLatitude());
            putFloat(R.string.pref_anylongitude, (float) coords.getLongitude());
        } else {
            remove(R.string.pref_anylatitude);
            remove(R.string.pref_anylongitude);
        }
    }

    public static Geopoint getAnyCoordinates() {
        if (contains(R.string.pref_anylatitude) && contains(R.string.pref_anylongitude)) {
            final float lat = getFloat(R.string.pref_anylatitude, 0);
            final float lon = getFloat(R.string.pref_anylongitude, 0);
            return new Geopoint(lat, lon);
        }
        return null;
    }

    public static boolean isUseCompass() {
        return useCompass;
    }

    public static void setUseCompass(final boolean value) {
        useCompass = value;
    }

    public static boolean isLightSkin() {
        return getBoolean(R.string.pref_skin, false);
    }

    @NonNull
    public static String getTwitterKeyConsumerPublic() {
        return TWITTER_KEY_CONSUMER_PUBLIC;
    }

    @NonNull
    public static String getTwitterKeyConsumerSecret() {
        return TWITTER_KEY_CONSUMER_SECRET;
    }

    public static String getWebDeviceCode() {
        return getString(R.string.pref_webDeviceCode, null);
    }

    public static boolean isRegisteredForSend2cgeo() {
        return getWebDeviceCode() != null;
    }

    static String getWebDeviceName() {
        return getString(R.string.pref_webDeviceName, Build.MODEL);
    }

    /**
     * @return The cache type used for filtering or ALL if no filter is active.
     *         Returns never null
     */
    @NonNull
    public static CacheType getCacheType() {
        return CacheType.getById(getString(R.string.pref_cachetype, CacheType.ALL.id));
    }

    /**
     * The Threshold for the showing of child waypoints
     */
    public static int getWayPointsThreshold() {
        return getInt(R.string.pref_showwaypointsthreshold, SHOW_WP_THRESHOLD_DEFAULT);
    }

    static void setShowWaypointsThreshold(final int threshold) {
        putInt(R.string.pref_showwaypointsthreshold, threshold);
    }

    public static boolean isUseTwitter() {
        return getBoolean(R.string.pref_twitter, false);
    }

    private static void setUseTwitter(final boolean useTwitter) {
        putBoolean(R.string.pref_twitter, useTwitter);
    }

    public static boolean isTwitterLoginValid() {
        return !StringUtils.isBlank(getTokenPublic())
                && !StringUtils.isBlank(getTokenSecret());
    }

    public static String getTokenPublic() {
        return getString(R.string.pref_twitter_token_public, null);
    }

    public static String getTokenSecret() {
        return getString(R.string.pref_twitter_token_secret, null);

    }

    static boolean hasTwitterAuthorization() {
        return StringUtils.isNotBlank(getTokenPublic())
                && StringUtils.isNotBlank(getTokenSecret());
    }

    public static void setTwitterTokens(@Nullable final String tokenPublic,
            @Nullable final String tokenSecret, final boolean enableTwitter) {
        putString(R.string.pref_twitter_token_public, tokenPublic);
        putString(R.string.pref_twitter_token_secret, tokenSecret);
        if (tokenPublic != null) {
            remove(R.string.pref_temp_twitter_token_public);
            remove(R.string.pref_temp_twitter_token_secret);
        }
        setUseTwitter(enableTwitter);
    }

    public static void setTwitterTempTokens(@Nullable final String tokenPublic,
            @Nullable final String tokenSecret) {
        putString(R.string.pref_temp_twitter_token_public, tokenPublic);
        putString(R.string.pref_temp_twitter_token_secret, tokenSecret);
    }

    public static ImmutablePair<String, String> getTempToken() {
        final String tokenPublic = getString(R.string.pref_temp_twitter_token_public, null);
        final String tokenSecret = getString(R.string.pref_temp_twitter_token_secret, null);
        return new ImmutablePair<>(tokenPublic, tokenSecret);
    }

    public static int getVersion() {
        return getInt(R.string.pref_version, 0);
    }

    public static void setVersion(final int version) {
        putInt(R.string.pref_version, version);
    }

    public static boolean isOpenLastDetailsPage() {
        return getBoolean(R.string.pref_opendetailslastpage, false);
    }

    public static int getLastDetailsPage() {
        return getInt(R.string.pref_lastdetailspage, 1);
    }

    public static void setLastDetailsPage(final int index) {
        putInt(R.string.pref_lastdetailspage, index);
    }

    public static int getDefaultNavigationTool() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool,
                String.valueOf(NavigationAppsEnum.COMPASS.id)));
    }

    public static int getDefaultNavigationTool2() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool2,
                String.valueOf(NavigationAppsEnum.INTERNAL_MAP.id)));
    }

    public static LivemapStrategy getLiveMapStrategy() {
        return LivemapStrategy.getById(getInt(R.string.pref_livemapstrategy, LivemapStrategy.AUTO.id));
    }

    public static void setLiveMapStrategy(final LivemapStrategy strategy) {
        putInt(R.string.pref_livemapstrategy, strategy.id);
    }

    public static boolean isDebug() {
        return Log.isDebug();
    }

    public static int getLiveMapHintShowCount() {
        return getInt(R.string.pref_livemaphintshowcount, 0);
    }

    public static void setLiveMapHintShowCount(final int showCount) {
        putInt(R.string.pref_livemaphintshowcount, showCount);
    }

    public static boolean isDbOnSDCard() {
        return getBoolean(R.string.pref_dbonsdcard, false);
    }

    public static void setDbOnSDCard(final boolean dbOnSDCard) {
        putBoolean(R.string.pref_dbonsdcard, dbOnSDCard);
    }

    public static String getGpxExportDir() {
        return getString(R.string.pref_gpxExportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static String getGpxImportDir() {
        return getString(R.string.pref_gpxImportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static boolean getShareAfterExport() {
        return getBoolean(R.string.pref_shareafterexport, true);
    }

    public static void setShareAfterExport(final boolean shareAfterExport) {
        putBoolean(R.string.pref_shareafterexport, shareAfterExport);
    }

    /**
     * Obtain Trackable action from the last Trackable log.
     *
     * @return
     *          The last Trackable Action or RETRIEVED_IT
     */
    public static int getTrackableAction() {
        return getInt(R.string.pref_trackableaction, LogTypeTrackable.RETRIEVED_IT.id);
    }

    /**
     * Save Trackable action from the last Trackable log.
     *
     * @param trackableAction
     *          The Trackable Action to remember
     */
    public static void setTrackableAction(final int trackableAction) {
        putInt(R.string.pref_trackableaction, trackableAction);
    }

    private static String getCustomRenderThemeBaseFolder() {
        return getString(R.string.pref_renderthemepath, "");
    }

    public static String getCustomRenderThemeFilePath() {
        return getString(R.string.pref_renderthemefile, "");
    }

    public static void setCustomRenderThemeFile(final String customRenderThemeFile) {
        putString(R.string.pref_renderthemefile, customRenderThemeFile);
    }

    public static File[] getMapThemeFiles() {
        final File directory = new File(getCustomRenderThemeBaseFolder());
        final List<File> result = new ArrayList<>();
        FileUtils.listDir(result, directory, new ExtensionsBasedFileSelector(new String[] { "xml" }), null);

        return result.toArray(new File[result.size()]);
    }

    private static class ExtensionsBasedFileSelector implements FileSelector {
        private final String[] extensions;
        public ExtensionsBasedFileSelector(final String[] extensions) {
            this.extensions = extensions;
        }
        @Override
        public boolean isSelected(final File file) {
            final String filename = file.getName();
            for (final String ext : extensions) {
                if (StringUtils.endsWithIgnoreCase(filename, ext)) {
                    return true;
                }
            }
            return false;
        }
        @Override
        public boolean shouldEnd() {
            return false;
        }
    }

    /**
     * @return true if plain text log wanted
     */
    public static boolean getPlainLogs() {
        return getBoolean(R.string.pref_plainLogs, false);
    }

    /**
     * Force set the plain text log preference
     *
     * @param plainLogs
     *            wanted or not
     */
    public static void setPlainLogs(final boolean plainLogs) {
        putBoolean(R.string.pref_plainLogs, plainLogs);
    }

    public static boolean getUseNativeUa() {
        return getBoolean(R.string.pref_nativeUa, false);
    }

    @NonNull
    public static String getCacheTwitterMessage() {
        return StringUtils.defaultString(getString(R.string.pref_twitter_cache_message, "I found [NAME] ([URL])."));
    }

    @NonNull
    public static String getTrackableTwitterMessage() {
        return StringUtils.defaultString(getString(R.string.pref_twitter_trackable_message, "I touched [NAME] ([URL])."));
    }

    public static int getLogImageScale() {
        return getInt(R.string.pref_logImageScale, -1);
    }

    public static void setLogImageScale(final int scale) {
        putInt(R.string.pref_logImageScale, scale);
    }

    public static void setExcludeMine(final boolean exclude) {
        putBoolean(R.string.pref_excludemine, exclude);
    }

    static void setLogin(final String username, final String password) {
        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            // erase username and password
            remove(R.string.pref_username);
            remove(R.string.pref_password);
            return;
        }
        // save username and password
        putString(R.string.pref_username, username);
        putString(R.string.pref_password, password);
    }

    public static long getFieldnoteExportDate() {
        return getLong(R.string.pref_fieldNoteExportDate, 0);
    }

    /**
     * Remember date of last field note export.
     */
    public static void setFieldnoteExportDate(final long date) {
        putLong(R.string.pref_fieldNoteExportDate, date);
    }

    public static boolean isUseNavigationApp(final NavigationAppsEnum navApp) {
        return getBoolean(navApp.preferenceKey, true);
    }

    /**
     * Remember the state of the "Upload" checkbox in the field notes export dialog.
     */
    public static void setFieldNoteExportUpload(final boolean upload) {
        putBoolean(R.string.pref_fieldNoteExportUpload, upload);
    }

    public static boolean getFieldNoteExportUpload() {
        return getBoolean(R.string.pref_fieldNoteExportUpload, true);
    }

    /**
     * Remember the state of the "Only new" checkbox in the field notes export dialog.
     */
    public static void setFieldNoteExportOnlyNew(final boolean onlyNew) {
        putBoolean(R.string.pref_fieldNoteExportOnlyNew, onlyNew);
    }

    public static boolean getFieldNoteExportOnlyNew() {
        return getBoolean(R.string.pref_fieldNoteExportOnlyNew, false);
    }

    public static String getECIconSet() {
        return getString(R.string.pref_ec_icons, "1");
    }

    /* Store last checksum of changelog for changelog display */
    public static long getLastChangelogChecksum() {
        return getLong(R.string.pref_changelog_last_checksum, 0);
    }

    public static void setLastChangelogChecksum(final long checksum) {
        putLong(R.string.pref_changelog_last_checksum, checksum);
    }

    public static List<String> getLastOpenedCaches() {
        final List<String> history = Arrays.asList(StringUtils.split(getString(R.string.pref_caches_history, StringUtils.EMPTY), HISTORY_SEPARATOR));
        return history.subList(0, Math.min(HISTORY_SIZE, history.size()));
    }

    public static void addCacheToHistory(@NonNull final String geocode) {
        final List<String> history = new ArrayList<>(getLastOpenedCaches());
        // bring entry to front, if it already existed
        history.remove(geocode);
        history.add(0, geocode);
        putString(R.string.pref_caches_history, StringUtils.join(history, HISTORY_SEPARATOR));
    }

    public static boolean useHardwareAcceleration() {
        return getBoolean(R.string.pref_hardware_acceleration, !HW_ACCEL_DISABLED_BY_DEFAULT);
    }

    static void setUseHardwareAcceleration(final boolean useHardwareAcceleration) {
        putBoolean(R.string.pref_hardware_acceleration, useHardwareAcceleration);
    }

    public static String getLastCacheLog() {
        return getString(R.string.pref_last_cache_log, StringUtils.EMPTY);
    }

    public static void setLastCacheLog(final String log) {
        putString(R.string.pref_last_cache_log, log);
    }

    public static String getLastTrackableLog() {
        return getString(R.string.pref_last_trackable_log, StringUtils.EMPTY);
    }

    public static void setLastTrackableLog(final String log) {
        putString(R.string.pref_last_trackable_log, log);
    }

    @Nullable
    public static String getHomeLocation() {
        return getString(R.string.pref_home_location, null);
    }

    public static void setHomeLocation(@NonNull final String homeLocation) {
        putString(R.string.pref_home_location, homeLocation);
    }

    public static void setForceOrientationSensor(final boolean forceOrientationSensor) {
        putBoolean(R.string.pref_force_orientation_sensor, forceOrientationSensor);
    }

    public static boolean useOrientationSensor(final Context context) {
        return OrientationProvider.hasOrientationSensor(context) && (getBoolean(R.string.pref_force_orientation_sensor, false) || !RotationProvider.hasRotationSensor(context));
    }
}
!@#$%
20190527_011221,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_a18448
package cgeo.geocaching.settings;

import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.R;
import cgeo.geocaching.apps.navi.NavigationAppFactory.NavigationAppsEnum;
import cgeo.geocaching.connector.capability.ICredentials;
import cgeo.geocaching.connector.gc.GCConnector;
import cgeo.geocaching.connector.gc.GCConstants;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.LogTypeTrackable;
import cgeo.geocaching.list.StoredList;
import cgeo.geocaching.location.Geopoint;
import cgeo.geocaching.maps.CGeoMap.MapMode;
import cgeo.geocaching.maps.LivemapStrategy;
import cgeo.geocaching.maps.MapProviderFactory;
import cgeo.geocaching.maps.google.v1.GoogleMapProvider;
import cgeo.geocaching.maps.interfaces.GeoPointImpl;
import cgeo.geocaching.maps.interfaces.MapProvider;
import cgeo.geocaching.maps.interfaces.MapSource;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider.OfflineMapSource;
import cgeo.geocaching.sensors.OrientationProvider;
import cgeo.geocaching.sensors.RotationProvider;
import cgeo.geocaching.utils.CryptUtils;
import cgeo.geocaching.utils.FileUtils;
import cgeo.geocaching.utils.FileUtils.FileSelector;
import cgeo.geocaching.utils.Log;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.os.Build;
import android.os.Build.VERSION;
import android.os.Build.VERSION_CODES;
import android.os.Environment;
import android.preference.PreferenceManager;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;

/**
 * General c:geo preferences/settings set by the user
 */
public class Settings {

    /**
     * On opening a map, we limit the _initial_ zoom. The user can still zoom out afterwards.
     */
    private static final int INITIAL_MAP_ZOOM_LIMIT = 16;
    private static final char HISTORY_SEPARATOR = ',';
    private static final int SHOW_WP_THRESHOLD_DEFAULT = 10;
    public static final int SHOW_WP_THRESHOLD_MAX = 50;
    private static final int MAP_SOURCE_DEFAULT = GoogleMapProvider.GOOGLE_MAP_ID.hashCode();

    public static final boolean HW_ACCEL_DISABLED_BY_DEFAULT =
            Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1 ||
            StringUtils.equals(Build.MODEL, "HTC One X") ||    // HTC One X
            StringUtils.equals(Build.MODEL, "HTC One S") ||    // HTC One S
            StringUtils.equals(Build.MODEL, "GT-I8190")  ||    // Samsung S3 mini
            StringUtils.equals(Build.MODEL, "GT-S6310L") ||    // Samsung Galaxy Young
            StringUtils.equals(Build.MODEL, "GT-P5210")  ||    // Samsung Galaxy Tab 3
            StringUtils.equals(Build.MODEL, "GT-S7580")  ||    // Samsung Galaxy Trend Plus
            StringUtils.equals(Build.MODEL, "GT-I9105P") ||    // Samsung Galaxy SII Plus
            StringUtils.equals(Build.MODEL, "ST25i")     ||    // Sony Xperia U
            StringUtils.equals(Build.MODEL, "bq Aquaris 5") || // bq Aquaris 5
            StringUtils.equals(Build.MODEL, "A1-810")    ||    // Unknown A1-810
            StringUtils.equals(Build.MODEL, "GT-I9195")  ||    // Samsung S4 mini
            StringUtils.equals(Build.MODEL, "GT-I8200N");      // Samsung S3 mini

    // twitter api keys
    private final static @NonNull String TWITTER_KEY_CONSUMER_PUBLIC = CryptUtils.rot13("ESnsCvAv3kEupF1GCR3jGj");
    private final static @NonNull String TWITTER_KEY_CONSUMER_SECRET = CryptUtils.rot13("7vQWceACV9umEjJucmlpFe9FCMZSeqIqfkQ2BnhV9x");

    private static boolean useCompass = true;

    public enum CoordInputFormatEnum {
        Plain,
        Deg,
        Min,
        Sec;

        static final int DEFAULT_INT_VALUE = Min.ordinal();

        public static CoordInputFormatEnum fromInt(final int id) {
            final CoordInputFormatEnum[] values = CoordInputFormatEnum.values();
            if (id < 0 || id >= values.length) {
                return Min;
            }
            return values[id];
        }
    }

    private static final SharedPreferences sharedPrefs = PreferenceManager
            .getDefaultSharedPreferences(CgeoApplication.getInstance().getBaseContext());
    static {
        migrateSettings();
        final boolean isDebug = sharedPrefs.getBoolean(getKey(R.string.pref_debug), false);
        Log.setDebug(isDebug);
        CgeoApplication.dumpOnOutOfMemory(isDebug);
    }

    /**
     * Cache the mapsource locally. If that is an offline map source, each request would potentially access the
     * underlying map file, leading to delays.
     */
    private static MapSource mapSource;

    protected Settings() {
        throw new InstantiationError();
    }

    private static void migrateSettings() {
        final int LATEST_PREFERENCES_VERSION = 2;
        final int currentVersion = getInt(R.string.pref_settingsversion, 0);

        // No need to migrate if we are up to date.
        if (currentVersion == LATEST_PREFERENCES_VERSION) {
            return;
        }

        // No need to migrate if we don't have older settings, defaults will be used instead.
        final String preferencesNameV0 = "cgeo.pref";
        final SharedPreferences prefsV0 = CgeoApplication.getInstance().getSharedPreferences(preferencesNameV0, Context.MODE_PRIVATE);
        if (currentVersion == 0 && prefsV0.getAll().isEmpty()) {
            final Editor e = sharedPrefs.edit();
            e.putInt(getKey(R.string.pref_settingsversion), LATEST_PREFERENCES_VERSION);
            e.apply();
            return;
        }

        if (currentVersion < 1) {
            // migrate from non standard file location and integer based boolean types
            final Editor e = sharedPrefs.edit();

            e.putString(getKey(R.string.pref_temp_twitter_token_secret), prefsV0.getString(getKey(R.string.pref_temp_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_temp_twitter_token_public), prefsV0.getString(getKey(R.string.pref_temp_twitter_token_public), null));
            e.putBoolean(getKey(R.string.pref_help_shown), prefsV0.getInt(getKey(R.string.pref_help_shown), 0) != 0);
            e.putFloat(getKey(R.string.pref_anylongitude), prefsV0.getFloat(getKey(R.string.pref_anylongitude), 0));
            e.putFloat(getKey(R.string.pref_anylatitude), prefsV0.getFloat(getKey(R.string.pref_anylatitude), 0));
            e.putBoolean(getKey(R.string.pref_offlinemaps), 0 != prefsV0.getInt(getKey(R.string.pref_offlinemaps), 1));
            e.putBoolean(getKey(R.string.pref_offlinewpmaps), 0 != prefsV0.getInt(getKey(R.string.pref_offlinewpmaps), 0));
            e.putString(getKey(R.string.pref_webDeviceCode), prefsV0.getString(getKey(R.string.pref_webDeviceCode), null));
            e.putString(getKey(R.string.pref_webDeviceName), prefsV0.getString(getKey(R.string.pref_webDeviceName), null));
            e.putBoolean(getKey(R.string.pref_maplive), prefsV0.getInt(getKey(R.string.pref_maplive), 1) != 0);
            e.putInt(getKey(R.string.pref_mapsource), prefsV0.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT));
            e.putBoolean(getKey(R.string.pref_twitter), 0 != prefsV0.getInt(getKey(R.string.pref_twitter), 0));
            e.putBoolean(getKey(R.string.pref_showaddress), 0 != prefsV0.getInt(getKey(R.string.pref_showaddress), 1));
            e.putBoolean(getKey(R.string.pref_showcaptcha), prefsV0.getBoolean(getKey(R.string.pref_showcaptcha), false));
            e.putBoolean(getKey(R.string.pref_maptrail), prefsV0.getInt(getKey(R.string.pref_maptrail), 1) != 0);
            e.putInt(getKey(R.string.pref_lastmapzoom), prefsV0.getInt(getKey(R.string.pref_lastmapzoom), 14));
            e.putBoolean(getKey(R.string.pref_livelist), 0 != prefsV0.getInt(getKey(R.string.pref_livelist), 1));
            e.putBoolean(getKey(R.string.pref_units_imperial), prefsV0.getInt(getKey(R.string.pref_units_imperial), 1) != 1);
            e.putBoolean(getKey(R.string.pref_skin), prefsV0.getInt(getKey(R.string.pref_skin), 0) != 0);
            e.putInt(getKey(R.string.pref_lastusedlist), prefsV0.getInt(getKey(R.string.pref_lastusedlist), StoredList.STANDARD_LIST_ID));
            e.putString(getKey(R.string.pref_cachetype), prefsV0.getString(getKey(R.string.pref_cachetype), CacheType.ALL.id));
            e.putString(getKey(R.string.pref_twitter_token_secret), prefsV0.getString(getKey(R.string.pref_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_twitter_token_public), prefsV0.getString(getKey(R.string.pref_twitter_token_public), null));
            e.putInt(getKey(R.string.pref_version), prefsV0.getInt(getKey(R.string.pref_version), 0));
            e.putBoolean(getKey(R.string.pref_autoloaddesc), 0 != prefsV0.getInt(getKey(R.string.pref_autoloaddesc), 1));
            e.putBoolean(getKey(R.string.pref_ratingwanted), prefsV0.getBoolean(getKey(R.string.pref_ratingwanted), true));
            e.putBoolean(getKey(R.string.pref_friendlogswanted), prefsV0.getBoolean(getKey(R.string.pref_friendlogswanted), true));
            e.putBoolean(getKey(R.string.pref_useenglish), prefsV0.getBoolean(getKey(R.string.pref_useenglish), false));
            e.putBoolean(getKey(R.string.pref_usecompass), 0 != prefsV0.getInt(getKey(R.string.pref_usecompass), 1));
            e.putBoolean(getKey(R.string.pref_trackautovisit), prefsV0.getBoolean(getKey(R.string.pref_trackautovisit), false));
            e.putBoolean(getKey(R.string.pref_sigautoinsert), prefsV0.getBoolean(getKey(R.string.pref_sigautoinsert), false));
            e.putBoolean(getKey(R.string.pref_logimages), prefsV0.getBoolean(getKey(R.string.pref_logimages), false));
            e.putBoolean(getKey(R.string.pref_excludedisabled), 0 != prefsV0.getInt(getKey(R.string.pref_excludedisabled), 0));
            e.putBoolean(getKey(R.string.pref_excludemine), 0 != prefsV0.getInt(getKey(R.string.pref_excludemine), 0));
            e.putString(getKey(R.string.pref_mapfile), prefsV0.getString(getKey(R.string.pref_mapfile), null));
            e.putString(getKey(R.string.pref_signature), prefsV0.getString(getKey(R.string.pref_signature), null));
            e.putString(getKey(R.string.pref_pass_vote), prefsV0.getString(getKey(R.string.pref_pass_vote), null));
            e.putString(getKey(R.string.pref_password), prefsV0.getString(getKey(R.string.pref_password), null));
            e.putString(getKey(R.string.pref_username), prefsV0.getString(getKey(R.string.pref_username), null));
            e.putString(getKey(R.string.pref_memberstatus), prefsV0.getString(getKey(R.string.pref_memberstatus), ""));
            e.putInt(getKey(R.string.pref_coordinputformat), prefsV0.getInt(getKey(R.string.pref_coordinputformat), CoordInputFormatEnum.DEFAULT_INT_VALUE));
            e.putBoolean(getKey(R.string.pref_log_offline), prefsV0.getBoolean(getKey(R.string.pref_log_offline), false));
            e.putBoolean(getKey(R.string.pref_choose_list), prefsV0.getBoolean(getKey(R.string.pref_choose_list), true));
            e.putBoolean(getKey(R.string.pref_loaddirectionimg), prefsV0.getBoolean(getKey(R.string.pref_loaddirectionimg), true));
            e.putString(getKey(R.string.pref_gccustomdate), prefsV0.getString(getKey(R.string.pref_gccustomdate), GCConstants.DEFAULT_GC_DATE));
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), prefsV0.getInt(getKey(R.string.pref_showwaypointsthreshold), SHOW_WP_THRESHOLD_DEFAULT));
            e.putString(getKey(R.string.pref_cookiestore), prefsV0.getString(getKey(R.string.pref_cookiestore), null));
            e.putBoolean(getKey(R.string.pref_opendetailslastpage), prefsV0.getBoolean(getKey(R.string.pref_opendetailslastpage), false));
            e.putInt(getKey(R.string.pref_lastdetailspage), prefsV0.getInt(getKey(R.string.pref_lastdetailspage), 1));
            e.putInt(getKey(R.string.pref_defaultNavigationTool), prefsV0.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id));
            e.putInt(getKey(R.string.pref_defaultNavigationTool2), prefsV0.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id));
            e.putInt(getKey(R.string.pref_livemapstrategy), prefsV0.getInt(getKey(R.string.pref_livemapstrategy), LivemapStrategy.AUTO.id));
            e.putBoolean(getKey(R.string.pref_debug), prefsV0.getBoolean(getKey(R.string.pref_debug), false));
            e.putInt(getKey(R.string.pref_livemaphintshowcount), prefsV0.getInt(getKey(R.string.pref_livemaphintshowcount), 0));

            e.putInt(getKey(R.string.pref_settingsversion), 1); // mark migrated
            e.apply();
        }

        // changes for new settings dialog
        if (currentVersion < 2) {
            final Editor e = sharedPrefs.edit();

            e.putBoolean(getKey(R.string.pref_units_imperial), useImperialUnits());

            // show waypoints threshold now as a slider
            int wpThreshold = getWayPointsThreshold();
            if (wpThreshold < 0) {
                wpThreshold = 0;
            } else if (wpThreshold > SHOW_WP_THRESHOLD_MAX) {
                wpThreshold = SHOW_WP_THRESHOLD_MAX;
            }
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), wpThreshold);

            // KEY_MAP_SOURCE must be string, because it is the key for a ListPreference now
            final int ms = sharedPrefs.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT);
            e.remove(getKey(R.string.pref_mapsource));
            e.putString(getKey(R.string.pref_mapsource), String.valueOf(ms));

            // navigation tool ids must be string, because ListPreference uses strings as keys
            final int dnt1 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id);
            final int dnt2 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id);
            e.remove(getKey(R.string.pref_defaultNavigationTool));
            e.remove(getKey(R.string.pref_defaultNavigationTool2));
            e.putString(getKey(R.string.pref_defaultNavigationTool), String.valueOf(dnt1));
            e.putString(getKey(R.string.pref_defaultNavigationTool2), String.valueOf(dnt2));

            // defaults for gpx directories
            e.putString(getKey(R.string.pref_gpxImportDir), getGpxImportDir());
            e.putString(getKey(R.string.pref_gpxExportDir), getGpxExportDir());

            e.putInt(getKey(R.string.pref_settingsversion), 2); // mark migrated
            e.apply();
        }
    }

    private static String getKey(final int prefKeyId) {
        return CgeoApplication.getInstance().getString(prefKeyId);
    }

    static String getString(final int prefKeyId, final String defaultValue) {
        return sharedPrefs.getString(getKey(prefKeyId), defaultValue);
    }

    private static int getInt(final int prefKeyId, final int defaultValue) {
        return sharedPrefs.getInt(getKey(prefKeyId), defaultValue);
    }

    private static long getLong(final int prefKeyId, final long defaultValue) {
        return sharedPrefs.getLong(getKey(prefKeyId), defaultValue);
    }

    private static boolean getBoolean(final int prefKeyId, final boolean defaultValue) {
        return sharedPrefs.getBoolean(getKey(prefKeyId), defaultValue);
    }

    private static float getFloat(final int prefKeyId, final float defaultValue) {
        return sharedPrefs.getFloat(getKey(prefKeyId), defaultValue);
    }

    protected static void putString(final int prefKeyId, final String value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putString(getKey(prefKeyId), value);
        edit.apply();
    }

    protected static void putBoolean(final int prefKeyId, final boolean value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putBoolean(getKey(prefKeyId), value);
        edit.apply();
    }

    private static void putInt(final int prefKeyId, final int value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putInt(getKey(prefKeyId), value);
        edit.apply();
    }

    private static void putLong(final int prefKeyId, final long value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putLong(getKey(prefKeyId), value);
        edit.apply();
    }

    private static void putFloat(final int prefKeyId, final float value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putFloat(getKey(prefKeyId), value);
        edit.apply();
    }

    private static void remove(final int prefKeyId) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.remove(getKey(prefKeyId));
        edit.apply();
    }

    private static boolean contains(final int prefKeyId) {
        return sharedPrefs.contains(getKey(prefKeyId));
    }

    public static boolean hasGCCredentials() {
        final String preUsername = getString(R.string.pref_username, null);
        final String prePassword = getString(R.string.pref_password, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    /**
     * Get login and password information of Geocaching.com.
     *
     * @return a pair either with (login, password) or (empty, empty) if no valid information is stored
     */
    public static ImmutablePair<String, String> getGcCredentials() {
        return getCredentials(GCConnector.getInstance());
    }

    /**
     * Get login and password information.
     *
     * @return a pair either with (login, password) or (empty, empty) if no valid information is stored
     */
    @NonNull
    public static ImmutablePair<String, String> getCredentials(final @NonNull ICredentials connector) {
        final String username = getString(connector.getUsernamePreferenceKey(), null);
        final String password = getString(connector.getPasswordPreferenceKey(), null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return new ImmutablePair<>(StringUtils.EMPTY, StringUtils.EMPTY);
        }

        return new ImmutablePair<>(username, password);
    }

    public static String getUsername() {
        return getString(R.string.pref_username, StringUtils.EMPTY);
    }

    public static boolean isGCConnectorActive() {
        return getBoolean(R.string.pref_connectorGCActive, true);
    }

    public static boolean isECConnectorActive() {
        return getBoolean(R.string.pref_connectorECActive, false);
    }

    public static boolean isGCPremiumMember() {
        final String memberStatus = getGCMemberStatus();
        return StringUtils.equalsIgnoreCase(memberStatus, GCConstants.MEMBER_STATUS_PREMIUM) ||
                StringUtils.equalsIgnoreCase(memberStatus, GCConstants.MEMBER_STATUS_CHARTER);
    }

    public static String getGCMemberStatus() {
        return getString(R.string.pref_memberstatus, "");
    }

    public static void setGCMemberStatus(final String memberStatus) {
        if (StringUtils.isBlank(memberStatus)) {
            remove(R.string.pref_memberstatus);
        }
        putString(R.string.pref_memberstatus, memberStatus);
    }

    public static ImmutablePair<String, String> getTokenPair(final int tokenPublicPrefKey, final int tokenSecretPrefKey) {
        return new ImmutablePair<>(getString(tokenPublicPrefKey, null), getString(tokenSecretPrefKey, null));
    }

    public static void setTokens(final int tokenPublicPrefKey, @Nullable final String tokenPublic, final int tokenSecretPrefKey, @Nullable final String tokenSecret) {
        if (tokenPublic == null) {
            remove(tokenPublicPrefKey);
        } else {
            putString(tokenPublicPrefKey, tokenPublic);
        }
        if (tokenSecret == null) {
            remove(tokenSecretPrefKey);
        } else {
            putString(tokenSecretPrefKey, tokenSecret);
        }
    }

    public static boolean isOCConnectorActive(final int isActivePrefKeyId) {
        return getBoolean(isActivePrefKeyId, false);
    }

    public static boolean hasOCAuthorization(final int tokenPublicPrefKeyId, final int tokenSecretPrefKeyId) {
        return StringUtils.isNotBlank(getString(tokenPublicPrefKeyId, ""))
                && StringUtils.isNotBlank(getString(tokenSecretPrefKeyId, ""));
    }

    public static boolean isGCVoteLogin() {
        return StringUtils.isNotBlank(getGCVoteLogin().left);
    }

    public static ImmutablePair<String, String> getGCVoteLogin() {
        final String username = getString(R.string.pref_username, null);
        final String password = getString(R.string.pref_pass_vote, null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return new ImmutablePair<>(StringUtils.EMPTY, StringUtils.EMPTY);
        }

        return new ImmutablePair<>(username, password);
    }

    @NonNull
    public static String getSignature() {
        return StringUtils.defaultString(getString(R.string.pref_signature, StringUtils.EMPTY));
    }

    public static void setCookieStore(final String cookies) {
        if (StringUtils.isBlank(cookies)) {
            // erase cookies
            remove(R.string.pref_cookiestore);
        }
        // save cookies
        putString(R.string.pref_cookiestore, cookies);
    }

    public static String getCookieStore() {
        return getString(R.string.pref_cookiestore, null);
    }

    public static void setUseGooglePlayServices(final boolean value) {
        putBoolean(R.string.pref_googleplayservices, value);
    }

    public static boolean useGooglePlayServices() {
        // By defaut, enable play services starting from ICS.
        return CgeoApplication.getInstance().isGooglePlayServicesAvailable() &&
                getBoolean(R.string.pref_googleplayservices, VERSION.SDK_INT >= VERSION_CODES.ICE_CREAM_SANDWICH);
    }

    public static boolean useLowPowerMode() {
        return getBoolean(R.string.pref_lowpowermode, false);
    }

    /**
     * @param cacheType
     *            The cache type used for future filtering
     */
    public static void setCacheType(final CacheType cacheType) {
        if (cacheType == null) {
            remove(R.string.pref_cachetype);
        } else {
            putString(R.string.pref_cachetype, cacheType.id);
        }
    }

    public static int getLastList() {
        return getInt(R.string.pref_lastusedlist, StoredList.STANDARD_LIST_ID);
    }

    public static void saveLastList(final int listId) {
        putInt(R.string.pref_lastusedlist, listId);
    }

    public static void setWebNameCode(final String name, final String code) {
        putString(R.string.pref_webDeviceName, name);
        putString(R.string.pref_webDeviceCode, code);
    }

    public static MapProvider getMapProvider() {
        return getMapSource().getMapProvider();
    }

    public static String getMapFile() {
        return getString(R.string.pref_mapfile, null);
    }

    static void setMapFile(final String mapFile) {
        putString(R.string.pref_mapfile, mapFile);
        if (mapFile != null) {
            setMapFileDirectory(new File(mapFile).getParent());
        }
    }

    public static String getMapFileDirectory() {
        final String mapDir = getString(R.string.pref_mapDirectory, null);
        if (mapDir != null) {
            return mapDir;
        }
        final String mapFile = getMapFile();
        if (mapFile != null) {
            return new File(mapFile).getParent();
        }
        return null;
    }

    static void setMapFileDirectory(final String mapFileDirectory) {
        putString(R.string.pref_mapDirectory, mapFileDirectory);
        MapsforgeMapProvider.getInstance().updateOfflineMaps();
    }

    private static boolean isValidMapFile() {
        return isValidMapFile(getMapFile());
    }

    public static boolean isValidMapFile(final String mapFileIn) {
        return MapsforgeMapProvider.isValidMapFile(mapFileIn);
    }

    public static boolean isScaleMapsforgeText() {
        return getBoolean(R.string.pref_mapsforge_scale_text, true);
    }

    public static CoordInputFormatEnum getCoordInputFormat() {
        return CoordInputFormatEnum.fromInt(getInt(R.string.pref_coordinputformat, CoordInputFormatEnum.DEFAULT_INT_VALUE));
    }

    public static void setCoordInputFormat(final CoordInputFormatEnum format) {
        putInt(R.string.pref_coordinputformat, format.ordinal());
    }

    public static boolean getLogOffline() {
        return getBoolean(R.string.pref_log_offline, false);
    }

    public static boolean getChooseList() {
        return getBoolean(R.string.pref_choose_list, false);
    }

    public static boolean getLoadDirImg() {
        return !isGCPremiumMember() && getBoolean(R.string.pref_loaddirectionimg, true);
    }

    public static void setGcCustomDate(final String format) {
        putString(R.string.pref_gccustomdate, format);
    }

    /**
     * @return User selected date format on GC.com
     */
    public static String getGcCustomDate() {
        // We might have some users whose stored value is null, which is invalid. In this case, we use the default.
        return StringUtils.defaultString(getString(R.string.pref_gccustomdate, GCConstants.DEFAULT_GC_DATE),
                GCConstants.DEFAULT_GC_DATE);
    }

    public static boolean isExcludeMyCaches() {
        return getBoolean(R.string.pref_excludemine, false);
    }

    public static boolean useEnglish() {
        return getBoolean(R.string.pref_useenglish, false);
    }

    public static boolean isShowAddress() {
        return getBoolean(R.string.pref_showaddress, true);
    }

    public static boolean isShowCaptcha() {
        return !isGCPremiumMember() && getBoolean(R.string.pref_showcaptcha, false);
    }

    public static boolean isExcludeDisabledCaches() {
        return getBoolean(R.string.pref_excludedisabled, false);
    }

    public static boolean isStoreOfflineMaps() {
        return getBoolean(R.string.pref_offlinemaps, true);
    }

    public static boolean isStoreOfflineWpMaps() {
        return getBoolean(R.string.pref_offlinewpmaps, false);
    }

    public static boolean isStoreLogImages() {
        return getBoolean(R.string.pref_logimages, false);
    }

    public static boolean isAutoLoadDescription() {
        return getBoolean(R.string.pref_autoloaddesc, true);
    }

    public static boolean isRatingWanted() {
        return getBoolean(R.string.pref_ratingwanted, true);
    }

    public static boolean isGeokretyConnectorActive() {
        return getBoolean(R.string.pref_connectorGeokretyActive, false);
    }

    public static boolean isGeokretyCacheActive() {
        return getBoolean(R.string.pref_geokrety_cache, true);
    }

    static boolean hasGeokretyAuthorization() {
        return StringUtils.isNotBlank(getGeokretySecId());
    }

    public static String getGeokretySecId() {
        return getString(R.string.pref_fakekey_geokrety_authorization, null);
    }

    public static void setGeokretySecId(final String secid) {
        putString(R.string.pref_fakekey_geokrety_authorization, secid);
    }

    public static boolean isRegisteredForGeokretyLogging() {
        return getGeokretySecId() != null;
    }

    /**
     * Retrieve showed popup counter for warning about logging Trackable recommend Geocode
     *
     * @return number of times the popup has appeared
     */
    public static int getLogTrackableWithoutGeocodeShowCount() {
        return getInt(R.string.pref_logtrackablewithoutgeocodeshowcount, 0);
    }

    /**
     * Store showed popup counter for warning about logging Trackable recommend Geocode
     *
     * @param showCount the count to save
     */
    public static void setLogTrackableWithoutGeocodeShowCount(final int showCount) {
        putInt(R.string.pref_logtrackablewithoutgeocodeshowcount, showCount);
    }

    public static boolean isFriendLogsWanted() {
        if (!hasGCCredentials()) {
            // don't show a friends log if the user is anonymous
            return false;
        }
        return getBoolean(R.string.pref_friendlogswanted, true);
    }

    public static boolean isLiveList() {
        return getBoolean(R.string.pref_livelist, true);
    }

    public static boolean isTrackableAutoVisit() {
        return getBoolean(R.string.pref_trackautovisit, false);
    }

    public static boolean isAutoInsertSignature() {
        return getBoolean(R.string.pref_sigautoinsert, false);
    }

    static void setUseImperialUnits(final boolean useImperialUnits) {
        putBoolean(R.string.pref_units_imperial, useImperialUnits);
    }

    public static boolean useImperialUnits() {
        return getBoolean(R.string.pref_units_imperial, useImperialUnitsByDefault());
    }

    private static boolean useImperialUnitsByDefault() {
        final String countryCode = Locale.getDefault().getCountry();
        return "US".equals(countryCode)  // USA
            || "LR".equals(countryCode)  // Liberia
            || "MM".equals(countryCode); // Burma
    }

    public static boolean isLiveMap() {
        return getBoolean(R.string.pref_maplive, true);
    }

    public static void setLiveMap(final boolean live) {
        putBoolean(R.string.pref_maplive, live);
    }

    public static boolean isMapTrail() {
        return getBoolean(R.string.pref_maptrail, false);
    }

    public static void setMapTrail(final boolean showTrail) {
        putBoolean(R.string.pref_maptrail, showTrail);
    }

    /**
     * whether to show a direction line on the map
     */
    public static boolean isMapDirection() {
        return getBoolean(R.string.pref_map_direction, true);
    }

    public static void setMapDirection(final boolean showDirection) {
        putBoolean(R.string.pref_map_direction, showDirection);
    }

    /**
     * Get last used zoom of the internal map. Differentiate between two use cases for a map of multiple caches (e.g.
     * live map) and the map of a single cache (which is often zoomed in more deep).
     */
    public static int getMapZoom(final MapMode mapMode) {
        if (mapMode == MapMode.SINGLE || mapMode == MapMode.COORDS) {
            return getCacheZoom();
        }
        return getMapZoom();
    }

    public static void setMapZoom(final MapMode mapMode, final int zoomLevel) {
        if (mapMode == MapMode.SINGLE || mapMode == MapMode.COORDS) {
            setCacheZoom(zoomLevel);
        }
        else {
            setMapZoom(zoomLevel);
        }
    }

    /**
     * @return zoom used for the (live) map
     */
    private static int getMapZoom() {
        return Math.max(getInt(R.string.pref_lastmapzoom, 14), INITIAL_MAP_ZOOM_LIMIT);
    }

    private static void setMapZoom(final int mapZoomLevel) {
        putInt(R.string.pref_lastmapzoom, mapZoomLevel);
    }

    /**
     * @return zoom used for the map of a single cache
     */
    private static int getCacheZoom() {
        return Math.max(getInt(R.string.pref_cache_zoom, 14), INITIAL_MAP_ZOOM_LIMIT);
    }

    private static void setCacheZoom(final int zoomLevel) {
        putInt(R.string.pref_cache_zoom, zoomLevel);
    }

    public static GeoPointImpl getMapCenter() {
        return getMapProvider().getMapItemFactory()
                .getGeoPointBase(new Geopoint(getInt(R.string.pref_lastmaplat, 0) / 1e6,
                        getInt(R.string.pref_lastmaplon, 0) / 1e6));
    }

    public static void setMapCenter(final GeoPointImpl mapViewCenter) {
        putInt(R.string.pref_lastmaplat, mapViewCenter.getLatitudeE6());
        putInt(R.string.pref_lastmaplon, mapViewCenter.getLongitudeE6());
    }

    @NonNull
    public static synchronized MapSource getMapSource() {
        if (mapSource != null) {
            return mapSource;
        }
        final int id = getConvertedMapId();
        mapSource = MapProviderFactory.getMapSource(id);
        if (mapSource != null) {
            // don't use offline maps if the map file is not valid
            if (!(mapSource instanceof OfflineMapSource) || isValidMapFile()) {
                return mapSource;
            }
        }
        // fallback to first available map
        return MapProviderFactory.getDefaultSource();
    }

    private final static int GOOGLEMAP_BASEID = 30;
    private final static int MAP = 1;
    private final static int SATELLITE = 2;

    private final static int MFMAP_BASEID = 40;
    private final static int MAPNIK = 1;
    private final static int CYCLEMAP = 3;
    private final static int OFFLINE = 4;
    private static final int HISTORY_SIZE = 10;

    /**
     * Convert old preference ids for maps (based on constant values) into new hash based ids.
     */
    private static int getConvertedMapId() {
        final int id = Integer.parseInt(getString(R.string.pref_mapsource,
                String.valueOf(MAP_SOURCE_DEFAULT)));
        switch (id) {
            case GOOGLEMAP_BASEID + MAP:
                return GoogleMapProvider.GOOGLE_MAP_ID.hashCode();
            case GOOGLEMAP_BASEID + SATELLITE:
                return GoogleMapProvider.GOOGLE_SATELLITE_ID.hashCode();
            case MFMAP_BASEID + MAPNIK:
                return MapsforgeMapProvider.MAPSFORGE_MAPNIK_ID.hashCode();
            case MFMAP_BASEID + CYCLEMAP:
                return MapsforgeMapProvider.MAPSFORGE_CYCLEMAP_ID.hashCode();
            case MFMAP_BASEID + OFFLINE: {
                final String mapFile = getMapFile();
                if (StringUtils.isNotEmpty(mapFile)) {
                    return mapFile.hashCode();
                }
                break;
            }
            default:
                break;
        }
        return id;
    }

    public static synchronized void setMapSource(final MapSource newMapSource) {
        putString(R.string.pref_mapsource, String.valueOf(newMapSource.getNumericalId()));
        if (newMapSource instanceof OfflineMapSource) {
            setMapFile(((OfflineMapSource) newMapSource).getFileName());
        }
        // cache the value
        mapSource = newMapSource;
    }

    public static void setAnyCoordinates(final Geopoint coords) {
        if (null != coords) {
            putFloat(R.string.pref_anylatitude, (float) coords.getLatitude());
            putFloat(R.string.pref_anylongitude, (float) coords.getLongitude());
        } else {
            remove(R.string.pref_anylatitude);
            remove(R.string.pref_anylongitude);
        }
    }

    public static Geopoint getAnyCoordinates() {
        if (contains(R.string.pref_anylatitude) && contains(R.string.pref_anylongitude)) {
            final float lat = getFloat(R.string.pref_anylatitude, 0);
            final float lon = getFloat(R.string.pref_anylongitude, 0);
            return new Geopoint(lat, lon);
        }
        return null;
    }

    public static boolean isUseCompass() {
        return useCompass;
    }

    public static void setUseCompass(final boolean value) {
        useCompass = value;
    }

    public static boolean isLightSkin() {
        return getBoolean(R.string.pref_skin, false);
    }

    @NonNull
    public static String getTwitterKeyConsumerPublic() {
        return TWITTER_KEY_CONSUMER_PUBLIC;
    }

    @NonNull
    public static String getTwitterKeyConsumerSecret() {
        return TWITTER_KEY_CONSUMER_SECRET;
    }

    public static String getWebDeviceCode() {
        return getString(R.string.pref_webDeviceCode, null);
    }

    public static boolean isRegisteredForSend2cgeo() {
        return getWebDeviceCode() != null;
    }

    static String getWebDeviceName() {
        return getString(R.string.pref_webDeviceName, Build.MODEL);
    }

    /**
     * @return The cache type used for filtering or ALL if no filter is active.
     *         Returns never null
     */
    @NonNull
    public static CacheType getCacheType() {
        return CacheType.getById(getString(R.string.pref_cachetype, CacheType.ALL.id));
    }

    /**
     * The Threshold for the showing of child waypoints
     */
    public static int getWayPointsThreshold() {
        return getInt(R.string.pref_showwaypointsthreshold, SHOW_WP_THRESHOLD_DEFAULT);
    }

    static void setShowWaypointsThreshold(final int threshold) {
        putInt(R.string.pref_showwaypointsthreshold, threshold);
    }

    public static boolean isUseTwitter() {
        return getBoolean(R.string.pref_twitter, false);
    }

    private static void setUseTwitter(final boolean useTwitter) {
        putBoolean(R.string.pref_twitter, useTwitter);
    }

    public static boolean isTwitterLoginValid() {
        return !StringUtils.isBlank(getTokenPublic())
                && !StringUtils.isBlank(getTokenSecret());
    }

    public static String getTokenPublic() {
        return getString(R.string.pref_twitter_token_public, null);
    }

    public static String getTokenSecret() {
        return getString(R.string.pref_twitter_token_secret, null);

    }

    static boolean hasTwitterAuthorization() {
        return StringUtils.isNotBlank(getTokenPublic())
                && StringUtils.isNotBlank(getTokenSecret());
    }

    public static void setTwitterTokens(@Nullable final String tokenPublic,
            @Nullable final String tokenSecret, final boolean enableTwitter) {
        putString(R.string.pref_twitter_token_public, tokenPublic);
        putString(R.string.pref_twitter_token_secret, tokenSecret);
        if (tokenPublic != null) {
            remove(R.string.pref_temp_twitter_token_public);
            remove(R.string.pref_temp_twitter_token_secret);
        }
        setUseTwitter(enableTwitter);
    }

    public static void setTwitterTempTokens(@Nullable final String tokenPublic,
            @Nullable final String tokenSecret) {
        putString(R.string.pref_temp_twitter_token_public, tokenPublic);
        putString(R.string.pref_temp_twitter_token_secret, tokenSecret);
    }

    public static ImmutablePair<String, String> getTempToken() {
        final String tokenPublic = getString(R.string.pref_temp_twitter_token_public, null);
        final String tokenSecret = getString(R.string.pref_temp_twitter_token_secret, null);
        return new ImmutablePair<>(tokenPublic, tokenSecret);
    }

    public static int getVersion() {
        return getInt(R.string.pref_version, 0);
    }

    public static void setVersion(final int version) {
        putInt(R.string.pref_version, version);
    }

    public static boolean isOpenLastDetailsPage() {
        return getBoolean(R.string.pref_opendetailslastpage, false);
    }

    public static int getLastDetailsPage() {
        return getInt(R.string.pref_lastdetailspage, 1);
    }

    public static void setLastDetailsPage(final int index) {
        putInt(R.string.pref_lastdetailspage, index);
    }

    public static int getDefaultNavigationTool() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool,
                String.valueOf(NavigationAppsEnum.COMPASS.id)));
    }

    public static int getDefaultNavigationTool2() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool2,
                String.valueOf(NavigationAppsEnum.INTERNAL_MAP.id)));
    }

    public static LivemapStrategy getLiveMapStrategy() {
        return LivemapStrategy.getById(getInt(R.string.pref_livemapstrategy, LivemapStrategy.AUTO.id));
    }

    public static void setLiveMapStrategy(final LivemapStrategy strategy) {
        putInt(R.string.pref_livemapstrategy, strategy.id);
    }

    public static boolean isDebug() {
        return Log.isDebug();
    }

    public static int getLiveMapHintShowCount() {
        return getInt(R.string.pref_livemaphintshowcount, 0);
    }

    public static void setLiveMapHintShowCount(final int showCount) {
        putInt(R.string.pref_livemaphintshowcount, showCount);
    }

    public static boolean isDbOnSDCard() {
        return getBoolean(R.string.pref_dbonsdcard, false);
    }

    public static void setDbOnSDCard(final boolean dbOnSDCard) {
        putBoolean(R.string.pref_dbonsdcard, dbOnSDCard);
    }

    public static String getGpxExportDir() {
        return getString(R.string.pref_gpxExportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static String getGpxImportDir() {
        return getString(R.string.pref_gpxImportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static boolean getShareAfterExport() {
        return getBoolean(R.string.pref_shareafterexport, true);
    }

    public static void setShareAfterExport(final boolean shareAfterExport) {
        putBoolean(R.string.pref_shareafterexport, shareAfterExport);
    }

    /**
     * Obtain Trackable action from the last Trackable log.
     *
     * @return
     *          The last Trackable Action or RETRIEVED_IT
     */
    public static int getTrackableAction() {
        return getInt(R.string.pref_trackableaction, LogTypeTrackable.RETRIEVED_IT.id);
    }

    /**
     * Save Trackable action from the last Trackable log.
     *
     * @param trackableAction
     *          The Trackable Action to remember
     */
    public static void setTrackableAction(final int trackableAction) {
        putInt(R.string.pref_trackableaction, trackableAction);
    }

    private static String getCustomRenderThemeBaseFolder() {
        return getString(R.string.pref_renderthemepath, "");
    }

    public static String getCustomRenderThemeFilePath() {
        return getString(R.string.pref_renderthemefile, "");
    }

    public static void setCustomRenderThemeFile(final String customRenderThemeFile) {
        putString(R.string.pref_renderthemefile, customRenderThemeFile);
    }

    public static File[] getMapThemeFiles() {
        final File directory = new File(getCustomRenderThemeBaseFolder());
        final List<File> result = new ArrayList<>();
        FileUtils.listDir(result, directory, new ExtensionsBasedFileSelector(new String[] { "xml" }), null);

        return result.toArray(new File[result.size()]);
    }

    private static class ExtensionsBasedFileSelector implements FileSelector {
        private final String[] extensions;
        public ExtensionsBasedFileSelector(final String[] extensions) {
            this.extensions = extensions;
        }
        @Override
        public boolean isSelected(final File file) {
            final String filename = file.getName();
            for (final String ext : extensions) {
                if (StringUtils.endsWithIgnoreCase(filename, ext)) {
                    return true;
                }
            }
            return false;
        }
        @Override
        public boolean shouldEnd() {
            return false;
        }
    }

    /**
     * @return true if plain text log wanted
     */
    public static boolean getPlainLogs() {
        return getBoolean(R.string.pref_plainLogs, false);
    }

    /**
     * Force set the plain text log preference
     *
     * @param plainLogs
     *            wanted or not
     */
    public static void setPlainLogs(final boolean plainLogs) {
        putBoolean(R.string.pref_plainLogs, plainLogs);
    }

    public static boolean getUseNativeUa() {
        return getBoolean(R.string.pref_nativeUa, false);
    }

    @NonNull
    public static String getCacheTwitterMessage() {
        return StringUtils.defaultString(getString(R.string.pref_twitter_cache_message, "I found [NAME] ([URL])."));
    }

    @NonNull
    public static String getTrackableTwitterMessage() {
        return StringUtils.defaultString(getString(R.string.pref_twitter_trackable_message, "I touched [NAME] ([URL])."));
    }

    public static int getLogImageScale() {
        return getInt(R.string.pref_logImageScale, -1);
    }

    public static void setLogImageScale(final int scale) {
        putInt(R.string.pref_logImageScale, scale);
    }

    public static void setExcludeMine(final boolean exclude) {
        putBoolean(R.string.pref_excludemine, exclude);
    }

    static void setLogin(final String username, final String password) {
        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            // erase username and password
            remove(R.string.pref_username);
            remove(R.string.pref_password);
            return;
        }
        // save username and password
        putString(R.string.pref_username, username);
        putString(R.string.pref_password, password);
    }

    public static long getFieldnoteExportDate() {
        return getLong(R.string.pref_fieldNoteExportDate, 0);
    }

    /**
     * Remember date of last field note export.
     */
    public static void setFieldnoteExportDate(final long date) {
        putLong(R.string.pref_fieldNoteExportDate, date);
    }

    public static boolean isUseNavigationApp(final NavigationAppsEnum navApp) {
        return getBoolean(navApp.preferenceKey, true);
    }

    /**
     * Remember the state of the "Upload" checkbox in the field notes export dialog.
     */
    public static void setFieldNoteExportUpload(final boolean upload) {
        putBoolean(R.string.pref_fieldNoteExportUpload, upload);
    }

    public static boolean getFieldNoteExportUpload() {
        return getBoolean(R.string.pref_fieldNoteExportUpload, true);
    }

    /**
     * Remember the state of the "Only new" checkbox in the field notes export dialog.
     */
    public static void setFieldNoteExportOnlyNew(final boolean onlyNew) {
        putBoolean(R.string.pref_fieldNoteExportOnlyNew, onlyNew);
    }

    public static boolean getFieldNoteExportOnlyNew() {
        return getBoolean(R.string.pref_fieldNoteExportOnlyNew, false);
    }

    public static String getECIconSet() {
        return getString(R.string.pref_ec_icons, "1");
    }

    /* Store last checksum of changelog for changelog display */
    public static long getLastChangelogChecksum() {
        return getLong(R.string.pref_changelog_last_checksum, 0);
    }

    public static void setLastChangelogChecksum(final long checksum) {
        putLong(R.string.pref_changelog_last_checksum, checksum);
    }

    public static List<String> getLastOpenedCaches() {
        final List<String> history = Arrays.asList(StringUtils.split(getString(R.string.pref_caches_history, StringUtils.EMPTY), HISTORY_SEPARATOR));
        return history.subList(0, Math.min(HISTORY_SIZE, history.size()));
    }

    public static void addCacheToHistory(@NonNull final String geocode) {
        final List<String> history = new ArrayList<>(getLastOpenedCaches());
        // bring entry to front, if it already existed
        history.remove(geocode);
        history.add(0, geocode);
        putString(R.string.pref_caches_history, StringUtils.join(history, HISTORY_SEPARATOR));
    }

    public static boolean useHardwareAcceleration() {
        return getBoolean(R.string.pref_hardware_acceleration, !HW_ACCEL_DISABLED_BY_DEFAULT);
    }

    static void setUseHardwareAcceleration(final boolean useHardwareAcceleration) {
        putBoolean(R.string.pref_hardware_acceleration, useHardwareAcceleration);
    }

    public static String getLastCacheLog() {
        return getString(R.string.pref_last_cache_log, StringUtils.EMPTY);
    }

    public static void setLastCacheLog(final String log) {
        putString(R.string.pref_last_cache_log, log);
    }

    public static String getLastTrackableLog() {
        return getString(R.string.pref_last_trackable_log, StringUtils.EMPTY);
    }

    public static void setLastTrackableLog(final String log) {
        putString(R.string.pref_last_trackable_log, log);
    }

    @Nullable
    public static String getHomeLocation() {
        return getString(R.string.pref_home_location, null);
    }

    public static void setHomeLocation(@NonNull final String homeLocation) {
        putString(R.string.pref_home_location, homeLocation);
    }

    public static void setForceOrientationSensor(final boolean forceOrientationSensor) {
        putBoolean(R.string.pref_force_orientation_sensor, forceOrientationSensor);
    }

    public static boolean useOrientationSensor(final Context context) {
        return OrientationProvider.hasOrientationSensor(context) && (getBoolean(R.string.pref_force_orientation_sensor, false) || !RotationProvider.hasRotationSensor(context));
    }
}
!@#$%
20190527_011221,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_c18448
package cgeo.geocaching.settings;

import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.R;
import cgeo.geocaching.apps.navi.NavigationAppFactory.NavigationAppsEnum;
import cgeo.geocaching.connector.capability.ICredentials;
import cgeo.geocaching.connector.gc.GCConnector;
import cgeo.geocaching.connector.gc.GCConstants;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.LogTypeTrackable;
import cgeo.geocaching.list.StoredList;
import cgeo.geocaching.location.Geopoint;
import cgeo.geocaching.maps.CGeoMap.MapMode;
import cgeo.geocaching.maps.LivemapStrategy;
import cgeo.geocaching.maps.MapProviderFactory;
import cgeo.geocaching.maps.google.v1.GoogleMapProvider;
import cgeo.geocaching.maps.interfaces.GeoPointImpl;
import cgeo.geocaching.maps.interfaces.MapProvider;
import cgeo.geocaching.maps.interfaces.MapSource;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider.OfflineMapSource;
import cgeo.geocaching.sensors.MagnetometerAndAccelerometerProvider;
import cgeo.geocaching.sensors.OrientationProvider;
import cgeo.geocaching.sensors.RotationProvider;
import cgeo.geocaching.utils.CryptUtils;
import cgeo.geocaching.utils.FileUtils;
import cgeo.geocaching.utils.FileUtils.FileSelector;
import cgeo.geocaching.utils.Log;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.os.Build;
import android.os.Build.VERSION;
import android.os.Build.VERSION_CODES;
import android.os.Environment;
import android.preference.PreferenceManager;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;

/**
 * General c:geo preferences/settings set by the user
 */
public class Settings {

    /**
     * On opening a map, we limit the _initial_ zoom. The user can still zoom out afterwards.
     */
    private static final int INITIAL_MAP_ZOOM_LIMIT = 16;
    private static final char HISTORY_SEPARATOR = ',';
    private static final int SHOW_WP_THRESHOLD_DEFAULT = 10;
    public static final int SHOW_WP_THRESHOLD_MAX = 50;
    private static final int MAP_SOURCE_DEFAULT = GoogleMapProvider.GOOGLE_MAP_ID.hashCode();

    public static final boolean HW_ACCEL_DISABLED_BY_DEFAULT =
            Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1 ||
            StringUtils.equals(Build.MODEL, "HTC One X") ||    // HTC One X
            StringUtils.equals(Build.MODEL, "HTC One S") ||    // HTC One S
            StringUtils.equals(Build.MODEL, "GT-I8190")  ||    // Samsung S3 mini
            StringUtils.equals(Build.MODEL, "GT-S6310L") ||    // Samsung Galaxy Young
            StringUtils.equals(Build.MODEL, "GT-P5210")  ||    // Samsung Galaxy Tab 3
            StringUtils.equals(Build.MODEL, "GT-S7580")  ||    // Samsung Galaxy Trend Plus
            StringUtils.equals(Build.MODEL, "GT-I9105P") ||    // Samsung Galaxy SII Plus
            StringUtils.equals(Build.MODEL, "ST25i")     ||    // Sony Xperia U
            StringUtils.equals(Build.MODEL, "bq Aquaris 5") || // bq Aquaris 5
            StringUtils.equals(Build.MODEL, "A1-810")    ||    // Unknown A1-810
            StringUtils.equals(Build.MODEL, "GT-I9195")  ||    // Samsung S4 mini
            StringUtils.equals(Build.MODEL, "GT-I8200N");      // Samsung S3 mini

    // twitter api keys
    private final static @NonNull String TWITTER_KEY_CONSUMER_PUBLIC = CryptUtils.rot13("ESnsCvAv3kEupF1GCR3jGj");
    private final static @NonNull String TWITTER_KEY_CONSUMER_SECRET = CryptUtils.rot13("7vQWceACV9umEjJucmlpFe9FCMZSeqIqfkQ2BnhV9x");

    private static boolean useCompass = true;

    public enum CoordInputFormatEnum {
        Plain,
        Deg,
        Min,
        Sec;

        static final int DEFAULT_INT_VALUE = Min.ordinal();

        public static CoordInputFormatEnum fromInt(final int id) {
            final CoordInputFormatEnum[] values = CoordInputFormatEnum.values();
            if (id < 0 || id >= values.length) {
                return Min;
            }
            return values[id];
        }
    }

    private static final SharedPreferences sharedPrefs = PreferenceManager
            .getDefaultSharedPreferences(CgeoApplication.getInstance().getBaseContext());
    static {
        migrateSettings();
        final boolean isDebug = sharedPrefs.getBoolean(getKey(R.string.pref_debug), false);
        Log.setDebug(isDebug);
        CgeoApplication.dumpOnOutOfMemory(isDebug);
    }

    /**
     * Cache the mapsource locally. If that is an offline map source, each request would potentially access the
     * underlying map file, leading to delays.
     */
    private static MapSource mapSource;

    protected Settings() {
        throw new InstantiationError();
    }

    private static void migrateSettings() {
        final int LATEST_PREFERENCES_VERSION = 2;
        final int currentVersion = getInt(R.string.pref_settingsversion, 0);

        // No need to migrate if we are up to date.
        if (currentVersion == LATEST_PREFERENCES_VERSION) {
            return;
        }

        // No need to migrate if we don't have older settings, defaults will be used instead.
        final String preferencesNameV0 = "cgeo.pref";
        final SharedPreferences prefsV0 = CgeoApplication.getInstance().getSharedPreferences(preferencesNameV0, Context.MODE_PRIVATE);
        if (currentVersion == 0 && prefsV0.getAll().isEmpty()) {
            final Editor e = sharedPrefs.edit();
            e.putInt(getKey(R.string.pref_settingsversion), LATEST_PREFERENCES_VERSION);
            e.apply();
            return;
        }

        if (currentVersion < 1) {
            // migrate from non standard file location and integer based boolean types
            final Editor e = sharedPrefs.edit();

            e.putString(getKey(R.string.pref_temp_twitter_token_secret), prefsV0.getString(getKey(R.string.pref_temp_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_temp_twitter_token_public), prefsV0.getString(getKey(R.string.pref_temp_twitter_token_public), null));
            e.putBoolean(getKey(R.string.pref_help_shown), prefsV0.getInt(getKey(R.string.pref_help_shown), 0) != 0);
            e.putFloat(getKey(R.string.pref_anylongitude), prefsV0.getFloat(getKey(R.string.pref_anylongitude), 0));
            e.putFloat(getKey(R.string.pref_anylatitude), prefsV0.getFloat(getKey(R.string.pref_anylatitude), 0));
            e.putBoolean(getKey(R.string.pref_offlinemaps), 0 != prefsV0.getInt(getKey(R.string.pref_offlinemaps), 1));
            e.putBoolean(getKey(R.string.pref_offlinewpmaps), 0 != prefsV0.getInt(getKey(R.string.pref_offlinewpmaps), 0));
            e.putString(getKey(R.string.pref_webDeviceCode), prefsV0.getString(getKey(R.string.pref_webDeviceCode), null));
            e.putString(getKey(R.string.pref_webDeviceName), prefsV0.getString(getKey(R.string.pref_webDeviceName), null));
            e.putBoolean(getKey(R.string.pref_maplive), prefsV0.getInt(getKey(R.string.pref_maplive), 1) != 0);
            e.putInt(getKey(R.string.pref_mapsource), prefsV0.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT));
            e.putBoolean(getKey(R.string.pref_twitter), 0 != prefsV0.getInt(getKey(R.string.pref_twitter), 0));
            e.putBoolean(getKey(R.string.pref_showaddress), 0 != prefsV0.getInt(getKey(R.string.pref_showaddress), 1));
            e.putBoolean(getKey(R.string.pref_showcaptcha), prefsV0.getBoolean(getKey(R.string.pref_showcaptcha), false));
            e.putBoolean(getKey(R.string.pref_maptrail), prefsV0.getInt(getKey(R.string.pref_maptrail), 1) != 0);
            e.putInt(getKey(R.string.pref_lastmapzoom), prefsV0.getInt(getKey(R.string.pref_lastmapzoom), 14));
            e.putBoolean(getKey(R.string.pref_livelist), 0 != prefsV0.getInt(getKey(R.string.pref_livelist), 1));
            e.putBoolean(getKey(R.string.pref_units_imperial), prefsV0.getInt(getKey(R.string.pref_units_imperial), 1) != 1);
            e.putBoolean(getKey(R.string.pref_skin), prefsV0.getInt(getKey(R.string.pref_skin), 0) != 0);
            e.putInt(getKey(R.string.pref_lastusedlist), prefsV0.getInt(getKey(R.string.pref_lastusedlist), StoredList.STANDARD_LIST_ID));
            e.putString(getKey(R.string.pref_cachetype), prefsV0.getString(getKey(R.string.pref_cachetype), CacheType.ALL.id));
            e.putString(getKey(R.string.pref_twitter_token_secret), prefsV0.getString(getKey(R.string.pref_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_twitter_token_public), prefsV0.getString(getKey(R.string.pref_twitter_token_public), null));
            e.putInt(getKey(R.string.pref_version), prefsV0.getInt(getKey(R.string.pref_version), 0));
            e.putBoolean(getKey(R.string.pref_autoloaddesc), 0 != prefsV0.getInt(getKey(R.string.pref_autoloaddesc), 1));
            e.putBoolean(getKey(R.string.pref_ratingwanted), prefsV0.getBoolean(getKey(R.string.pref_ratingwanted), true));
            e.putBoolean(getKey(R.string.pref_friendlogswanted), prefsV0.getBoolean(getKey(R.string.pref_friendlogswanted), true));
            e.putBoolean(getKey(R.string.pref_useenglish), prefsV0.getBoolean(getKey(R.string.pref_useenglish), false));
            e.putBoolean(getKey(R.string.pref_usecompass), 0 != prefsV0.getInt(getKey(R.string.pref_usecompass), 1));
            e.putBoolean(getKey(R.string.pref_trackautovisit), prefsV0.getBoolean(getKey(R.string.pref_trackautovisit), false));
            e.putBoolean(getKey(R.string.pref_sigautoinsert), prefsV0.getBoolean(getKey(R.string.pref_sigautoinsert), false));
            e.putBoolean(getKey(R.string.pref_logimages), prefsV0.getBoolean(getKey(R.string.pref_logimages), false));
            e.putBoolean(getKey(R.string.pref_excludedisabled), 0 != prefsV0.getInt(getKey(R.string.pref_excludedisabled), 0));
            e.putBoolean(getKey(R.string.pref_excludemine), 0 != prefsV0.getInt(getKey(R.string.pref_excludemine), 0));
            e.putString(getKey(R.string.pref_mapfile), prefsV0.getString(getKey(R.string.pref_mapfile), null));
            e.putString(getKey(R.string.pref_signature), prefsV0.getString(getKey(R.string.pref_signature), null));
            e.putString(getKey(R.string.pref_pass_vote), prefsV0.getString(getKey(R.string.pref_pass_vote), null));
            e.putString(getKey(R.string.pref_password), prefsV0.getString(getKey(R.string.pref_password), null));
            e.putString(getKey(R.string.pref_username), prefsV0.getString(getKey(R.string.pref_username), null));
            e.putString(getKey(R.string.pref_memberstatus), prefsV0.getString(getKey(R.string.pref_memberstatus), ""));
            e.putInt(getKey(R.string.pref_coordinputformat), prefsV0.getInt(getKey(R.string.pref_coordinputformat), CoordInputFormatEnum.DEFAULT_INT_VALUE));
            e.putBoolean(getKey(R.string.pref_log_offline), prefsV0.getBoolean(getKey(R.string.pref_log_offline), false));
            e.putBoolean(getKey(R.string.pref_choose_list), prefsV0.getBoolean(getKey(R.string.pref_choose_list), true));
            e.putBoolean(getKey(R.string.pref_loaddirectionimg), prefsV0.getBoolean(getKey(R.string.pref_loaddirectionimg), true));
            e.putString(getKey(R.string.pref_gccustomdate), prefsV0.getString(getKey(R.string.pref_gccustomdate), GCConstants.DEFAULT_GC_DATE));
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), prefsV0.getInt(getKey(R.string.pref_showwaypointsthreshold), SHOW_WP_THRESHOLD_DEFAULT));
            e.putString(getKey(R.string.pref_cookiestore), prefsV0.getString(getKey(R.string.pref_cookiestore), null));
            e.putBoolean(getKey(R.string.pref_opendetailslastpage), prefsV0.getBoolean(getKey(R.string.pref_opendetailslastpage), false));
            e.putInt(getKey(R.string.pref_lastdetailspage), prefsV0.getInt(getKey(R.string.pref_lastdetailspage), 1));
            e.putInt(getKey(R.string.pref_defaultNavigationTool), prefsV0.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id));
            e.putInt(getKey(R.string.pref_defaultNavigationTool2), prefsV0.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id));
            e.putInt(getKey(R.string.pref_livemapstrategy), prefsV0.getInt(getKey(R.string.pref_livemapstrategy), LivemapStrategy.AUTO.id));
            e.putBoolean(getKey(R.string.pref_debug), prefsV0.getBoolean(getKey(R.string.pref_debug), false));
            e.putInt(getKey(R.string.pref_livemaphintshowcount), prefsV0.getInt(getKey(R.string.pref_livemaphintshowcount), 0));

            e.putInt(getKey(R.string.pref_settingsversion), 1); // mark migrated
            e.apply();
        }

        // changes for new settings dialog
        if (currentVersion < 2) {
            final Editor e = sharedPrefs.edit();

            e.putBoolean(getKey(R.string.pref_units_imperial), useImperialUnits());

            // show waypoints threshold now as a slider
            int wpThreshold = getWayPointsThreshold();
            if (wpThreshold < 0) {
                wpThreshold = 0;
            } else if (wpThreshold > SHOW_WP_THRESHOLD_MAX) {
                wpThreshold = SHOW_WP_THRESHOLD_MAX;
            }
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), wpThreshold);

            // KEY_MAP_SOURCE must be string, because it is the key for a ListPreference now
            final int ms = sharedPrefs.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT);
            e.remove(getKey(R.string.pref_mapsource));
            e.putString(getKey(R.string.pref_mapsource), String.valueOf(ms));

            // navigation tool ids must be string, because ListPreference uses strings as keys
            final int dnt1 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id);
            final int dnt2 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id);
            e.remove(getKey(R.string.pref_defaultNavigationTool));
            e.remove(getKey(R.string.pref_defaultNavigationTool2));
            e.putString(getKey(R.string.pref_defaultNavigationTool), String.valueOf(dnt1));
            e.putString(getKey(R.string.pref_defaultNavigationTool2), String.valueOf(dnt2));

            // defaults for gpx directories
            e.putString(getKey(R.string.pref_gpxImportDir), getGpxImportDir());
            e.putString(getKey(R.string.pref_gpxExportDir), getGpxExportDir());

            e.putInt(getKey(R.string.pref_settingsversion), 2); // mark migrated
            e.apply();
        }
    }

    private static String getKey(final int prefKeyId) {
        return CgeoApplication.getInstance().getString(prefKeyId);
    }

    static String getString(final int prefKeyId, final String defaultValue) {
        return sharedPrefs.getString(getKey(prefKeyId), defaultValue);
    }

    private static int getInt(final int prefKeyId, final int defaultValue) {
        return sharedPrefs.getInt(getKey(prefKeyId), defaultValue);
    }

    private static long getLong(final int prefKeyId, final long defaultValue) {
        return sharedPrefs.getLong(getKey(prefKeyId), defaultValue);
    }

    private static boolean getBoolean(final int prefKeyId, final boolean defaultValue) {
        return sharedPrefs.getBoolean(getKey(prefKeyId), defaultValue);
    }

    private static float getFloat(final int prefKeyId, final float defaultValue) {
        return sharedPrefs.getFloat(getKey(prefKeyId), defaultValue);
    }

    protected static void putString(final int prefKeyId, final String value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putString(getKey(prefKeyId), value);
        edit.apply();
    }

    protected static void putBoolean(final int prefKeyId, final boolean value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putBoolean(getKey(prefKeyId), value);
        edit.apply();
    }

    private static void putInt(final int prefKeyId, final int value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putInt(getKey(prefKeyId), value);
        edit.apply();
    }

    private static void putLong(final int prefKeyId, final long value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putLong(getKey(prefKeyId), value);
        edit.apply();
    }

    private static void putFloat(final int prefKeyId, final float value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putFloat(getKey(prefKeyId), value);
        edit.apply();
    }

    private static void remove(final int prefKeyId) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.remove(getKey(prefKeyId));
        edit.apply();
    }

    private static boolean contains(final int prefKeyId) {
        return sharedPrefs.contains(getKey(prefKeyId));
    }

    public static boolean hasGCCredentials() {
        final String preUsername = getString(R.string.pref_username, null);
        final String prePassword = getString(R.string.pref_password, null);

        return !StringUtils.isBlank(preUsername) && !StringUtils.isBlank(prePassword);
    }

    /**
     * Get login and password information of Geocaching.com.
     *
     * @return a pair either with (login, password) or (empty, empty) if no valid information is stored
     */
    public static ImmutablePair<String, String> getGcCredentials() {
        return getCredentials(GCConnector.getInstance());
    }

    /**
     * Get login and password information.
     *
     * @return a pair either with (login, password) or (empty, empty) if no valid information is stored
     */
    @NonNull
    public static ImmutablePair<String, String> getCredentials(final @NonNull ICredentials connector) {
        final String username = getString(connector.getUsernamePreferenceKey(), null);
        final String password = getString(connector.getPasswordPreferenceKey(), null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return new ImmutablePair<>(StringUtils.EMPTY, StringUtils.EMPTY);
        }

        return new ImmutablePair<>(username, password);
    }

    public static String getUsername() {
        return getString(R.string.pref_username, StringUtils.EMPTY);
    }

    public static boolean isGCConnectorActive() {
        return getBoolean(R.string.pref_connectorGCActive, true);
    }

    public static boolean isECConnectorActive() {
        return getBoolean(R.string.pref_connectorECActive, false);
    }

    public static boolean isGCPremiumMember() {
        final String memberStatus = getGCMemberStatus();
        return StringUtils.equalsIgnoreCase(memberStatus, GCConstants.MEMBER_STATUS_PREMIUM) ||
                StringUtils.equalsIgnoreCase(memberStatus, GCConstants.MEMBER_STATUS_CHARTER);
    }

    public static String getGCMemberStatus() {
        return getString(R.string.pref_memberstatus, "");
    }

    public static void setGCMemberStatus(final String memberStatus) {
        if (StringUtils.isBlank(memberStatus)) {
            remove(R.string.pref_memberstatus);
        }
        putString(R.string.pref_memberstatus, memberStatus);
    }

    public static ImmutablePair<String, String> getTokenPair(final int tokenPublicPrefKey, final int tokenSecretPrefKey) {
        return new ImmutablePair<>(getString(tokenPublicPrefKey, null), getString(tokenSecretPrefKey, null));
    }

    public static void setTokens(final int tokenPublicPrefKey, @Nullable final String tokenPublic, final int tokenSecretPrefKey, @Nullable final String tokenSecret) {
        if (tokenPublic == null) {
            remove(tokenPublicPrefKey);
        } else {
            putString(tokenPublicPrefKey, tokenPublic);
        }
        if (tokenSecret == null) {
            remove(tokenSecretPrefKey);
        } else {
            putString(tokenSecretPrefKey, tokenSecret);
        }
    }

    public static boolean isOCConnectorActive(final int isActivePrefKeyId) {
        return getBoolean(isActivePrefKeyId, false);
    }

    public static boolean hasOCAuthorization(final int tokenPublicPrefKeyId, final int tokenSecretPrefKeyId) {
        return StringUtils.isNotBlank(getString(tokenPublicPrefKeyId, ""))
                && StringUtils.isNotBlank(getString(tokenSecretPrefKeyId, ""));
    }

    public static boolean isGCVoteLogin() {
        return StringUtils.isNotBlank(getGCVoteLogin().left);
    }

    public static ImmutablePair<String, String> getGCVoteLogin() {
        final String username = getString(R.string.pref_username, null);
        final String password = getString(R.string.pref_pass_vote, null);

        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            return new ImmutablePair<>(StringUtils.EMPTY, StringUtils.EMPTY);
        }

        return new ImmutablePair<>(username, password);
    }

    @NonNull
    public static String getSignature() {
        return StringUtils.defaultString(getString(R.string.pref_signature, StringUtils.EMPTY));
    }

    public static void setCookieStore(final String cookies) {
        if (StringUtils.isBlank(cookies)) {
            // erase cookies
            remove(R.string.pref_cookiestore);
        }
        // save cookies
        putString(R.string.pref_cookiestore, cookies);
    }

    public static String getCookieStore() {
        return getString(R.string.pref_cookiestore, null);
    }

    public static void setUseGooglePlayServices(final boolean value) {
        putBoolean(R.string.pref_googleplayservices, value);
    }

    public static boolean useGooglePlayServices() {
        // By defaut, enable play services starting from ICS.
        return CgeoApplication.getInstance().isGooglePlayServicesAvailable() &&
                getBoolean(R.string.pref_googleplayservices, VERSION.SDK_INT >= VERSION_CODES.ICE_CREAM_SANDWICH);
    }

    public static boolean useLowPowerMode() {
        return getBoolean(R.string.pref_lowpowermode, false);
    }

    /**
     * @param cacheType
     *            The cache type used for future filtering
     */
    public static void setCacheType(final CacheType cacheType) {
        if (cacheType == null) {
            remove(R.string.pref_cachetype);
        } else {
            putString(R.string.pref_cachetype, cacheType.id);
        }
    }

    public static int getLastList() {
        return getInt(R.string.pref_lastusedlist, StoredList.STANDARD_LIST_ID);
    }

    public static void saveLastList(final int listId) {
        putInt(R.string.pref_lastusedlist, listId);
    }

    public static void setWebNameCode(final String name, final String code) {
        putString(R.string.pref_webDeviceName, name);
        putString(R.string.pref_webDeviceCode, code);
    }

    public static MapProvider getMapProvider() {
        return getMapSource().getMapProvider();
    }

    public static String getMapFile() {
        return getString(R.string.pref_mapfile, null);
    }

    static void setMapFile(final String mapFile) {
        putString(R.string.pref_mapfile, mapFile);
        if (mapFile != null) {
            setMapFileDirectory(new File(mapFile).getParent());
        }
    }

    public static String getMapFileDirectory() {
        final String mapDir = getString(R.string.pref_mapDirectory, null);
        if (mapDir != null) {
            return mapDir;
        }
        final String mapFile = getMapFile();
        if (mapFile != null) {
            return new File(mapFile).getParent();
        }
        return null;
    }

    static void setMapFileDirectory(final String mapFileDirectory) {
        putString(R.string.pref_mapDirectory, mapFileDirectory);
        MapsforgeMapProvider.getInstance().updateOfflineMaps();
    }

    private static boolean isValidMapFile() {
        return isValidMapFile(getMapFile());
    }

    public static boolean isValidMapFile(final String mapFileIn) {
        return MapsforgeMapProvider.isValidMapFile(mapFileIn);
    }

    public static boolean isScaleMapsforgeText() {
        return getBoolean(R.string.pref_mapsforge_scale_text, true);
    }

    public static CoordInputFormatEnum getCoordInputFormat() {
        return CoordInputFormatEnum.fromInt(getInt(R.string.pref_coordinputformat, CoordInputFormatEnum.DEFAULT_INT_VALUE));
    }

    public static void setCoordInputFormat(final CoordInputFormatEnum format) {
        putInt(R.string.pref_coordinputformat, format.ordinal());
    }

    public static boolean getLogOffline() {
        return getBoolean(R.string.pref_log_offline, false);
    }

    public static boolean getChooseList() {
        return getBoolean(R.string.pref_choose_list, false);
    }

    public static boolean getLoadDirImg() {
        return !isGCPremiumMember() && getBoolean(R.string.pref_loaddirectionimg, true);
    }

    public static void setGcCustomDate(final String format) {
        putString(R.string.pref_gccustomdate, format);
    }

    /**
     * @return User selected date format on GC.com
     */
    public static String getGcCustomDate() {
        // We might have some users whose stored value is null, which is invalid. In this case, we use the default.
        return StringUtils.defaultString(getString(R.string.pref_gccustomdate, GCConstants.DEFAULT_GC_DATE),
                GCConstants.DEFAULT_GC_DATE);
    }

    public static boolean isExcludeMyCaches() {
        return getBoolean(R.string.pref_excludemine, false);
    }

    public static boolean useEnglish() {
        return getBoolean(R.string.pref_useenglish, false);
    }

    public static boolean isShowAddress() {
        return getBoolean(R.string.pref_showaddress, true);
    }

    public static boolean isShowCaptcha() {
        return !isGCPremiumMember() && getBoolean(R.string.pref_showcaptcha, false);
    }

    public static boolean isExcludeDisabledCaches() {
        return getBoolean(R.string.pref_excludedisabled, false);
    }

    public static boolean isStoreOfflineMaps() {
        return getBoolean(R.string.pref_offlinemaps, true);
    }

    public static boolean isStoreOfflineWpMaps() {
        return getBoolean(R.string.pref_offlinewpmaps, false);
    }

    public static boolean isStoreLogImages() {
        return getBoolean(R.string.pref_logimages, false);
    }

    public static boolean isAutoLoadDescription() {
        return getBoolean(R.string.pref_autoloaddesc, true);
    }

    public static boolean isRatingWanted() {
        return getBoolean(R.string.pref_ratingwanted, true);
    }

    public static boolean isGeokretyConnectorActive() {
        return getBoolean(R.string.pref_connectorGeokretyActive, false);
    }

    public static boolean isGeokretyCacheActive() {
        return getBoolean(R.string.pref_geokrety_cache, true);
    }

    static boolean hasGeokretyAuthorization() {
        return StringUtils.isNotBlank(getGeokretySecId());
    }

    public static String getGeokretySecId() {
        return getString(R.string.pref_fakekey_geokrety_authorization, null);
    }

    public static void setGeokretySecId(final String secid) {
        putString(R.string.pref_fakekey_geokrety_authorization, secid);
    }

    public static boolean isRegisteredForGeokretyLogging() {
        return getGeokretySecId() != null;
    }

    /**
     * Retrieve showed popup counter for warning about logging Trackable recommend Geocode
     *
     * @return number of times the popup has appeared
     */
    public static int getLogTrackableWithoutGeocodeShowCount() {
        return getInt(R.string.pref_logtrackablewithoutgeocodeshowcount, 0);
    }

    /**
     * Store showed popup counter for warning about logging Trackable recommend Geocode
     *
     * @param showCount the count to save
     */
    public static void setLogTrackableWithoutGeocodeShowCount(final int showCount) {
        putInt(R.string.pref_logtrackablewithoutgeocodeshowcount, showCount);
    }

    public static boolean isFriendLogsWanted() {
        if (!hasGCCredentials()) {
            // don't show a friends log if the user is anonymous
            return false;
        }
        return getBoolean(R.string.pref_friendlogswanted, true);
    }

    public static boolean isLiveList() {
        return getBoolean(R.string.pref_livelist, true);
    }

    public static boolean isTrackableAutoVisit() {
        return getBoolean(R.string.pref_trackautovisit, false);
    }

    public static boolean isAutoInsertSignature() {
        return getBoolean(R.string.pref_sigautoinsert, false);
    }

    static void setUseImperialUnits(final boolean useImperialUnits) {
        putBoolean(R.string.pref_units_imperial, useImperialUnits);
    }

    public static boolean useImperialUnits() {
        return getBoolean(R.string.pref_units_imperial, useImperialUnitsByDefault());
    }

    private static boolean useImperialUnitsByDefault() {
        final String countryCode = Locale.getDefault().getCountry();
        return "US".equals(countryCode)  // USA
            || "LR".equals(countryCode)  // Liberia
            || "MM".equals(countryCode); // Burma
    }

    public static boolean isLiveMap() {
        return getBoolean(R.string.pref_maplive, true);
    }

    public static void setLiveMap(final boolean live) {
        putBoolean(R.string.pref_maplive, live);
    }

    public static boolean isMapTrail() {
        return getBoolean(R.string.pref_maptrail, false);
    }

    public static void setMapTrail(final boolean showTrail) {
        putBoolean(R.string.pref_maptrail, showTrail);
    }

    /**
     * whether to show a direction line on the map
     */
    public static boolean isMapDirection() {
        return getBoolean(R.string.pref_map_direction, true);
    }

    public static void setMapDirection(final boolean showDirection) {
        putBoolean(R.string.pref_map_direction, showDirection);
    }

    /**
     * Get last used zoom of the internal map. Differentiate between two use cases for a map of multiple caches (e.g.
     * live map) and the map of a single cache (which is often zoomed in more deep).
     */
    public static int getMapZoom(final MapMode mapMode) {
        if (mapMode == MapMode.SINGLE || mapMode == MapMode.COORDS) {
            return getCacheZoom();
        }
        return getMapZoom();
    }

    public static void setMapZoom(final MapMode mapMode, final int zoomLevel) {
        if (mapMode == MapMode.SINGLE || mapMode == MapMode.COORDS) {
            setCacheZoom(zoomLevel);
        }
        else {
            setMapZoom(zoomLevel);
        }
    }

    /**
     * @return zoom used for the (live) map
     */
    private static int getMapZoom() {
        return Math.max(getInt(R.string.pref_lastmapzoom, 14), INITIAL_MAP_ZOOM_LIMIT);
    }

    private static void setMapZoom(final int mapZoomLevel) {
        putInt(R.string.pref_lastmapzoom, mapZoomLevel);
    }

    /**
     * @return zoom used for the map of a single cache
     */
    private static int getCacheZoom() {
        return Math.max(getInt(R.string.pref_cache_zoom, 14), INITIAL_MAP_ZOOM_LIMIT);
    }

    private static void setCacheZoom(final int zoomLevel) {
        putInt(R.string.pref_cache_zoom, zoomLevel);
    }

    public static GeoPointImpl getMapCenter() {
        return getMapProvider().getMapItemFactory()
                .getGeoPointBase(new Geopoint(getInt(R.string.pref_lastmaplat, 0) / 1e6,
                        getInt(R.string.pref_lastmaplon, 0) / 1e6));
    }

    public static void setMapCenter(final GeoPointImpl mapViewCenter) {
        putInt(R.string.pref_lastmaplat, mapViewCenter.getLatitudeE6());
        putInt(R.string.pref_lastmaplon, mapViewCenter.getLongitudeE6());
    }

    @NonNull
    public static synchronized MapSource getMapSource() {
        if (mapSource != null) {
            return mapSource;
        }
        final int id = getConvertedMapId();
        mapSource = MapProviderFactory.getMapSource(id);
        if (mapSource != null) {
            // don't use offline maps if the map file is not valid
            if (!(mapSource instanceof OfflineMapSource) || isValidMapFile()) {
                return mapSource;
            }
        }
        // fallback to first available map
        return MapProviderFactory.getDefaultSource();
    }

    private final static int GOOGLEMAP_BASEID = 30;
    private final static int MAP = 1;
    private final static int SATELLITE = 2;

    private final static int MFMAP_BASEID = 40;
    private final static int MAPNIK = 1;
    private final static int CYCLEMAP = 3;
    private final static int OFFLINE = 4;
    private static final int HISTORY_SIZE = 10;

    /**
     * Convert old preference ids for maps (based on constant values) into new hash based ids.
     */
    private static int getConvertedMapId() {
        final int id = Integer.parseInt(getString(R.string.pref_mapsource,
                String.valueOf(MAP_SOURCE_DEFAULT)));
        switch (id) {
            case GOOGLEMAP_BASEID + MAP:
                return GoogleMapProvider.GOOGLE_MAP_ID.hashCode();
            case GOOGLEMAP_BASEID + SATELLITE:
                return GoogleMapProvider.GOOGLE_SATELLITE_ID.hashCode();
            case MFMAP_BASEID + MAPNIK:
                return MapsforgeMapProvider.MAPSFORGE_MAPNIK_ID.hashCode();
            case MFMAP_BASEID + CYCLEMAP:
                return MapsforgeMapProvider.MAPSFORGE_CYCLEMAP_ID.hashCode();
            case MFMAP_BASEID + OFFLINE: {
                final String mapFile = getMapFile();
                if (StringUtils.isNotEmpty(mapFile)) {
                    return mapFile.hashCode();
                }
                break;
            }
            default:
                break;
        }
        return id;
    }

    public static synchronized void setMapSource(final MapSource newMapSource) {
        putString(R.string.pref_mapsource, String.valueOf(newMapSource.getNumericalId()));
        if (newMapSource instanceof OfflineMapSource) {
            setMapFile(((OfflineMapSource) newMapSource).getFileName());
        }
        // cache the value
        mapSource = newMapSource;
    }

    public static void setAnyCoordinates(final Geopoint coords) {
        if (null != coords) {
            putFloat(R.string.pref_anylatitude, (float) coords.getLatitude());
            putFloat(R.string.pref_anylongitude, (float) coords.getLongitude());
        } else {
            remove(R.string.pref_anylatitude);
            remove(R.string.pref_anylongitude);
        }
    }

    public static Geopoint getAnyCoordinates() {
        if (contains(R.string.pref_anylatitude) && contains(R.string.pref_anylongitude)) {
            final float lat = getFloat(R.string.pref_anylatitude, 0);
            final float lon = getFloat(R.string.pref_anylongitude, 0);
            return new Geopoint(lat, lon);
        }
        return null;
    }

    public static boolean isUseCompass() {
        return useCompass;
    }

    public static void setUseCompass(final boolean value) {
        useCompass = value;
    }

    public static boolean isLightSkin() {
        return getBoolean(R.string.pref_skin, false);
    }

    @NonNull
    public static String getTwitterKeyConsumerPublic() {
        return TWITTER_KEY_CONSUMER_PUBLIC;
    }

    @NonNull
    public static String getTwitterKeyConsumerSecret() {
        return TWITTER_KEY_CONSUMER_SECRET;
    }

    public static String getWebDeviceCode() {
        return getString(R.string.pref_webDeviceCode, null);
    }

    public static boolean isRegisteredForSend2cgeo() {
        return getWebDeviceCode() != null;
    }

    static String getWebDeviceName() {
        return getString(R.string.pref_webDeviceName, Build.MODEL);
    }

    /**
     * @return The cache type used for filtering or ALL if no filter is active.
     *         Returns never null
     */
    @NonNull
    public static CacheType getCacheType() {
        return CacheType.getById(getString(R.string.pref_cachetype, CacheType.ALL.id));
    }

    /**
     * The Threshold for the showing of child waypoints
     */
    public static int getWayPointsThreshold() {
        return getInt(R.string.pref_showwaypointsthreshold, SHOW_WP_THRESHOLD_DEFAULT);
    }

    static void setShowWaypointsThreshold(final int threshold) {
        putInt(R.string.pref_showwaypointsthreshold, threshold);
    }

    public static boolean isUseTwitter() {
        return getBoolean(R.string.pref_twitter, false);
    }

    private static void setUseTwitter(final boolean useTwitter) {
        putBoolean(R.string.pref_twitter, useTwitter);
    }

    public static boolean isTwitterLoginValid() {
        return !StringUtils.isBlank(getTokenPublic())
                && !StringUtils.isBlank(getTokenSecret());
    }

    public static String getTokenPublic() {
        return getString(R.string.pref_twitter_token_public, null);
    }

    public static String getTokenSecret() {
        return getString(R.string.pref_twitter_token_secret, null);

    }

    static boolean hasTwitterAuthorization() {
        return StringUtils.isNotBlank(getTokenPublic())
                && StringUtils.isNotBlank(getTokenSecret());
    }

    public static void setTwitterTokens(@Nullable final String tokenPublic,
            @Nullable final String tokenSecret, final boolean enableTwitter) {
        putString(R.string.pref_twitter_token_public, tokenPublic);
        putString(R.string.pref_twitter_token_secret, tokenSecret);
        if (tokenPublic != null) {
            remove(R.string.pref_temp_twitter_token_public);
            remove(R.string.pref_temp_twitter_token_secret);
        }
        setUseTwitter(enableTwitter);
    }

    public static void setTwitterTempTokens(@Nullable final String tokenPublic,
            @Nullable final String tokenSecret) {
        putString(R.string.pref_temp_twitter_token_public, tokenPublic);
        putString(R.string.pref_temp_twitter_token_secret, tokenSecret);
    }

    public static ImmutablePair<String, String> getTempToken() {
        final String tokenPublic = getString(R.string.pref_temp_twitter_token_public, null);
        final String tokenSecret = getString(R.string.pref_temp_twitter_token_secret, null);
        return new ImmutablePair<>(tokenPublic, tokenSecret);
    }

    public static int getVersion() {
        return getInt(R.string.pref_version, 0);
    }

    public static void setVersion(final int version) {
        putInt(R.string.pref_version, version);
    }

    public static boolean isOpenLastDetailsPage() {
        return getBoolean(R.string.pref_opendetailslastpage, false);
    }

    public static int getLastDetailsPage() {
        return getInt(R.string.pref_lastdetailspage, 1);
    }

    public static void setLastDetailsPage(final int index) {
        putInt(R.string.pref_lastdetailspage, index);
    }

    public static int getDefaultNavigationTool() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool,
                String.valueOf(NavigationAppsEnum.COMPASS.id)));
    }

    public static int getDefaultNavigationTool2() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool2,
                String.valueOf(NavigationAppsEnum.INTERNAL_MAP.id)));
    }

    public static LivemapStrategy getLiveMapStrategy() {
        return LivemapStrategy.getById(getInt(R.string.pref_livemapstrategy, LivemapStrategy.AUTO.id));
    }

    public static void setLiveMapStrategy(final LivemapStrategy strategy) {
        putInt(R.string.pref_livemapstrategy, strategy.id);
    }

    public static boolean isDebug() {
        return Log.isDebug();
    }

    public static int getLiveMapHintShowCount() {
        return getInt(R.string.pref_livemaphintshowcount, 0);
    }

    public static void setLiveMapHintShowCount(final int showCount) {
        putInt(R.string.pref_livemaphintshowcount, showCount);
    }

    public static boolean isDbOnSDCard() {
        return getBoolean(R.string.pref_dbonsdcard, false);
    }

    public static void setDbOnSDCard(final boolean dbOnSDCard) {
        putBoolean(R.string.pref_dbonsdcard, dbOnSDCard);
    }

    public static String getGpxExportDir() {
        return getString(R.string.pref_gpxExportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static String getGpxImportDir() {
        return getString(R.string.pref_gpxImportDir,
                Environment.getExternalStorageDirectory().getPath() + "/gpx");
    }

    public static boolean getShareAfterExport() {
        return getBoolean(R.string.pref_shareafterexport, true);
    }

    public static void setShareAfterExport(final boolean shareAfterExport) {
        putBoolean(R.string.pref_shareafterexport, shareAfterExport);
    }

    /**
     * Obtain Trackable action from the last Trackable log.
     *
     * @return
     *          The last Trackable Action or RETRIEVED_IT
     */
    public static int getTrackableAction() {
        return getInt(R.string.pref_trackableaction, LogTypeTrackable.RETRIEVED_IT.id);
    }

    /**
     * Save Trackable action from the last Trackable log.
     *
     * @param trackableAction
     *          The Trackable Action to remember
     */
    public static void setTrackableAction(final int trackableAction) {
        putInt(R.string.pref_trackableaction, trackableAction);
    }

    private static String getCustomRenderThemeBaseFolder() {
        return getString(R.string.pref_renderthemepath, "");
    }

    public static String getCustomRenderThemeFilePath() {
        return getString(R.string.pref_renderthemefile, "");
    }

    public static void setCustomRenderThemeFile(final String customRenderThemeFile) {
        putString(R.string.pref_renderthemefile, customRenderThemeFile);
    }

    public static File[] getMapThemeFiles() {
        final File directory = new File(getCustomRenderThemeBaseFolder());
        final List<File> result = new ArrayList<>();
        FileUtils.listDir(result, directory, new ExtensionsBasedFileSelector(new String[] { "xml" }), null);

        return result.toArray(new File[result.size()]);
    }

    private static class ExtensionsBasedFileSelector implements FileSelector {
        private final String[] extensions;
        public ExtensionsBasedFileSelector(final String[] extensions) {
            this.extensions = extensions;
        }
        @Override
        public boolean isSelected(final File file) {
            final String filename = file.getName();
            for (final String ext : extensions) {
                if (StringUtils.endsWithIgnoreCase(filename, ext)) {
                    return true;
                }
            }
            return false;
        }
        @Override
        public boolean shouldEnd() {
            return false;
        }
    }

    /**
     * @return true if plain text log wanted
     */
    public static boolean getPlainLogs() {
        return getBoolean(R.string.pref_plainLogs, false);
    }

    /**
     * Force set the plain text log preference
     *
     * @param plainLogs
     *            wanted or not
     */
    public static void setPlainLogs(final boolean plainLogs) {
        putBoolean(R.string.pref_plainLogs, plainLogs);
    }

    public static boolean getUseNativeUa() {
        return getBoolean(R.string.pref_nativeUa, false);
    }

    @NonNull
    public static String getCacheTwitterMessage() {
        return StringUtils.defaultString(getString(R.string.pref_twitter_cache_message, "I found [NAME] ([URL])."));
    }

    @NonNull
    public static String getTrackableTwitterMessage() {
        return StringUtils.defaultString(getString(R.string.pref_twitter_trackable_message, "I touched [NAME] ([URL])."));
    }

    public static int getLogImageScale() {
        return getInt(R.string.pref_logImageScale, -1);
    }

    public static void setLogImageScale(final int scale) {
        putInt(R.string.pref_logImageScale, scale);
    }

    public static void setExcludeMine(final boolean exclude) {
        putBoolean(R.string.pref_excludemine, exclude);
    }

    static void setLogin(final String username, final String password) {
        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            // erase username and password
            remove(R.string.pref_username);
            remove(R.string.pref_password);
            return;
        }
        // save username and password
        putString(R.string.pref_username, username);
        putString(R.string.pref_password, password);
    }

    public static long getFieldnoteExportDate() {
        return getLong(R.string.pref_fieldNoteExportDate, 0);
    }

    /**
     * Remember date of last field note export.
     */
    public static void setFieldnoteExportDate(final long date) {
        putLong(R.string.pref_fieldNoteExportDate, date);
    }

    public static boolean isUseNavigationApp(final NavigationAppsEnum navApp) {
        return getBoolean(navApp.preferenceKey, true);
    }

    /**
     * Remember the state of the "Upload" checkbox in the field notes export dialog.
     */
    public static void setFieldNoteExportUpload(final boolean upload) {
        putBoolean(R.string.pref_fieldNoteExportUpload, upload);
    }

    public static boolean getFieldNoteExportUpload() {
        return getBoolean(R.string.pref_fieldNoteExportUpload, true);
    }

    /**
     * Remember the state of the "Only new" checkbox in the field notes export dialog.
     */
    public static void setFieldNoteExportOnlyNew(final boolean onlyNew) {
        putBoolean(R.string.pref_fieldNoteExportOnlyNew, onlyNew);
    }

    public static boolean getFieldNoteExportOnlyNew() {
        return getBoolean(R.string.pref_fieldNoteExportOnlyNew, false);
    }

    public static String getECIconSet() {
        return getString(R.string.pref_ec_icons, "1");
    }

    /* Store last checksum of changelog for changelog display */
    public static long getLastChangelogChecksum() {
        return getLong(R.string.pref_changelog_last_checksum, 0);
    }

    public static void setLastChangelogChecksum(final long checksum) {
        putLong(R.string.pref_changelog_last_checksum, checksum);
    }

    public static List<String> getLastOpenedCaches() {
        final List<String> history = Arrays.asList(StringUtils.split(getString(R.string.pref_caches_history, StringUtils.EMPTY), HISTORY_SEPARATOR));
        return history.subList(0, Math.min(HISTORY_SIZE, history.size()));
    }

    public static void addCacheToHistory(@NonNull final String geocode) {
        final List<String> history = new ArrayList<>(getLastOpenedCaches());
        // bring entry to front, if it already existed
        history.remove(geocode);
        history.add(0, geocode);
        putString(R.string.pref_caches_history, StringUtils.join(history, HISTORY_SEPARATOR));
    }

    public static boolean useHardwareAcceleration() {
        return getBoolean(R.string.pref_hardware_acceleration, !HW_ACCEL_DISABLED_BY_DEFAULT);
    }

    static void setUseHardwareAcceleration(final boolean useHardwareAcceleration) {
        putBoolean(R.string.pref_hardware_acceleration, useHardwareAcceleration);
    }

    public static String getLastCacheLog() {
        return getString(R.string.pref_last_cache_log, StringUtils.EMPTY);
    }

    public static void setLastCacheLog(final String log) {
        putString(R.string.pref_last_cache_log, log);
    }

    public static String getLastTrackableLog() {
        return getString(R.string.pref_last_trackable_log, StringUtils.EMPTY);
    }

    public static void setLastTrackableLog(final String log) {
        putString(R.string.pref_last_trackable_log, log);
    }

    @Nullable
    public static String getHomeLocation() {
        return getString(R.string.pref_home_location, null);
    }

    public static void setHomeLocation(@NonNull final String homeLocation) {
        putString(R.string.pref_home_location, homeLocation);
    }

    public static void setForceOrientationSensor(final boolean forceOrientationSensor) {
        putBoolean(R.string.pref_force_orientation_sensor, forceOrientationSensor);
    }

    public static boolean useOrientationSensor(final Context context) {
        return OrientationProvider.hasOrientationSensor(context) &&
                (getBoolean(R.string.pref_force_orientation_sensor, false) ||
                    !(RotationProvider.hasRotationSensor(context) || MagnetometerAndAccelerometerProvider.hasMagnetometerAndAccelerometerSensors(context))
                );
    }
}
!@#$%
20190527_012143,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_b00800
package cgeo.geocaching.enumerations;

import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.R;

import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;

import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

/**
 * Different log types
 */
public enum LogType {

    FOUND_IT(2, "2", "found it", "Found it", R.string.log_found, R.drawable.mark_green, R.drawable.marker_found_offline),
    DIDNT_FIND_IT(3, "3", "didn't find it", "Didn't find it", R.string.log_dnf, R.drawable.mark_red, R.drawable.marker_not_found_offline),
    NOTE(4, "4", "write note", "Comment", R.string.log_note, R.drawable.mark_gray, R.drawable.marker_note),
    PUBLISH_LISTING(1003, "24", "publish listing", "", R.string.log_published, R.drawable.mark_green_more),
    ENABLE_LISTING(23, "23", "enable listing", "Ready to search", R.string.log_enabled, R.drawable.mark_green_more),
    ARCHIVE(5, "5", "archive", "Archived", R.string.log_archived, R.drawable.mark_red_more, R.drawable.marker_archive),
    UNARCHIVE(12, "12", "unarchive", "", R.string.log_unarchived, R.drawable.mark_green_more),
    TEMP_DISABLE_LISTING(22, "22", "temporarily disable listing", "Temporarily unavailable", R.string.log_disabled, R.drawable.mark_red_more),
    NEEDS_ARCHIVE(7, "7", "needs archived", "", R.string.log_needs_archived, R.drawable.mark_red, R.drawable.marker_archive),
    WILL_ATTEND(9, "9", "will attend", "Will attend", R.string.log_attend),
    ATTENDED(10, "10", "attended", "Attended", R.string.log_attended, R.drawable.mark_green, R.drawable.marker_found_offline),
    RETRIEVED_IT(13, "13", "retrieved it", "", R.string.log_retrieved, R.drawable.mark_green_more),
    PLACED_IT(14, "14", "placed it", "", R.string.log_placed, R.drawable.mark_green_more),
    GRABBED_IT(19, "19", "grabbed it", "", R.string.log_grabbed, R.drawable.mark_green_more),
    NEEDS_MAINTENANCE(45, "45", "needs maintenance", "Needs maintenance", R.string.log_maintenance_needed, R.drawable.mark_red, R.drawable.marker_maintenance),
    OWNER_MAINTENANCE(46, "46", "owner maintenance", "", R.string.log_maintained, R.drawable.mark_green_more, R.drawable.marker_owner_maintenance),
    UPDATE_COORDINATES(47, "47", "update coordinates", "Moved", R.string.log_update, R.drawable.marker_owner_maintenance),
    DISCOVERED_IT(48, "48", "discovered it", "", R.string.log_discovered, R.drawable.mark_green),
    POST_REVIEWER_NOTE(18, "18", "post reviewer note", "", R.string.log_reviewer),
    SUBMIT_FOR_REVIEW(76, "76", "submit for review", "", R.string.log_submit_for_review),
    VISIT(1001, "75", "visit", "", R.string.log_tb_visit, R.drawable.mark_green),
    WEBCAM_PHOTO_TAKEN(11, "11", "webcam photo taken", "", R.string.log_webcam, R.drawable.mark_green, R.drawable.marker_found_offline),
    ANNOUNCEMENT(74, "74", "announcement", "", R.string.log_announcement),
    MOVE_COLLECTION(69, "69", "unused_collection", "", R.string.log_movecollection),
    MOVE_INVENTORY(70, "70", "unused_inventory", "", R.string.log_moveinventory),
    RETRACT(25, "25", "retract listing", "", R.string.log_retractlisting),
    MARKED_MISSING(16, "16", "marked missing", "", R.string.log_marked_missing, R.drawable.mark_red),
    OC_TEAM_COMMENT(83, null, "X1", "OC Team comment", R.string.log_oc_team_comment),
    UNKNOWN(0, "unknown", "", "", R.string.err_unknown, R.drawable.mark_red); // LogType not initialized yet

    public final int id;
    @Nullable
    public final String iconName;
    @NonNull
    public final String type;
    @NonNull
    public final String oc_type;
    private final int stringId;
    public final int markerId;
    /**
     * Drawable ID for a small overlay image for this log type.
     */
    public final int overlayId;

    LogType(final int id, @Nullable final String iconName, @NonNull final String type, @NonNull final String oc_type,
            final int stringId, final int markerId, final int overlayId) {
        this.id = id;
        this.iconName = iconName;
        this.type = type;
        this.oc_type = oc_type;
        this.stringId = stringId;
        this.markerId = markerId;
        this.overlayId = overlayId;
    }

    LogType(final int id, final String iconName, final String type, final String oc_type, final int stringId,
            final int markerId) {
        this(id, iconName, type, oc_type, stringId, markerId, 0);
    }

    LogType(final int id, final String iconName, final String type, final String oc_type, final int stringId) {
        this(id, iconName, type, oc_type, stringId, R.drawable.mark_gray);
    }

    private final static Map<String, LogType> FIND_BY_ICONNAME = new HashMap<>();
    private final static Map<String, LogType> FIND_BY_TYPE = new HashMap<>();

    static {
        for (final LogType lt : values()) {
            if (lt.iconName != null) {
                FIND_BY_ICONNAME.put(lt.iconName, lt);
            }
            FIND_BY_TYPE.put(lt.type, lt);
        }
    }

    @NonNull
    public static LogType getById(final int id) {
        for (final LogType logType : values()) {
            if (logType.id == id) {
                return logType;
            }
        }
        return UNKNOWN;
    }

    @NonNull
    public static LogType getByIconName(final String imageType) {
        // Special case for post reviewer note, which appears sometimes as
        // 18.png (in individual entries) or as 68.png
        // (in logs counts).
        if ("68".equals(imageType)) {
            return POST_REVIEWER_NOTE;
        }
        final LogType result = imageType != null ? FIND_BY_ICONNAME.get(imageType.toLowerCase(Locale.US).trim()) : null;
        if (result == null) {
            return UNKNOWN;
        }
        return result;
    }

    @NonNull
    public static LogType getByType(final String type) {
        final LogType result = type != null ? FIND_BY_TYPE.get(type.toLowerCase(Locale.US).trim()) : null;
        if (result == null) {
            return UNKNOWN;
        }
        return result;
    }

    @NonNull
    public final String getL10n() {
        return CgeoApplication.getInstance().getBaseContext().getResources().getString(stringId);
    }

    /**
     * Check if the Offline Log is about Archiving.
     *
     * @return True if the Offline LogEntry is about Archiving
     */
    public final boolean isArchiveLog() {
        return this == ARCHIVE || this == NEEDS_ARCHIVE;
    }

    /**
     * Check if the Offline Log is a Found Log.
     *
     * @return True if the Offline LogEntry is a Found
     */
    public final boolean isFoundLog() {
        return this == FOUND_IT || this == ATTENDED || this == WEBCAM_PHOTO_TAKEN;
    }

    /**
     * Check if the LogType is unusual. May lead to user confirmation.
     *
     * @return True if user must confirm Log
     */
    public boolean mustConfirmLog() {
        return isArchiveLog();
    }

    /**
     * get the overlay image ID for showing the offline log type
     */
    public int getOfflineLogOverlay() {
        if (overlayId != 0) {
            return overlayId;
        }
        return R.drawable.marker_unknown_offline;
    }
}
!@#$%
20190527_012143,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_a00800
package cgeo.geocaching.enumerations;

import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.R;

import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;

import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

/**
 * Different log types
 */
public enum LogType {

	FOUND_IT(2, "2", "found it", "Found it", R.string.log_found, R.drawable.mark_green, R.drawable.marker_found_offline),
	DIDNT_FIND_IT(3, "3", "didn't find it", "Didn't find it", R.string.log_dnf, R.drawable.mark_red, R.drawable.marker_not_found_offline),
	NOTE(4, "4", "write note", "Comment", R.string.log_note, R.drawable.mark_gray, R.drawable.marker_note),
	PUBLISH_LISTING(1003, "24", "publish listing", "", R.string.log_published, R.drawable.mark_green_more),
	ENABLE_LISTING(23, "23", "enable listing", "Ready to search", R.string.log_enabled, R.drawable.mark_green_more),
	ARCHIVE(5, "5", "archive", "Archived", R.string.log_archived, R.drawable.mark_red_more, R.drawable.marker_archive),
	UNARCHIVE(12, "12", "unarchive", "", R.string.log_unarchived, R.drawable.mark_green_more),
	TEMP_DISABLE_LISTING(22, "22", "temporarily disable listing", "Temporarily unavailable", R.string.log_disabled, R.drawable.mark_red_more),
	NEEDS_ARCHIVE(7, "7", "needs archived", "", R.string.log_needs_archived, R.drawable.mark_red, R.drawable.marker_archive),
	WILL_ATTEND(9, "9", "will attend", "Will attend", R.string.log_attend),
	ATTENDED(10, "10", "attended", "Attended", R.string.log_attended, R.drawable.mark_green, R.drawable.marker_found_offline),
	RETRIEVED_IT(13, "13", "retrieved it", "", R.string.log_retrieved, R.drawable.mark_green_more),
	PLACED_IT(14, "14", "placed it", "", R.string.log_placed, R.drawable.mark_green_more),
	GRABBED_IT(19, "19", "grabbed it", "", R.string.log_grabbed, R.drawable.mark_green_more),
	NEEDS_MAINTENANCE(45, "45", "needs maintenance", "Needs maintenance", R.string.log_maintenance_needed, R.drawable.mark_red, R.drawable.marker_maintenance),
	OWNER_MAINTENANCE(46, "46", "owner maintenance", "", R.string.log_maintained, R.drawable.mark_green_more, R.drawable.marker_owner_maintenance),
	UPDATE_COORDINATES(47, "47", "update coordinates", "Moved", R.string.log_update, R.drawable.marker_owner_maintenance),
	DISCOVERED_IT(48, "48", "discovered it", "", R.string.log_discovered, R.drawable.mark_green),
	POST_REVIEWER_NOTE(18, "18", "post reviewer note", "", R.string.log_reviewer),
	SUBMIT_FOR_REVIEW(76, "76", "submit for review", "", R.string.log_submit_for_review),
	VISIT(1001, "75", "visit", "", R.string.log_tb_visit, R.drawable.mark_green),
	WEBCAM_PHOTO_TAKEN(11, "11", "webcam photo taken", "", R.string.log_webcam, R.drawable.mark_green, R.drawable.marker_found_offline),
	ANNOUNCEMENT(74, "74", "announcement", "", R.string.log_announcement),
	MOVE_COLLECTION(69, "69", "unused_collection", "", R.string.log_movecollection),
	MOVE_INVENTORY(70, "70", "unused_inventory", "", R.string.log_moveinventory),
	RETRACT(25, "25", "retract listing", "", R.string.log_retractlisting),
	MARKED_MISSING(16, "16", "marked missing", "", R.string.log_marked_missing, R.drawable.mark_red),
	OC_TEAM_COMMENT(83, null, "X1", "OC Team comment", R.string.log_oc_team_comment),
	UNKNOWN(0, "unknown", "", "", R.string.err_unknown, R.drawable.mark_red); // LogType
																				// not
																				// init.
																				// yet

	public final int id;
	@Nullable
	public final String iconName;
	@NonNull
	public final String type;
	@NonNull
	public final String oc_type;
	private final int stringId;
	public final int markerId;
	/**
	 * Drawable ID for a small overlay image for this log type.
	 */
	public final int overlayId;

	LogType(final int id, @Nullable final String iconName, @NonNull final String type, @NonNull final String oc_type,
			final int stringId, final int markerId, final int overlayId) {
		this.id = id;
		this.iconName = iconName;
		this.type = type;
		this.oc_type = oc_type;
		this.stringId = stringId;
		this.markerId = markerId;
		this.overlayId = overlayId;
	}

	LogType(final int id, final String iconName, final String type, final String oc_type, final int stringId,
			final int markerId) {
		this(id, iconName, type, oc_type, stringId, markerId, 0);
	}

	LogType(final int id, final String iconName, final String type, final String oc_type, final int stringId) {
		this(id, iconName, type, oc_type, stringId, R.drawable.mark_gray);
	}

	private final static Map<String, LogType> FIND_BY_ICONNAME = new HashMap<>();
	private final static Map<String, LogType> FIND_BY_TYPE = new HashMap<>();

	static {
		for (final LogType lt : values()) {
			if (lt.iconName != null) {
				FIND_BY_ICONNAME.put(lt.iconName, lt);
			}
			FIND_BY_TYPE.put(lt.type, lt);
		}
	}

	@NonNull
	public static LogType getById(final int id) {
		for (final LogType logType : values()) {
			if (logType.id == id) {
				return logType;
			}
		}
		return UNKNOWN;
	}

	@NonNull
	public static LogType getByIconName(final String imageType) {
		// Special case for post reviewer note, which appears sometimes as
		// 18.png (in individual entries) or as 68.png
		// (in logs counts).
		if ("68".equals(imageType)) {
			return POST_REVIEWER_NOTE;
		}
		final LogType result = imageType != null ? FIND_BY_ICONNAME.get(imageType.toLowerCase(Locale.US).trim()) : null;
		if (result == null) {
			return UNKNOWN;
		}
		return result;
	}

	@NonNull
	public static LogType getByType(final String type) {
		final LogType result = type != null ? FIND_BY_TYPE.get(type.toLowerCase(Locale.US).trim()) : null;
		if (result == null) {
			return UNKNOWN;
		}
		return result;
	}

	@NonNull
	public final String getL10n() {
		return CgeoApplication.getInstance().getBaseContext().getResources().getString(stringId);
	}

	/**
	 * Check if the Offline Log is about Archiving.
	 *
	 * @return True if the Offline LogEntry is about Archiving
	 */
	public final boolean isArchiveLog() {
		return this == ARCHIVE || this == NEEDS_ARCHIVE;
	}

	/**
	 * Check if the Offline Log is a Found Log.
	 *
	 * @return True if the Offline LogEntry is a Found
	 */
	public final boolean isFoundLog() {
		return this == FOUND_IT || this == ATTENDED || this == WEBCAM_PHOTO_TAKEN;
	}

	/**
	 * Check if the LogType is unusual. May lead to user confirmation.
	 *
	 * @return True if user must confirm Log
	 */
	public boolean mustConfirmLog() {
		return isArchiveLog();
	}

	/**
	 * get the overlay image ID for showing the offline log type
	 */
	public int getOfflineLogOverlay() {
		if (overlayId != 0) {
			return overlayId;
		}
		return R.drawable.marker_unknown_offline;
	}
}
!@#$%
20190527_012143,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_c00800
package cgeo.geocaching.enumerations;

import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.R;

import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

/**
 * Different log types
 */
public enum LogType {

	FOUND_IT(2, "2", "found it", "Found it", R.string.log_found, R.drawable.mark_green, R.drawable.marker_found_offline),
	DIDNT_FIND_IT(3, "3", "didn't find it", "Didn't find it", R.string.log_dnf, R.drawable.mark_red, R.drawable.marker_not_found_offline),
	NOTE(4, "4", "write note", "Comment", R.string.log_note, R.drawable.mark_gray, R.drawable.marker_note),
	PUBLISH_LISTING(1003, "24", "publish listing", "", R.string.log_published, R.drawable.mark_green_more),
	ENABLE_LISTING(23, "23", "enable listing", "Ready to search", R.string.log_enabled, R.drawable.mark_green_more),
	ARCHIVE(5, "5", "archive", "Archived", R.string.log_archived, R.drawable.mark_red_more, R.drawable.marker_archive),
	UNARCHIVE(12, "12", "unarchive", "", R.string.log_unarchived, R.drawable.mark_green_more),
	TEMP_DISABLE_LISTING(22, "22", "temporarily disable listing", "Temporarily unavailable", R.string.log_disabled, R.drawable.mark_red_more),
	NEEDS_ARCHIVE(7, "7", "needs archived", "", R.string.log_needs_archived, R.drawable.mark_red, R.drawable.marker_archive),
	WILL_ATTEND(9, "9", "will attend", "Will attend", R.string.log_attend),
	ATTENDED(10, "10", "attended", "Attended", R.string.log_attended, R.drawable.mark_green, R.drawable.marker_found_offline),
	RETRIEVED_IT(13, "13", "retrieved it", "", R.string.log_retrieved, R.drawable.mark_green_more),
	PLACED_IT(14, "14", "placed it", "", R.string.log_placed, R.drawable.mark_green_more),
	GRABBED_IT(19, "19", "grabbed it", "", R.string.log_grabbed, R.drawable.mark_green_more),
	NEEDS_MAINTENANCE(45, "45", "needs maintenance", "Needs maintenance", R.string.log_maintenance_needed, R.drawable.mark_red, R.drawable.marker_maintenance),
	OWNER_MAINTENANCE(46, "46", "owner maintenance", "", R.string.log_maintained, R.drawable.mark_green_more, R.drawable.marker_owner_maintenance),
	UPDATE_COORDINATES(47, "47", "update coordinates", "Moved", R.string.log_update, R.drawable.marker_owner_maintenance),
	DISCOVERED_IT(48, "48", "discovered it", "", R.string.log_discovered, R.drawable.mark_green),
	POST_REVIEWER_NOTE(18, "18", "post reviewer note", "", R.string.log_reviewer),
	SUBMIT_FOR_REVIEW(76, "76", "submit for review", "", R.string.log_submit_for_review),
	VISIT(1001, "75", "visit", "", R.string.log_tb_visit, R.drawable.mark_green),
	WEBCAM_PHOTO_TAKEN(11, "11", "webcam photo taken", "", R.string.log_webcam, R.drawable.mark_green, R.drawable.marker_found_offline),
	ANNOUNCEMENT(74, "74", "announcement", "", R.string.log_announcement),
	MOVE_COLLECTION(69, "69", "unused_collection", "", R.string.log_movecollection),
	MOVE_INVENTORY(70, "70", "unused_inventory", "", R.string.log_moveinventory),
	RETRACT(25, "25", "retract listing", "", R.string.log_retractlisting),
	MARKED_MISSING(16, "16", "marked missing", "", R.string.log_marked_missing, R.drawable.mark_red),
	OC_TEAM_COMMENT(83, null, "X1", "OC Team comment", R.string.log_oc_team_comment),
	UNKNOWN(0, "unknown", "", "", R.string.err_unknown, R.drawable.mark_red); // LogType
																				// not
																				// init.
																				// yet

	public final int id;
	@Nullable
	public final String iconName;
	@NonNull
	public final String type;
	@NonNull
	public final String oc_type;
	private final int stringId;
	public final int markerId;
	/**
	 * Drawable ID for a small overlay image for this log type.
	 */
	public final int overlayId;

	LogType(final int id, @Nullable final String iconName, @NonNull final String type, @NonNull final String oc_type,
			final int stringId, final int markerId, final int overlayId) {
		this.id = id;
		this.iconName = iconName;
		this.type = type;
		this.oc_type = oc_type;
		this.stringId = stringId;
		this.markerId = markerId;
		this.overlayId = overlayId;
	}

	LogType(final int id, final String iconName, final String type, final String oc_type, final int stringId,
			final int markerId) {
		this(id, iconName, type, oc_type, stringId, markerId, 0);
	}

	LogType(final int id, final String iconName, final String type, final String oc_type, final int stringId) {
		this(id, iconName, type, oc_type, stringId, R.drawable.mark_gray);
	}

	private final static Map<String, LogType> FIND_BY_ICONNAME = new HashMap<>();
	private final static Map<String, LogType> FIND_BY_TYPE = new HashMap<>();

	static {
		for (final LogType lt : values()) {
			if (lt.iconName != null) {
				FIND_BY_ICONNAME.put(lt.iconName, lt);
			}
			FIND_BY_TYPE.put(lt.type, lt);
		}
	}

	@NonNull
	public static LogType getById(final int id) {
		for (final LogType logType : values()) {
			if (logType.id == id) {
				return logType;
			}
		}
		return UNKNOWN;
	}

	@NonNull
	public static LogType getByIconName(final String imageType) {
		// Special case for post reviewer note, which appears sometimes as
		// 18.png (in individual entries) or as 68.png
		// (in logs counts).
		if ("68".equals(imageType)) {
			return POST_REVIEWER_NOTE;
		}
		final LogType result = imageType != null ? FIND_BY_ICONNAME.get(imageType.toLowerCase(Locale.US).trim()) : null;
		if (result == null) {
			return UNKNOWN;
		}
		return result;
	}

	@NonNull
	public static LogType getByType(final String type) {
		final LogType result = type != null ? FIND_BY_TYPE.get(type.toLowerCase(Locale.US).trim()) : null;
		if (result == null) {
			return UNKNOWN;
		}
		return result;
	}

	@NonNull
	public final String getL10n() {
		return CgeoApplication.getInstance().getBaseContext().getResources().getString(stringId);
	}

	/**
	 * Check if the Offline Log is about Archiving.
	 *
	 * @return True if the Offline LogEntry is about Archiving
	 */
	public final boolean isArchiveLog() {
		return this == ARCHIVE || this == NEEDS_ARCHIVE;
	}

	/**
	 * Check if the Offline Log is a Found Log.
	 *
	 * @return True if the Offline LogEntry is a Found
	 */
	public final boolean isFoundLog() {
		return this == FOUND_IT || this == ATTENDED || this == WEBCAM_PHOTO_TAKEN;
	}

	/**
	 * Check if the LogType is unusual. May lead to user confirmation.
	 *
	 * @return True if user must confirm Log
	 */
	public boolean mustConfirmLog() {
		return isArchiveLog();
	}

	/**
	 * get the overlay image ID for showing the offline log type
	 */
	public int getOfflineLogOverlay() {
		if (overlayId != 0) {
			return overlayId;
		}
		return R.drawable.marker_unknown_offline;
	}

    /**
     * return the collection of found log type ids, to be used in the parser
     */
    public static Collection<String> foundLogTypes() {
        final ArrayList<String> foundLogTypes = new ArrayList<>();
        for (final LogType logType : LogType.values()) {
            if (logType.isFoundLog()) {
                foundLogTypes.add(String.valueOf(logType.id));
            }
        }
        return foundLogTypes;
    }
}
!@#$%
20190527_012532,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_b08020
package cgeo.geocaching.models;

import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.LogCacheActivity;
import cgeo.geocaching.R;
import cgeo.geocaching.SearchResult;
import cgeo.geocaching.StaticMapsProvider;
import cgeo.geocaching.activity.ActivityMixin;
import cgeo.geocaching.activity.SimpleWebviewActivity;
import cgeo.geocaching.connector.ConnectorFactory;
import cgeo.geocaching.connector.IConnector;
import cgeo.geocaching.connector.ILoggingManager;
import cgeo.geocaching.connector.capability.ISearchByCenter;
import cgeo.geocaching.connector.capability.ISearchByGeocode;
import cgeo.geocaching.connector.gc.GCConnector;
import cgeo.geocaching.connector.gc.GCConstants;
import cgeo.geocaching.connector.gc.Tile;
import cgeo.geocaching.connector.gc.UncertainProperty;
import cgeo.geocaching.connector.trackable.TrackableBrand;
import cgeo.geocaching.enumerations.CacheSize;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.CoordinatesType;
import cgeo.geocaching.enumerations.LoadFlags;
import cgeo.geocaching.enumerations.LoadFlags.RemoveFlag;
import cgeo.geocaching.enumerations.LoadFlags.SaveFlag;
import cgeo.geocaching.enumerations.LogType;
import cgeo.geocaching.enumerations.WaypointType;
import cgeo.geocaching.list.StoredList;
import cgeo.geocaching.location.Geopoint;
import cgeo.geocaching.maps.mapsforge.v6.caches.GeoitemRef;
import cgeo.geocaching.network.HtmlImage;
import cgeo.geocaching.settings.Settings;
import cgeo.geocaching.storage.DataStore;
import cgeo.geocaching.storage.DataStore.StorageLocation;
import cgeo.geocaching.utils.CalendarUtils;
import cgeo.geocaching.utils.CancellableHandler;
import cgeo.geocaching.utils.ImageUtils;
import cgeo.geocaching.utils.LazyInitializedList;
import cgeo.geocaching.utils.Log;
import cgeo.geocaching.utils.LogTemplateProvider;
import cgeo.geocaching.utils.LogTemplateProvider.LogContext;
import cgeo.geocaching.utils.MatcherWrapper;

import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.collections4.ListUtils;
import org.apache.commons.lang3.BooleanUtils;
import org.apache.commons.lang3.ObjectUtils;
import org.apache.commons.lang3.StringUtils;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;

import android.app.Activity;
import android.content.Intent;
import android.content.res.Resources;
import android.net.Uri;
import android.os.Environment;
import android.os.Handler;
import android.os.Message;
import android.os.Parcelable;
import android.text.Html;

import java.io.File;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.EnumMap;
import java.util.EnumSet;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Set;
import java.util.regex.Pattern;

import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import rx.Scheduler;
import rx.Subscription;
import rx.functions.Action0;
import rx.schedulers.Schedulers;

/**
 * Internal representation of a "cache"
 */
public class Geocache implements IWaypoint {

    private static final int OWN_WP_PREFIX_OFFSET = 17;
    private long updated = 0;
    private long detailedUpdate = 0;
    private long visitedDate = 0;
    private Set<Integer> lists = new HashSet<>();
    private boolean detailed = false;

    @NonNull
    private String geocode = "";
    private String cacheId = "";
    private String guid = "";
    private UncertainProperty<CacheType> cacheType = new UncertainProperty<>(CacheType.UNKNOWN, Tile.ZOOMLEVEL_MIN - 1);
    private String name = "";
    private String ownerDisplayName = "";
    private String ownerUserId = "";
    @Nullable
    private Date hidden = null;
    /**
     * lazy initialized
     */
    private String hint = null;
    @NonNull private CacheSize size = CacheSize.UNKNOWN;
    private float difficulty = 0;
    private float terrain = 0;
    private Float direction = null;
    private Float distance = null;
    /**
     * lazy initialized
     */
    private String location = null;
    private UncertainProperty<Geopoint> coords = new UncertainProperty<>(null);
    private boolean reliableLatLon = false;
    private String personalNote = null;
    /**
     * lazy initialized
     */
    private String shortdesc = null;
    /**
     * lazy initialized
     */
    private String description = null;
    private Boolean disabled = null;
    private Boolean archived = null;
    private Boolean premiumMembersOnly = null;
    private Boolean found = null;
    private Boolean favorite = null;
    private Boolean onWatchlist = null;
    private Boolean logOffline = null;
    private int watchlistCount = -1; // valid numbers are larger than -1
    private int favoritePoints = 0;
    private float rating = 0; // valid ratings are larger than zero
    private int votes = 0;
    private float myVote = 0; // valid ratings are larger than zero
    private int inventoryItems = 0;
    private final LazyInitializedList<String> attributes = new LazyInitializedList<String>() {
        @Override
        public List<String> call() {
            return inDatabase() ? DataStore.loadAttributes(geocode) : new LinkedList<String>();
        }
    };
    private final LazyInitializedList<Waypoint> waypoints = new LazyInitializedList<Waypoint>() {
        @Override
        public List<Waypoint> call() {
            return inDatabase() ? DataStore.loadWaypoints(geocode) : new LinkedList<Waypoint>();
        }
    };
    private List<Image> spoilers = null;

    private List<Trackable> inventory = null;
    private Map<LogType, Integer> logCounts = new EnumMap<>(LogType.class);
    private boolean userModifiedCoords = false;
    // temporary values
    private boolean statusChecked = false;
    private String directionImg = "";
    private String nameForSorting;
    private final EnumSet<StorageLocation> storageLocation = EnumSet.of(StorageLocation.HEAP);
    private boolean finalDefined = false;
    private boolean logPasswordRequired = false;
    private LogEntry offlineLogs = null;

    private static final Pattern NUMBER_PATTERN = Pattern.compile("\\d+");

    private Handler changeNotificationHandler = null;

    public void setChangeNotificationHandler(final Handler newNotificationHandler) {
        changeNotificationHandler = newNotificationHandler;
    }

    /**
     * Sends a change notification to interested parties
     */
    private void notifyChange() {
        if (changeNotificationHandler != null) {
            changeNotificationHandler.sendEmptyMessage(0);
        }
    }

    /**
     * Gather missing information for new Geocache object from the stored Geocache object.
     * This is called in the new Geocache parsed from website to set information not yet
     * parsed.
     *
     * @param other
     *            the other version, or null if non-existent
     * @return true if this cache is "equal" to the other version
     */
    public boolean gatherMissingFrom(final Geocache other) {
        if (other == null) {
            return false;
        }
        if (other == this) {
            return true;
        }

        updated = System.currentTimeMillis();
        // if parsed cache is not yet detailed and stored is, the information of
        // the parsed cache will be overwritten
        if (!detailed && other.detailed) {
            detailed = true;
            detailedUpdate = other.detailedUpdate;
            // boolean values must be enumerated here. Other types are assigned outside this if-statement
            reliableLatLon = other.reliableLatLon;
            finalDefined = other.finalDefined;
        }

        if (premiumMembersOnly == null) {
            premiumMembersOnly = other.premiumMembersOnly;
        }
        if (found == null) {
            found = other.found;
        }
        if (disabled == null) {
            disabled = other.disabled;
        }
        if (favorite == null) {
            favorite = other.favorite;
        }
        if (archived == null) {
            archived = other.archived;
        }
        if (onWatchlist == null) {
            onWatchlist = other.onWatchlist;
        }
        if (logOffline == null) {
            logOffline = other.logOffline;
        }
        if (visitedDate == 0) {
            visitedDate = other.visitedDate;
        }
        if (lists.isEmpty()) {
            lists.addAll(other.lists);
        }
        if (StringUtils.isBlank(geocode)) {
            geocode = other.geocode;
        }
        if (StringUtils.isBlank(cacheId)) {
            cacheId = other.cacheId;
        }
        if (StringUtils.isBlank(guid)) {
            guid = other.guid;
        }
        cacheType = UncertainProperty.getMergedProperty(cacheType, other.cacheType);
        if (StringUtils.isBlank(name)) {
            name = other.name;
        }
        if (StringUtils.isBlank(ownerDisplayName)) {
            ownerDisplayName = other.ownerDisplayName;
        }
        if (StringUtils.isBlank(ownerUserId)) {
            ownerUserId = other.ownerUserId;
        }
        if (hidden == null) {
            hidden = other.hidden;
        }
        if (!detailed && StringUtils.isBlank(getHint())) {
            hint = other.getHint();
        }
        if (size == CacheSize.UNKNOWN) {
            size = other.size;
        }
        if (difficulty == 0) {
            difficulty = other.difficulty;
        }
        if (terrain == 0) {
            terrain = other.terrain;
        }
        if (direction == null) {
            direction = other.direction;
        }
        if (distance == null) {
            distance = other.distance;
        }
        if (StringUtils.isBlank(getLocation())) {
            location = other.getLocation();
        }
        coords = UncertainProperty.getMergedProperty(coords, other.coords);
        // don't use StringUtils.isBlank here. Otherwise we cannot recognize a note which was deleted on GC
        if (personalNote == null) {
            personalNote = other.personalNote;
        } else if (other.personalNote != null && !personalNote.equals(other.personalNote)) {
            final PersonalNote myNote = new PersonalNote(this);
            final PersonalNote otherNote = new PersonalNote(other);
            final PersonalNote mergedNote = myNote.mergeWith(otherNote);
            personalNote = mergedNote.toString();
        }
        if (!detailed && StringUtils.isBlank(getShortDescription())) {
            shortdesc = other.getShortDescription();
        }
        if (StringUtils.isBlank(getDescription())) {
            description = other.getDescription();
        }
        // FIXME: this makes no sense to favor this over the other. 0 should not be a special case here as it is
        // in the range of acceptable values. This is probably the case at other places (rating, votes, etc.) too.
        if (favoritePoints == 0) {
            favoritePoints = other.favoritePoints;
        }
        if (rating == 0) {
            rating = other.rating;
        }
        if (votes == 0) {
            votes = other.votes;
        }
        if (myVote == 0) {
            myVote = other.myVote;
        }
        if (!detailed && attributes.isEmpty() && other.attributes != null) {
            attributes.addAll(other.attributes);
        }
        if (waypoints.isEmpty()) {
            this.setWaypoints(other.waypoints, false);
        } else {
            final List<Waypoint> newPoints = new ArrayList<>(waypoints);
            Waypoint.mergeWayPoints(newPoints, other.waypoints, false);
            this.setWaypoints(newPoints, false);
        }
        if (spoilers == null) {
            spoilers = other.spoilers;
        }
        if (inventory == null) {
            // If inventoryItems is 0, it can mean both
            // "don't know" or "0 items". Since we cannot distinguish
            // them here, only populate inventoryItems from
            // old data when we have to do it for inventory.
            setInventory(other.inventory);
        }
        if (logCounts.isEmpty()) {
            logCounts = other.logCounts;
        }

        // if cache has ORIGINAL type waypoint ... it is considered that it has modified coordinates, otherwise not
        userModifiedCoords = false;
        for (final Waypoint wpt : waypoints) {
            if (wpt.getWaypointType() == WaypointType.ORIGINAL) {
                userModifiedCoords = true;
                break;
            }
        }

        if (!reliableLatLon) {
            reliableLatLon = other.reliableLatLon;
        }

        return isEqualTo(other);
    }

    /**
     * Compare two caches quickly. For map and list fields only the references are compared !
     *
     * @param other
     *            the other cache to compare this one to
     * @return true if both caches have the same content
     */
    @SuppressWarnings("deprecation")
    @SuppressFBWarnings("FE_FLOATING_POINT_EQUALITY")
    private boolean isEqualTo(final Geocache other) {
        return detailed == other.detailed &&
                StringUtils.equalsIgnoreCase(geocode, other.geocode) &&
                StringUtils.equalsIgnoreCase(name, other.name) &&
                UncertainProperty.equalValues(cacheType, other.cacheType) &&
                size == other.size &&
                ObjectUtils.equals(found, other.found) &&
                ObjectUtils.equals(premiumMembersOnly, other.premiumMembersOnly) &&
                difficulty == other.difficulty &&
                terrain == other.terrain &&
                UncertainProperty.equalValues(coords, other.coords) &&
                reliableLatLon == other.reliableLatLon &&
                ObjectUtils.equals(disabled, other.disabled) &&
                ObjectUtils.equals(archived, other.archived) &&
                ObjectUtils.equals(lists, other.lists) &&
                StringUtils.equalsIgnoreCase(ownerDisplayName, other.ownerDisplayName) &&
                StringUtils.equalsIgnoreCase(ownerUserId, other.ownerUserId) &&
                StringUtils.equalsIgnoreCase(getDescription(), other.getDescription()) &&
                StringUtils.equalsIgnoreCase(personalNote, other.personalNote) &&
                StringUtils.equalsIgnoreCase(getShortDescription(), other.getShortDescription()) &&
                StringUtils.equalsIgnoreCase(getLocation(), other.getLocation()) &&
                ObjectUtils.equals(favorite, other.favorite) &&
                favoritePoints == other.favoritePoints &&
                ObjectUtils.equals(onWatchlist, other.onWatchlist) &&
                (hidden != null ? hidden.equals(other.hidden) : other.hidden == null) &&
                StringUtils.equalsIgnoreCase(guid, other.guid) &&
                StringUtils.equalsIgnoreCase(getHint(), other.getHint()) &&
                StringUtils.equalsIgnoreCase(cacheId, other.cacheId) &&
                (direction != null ? direction.equals(other.direction) : other.direction == null) &&
                (distance != null ? distance.equals(other.distance) : other.distance == null) &&
                rating == other.rating &&
                votes == other.votes &&
                myVote == other.myVote &&
                inventoryItems == other.inventoryItems &&
                attributes == other.attributes &&
                waypoints == other.waypoints &&
                spoilers == other.spoilers &&
                inventory == other.inventory &&
                logCounts == other.logCounts &&
                ObjectUtils.equals(logOffline, other.logOffline) &&
                finalDefined == other.finalDefined;
    }

    public boolean hasTrackables() {
        return inventoryItems > 0;
    }

    public boolean canBeAddedToCalendar() {
        // Is event type with event date set?
        return isEventCache() && hidden != null;
    }

    public boolean isPastEvent() {
        final Calendar cal = Calendar.getInstance();
        cal.setTime(new Date());
        cal.set(Calendar.HOUR_OF_DAY, 0);
        cal.set(Calendar.MINUTE, 0);
        cal.set(Calendar.SECOND, 0);
        cal.set(Calendar.MILLISECOND, 0);
        assert hidden != null; // Eclipse compiler issue
        return hidden.compareTo(cal.getTime()) < 0;
    }

    public boolean isEventCache() {
        return cacheType.getValue().isEvent();
    }

    public void logVisit(final Activity fromActivity) {
        if (!getConnector().canLog(this)) {
            ActivityMixin.showToast(fromActivity, fromActivity.getResources().getString(R.string.err_cannot_log_visit));
            return;
        }
        fromActivity.startActivity(LogCacheActivity.getLogCacheIntent(fromActivity, cacheId, geocode));
    }

    public void logOffline(final Activity fromActivity, final LogType logType) {
        final boolean mustIncludeSignature = StringUtils.isNotBlank(Settings.getSignature()) && Settings.isAutoInsertSignature();
        final String initial = mustIncludeSignature ? LogTemplateProvider.applyTemplates(Settings.getSignature(), new LogContext(this, null, true)) : "";
        logOffline(fromActivity, initial, Calendar.getInstance(), logType);
    }

    public void logOffline(final Activity fromActivity, final String log, final Calendar date, final LogType logType) {
        if (logType == LogType.UNKNOWN) {
            return;
        }
        final boolean status = DataStore.saveLogOffline(geocode, date.getTime(), logType, log);

        final Resources res = fromActivity.getResources();
        if (status) {
            ActivityMixin.showToast(fromActivity, res.getString(R.string.info_log_saved));
            DataStore.saveVisitDate(geocode);
            logOffline = Boolean.TRUE;

            offlineLogs = DataStore.loadLogOffline(geocode);
            notifyChange();
        } else {
            ActivityMixin.showToast(fromActivity, res.getString(R.string.err_log_post_failed));
        }
    }

    /**
     * Get the Offline Log entry if any.
     *
     * @return
     *          The Offline LogEntry
     */
    @Nullable
    public LogEntry getOfflineLog() {
        if (isLogOffline() && offlineLogs == null) {
            offlineLogs = DataStore.loadLogOffline(geocode);
        }
        return offlineLogs;
    }

    /**
     * Get the Offline Log entry if any.
     *
     * @return
     *          The Offline LogEntry else Null
     */
    @Nullable
    public LogType getOfflineLogType() {
        final LogEntry offlineLog = getOfflineLog();
        if (offlineLog == null) {
            return null;
        }
        return offlineLog.getType();
    }

    /**
     * Drop offline log for a given geocode.
     */
    public void clearOfflineLog() {
        DataStore.clearLogOffline(geocode);
        setLogOffline(false);
        notifyChange();
    }

    @NonNull
    public List<LogType> getPossibleLogTypes() {
        return getConnector().getPossibleLogTypes(this);
    }

    public void openInBrowser(final Activity fromActivity) {
        if (getUrl() == null) {
            return;
        }
        final Intent viewIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(getLongUrl()));

        // Check if cgeo is the default, show the chooser to let the user choose a browser
        if (viewIntent.resolveActivity(fromActivity.getPackageManager()).getPackageName().equals(fromActivity.getPackageName())) {
            final Intent chooser = Intent.createChooser(viewIntent, fromActivity.getString(R.string.cache_menu_browser));

            final Intent internalBrowser = new Intent(fromActivity, SimpleWebviewActivity.class);
            internalBrowser.setData(Uri.parse(getUrl()));

            chooser.putExtra(Intent.EXTRA_INITIAL_INTENTS, new Parcelable[] {internalBrowser});


            fromActivity.startActivity(chooser);
        } else {
            fromActivity.startActivity(viewIntent);
        }
    }

    @NonNull
    private IConnector getConnector() {
        return ConnectorFactory.getConnector(this);
    }

    public boolean supportsRefresh() {
        return getConnector() instanceof ISearchByGeocode;
    }

    public boolean supportsWatchList() {
        return getConnector().supportsWatchList();
    }

    public boolean supportsFavoritePoints() {
        return getConnector().supportsFavoritePoints(this);
    }

    public boolean supportsLogging() {
        return getConnector().supportsLogging();
    }

    public boolean supportsLogImages() {
        return getConnector().supportsLogImages();
    }

    public boolean supportsOwnCoordinates() {
        return getConnector().supportsOwnCoordinates();
    }

    @NonNull
    public ILoggingManager getLoggingManager(final LogCacheActivity activity) {
        return getConnector().getLoggingManager(activity, this);
    }

    public float getDifficulty() {
        return difficulty;
    }

    @Override
    @NonNull
    public String getGeocode() {
        return geocode;
    }

    /**
     * @return displayed owner, might differ from the real owner
     */
    public String getOwnerDisplayName() {
        return ownerDisplayName;
    }

    @NonNull
    public CacheSize getSize() {
        return size;
    }

    public float getTerrain() {
        return terrain;
    }

    public boolean isArchived() {
        return BooleanUtils.isTrue(archived);
    }

    public boolean isDisabled() {
        return BooleanUtils.isTrue(disabled);
    }

    public boolean isPremiumMembersOnly() {
        return BooleanUtils.isTrue(premiumMembersOnly);
    }

    public void setPremiumMembersOnly(final boolean members) {
        this.premiumMembersOnly = members;
    }

    /**
     *
     * @return {@code true} if the user is the owner of the cache, {@code false} otherwise
     */
    public boolean isOwner() {
        return getConnector().isOwner(this);
    }

    /**
     * @return GC username of the (actual) owner, might differ from the owner. Never empty.
     */
    @NonNull
    public String getOwnerUserId() {
        return ownerUserId;
    }

    /**
     * Attention, calling this method may trigger a database access for the cache!
     *
     * @return the decrypted hint
     */
    public String getHint() {
        initializeCacheTexts();
        assertTextNotNull(hint, "Hint");
        return hint;
    }

    /**
     * After lazy loading the lazily loaded field must be non {@code null}.
     *
     */
    private static void assertTextNotNull(final String field, final String name) throws InternalError {
        if (field == null) {
            throw new InternalError(name + " field is not allowed to be null here");
        }
    }

    /**
     * Attention, calling this method may trigger a database access for the cache!
     */
    public String getDescription() {
        initializeCacheTexts();
        assertTextNotNull(description, "Description");
        return description;
    }

    /**
     * loads long text parts of a cache on demand (but all fields together)
     */
    private void initializeCacheTexts() {
        if (description == null || shortdesc == null || hint == null || location == null) {
            if (inDatabase()) {
                final Geocache partial = DataStore.loadCacheTexts(this.getGeocode());
                if (description == null) {
                    setDescription(partial.getDescription());
                }
                if (shortdesc == null) {
                    setShortDescription(partial.getShortDescription());
                }
                if (hint == null) {
                    setHint(partial.getHint());
                }
                if (location == null) {
                    setLocation(partial.getLocation());
                }
            } else {
                description = StringUtils.defaultString(description);
                shortdesc = StringUtils.defaultString(shortdesc);
                hint = StringUtils.defaultString(hint);
                location = StringUtils.defaultString(location);
            }
        }
    }

    /**
     * Attention, calling this method may trigger a database access for the cache!
     */
    public String getShortDescription() {
        initializeCacheTexts();
        assertTextNotNull(shortdesc, "Short description");
        return shortdesc;
    }

    @Override
    public String getName() {
        return name;
    }

    public String getCacheId() {
        if (StringUtils.isBlank(cacheId) && getConnector().equals(GCConnector.getInstance())) {
            return String.valueOf(GCConstants.gccodeToGCId(geocode));
        }

        return cacheId;
    }

    public String getGuid() {
        return guid;
    }

    /**
     * Attention, calling this method may trigger a database access for the cache!
     */
    public String getLocation() {
        initializeCacheTexts();
        assertTextNotNull(location, "Location");
        return location;
    }

    public String getPersonalNote() {
        // non premium members have no personal notes, premium members have an empty string by default.
        // map both to null, so other code doesn't need to differentiate
        return StringUtils.defaultIfBlank(personalNote, null);
    }

    public boolean supportsCachesAround() {
        return getConnector() instanceof ISearchByCenter;
    }

    public void shareCache(@NonNull final Activity fromActivity, final Resources res) {
        final Intent intent = getShareIntent();

        fromActivity.startActivity(Intent.createChooser(intent, res.getText(R.string.cache_menu_share)));
    }

    @NonNull
    public Intent getShareIntent() {
        final StringBuilder subject = new StringBuilder("Geocache ");
        subject.append(geocode);
        if (StringUtils.isNotBlank(name)) {
            subject.append(" - ").append(name);
        }

        final Intent intent = new Intent(Intent.ACTION_SEND);
        intent.setType("text/plain");
        intent.putExtra(Intent.EXTRA_SUBJECT, subject.toString());
        intent.putExtra(Intent.EXTRA_TEXT, StringUtils.defaultString(getUrl()));

        return intent;
    }

    @Nullable
    public String getUrl() {
        return getConnector().getCacheUrl(this);
    }

    @Nullable
    public String getLongUrl() {
        return getConnector().getLongCacheUrl(this);
    }

    @Nullable
    public String getCgeoUrl() {
        return getConnector().getCacheUrl(this);
    }

    public boolean supportsGCVote() {
        return StringUtils.startsWithIgnoreCase(geocode, "GC");
    }

    public void setDescription(final String description) {
        this.description = description;
    }

    public boolean isFound() {
        return BooleanUtils.isTrue(found);
    }

    /**
     *
     * @return {@code true} if the user has put a favorite point onto this cache
     */
    public boolean isFavorite() {
        return BooleanUtils.isTrue(favorite);
    }

    public void setFavorite(final boolean favorite) {
        this.favorite = favorite;
    }

    @Nullable
    public Date getHiddenDate() {
        if (hidden != null) {
            return new Date(hidden.getTime());
        }
        return null;
    }

    @NonNull
    public List<String> getAttributes() {
        return attributes.getUnderlyingList();
    }

    public void addSpoiler(final Image spoiler) {
        if (spoilers == null) {
            spoilers = new ArrayList<>();
        }
        spoilers.add(spoiler);
    }

    @NonNull
    public List<Image> getSpoilers() {
        return ListUtils.unmodifiableList(ListUtils.emptyIfNull(spoilers));
    }

    /**
     * @return a statistic how often the caches has been found, disabled, archived etc.
     */
    public Map<LogType, Integer> getLogCounts() {
        return logCounts;
    }

    public int getFavoritePoints() {
        return favoritePoints;
    }

    /**
     * @return the normalized cached name to be used for sorting, taking into account the numerical parts in the name
     */
    public String getNameForSorting() {
        if (nameForSorting == null) {
            nameForSorting = name;
            // pad each number part to a fixed size of 6 digits, so that numerical sorting becomes equivalent to string sorting
            MatcherWrapper matcher = new MatcherWrapper(NUMBER_PATTERN, nameForSorting);
            int start = 0;
            while (matcher.find(start)) {
                final String number = matcher.group();
                nameForSorting = StringUtils.substring(nameForSorting, 0, matcher.start()) + StringUtils.leftPad(number, 6, '0') + StringUtils.substring(nameForSorting, matcher.start() + number.length());
                start = matcher.start() + Math.max(6, number.length());
                matcher = new MatcherWrapper(NUMBER_PATTERN, nameForSorting);
            }
        }
        return nameForSorting;
    }

    public boolean isVirtual() {
        return cacheType.getValue().isVirtual();
    }

    public boolean showSize() {
        return !(size == CacheSize.NOT_CHOSEN || isEventCache() || isVirtual());
    }

    public long getUpdated() {
        return updated;
    }

    public void setUpdated(final long updated) {
        this.updated = updated;
    }

    public long getDetailedUpdate() {
        return detailedUpdate;
    }

    public void setDetailedUpdate(final long detailedUpdate) {
        this.detailedUpdate = detailedUpdate;
    }

    public long getVisitedDate() {
        return visitedDate;
    }

    public void setVisitedDate(final long visitedDate) {
        this.visitedDate = visitedDate;
    }

    public Set<Integer> getLists() {
        return lists;
    }

    public void setLists(final Set<Integer> lists) {
        this.lists = lists;
    }

    public boolean isDetailed() {
        return detailed;
    }

    public void setDetailed(final boolean detailed) {
        this.detailed = detailed;
    }

    public void setHidden(@Nullable final Date hidden) {
        this.hidden = hidden != null ? new Date(hidden.getTime()) : null;
    }

    public Float getDirection() {
        return direction;
    }

    public void setDirection(final Float direction) {
        this.direction = direction;
    }

    public Float getDistance() {
        return distance;
    }

    public void setDistance(final Float distance) {
        this.distance = distance;
    }

    @Override
    public Geopoint getCoords() {
        return coords.getValue();
    }

    public int getCoordZoomLevel() {
        return coords.getCertaintyLevel();
    }

    /**
     * Set reliable coordinates
     */
    public void setCoords(final Geopoint coords) {
        this.coords = new UncertainProperty<>(coords);
    }

    /**
     * Set unreliable coordinates from a certain map zoom level
     */
    public void setCoords(final Geopoint coords, final int zoomlevel) {
        this.coords = new UncertainProperty<>(coords, zoomlevel);
    }

    /**
     * @return true if the coords are from the cache details page and the user has been logged in
     */
    public boolean isReliableLatLon() {
        return getConnector().isReliableLatLon(reliableLatLon);
    }

    public void setReliableLatLon(final boolean reliableLatLon) {
        this.reliableLatLon = reliableLatLon;
    }

    public void setShortDescription(final String shortdesc) {
        this.shortdesc = shortdesc;
    }

    public void setFavoritePoints(final int favoriteCnt) {
        this.favoritePoints = favoriteCnt;
    }

    public float getRating() {
        return rating;
    }

    public void setRating(final float rating) {
        this.rating = rating;
    }

    public int getVotes() {
        return votes;
    }

    public void setVotes(final int votes) {
        this.votes = votes;
    }

    public float getMyVote() {
        return myVote;
    }

    public void setMyVote(final float myVote) {
        this.myVote = myVote;
    }

    /**
     * Get the current inventory count
     *
     * @return the inventory size
     */
    public int getInventoryItems() {
        return inventoryItems;
    }

    /**
     * Set the current inventory count
     *
     * @param inventoryItems the new inventory size
     */
    public void setInventoryItems(final int inventoryItems) {
        this.inventoryItems = inventoryItems;
    }

    /**
     * Get the current inventory
     *
     * @return the Geocache inventory
     */
    public List<Trackable> getInventory() {
        return inventory;
    }

    /**
     * Replace the inventory with new content.
     * No check are performed.
     *
     * @param newInventory to set on Geocache
     */
    public void setInventory(final List<Trackable> newInventory) {
        inventory = newInventory;
        inventoryItems = CollectionUtils.size(inventory);
    }

    /**
     * Add new Trackables to inventory safely.
     * This takes care of removing old items if they are from the same brand.
     * If items are present, data is merged, not duplicated.
     *
     * @param newTrackables
     *            to be added to the Geocache
     */
    public void mergeInventory(@NonNull final List<Trackable> newTrackables, final EnumSet<TrackableBrand> processedBrands) {

        final List<Trackable> mergedTrackables = new ArrayList<>(newTrackables);

        for (final Trackable trackable : ListUtils.emptyIfNull(inventory)) {
            if (processedBrands.contains(trackable.getBrand())) {
                final ListIterator<Trackable> iterator = mergedTrackables.listIterator();
                while (iterator.hasNext()) {
                    final Trackable newTrackable = iterator.next();
                    if (trackable.getUniqueID().equals(newTrackable.getUniqueID())) {
                        // Respect the merge order. New Values replace existing values.
                        trackable.mergeTrackable(newTrackable);
                        iterator.set(trackable);
                        break;
                    }
                }
            } else {
                mergedTrackables.add(trackable);
            }
        }
        setInventory(mergedTrackables);
    }

    /**
     * Add new Trackable to inventory safely.
     * If items are present, data are merged, not duplicated.
     *
     * @param newTrackable to be added to the Geocache
     */
    public void addInventoryItem(final Trackable newTrackable) {
        if (inventory == null) {
            inventory = new ArrayList<>();
        }
        boolean foundTrackable = false;
        for (final Trackable trackable: inventory) {
            if (trackable.getUniqueID().equals(newTrackable.getUniqueID())) {
                // Trackable already present, merge data
                foundTrackable = true;
                trackable.mergeTrackable(newTrackable);
                break;
            }
        }
        if (!foundTrackable) {
            inventory.add(newTrackable);
        }
        inventoryItems = inventory.size();
    }

    /**
     * @return {@code true} if the cache is on the user's watchlist, {@code false} otherwise
     */
    public boolean isOnWatchlist() {
        return BooleanUtils.isTrue(onWatchlist);
    }

    public void setOnWatchlist(final boolean onWatchlist) {
        this.onWatchlist = onWatchlist;
    }

    /**
     *
     * Set the number of users watching this geocache
     * @param watchlistCount Number of users watching this geocache
     */
    public void setWatchlistCount(final int watchlistCount) {
        this.watchlistCount = watchlistCount;
    }

    /**
     *
     * get the number of users watching this geocache
     * @return watchlistCount Number of users watching this geocache
     */
    public int getWatchlistCount() {
        return watchlistCount;
    }

    /**
     * return an immutable list of waypoints.
     *
     * @return always non {@code null}
     */
    @NonNull
    public List<Waypoint> getWaypoints() {
        return waypoints.getUnderlyingList();
    }

    /**
     * @param waypoints
     *            List of waypoints to set for cache
     * @param saveToDatabase
     *            Indicates whether to add the waypoints to the database. Should be false if
     *            called while loading or building a cache
     * @return {@code true} if waypoints successfully added to waypoint database
     */
    public boolean setWaypoints(@Nullable final List<Waypoint> waypoints, final boolean saveToDatabase) {
        this.waypoints.clear();
        if (waypoints != null) {
            this.waypoints.addAll(waypoints);
        }
        finalDefined = false;
        if (waypoints != null) {
            for (final Waypoint waypoint : waypoints) {
                waypoint.setGeocode(geocode);
                if (waypoint.isFinalWithCoords()) {
                    finalDefined = true;
                }
            }
        }
        return saveToDatabase && DataStore.saveWaypoints(this);
    }

    /**
     * The list of logs is immutable, because it is directly fetched from the database on demand, and not stored at this
     * object. If you want to modify logs, you have to load all logs of the cache, create a new list from the existing
     * list and store that new list in the database.
     *
     * @return immutable list of logs
     */
    @NonNull
    public List<LogEntry> getLogs() {
        return inDatabase() ? DataStore.loadLogs(geocode) : Collections.<LogEntry>emptyList();
    }

    /**
     * @return only the logs of friends
     */
    @NonNull
    public List<LogEntry> getFriendsLogs() {
        final List<LogEntry> friendLogs = new ArrayList<>();
        for (final LogEntry log : getLogs()) {
            if (log.friend) {
                friendLogs.add(log);
            }
        }
        return Collections.unmodifiableList(friendLogs);
    }

    public boolean isLogOffline() {
        return BooleanUtils.isTrue(logOffline);
    }

    public void setLogOffline(final boolean logOffline) {
        this.logOffline = logOffline;
    }

    public boolean isStatusChecked() {
        return statusChecked;
    }

    public void setStatusChecked(final boolean statusChecked) {
        this.statusChecked = statusChecked;
    }

    public String getDirectionImg() {
        return directionImg;
    }

    public void setDirectionImg(final String directionImg) {
        this.directionImg = directionImg;
    }

    public void setGeocode(@NonNull final String geocode) {
        this.geocode = StringUtils.upperCase(geocode);
    }

    public void setCacheId(final String cacheId) {
        this.cacheId = cacheId;
    }

    public void setGuid(final String guid) {
        this.guid = guid;
    }

    public void setName(final String name) {
        this.name = name;
    }

    public void setOwnerDisplayName(final String ownerDisplayName) {
        this.ownerDisplayName = ownerDisplayName;
    }

    public void setOwnerUserId(final String ownerUserId) {
        this.ownerUserId = ownerUserId;
    }

    public void setHint(final String hint) {
        this.hint = hint;
    }

    public void setSize(@NonNull final CacheSize size) {
        this.size = size;
    }

    public void setDifficulty(final float difficulty) {
        this.difficulty = difficulty;
    }

    public void setTerrain(final float terrain) {
        this.terrain = terrain;
    }

    public void setLocation(final String location) {
        this.location = location;
    }

    public void setPersonalNote(final String personalNote) {
        this.personalNote = StringUtils.trimToNull(personalNote);
    }

    public void setDisabled(final boolean disabled) {
        this.disabled = disabled;
    }

    public void setArchived(final boolean archived) {
        this.archived = archived;
    }

    public void setFound(final boolean found) {
        this.found = found;
    }

    public void setAttributes(final List<String> attributes) {
        this.attributes.clear();
        if (attributes != null) {
            this.attributes.addAll(attributes);
        }
    }

    public void setSpoilers(final List<Image> spoilers) {
        this.spoilers = spoilers;
    }

    public void setLogCounts(final Map<LogType, Integer> logCounts) {
        this.logCounts = logCounts;
    }

    /*
     * (non-Javadoc)
     *
     * @see cgeo.geocaching.IBasicCache#getType()
     *
     * @returns Never null
     */
    public CacheType getType() {
        return cacheType.getValue();
    }

    public void setType(final CacheType cacheType) {
        if (cacheType == null || cacheType == CacheType.ALL) {
            throw new IllegalArgumentException("Illegal cache type");
        }
        this.cacheType = new UncertainProperty<>(cacheType);
    }

    public void setType(final CacheType cacheType, final int zoomlevel) {
        if (cacheType == null || cacheType == CacheType.ALL) {
            throw new IllegalArgumentException("Illegal cache type");
        }
        this.cacheType = new UncertainProperty<>(cacheType, zoomlevel);
    }

    public boolean hasDifficulty() {
        return difficulty > 0f;
    }

    public boolean hasTerrain() {
        return terrain > 0f;
    }

    /**
     * @return the storageLocation
     */
    public EnumSet<StorageLocation> getStorageLocation() {
        return storageLocation;
    }

    /**
     * @param storageLocation
     *            the storageLocation to set
     */
    public void addStorageLocation(final StorageLocation storageLocation) {
        this.storageLocation.add(storageLocation);
    }

    /**
     * Check if this cache instance comes from or has been stored into the database.
     */
    public boolean inDatabase() {
        return storageLocation.contains(StorageLocation.DATABASE);
    }

    /**
     * @param waypoint
     *            Waypoint to add to the cache
     * @param saveToDatabase
     *            Indicates whether to add the waypoint to the database. Should be false if
     *            called while loading or building a cache
     * @return {@code true} if waypoint successfully added to waypoint database
     */
    public boolean addOrChangeWaypoint(final Waypoint waypoint, final boolean saveToDatabase) {
        waypoint.setGeocode(geocode);

        if (waypoint.getId() < 0) { // this is a new waypoint
            if (StringUtils.isBlank(waypoint.getPrefix())) {
                assignUniquePrefix(waypoint);
            }
            waypoints.add(waypoint);
            if (waypoint.isFinalWithCoords()) {
                finalDefined = true;
            }
        } else { // this is a waypoint being edited
            final int index = getWaypointIndex(waypoint);
            if (index >= 0) {
                final Waypoint oldWaypoint = waypoints.remove(index);
                waypoint.setPrefix(oldWaypoint.getPrefix());
                //migration
                if (StringUtils.isBlank(waypoint.getPrefix())
                        || StringUtils.equalsIgnoreCase(waypoint.getPrefix(), Waypoint.PREFIX_OWN)) {
                    assignUniquePrefix(waypoint);
                }
            }
            waypoints.add(waypoint);
            // when waypoint was edited, finalDefined may have changed
            resetFinalDefined();
        }
        return saveToDatabase && DataStore.saveWaypoint(waypoint.getId(), geocode, waypoint);
    }

    /*
     * Assigns a unique two-digit (compatibility with gc.com)
     * prefix within the scope of this cache.
     */
    private void assignUniquePrefix(final Waypoint waypoint) {
        // gather existing prefixes
        final Set<String> assignedPrefixes = new HashSet<>();
        for (final Waypoint wp : waypoints) {
            assignedPrefixes.add(wp.getPrefix());
        }

        for (int i = OWN_WP_PREFIX_OFFSET; i < 100; i++) {
            final String prefixCandidate = String.valueOf(i);
            if (!assignedPrefixes.contains(prefixCandidate)) {
                waypoint.setPrefix(prefixCandidate);
                return;
            }
        }

        throw new IllegalStateException("too many waypoints, unable to assign unique prefix");
    }

    public boolean hasWaypoints() {
        return !waypoints.isEmpty();
    }

    public boolean hasFinalDefined() {
        return finalDefined;
    }

    // Only for loading
    public void setFinalDefined(final boolean finalDefined) {
        this.finalDefined = finalDefined;
    }

    /**
     * Reset {@code finalDefined} based on current list of stored waypoints
     */
    private void resetFinalDefined() {
        finalDefined = false;
        for (final Waypoint wp : waypoints) {
            if (wp.isFinalWithCoords()) {
                finalDefined = true;
                break;
            }
        }
    }

    public boolean hasUserModifiedCoords() {
        return userModifiedCoords;
    }

    public void setUserModifiedCoords(final boolean coordsChanged) {
        userModifiedCoords = coordsChanged;
    }

    /**
     * Duplicate a waypoint.
     *
     * @param original
     *            the waypoint to duplicate
     * @return {@code true} if the waypoint was duplicated, {@code false} otherwise (invalid index)
     */
    public boolean duplicateWaypoint(final Waypoint original) {
        if (original == null) {
            return false;
        }
        final int index = getWaypointIndex(original);
        final Waypoint copy = new Waypoint(original);
        copy.setUserDefined();
        copy.setName(CgeoApplication.getInstance().getString(R.string.waypoint_copy_of) + " " + copy.getName());
        waypoints.add(index + 1, copy);
        return DataStore.saveWaypoint(-1, geocode, copy);
    }

    /**
     * delete a user defined waypoint
     *
     * @param waypoint
     *            to be removed from cache
     * @return {@code true}, if the waypoint was deleted
     */
    public boolean deleteWaypoint(final Waypoint waypoint) {
        if (waypoint == null) {
            return false;
        }
        if (waypoint.getId() < 0) {
            return false;
        }
        if (waypoint.isUserDefined()) {
            final int index = getWaypointIndex(waypoint);
            waypoints.remove(index);
            DataStore.deleteWaypoint(waypoint.getId());
            DataStore.removeCache(geocode, EnumSet.of(RemoveFlag.CACHE));
            // Check status if Final is defined
            if (waypoint.isFinalWithCoords()) {
                resetFinalDefined();
            }
            return true;
        }
        return false;
    }

    /**
     * deletes any waypoint
     */

    public void deleteWaypointForce(final Waypoint waypoint) {
        final int index = getWaypointIndex(waypoint);
        waypoints.remove(index);
        DataStore.deleteWaypoint(waypoint.getId());
        DataStore.removeCache(geocode, EnumSet.of(RemoveFlag.CACHE));
        resetFinalDefined();
    }

    /**
     * Find index of given {@code waypoint} in cache's {@code waypoints} list
     *
     * @param waypoint
     *            to find index for
     * @return index in {@code waypoints} if found, -1 otherwise
     */
    private int getWaypointIndex(final Waypoint waypoint) {
        final int id = waypoint.getId();
        for (int index = 0; index < waypoints.size(); index++) {
            if (waypoints.get(index).getId() == id) {
                return index;
            }
        }
        return -1;
    }

    /**
     * Lookup a waypoint by its id.
     *
     * @param id
     *            the id of the waypoint to look for
     * @return waypoint or {@code null}
     */
    public Waypoint getWaypointById(final int id) {
        for (final Waypoint waypoint : waypoints) {
            if (waypoint.getId() == id) {
                return waypoint;
            }
        }
        return null;
    }

    /**
     * Detect coordinates in the personal note and convert them to user defined waypoints. Works by rule of thumb.
     */
    public boolean parseWaypointsFromNote() {
        boolean changed = false;
        for (final Waypoint waypoint : Waypoint.parseWaypointsFromNote(StringUtils.defaultString(getPersonalNote()))) {
            if (!hasIdenticalWaypoint(waypoint.getCoords())) {
                addOrChangeWaypoint(waypoint, false);
                changed = true;
            }
        }
        return changed;
    }

    private boolean hasIdenticalWaypoint(final Geopoint point) {
        for (final Waypoint waypoint: waypoints) {
            // waypoint can have no coords such as a Final set by cache owner
            final Geopoint coords = waypoint.getCoords();
            if (coords != null && coords.equals(point)) {
                return true;
            }
        }
        return false;
    }

    /*
     * For working in the debugger
     * (non-Javadoc)
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        return this.geocode + " " + this.name;
    }

    @Override
    public int hashCode() {
        return StringUtils.defaultString(geocode).hashCode();
    }

    @Override
    public boolean equals(final Object obj) {
        // TODO: explain the following line or remove this non-standard equality method
        // just compare the geocode even if that is not what "equals" normally does
        return this == obj || (obj instanceof Geocache && StringUtils.isNotEmpty(geocode) && geocode.equals(((Geocache) obj).geocode));
    }

    public void store() {
        store(StoredList.STANDARD_LIST_ID, null);
    }

    public void store(final int listId, final CancellableHandler handler) {
        lists.add(listId);
        storeCache(this, null, lists, false, handler);
    }

    @Override
    public int getId() {
        return 0;
    }

    @Override
    public WaypointType getWaypointType() {
        return null;
    }

    @Override
    public CoordinatesType getCoordType() {
        return CoordinatesType.CACHE;
    }

    public Subscription drop(final Handler handler) {
        return Schedulers.io().createWorker().schedule(new Action0() {
            @Override
            public void call() {
                try {
                    dropSynchronous();
                    handler.sendMessage(Message.obtain());
                } catch (final Exception e) {
                    Log.e("cache.drop: ", e);
                }
            }
        });
    }

    public void dropSynchronous() {
        DataStore.markDropped(Collections.singletonList(this));
        DataStore.removeCache(getGeocode(), EnumSet.of(RemoveFlag.CACHE));
    }

    private void warnIncorrectParsingIf(final boolean incorrect, final String field) {
        if (incorrect) {
            Log.w(field + " not parsed correctly for " + geocode);
        }
    }

    private void warnIncorrectParsingIfBlank(final String str, final String field) {
        warnIncorrectParsingIf(StringUtils.isBlank(str), field);
    }

    public void checkFields() {
        warnIncorrectParsingIfBlank(getGeocode(), "geo");
        warnIncorrectParsingIfBlank(getName(), "name");
        warnIncorrectParsingIfBlank(getGuid(), "guid");
        warnIncorrectParsingIf(getTerrain() == 0.0, "terrain");
        warnIncorrectParsingIf(getDifficulty() == 0.0, "difficulty");
        warnIncorrectParsingIfBlank(getOwnerDisplayName(), "owner");
        warnIncorrectParsingIfBlank(getOwnerUserId(), "owner");
        warnIncorrectParsingIf(getHiddenDate() == null, "hidden");
        warnIncorrectParsingIf(getFavoritePoints() < 0, "favoriteCount");
        warnIncorrectParsingIf(getSize() == CacheSize.UNKNOWN, "size");
        warnIncorrectParsingIf(getType() == null || getType() == CacheType.UNKNOWN, "type");
        warnIncorrectParsingIf(getCoords() == null, "coordinates");
        warnIncorrectParsingIfBlank(getLocation(), "location");
    }

    public Subscription refresh(final CancellableHandler handler, final Scheduler scheduler) {
        return scheduler.createWorker().schedule(new Action0() {
            @Override
            public void call() {
                refreshSynchronous(handler);
            }
        });
    }

    public void refreshSynchronous(final CancellableHandler handler) {
        storeCache(null, geocode, lists, true, handler);
    }

    public static void storeCache(final Geocache origCache, final String geocode, final Set<Integer> lists, final boolean forceRedownload, final CancellableHandler handler) {
        try {
            Geocache cache = null;
            // get cache details, they may not yet be complete
            if (origCache != null) {
                SearchResult search = null;
                // only reload the cache if it was already stored or doesn't have full details (by checking the description)
                if (origCache.isOffline() || StringUtils.isBlank(origCache.getDescription())) {
                    search = searchByGeocode(origCache.getGeocode(), null, false, handler);
                }
                if (search != null) {
                    cache = search.getFirstCacheFromResult(LoadFlags.LOAD_CACHE_OR_DB);
                } else {
                    cache = origCache;
                }
            } else if (StringUtils.isNotBlank(geocode)) {
                final SearchResult search = searchByGeocode(geocode, null, forceRedownload, handler);
                if (search != null) {
                    cache = search.getFirstCacheFromResult(LoadFlags.LOAD_CACHE_OR_DB);
                }
            }

            if (cache == null) {
                if (handler != null) {
                    handler.sendMessage(Message.obtain());
                }

                return;
            }

            if (CancellableHandler.isCancelled(handler)) {
                return;
            }

            final HtmlImage imgGetter = new HtmlImage(cache.getGeocode(), false, true, forceRedownload);

            // store images from description
            if (StringUtils.isNotBlank(cache.getDescription())) {
                Html.fromHtml(cache.getDescription(), imgGetter, null);
            }

            if (CancellableHandler.isCancelled(handler)) {
                return;
            }

            // store spoilers
            if (CollectionUtils.isNotEmpty(cache.getSpoilers())) {
                for (final Image oneSpoiler : cache.getSpoilers()) {
                    imgGetter.getDrawable(oneSpoiler.getUrl());
                }
            }

            if (CancellableHandler.isCancelled(handler)) {
                return;
            }

            // store images from logs
            if (Settings.isStoreLogImages()) {
                for (final LogEntry log : cache.getLogs()) {
                    if (log.hasLogImages()) {
                        for (final Image oneLogImg : log.getLogImages()) {
                            imgGetter.getDrawable(oneLogImg.getUrl());
                        }
                    }
                }
            }

            if (CancellableHandler.isCancelled(handler)) {
                return;
            }

            cache.setLists(lists);
            DataStore.saveCache(cache, EnumSet.of(SaveFlag.DB));

            if (CancellableHandler.isCancelled(handler)) {
                return;
            }

            StaticMapsProvider.downloadMaps(cache).mergeWith(imgGetter.waitForEndCompletable(handler)).await();

            if (handler != null) {
                handler.sendEmptyMessage(CancellableHandler.DONE);
            }
        } catch (final Exception e) {
            Log.e("Geocache.storeCache", e);
        }
    }

    public static SearchResult searchByGeocode(final String geocode, final String guid, final boolean forceReload, final CancellableHandler handler) {
        if (StringUtils.isBlank(geocode) && StringUtils.isBlank(guid)) {
            Log.e("Geocache.searchByGeocode: No geocode nor guid given");
            return null;
        }

        if (!forceReload && (DataStore.isOffline(geocode, guid) || DataStore.isThere(geocode, guid, true))) {
            final SearchResult search = new SearchResult();
            final String realGeocode = StringUtils.isNotBlank(geocode) ? geocode : DataStore.getGeocodeForGuid(guid);
            search.addGeocode(realGeocode);
            return search;
        }

        // if we have no geocode, we can't dynamically select the handler, but must explicitly use GC
        if (geocode == null) {
            return GCConnector.getInstance().searchByGeocode(null, guid, handler);
        }

        final IConnector connector = ConnectorFactory.getConnector(geocode);
        if (connector instanceof ISearchByGeocode) {
            return ((ISearchByGeocode) connector).searchByGeocode(geocode, guid, handler);
        }
        return null;
    }

    public boolean isOffline() {
        return !lists.isEmpty() && (lists.size() > 1 || lists.iterator().next() != StoredList.TEMPORARY_LIST.id);
    }

    /**
     * guess an event start time from the description
     *
     * @return start time in minutes after midnight
     */
    public int guessEventTimeMinutes() {
        if (!isEventCache()) {
            return -1;
        }

        final String hourLocalized = CgeoApplication.getInstance().getString(R.string.cache_time_full_hours);
        final List<Pattern> patterns = new ArrayList<>();

        // 12:34
        patterns.add(Pattern.compile("\\b(\\d{1,2})\\:(\\d\\d)\\b"));
        if (StringUtils.isNotBlank(hourLocalized)) {
            // 12:34o'clock
            patterns.add(Pattern.compile("\\b(\\d{1,2})\\:(\\d\\d)" + Pattern.quote(hourLocalized), Pattern.CASE_INSENSITIVE));
            // 17 - 20 o'clock
            patterns.add(Pattern.compile("\\b(\\d{1,2})(?:\\.00)?" + "\\s*(?:-|[a-z]+)\\s?" + "(?:\\d{1,2})(?:\\.00)?" + "\\s?" + Pattern.quote(hourLocalized), Pattern.CASE_INSENSITIVE));
            // 12 o'clock, 12.00 o'clock
            patterns.add(Pattern.compile("\\b(\\d{1,2})(?:\\.(00|15|30|45))?\\s?" + Pattern.quote(hourLocalized), Pattern.CASE_INSENSITIVE));
        }

        final String searchText = getShortDescription() + ' ' + getDescription();
        for (final Pattern pattern : patterns) {
            final MatcherWrapper matcher = new MatcherWrapper(pattern, searchText);
            while (matcher.find()) {
                try {
                    final int hours = Integer.parseInt(matcher.group(1));
                    int minutes = 0;
                    if (matcher.groupCount() >= 2 && StringUtils.isNotEmpty(matcher.group(2))) {
                        minutes = Integer.parseInt(matcher.group(2));
                    }
                    if (hours >= 0 && hours < 24 && minutes >= 0 && minutes < 60) {
                        return hours * 60 + minutes;
                    }
                } catch (final NumberFormatException ignored) {
                    // cannot happen, but static code analysis doesn't know
                }
            }
        }
        return -1;
    }

    public boolean hasStaticMap() {
        return StaticMapsProvider.hasStaticMap(this);
    }

    @NonNull
    public Collection<Image> getImages() {
        final List<Image> result = new LinkedList<>();
        result.addAll(getSpoilers());
        addLocalSpoilersTo(result);
        for (final LogEntry log : getLogs()) {
            result.addAll(log.getLogImages());
        }
        ImageUtils.addImagesFromHtml(result, geocode, getShortDescription(), getDescription());
        return result;
    }

    /**
     * Add spoilers stored locally in <tt>/sdcard/GeocachePhotos</tt>. If a cache is named GC123ABC, the
     * directory will be <tt>/sdcard/GeocachePhotos/C/B/GC123ABC/</tt>.
     *
     * @param spoilers the list to add to
     */
    private void addLocalSpoilersTo(final List<Image> spoilers) {
        if (StringUtils.length(geocode) >= 2) {
            final String suffix = StringUtils.right(geocode, 2);
            final File baseDir = new File(Environment.getExternalStorageDirectory(), "GeocachePhotos");
            final File lastCharDir = new File(baseDir, suffix.substring(1));
            final File secondToLastCharDir = new File(lastCharDir, suffix.substring(0, 1));
            final File finalDir = new File(secondToLastCharDir, geocode);
            final File[] files = finalDir.listFiles();
            if (files != null) {
                for (final File image : files) {
                    spoilers.add(new Image.Builder()
                            .setUrl("file://" + image.getAbsolutePath())
                            .setTitle(image.getName())
                            .build());
                }
            }
        }
    }

    public void setDetailedUpdatedNow() {
        final long now = System.currentTimeMillis();
        setUpdated(now);
        setDetailedUpdate(now);
        setDetailed(true);
    }

    /**
     * Gets whether the user has logged the specific log type for this cache. Only checks the currently stored logs of
     * the cache, so the result might be wrong.
     */
    public boolean hasOwnLog(final LogType logType) {
        for (final LogEntry logEntry : getLogs()) {
            if (logEntry.getType() == logType && logEntry.isOwn()) {
                return true;
            }
        }
        return false;
    }

    public int getMapMarkerId() {
        return getConnector().getCacheMapMarkerId(isDisabled() || isArchived());
    }

    public boolean isLogPasswordRequired() {
        return logPasswordRequired;
    }

    public void setLogPasswordRequired(final boolean required) {
        logPasswordRequired = required;
    }

    public String getWaypointGpxId(final String prefix) {
        return getConnector().getWaypointGpxId(prefix, geocode);
    }

    @NonNull
    public String getWaypointPrefix(final String name) {
        return getConnector().getWaypointPrefix(name);
    }

    /**
     * Get number of overall finds for a cache, or 0 if the number of finds is not known.
     */
    public int getFindsCount() {
        if (getLogCounts().isEmpty()) {
            setLogCounts(inDatabase() ? DataStore.loadLogCounts(getGeocode()) : Collections.<LogType, Integer>emptyMap());
        }
        final Integer logged = getLogCounts().get(LogType.FOUND_IT);
        if (logged != null) {
            return logged;
        }
        return 0;
    }

    public boolean applyDistanceRule() {
        return (getType().applyDistanceRule() || hasUserModifiedCoords()) && getConnector() == GCConnector.getInstance();
    }

    @NonNull
    public LogType getDefaultLogType() {
        if (isEventCache()) {
            final Date eventDate = getHiddenDate();
            final boolean expired = CalendarUtils.isPastEvent(this);

            if (hasOwnLog(LogType.WILL_ATTEND) || expired || (eventDate != null && CalendarUtils.daysSince(eventDate.getTime()) == 0)) {
                return hasOwnLog(LogType.ATTENDED) ? LogType.NOTE : LogType.ATTENDED;
            }
            return LogType.WILL_ATTEND;
        }
        if (isFound()) {
            return LogType.NOTE;
        }
        if (getType() == CacheType.WEBCAM) {
            return LogType.WEBCAM_PHOTO_TAKEN;
        }
        return LogType.FOUND_IT;
    }

    /**
     * Get the geocodes of a collection of caches.
     *
     * @param caches a collection of caches
     * @return the non-blank geocodes of the caches
     */
    @NonNull
    public static Set<String> getGeocodes(@NonNull final Collection<Geocache> caches) {
        final Set<String> geocodes = new HashSet<>(caches.size());
        for (final Geocache cache : caches) {
            final String geocode = cache.getGeocode();
            if (StringUtils.isNotBlank(geocode)) {
                geocodes.add(geocode);
            }
        }
        return geocodes;
    }

    /**
     * Show the hint as toast message. If no hint is available, a default "no hint available" will be shown instead.
     */
    public void showHintToast(final Activity activity) {
        final String hint = getHint();
        ActivityMixin.showToast(activity, StringUtils.defaultIfBlank(hint, activity.getString(R.string.cache_hint_not_available)));
    }

    public GeoitemRef getGeoitemRef() {
        return new GeoitemRef(getGeocode(), getCoordType(), getGeocode(), 0, getName(), getType().markerId);
    }

}
!@#$%
20190527_012532,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_a08020
package cgeo.geocaching.models;

import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.LogCacheActivity;
import cgeo.geocaching.R;
import cgeo.geocaching.SearchResult;
import cgeo.geocaching.StaticMapsProvider;
import cgeo.geocaching.activity.ActivityMixin;
import cgeo.geocaching.activity.SimpleWebviewActivity;
import cgeo.geocaching.connector.ConnectorFactory;
import cgeo.geocaching.connector.IConnector;
import cgeo.geocaching.connector.ILoggingManager;
import cgeo.geocaching.connector.capability.ISearchByCenter;
import cgeo.geocaching.connector.capability.ISearchByGeocode;
import cgeo.geocaching.connector.gc.GCConnector;
import cgeo.geocaching.connector.gc.GCConstants;
import cgeo.geocaching.connector.gc.Tile;
import cgeo.geocaching.connector.gc.UncertainProperty;
import cgeo.geocaching.connector.trackable.TrackableBrand;
import cgeo.geocaching.enumerations.CacheSize;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.CoordinatesType;
import cgeo.geocaching.enumerations.LoadFlags;
import cgeo.geocaching.enumerations.LoadFlags.RemoveFlag;
import cgeo.geocaching.enumerations.LoadFlags.SaveFlag;
import cgeo.geocaching.enumerations.LogType;
import cgeo.geocaching.enumerations.WaypointType;
import cgeo.geocaching.list.StoredList;
import cgeo.geocaching.location.Geopoint;
import cgeo.geocaching.maps.mapsforge.v6.caches.GeoitemRef;
import cgeo.geocaching.network.HtmlImage;
import cgeo.geocaching.settings.Settings;
import cgeo.geocaching.storage.DataStore;
import cgeo.geocaching.storage.DataStore.StorageLocation;
import cgeo.geocaching.utils.CalendarUtils;
import cgeo.geocaching.utils.CancellableHandler;
import cgeo.geocaching.utils.ImageUtils;
import cgeo.geocaching.utils.LazyInitializedList;
import cgeo.geocaching.utils.Log;
import cgeo.geocaching.utils.LogTemplateProvider;
import cgeo.geocaching.utils.LogTemplateProvider.LogContext;
import cgeo.geocaching.utils.MatcherWrapper;

import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.collections4.ListUtils;
import org.apache.commons.lang3.BooleanUtils;
import org.apache.commons.lang3.ObjectUtils;
import org.apache.commons.lang3.StringUtils;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;

import android.app.Activity;
import android.content.Intent;
import android.content.res.Resources;
import android.net.Uri;
import android.os.Environment;
import android.os.Handler;
import android.os.Message;
import android.os.Parcelable;
import android.text.Html;

import java.io.File;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.EnumMap;
import java.util.EnumSet;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Set;
import java.util.regex.Pattern;

import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import rx.Scheduler;
import rx.Subscription;
import rx.functions.Action0;
import rx.schedulers.Schedulers;

/**
 * Internal representation of a "cache"
 */
public class Geocache implements IWaypoint {

    private static final int OWN_WP_PREFIX_OFFSET = 17;
    private long updated = 0;
    private long detailedUpdate = 0;
    private long visitedDate = 0;
    private Set<Integer> lists = new HashSet<>();
    private boolean detailed = false;

    @NonNull
    private String geocode = "";
    private String cacheId = "";
    private String guid = "";
    private UncertainProperty<CacheType> cacheType = new UncertainProperty<>(CacheType.UNKNOWN, Tile.ZOOMLEVEL_MIN - 1);
    private String name = "";
    private String ownerDisplayName = "";
    private String ownerUserId = "";
    @Nullable
    private Date hidden = null;
    /**
     * lazy initialized
     */
    private String hint = null;
    @NonNull private CacheSize size = CacheSize.UNKNOWN;
    private float difficulty = 0;
    private float terrain = 0;
    private Float direction = null;
    private Float distance = null;
    /**
     * lazy initialized
     */
    private String location = null;
    private UncertainProperty<Geopoint> coords = new UncertainProperty<>(null);
    private boolean reliableLatLon = false;
    private String personalNote = null;
    /**
     * lazy initialized
     */
    private String shortdesc = null;
    /**
     * lazy initialized
     */
    private String description = null;
    private Boolean disabled = null;
    private Boolean archived = null;
    private Boolean premiumMembersOnly = null;
    private Boolean found = null;
    private Boolean favorite = null;
    private Boolean onWatchlist = null;
    private Boolean logOffline = null;
    private int watchlistCount = -1; // valid numbers are larger than -1
    private int favoritePoints = 0;
    private float rating = 0; // valid ratings are larger than zero
    private int votes = 0;
    private float myVote = 0; // valid ratings are larger than zero
    private int inventoryItems = 0;
    private final LazyInitializedList<String> attributes = new LazyInitializedList<String>() {
        @Override
        public List<String> call() {
            return inDatabase() ? DataStore.loadAttributes(geocode) : new LinkedList<String>();
        }
    };
    private final LazyInitializedList<Waypoint> waypoints = new LazyInitializedList<Waypoint>() {
        @Override
        public List<Waypoint> call() {
            return inDatabase() ? DataStore.loadWaypoints(geocode) : new LinkedList<Waypoint>();
        }
    };
    private List<Image> spoilers = null;

    private List<Trackable> inventory = null;
    private Map<LogType, Integer> logCounts = new EnumMap<>(LogType.class);
    private boolean userModifiedCoords = false;
    // temporary values
    private boolean statusChecked = false;
    private String directionImg = "";
    private String nameForSorting;
    private final EnumSet<StorageLocation> storageLocation = EnumSet.of(StorageLocation.HEAP);
    private boolean finalDefined = false;
    private boolean logPasswordRequired = false;
    private LogEntry offlineLogs = null;

    private static final Pattern NUMBER_PATTERN = Pattern.compile("\\d+");

    private Handler changeNotificationHandler = null;

    public void setChangeNotificationHandler(final Handler newNotificationHandler) {
        changeNotificationHandler = newNotificationHandler;
    }

    /**
     * Sends a change notification to interested parties
     */
    private void notifyChange() {
        if (changeNotificationHandler != null) {
            changeNotificationHandler.sendEmptyMessage(0);
        }
    }

    /**
     * Gather missing information for new Geocache object from the stored Geocache object.
     * This is called in the new Geocache parsed from website to set information not yet
     * parsed.
     *
     * @param other
     *            the other version, or null if non-existent
     * @return true if this cache is "equal" to the other version
     */
    public boolean gatherMissingFrom(final Geocache other) {
        if (other == null) {
            return false;
        }
        if (other == this) {
            return true;
        }

        updated = System.currentTimeMillis();
        // if parsed cache is not yet detailed and stored is, the information of
        // the parsed cache will be overwritten
        if (!detailed && other.detailed) {
            detailed = true;
            detailedUpdate = other.detailedUpdate;
            // boolean values must be enumerated here. Other types are assigned outside this if-statement
            reliableLatLon = other.reliableLatLon;
            finalDefined = other.finalDefined;
        }

        if (premiumMembersOnly == null) {
            premiumMembersOnly = other.premiumMembersOnly;
        }
        if (found == null) {
            found = other.found;
        }
        if (disabled == null) {
            disabled = other.disabled;
        }
        if (favorite == null) {
            favorite = other.favorite;
        }
        if (archived == null) {
            archived = other.archived;
        }
        if (onWatchlist == null) {
            onWatchlist = other.onWatchlist;
        }
        if (logOffline == null) {
            logOffline = other.logOffline;
        }
        if (visitedDate == 0) {
            visitedDate = other.visitedDate;
        }
        if (lists.isEmpty()) {
            lists.addAll(other.lists);
        }
        if (StringUtils.isBlank(geocode)) {
            geocode = other.geocode;
        }
        if (StringUtils.isBlank(cacheId)) {
            cacheId = other.cacheId;
        }
        if (StringUtils.isBlank(guid)) {
            guid = other.guid;
        }
        cacheType = UncertainProperty.getMergedProperty(cacheType, other.cacheType);
        if (StringUtils.isBlank(name)) {
            name = other.name;
        }
        if (StringUtils.isBlank(ownerDisplayName)) {
            ownerDisplayName = other.ownerDisplayName;
        }
        if (StringUtils.isBlank(ownerUserId)) {
            ownerUserId = other.ownerUserId;
        }
        if (hidden == null) {
            hidden = other.hidden;
        }
        if (!detailed && StringUtils.isBlank(getHint())) {
            hint = other.getHint();
        }
        if (size == CacheSize.UNKNOWN) {
            size = other.size;
        }
        if (difficulty == 0) {
            difficulty = other.difficulty;
        }
        if (terrain == 0) {
            terrain = other.terrain;
        }
        if (direction == null) {
            direction = other.direction;
        }
        if (distance == null) {
            distance = other.distance;
        }
        if (StringUtils.isBlank(getLocation())) {
            location = other.getLocation();
        }
        coords = UncertainProperty.getMergedProperty(coords, other.coords);
        // don't use StringUtils.isBlank here. Otherwise we cannot recognize a note which was deleted on GC
        if (personalNote == null) {
            personalNote = other.personalNote;
        } else if (other.personalNote != null && !personalNote.equals(other.personalNote)) {
            final PersonalNote myNote = new PersonalNote(this);
            final PersonalNote otherNote = new PersonalNote(other);
            final PersonalNote mergedNote = myNote.mergeWith(otherNote);
            personalNote = mergedNote.toString();
        }
        if (!detailed && StringUtils.isBlank(getShortDescription())) {
            shortdesc = other.getShortDescription();
        }
        if (StringUtils.isBlank(getDescription())) {
            description = other.getDescription();
        }
        // FIXME: this makes no sense to favor this over the other. 0 should not be a special case here as it is
        // in the range of acceptable values. This is probably the case at other places (rating, votes, etc.) too.
        if (favoritePoints == 0) {
            favoritePoints = other.favoritePoints;
        }
        if (rating == 0) {
            rating = other.rating;
        }
        if (votes == 0) {
            votes = other.votes;
        }
        if (myVote == 0) {
            myVote = other.myVote;
        }
        if (!detailed && attributes.isEmpty() && other.attributes != null) {
            attributes.addAll(other.attributes);
        }
        if (waypoints.isEmpty()) {
            this.setWaypoints(other.waypoints, false);
        }
        else {
            final List<Waypoint> newPoints = new ArrayList<>(waypoints);
            Waypoint.mergeWayPoints(newPoints, other.waypoints, false);
            this.setWaypoints(newPoints, false);
        }
        if (spoilers == null) {
            spoilers = other.spoilers;
        }
        if (inventory == null) {
            // If inventoryItems is 0, it can mean both
            // "don't know" or "0 items". Since we cannot distinguish
            // them here, only populate inventoryItems from
            // old data when we have to do it for inventory.
            setInventory(other.inventory);
        }
        if (logCounts.isEmpty()) {
            logCounts = other.logCounts;
        }

        // if cache has ORIGINAL type waypoint ... it is considered that it has modified coordinates, otherwise not
        userModifiedCoords = false;
        for (final Waypoint wpt : waypoints) {
            if (wpt.getWaypointType() == WaypointType.ORIGINAL) {
                userModifiedCoords = true;
                break;
            }
        }

        if (!reliableLatLon) {
            reliableLatLon = other.reliableLatLon;
        }

        return isEqualTo(other);
    }

    /**
     * Compare two caches quickly. For map and list fields only the references are compared !
     *
     * @param other
     *            the other cache to compare this one to
     * @return true if both caches have the same content
     */
    @SuppressWarnings("deprecation")
    @SuppressFBWarnings("FE_FLOATING_POINT_EQUALITY")
    private boolean isEqualTo(final Geocache other) {
        return detailed == other.detailed &&
                StringUtils.equalsIgnoreCase(geocode, other.geocode) &&
                StringUtils.equalsIgnoreCase(name, other.name) &&
                UncertainProperty.equalValues(cacheType, other.cacheType) &&
                size == other.size &&
                ObjectUtils.equals(found, other.found) &&
                ObjectUtils.equals(premiumMembersOnly, other.premiumMembersOnly) &&
                difficulty == other.difficulty &&
                terrain == other.terrain &&
                UncertainProperty.equalValues(coords, other.coords) &&
                reliableLatLon == other.reliableLatLon &&
                ObjectUtils.equals(disabled, other.disabled) &&
                ObjectUtils.equals(archived, other.archived) &&
                ObjectUtils.equals(lists, other.lists) &&
                StringUtils.equalsIgnoreCase(ownerDisplayName, other.ownerDisplayName) &&
                StringUtils.equalsIgnoreCase(ownerUserId, other.ownerUserId) &&
                StringUtils.equalsIgnoreCase(getDescription(), other.getDescription()) &&
                StringUtils.equalsIgnoreCase(personalNote, other.personalNote) &&
                StringUtils.equalsIgnoreCase(getShortDescription(), other.getShortDescription()) &&
                StringUtils.equalsIgnoreCase(getLocation(), other.getLocation()) &&
                ObjectUtils.equals(favorite, other.favorite) &&
                favoritePoints == other.favoritePoints &&
                ObjectUtils.equals(onWatchlist, other.onWatchlist) &&
                (hidden != null ? hidden.equals(other.hidden) : other.hidden == null) &&
                StringUtils.equalsIgnoreCase(guid, other.guid) &&
                StringUtils.equalsIgnoreCase(getHint(), other.getHint()) &&
                StringUtils.equalsIgnoreCase(cacheId, other.cacheId) &&
                (direction != null ? direction.equals(other.direction) : other.direction == null) &&
                (distance != null ? distance.equals(other.distance) : other.distance == null) &&
                rating == other.rating &&
                votes == other.votes &&
                myVote == other.myVote &&
                inventoryItems == other.inventoryItems &&
                attributes == other.attributes &&
                waypoints == other.waypoints &&
                spoilers == other.spoilers &&
                inventory == other.inventory &&
                logCounts == other.logCounts &&
                ObjectUtils.equals(logOffline, other.logOffline) &&
                finalDefined == other.finalDefined;
    }

    public boolean hasTrackables() {
        return inventoryItems > 0;
    }

    public boolean canBeAddedToCalendar() {
        // Is event type with event date set?
        return isEventCache() && hidden != null;
    }

    public boolean isPastEvent() {
        final Calendar cal = Calendar.getInstance();
        cal.setTime(new Date());
        cal.set(Calendar.HOUR_OF_DAY, 0);
        cal.set(Calendar.MINUTE, 0);
        cal.set(Calendar.SECOND, 0);
        cal.set(Calendar.MILLISECOND, 0);
        assert hidden != null; // Eclipse compiler issue
        return hidden.compareTo(cal.getTime()) < 0;
    }

    public boolean isEventCache() {
        return cacheType.getValue().isEvent();
    }

    public void logVisit(final Activity fromActivity) {
        if (!getConnector().canLog(this)) {
            ActivityMixin.showToast(fromActivity, fromActivity.getResources().getString(R.string.err_cannot_log_visit));
            return;
        }
        fromActivity.startActivity(LogCacheActivity.getLogCacheIntent(fromActivity, cacheId, geocode));
    }

    public void logOffline(final Activity fromActivity, final LogType logType) {
        final boolean mustIncludeSignature = StringUtils.isNotBlank(Settings.getSignature()) && Settings.isAutoInsertSignature();
        final String initial = mustIncludeSignature ? LogTemplateProvider.applyTemplates(Settings.getSignature(), new LogContext(this, null, true)) : "";
        logOffline(fromActivity, initial, Calendar.getInstance(), logType);
    }

    public void logOffline(final Activity fromActivity, final String log, final Calendar date, final LogType logType) {
        if (logType == LogType.UNKNOWN) {
            return;
        }
        final boolean status = DataStore.saveLogOffline(geocode, date.getTime(), logType, log);

        final Resources res = fromActivity.getResources();
        if (status) {
            ActivityMixin.showToast(fromActivity, res.getString(R.string.info_log_saved));
            DataStore.saveVisitDate(geocode);
            logOffline = Boolean.TRUE;

            offlineLogs = DataStore.loadLogOffline(geocode);
            notifyChange();
        } else {
            ActivityMixin.showToast(fromActivity, res.getString(R.string.err_log_post_failed));
        }
    }

    /**
     * Get the Offline Log entry if any.
     *
     * @return
     *          The Offline LogEntry
     */
    @Nullable
    public LogEntry getOfflineLog() {
        if (isLogOffline() && offlineLogs == null) {
            offlineLogs = DataStore.loadLogOffline(geocode);
        }
        return offlineLogs;
    }

    /**
     * Get the Offline Log entry if any.
     *
     * @return
     *          The Offline LogEntry else Null
     */
    @Nullable
    public LogType getOfflineLogType() {
        final LogEntry offlineLog = getOfflineLog();
        if (offlineLog == null) {
            return null;
        }
        return offlineLog.getType();
    }

    /**
     * Drop offline log for a given geocode.
     */
    public void clearOfflineLog() {
        DataStore.clearLogOffline(geocode);
        setLogOffline(false);
        notifyChange();
    }

    @NonNull
    public List<LogType> getPossibleLogTypes() {
        return getConnector().getPossibleLogTypes(this);
    }

    public void openInBrowser(final Activity fromActivity) {
        if (getUrl() == null) {
            return;
        }
        final Intent viewIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(getLongUrl()));

        // Check if cgeo is the default, show the chooser to let the user choose a browser
        if (viewIntent.resolveActivity(fromActivity.getPackageManager()).getPackageName().equals(fromActivity.getPackageName())) {
            final Intent chooser = Intent.createChooser(viewIntent, fromActivity.getString(R.string.cache_menu_browser));

            final Intent internalBrowser = new Intent(fromActivity, SimpleWebviewActivity.class);
            internalBrowser.setData(Uri.parse(getUrl()));

            chooser.putExtra(Intent.EXTRA_INITIAL_INTENTS, new Parcelable[] {internalBrowser});


            fromActivity.startActivity(chooser);
        } else {
            fromActivity.startActivity(viewIntent);
        }
    }

    @NonNull
    private IConnector getConnector() {
        return ConnectorFactory.getConnector(this);
    }

    public boolean supportsRefresh() {
        return getConnector() instanceof ISearchByGeocode;
    }

    public boolean supportsWatchList() {
        return getConnector().supportsWatchList();
    }

    public boolean supportsFavoritePoints() {
        return getConnector().supportsFavoritePoints(this);
    }

    public boolean supportsLogging() {
        return getConnector().supportsLogging();
    }

    public boolean supportsLogImages() {
        return getConnector().supportsLogImages();
    }

    public boolean supportsOwnCoordinates() {
        return getConnector().supportsOwnCoordinates();
    }

    @NonNull
    public ILoggingManager getLoggingManager(final LogCacheActivity activity) {
        return getConnector().getLoggingManager(activity, this);
    }

    public float getDifficulty() {
        return difficulty;
    }

    @Override
    @NonNull
    public String getGeocode() {
        return geocode;
    }

    /**
     * @return displayed owner, might differ from the real owner
     */
    public String getOwnerDisplayName() {
        return ownerDisplayName;
    }

    @NonNull
    public CacheSize getSize() {
        return size;
    }

    public float getTerrain() {
        return terrain;
    }

    public boolean isArchived() {
        return BooleanUtils.isTrue(archived);
    }

    public boolean isDisabled() {
        return BooleanUtils.isTrue(disabled);
    }

    public boolean isPremiumMembersOnly() {
        return BooleanUtils.isTrue(premiumMembersOnly);
    }

    public void setPremiumMembersOnly(final boolean members) {
        this.premiumMembersOnly = members;
    }

    /**
     *
     * @return {@code true} if the user is the owner of the cache, {@code false} otherwise
     */
    public boolean isOwner() {
        return getConnector().isOwner(this);
    }

    /**
     * @return GC username of the (actual) owner, might differ from the owner. Never empty.
     */
    @NonNull
    public String getOwnerUserId() {
        return ownerUserId;
    }

    /**
     * Attention, calling this method may trigger a database access for the cache!
     *
     * @return the decrypted hint
     */
    public String getHint() {
        initializeCacheTexts();
        assertTextNotNull(hint, "Hint");
        return hint;
    }

    /**
     * After lazy loading the lazily loaded field must be non {@code null}.
     *
     */
    private static void assertTextNotNull(final String field, final String name) throws InternalError {
        if (field == null) {
            throw new InternalError(name + " field is not allowed to be null here");
        }
    }

    /**
     * Attention, calling this method may trigger a database access for the cache!
     */
    public String getDescription() {
        initializeCacheTexts();
        assertTextNotNull(description, "Description");
        return description;
    }

    /**
     * loads long text parts of a cache on demand (but all fields together)
     */
    private void initializeCacheTexts() {
        if (description == null || shortdesc == null || hint == null || location == null) {
            if (inDatabase()) {
                final Geocache partial = DataStore.loadCacheTexts(this.getGeocode());
                if (description == null) {
                    setDescription(partial.getDescription());
                }
                if (shortdesc == null) {
                    setShortDescription(partial.getShortDescription());
                }
                if (hint == null) {
                    setHint(partial.getHint());
                }
                if (location == null) {
                    setLocation(partial.getLocation());
                }
            } else {
                description = StringUtils.defaultString(description);
                shortdesc = StringUtils.defaultString(shortdesc);
                hint = StringUtils.defaultString(hint);
                location = StringUtils.defaultString(location);
            }
        }
    }

    /**
     * Attention, calling this method may trigger a database access for the cache!
     */
    public String getShortDescription() {
        initializeCacheTexts();
        assertTextNotNull(shortdesc, "Short description");
        return shortdesc;
    }

    @Override
    public String getName() {
        return name;
    }

    public String getCacheId() {
        if (StringUtils.isBlank(cacheId) && getConnector().equals(GCConnector.getInstance())) {
            return String.valueOf(GCConstants.gccodeToGCId(geocode));
        }

        return cacheId;
    }

    public String getGuid() {
        return guid;
    }

    /**
     * Attention, calling this method may trigger a database access for the cache!
     */
    public String getLocation() {
        initializeCacheTexts();
        assertTextNotNull(location, "Location");
        return location;
    }

    public String getPersonalNote() {
        // non premium members have no personal notes, premium members have an empty string by default.
        // map both to null, so other code doesn't need to differentiate
        return StringUtils.defaultIfBlank(personalNote, null);
    }

    public boolean supportsCachesAround() {
        return getConnector() instanceof ISearchByCenter;
    }

    public void shareCache(@NonNull final Activity fromActivity, final Resources res) {
        final Intent intent = getShareIntent();

        fromActivity.startActivity(Intent.createChooser(intent, res.getText(R.string.cache_menu_share)));
    }

    @NonNull
    public Intent getShareIntent() {
        final StringBuilder subject = new StringBuilder("Geocache ");
        subject.append(geocode);
        if (StringUtils.isNotBlank(name)) {
            subject.append(" - ").append(name);
        }

        final Intent intent = new Intent(Intent.ACTION_SEND);
        intent.setType("text/plain");
        intent.putExtra(Intent.EXTRA_SUBJECT, subject.toString());
        intent.putExtra(Intent.EXTRA_TEXT, StringUtils.defaultString(getUrl()));

        return intent;
    }

    @Nullable
    public String getUrl() {
        return getConnector().getCacheUrl(this);
    }

    @Nullable
    public String getLongUrl() {
        return getConnector().getLongCacheUrl(this);
    }

    @Nullable
    public String getCgeoUrl() {
        return getConnector().getCacheUrl(this);
    }

    public boolean supportsGCVote() {
        return StringUtils.startsWithIgnoreCase(geocode, "GC");
    }

    public void setDescription(final String description) {
        this.description = description;
    }

    public boolean isFound() {
        return BooleanUtils.isTrue(found);
    }

    /**
     *
     * @return {@code true} if the user has put a favorite point onto this cache
     */
    public boolean isFavorite() {
        return BooleanUtils.isTrue(favorite);
    }

    public void setFavorite(final boolean favorite) {
        this.favorite = favorite;
    }

    @Nullable
    public Date getHiddenDate() {
        if (hidden != null) {
            return new Date(hidden.getTime());
        }
        return null;
    }

    @NonNull
    public List<String> getAttributes() {
        return attributes.getUnderlyingList();
    }

    public void addSpoiler(final Image spoiler) {
        if (spoilers == null) {
            spoilers = new ArrayList<>();
        }
        spoilers.add(spoiler);
    }

    @NonNull
    public List<Image> getSpoilers() {
        return ListUtils.unmodifiableList(ListUtils.emptyIfNull(spoilers));
    }

    /**
     * @return a statistic how often the caches has been found, disabled, archived etc.
     */
    public Map<LogType, Integer> getLogCounts() {
        return logCounts;
    }

    public int getFavoritePoints() {
        return favoritePoints;
    }

    /**
     * @return the normalized cached name to be used for sorting, taking into account the numerical parts in the name
     */
    public String getNameForSorting() {
        if (nameForSorting == null) {
            nameForSorting = name;
            // pad each number part to a fixed size of 6 digits, so that numerical sorting becomes equivalent to string sorting
            MatcherWrapper matcher = new MatcherWrapper(NUMBER_PATTERN, nameForSorting);
            int start = 0;
            while (matcher.find(start)) {
                final String number = matcher.group();
                nameForSorting = StringUtils.substring(nameForSorting, 0, matcher.start()) + StringUtils.leftPad(number, 6, '0') + StringUtils.substring(nameForSorting, matcher.start() + number.length());
                start = matcher.start() + Math.max(6, number.length());
                matcher = new MatcherWrapper(NUMBER_PATTERN, nameForSorting);
            }
        }
        return nameForSorting;
    }

    public boolean isVirtual() {
        return cacheType.getValue().isVirtual();
    }

    public boolean showSize() {
        return !(size == CacheSize.NOT_CHOSEN || isEventCache() || isVirtual());
    }

    public long getUpdated() {
        return updated;
    }

    public void setUpdated(final long updated) {
        this.updated = updated;
    }

    public long getDetailedUpdate() {
        return detailedUpdate;
    }

    public void setDetailedUpdate(final long detailedUpdate) {
        this.detailedUpdate = detailedUpdate;
    }

    public long getVisitedDate() {
        return visitedDate;
    }

    public void setVisitedDate(final long visitedDate) {
        this.visitedDate = visitedDate;
    }

    public Set<Integer> getLists() {
        return lists;
    }

    public void setLists(final Set<Integer> lists) {
        this.lists = lists;
    }

    public boolean isDetailed() {
        return detailed;
    }

    public void setDetailed(final boolean detailed) {
        this.detailed = detailed;
    }

    public void setHidden(@Nullable final Date hidden) {
        this.hidden = hidden != null ? new Date(hidden.getTime()) : null;
    }

    public Float getDirection() {
        return direction;
    }

    public void setDirection(final Float direction) {
        this.direction = direction;
    }

    public Float getDistance() {
        return distance;
    }

    public void setDistance(final Float distance) {
        this.distance = distance;
    }

    @Override
    public Geopoint getCoords() {
        return coords.getValue();
    }

    public int getCoordZoomLevel() {
        return coords.getCertaintyLevel();
    }

    /**
     * Set reliable coordinates
     */
    public void setCoords(final Geopoint coords) {
        this.coords = new UncertainProperty<>(coords);
    }

    /**
     * Set unreliable coordinates from a certain map zoom level
     */
    public void setCoords(final Geopoint coords, final int zoomlevel) {
        this.coords = new UncertainProperty<>(coords, zoomlevel);
    }

    /**
     * @return true if the coords are from the cache details page and the user has been logged in
     */
    public boolean isReliableLatLon() {
        return getConnector().isReliableLatLon(reliableLatLon);
    }

    public void setReliableLatLon(final boolean reliableLatLon) {
        this.reliableLatLon = reliableLatLon;
    }

    public void setShortDescription(final String shortdesc) {
        this.shortdesc = shortdesc;
    }

    public void setFavoritePoints(final int favoriteCnt) {
        this.favoritePoints = favoriteCnt;
    }

    public float getRating() {
        return rating;
    }

    public void setRating(final float rating) {
        this.rating = rating;
    }

    public int getVotes() {
        return votes;
    }

    public void setVotes(final int votes) {
        this.votes = votes;
    }

    public float getMyVote() {
        return myVote;
    }

    public void setMyVote(final float myVote) {
        this.myVote = myVote;
    }

    /**
     * Get the current inventory count
     *
     * @return the inventory size
     */
    public int getInventoryItems() {
        return inventoryItems;
    }

    /**
     * Set the current inventory count
     *
     * @param inventoryItems the new inventory size
     */
    public void setInventoryItems(final int inventoryItems) {
        this.inventoryItems = inventoryItems;
    }

    /**
     * Get the current inventory
     *
     * @return the Geocache inventory
     */
    public List<Trackable> getInventory() {
        return inventory;
    }

    /**
     * Replace the inventory with new content.
     * No check are performed.
     *
     * @param newInventory to set on Geocache
     */
    public void setInventory(final List<Trackable> newInventory) {
        inventory = newInventory;
        inventoryItems = CollectionUtils.size(inventory);
    }

    /**
     * Add new Trackables to inventory safely.
     * This takes care of removing old items if they are from the same brand.
     * If items are present, data is merged, not duplicated.
     *
     * @param newTrackables
     *            to be added to the Geocache
     */
    public void mergeInventory(@NonNull final List<Trackable> newTrackables, final EnumSet<TrackableBrand> processedBrands) {

        final List<Trackable> mergedTrackables = new ArrayList<>(newTrackables);

        for (final Trackable trackable : ListUtils.emptyIfNull(inventory)) {
            if (processedBrands.contains(trackable.getBrand())) {
                final ListIterator<Trackable> iterator = mergedTrackables.listIterator();
                while (iterator.hasNext()) {
                    final Trackable newTrackable = iterator.next();
                    if (trackable.getUniqueID().equals(newTrackable.getUniqueID())) {
                        // Respect the merge order. New Values replace existing values.
                        trackable.mergeTrackable(newTrackable);
                        iterator.set(trackable);
                        break;
                    }
                }
            } else {
                mergedTrackables.add(trackable);
            }
        }
        setInventory(mergedTrackables);
    }

    /**
     * Add new Trackable to inventory safely.
     * If items are present, data are merged, not duplicated.
     *
     * @param newTrackable to be added to the Geocache
     */
    public void addInventoryItem(final Trackable newTrackable) {
        if (inventory == null) {
            inventory = new ArrayList<>();
        }
        boolean foundTrackable = false;
        for (final Trackable trackable: inventory) {
            if (trackable.getUniqueID().equals(newTrackable.getUniqueID())) {
                // Trackable already present, merge data
                foundTrackable = true;
                trackable.mergeTrackable(newTrackable);
                break;
            }
        }
        if (!foundTrackable) {
            inventory.add(newTrackable);
        }
        inventoryItems = inventory.size();
    }

    /**
     * @return {@code true} if the cache is on the user's watchlist, {@code false} otherwise
     */
    public boolean isOnWatchlist() {
        return BooleanUtils.isTrue(onWatchlist);
    }

    public void setOnWatchlist(final boolean onWatchlist) {
        this.onWatchlist = onWatchlist;
    }

    /**
     *
     * Set the number of users watching this geocache
     * @param watchlistCount Number of users watching this geocache
     */
    public void setWatchlistCount(final int watchlistCount) {
        this.watchlistCount = watchlistCount;
    }

    /**
     *
     * get the number of users watching this geocache
     * @return watchlistCount Number of users watching this geocache
     */
    public int getWatchlistCount() {
        return watchlistCount;
    }

    /**
     * return an immutable list of waypoints.
     *
     * @return always non {@code null}
     */
    @NonNull
    public List<Waypoint> getWaypoints() {
        return waypoints.getUnderlyingList();
    }

    /**
     * @param waypoints
     *            List of waypoints to set for cache
     * @param saveToDatabase
     *            Indicates whether to add the waypoints to the database. Should be false if
     *            called while loading or building a cache
     * @return {@code true} if waypoints successfully added to waypoint database
     */
    public boolean setWaypoints(@Nullable final List<Waypoint> waypoints, final boolean saveToDatabase) {
        this.waypoints.clear();
        if (waypoints != null) {
            this.waypoints.addAll(waypoints);
        }
        finalDefined = false;
        if (waypoints != null) {
            for (final Waypoint waypoint : waypoints) {
                waypoint.setGeocode(geocode);
                if (waypoint.isFinalWithCoords()) {
                    finalDefined = true;
                }
            }
        }
        return saveToDatabase && DataStore.saveWaypoints(this);
    }

    /**
     * The list of logs is immutable, because it is directly fetched from the database on demand, and not stored at this
     * object. If you want to modify logs, you have to load all logs of the cache, create a new list from the existing
     * list and store that new list in the database.
     *
     * @return immutable list of logs
     */
    @NonNull
    public List<LogEntry> getLogs() {
        return inDatabase() ? DataStore.loadLogs(geocode) : Collections.<LogEntry>emptyList();
    }

    /**
     * @return only the logs of friends
     */
    @NonNull
    public List<LogEntry> getFriendsLogs() {
        final List<LogEntry> friendLogs = new ArrayList<>();
        for (final LogEntry log : getLogs()) {
            if (log.friend) {
                friendLogs.add(log);
            }
        }
        return Collections.unmodifiableList(friendLogs);
    }

    public boolean isLogOffline() {
        return BooleanUtils.isTrue(logOffline);
    }

    public void setLogOffline(final boolean logOffline) {
        this.logOffline = logOffline;
    }

    public boolean isStatusChecked() {
        return statusChecked;
    }

    public void setStatusChecked(final boolean statusChecked) {
        this.statusChecked = statusChecked;
    }

    public String getDirectionImg() {
        return directionImg;
    }

    public void setDirectionImg(final String directionImg) {
        this.directionImg = directionImg;
    }

    public void setGeocode(@NonNull final String geocode) {
        this.geocode = StringUtils.upperCase(geocode);
    }

    public void setCacheId(final String cacheId) {
        this.cacheId = cacheId;
    }

    public void setGuid(final String guid) {
        this.guid = guid;
    }

    public void setName(final String name) {
        this.name = name;
    }

    public void setOwnerDisplayName(final String ownerDisplayName) {
        this.ownerDisplayName = ownerDisplayName;
    }

    public void setOwnerUserId(final String ownerUserId) {
        this.ownerUserId = ownerUserId;
    }

    public void setHint(final String hint) {
        this.hint = hint;
    }

    public void setSize(@NonNull final CacheSize size) {
        this.size = size;
    }

    public void setDifficulty(final float difficulty) {
        this.difficulty = difficulty;
    }

    public void setTerrain(final float terrain) {
        this.terrain = terrain;
    }

    public void setLocation(final String location) {
        this.location = location;
    }

    public void setPersonalNote(final String personalNote) {
        this.personalNote = StringUtils.trimToNull(personalNote);
    }

    public void setDisabled(final boolean disabled) {
        this.disabled = disabled;
    }

    public void setArchived(final boolean archived) {
        this.archived = archived;
    }

    public void setFound(final boolean found) {
        this.found = found;
    }

    public void setAttributes(final List<String> attributes) {
        this.attributes.clear();
        if (attributes != null) {
            this.attributes.addAll(attributes);
        }
    }

    public void setSpoilers(final List<Image> spoilers) {
        this.spoilers = spoilers;
    }

    public void setLogCounts(final Map<LogType, Integer> logCounts) {
        this.logCounts = logCounts;
    }

    /*
     * (non-Javadoc)
     *
     * @see cgeo.geocaching.IBasicCache#getType()
     *
     * @returns Never null
     */
    public CacheType getType() {
        return cacheType.getValue();
    }

    public void setType(final CacheType cacheType) {
        if (cacheType == null || cacheType == CacheType.ALL) {
            throw new IllegalArgumentException("Illegal cache type");
        }
        this.cacheType = new UncertainProperty<>(cacheType);
    }

    public void setType(final CacheType cacheType, final int zoomlevel) {
        if (cacheType == null || cacheType == CacheType.ALL) {
            throw new IllegalArgumentException("Illegal cache type");
        }
        this.cacheType = new UncertainProperty<>(cacheType, zoomlevel);
    }

    public boolean hasDifficulty() {
        return difficulty > 0f;
    }

    public boolean hasTerrain() {
        return terrain > 0f;
    }

    /**
     * @return the storageLocation
     */
    public EnumSet<StorageLocation> getStorageLocation() {
        return storageLocation;
    }

    /**
     * @param storageLocation
     *            the storageLocation to set
     */
    public void addStorageLocation(final StorageLocation storageLocation) {
        this.storageLocation.add(storageLocation);
    }

    /**
     * Check if this cache instance comes from or has been stored into the database.
     */
    public boolean inDatabase() {
        return storageLocation.contains(StorageLocation.DATABASE);
    }

    /**
     * @param waypoint
     *            Waypoint to add to the cache
     * @param saveToDatabase
     *            Indicates whether to add the waypoint to the database. Should be false if
     *            called while loading or building a cache
     * @return {@code true} if waypoint successfully added to waypoint database
     */
    public boolean addOrChangeWaypoint(final Waypoint waypoint, final boolean saveToDatabase) {
        waypoint.setGeocode(geocode);

        if (waypoint.getId() < 0) { // this is a new waypoint
            if (StringUtils.isBlank(waypoint.getPrefix())) {
                assignUniquePrefix(waypoint);
            }
            waypoints.add(waypoint);
            if (waypoint.isFinalWithCoords()) {
                finalDefined = true;
            }
        } else { // this is a waypoint being edited
            final int index = getWaypointIndex(waypoint);
            if (index >= 0) {
                final Waypoint oldWaypoint = waypoints.remove(index);
                waypoint.setPrefix(oldWaypoint.getPrefix());
                //migration
                if (StringUtils.isBlank(waypoint.getPrefix())
                        || StringUtils.equalsIgnoreCase(waypoint.getPrefix(), Waypoint.PREFIX_OWN)) {
                    assignUniquePrefix(waypoint);
                }
            }
            waypoints.add(waypoint);
            // when waypoint was edited, finalDefined may have changed
            resetFinalDefined();
        }
        return saveToDatabase && DataStore.saveWaypoint(waypoint.getId(), geocode, waypoint);
    }

    /*
     * Assigns a unique two-digit (compatibility with gc.com)
     * prefix within the scope of this cache.
     */
    private void assignUniquePrefix(final Waypoint waypoint) {
        // gather existing prefixes
        final Set<String> assignedPrefixes = new HashSet<>();
        for (final Waypoint wp : waypoints) {
            assignedPrefixes.add(wp.getPrefix());
        }

        for (int i = OWN_WP_PREFIX_OFFSET; i < 100; i++) {
            final String prefixCandidate = String.valueOf(i);
            if (!assignedPrefixes.contains(prefixCandidate)) {
                waypoint.setPrefix(prefixCandidate);
                return;
            }
        }

        throw new IllegalStateException("too many waypoints, unable to assign unique prefix");
    }

    public boolean hasWaypoints() {
        return !waypoints.isEmpty();
    }

    public boolean hasFinalDefined() {
        return finalDefined;
    }

    // Only for loading
    public void setFinalDefined(final boolean finalDefined) {
        this.finalDefined = finalDefined;
    }

    /**
     * Reset {@code finalDefined} based on current list of stored waypoints
     */
    private void resetFinalDefined() {
        finalDefined = false;
        for (final Waypoint wp : waypoints) {
            if (wp.isFinalWithCoords()) {
                finalDefined = true;
                break;
            }
        }
    }

    public boolean hasUserModifiedCoords() {
        return userModifiedCoords;
    }

    public void setUserModifiedCoords(final boolean coordsChanged) {
        userModifiedCoords = coordsChanged;
    }

    /**
     * Duplicate a waypoint.
     *
     * @param original
     *            the waypoint to duplicate
     * @return {@code true} if the waypoint was duplicated, {@code false} otherwise (invalid index)
     */
    public boolean duplicateWaypoint(final Waypoint original) {
        if (original == null) {
            return false;
        }
        final int index = getWaypointIndex(original);
        final Waypoint copy = new Waypoint(original);
        copy.setUserDefined();
        copy.setName(CgeoApplication.getInstance().getString(R.string.waypoint_copy_of) + " " + copy.getName());
        waypoints.add(index + 1, copy);
        return DataStore.saveWaypoint(-1, geocode, copy);
    }

    /**
     * delete a user defined waypoint
     *
     * @param waypoint
     *            to be removed from cache
     * @return {@code true}, if the waypoint was deleted
     */
    public boolean deleteWaypoint(final Waypoint waypoint) {
        if (waypoint == null) {
            return false;
        }
        if (waypoint.getId() < 0) {
            return false;
        }
        if (waypoint.isUserDefined()) {
            final int index = getWaypointIndex(waypoint);
            waypoints.remove(index);
            DataStore.deleteWaypoint(waypoint.getId());
            DataStore.removeCache(geocode, EnumSet.of(RemoveFlag.CACHE));
            // Check status if Final is defined
            if (waypoint.isFinalWithCoords()) {
                resetFinalDefined();
            }
            return true;
        }
        return false;
    }

    /**
     * deletes any waypoint
     */

    public void deleteWaypointForce(final Waypoint waypoint) {
        final int index = getWaypointIndex(waypoint);
        waypoints.remove(index);
        DataStore.deleteWaypoint(waypoint.getId());
        DataStore.removeCache(geocode, EnumSet.of(RemoveFlag.CACHE));
        resetFinalDefined();
    }

    /**
     * Find index of given {@code waypoint} in cache's {@code waypoints} list
     *
     * @param waypoint
     *            to find index for
     * @return index in {@code waypoints} if found, -1 otherwise
     */
    private int getWaypointIndex(final Waypoint waypoint) {
        final int id = waypoint.getId();
        for (int index = 0; index < waypoints.size(); index++) {
            if (waypoints.get(index).getId() == id) {
                return index;
            }
        }
        return -1;
    }

    /**
     * Lookup a waypoint by its id.
     *
     * @param id
     *            the id of the waypoint to look for
     * @return waypoint or {@code null}
     */
    public Waypoint getWaypointById(final int id) {
        for (final Waypoint waypoint : waypoints) {
            if (waypoint.getId() == id) {
                return waypoint;
            }
        }
        return null;
    }

    /**
     * Detect coordinates in the personal note and convert them to user defined waypoints. Works by rule of thumb.
     */
    public boolean parseWaypointsFromNote() {
        boolean changed = false;
        for (final Waypoint waypoint : Waypoint.parseWaypointsFromNote(StringUtils.defaultString(getPersonalNote()))) {
            if (!hasIdenticalWaypoint(waypoint.getCoords())) {
                addOrChangeWaypoint(waypoint, false);
                changed = true;
            }
        }
        return changed;
    }

    private boolean hasIdenticalWaypoint(final Geopoint point) {
        for (final Waypoint waypoint: waypoints) {
            // waypoint can have no coords such as a Final set by cache owner
            final Geopoint coords = waypoint.getCoords();
            if (coords != null && coords.equals(point)) {
                return true;
            }
        }
        return false;
    }

    /*
     * For working in the debugger
     * (non-Javadoc)
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        return this.geocode + " " + this.name;
    }

    @Override
    public int hashCode() {
        return StringUtils.defaultString(geocode).hashCode();
    }

    @Override
    public boolean equals(final Object obj) {
        // TODO: explain the following line or remove this non-standard equality method
        // just compare the geocode even if that is not what "equals" normally does
        return this == obj || (obj instanceof Geocache && StringUtils.isNotEmpty(geocode) && geocode.equals(((Geocache) obj).geocode));
    }

    public void store() {
        store(StoredList.STANDARD_LIST_ID, null);
    }

    public void store(final int listId, final CancellableHandler handler) {
        lists.add(listId);
        storeCache(this, null, lists, false, handler);
    }

    @Override
    public int getId() {
        return 0;
    }

    @Override
    public WaypointType getWaypointType() {
        return null;
    }

    @Override
    public CoordinatesType getCoordType() {
        return CoordinatesType.CACHE;
    }

    public Subscription drop(final Handler handler) {
        return Schedulers.io().createWorker().schedule(new Action0() {
            @Override
            public void call() {
                try {
                    dropSynchronous();
                    handler.sendMessage(Message.obtain());
                } catch (final Exception e) {
                    Log.e("cache.drop: ", e);
                }
            }
        });
    }

    public void dropSynchronous() {
        DataStore.markDropped(Collections.singletonList(this));
        DataStore.removeCache(getGeocode(), EnumSet.of(RemoveFlag.CACHE));
    }

    private void warnIncorrectParsingIf(final boolean incorrect, final String field) {
        if (incorrect) {
            Log.w(field + " not parsed correctly for " + geocode);
        }
    }

    private void warnIncorrectParsingIfBlank(final String str, final String field) {
        warnIncorrectParsingIf(StringUtils.isBlank(str), field);
    }

    public void checkFields() {
        warnIncorrectParsingIfBlank(getGeocode(), "geo");
        warnIncorrectParsingIfBlank(getName(), "name");
        warnIncorrectParsingIfBlank(getGuid(), "guid");
        warnIncorrectParsingIf(getTerrain() == 0.0, "terrain");
        warnIncorrectParsingIf(getDifficulty() == 0.0, "difficulty");
        warnIncorrectParsingIfBlank(getOwnerDisplayName(), "owner");
        warnIncorrectParsingIfBlank(getOwnerUserId(), "owner");
        warnIncorrectParsingIf(getHiddenDate() == null, "hidden");
        warnIncorrectParsingIf(getFavoritePoints() < 0, "favoriteCount");
        warnIncorrectParsingIf(getSize() == CacheSize.UNKNOWN, "size");
        warnIncorrectParsingIf(getType() == null || getType() == CacheType.UNKNOWN, "type");
        warnIncorrectParsingIf(getCoords() == null, "coordinates");
        warnIncorrectParsingIfBlank(getLocation(), "location");
    }

    public Subscription refresh(final CancellableHandler handler, final Scheduler scheduler) {
        return scheduler.createWorker().schedule(new Action0() {
            @Override
            public void call() {
                refreshSynchronous(handler);
            }
        });
    }

    public void refreshSynchronous(final CancellableHandler handler) {
        storeCache(null, geocode, lists, true, handler);
    }

    public static void storeCache(final Geocache origCache, final String geocode, final Set<Integer> lists, final boolean forceRedownload, final CancellableHandler handler) {
        try {
            Geocache cache = null;
            // get cache details, they may not yet be complete
            if (origCache != null) {
                SearchResult search = null;
                // only reload the cache if it was already stored or doesn't have full details (by checking the description)
                if (origCache.isOffline() || StringUtils.isBlank(origCache.getDescription())) {
                    search = searchByGeocode(origCache.getGeocode(), null, false, handler);
                }
                if (search != null) {
                    cache = search.getFirstCacheFromResult(LoadFlags.LOAD_CACHE_OR_DB);
                } else {
                    cache = origCache;
                }
            } else if (StringUtils.isNotBlank(geocode)) {
                final SearchResult search = searchByGeocode(geocode, null, forceRedownload, handler);
                if (search != null) {
                    cache = search.getFirstCacheFromResult(LoadFlags.LOAD_CACHE_OR_DB);
                }
            }

            if (cache == null) {
                if (handler != null) {
                    handler.sendMessage(Message.obtain());
                }

                return;
            }

            if (CancellableHandler.isCancelled(handler)) {
                return;
            }

            final HtmlImage imgGetter = new HtmlImage(cache.getGeocode(), false, true, forceRedownload);

            // store images from description
            if (StringUtils.isNotBlank(cache.getDescription())) {
                Html.fromHtml(cache.getDescription(), imgGetter, null);
            }

            if (CancellableHandler.isCancelled(handler)) {
                return;
            }

            // store spoilers
            if (CollectionUtils.isNotEmpty(cache.getSpoilers())) {
                for (final Image oneSpoiler : cache.getSpoilers()) {
                    imgGetter.getDrawable(oneSpoiler.getUrl());
                }
            }

            if (CancellableHandler.isCancelled(handler)) {
                return;
            }

            // store images from logs
            if (Settings.isStoreLogImages()) {
                for (final LogEntry log : cache.getLogs()) {
                    if (log.hasLogImages()) {
                        for (final Image oneLogImg : log.getLogImages()) {
                            imgGetter.getDrawable(oneLogImg.getUrl());
                        }
                    }
                }
            }

            if (CancellableHandler.isCancelled(handler)) {
                return;
            }

            cache.setLists(lists);
            DataStore.saveCache(cache, EnumSet.of(SaveFlag.DB));

            if (CancellableHandler.isCancelled(handler)) {
                return;
            }

            StaticMapsProvider.downloadMaps(cache).mergeWith(imgGetter.waitForEndCompletable(handler)).await();

            if (handler != null) {
                handler.sendEmptyMessage(CancellableHandler.DONE);
            }
        } catch (final Exception e) {
            Log.e("Geocache.storeCache", e);
        }
    }

    public static SearchResult searchByGeocode(final String geocode, final String guid, final boolean forceReload, final CancellableHandler handler) {
        if (StringUtils.isBlank(geocode) && StringUtils.isBlank(guid)) {
            Log.e("Geocache.searchByGeocode: No geocode nor guid given");
            return null;
        }

        if (!forceReload && (DataStore.isOffline(geocode, guid) || DataStore.isThere(geocode, guid, true))) {
            final SearchResult search = new SearchResult();
            final String realGeocode = StringUtils.isNotBlank(geocode) ? geocode : DataStore.getGeocodeForGuid(guid);
            search.addGeocode(realGeocode);
            return search;
        }

        // if we have no geocode, we can't dynamically select the handler, but must explicitly use GC
        if (geocode == null) {
            return GCConnector.getInstance().searchByGeocode(null, guid, handler);
        }

        final IConnector connector = ConnectorFactory.getConnector(geocode);
        if (connector instanceof ISearchByGeocode) {
            return ((ISearchByGeocode) connector).searchByGeocode(geocode, guid, handler);
        }
        return null;
    }

    public boolean isOffline() {
        return !lists.isEmpty() && (lists.size() > 1 || lists.iterator().next() != StoredList.TEMPORARY_LIST.id);
    }

    /**
     * guess an event start time from the description
     *
     * @return start time in minutes after midnight
     */
    public int guessEventTimeMinutes() {
        if (!isEventCache()) {
            return -1;
        }

        final String hourLocalized = CgeoApplication.getInstance().getString(R.string.cache_time_full_hours);
        final List<Pattern> patterns = new ArrayList<>();

        // 12:34
        patterns.add(Pattern.compile("\\b(\\d{1,2})\\:(\\d\\d)\\b"));
        if (StringUtils.isNotBlank(hourLocalized)) {
            // 12:34o'clock
            patterns.add(Pattern.compile("\\b(\\d{1,2})\\:(\\d\\d)" + Pattern.quote(hourLocalized), Pattern.CASE_INSENSITIVE));
            // 17 - 20 o'clock
            patterns.add(Pattern.compile("\\b(\\d{1,2})(?:\\.00)?" + "\\s*(?:-|[a-z]+)\\s?" + "(?:\\d{1,2})(?:\\.00)?" + "\\s?" + Pattern.quote(hourLocalized), Pattern.CASE_INSENSITIVE));
            // 12 o'clock, 12.00 o'clock
            patterns.add(Pattern.compile("\\b(\\d{1,2})(?:\\.(00|15|30|45))?\\s?" + Pattern.quote(hourLocalized), Pattern.CASE_INSENSITIVE));
        }

        final String searchText = getShortDescription() + ' ' + getDescription();
        for (final Pattern pattern : patterns) {
            final MatcherWrapper matcher = new MatcherWrapper(pattern, searchText);
            while (matcher.find()) {
                try {
                    final int hours = Integer.parseInt(matcher.group(1));
                    int minutes = 0;
                    if (matcher.groupCount() >= 2 && StringUtils.isNotEmpty(matcher.group(2))) {
                        minutes = Integer.parseInt(matcher.group(2));
                    }
                    if (hours >= 0 && hours < 24 && minutes >= 0 && minutes < 60) {
                        return hours * 60 + minutes;
                    }
                } catch (final NumberFormatException ignored) {
                    // cannot happen, but static code analysis doesn't know
                }
            }
        }
        return -1;
    }

    public boolean hasStaticMap() {
        return StaticMapsProvider.hasStaticMap(this);
    }

    @NonNull
    public Collection<Image> getImages() {
        final List<Image> result = new LinkedList<>();
        result.addAll(getSpoilers());
        addLocalSpoilersTo(result);
        for (final LogEntry log : getLogs()) {
            result.addAll(log.getLogImages());
        }
        ImageUtils.addImagesFromHtml(result, geocode, getShortDescription(), getDescription());
        return result;
    }

    /**
     * Add spoilers stored locally in <tt>/sdcard/GeocachePhotos</tt>. If a cache is named GC123ABC, the
     * directory will be <tt>/sdcard/GeocachePhotos/C/B/GC123ABC/</tt>.
     *
     * @param spoilers the list to add to
     */
    private void addLocalSpoilersTo(final List<Image> spoilers) {
        if (StringUtils.length(geocode) >= 2) {
            final String suffix = StringUtils.right(geocode, 2);
            final File baseDir = new File(Environment.getExternalStorageDirectory(), "GeocachePhotos");
            final File lastCharDir = new File(baseDir, suffix.substring(1));
            final File secondToLastCharDir = new File(lastCharDir, suffix.substring(0, 1));
            final File finalDir = new File(secondToLastCharDir, geocode);
            final File[] files = finalDir.listFiles();
            if (files != null) {
                for (final File image : files) {
                    spoilers.add(new Image.Builder()
                            .setUrl("file://" + image.getAbsolutePath())
                            .setTitle(image.getName())
                            .build());
                }
            }
        }
    }

    public void setDetailedUpdatedNow() {
        final long now = System.currentTimeMillis();
        setUpdated(now);
        setDetailedUpdate(now);
        setDetailed(true);
    }

    /**
     * Gets whether the user has logged the specific log type for this cache. Only checks the currently stored logs of
     * the cache, so the result might be wrong.
     */
    public boolean hasOwnLog(final LogType logType) {
        for (final LogEntry logEntry : getLogs()) {
            if (logEntry.getType() == logType && logEntry.isOwn()) {
                return true;
            }
        }
        return false;
    }

    public int getMapMarkerId() {
        return getConnector().getCacheMapMarkerId(isDisabled() || isArchived());
    }

    public boolean isLogPasswordRequired() {
        return logPasswordRequired;
    }

    public void setLogPasswordRequired(final boolean required) {
        logPasswordRequired = required;
    }

    public String getWaypointGpxId(final String prefix) {
        return getConnector().getWaypointGpxId(prefix, geocode);
    }

    @NonNull
    public String getWaypointPrefix(final String name) {
        return getConnector().getWaypointPrefix(name);
    }

    /**
     * Get number of overall finds for a cache, or 0 if the number of finds is not known.
     */
    public int getFindsCount() {
        if (getLogCounts().isEmpty()) {
            setLogCounts(inDatabase() ? DataStore.loadLogCounts(getGeocode()) : Collections.<LogType, Integer>emptyMap());
        }
        final Integer logged = getLogCounts().get(LogType.FOUND_IT);
        if (logged != null) {
            return logged;
        }
        return 0;
    }

    public boolean applyDistanceRule() {
        return (getType().applyDistanceRule() || hasUserModifiedCoords()) && getConnector() == GCConnector.getInstance();
    }

    @NonNull
    public LogType getDefaultLogType() {
        if (isEventCache()) {
            final Date eventDate = getHiddenDate();
            final boolean expired = CalendarUtils.isPastEvent(this);

            if (hasOwnLog(LogType.WILL_ATTEND) || expired || (eventDate != null && CalendarUtils.daysSince(eventDate.getTime()) == 0)) {
                return hasOwnLog(LogType.ATTENDED) ? LogType.NOTE : LogType.ATTENDED;
            }
            return LogType.WILL_ATTEND;
        }
        if (isFound()) {
            return LogType.NOTE;
        }
        if (getType() == CacheType.WEBCAM) {
            return LogType.WEBCAM_PHOTO_TAKEN;
        }
        return LogType.FOUND_IT;
    }

    /**
     * Get the geocodes of a collection of caches.
     *
     * @param caches a collection of caches
     * @return the non-blank geocodes of the caches
     */
    @NonNull
    public static Set<String> getGeocodes(@NonNull final Collection<Geocache> caches) {
        final Set<String> geocodes = new HashSet<>(caches.size());
        for (final Geocache cache : caches) {
            final String geocode = cache.getGeocode();
            if (StringUtils.isNotBlank(geocode)) {
                geocodes.add(geocode);
            }
        }
        return geocodes;
    }

    /**
     * Show the hint as toast message. If no hint is available, a default "no hint available" will be shown instead.
     */
    public void showHintToast(final Activity activity) {
        final String hint = getHint();
        ActivityMixin.showToast(activity, StringUtils.defaultIfBlank(hint, activity.getString(R.string.cache_hint_not_available)));
    }

    public GeoitemRef getGeoitemRef() {
        return new GeoitemRef(getGeocode(), getCoordType(), getGeocode(), 0, getName(), getType().markerId);
    }

}
!@#$%
20190527_012532,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_c08020
package cgeo.geocaching.models;

import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.LogCacheActivity;
import cgeo.geocaching.R;
import cgeo.geocaching.SearchResult;
import cgeo.geocaching.StaticMapsProvider;
import cgeo.geocaching.activity.ActivityMixin;
import cgeo.geocaching.activity.SimpleWebviewActivity;
import cgeo.geocaching.connector.ConnectorFactory;
import cgeo.geocaching.connector.IConnector;
import cgeo.geocaching.connector.ILoggingManager;
import cgeo.geocaching.connector.capability.ISearchByCenter;
import cgeo.geocaching.connector.capability.ISearchByGeocode;
import cgeo.geocaching.connector.gc.GCConnector;
import cgeo.geocaching.connector.gc.GCConstants;
import cgeo.geocaching.connector.gc.Tile;
import cgeo.geocaching.connector.gc.UncertainProperty;
import cgeo.geocaching.connector.trackable.TrackableBrand;
import cgeo.geocaching.enumerations.CacheSize;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.enumerations.CoordinatesType;
import cgeo.geocaching.enumerations.LoadFlags;
import cgeo.geocaching.enumerations.LoadFlags.RemoveFlag;
import cgeo.geocaching.enumerations.LoadFlags.SaveFlag;
import cgeo.geocaching.enumerations.LogType;
import cgeo.geocaching.enumerations.WaypointType;
import cgeo.geocaching.list.StoredList;
import cgeo.geocaching.location.Geopoint;
import cgeo.geocaching.maps.mapsforge.v6.caches.GeoitemRef;
import cgeo.geocaching.network.HtmlImage;
import cgeo.geocaching.settings.Settings;
import cgeo.geocaching.storage.DataStore;
import cgeo.geocaching.storage.DataStore.StorageLocation;
import cgeo.geocaching.utils.CalendarUtils;
import cgeo.geocaching.utils.CancellableHandler;
import cgeo.geocaching.utils.ImageUtils;
import cgeo.geocaching.utils.LazyInitializedList;
import cgeo.geocaching.utils.Log;
import cgeo.geocaching.utils.LogTemplateProvider;
import cgeo.geocaching.utils.LogTemplateProvider.LogContext;
import cgeo.geocaching.utils.MatcherWrapper;

import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.collections4.ListUtils;
import org.apache.commons.lang3.BooleanUtils;
import org.apache.commons.lang3.ObjectUtils;
import org.apache.commons.lang3.StringUtils;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;

import android.app.Activity;
import android.content.Intent;
import android.content.res.Resources;
import android.net.Uri;
import android.os.Environment;
import android.os.Handler;
import android.os.Message;
import android.os.Parcelable;
import android.text.Html;

import java.io.File;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.EnumMap;
import java.util.EnumSet;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Set;
import java.util.regex.Pattern;

import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import rx.Scheduler;
import rx.Subscription;
import rx.functions.Action0;
import rx.schedulers.Schedulers;

/**
 * Internal representation of a "cache"
 */
public class Geocache implements IWaypoint {

    private static final int OWN_WP_PREFIX_OFFSET = 17;
    private long updated = 0;
    private long detailedUpdate = 0;
    private long visitedDate = 0;
    private Set<Integer> lists = new HashSet<>();
    private boolean detailed = false;

    @NonNull
    private String geocode = "";
    private String cacheId = "";
    private String guid = "";
    private UncertainProperty<CacheType> cacheType = new UncertainProperty<>(CacheType.UNKNOWN, Tile.ZOOMLEVEL_MIN - 1);
    private String name = "";
    private String ownerDisplayName = "";
    private String ownerUserId = "";
    @Nullable
    private Date hidden = null;
    /**
     * lazy initialized
     */
    private String hint = null;
    @NonNull private CacheSize size = CacheSize.UNKNOWN;
    private float difficulty = 0;
    private float terrain = 0;
    private Float direction = null;
    private Float distance = null;
    /**
     * lazy initialized
     */
    private String location = null;
    private UncertainProperty<Geopoint> coords = new UncertainProperty<>(null);
    private boolean reliableLatLon = false;
    private String personalNote = null;
    /**
     * lazy initialized
     */
    private String shortdesc = null;
    /**
     * lazy initialized
     */
    private String description = null;
    private Boolean disabled = null;
    private Boolean archived = null;
    private Boolean premiumMembersOnly = null;
    private Boolean found = null;
    private Boolean favorite = null;
    private Boolean onWatchlist = null;
    private Boolean logOffline = null;
    private int watchlistCount = -1; // valid numbers are larger than -1
    private int favoritePoints = 0;
    private float rating = 0; // valid ratings are larger than zero
    private int votes = 0;
    private float myVote = 0; // valid ratings are larger than zero
    private int inventoryItems = 0;
    private final LazyInitializedList<String> attributes = new LazyInitializedList<String>() {
        @Override
        public List<String> call() {
            return inDatabase() ? DataStore.loadAttributes(geocode) : new LinkedList<String>();
        }
    };
    private final LazyInitializedList<Waypoint> waypoints = new LazyInitializedList<Waypoint>() {
        @Override
        public List<Waypoint> call() {
            return inDatabase() ? DataStore.loadWaypoints(geocode) : new LinkedList<Waypoint>();
        }
    };
    private List<Image> spoilers = null;

    private List<Trackable> inventory = null;
    private Map<LogType, Integer> logCounts = new EnumMap<>(LogType.class);
    private boolean userModifiedCoords = false;
    // temporary values
    private boolean statusChecked = false;
    private String directionImg = "";
    private String nameForSorting;
    private final EnumSet<StorageLocation> storageLocation = EnumSet.of(StorageLocation.HEAP);
    private boolean finalDefined = false;
    private boolean logPasswordRequired = false;
    private LogEntry offlineLogs = null;

    private static final Pattern NUMBER_PATTERN = Pattern.compile("\\d+");

    private Handler changeNotificationHandler = null;

    public void setChangeNotificationHandler(final Handler newNotificationHandler) {
        changeNotificationHandler = newNotificationHandler;
    }

    /**
     * Sends a change notification to interested parties
     */
    private void notifyChange() {
        if (changeNotificationHandler != null) {
            changeNotificationHandler.sendEmptyMessage(0);
        }
    }

    /**
     * Gather missing information for new Geocache object from the stored Geocache object.
     * This is called in the new Geocache parsed from website to set information not yet
     * parsed.
     *
     * @param other
     *            the other version, or null if non-existent
     * @return true if this cache is "equal" to the other version
     */
    public boolean gatherMissingFrom(final Geocache other) {
        if (other == null) {
            return false;
        }
        if (other == this) {
            return true;
        }

        updated = System.currentTimeMillis();
        // if parsed cache is not yet detailed and stored is, the information of
        // the parsed cache will be overwritten
        if (!detailed && other.detailed) {
            detailed = true;
            detailedUpdate = other.detailedUpdate;
            // boolean values must be enumerated here. Other types are assigned outside this if-statement
            reliableLatLon = other.reliableLatLon;
            finalDefined = other.finalDefined;
        }

        if (premiumMembersOnly == null) {
            premiumMembersOnly = other.premiumMembersOnly;
        }
        if (found == null) {
            found = other.found;
        }
        if (disabled == null) {
            disabled = other.disabled;
        }
        if (favorite == null) {
            favorite = other.favorite;
        }
        if (archived == null) {
            archived = other.archived;
        }
        if (onWatchlist == null) {
            onWatchlist = other.onWatchlist;
        }
        if (logOffline == null) {
            logOffline = other.logOffline;
        }
        if (visitedDate == 0) {
            visitedDate = other.visitedDate;
        }
        if (lists.isEmpty()) {
            lists.addAll(other.lists);
        }
        if (StringUtils.isBlank(geocode)) {
            geocode = other.geocode;
        }
        if (StringUtils.isBlank(cacheId)) {
            cacheId = other.cacheId;
        }
        if (StringUtils.isBlank(guid)) {
            guid = other.guid;
        }
        cacheType = UncertainProperty.getMergedProperty(cacheType, other.cacheType);
        if (StringUtils.isBlank(name)) {
            name = other.name;
        }
        if (StringUtils.isBlank(ownerDisplayName)) {
            ownerDisplayName = other.ownerDisplayName;
        }
        if (StringUtils.isBlank(ownerUserId)) {
            ownerUserId = other.ownerUserId;
        }
        if (hidden == null) {
            hidden = other.hidden;
        }
        if (!detailed && StringUtils.isBlank(getHint())) {
            hint = other.getHint();
        }
        if (size == CacheSize.UNKNOWN) {
            size = other.size;
        }
        if (difficulty == 0) {
            difficulty = other.difficulty;
        }
        if (terrain == 0) {
            terrain = other.terrain;
        }
        if (direction == null) {
            direction = other.direction;
        }
        if (distance == null) {
            distance = other.distance;
        }
        if (StringUtils.isBlank(getLocation())) {
            location = other.getLocation();
        }
        coords = UncertainProperty.getMergedProperty(coords, other.coords);
        // don't use StringUtils.isBlank here. Otherwise we cannot recognize a note which was deleted on GC
        if (personalNote == null) {
            personalNote = other.personalNote;
        } else if (other.personalNote != null && !personalNote.equals(other.personalNote)) {
            final PersonalNote myNote = new PersonalNote(this);
            final PersonalNote otherNote = new PersonalNote(other);
            final PersonalNote mergedNote = myNote.mergeWith(otherNote);
            personalNote = mergedNote.toString();
        }
        if (!detailed && StringUtils.isBlank(getShortDescription())) {
            shortdesc = other.getShortDescription();
        }
        if (StringUtils.isBlank(getDescription())) {
            description = other.getDescription();
        }
        // FIXME: this makes no sense to favor this over the other. 0 should not be a special case here as it is
        // in the range of acceptable values. This is probably the case at other places (rating, votes, etc.) too.
        if (favoritePoints == 0) {
            favoritePoints = other.favoritePoints;
        }
        if (rating == 0) {
            rating = other.rating;
        }
        if (votes == 0) {
            votes = other.votes;
        }
        if (myVote == 0) {
            myVote = other.myVote;
        }
        if (!detailed && attributes.isEmpty() && other.attributes != null) {
            attributes.addAll(other.attributes);
        }
        if (waypoints.isEmpty()) {
            this.setWaypoints(other.waypoints, false);
        }
        else {
            final List<Waypoint> newPoints = new ArrayList<>(waypoints);
            Waypoint.mergeWayPoints(newPoints, other.waypoints, false);
            this.setWaypoints(newPoints, false);
        }
        if (spoilers == null) {
            spoilers = other.spoilers;
        }
        if (inventory == null) {
            // If inventoryItems is 0, it can mean both
            // "don't know" or "0 items". Since we cannot distinguish
            // them here, only populate inventoryItems from
            // old data when we have to do it for inventory.
            setInventory(other.inventory);
        }
        if (logCounts.isEmpty()) {
            logCounts = other.logCounts;
        }

        // if cache has ORIGINAL type waypoint ... it is considered that it has modified coordinates, otherwise not
        userModifiedCoords = false;
        for (final Waypoint wpt : waypoints) {
            if (wpt.getWaypointType() == WaypointType.ORIGINAL) {
                userModifiedCoords = true;
                break;
            }
        }

        if (!reliableLatLon) {
            reliableLatLon = other.reliableLatLon;
        }

        return isEqualTo(other);
    }

    /**
     * Compare two caches quickly. For map and list fields only the references are compared !
     *
     * @param other
     *            the other cache to compare this one to
     * @return true if both caches have the same content
     */
    @SuppressWarnings("deprecation")
    @SuppressFBWarnings("FE_FLOATING_POINT_EQUALITY")
    private boolean isEqualTo(final Geocache other) {
        return detailed == other.detailed &&
                StringUtils.equalsIgnoreCase(geocode, other.geocode) &&
                StringUtils.equalsIgnoreCase(name, other.name) &&
                UncertainProperty.equalValues(cacheType, other.cacheType) &&
                size == other.size &&
                ObjectUtils.equals(found, other.found) &&
                ObjectUtils.equals(premiumMembersOnly, other.premiumMembersOnly) &&
                difficulty == other.difficulty &&
                terrain == other.terrain &&
                UncertainProperty.equalValues(coords, other.coords) &&
                reliableLatLon == other.reliableLatLon &&
                ObjectUtils.equals(disabled, other.disabled) &&
                ObjectUtils.equals(archived, other.archived) &&
                ObjectUtils.equals(lists, other.lists) &&
                StringUtils.equalsIgnoreCase(ownerDisplayName, other.ownerDisplayName) &&
                StringUtils.equalsIgnoreCase(ownerUserId, other.ownerUserId) &&
                StringUtils.equalsIgnoreCase(getDescription(), other.getDescription()) &&
                StringUtils.equalsIgnoreCase(personalNote, other.personalNote) &&
                StringUtils.equalsIgnoreCase(getShortDescription(), other.getShortDescription()) &&
                StringUtils.equalsIgnoreCase(getLocation(), other.getLocation()) &&
                ObjectUtils.equals(favorite, other.favorite) &&
                favoritePoints == other.favoritePoints &&
                ObjectUtils.equals(onWatchlist, other.onWatchlist) &&
                (hidden != null ? hidden.equals(other.hidden) : other.hidden == null) &&
                StringUtils.equalsIgnoreCase(guid, other.guid) &&
                StringUtils.equalsIgnoreCase(getHint(), other.getHint()) &&
                StringUtils.equalsIgnoreCase(cacheId, other.cacheId) &&
                (direction != null ? direction.equals(other.direction) : other.direction == null) &&
                (distance != null ? distance.equals(other.distance) : other.distance == null) &&
                rating == other.rating &&
                votes == other.votes &&
                myVote == other.myVote &&
                inventoryItems == other.inventoryItems &&
                attributes == other.attributes &&
                waypoints == other.waypoints &&
                spoilers == other.spoilers &&
                inventory == other.inventory &&
                logCounts == other.logCounts &&
                ObjectUtils.equals(logOffline, other.logOffline) &&
                finalDefined == other.finalDefined;
    }

    public boolean hasTrackables() {
        return inventoryItems > 0;
    }

    public boolean canBeAddedToCalendar() {
        // Is event type with event date set?
        return isEventCache() && hidden != null;
    }

    public boolean isPastEvent() {
        final Calendar cal = Calendar.getInstance();
        cal.setTime(new Date());
        cal.set(Calendar.HOUR_OF_DAY, 0);
        cal.set(Calendar.MINUTE, 0);
        cal.set(Calendar.SECOND, 0);
        cal.set(Calendar.MILLISECOND, 0);
        assert hidden != null; // Eclipse compiler issue
        return hidden.compareTo(cal.getTime()) < 0;
    }

    public boolean isEventCache() {
        return cacheType.getValue().isEvent();
    }

    public void logVisit(final Activity fromActivity) {
        if (!getConnector().canLog(this)) {
            ActivityMixin.showToast(fromActivity, fromActivity.getResources().getString(R.string.err_cannot_log_visit));
            return;
        }
        fromActivity.startActivity(LogCacheActivity.getLogCacheIntent(fromActivity, cacheId, geocode));
    }

    public void logOffline(final Activity fromActivity, final LogType logType) {
        final boolean mustIncludeSignature = StringUtils.isNotBlank(Settings.getSignature()) && Settings.isAutoInsertSignature();
        final String initial = mustIncludeSignature ? LogTemplateProvider.applyTemplates(Settings.getSignature(), new LogContext(this, null, true)) : "";
        logOffline(fromActivity, initial, Calendar.getInstance(), logType);
    }

    public void logOffline(final Activity fromActivity, final String log, final Calendar date, final LogType logType) {
        if (logType == LogType.UNKNOWN) {
            return;
        }
        final boolean status = DataStore.saveLogOffline(geocode, date.getTime(), logType, log);

        final Resources res = fromActivity.getResources();
        if (status) {
            ActivityMixin.showToast(fromActivity, res.getString(R.string.info_log_saved));
            DataStore.saveVisitDate(geocode);
            logOffline = Boolean.TRUE;

            offlineLogs = DataStore.loadLogOffline(geocode);
            notifyChange();
        } else {
            ActivityMixin.showToast(fromActivity, res.getString(R.string.err_log_post_failed));
        }
    }

    /**
     * Get the Offline Log entry if any.
     *
     * @return
     *          The Offline LogEntry
     */
    @Nullable
    public LogEntry getOfflineLog() {
        if (isLogOffline() && offlineLogs == null) {
            offlineLogs = DataStore.loadLogOffline(geocode);
        }
        return offlineLogs;
    }

    /**
     * Get the Offline Log entry if any.
     *
     * @return
     *          The Offline LogEntry else Null
     */
    @Nullable
    public LogType getOfflineLogType() {
        final LogEntry offlineLog = getOfflineLog();
        if (offlineLog == null) {
            return null;
        }
        return offlineLog.getType();
    }

    /**
     * Drop offline log for a given geocode.
     */
    public void clearOfflineLog() {
        DataStore.clearLogOffline(geocode);
        setLogOffline(false);
        notifyChange();
    }

    @NonNull
    public List<LogType> getPossibleLogTypes() {
        return getConnector().getPossibleLogTypes(this);
    }

    public void openInBrowser(final Activity fromActivity) {
        if (getUrl() == null) {
            return;
        }
        final Intent viewIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(getLongUrl()));

        // Check if cgeo is the default, show the chooser to let the user choose a browser
        if (viewIntent.resolveActivity(fromActivity.getPackageManager()).getPackageName().equals(fromActivity.getPackageName())) {
            final Intent chooser = Intent.createChooser(viewIntent, fromActivity.getString(R.string.cache_menu_browser));

            final Intent internalBrowser = new Intent(fromActivity, SimpleWebviewActivity.class);
            internalBrowser.setData(Uri.parse(getUrl()));

            chooser.putExtra(Intent.EXTRA_INITIAL_INTENTS, new Parcelable[] {internalBrowser});


            fromActivity.startActivity(chooser);
        } else {
            fromActivity.startActivity(viewIntent);
        }
    }

    @NonNull
    private IConnector getConnector() {
        return ConnectorFactory.getConnector(this);
    }

    public boolean supportsRefresh() {
        return getConnector() instanceof ISearchByGeocode;
    }

    public boolean supportsWatchList() {
        return getConnector().supportsWatchList();
    }

    public boolean supportsFavoritePoints() {
        return getConnector().supportsFavoritePoints(this);
    }

    public boolean supportsLogging() {
        return getConnector().supportsLogging();
    }

    public boolean supportsLogImages() {
        return getConnector().supportsLogImages();
    }

    public boolean supportsOwnCoordinates() {
        return getConnector().supportsOwnCoordinates();
    }

    @NonNull
    public ILoggingManager getLoggingManager(final LogCacheActivity activity) {
        return getConnector().getLoggingManager(activity, this);
    }

    public float getDifficulty() {
        return difficulty;
    }

    @Override
    @NonNull
    public String getGeocode() {
        return geocode;
    }

    /**
     * @return displayed owner, might differ from the real owner
     */
    public String getOwnerDisplayName() {
        return ownerDisplayName;
    }

    @NonNull
    public CacheSize getSize() {
        return size;
    }

    public float getTerrain() {
        return terrain;
    }

    public boolean isArchived() {
        return BooleanUtils.isTrue(archived);
    }

    public boolean isDisabled() {
        return BooleanUtils.isTrue(disabled);
    }

    public boolean isPremiumMembersOnly() {
        return BooleanUtils.isTrue(premiumMembersOnly);
    }

    public void setPremiumMembersOnly(final boolean members) {
        this.premiumMembersOnly = members;
    }

    /**
     *
     * @return {@code true} if the user is the owner of the cache, {@code false} otherwise
     */
    public boolean isOwner() {
        return getConnector().isOwner(this);
    }

    /**
     * @return GC username of the (actual) owner, might differ from the owner. Never empty.
     */
    @NonNull
    public String getOwnerUserId() {
        return ownerUserId;
    }

    /**
     * Attention, calling this method may trigger a database access for the cache!
     *
     * @return the decrypted hint
     */
    public String getHint() {
        initializeCacheTexts();
        assertTextNotNull(hint, "Hint");
        return hint;
    }

    /**
     * After lazy loading the lazily loaded field must be non {@code null}.
     *
     */
    private static void assertTextNotNull(final String field, final String name) throws InternalError {
        if (field == null) {
            throw new InternalError(name + " field is not allowed to be null here");
        }
    }

    /**
     * Attention, calling this method may trigger a database access for the cache!
     */
    public String getDescription() {
        initializeCacheTexts();
        assertTextNotNull(description, "Description");
        return description;
    }

    /**
     * loads long text parts of a cache on demand (but all fields together)
     */
    private void initializeCacheTexts() {
        if (description == null || shortdesc == null || hint == null || location == null) {
            if (inDatabase()) {
                final Geocache partial = DataStore.loadCacheTexts(this.getGeocode());
                if (description == null) {
                    setDescription(partial.getDescription());
                }
                if (shortdesc == null) {
                    setShortDescription(partial.getShortDescription());
                }
                if (hint == null) {
                    setHint(partial.getHint());
                }
                if (location == null) {
                    setLocation(partial.getLocation());
                }
            } else {
                description = StringUtils.defaultString(description);
                shortdesc = StringUtils.defaultString(shortdesc);
                hint = StringUtils.defaultString(hint);
                location = StringUtils.defaultString(location);
            }
        }
    }

    /**
     * Attention, calling this method may trigger a database access for the cache!
     */
    public String getShortDescription() {
        initializeCacheTexts();
        assertTextNotNull(shortdesc, "Short description");
        return shortdesc;
    }

    @Override
    public String getName() {
        return name;
    }

    public String getCacheId() {
        if (StringUtils.isBlank(cacheId) && getConnector().equals(GCConnector.getInstance())) {
            return String.valueOf(GCConstants.gccodeToGCId(geocode));
        }

        return cacheId;
    }

    public String getGuid() {
        return guid;
    }

    /**
     * Attention, calling this method may trigger a database access for the cache!
     */
    public String getLocation() {
        initializeCacheTexts();
        assertTextNotNull(location, "Location");
        return location;
    }

    public String getPersonalNote() {
        // non premium members have no personal notes, premium members have an empty string by default.
        // map both to null, so other code doesn't need to differentiate
        return StringUtils.defaultIfBlank(personalNote, null);
    }

    public boolean supportsCachesAround() {
        return getConnector() instanceof ISearchByCenter;
    }

    public void shareCache(@NonNull final Activity fromActivity, final Resources res) {
        final Intent intent = getShareIntent();

        fromActivity.startActivity(Intent.createChooser(intent, res.getText(R.string.cache_menu_share)));
    }

    @NonNull
    public Intent getShareIntent() {
        final StringBuilder subject = new StringBuilder("Geocache ");
        subject.append(geocode);
        if (StringUtils.isNotBlank(name)) {
            subject.append(" - ").append(name);
        }

        final Intent intent = new Intent(Intent.ACTION_SEND);
        intent.setType("text/plain");
        intent.putExtra(Intent.EXTRA_SUBJECT, subject.toString());
        intent.putExtra(Intent.EXTRA_TEXT, StringUtils.defaultString(getUrl()));

        return intent;
    }

    @Nullable
    public String getUrl() {
        return getConnector().getCacheUrl(this);
    }

    @Nullable
    public String getLongUrl() {
        return getConnector().getLongCacheUrl(this);
    }

    @Nullable
    public String getCgeoUrl() {
        return getConnector().getCacheUrl(this);
    }

    public boolean supportsGCVote() {
        return StringUtils.startsWithIgnoreCase(geocode, "GC");
    }

    public void setDescription(final String description) {
        this.description = description;
    }

    public boolean isFound() {
        return BooleanUtils.isTrue(found);
    }

    /**
     *
     * @return {@code true} if the user has put a favorite point onto this cache
     */
    public boolean isFavorite() {
        return BooleanUtils.isTrue(favorite);
    }

    public void setFavorite(final boolean favorite) {
        this.favorite = favorite;
    }

    @Nullable
    public Date getHiddenDate() {
        if (hidden != null) {
            return new Date(hidden.getTime());
        }
        return null;
    }

    @NonNull
    public List<String> getAttributes() {
        return attributes.getUnderlyingList();
    }

    public void addSpoiler(final Image spoiler) {
        if (spoilers == null) {
            spoilers = new ArrayList<>();
        }
        spoilers.add(spoiler);
    }

    @NonNull
    public List<Image> getSpoilers() {
        return ListUtils.unmodifiableList(ListUtils.emptyIfNull(spoilers));
    }

    /**
     * @return a statistic how often the caches has been found, disabled, archived etc.
     */
    public Map<LogType, Integer> getLogCounts() {
        return logCounts;
    }

    public int getFavoritePoints() {
        return favoritePoints;
    }

    /**
     * @return the normalized cached name to be used for sorting, taking into account the numerical parts in the name
     */
    public String getNameForSorting() {
        if (nameForSorting == null) {
            nameForSorting = name;
            // pad each number part to a fixed size of 6 digits, so that numerical sorting becomes equivalent to string sorting
            MatcherWrapper matcher = new MatcherWrapper(NUMBER_PATTERN, nameForSorting);
            int start = 0;
            while (matcher.find(start)) {
                final String number = matcher.group();
                nameForSorting = StringUtils.substring(nameForSorting, 0, matcher.start()) + StringUtils.leftPad(number, 6, '0') + StringUtils.substring(nameForSorting, matcher.start() + number.length());
                start = matcher.start() + Math.max(6, number.length());
                matcher = new MatcherWrapper(NUMBER_PATTERN, nameForSorting);
            }
        }
        return nameForSorting;
    }

    public boolean isVirtual() {
        return cacheType.getValue().isVirtual();
    }

    public boolean showSize() {
        return !(size == CacheSize.NOT_CHOSEN || isEventCache() || isVirtual());
    }

    public long getUpdated() {
        return updated;
    }

    public void setUpdated(final long updated) {
        this.updated = updated;
    }

    public long getDetailedUpdate() {
        return detailedUpdate;
    }

    public void setDetailedUpdate(final long detailedUpdate) {
        this.detailedUpdate = detailedUpdate;
    }

    public long getVisitedDate() {
        return visitedDate;
    }

    public void setVisitedDate(final long visitedDate) {
        this.visitedDate = visitedDate;
    }

    public Set<Integer> getLists() {
        return lists;
    }

    public void setLists(final Set<Integer> lists) {
        this.lists = lists;
    }

    public boolean isDetailed() {
        return detailed;
    }

    public void setDetailed(final boolean detailed) {
        this.detailed = detailed;
    }

    public void setHidden(@Nullable final Date hidden) {
        this.hidden = hidden != null ? new Date(hidden.getTime()) : null;
    }

    public Float getDirection() {
        return direction;
    }

    public void setDirection(final Float direction) {
        this.direction = direction;
    }

    public Float getDistance() {
        return distance;
    }

    public void setDistance(final Float distance) {
        this.distance = distance;
    }

    @Override
    public Geopoint getCoords() {
        return coords.getValue();
    }

    public int getCoordZoomLevel() {
        return coords.getCertaintyLevel();
    }

    /**
     * Set reliable coordinates
     */
    public void setCoords(final Geopoint coords) {
        this.coords = new UncertainProperty<>(coords);
    }

    /**
     * Set unreliable coordinates from a certain map zoom level
     */
    public void setCoords(final Geopoint coords, final int zoomlevel) {
        this.coords = new UncertainProperty<>(coords, zoomlevel);
    }

    /**
     * @return true if the coords are from the cache details page and the user has been logged in
     */
    public boolean isReliableLatLon() {
        return getConnector().isReliableLatLon(reliableLatLon);
    }

    public void setReliableLatLon(final boolean reliableLatLon) {
        this.reliableLatLon = reliableLatLon;
    }

    public void setShortDescription(final String shortdesc) {
        this.shortdesc = shortdesc;
    }

    public void setFavoritePoints(final int favoriteCnt) {
        this.favoritePoints = favoriteCnt;
    }

    public float getRating() {
        return rating;
    }

    public void setRating(final float rating) {
        this.rating = rating;
    }

    public int getVotes() {
        return votes;
    }

    public void setVotes(final int votes) {
        this.votes = votes;
    }

    public float getMyVote() {
        return myVote;
    }

    public void setMyVote(final float myVote) {
        this.myVote = myVote;
    }

    /**
     * Get the current inventory count
     *
     * @return the inventory size
     */
    public int getInventoryItems() {
        return inventoryItems;
    }

    /**
     * Set the current inventory count
     *
     * @param inventoryItems the new inventory size
     */
    public void setInventoryItems(final int inventoryItems) {
        this.inventoryItems = inventoryItems;
    }

    /**
     * Get the current inventory
     *
     * @return the Geocache inventory
     */
    public List<Trackable> getInventory() {
        return inventory;
    }

    /**
     * Replace the inventory with new content.
     * No check are performed.
     *
     * @param newInventory to set on Geocache
     */
    public void setInventory(final List<Trackable> newInventory) {
        inventory = newInventory;
        inventoryItems = CollectionUtils.size(inventory);
    }

    /**
     * Add new Trackables to inventory safely.
     * This takes care of removing old items if they are from the same brand.
     * If items are present, data is merged, not duplicated.
     *
     * @param newTrackables
     *            to be added to the Geocache
     */
    public void mergeInventory(@NonNull final List<Trackable> newTrackables, final EnumSet<TrackableBrand> processedBrands) {

        final List<Trackable> mergedTrackables = new ArrayList<>(newTrackables);

        for (final Trackable trackable : ListUtils.emptyIfNull(inventory)) {
            if (processedBrands.contains(trackable.getBrand())) {
                final ListIterator<Trackable> iterator = mergedTrackables.listIterator();
                while (iterator.hasNext()) {
                    final Trackable newTrackable = iterator.next();
                    if (trackable.getUniqueID().equals(newTrackable.getUniqueID())) {
                        // Respect the merge order. New Values replace existing values.
                        trackable.mergeTrackable(newTrackable);
                        iterator.set(trackable);
                        break;
                    }
                }
            } else {
                mergedTrackables.add(trackable);
            }
        }
        setInventory(mergedTrackables);
    }

    /**
     * Add new Trackable to inventory safely.
     * If items are present, data are merged, not duplicated.
     *
     * @param newTrackable to be added to the Geocache
     */
    public void addInventoryItem(final Trackable newTrackable) {
        if (inventory == null) {
            inventory = new ArrayList<>();
        }
        boolean foundTrackable = false;
        for (final Trackable trackable: inventory) {
            if (trackable.getUniqueID().equals(newTrackable.getUniqueID())) {
                // Trackable already present, merge data
                foundTrackable = true;
                trackable.mergeTrackable(newTrackable);
                break;
            }
        }
        if (!foundTrackable) {
            inventory.add(newTrackable);
        }
        inventoryItems = inventory.size();
    }

    /**
     * @return {@code true} if the cache is on the user's watchlist, {@code false} otherwise
     */
    public boolean isOnWatchlist() {
        return BooleanUtils.isTrue(onWatchlist);
    }

    public void setOnWatchlist(final boolean onWatchlist) {
        this.onWatchlist = onWatchlist;
    }

    /**
     *
     * Set the number of users watching this geocache
     * @param watchlistCount Number of users watching this geocache
     */
    public void setWatchlistCount(final int watchlistCount) {
        this.watchlistCount = watchlistCount;
    }

    /**
     *
     * get the number of users watching this geocache
     * @return watchlistCount Number of users watching this geocache
     */
    public int getWatchlistCount() {
        return watchlistCount;
    }

    /**
     * return an immutable list of waypoints.
     *
     * @return always non {@code null}
     */
    @NonNull
    public List<Waypoint> getWaypoints() {
        return waypoints.getUnderlyingList();
    }

    /**
     * @param waypoints
     *            List of waypoints to set for cache
     * @param saveToDatabase
     *            Indicates whether to add the waypoints to the database. Should be false if
     *            called while loading or building a cache
     * @return {@code true} if waypoints successfully added to waypoint database
     */
    public boolean setWaypoints(@Nullable final List<Waypoint> waypoints, final boolean saveToDatabase) {
        this.waypoints.clear();
        if (waypoints != null) {
            this.waypoints.addAll(waypoints);
        }
        finalDefined = false;
        if (waypoints != null) {
            for (final Waypoint waypoint : waypoints) {
                waypoint.setGeocode(geocode);
                if (waypoint.isFinalWithCoords()) {
                    finalDefined = true;
                }
            }
        }
        return saveToDatabase && DataStore.saveWaypoints(this);
    }

    /**
     * The list of logs is immutable, because it is directly fetched from the database on demand, and not stored at this
     * object. If you want to modify logs, you have to load all logs of the cache, create a new list from the existing
     * list and store that new list in the database.
     *
     * @return immutable list of logs
     */
    @NonNull
    public List<LogEntry> getLogs() {
        return inDatabase() ? DataStore.loadLogs(geocode) : Collections.<LogEntry>emptyList();
    }

    /**
     * @return only the logs of friends
     */
    @NonNull
    public List<LogEntry> getFriendsLogs() {
        final List<LogEntry> friendLogs = new ArrayList<>();
        for (final LogEntry log : getLogs()) {
            if (log.friend) {
                friendLogs.add(log);
            }
        }
        return Collections.unmodifiableList(friendLogs);
    }

    public boolean isLogOffline() {
        return BooleanUtils.isTrue(logOffline);
    }

    public void setLogOffline(final boolean logOffline) {
        this.logOffline = logOffline;
    }

    public boolean isStatusChecked() {
        return statusChecked;
    }

    public void setStatusChecked(final boolean statusChecked) {
        this.statusChecked = statusChecked;
    }

    public String getDirectionImg() {
        return directionImg;
    }

    public void setDirectionImg(final String directionImg) {
        this.directionImg = directionImg;
    }

    public void setGeocode(@NonNull final String geocode) {
        this.geocode = StringUtils.upperCase(geocode);
    }

    public void setCacheId(final String cacheId) {
        this.cacheId = cacheId;
    }

    public void setGuid(final String guid) {
        this.guid = guid;
    }

    public void setName(final String name) {
        this.name = name;
    }

    public void setOwnerDisplayName(final String ownerDisplayName) {
        this.ownerDisplayName = ownerDisplayName;
    }

    public void setOwnerUserId(final String ownerUserId) {
        this.ownerUserId = ownerUserId;
    }

    public void setHint(final String hint) {
        this.hint = hint;
    }

    public void setSize(@NonNull final CacheSize size) {
        this.size = size;
    }

    public void setDifficulty(final float difficulty) {
        this.difficulty = difficulty;
    }

    public void setTerrain(final float terrain) {
        this.terrain = terrain;
    }

    public void setLocation(final String location) {
        this.location = location;
    }

    public void setPersonalNote(final String personalNote) {
        this.personalNote = StringUtils.trimToNull(personalNote);
    }

    public void setDisabled(final boolean disabled) {
        this.disabled = disabled;
    }

    public void setArchived(final boolean archived) {
        this.archived = archived;
    }

    public void setFound(final boolean found) {
        this.found = found;
    }

    public void setAttributes(final List<String> attributes) {
        this.attributes.clear();
        if (attributes != null) {
            this.attributes.addAll(attributes);
        }
    }

    public void setSpoilers(final List<Image> spoilers) {
        this.spoilers = spoilers;
    }

    public boolean hasSpoilersSet() {
        return this.spoilers != null;
    }

    public void setLogCounts(final Map<LogType, Integer> logCounts) {
        this.logCounts = logCounts;
    }

    /*
     * (non-Javadoc)
     *
     * @see cgeo.geocaching.IBasicCache#getType()
     *
     * @returns Never null
     */
    public CacheType getType() {
        return cacheType.getValue();
    }

    public void setType(final CacheType cacheType) {
        if (cacheType == null || cacheType == CacheType.ALL) {
            throw new IllegalArgumentException("Illegal cache type");
        }
        this.cacheType = new UncertainProperty<>(cacheType);
    }

    public void setType(final CacheType cacheType, final int zoomlevel) {
        if (cacheType == null || cacheType == CacheType.ALL) {
            throw new IllegalArgumentException("Illegal cache type");
        }
        this.cacheType = new UncertainProperty<>(cacheType, zoomlevel);
    }

    public boolean hasDifficulty() {
        return difficulty > 0f;
    }

    public boolean hasTerrain() {
        return terrain > 0f;
    }

    /**
     * @return the storageLocation
     */
    public EnumSet<StorageLocation> getStorageLocation() {
        return storageLocation;
    }

    /**
     * @param storageLocation
     *            the storageLocation to set
     */
    public void addStorageLocation(final StorageLocation storageLocation) {
        this.storageLocation.add(storageLocation);
    }

    /**
     * Check if this cache instance comes from or has been stored into the database.
     */
    public boolean inDatabase() {
        return storageLocation.contains(StorageLocation.DATABASE);
    }

    /**
     * @param waypoint
     *            Waypoint to add to the cache
     * @param saveToDatabase
     *            Indicates whether to add the waypoint to the database. Should be false if
     *            called while loading or building a cache
     * @return {@code true} if waypoint successfully added to waypoint database
     */
    public boolean addOrChangeWaypoint(final Waypoint waypoint, final boolean saveToDatabase) {
        waypoint.setGeocode(geocode);

        if (waypoint.getId() < 0) { // this is a new waypoint
            if (StringUtils.isBlank(waypoint.getPrefix())) {
                assignUniquePrefix(waypoint);
            }
            waypoints.add(waypoint);
            if (waypoint.isFinalWithCoords()) {
                finalDefined = true;
            }
        } else { // this is a waypoint being edited
            final int index = getWaypointIndex(waypoint);
            if (index >= 0) {
                final Waypoint oldWaypoint = waypoints.remove(index);
                waypoint.setPrefix(oldWaypoint.getPrefix());
                //migration
                if (StringUtils.isBlank(waypoint.getPrefix())
                        || StringUtils.equalsIgnoreCase(waypoint.getPrefix(), Waypoint.PREFIX_OWN)) {
                    assignUniquePrefix(waypoint);
                }
            }
            waypoints.add(waypoint);
            // when waypoint was edited, finalDefined may have changed
            resetFinalDefined();
        }
        return saveToDatabase && DataStore.saveWaypoint(waypoint.getId(), geocode, waypoint);
    }

    /*
     * Assigns a unique two-digit (compatibility with gc.com)
     * prefix within the scope of this cache.
     */
    private void assignUniquePrefix(final Waypoint waypoint) {
        // gather existing prefixes
        final Set<String> assignedPrefixes = new HashSet<>();
        for (final Waypoint wp : waypoints) {
            assignedPrefixes.add(wp.getPrefix());
        }

        for (int i = OWN_WP_PREFIX_OFFSET; i < 100; i++) {
            final String prefixCandidate = String.valueOf(i);
            if (!assignedPrefixes.contains(prefixCandidate)) {
                waypoint.setPrefix(prefixCandidate);
                return;
            }
        }

        throw new IllegalStateException("too many waypoints, unable to assign unique prefix");
    }

    public boolean hasWaypoints() {
        return !waypoints.isEmpty();
    }

    public boolean hasFinalDefined() {
        return finalDefined;
    }

    // Only for loading
    public void setFinalDefined(final boolean finalDefined) {
        this.finalDefined = finalDefined;
    }

    /**
     * Reset {@code finalDefined} based on current list of stored waypoints
     */
    private void resetFinalDefined() {
        finalDefined = false;
        for (final Waypoint wp : waypoints) {
            if (wp.isFinalWithCoords()) {
                finalDefined = true;
                break;
            }
        }
    }

    public boolean hasUserModifiedCoords() {
        return userModifiedCoords;
    }

    public void setUserModifiedCoords(final boolean coordsChanged) {
        userModifiedCoords = coordsChanged;
    }

    /**
     * Duplicate a waypoint.
     *
     * @param original
     *            the waypoint to duplicate
     * @return {@code true} if the waypoint was duplicated, {@code false} otherwise (invalid index)
     */
    public boolean duplicateWaypoint(final Waypoint original) {
        if (original == null) {
            return false;
        }
        final int index = getWaypointIndex(original);
        final Waypoint copy = new Waypoint(original);
        copy.setUserDefined();
        copy.setName(CgeoApplication.getInstance().getString(R.string.waypoint_copy_of) + " " + copy.getName());
        waypoints.add(index + 1, copy);
        return DataStore.saveWaypoint(-1, geocode, copy);
    }

    /**
     * delete a user defined waypoint
     *
     * @param waypoint
     *            to be removed from cache
     * @return {@code true}, if the waypoint was deleted
     */
    public boolean deleteWaypoint(final Waypoint waypoint) {
        if (waypoint == null) {
            return false;
        }
        if (waypoint.getId() < 0) {
            return false;
        }
        if (waypoint.isUserDefined()) {
            final int index = getWaypointIndex(waypoint);
            waypoints.remove(index);
            DataStore.deleteWaypoint(waypoint.getId());
            DataStore.removeCache(geocode, EnumSet.of(RemoveFlag.CACHE));
            // Check status if Final is defined
            if (waypoint.isFinalWithCoords()) {
                resetFinalDefined();
            }
            return true;
        }
        return false;
    }

    /**
     * deletes any waypoint
     */

    public void deleteWaypointForce(final Waypoint waypoint) {
        final int index = getWaypointIndex(waypoint);
        waypoints.remove(index);
        DataStore.deleteWaypoint(waypoint.getId());
        DataStore.removeCache(geocode, EnumSet.of(RemoveFlag.CACHE));
        resetFinalDefined();
    }

    /**
     * Find index of given {@code waypoint} in cache's {@code waypoints} list
     *
     * @param waypoint
     *            to find index for
     * @return index in {@code waypoints} if found, -1 otherwise
     */
    private int getWaypointIndex(final Waypoint waypoint) {
        final int id = waypoint.getId();
        for (int index = 0; index < waypoints.size(); index++) {
            if (waypoints.get(index).getId() == id) {
                return index;
            }
        }
        return -1;
    }

    /**
     * Lookup a waypoint by its id.
     *
     * @param id
     *            the id of the waypoint to look for
     * @return waypoint or {@code null}
     */
    public Waypoint getWaypointById(final int id) {
        for (final Waypoint waypoint : waypoints) {
            if (waypoint.getId() == id) {
                return waypoint;
            }
        }
        return null;
    }

    /**
     * Detect coordinates in the personal note and convert them to user defined waypoints. Works by rule of thumb.
     */
    public boolean parseWaypointsFromNote() {
        boolean changed = false;
        for (final Waypoint waypoint : Waypoint.parseWaypointsFromNote(StringUtils.defaultString(getPersonalNote()))) {
            if (!hasIdenticalWaypoint(waypoint.getCoords())) {
                addOrChangeWaypoint(waypoint, false);
                changed = true;
            }
        }
        return changed;
    }

    private boolean hasIdenticalWaypoint(final Geopoint point) {
        for (final Waypoint waypoint: waypoints) {
            // waypoint can have no coords such as a Final set by cache owner
            final Geopoint coords = waypoint.getCoords();
            if (coords != null && coords.equals(point)) {
                return true;
            }
        }
        return false;
    }

    /*
     * For working in the debugger
     * (non-Javadoc)
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        return this.geocode + " " + this.name;
    }

    @Override
    public int hashCode() {
        return StringUtils.defaultString(geocode).hashCode();
    }

    @Override
    public boolean equals(final Object obj) {
        // TODO: explain the following line or remove this non-standard equality method
        // just compare the geocode even if that is not what "equals" normally does
        return this == obj || (obj instanceof Geocache && StringUtils.isNotEmpty(geocode) && geocode.equals(((Geocache) obj).geocode));
    }

    public void store() {
        store(StoredList.STANDARD_LIST_ID, null);
    }

    public void store(final int listId, final CancellableHandler handler) {
        lists.add(listId);
        storeCache(this, null, lists, false, handler);
    }

    @Override
    public int getId() {
        return 0;
    }

    @Override
    public WaypointType getWaypointType() {
        return null;
    }

    @Override
    public CoordinatesType getCoordType() {
        return CoordinatesType.CACHE;
    }

    public Subscription drop(final Handler handler) {
        return Schedulers.io().createWorker().schedule(new Action0() {
            @Override
            public void call() {
                try {
                    dropSynchronous();
                    handler.sendMessage(Message.obtain());
                } catch (final Exception e) {
                    Log.e("cache.drop: ", e);
                }
            }
        });
    }

    public void dropSynchronous() {
        DataStore.markDropped(Collections.singletonList(this));
        DataStore.removeCache(getGeocode(), EnumSet.of(RemoveFlag.CACHE));
    }

    private void warnIncorrectParsingIf(final boolean incorrect, final String field) {
        if (incorrect) {
            Log.w(field + " not parsed correctly for " + geocode);
        }
    }

    private void warnIncorrectParsingIfBlank(final String str, final String field) {
        warnIncorrectParsingIf(StringUtils.isBlank(str), field);
    }

    public void checkFields() {
        warnIncorrectParsingIfBlank(getGeocode(), "geo");
        warnIncorrectParsingIfBlank(getName(), "name");
        warnIncorrectParsingIfBlank(getGuid(), "guid");
        warnIncorrectParsingIf(getTerrain() == 0.0, "terrain");
        warnIncorrectParsingIf(getDifficulty() == 0.0, "difficulty");
        warnIncorrectParsingIfBlank(getOwnerDisplayName(), "owner");
        warnIncorrectParsingIfBlank(getOwnerUserId(), "owner");
        warnIncorrectParsingIf(getHiddenDate() == null, "hidden");
        warnIncorrectParsingIf(getFavoritePoints() < 0, "favoriteCount");
        warnIncorrectParsingIf(getSize() == CacheSize.UNKNOWN, "size");
        warnIncorrectParsingIf(getType() == null || getType() == CacheType.UNKNOWN, "type");
        warnIncorrectParsingIf(getCoords() == null, "coordinates");
        warnIncorrectParsingIfBlank(getLocation(), "location");
    }

    public Subscription refresh(final CancellableHandler handler, final Scheduler scheduler) {
        return scheduler.createWorker().schedule(new Action0() {
            @Override
            public void call() {
                refreshSynchronous(handler);
            }
        });
    }

    public void refreshSynchronous(final CancellableHandler handler) {
        storeCache(null, geocode, lists, true, handler);
    }

    public static void storeCache(final Geocache origCache, final String geocode, final Set<Integer> lists, final boolean forceRedownload, final CancellableHandler handler) {
        try {
            Geocache cache = null;
            // get cache details, they may not yet be complete
            if (origCache != null) {
                SearchResult search = null;
                // only reload the cache if it was already stored or doesn't have full details (by checking the description)
                if (origCache.isOffline() || StringUtils.isBlank(origCache.getDescription())) {
                    search = searchByGeocode(origCache.getGeocode(), null, false, handler);
                }
                if (search != null) {
                    cache = search.getFirstCacheFromResult(LoadFlags.LOAD_CACHE_OR_DB);
                } else {
                    cache = origCache;
                }
            } else if (StringUtils.isNotBlank(geocode)) {
                final SearchResult search = searchByGeocode(geocode, null, forceRedownload, handler);
                if (search != null) {
                    cache = search.getFirstCacheFromResult(LoadFlags.LOAD_CACHE_OR_DB);
                }
            }

            if (cache == null) {
                if (handler != null) {
                    handler.sendMessage(Message.obtain());
                }

                return;
            }

            if (CancellableHandler.isCancelled(handler)) {
                return;
            }

            final HtmlImage imgGetter = new HtmlImage(cache.getGeocode(), false, true, forceRedownload);

            // store images from description
            if (StringUtils.isNotBlank(cache.getDescription())) {
                Html.fromHtml(cache.getDescription(), imgGetter, null);
            }

            if (CancellableHandler.isCancelled(handler)) {
                return;
            }

            // store spoilers
            if (CollectionUtils.isNotEmpty(cache.getSpoilers())) {
                for (final Image oneSpoiler : cache.getSpoilers()) {
                    imgGetter.getDrawable(oneSpoiler.getUrl());
                }
            }

            if (CancellableHandler.isCancelled(handler)) {
                return;
            }

            // store images from logs
            if (Settings.isStoreLogImages()) {
                for (final LogEntry log : cache.getLogs()) {
                    if (log.hasLogImages()) {
                        for (final Image oneLogImg : log.getLogImages()) {
                            imgGetter.getDrawable(oneLogImg.getUrl());
                        }
                    }
                }
            }

            if (CancellableHandler.isCancelled(handler)) {
                return;
            }

            cache.setLists(lists);
            DataStore.saveCache(cache, EnumSet.of(SaveFlag.DB));

            if (CancellableHandler.isCancelled(handler)) {
                return;
            }

            StaticMapsProvider.downloadMaps(cache).mergeWith(imgGetter.waitForEndCompletable(handler)).await();

            if (handler != null) {
                handler.sendEmptyMessage(CancellableHandler.DONE);
            }
        } catch (final Exception e) {
            Log.e("Geocache.storeCache", e);
        }
    }

    public static SearchResult searchByGeocode(final String geocode, final String guid, final boolean forceReload, final CancellableHandler handler) {
        if (StringUtils.isBlank(geocode) && StringUtils.isBlank(guid)) {
            Log.e("Geocache.searchByGeocode: No geocode nor guid given");
            return null;
        }

        if (!forceReload && (DataStore.isOffline(geocode, guid) || DataStore.isThere(geocode, guid, true))) {
            final SearchResult search = new SearchResult();
            final String realGeocode = StringUtils.isNotBlank(geocode) ? geocode : DataStore.getGeocodeForGuid(guid);
            search.addGeocode(realGeocode);
            return search;
        }

        // if we have no geocode, we can't dynamically select the handler, but must explicitly use GC
        if (geocode == null) {
            return GCConnector.getInstance().searchByGeocode(null, guid, handler);
        }

        final IConnector connector = ConnectorFactory.getConnector(geocode);
        if (connector instanceof ISearchByGeocode) {
            return ((ISearchByGeocode) connector).searchByGeocode(geocode, guid, handler);
        }
        return null;
    }

    public boolean isOffline() {
        return !lists.isEmpty() && (lists.size() > 1 || lists.iterator().next() != StoredList.TEMPORARY_LIST.id);
    }

    /**
     * guess an event start time from the description
     *
     * @return start time in minutes after midnight
     */
    public int guessEventTimeMinutes() {
        if (!isEventCache()) {
            return -1;
        }

        final String hourLocalized = CgeoApplication.getInstance().getString(R.string.cache_time_full_hours);
        final List<Pattern> patterns = new ArrayList<>();

        // 12:34
        patterns.add(Pattern.compile("\\b(\\d{1,2})\\:(\\d\\d)\\b"));
        if (StringUtils.isNotBlank(hourLocalized)) {
            // 12:34o'clock
            patterns.add(Pattern.compile("\\b(\\d{1,2})\\:(\\d\\d)" + Pattern.quote(hourLocalized), Pattern.CASE_INSENSITIVE));
            // 17 - 20 o'clock
            patterns.add(Pattern.compile("\\b(\\d{1,2})(?:\\.00)?" + "\\s*(?:-|[a-z]+)\\s?" + "(?:\\d{1,2})(?:\\.00)?" + "\\s?" + Pattern.quote(hourLocalized), Pattern.CASE_INSENSITIVE));
            // 12 o'clock, 12.00 o'clock
            patterns.add(Pattern.compile("\\b(\\d{1,2})(?:\\.(00|15|30|45))?\\s?" + Pattern.quote(hourLocalized), Pattern.CASE_INSENSITIVE));
        }

        final String searchText = getShortDescription() + ' ' + getDescription();
        for (final Pattern pattern : patterns) {
            final MatcherWrapper matcher = new MatcherWrapper(pattern, searchText);
            while (matcher.find()) {
                try {
                    final int hours = Integer.parseInt(matcher.group(1));
                    int minutes = 0;
                    if (matcher.groupCount() >= 2 && StringUtils.isNotEmpty(matcher.group(2))) {
                        minutes = Integer.parseInt(matcher.group(2));
                    }
                    if (hours >= 0 && hours < 24 && minutes >= 0 && minutes < 60) {
                        return hours * 60 + minutes;
                    }
                } catch (final NumberFormatException ignored) {
                    // cannot happen, but static code analysis doesn't know
                }
            }
        }
        return -1;
    }

    public boolean hasStaticMap() {
        return StaticMapsProvider.hasStaticMap(this);
    }

    @NonNull
    public Collection<Image> getImages() {
        final List<Image> result = new LinkedList<>();
        result.addAll(getSpoilers());
        addLocalSpoilersTo(result);
        for (final LogEntry log : getLogs()) {
            result.addAll(log.getLogImages());
        }
        ImageUtils.addImagesFromHtml(result, geocode, getShortDescription(), getDescription());
        return result;
    }

    /**
     * Add spoilers stored locally in <tt>/sdcard/GeocachePhotos</tt>. If a cache is named GC123ABC, the
     * directory will be <tt>/sdcard/GeocachePhotos/C/B/GC123ABC/</tt>.
     *
     * @param spoilers the list to add to
     */
    private void addLocalSpoilersTo(final List<Image> spoilers) {
        if (StringUtils.length(geocode) >= 2) {
            final String suffix = StringUtils.right(geocode, 2);
            final File baseDir = new File(Environment.getExternalStorageDirectory(), "GeocachePhotos");
            final File lastCharDir = new File(baseDir, suffix.substring(1));
            final File secondToLastCharDir = new File(lastCharDir, suffix.substring(0, 1));
            final File finalDir = new File(secondToLastCharDir, geocode);
            final File[] files = finalDir.listFiles();
            if (files != null) {
                for (final File image : files) {
                    spoilers.add(new Image.Builder()
                            .setUrl("file://" + image.getAbsolutePath())
                            .setTitle(image.getName())
                            .build());
                }
            }
        }
    }

    public void setDetailedUpdatedNow() {
        final long now = System.currentTimeMillis();
        setUpdated(now);
        setDetailedUpdate(now);
        setDetailed(true);
    }

    /**
     * Gets whether the user has logged the specific log type for this cache. Only checks the currently stored logs of
     * the cache, so the result might be wrong.
     */
    public boolean hasOwnLog(final LogType logType) {
        for (final LogEntry logEntry : getLogs()) {
            if (logEntry.getType() == logType && logEntry.isOwn()) {
                return true;
            }
        }
        return false;
    }

    public int getMapMarkerId() {
        return getConnector().getCacheMapMarkerId(isDisabled() || isArchived());
    }

    public boolean isLogPasswordRequired() {
        return logPasswordRequired;
    }

    public void setLogPasswordRequired(final boolean required) {
        logPasswordRequired = required;
    }

    public String getWaypointGpxId(final String prefix) {
        return getConnector().getWaypointGpxId(prefix, geocode);
    }

    @NonNull
    public String getWaypointPrefix(final String name) {
        return getConnector().getWaypointPrefix(name);
    }

    /**
     * Get number of overall finds for a cache, or 0 if the number of finds is not known.
     */
    public int getFindsCount() {
        if (getLogCounts().isEmpty()) {
            setLogCounts(inDatabase() ? DataStore.loadLogCounts(getGeocode()) : Collections.<LogType, Integer>emptyMap());
        }
        final Integer logged = getLogCounts().get(LogType.FOUND_IT);
        if (logged != null) {
            return logged;
        }
        return 0;
    }

    public boolean applyDistanceRule() {
        return (getType().applyDistanceRule() || hasUserModifiedCoords()) && getConnector() == GCConnector.getInstance();
    }

    @NonNull
    public LogType getDefaultLogType() {
        if (isEventCache()) {
            final Date eventDate = getHiddenDate();
            final boolean expired = CalendarUtils.isPastEvent(this);

            if (hasOwnLog(LogType.WILL_ATTEND) || expired || (eventDate != null && CalendarUtils.daysSince(eventDate.getTime()) == 0)) {
                return hasOwnLog(LogType.ATTENDED) ? LogType.NOTE : LogType.ATTENDED;
            }
            return LogType.WILL_ATTEND;
        }
        if (isFound()) {
            return LogType.NOTE;
        }
        if (getType() == CacheType.WEBCAM) {
            return LogType.WEBCAM_PHOTO_TAKEN;
        }
        return LogType.FOUND_IT;
    }

    /**
     * Get the geocodes of a collection of caches.
     *
     * @param caches a collection of caches
     * @return the non-blank geocodes of the caches
     */
    @NonNull
    public static Set<String> getGeocodes(@NonNull final Collection<Geocache> caches) {
        final Set<String> geocodes = new HashSet<>(caches.size());
        for (final Geocache cache : caches) {
            final String geocode = cache.getGeocode();
            if (StringUtils.isNotBlank(geocode)) {
                geocodes.add(geocode);
            }
        }
        return geocodes;
    }

    /**
     * Show the hint as toast message. If no hint is available, a default "no hint available" will be shown instead.
     */
    public void showHintToast(final Activity activity) {
        final String hint = getHint();
        ActivityMixin.showToast(activity, StringUtils.defaultIfBlank(hint, activity.getString(R.string.cache_hint_not_available)));
    }

    public GeoitemRef getGeoitemRef() {
        return new GeoitemRef(getGeocode(), getCoordType(), getGeocode(), 0, getName(), getType().markerId);
    }

}
!@#$%
20190527_013756,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_b12788
package cgeo.geocaching.settings;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.os.Build;
import android.preference.PreferenceManager;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;

import java.io.File;
import java.io.FileFilter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Set;

import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.R;
import cgeo.geocaching.apps.navi.NavigationAppFactory.NavigationAppsEnum;
import cgeo.geocaching.connector.capability.ICredentials;
import cgeo.geocaching.connector.gc.GCConnector;
import cgeo.geocaching.connector.gc.GCConstants;
import cgeo.geocaching.connector.gc.GCMemberState;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.list.StoredList;
import cgeo.geocaching.location.Geopoint;
import cgeo.geocaching.log.LogTypeTrackable;
import cgeo.geocaching.log.TrackableComparator;
import cgeo.geocaching.maps.LivemapStrategy;
import cgeo.geocaching.maps.MapMode;
import cgeo.geocaching.maps.MapProviderFactory;
import cgeo.geocaching.maps.google.v1.GoogleMapProvider;
import cgeo.geocaching.maps.interfaces.GeoPointImpl;
import cgeo.geocaching.maps.interfaces.MapProvider;
import cgeo.geocaching.maps.interfaces.MapSource;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider.OfflineMapSource;
import cgeo.geocaching.maps.routing.Routing;
import cgeo.geocaching.maps.routing.RoutingMode;
import cgeo.geocaching.network.HtmlImage;
import cgeo.geocaching.playservices.GooglePlayServices;
import cgeo.geocaching.sensors.MagnetometerAndAccelerometerProvider;
import cgeo.geocaching.sensors.OrientationProvider;
import cgeo.geocaching.sensors.RotationProvider;
import cgeo.geocaching.storage.DataStore;
import cgeo.geocaching.storage.LocalStorage;
import cgeo.geocaching.utils.CryptUtils;
import cgeo.geocaching.utils.FileUtils;
import cgeo.geocaching.utils.FileUtils.FileSelector;
import cgeo.geocaching.utils.Log;

/**
 * General c:geo preferences/settings set by the user
 */
public class Settings {

    /**
     * On opening a map, we limit the _initial_ zoom. The user can still zoom out afterwards.
     */
    private static final int INITIAL_MAP_ZOOM_LIMIT = 16;

    /**
     * Separator char for preferences with multiple elements.
     */
    private static final char SEPARATOR_CHAR = ',';

    private static final int SHOW_WP_THRESHOLD_DEFAULT = 10;
    public static final int SHOW_WP_THRESHOLD_MAX = 50;
    private static final int MAP_SOURCE_DEFAULT = GoogleMapProvider.GOOGLE_MAP_ID.hashCode();

    private static final String PHONE_MODEL_AND_SDK = Build.MODEL + "/" + Build.VERSION.SDK_INT;

    // twitter api keys
    @NonNull private static final String TWITTER_KEY_CONSUMER_PUBLIC = CryptUtils.rot13("ESnsCvAv3kEupF1GCR3jGj");
    @NonNull private static final String TWITTER_KEY_CONSUMER_SECRET = CryptUtils.rot13("7vQWceACV9umEjJucmlpFe9FCMZSeqIqfkQ2BnhV9x");

    private static boolean useCompass = true;

    public enum CoordInputFormatEnum {
        Plain,
        Deg,
        Min,
        Sec;

        static final int DEFAULT_INT_VALUE = Min.ordinal();

        public static CoordInputFormatEnum fromInt(final int id) {
            final CoordInputFormatEnum[] values = CoordInputFormatEnum.values();
            if (id < 0 || id >= values.length) {
                return Min;
            }
            return values[id];
        }
    }

    private static final SharedPreferences sharedPrefs = PreferenceManager
            .getDefaultSharedPreferences(CgeoApplication.getInstance().getBaseContext());
    static {
        migrateSettings();
        Log.setDebug(sharedPrefs.getBoolean(getKey(R.string.pref_debug), false));
    }

    /**
     * Cache the mapsource locally. If that is an offline map source, each request would potentially access the
     * underlying map file, leading to delays.
     */
    private static MapSource mapSource;

    protected Settings() {
        throw new InstantiationError();
    }

    private static void migrateSettings() {
        final int latestPreferencesVersion = 3;
        final int currentVersion = getInt(R.string.pref_settingsversion, 0);

        // No need to migrate if we are up to date.
        if (currentVersion == latestPreferencesVersion) {
            return;
        }

        // No need to migrate if we don't have older settings, defaults will be used instead.
        final String preferencesNameV0 = "cgeo.pref";
        final SharedPreferences prefsV0 = CgeoApplication.getInstance().getSharedPreferences(preferencesNameV0, Context.MODE_PRIVATE);
        if (currentVersion == 0 && prefsV0.getAll().isEmpty()) {
            final Editor e = sharedPrefs.edit();
            e.putInt(getKey(R.string.pref_settingsversion), latestPreferencesVersion);
            e.apply();
            return;
        }

        if (currentVersion < 1) {
            // migrate from non standard file location and integer based boolean types
            final Editor e = sharedPrefs.edit();

            e.putString(getKey(R.string.pref_temp_twitter_token_secret), prefsV0.getString(getKey(R.string.pref_temp_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_temp_twitter_token_public), prefsV0.getString(getKey(R.string.pref_temp_twitter_token_public), null));
            e.putBoolean(getKey(R.string.pref_help_shown), prefsV0.getInt(getKey(R.string.pref_help_shown), 0) != 0);
            e.putFloat(getKey(R.string.pref_anylongitude), prefsV0.getFloat(getKey(R.string.pref_anylongitude), 0));
            e.putFloat(getKey(R.string.pref_anylatitude), prefsV0.getFloat(getKey(R.string.pref_anylatitude), 0));
            e.putBoolean(getKey(R.string.pref_offlinemaps), prefsV0.getInt(getKey(R.string.pref_offlinemaps), 1) != 0);
            e.putBoolean(getKey(R.string.pref_offlinewpmaps), prefsV0.getInt(getKey(R.string.pref_offlinewpmaps), 0) != 0);
            e.putString(getKey(R.string.pref_webDeviceCode), prefsV0.getString(getKey(R.string.pref_webDeviceCode), null));
            e.putString(getKey(R.string.pref_webDeviceName), prefsV0.getString(getKey(R.string.pref_webDeviceName), null));
            e.putBoolean(getKey(R.string.pref_maplive), prefsV0.getInt(getKey(R.string.pref_maplive), 1) != 0);
            e.putInt(getKey(R.string.pref_mapsource), prefsV0.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT));
            e.putBoolean(getKey(R.string.pref_twitter), prefsV0.getInt(getKey(R.string.pref_twitter), 0) != 0);
            e.putBoolean(getKey(R.string.pref_showaddress), prefsV0.getInt(getKey(R.string.pref_showaddress), 1) != 0);
            e.putBoolean(getKey(R.string.pref_maptrail), prefsV0.getInt(getKey(R.string.pref_maptrail), 1) != 0);
            e.putInt(getKey(R.string.pref_lastmapzoom), prefsV0.getInt(getKey(R.string.pref_lastmapzoom), 14));
            e.putBoolean(getKey(R.string.pref_livelist), prefsV0.getInt(getKey(R.string.pref_livelist), 1) != 0);
            e.putBoolean(getKey(R.string.pref_units_imperial), prefsV0.getInt(getKey(R.string.pref_units_imperial), 1) != 1);
            e.putBoolean(getKey(R.string.pref_skin), prefsV0.getInt(getKey(R.string.pref_skin), 0) != 0);
            e.putInt(getKey(R.string.pref_lastusedlist), prefsV0.getInt(getKey(R.string.pref_lastusedlist), StoredList.STANDARD_LIST_ID));
            e.putString(getKey(R.string.pref_cachetype), prefsV0.getString(getKey(R.string.pref_cachetype), CacheType.ALL.id));
            e.putString(getKey(R.string.pref_twitter_token_secret), prefsV0.getString(getKey(R.string.pref_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_twitter_token_public), prefsV0.getString(getKey(R.string.pref_twitter_token_public), null));
            e.putInt(getKey(R.string.pref_version), prefsV0.getInt(getKey(R.string.pref_version), 0));
            e.putBoolean(getKey(R.string.pref_ratingwanted), prefsV0.getBoolean(getKey(R.string.pref_ratingwanted), true));
            e.putBoolean(getKey(R.string.pref_friendlogswanted), prefsV0.getBoolean(getKey(R.string.pref_friendlogswanted), true));
            e.putBoolean(getKey(R.string.pref_useenglish), prefsV0.getBoolean(getKey(R.string.pref_useenglish), false));
            e.putBoolean(getKey(R.string.pref_usecompass), prefsV0.getInt(getKey(R.string.pref_usecompass), 1) != 0);
            e.putBoolean(getKey(R.string.pref_trackautovisit), prefsV0.getBoolean(getKey(R.string.pref_trackautovisit), false));
            e.putBoolean(getKey(R.string.pref_sigautoinsert), prefsV0.getBoolean(getKey(R.string.pref_sigautoinsert), false));
            e.putBoolean(getKey(R.string.pref_logimages), prefsV0.getBoolean(getKey(R.string.pref_logimages), false));
            e.putBoolean(getKey(R.string.pref_excludedisabled), prefsV0.getInt(getKey(R.string.pref_excludedisabled), 0) != 0);
            e.putBoolean(getKey(R.string.pref_excludemine), prefsV0.getInt(getKey(R.string.pref_excludemine), 0) != 0);
            e.putString(getKey(R.string.pref_mapfile), prefsV0.getString(getKey(R.string.pref_mapfile), null));
            e.putString(getKey(R.string.pref_signature), prefsV0.getString(getKey(R.string.pref_signature), null));
            e.putString(getKey(R.string.pref_pass_vote), prefsV0.getString(getKey(R.string.pref_pass_vote), null));
            e.putString(getKey(R.string.pref_password), prefsV0.getString(getKey(R.string.pref_password), null));
            e.putString(getKey(R.string.pref_username), prefsV0.getString(getKey(R.string.pref_username), null));
            e.putString(getKey(R.string.pref_memberstatus), prefsV0.getString(getKey(R.string.pref_memberstatus), ""));
            e.putInt(getKey(R.string.pref_coordinputformat), prefsV0.getInt(getKey(R.string.pref_coordinputformat), CoordInputFormatEnum.DEFAULT_INT_VALUE));
            e.putBoolean(getKey(R.string.pref_log_offline), prefsV0.getBoolean(getKey(R.string.pref_log_offline), false));
            e.putBoolean(getKey(R.string.pref_choose_list), prefsV0.getBoolean(getKey(R.string.pref_choose_list), true));
            e.putBoolean(getKey(R.string.pref_loaddirectionimg), prefsV0.getBoolean(getKey(R.string.pref_loaddirectionimg), true));
            e.putString(getKey(R.string.pref_gccustomdate), prefsV0.getString(getKey(R.string.pref_gccustomdate), GCConstants.DEFAULT_GC_DATE));
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), prefsV0.getInt(getKey(R.string.pref_showwaypointsthreshold), SHOW_WP_THRESHOLD_DEFAULT));
            e.putBoolean(getKey(R.string.pref_opendetailslastpage), prefsV0.getBoolean(getKey(R.string.pref_opendetailslastpage), false));
            e.putInt(getKey(R.string.pref_lastdetailspage), prefsV0.getInt(getKey(R.string.pref_lastdetailspage), 1));
            e.putInt(getKey(R.string.pref_defaultNavigationTool), prefsV0.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id));
            e.putInt(getKey(R.string.pref_defaultNavigationTool2), prefsV0.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id));
            e.putInt(getKey(R.string.pref_livemapstrategy), prefsV0.getInt(getKey(R.string.pref_livemapstrategy), LivemapStrategy.AUTO.id));
            e.putBoolean(getKey(R.string.pref_debug), prefsV0.getBoolean(getKey(R.string.pref_debug), false));
            e.putInt(getKey(R.string.pref_livemaphintshowcount), prefsV0.getInt(getKey(R.string.pref_livemaphintshowcount), 0));

            e.putInt(getKey(R.string.pref_settingsversion), 1); // mark migrated
            e.apply();
        }

        // changes for new settings dialog
        if (currentVersion < 2) {
            final Editor e = sharedPrefs.edit();

            e.putBoolean(getKey(R.string.pref_units_imperial), useImperialUnits());

            // show waypoints threshold now as a slider
            int wpThreshold = getWayPointsThreshold();
            if (wpThreshold < 0) {
                wpThreshold = 0;
            } else if (wpThreshold > SHOW_WP_THRESHOLD_MAX) {
                wpThreshold = SHOW_WP_THRESHOLD_MAX;
            }
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), wpThreshold);

            // KEY_MAP_SOURCE must be string, because it is the key for a ListPreference now
            final int ms = sharedPrefs.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT);
            e.remove(getKey(R.string.pref_mapsource));
            e.putString(getKey(R.string.pref_mapsource), String.valueOf(ms));

            // navigation tool ids must be string, because ListPreference uses strings as keys
            final int dnt1 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id);
            final int dnt2 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id);
            e.remove(getKey(R.string.pref_defaultNavigationTool));
            e.remove(getKey(R.string.pref_defaultNavigationTool2));
            e.putString(getKey(R.string.pref_defaultNavigationTool), String.valueOf(dnt1));
            e.putString(getKey(R.string.pref_defaultNavigationTool2), String.valueOf(dnt2));

            // defaults for gpx directories
            e.putString(getKey(R.string.pref_gpxImportDir), LocalStorage.getDefaultGpxDirectory().getPath());
            e.putString(getKey(R.string.pref_gpxExportDir), LocalStorage.getDefaultGpxDirectory().getPath());

            e.putInt(getKey(R.string.pref_settingsversion), 2); // mark migrated
            e.apply();
        }

        if (currentVersion < 3) {
            final Editor e = sharedPrefs.edit();

            Log.i("Moving field-notes");
            FileUtils.move(LocalStorage.getLegacyFieldNotesDirectory(), LocalStorage.getFieldNotesDirectory());

            Log.i("Moving gpx ex- and import dirs");
            if (getGpxExportDir().equals(LocalStorage.getLegacyGpxDirectory().getPath())) {
                e.putString(getKey(R.string.pref_gpxExportDir), LocalStorage.getDefaultGpxDirectory().getPath());
            }
            if (getGpxImportDir().equals(LocalStorage.getLegacyGpxDirectory().getPath())) {
                e.putString(getKey(R.string.pref_gpxImportDir), LocalStorage.getDefaultGpxDirectory().getPath());
            }
            FileUtils.move(LocalStorage.getLegacyGpxDirectory(), LocalStorage.getDefaultGpxDirectory());

            Log.i("Moving local spoilers");
            FileUtils.move(LocalStorage.getLegacyLocalSpoilersDirectory(), LocalStorage.getLocalSpoilersDirectory());

            Log.i("Moving db files");
            FileUtils.moveTo(new File(LocalStorage.getLegacyExternalCgeoDirectory(), DataStore.DB_FILE_NAME), LocalStorage.getExternalDbDirectory());
            FileUtils.moveTo(new File(LocalStorage.getLegacyExternalCgeoDirectory(), DataStore.DB_FILE_NAME + DataStore.DB_FILE_CORRUPTED_EXTENSION), LocalStorage.getBackupDirectory());
            FileUtils.moveTo(new File(LocalStorage.getLegacyExternalCgeoDirectory(), DataStore.DB_FILE_NAME_BACKUP), LocalStorage.getBackupDirectory());
            FileUtils.moveTo(new File(LocalStorage.getLegacyExternalCgeoDirectory(), DataStore.DB_FILE_NAME_BACKUP + DataStore.DB_FILE_CORRUPTED_EXTENSION), LocalStorage.getBackupDirectory());

            Log.i("Moving geocache data");
            final FileFilter geocacheDirectories = new FileFilter() {
                @Override
                public boolean accept(final File pathname) {
                    final String name = pathname.getName();
                    return pathname.isDirectory() &&
                            (HtmlImage.SHARED.equals(name) || LocalStorage.GEOCACHE_FILE_PATTERN.matcher(name).find());
                }
            };
            final File[] list = LocalStorage.getLegacyExternalCgeoDirectory().listFiles(geocacheDirectories);
            if (list != null) {
                for (final File file : list) {
                    FileUtils.moveTo(file, LocalStorage.getGeocacheDataDirectory());
                }
            }

            Log.i("Deleting legacy .cgeo dir");
            FileUtils.deleteIgnoringFailure(LocalStorage.getLegacyExternalCgeoDirectory());

            e.putString(getKey(R.string.pref_dataDir), LocalStorage.getExternalPrivateCgeoDirectory().getAbsolutePath());
            e.putInt(getKey(R.string.pref_settingsversion), 3); // mark migrated
            e.apply();
        }
    }

    private static String getKey(final int prefKeyId) {
        return CgeoApplication.getInstance().getString(prefKeyId);
    }

    static String getString(final int prefKeyId, final String defaultValue) {
        return sharedPrefs.getString(getKey(prefKeyId), defaultValue);
    }

    private static List<String> getStringList(final int prefKeyId, final String defaultValue) {
        return Arrays.asList(StringUtils.split(getString(prefKeyId, defaultValue), SEPARATOR_CHAR));
    }

    private static int getInt(final int prefKeyId, final int defaultValue) {
        return sharedPrefs.getInt(getKey(prefKeyId), defaultValue);
    }

    private static long getLong(final int prefKeyId, final long defaultValue) {
        return sharedPrefs.getLong(getKey(prefKeyId), defaultValue);
    }

    private static boolean getBoolean(final int prefKeyId, final boolean defaultValue) {
        return sharedPrefs.getBoolean(getKey(prefKeyId), defaultValue);
    }

    private static float getFloat(final int prefKeyId, final float defaultValue) {
        return sharedPrefs.getFloat(getKey(prefKeyId), defaultValue);
    }

    protected static void putString(final int prefKeyId, final String value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putString(getKey(prefKeyId), value);
        edit.apply();
    }

    private static void putStringList(final int prefKeyId, final Iterable<?> elements) {
        putString(prefKeyId, StringUtils.join(elements, SEPARATOR_CHAR));
    }


    protected static void putBoolean(final int prefKeyId, final boolean value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putBoolean(getKey(prefKeyId), value);
        edit.apply();
    }

    private static void putInt(final int prefKeyId, final int value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putInt(getKey(prefKeyId), value);
        edit.apply();
    }

    private static void putLong(final int prefKeyId, final long value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putLong(getKey(prefKeyId), value);
        edit.apply();
    }

    private static void putFloat(final int prefKeyId, final float value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putFloat(getKey(prefKeyId), value);
        edit.apply();
    }

    private static void remove(final int prefKeyId) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.remove(getKey(prefKeyId));
        edit.apply();
    }

    private static boolean contains(final int prefKeyId) {
        return sharedPrefs.contains(getKey(prefKeyId));
    }

    public static boolean hasGCCredentials() {
        return getGcCredentials().isValid();
    }

    /**
     * Get login and password information of Geocaching.com.
     *
     * @return a pair either with (login, password) or (empty, empty) if no valid information is stored
     */
    public static Credentials getGcCredentials() {
        return getCredentials(GCConnector.getInstance());
    }

    /**
     * Get login and password information from preference key id.
     *
     * @param usernamePreferenceKey Username preference key id
     * @param passwordPreferenceKey Password preference key id
     * @return the credential information
     */
    @NonNull
    public static Credentials getCredentials(final int usernamePreferenceKey, final int passwordPreferenceKey) {
        final String username = StringUtils.trim(getString(usernamePreferenceKey, StringUtils.EMPTY));
        final String password = getString(passwordPreferenceKey, StringUtils.EMPTY);
        return new Credentials(username, password);
    }

    /**
     * Get login and password information.
     *
     * @param connector the connector to retrieve the login information from
     * @return the credential information
     */
    @NonNull
    public static Credentials getCredentials(@NonNull final ICredentials connector) {
        return getCredentials(connector.getUsernamePreferenceKey(), connector.getPasswordPreferenceKey());
    }

    /**
     * Set login and password information.
     *
     * @param connector the connector to retrieve the login information from
     * @param credentials the credential information to store
     */
    public static void setCredentials(@NonNull final ICredentials connector, final Credentials credentials) {
        putString(connector.getUsernamePreferenceKey(), credentials.getUsernameRaw());
        putString(connector.getPasswordPreferenceKey(), credentials.getPasswordRaw());
    }

    public static String getUserName() {
        return StringUtils.trim(getString(R.string.pref_username, StringUtils.EMPTY));
    }

    public static boolean isGCConnectorActive() {
        return getBoolean(R.string.pref_connectorGCActive, true);
    }

    public static boolean isECConnectorActive() {
        return getBoolean(R.string.pref_connectorECActive, false);
    }

    public static boolean isSUConnectorActive() {
        return getBoolean(R.string.pref_connectorSUActive, false);
    }

    public static boolean isGCPremiumMember() {
        return getGCMemberStatus().isPremium();
    }

    public static GCMemberState getGCMemberStatus() {
        return GCMemberState.fromString(getString(R.string.pref_memberstatus, ""));
    }

    public static void setGCMemberStatus(final GCMemberState memberStatus) {
        putString(R.string.pref_memberstatus, memberStatus.englishWebsite);
    }

    @NonNull
    public static ImmutablePair<String, String> getTokenPair(final int tokenPublicPrefKey, final int tokenSecretPrefKey) {
        return new ImmutablePair<>(getString(tokenPublicPrefKey, null), getString(tokenSecretPrefKey, null));
    }

    public static void setTokens(final int tokenPublicPrefKey, @Nullable final String tokenPublic, final int tokenSecretPrefKey, @Nullable final String tokenSecret) {
        if (tokenPublic == null) {
            remove(tokenPublicPrefKey);
        } else {
            putString(tokenPublicPrefKey, tokenPublic);
        }
        if (tokenSecret == null) {
            remove(tokenSecretPrefKey);
        } else {
            putString(tokenSecretPrefKey, tokenSecret);
        }
    }

    public static boolean isOCConnectorActive(final int isActivePrefKeyId) {
        return getBoolean(isActivePrefKeyId, false);
    }

    public static boolean hasOCAuthorization(final int tokenPublicPrefKeyId, final int tokenSecretPrefKeyId) {
        return StringUtils.isNotBlank(getString(tokenPublicPrefKeyId, ""))
                && StringUtils.isNotBlank(getString(tokenSecretPrefKeyId, ""));
    }

    public static boolean isGCVoteLoginValid() {
        return getGCVoteLogin().isValid();
    }

    @NonNull
    public static Credentials getGCVoteLogin() {
        final String username = StringUtils.trimToNull(getString(R.string.pref_username, null));
        final String password = getString(R.string.pref_pass_vote, null);
        return new Credentials(username, password);
    }

    @NonNull
    public static String getSignature() {
        return StringUtils.defaultString(getString(R.string.pref_signature, StringUtils.EMPTY));
    }

    public static void setUseGooglePlayServices(final boolean value) {
        putBoolean(R.string.pref_googleplayservices, value);
    }

    public static boolean useGooglePlayServices() {
        if (!GooglePlayServices.isAvailable()) {
            return false;
        }
        return outdatedPhoneModelOrSdk() || getBoolean(R.string.pref_googleplayservices, true);
    }

    public static boolean useLowPowerMode() {
        return getBoolean(R.string.pref_lowpowermode, false);
    }

    /**
     * @param cacheType
     *            The cache type used for future filtering
     */
    public static void setCacheType(final CacheType cacheType) {
        if (cacheType == null) {
            remove(R.string.pref_cachetype);
        } else {
            putString(R.string.pref_cachetype, cacheType.id);
        }
    }

    public static int getLastDisplayedList() {
        return getInt(R.string.pref_lastusedlist, StoredList.STANDARD_LIST_ID);
    }

    /**
     * remember the last displayed cache list
     */
    public static void setLastDisplayedList(final int listId) {
        putInt(R.string.pref_lastusedlist, listId);
    }

    public static Set<Integer> getLastSelectedLists() {
        final Set<Integer> lastSelectedLists = new HashSet<>();
        for (final String lastSelectedListString : getStringList(R.string.pref_last_selected_lists, StringUtils.EMPTY)) {
            try {
                lastSelectedLists.add(Integer.valueOf(lastSelectedListString));
            } catch (final NumberFormatException ignored) { }
        }
        return lastSelectedLists;
    }

    /**
     * remember the last selection in the dialog that assigns a cache to certain lists
     */
    public static void setLastSelectedLists(final Set<Integer> lastSelectedLists) {
        putStringList(R.string.pref_last_selected_lists, lastSelectedLists);
    }

    public static void setWebNameCode(final String name, final String code) {
        putString(R.string.pref_webDeviceName, name);
        putString(R.string.pref_webDeviceCode, code);
    }

    public static MapProvider getMapProvider() {
        return getMapSource().getMapProvider();
    }

    public static String getMapFile() {
        return getString(R.string.pref_mapfile, null);
    }

    static void setMapFile(final String mapFile) {
        putString(R.string.pref_mapfile, mapFile);
        if (mapFile != null) {
            setMapFileDirectory(new File(mapFile).getParent());
        }
    }

    public static String getMapFileDirectory() {
        final String mapDir = getString(R.string.pref_mapDirectory, null);
        if (mapDir != null) {
            return mapDir;
        }
        final String mapFile = getMapFile();
        if (mapFile != null) {
            return new File(mapFile).getParent();
        }
        return null;
    }

    static void setMapFileDirectory(final String mapFileDirectory) {
        putString(R.string.pref_mapDirectory, mapFileDirectory);
        MapsforgeMapProvider.getInstance().updateOfflineMaps();
    }

    private static boolean isValidMapFile() {
        return isValidMapFile(getMapFile());
    }

    public static boolean isValidMapFile(final String mapFileIn) {
        return MapsforgeMapProvider.isValidMapFile(mapFileIn);
    }

    public static boolean isScaleMapsforgeText() {
        return getBoolean(R.string.pref_mapsforge_scale_text, true);
    }

    public static CoordInputFormatEnum getCoordInputFormat() {
        return CoordInputFormatEnum.fromInt(getInt(R.string.pref_coordinputformat, CoordInputFormatEnum.DEFAULT_INT_VALUE));
    }

    public static void setCoordInputFormat(final CoordInputFormatEnum format) {
        putInt(R.string.pref_coordinputformat, format.ordinal());
    }

    public static boolean getLogOffline() {
        return getBoolean(R.string.pref_log_offline, false);
    }

    public static boolean getChooseList() {
        return getBoolean(R.string.pref_choose_list, false);
    }

    public static boolean getLoadDirImg() {
        return !isGCPremiumMember() && getBoolean(R.string.pref_loaddirectionimg, true);
    }

    public static void setGcCustomDate(final String format) {
        putString(R.string.pref_gccustomdate, format);
    }

    /**
     * @return User selected date format on GC.com
     */
    public static String getGcCustomDate() {
        // We might have some users whose stored value is null, which is invalid. In this case, we use the default.
        return StringUtils.defaultString(getString(R.string.pref_gccustomdate, GCConstants.DEFAULT_GC_DATE),
                GCConstants.DEFAULT_GC_DATE);
    }

    public static boolean isExcludeMyCaches() {
        return getBoolean(R.string.pref_excludemine, false);
    }

    public static boolean useEnglish() {
        return getBoolean(R.string.pref_useenglish, false);
    }

    public static void setUseEnglish(final boolean useEnglish) {
        putBoolean(R.string.pref_useenglish, useEnglish);
    }

    public static boolean isShowAddress() {
        return getBoolean(R.string.pref_showaddress, true);
    }

    public static boolean isExcludeDisabledCaches() {
        return getBoolean(R.string.pref_excludedisabled, false);
    }

    public static boolean isStoreOfflineMaps() {
        return getBoolean(R.string.pref_offlinemaps, true);
    }

    public static boolean isStoreOfflineWpMaps() {
        return getBoolean(R.string.pref_offlinewpmaps, false);
    }

    public static boolean isStoreLogImages() {
        return getBoolean(R.string.pref_logimages, false);
    }

    public static boolean isRatingWanted() {
        return getBoolean(R.string.pref_ratingwanted, true);
    }

    public static boolean isGeokretyConnectorActive() {
        return getBoolean(R.string.pref_connectorGeokretyActive, false);
    }

    public static boolean isGeokretyCacheActive() {
        return getBoolean(R.string.pref_geokrety_cache, true);
    }

    static boolean hasGeokretyAuthorization() {
        return StringUtils.isNotBlank(getGeokretySecId());
    }

    public static String getGeokretySecId() {
        return getString(R.string.pref_fakekey_geokrety_authorization, null);
    }

    public static void setGeokretySecId(final String secid) {
        putString(R.string.pref_fakekey_geokrety_authorization, secid);
    }

    public static String getTokenSecret(final int prefKeyId) {
        return getString(prefKeyId, StringUtils.EMPTY);
    }

    public static void setTokenSecret(final int prefKeyId, final String secretToken) {
        putString(prefKeyId, secretToken);
    }

    public static boolean isRegisteredForGeokretyLogging() {
        return getGeokretySecId() != null;
    }

    /**
     * Retrieve showed popup counter for warning about logging Trackable recommend Geocode
     *
     * @return number of times the popup has appeared
     */
    public static int getLogTrackableWithoutGeocodeShowCount() {
        return getInt(R.string.pref_logtrackablewithoutgeocodeshowcount, 0);
    }

    /**
     * Store showed popup counter for warning about logging Trackable recommend Geocode
     *
     * @param showCount the count to save
     */
    public static void setLogTrackableWithoutGeocodeShowCount(final int showCount) {
        putInt(R.string.pref_logtrackablewithoutgeocodeshowcount, showCount);
    }

    public static boolean isFriendLogsWanted() {
        if (!hasGCCredentials()) {
            // don't show a friends log if the user is anonymous
            return false;
        }
        return getBoolean(R.string.pref_friendlogswanted, true);
    }

    public static boolean isLiveList() {
        return getBoolean(R.string.pref_livelist, true);
    }

    public static boolean isTrackableAutoVisit() {
        return getBoolean(R.string.pref_trackautovisit, false);
    }

    public static boolean isAutoInsertSignature() {
        return getBoolean(R.string.pref_sigautoinsert, false);
    }

    static void setUseImperialUnits(final boolean useImperialUnits) {
        putBoolean(R.string.pref_units_imperial, useImperialUnits);
    }

    public static boolean useImperialUnits() {
        return getBoolean(R.string.pref_units_imperial, useImperialUnitsByDefault());
    }

    private static boolean useImperialUnitsByDefault() {
        final String countryCode = Locale.getDefault().getCountry();
        return "US".equals(countryCode)  // USA
            || "LR".equals(countryCode)  // Liberia
            || "MM".equals(countryCode); // Burma
    }

    public static boolean isLiveMap() {
        return getBoolean(R.string.pref_maplive, true);
    }

    public static void setLiveMap(final boolean live) {
        putBoolean(R.string.pref_maplive, live);
    }

    public static boolean isMapTrail() {
        return getBoolean(R.string.pref_maptrail, false);
    }

    public static void setMapTrail(final boolean showTrail) {
        putBoolean(R.string.pref_maptrail, showTrail);
    }

    /**
     * whether to show a direction line on the map
     */
    public static boolean isMapDirection() {
        return getBoolean(R.string.pref_map_direction, true);
    }

    public static void setMapDirection(final boolean showDirection) {
        putBoolean(R.string.pref_map_direction, showDirection);
    }

    /**
     * Get last used zoom of the internal map. Differentiate between two use cases for a map of multiple caches (e.g.
     * live map) and the map of a single cache (which is often zoomed in more deep).
     */
    public static int getMapZoom(final MapMode mapMode) {
        if (mapMode == MapMode.SINGLE || mapMode == MapMode.COORDS) {
            return getCacheZoom();
        }
        return getMapZoom();
    }

    public static void setMapZoom(final MapMode mapMode, final int zoomLevel) {
        if (mapMode == MapMode.SINGLE || mapMode == MapMode.COORDS) {
            setCacheZoom(zoomLevel);
        } else {
            setMapZoom(zoomLevel);
        }
    }

    /**
     * @return zoom used for the (live) map
     */
    private static int getMapZoom() {
        return Math.max(getInt(R.string.pref_lastmapzoom, 14), INITIAL_MAP_ZOOM_LIMIT);
    }

    private static void setMapZoom(final int mapZoomLevel) {
        putInt(R.string.pref_lastmapzoom, mapZoomLevel);
    }

    /**
     * @return zoom used for the map of a single cache
     */
    private static int getCacheZoom() {
        return Math.max(getInt(R.string.pref_cache_zoom, 14), INITIAL_MAP_ZOOM_LIMIT);
    }

    private static void setCacheZoom(final int zoomLevel) {
        putInt(R.string.pref_cache_zoom, zoomLevel);
    }

    public static GeoPointImpl getMapCenter() {
        return getMapProvider().getMapItemFactory()
                .getGeoPointBase(new Geopoint(getInt(R.string.pref_lastmaplat, 0) / 1e6,
                        getInt(R.string.pref_lastmaplon, 0) / 1e6));
    }

    public static void setMapCenter(final GeoPointImpl mapViewCenter) {
        putInt(R.string.pref_lastmaplat, mapViewCenter.getLatitudeE6());
        putInt(R.string.pref_lastmaplon, mapViewCenter.getLongitudeE6());
    }

    @NonNull
    public static synchronized MapSource getMapSource() {
        if (mapSource != null) {
            return mapSource;
        }
        final int id = getConvertedMapId();
        mapSource = MapProviderFactory.getMapSource(id);
        if (mapSource != null) {
            // don't use offline maps if the map file is not valid
            if (!(mapSource instanceof OfflineMapSource) || isValidMapFile()) {
                return mapSource;
            }
        }
        // fallback to first available map
        return MapProviderFactory.getDefaultSource();
    }

    private static final int GOOGLEMAP_BASEID = 30;
    private static final int MAP = 1;
    private static final int SATELLITE = 2;

    private static final int MFMAP_BASEID = 40;
    private static final int MAPNIK = 1;
    private static final int CYCLEMAP = 3;
    private static final int OFFLINE = 4;
    private static final int HISTORY_SIZE = 10;

    /**
     * Convert old preference ids for maps (based on constant values) into new hash based ids.
     */
    private static int getConvertedMapId() {
        final int id = Integer.parseInt(getString(R.string.pref_mapsource,
                String.valueOf(MAP_SOURCE_DEFAULT)));
        switch (id) {
            case GOOGLEMAP_BASEID + MAP:
                return GoogleMapProvider.GOOGLE_MAP_ID.hashCode();
            case GOOGLEMAP_BASEID + SATELLITE:
                return GoogleMapProvider.GOOGLE_SATELLITE_ID.hashCode();
            case MFMAP_BASEID + MAPNIK:
                return MapsforgeMapProvider.MAPSFORGE_MAPNIK_ID.hashCode();
            case MFMAP_BASEID + CYCLEMAP:
                return MapsforgeMapProvider.MAPSFORGE_CYCLEMAP_ID.hashCode();
            case MFMAP_BASEID + OFFLINE: {
                final String mapFile = getMapFile();
                if (StringUtils.isNotEmpty(mapFile)) {
                    return mapFile.hashCode();
                }
                break;
            }
            default:
                break;
        }
        return id;
    }

    public static synchronized void setMapSource(final MapSource newMapSource) {
        putString(R.string.pref_mapsource, String.valueOf(newMapSource.getNumericalId()));
        if (newMapSource instanceof OfflineMapSource) {
            setMapFile(((OfflineMapSource) newMapSource).getFileName());
        }
        // cache the value
        mapSource = newMapSource;
    }

    public static void setAnyCoordinates(final Geopoint coords) {
        if (coords != null) {
            putFloat(R.string.pref_anylatitude, (float) coords.getLatitude());
            putFloat(R.string.pref_anylongitude, (float) coords.getLongitude());
        } else {
            remove(R.string.pref_anylatitude);
            remove(R.string.pref_anylongitude);
        }
    }

    public static Geopoint getAnyCoordinates() {
        if (contains(R.string.pref_anylatitude) && contains(R.string.pref_anylongitude)) {
            final float lat = getFloat(R.string.pref_anylatitude, 0);
            final float lon = getFloat(R.string.pref_anylongitude, 0);
            return new Geopoint(lat, lon);
        }
        return null;
    }

    public static boolean isUseCompass() {
        return useCompass;
    }

    public static void setUseCompass(final boolean value) {
        useCompass = value;
    }

    public static boolean isLightSkin() {
        return getBoolean(R.string.pref_skin, false);
    }

    @NonNull
    public static String getTwitterKeyConsumerPublic() {
        return TWITTER_KEY_CONSUMER_PUBLIC;
    }

    @NonNull
    public static String getTwitterKeyConsumerSecret() {
        return TWITTER_KEY_CONSUMER_SECRET;
    }

    public static String getWebDeviceCode() {
        return getString(R.string.pref_webDeviceCode, null);
    }

    public static boolean isRegisteredForSend2cgeo() {
        return getWebDeviceCode() != null;
    }

    static String getWebDeviceName() {
        return getString(R.string.pref_webDeviceName, Build.MODEL);
    }

    /**
     * @return The cache type used for filtering or ALL if no filter is active.
     *         Returns never null
     */
    @NonNull
    public static CacheType getCacheType() {
        return CacheType.getById(getString(R.string.pref_cachetype, CacheType.ALL.id));
    }

    /**
     * The Threshold for the showing of child waypoints
     */
    public static int getWayPointsThreshold() {
        return getInt(R.string.pref_showwaypointsthreshold, SHOW_WP_THRESHOLD_DEFAULT);
    }

    static void setShowWaypointsThreshold(final int threshold) {
        putInt(R.string.pref_showwaypointsthreshold, threshold);
    }

    public static boolean isUseTwitter() {
        return getBoolean(R.string.pref_twitter, false);
    }

    private static void setUseTwitter(final boolean useTwitter) {
        putBoolean(R.string.pref_twitter, useTwitter);
    }

    public static boolean isTwitterLoginValid() {
        return !StringUtils.isBlank(getTokenPublic())
                && !StringUtils.isBlank(getTokenSecret());
    }

    public static String getTokenPublic() {
        return getString(R.string.pref_twitter_token_public, null);
    }

    public static String getTokenSecret() {
        return getString(R.string.pref_twitter_token_secret, null);

    }

    static boolean hasTwitterAuthorization() {
        return StringUtils.isNotBlank(getTokenPublic())
                && StringUtils.isNotBlank(getTokenSecret());
    }

    public static void setTwitterTokens(@Nullable final String tokenPublic,
            @Nullable final String tokenSecret, final boolean enableTwitter) {
        putString(R.string.pref_twitter_token_public, tokenPublic);
        putString(R.string.pref_twitter_token_secret, tokenSecret);
        if (tokenPublic != null) {
            remove(R.string.pref_temp_twitter_token_public);
            remove(R.string.pref_temp_twitter_token_secret);
        }
        setUseTwitter(enableTwitter);
    }

    public static void setTwitterTempTokens(@Nullable final String tokenPublic,
            @Nullable final String tokenSecret) {
        putString(R.string.pref_temp_twitter_token_public, tokenPublic);
        putString(R.string.pref_temp_twitter_token_secret, tokenSecret);
    }

    @NonNull
    public static ImmutablePair<String, String> getTempToken() {
        final String tokenPublic = getString(R.string.pref_temp_twitter_token_public, null);
        final String tokenSecret = getString(R.string.pref_temp_twitter_token_secret, null);
        return new ImmutablePair<>(tokenPublic, tokenSecret);
    }

    public static int getVersion() {
        return getInt(R.string.pref_version, 0);
    }

    public static void setVersion(final int version) {
        putInt(R.string.pref_version, version);
    }

    public static boolean isOpenLastDetailsPage() {
        return getBoolean(R.string.pref_opendetailslastpage, false);
    }

    public static int getLastDetailsPage() {
        return getInt(R.string.pref_lastdetailspage, 1);
    }

    public static void setLastDetailsPage(final int index) {
        putInt(R.string.pref_lastdetailspage, index);
    }

    public static int getDefaultNavigationTool() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool,
                String.valueOf(NavigationAppsEnum.COMPASS.id)));
    }

    public static int getDefaultNavigationTool2() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool2,
                String.valueOf(NavigationAppsEnum.INTERNAL_MAP.id)));
    }

    @NonNull
    public static LivemapStrategy getLiveMapStrategy() {
        return LivemapStrategy.getById(getInt(R.string.pref_livemapstrategy, LivemapStrategy.AUTO.id));
    }

    public static void setLiveMapStrategy(final LivemapStrategy strategy) {
        putInt(R.string.pref_livemapstrategy, strategy.id);
    }

    public static boolean isDebug() {
        return Log.isDebug();
    }

    public static int getLiveMapHintShowCount() {
        return getInt(R.string.pref_livemaphintshowcount, 0);
    }

    public static void setLiveMapHintShowCount(final int showCount) {
        putInt(R.string.pref_livemaphintshowcount, showCount);
    }

    public static boolean isDbOnSDCard() {
        return getBoolean(R.string.pref_dbonsdcard, false);
    }

    public static void setDbOnSDCard(final boolean dbOnSDCard) {
        putBoolean(R.string.pref_dbonsdcard, dbOnSDCard);
    }

    public static String getGpxExportDir() {
        return getString(R.string.pref_gpxExportDir,
                LocalStorage.getDefaultGpxDirectory().getPath());
    }

    public static String getGpxImportDir() {
        return getString(R.string.pref_gpxImportDir,
                LocalStorage.getDefaultGpxDirectory().getPath());
    }

    public static String getExternalPrivateCgeoDirectory() {
        return getString(R.string.pref_dataDir, null);
    }

    public static void setExternalPrivateCgeoDirectory(final String extDir) {
        putString(R.string.pref_dataDir, extDir);
    }

    public static boolean getShareAfterExport() {
        return getBoolean(R.string.pref_shareafterexport, true);
    }

    public static void setShareAfterExport(final boolean shareAfterExport) {
        putBoolean(R.string.pref_shareafterexport, shareAfterExport);
    }
    public static boolean getIncludeFoundStatus() {
        return getBoolean(R.string.pref_includefoundstatus, true);
    }

    public static void setIncludeFoundStatus(final boolean includeFoundStatus) {
        putBoolean(R.string.pref_includefoundstatus, includeFoundStatus);
    }

    /**
     * Get Trackable inventory sort method based on the last Trackable inventory sort method.
     *
     * @return
     *         The Trackable Sort Method previously used.
     */
    public static TrackableComparator getTrackableComparator() {
        return TrackableComparator.findByName(getString(R.string.pref_trackable_inventory_sort, ""));
    }

    /**
     * Set Trackable inventory sort method.
     *
     * @param trackableSortMethod
     *          The Trackable Sort Method to remember
     */
    public static void setTrackableComparator(final TrackableComparator trackableSortMethod) {
        putString(R.string.pref_trackable_inventory_sort, trackableSortMethod.name());
    }
    /**
     * Obtain Trackable action from the last Trackable log.
     *
     * @return
     *          The last Trackable Action or RETRIEVED_IT
     */
    public static int getTrackableAction() {
        return getInt(R.string.pref_trackableaction, LogTypeTrackable.RETRIEVED_IT.id);
    }

    /**
     * Save Trackable action from the last Trackable log.
     *
     * @param trackableAction
     *          The Trackable Action to remember
     */
    public static void setTrackableAction(final int trackableAction) {
        putInt(R.string.pref_trackableaction, trackableAction);
    }

    private static String getCustomRenderThemeBaseFolder() {
        return getString(R.string.pref_renderthemepath, "");
    }

    public static String getCustomRenderThemeFilePath() {
        return getString(R.string.pref_renderthemefile, "");
    }

    public static void setCustomRenderThemeFile(final String customRenderThemeFile) {
        putString(R.string.pref_renderthemefile, customRenderThemeFile);
    }

    public static File[] getMapThemeFiles() {
        final File directory = new File(getCustomRenderThemeBaseFolder());
        final List<File> result = new ArrayList<>();
        FileUtils.listDir(result, directory, new ExtensionsBasedFileSelector(new String[] { "xml" }), null);

        return result.toArray(new File[result.size()]);
    }

    private static class ExtensionsBasedFileSelector implements FileSelector {
        private final String[] extensions;

        ExtensionsBasedFileSelector(final String[] extensions) {
            this.extensions = extensions;
        }

        @Override
        public boolean isSelected(final File file) {
            final String filename = file.getName();
            for (final String ext : extensions) {
                if (StringUtils.endsWithIgnoreCase(filename, ext)) {
                    return true;
                }
            }
            return false;
        }

        @Override
        public boolean shouldEnd() {
            return false;
        }
    }

    /**
     * @return true if plain text log wanted
     */
    public static boolean getPlainLogs() {
        return getBoolean(R.string.pref_plainLogs, false);
    }

    /**
     * Force set the plain text log preference
     *
     * @param plainLogs
     *            wanted or not
     */
    public static void setPlainLogs(final boolean plainLogs) {
        putBoolean(R.string.pref_plainLogs, plainLogs);
    }

    public static boolean getUseNativeUa() {
        return getBoolean(R.string.pref_nativeUa, false);
    }

    @NonNull
    public static String getCacheTwitterMessage() {
        return StringUtils.defaultString(getString(R.string.pref_twitter_cache_message, "I found [NAME] ([URL])."));
    }

    @NonNull
    public static String getTrackableTwitterMessage() {
        return StringUtils.defaultString(getString(R.string.pref_twitter_trackable_message, "I touched [NAME] ([URL])."));
    }

    public static int getLogImageScale() {
        return getInt(R.string.pref_logImageScale, -1);
    }

    public static void setLogImageScale(final int scale) {
        putInt(R.string.pref_logImageScale, scale);
    }

    public static void setExcludeMine(final boolean exclude) {
        putBoolean(R.string.pref_excludemine, exclude);
    }

    public static void setExcludeDisabled(final boolean exclude) {
        putBoolean(R.string.pref_excludedisabled, exclude);
    }

    static void setLogin(final String username, final String password) {
        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            // erase username and password
            remove(R.string.pref_username);
            remove(R.string.pref_password);
            return;
        }
        // save username and password
        putString(R.string.pref_username, StringUtils.trim(username));
        putString(R.string.pref_password, password);
    }

    public static long getFieldnoteExportDate() {
        return getLong(R.string.pref_fieldNoteExportDate, 0);
    }

    /**
     * Remember date of last field note export.
     */
    public static void setFieldnoteExportDate(final long date) {
        putLong(R.string.pref_fieldNoteExportDate, date);
    }

    public static boolean isUseNavigationApp(final NavigationAppsEnum navApp) {
        return getBoolean(navApp.preferenceKey, true);
    }

    /**
     * Remember the state of the "Upload" checkbox in the field notes export dialog.
     */
    public static void setFieldNoteExportUpload(final boolean upload) {
        putBoolean(R.string.pref_fieldNoteExportUpload, upload);
    }

    public static boolean getFieldNoteExportUpload() {
        return getBoolean(R.string.pref_fieldNoteExportUpload, true);
    }

    /**
     * Remember the state of the "Only new" checkbox in the field notes export dialog.
     */
    public static void setFieldNoteExportOnlyNew(final boolean onlyNew) {
        putBoolean(R.string.pref_fieldNoteExportOnlyNew, onlyNew);
    }

    public static boolean getFieldNoteExportOnlyNew() {
        return getBoolean(R.string.pref_fieldNoteExportOnlyNew, false);
    }

    public static String getECIconSet() {
        return getString(R.string.pref_ec_icons, "1");
    }

    /* Store last checksum of changelog for changelog display */
    public static long getLastChangelogChecksum() {
        return getLong(R.string.pref_changelog_last_checksum, 0);
    }

    public static void setLastChangelogChecksum(final long checksum) {
        putLong(R.string.pref_changelog_last_checksum, checksum);
    }

    public static List<String> getLastOpenedCaches() {
        final List<String> history = getStringList(R.string.pref_caches_history, StringUtils.EMPTY);
        return history.subList(0, Math.min(HISTORY_SIZE, history.size()));
    }

    public static void addCacheToHistory(@NonNull final String geocode) {
        final List<String> history = new ArrayList<>(getLastOpenedCaches());
        // bring entry to front, if it already existed
        history.remove(geocode);
        history.add(0, geocode);
        putStringList(R.string.pref_caches_history, history);
    }

    public static boolean useNewMapAsDefault() {
        return getBoolean(R.string.pref_new_map_as_default, false);
    }

    static void setUseNewMapAsDefault(final boolean useNewMapAsDefault) {
        putBoolean(R.string.pref_new_map_as_default, useNewMapAsDefault);
    }

    public static boolean useHardwareAcceleration() {
        return outdatedPhoneModelOrSdk() ? HwAccel.hwAccelShouldBeEnabled() :
                getBoolean(R.string.pref_hardware_acceleration, HwAccel.hwAccelShouldBeEnabled());
    }

    static void setUseHardwareAcceleration(final boolean useHardwareAcceleration) {
        putBoolean(R.string.pref_hardware_acceleration, useHardwareAcceleration);
        storePhoneModelAndSdk();
    }

    private static boolean outdatedPhoneModelOrSdk() {
        return !StringUtils.equals(PHONE_MODEL_AND_SDK, getString(R.string.pref_phone_model_and_sdk, null));
    }

    private static void storePhoneModelAndSdk() {
        putString(R.string.pref_phone_model_and_sdk, PHONE_MODEL_AND_SDK);
    }

    public static String getLastCacheLog() {
        return getString(R.string.pref_last_cache_log, StringUtils.EMPTY);
    }

    public static void setLastCacheLog(final String log) {
        putString(R.string.pref_last_cache_log, log);
    }

    public static String getLastTrackableLog() {
        return getString(R.string.pref_last_trackable_log, StringUtils.EMPTY);
    }

    public static void setLastTrackableLog(final String log) {
        putString(R.string.pref_last_trackable_log, log);
    }

    @Nullable
    public static String getHomeLocation() {
        return getString(R.string.pref_home_location, null);
    }

    public static void setHomeLocation(@NonNull final String homeLocation) {
        putString(R.string.pref_home_location, homeLocation);
    }

    public static void setForceOrientationSensor(final boolean forceOrientationSensor) {
        putBoolean(R.string.pref_force_orientation_sensor, forceOrientationSensor);
    }

    public static boolean useOrientationSensor(final Context context) {
        return OrientationProvider.hasOrientationSensor(context) &&
                (getBoolean(R.string.pref_force_orientation_sensor, false) ||
                    !(RotationProvider.hasRotationSensor(context) || MagnetometerAndAccelerometerProvider.hasMagnetometerAndAccelerometerSensors(context))
                );
    }

    /**
     * Get avatar URL by connector.
     *
     * @param connector the connector to retrieve the avatar information from
     * @return the avatar url
     */
    @NonNull
    public static String getAvatarUrl(@NonNull final ICredentials connector) {
        return getString(connector.getAvatarPreferenceKey(), null);
    }

    /**
     * Set avatar URL by connector.
     *
     * @param connector the connector to retrieve the avatar information from
     * @param avatarUrl the avatar url information to store
     */
    public static void setAvatarUrl(@NonNull final ICredentials connector, final String avatarUrl) {
        putString(connector.getAvatarPreferenceKey(), avatarUrl);
    }

    /**
     * Return the locale that should be used to display information to the user.
     *
     * @return either the system locale or an English one, depending on the settings
     */
    public static Locale getApplicationLocale() {
        return Settings.useEnglish() ? Locale.ENGLISH : Locale.getDefault();
    }

    public static void setRoutingMode(@NonNull final RoutingMode mode) {
        putString(R.string.pref_map_routing, mode.parameterValue);
        Routing.invalidateRouting();
    }

    public static RoutingMode getRoutingMode() {
        return RoutingMode.fromString(getString(R.string.pref_map_routing, "foot"));
    }

}
!@#$%
20190527_013756,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_a12788
package cgeo.geocaching.settings;

import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.R;
import cgeo.geocaching.apps.navi.NavigationAppFactory.NavigationAppsEnum;
import cgeo.geocaching.connector.capability.ICredentials;
import cgeo.geocaching.connector.gc.GCConnector;
import cgeo.geocaching.connector.gc.GCConstants;
import cgeo.geocaching.connector.gc.GCMemberState;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.list.StoredList;
import cgeo.geocaching.location.Geopoint;
import cgeo.geocaching.log.LogTypeTrackable;
import cgeo.geocaching.maps.LivemapStrategy;
import cgeo.geocaching.maps.MapMode;
import cgeo.geocaching.maps.MapProviderFactory;
import cgeo.geocaching.maps.google.v1.GoogleMapProvider;
import cgeo.geocaching.maps.interfaces.GeoPointImpl;
import cgeo.geocaching.maps.interfaces.MapProvider;
import cgeo.geocaching.maps.interfaces.MapSource;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider.OfflineMapSource;
import cgeo.geocaching.maps.routing.Routing;
import cgeo.geocaching.maps.routing.RoutingMode;
import cgeo.geocaching.network.HtmlImage;
import cgeo.geocaching.playservices.GooglePlayServices;
import cgeo.geocaching.sensors.MagnetometerAndAccelerometerProvider;
import cgeo.geocaching.sensors.OrientationProvider;
import cgeo.geocaching.sensors.RotationProvider;
import cgeo.geocaching.storage.DataStore;
import cgeo.geocaching.storage.LocalStorage;
import cgeo.geocaching.utils.CryptUtils;
import cgeo.geocaching.utils.FileUtils;
import cgeo.geocaching.utils.FileUtils.FileSelector;
import cgeo.geocaching.utils.Log;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.os.Build;
import android.preference.PreferenceManager;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;

import java.io.File;
import java.io.FileFilter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Set;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;

/**
 * General c:geo preferences/settings set by the user
 */
public class Settings {

    /**
     * On opening a map, we limit the _initial_ zoom. The user can still zoom out afterwards.
     */
    private static final int INITIAL_MAP_ZOOM_LIMIT = 16;

    /**
     * Separator char for preferences with multiple elements.
     */
    private static final char SEPARATOR_CHAR = ',';

    private static final int SHOW_WP_THRESHOLD_DEFAULT = 10;
    public static final int SHOW_WP_THRESHOLD_MAX = 50;
    private static final int MAP_SOURCE_DEFAULT = GoogleMapProvider.GOOGLE_MAP_ID.hashCode();

    private static final String PHONE_MODEL_AND_SDK = Build.MODEL + "/" + Build.VERSION.SDK_INT;

    // twitter api keys
    @NonNull private static final String TWITTER_KEY_CONSUMER_PUBLIC = CryptUtils.rot13("ESnsCvAv3kEupF1GCR3jGj");
    @NonNull private static final String TWITTER_KEY_CONSUMER_SECRET = CryptUtils.rot13("7vQWceACV9umEjJucmlpFe9FCMZSeqIqfkQ2BnhV9x");

    private static boolean useCompass = true;

    public enum CoordInputFormatEnum {
        Plain,
        Deg,
        Min,
        Sec;

        static final int DEFAULT_INT_VALUE = Min.ordinal();

        public static CoordInputFormatEnum fromInt(final int id) {
            final CoordInputFormatEnum[] values = CoordInputFormatEnum.values();
            if (id < 0 || id >= values.length) {
                return Min;
            }
            return values[id];
        }
    }

    private static final SharedPreferences sharedPrefs = PreferenceManager
            .getDefaultSharedPreferences(CgeoApplication.getInstance().getBaseContext());
    static {
        migrateSettings();
        Log.setDebug(sharedPrefs.getBoolean(getKey(R.string.pref_debug), false));
    }

    /**
     * Cache the mapsource locally. If that is an offline map source, each request would potentially access the
     * underlying map file, leading to delays.
     */
    private static MapSource mapSource;

    protected Settings() {
        throw new InstantiationError();
    }

    private static void migrateSettings() {
        final int latestPreferencesVersion = 3;
        final int currentVersion = getInt(R.string.pref_settingsversion, 0);

        // No need to migrate if we are up to date.
        if (currentVersion == latestPreferencesVersion) {
            return;
        }

        // No need to migrate if we don't have older settings, defaults will be used instead.
        final String preferencesNameV0 = "cgeo.pref";
        final SharedPreferences prefsV0 = CgeoApplication.getInstance().getSharedPreferences(preferencesNameV0, Context.MODE_PRIVATE);
        if (currentVersion == 0 && prefsV0.getAll().isEmpty()) {
            final Editor e = sharedPrefs.edit();
            e.putInt(getKey(R.string.pref_settingsversion), latestPreferencesVersion);
            e.apply();
            return;
        }

        if (currentVersion < 1) {
            // migrate from non standard file location and integer based boolean types
            final Editor e = sharedPrefs.edit();

            e.putString(getKey(R.string.pref_temp_twitter_token_secret), prefsV0.getString(getKey(R.string.pref_temp_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_temp_twitter_token_public), prefsV0.getString(getKey(R.string.pref_temp_twitter_token_public), null));
            e.putBoolean(getKey(R.string.pref_help_shown), prefsV0.getInt(getKey(R.string.pref_help_shown), 0) != 0);
            e.putFloat(getKey(R.string.pref_anylongitude), prefsV0.getFloat(getKey(R.string.pref_anylongitude), 0));
            e.putFloat(getKey(R.string.pref_anylatitude), prefsV0.getFloat(getKey(R.string.pref_anylatitude), 0));
            e.putBoolean(getKey(R.string.pref_offlinemaps), prefsV0.getInt(getKey(R.string.pref_offlinemaps), 1) != 0);
            e.putBoolean(getKey(R.string.pref_offlinewpmaps), prefsV0.getInt(getKey(R.string.pref_offlinewpmaps), 0) != 0);
            e.putString(getKey(R.string.pref_webDeviceCode), prefsV0.getString(getKey(R.string.pref_webDeviceCode), null));
            e.putString(getKey(R.string.pref_webDeviceName), prefsV0.getString(getKey(R.string.pref_webDeviceName), null));
            e.putBoolean(getKey(R.string.pref_maplive), prefsV0.getInt(getKey(R.string.pref_maplive), 1) != 0);
            e.putInt(getKey(R.string.pref_mapsource), prefsV0.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT));
            e.putBoolean(getKey(R.string.pref_twitter), prefsV0.getInt(getKey(R.string.pref_twitter), 0) != 0);
            e.putBoolean(getKey(R.string.pref_showaddress), prefsV0.getInt(getKey(R.string.pref_showaddress), 1) != 0);
            e.putBoolean(getKey(R.string.pref_maptrail), prefsV0.getInt(getKey(R.string.pref_maptrail), 1) != 0);
            e.putInt(getKey(R.string.pref_lastmapzoom), prefsV0.getInt(getKey(R.string.pref_lastmapzoom), 14));
            e.putBoolean(getKey(R.string.pref_livelist), prefsV0.getInt(getKey(R.string.pref_livelist), 1) != 0);
            e.putBoolean(getKey(R.string.pref_units_imperial), prefsV0.getInt(getKey(R.string.pref_units_imperial), 1) != 1);
            e.putBoolean(getKey(R.string.pref_skin), prefsV0.getInt(getKey(R.string.pref_skin), 0) != 0);
            e.putInt(getKey(R.string.pref_lastusedlist), prefsV0.getInt(getKey(R.string.pref_lastusedlist), StoredList.STANDARD_LIST_ID));
            e.putString(getKey(R.string.pref_cachetype), prefsV0.getString(getKey(R.string.pref_cachetype), CacheType.ALL.id));
            e.putString(getKey(R.string.pref_twitter_token_secret), prefsV0.getString(getKey(R.string.pref_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_twitter_token_public), prefsV0.getString(getKey(R.string.pref_twitter_token_public), null));
            e.putInt(getKey(R.string.pref_version), prefsV0.getInt(getKey(R.string.pref_version), 0));
            e.putBoolean(getKey(R.string.pref_ratingwanted), prefsV0.getBoolean(getKey(R.string.pref_ratingwanted), true));
            e.putBoolean(getKey(R.string.pref_friendlogswanted), prefsV0.getBoolean(getKey(R.string.pref_friendlogswanted), true));
            e.putBoolean(getKey(R.string.pref_useenglish), prefsV0.getBoolean(getKey(R.string.pref_useenglish), false));
            e.putBoolean(getKey(R.string.pref_usecompass), prefsV0.getInt(getKey(R.string.pref_usecompass), 1) != 0);
            e.putBoolean(getKey(R.string.pref_trackautovisit), prefsV0.getBoolean(getKey(R.string.pref_trackautovisit), false));
            e.putBoolean(getKey(R.string.pref_sigautoinsert), prefsV0.getBoolean(getKey(R.string.pref_sigautoinsert), false));
            e.putBoolean(getKey(R.string.pref_logimages), prefsV0.getBoolean(getKey(R.string.pref_logimages), false));
            e.putBoolean(getKey(R.string.pref_excludedisabled), prefsV0.getInt(getKey(R.string.pref_excludedisabled), 0) != 0);
            e.putBoolean(getKey(R.string.pref_excludemine), prefsV0.getInt(getKey(R.string.pref_excludemine), 0) != 0);
            e.putString(getKey(R.string.pref_mapfile), prefsV0.getString(getKey(R.string.pref_mapfile), null));
            e.putString(getKey(R.string.pref_signature), prefsV0.getString(getKey(R.string.pref_signature), null));
            e.putString(getKey(R.string.pref_pass_vote), prefsV0.getString(getKey(R.string.pref_pass_vote), null));
            e.putString(getKey(R.string.pref_password), prefsV0.getString(getKey(R.string.pref_password), null));
            e.putString(getKey(R.string.pref_username), prefsV0.getString(getKey(R.string.pref_username), null));
            e.putString(getKey(R.string.pref_memberstatus), prefsV0.getString(getKey(R.string.pref_memberstatus), ""));
            e.putInt(getKey(R.string.pref_coordinputformat), prefsV0.getInt(getKey(R.string.pref_coordinputformat), CoordInputFormatEnum.DEFAULT_INT_VALUE));
            e.putBoolean(getKey(R.string.pref_log_offline), prefsV0.getBoolean(getKey(R.string.pref_log_offline), false));
            e.putBoolean(getKey(R.string.pref_choose_list), prefsV0.getBoolean(getKey(R.string.pref_choose_list), true));
            e.putBoolean(getKey(R.string.pref_loaddirectionimg), prefsV0.getBoolean(getKey(R.string.pref_loaddirectionimg), true));
            e.putString(getKey(R.string.pref_gccustomdate), prefsV0.getString(getKey(R.string.pref_gccustomdate), GCConstants.DEFAULT_GC_DATE));
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), prefsV0.getInt(getKey(R.string.pref_showwaypointsthreshold), SHOW_WP_THRESHOLD_DEFAULT));
            e.putBoolean(getKey(R.string.pref_opendetailslastpage), prefsV0.getBoolean(getKey(R.string.pref_opendetailslastpage), false));
            e.putInt(getKey(R.string.pref_lastdetailspage), prefsV0.getInt(getKey(R.string.pref_lastdetailspage), 1));
            e.putInt(getKey(R.string.pref_defaultNavigationTool), prefsV0.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id));
            e.putInt(getKey(R.string.pref_defaultNavigationTool2), prefsV0.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id));
            e.putInt(getKey(R.string.pref_livemapstrategy), prefsV0.getInt(getKey(R.string.pref_livemapstrategy), LivemapStrategy.AUTO.id));
            e.putBoolean(getKey(R.string.pref_debug), prefsV0.getBoolean(getKey(R.string.pref_debug), false));
            e.putInt(getKey(R.string.pref_livemaphintshowcount), prefsV0.getInt(getKey(R.string.pref_livemaphintshowcount), 0));

            e.putInt(getKey(R.string.pref_settingsversion), 1); // mark migrated
            e.apply();
        }

        // changes for new settings dialog
        if (currentVersion < 2) {
            final Editor e = sharedPrefs.edit();

            e.putBoolean(getKey(R.string.pref_units_imperial), useImperialUnits());

            // show waypoints threshold now as a slider
            int wpThreshold = getWayPointsThreshold();
            if (wpThreshold < 0) {
                wpThreshold = 0;
            } else if (wpThreshold > SHOW_WP_THRESHOLD_MAX) {
                wpThreshold = SHOW_WP_THRESHOLD_MAX;
            }
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), wpThreshold);

            // KEY_MAP_SOURCE must be string, because it is the key for a ListPreference now
            final int ms = sharedPrefs.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT);
            e.remove(getKey(R.string.pref_mapsource));
            e.putString(getKey(R.string.pref_mapsource), String.valueOf(ms));

            // navigation tool ids must be string, because ListPreference uses strings as keys
            final int dnt1 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id);
            final int dnt2 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id);
            e.remove(getKey(R.string.pref_defaultNavigationTool));
            e.remove(getKey(R.string.pref_defaultNavigationTool2));
            e.putString(getKey(R.string.pref_defaultNavigationTool), String.valueOf(dnt1));
            e.putString(getKey(R.string.pref_defaultNavigationTool2), String.valueOf(dnt2));

            // defaults for gpx directories
            e.putString(getKey(R.string.pref_gpxImportDir), LocalStorage.getDefaultGpxDirectory().getPath());
            e.putString(getKey(R.string.pref_gpxExportDir), LocalStorage.getDefaultGpxDirectory().getPath());

            e.putInt(getKey(R.string.pref_settingsversion), 2); // mark migrated
            e.apply();
        }

        if (currentVersion < 3) {
            final Editor e = sharedPrefs.edit();

            Log.i("Moving field-notes");
            FileUtils.move(LocalStorage.getLegacyFieldNotesDirectory(), LocalStorage.getFieldNotesDirectory());

            Log.i("Moving gpx ex- and import dirs");
            if (getGpxExportDir().equals(LocalStorage.getLegacyGpxDirectory().getPath())) {
                e.putString(getKey(R.string.pref_gpxExportDir), LocalStorage.getDefaultGpxDirectory().getPath());
            }
            if (getGpxImportDir().equals(LocalStorage.getLegacyGpxDirectory().getPath())) {
                e.putString(getKey(R.string.pref_gpxImportDir), LocalStorage.getDefaultGpxDirectory().getPath());
            }
            FileUtils.move(LocalStorage.getLegacyGpxDirectory(), LocalStorage.getDefaultGpxDirectory());

            Log.i("Moving local spoilers");
            FileUtils.move(LocalStorage.getLegacyLocalSpoilersDirectory(), LocalStorage.getLocalSpoilersDirectory());

            Log.i("Moving db files");
            FileUtils.moveTo(new File(LocalStorage.getLegacyExternalCgeoDirectory(), DataStore.DB_FILE_NAME), LocalStorage.getExternalDbDirectory());
            FileUtils.moveTo(new File(LocalStorage.getLegacyExternalCgeoDirectory(), DataStore.DB_FILE_NAME + DataStore.DB_FILE_CORRUPTED_EXTENSION), LocalStorage.getBackupDirectory());
            FileUtils.moveTo(new File(LocalStorage.getLegacyExternalCgeoDirectory(), DataStore.DB_FILE_NAME_BACKUP), LocalStorage.getBackupDirectory());
            FileUtils.moveTo(new File(LocalStorage.getLegacyExternalCgeoDirectory(), DataStore.DB_FILE_NAME_BACKUP + DataStore.DB_FILE_CORRUPTED_EXTENSION), LocalStorage.getBackupDirectory());

            Log.i("Moving geocache data");
            final FileFilter geocacheDirectories = new FileFilter() {
                @Override
                public boolean accept(final File pathname) {
                    final String name = pathname.getName();
                    return pathname.isDirectory() &&
                            (HtmlImage.SHARED.equals(name) || LocalStorage.GEOCACHE_FILE_PATTERN.matcher(name).find());
                }
            };
            final File[] list = LocalStorage.getLegacyExternalCgeoDirectory().listFiles(geocacheDirectories);
            if (list != null) {
                for (final File file : list) {
                    FileUtils.moveTo(file, LocalStorage.getGeocacheDataDirectory());
                }
            }

            Log.i("Deleting legacy .cgeo dir");
            FileUtils.deleteIgnoringFailure(LocalStorage.getLegacyExternalCgeoDirectory());

            e.putString(getKey(R.string.pref_dataDir), LocalStorage.getExternalPrivateCgeoDirectory().getAbsolutePath());
            e.putInt(getKey(R.string.pref_settingsversion), 3); // mark migrated
            e.apply();
        }
    }

    private static String getKey(final int prefKeyId) {
        return CgeoApplication.getInstance().getString(prefKeyId);
    }

    static String getString(final int prefKeyId, final String defaultValue) {
        return sharedPrefs.getString(getKey(prefKeyId), defaultValue);
    }

    private static List<String> getStringList(final int prefKeyId, final String defaultValue) {
        return Arrays.asList(StringUtils.split(getString(prefKeyId, defaultValue), SEPARATOR_CHAR));
    }

    private static int getInt(final int prefKeyId, final int defaultValue) {
        return sharedPrefs.getInt(getKey(prefKeyId), defaultValue);
    }

    private static long getLong(final int prefKeyId, final long defaultValue) {
        return sharedPrefs.getLong(getKey(prefKeyId), defaultValue);
    }

    private static boolean getBoolean(final int prefKeyId, final boolean defaultValue) {
        return sharedPrefs.getBoolean(getKey(prefKeyId), defaultValue);
    }

    private static float getFloat(final int prefKeyId, final float defaultValue) {
        return sharedPrefs.getFloat(getKey(prefKeyId), defaultValue);
    }

    protected static void putString(final int prefKeyId, final String value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putString(getKey(prefKeyId), value);
        edit.apply();
    }

    private static void putStringList(final int prefKeyId, final Iterable<?> elements) {
        putString(prefKeyId, StringUtils.join(elements, SEPARATOR_CHAR));
    }


    protected static void putBoolean(final int prefKeyId, final boolean value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putBoolean(getKey(prefKeyId), value);
        edit.apply();
    }

    private static void putInt(final int prefKeyId, final int value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putInt(getKey(prefKeyId), value);
        edit.apply();
    }

    private static void putLong(final int prefKeyId, final long value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putLong(getKey(prefKeyId), value);
        edit.apply();
    }

    private static void putFloat(final int prefKeyId, final float value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putFloat(getKey(prefKeyId), value);
        edit.apply();
    }

    private static void remove(final int prefKeyId) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.remove(getKey(prefKeyId));
        edit.apply();
    }

    private static boolean contains(final int prefKeyId) {
        return sharedPrefs.contains(getKey(prefKeyId));
    }

    public static boolean hasGCCredentials() {
        return getGcCredentials().isValid();
    }

    /**
     * Get login and password information of Geocaching.com.
     *
     * @return a pair either with (login, password) or (empty, empty) if no valid information is stored
     */
    public static Credentials getGcCredentials() {
        return getCredentials(GCConnector.getInstance());
    }

    /**
     * Get login and password information from preference key id.
     *
     * @param usernamePreferenceKey Username preference key id
     * @param passwordPreferenceKey Password preference key id
     * @return the credential information
     */
    @NonNull
    public static Credentials getCredentials(final int usernamePreferenceKey, final int passwordPreferenceKey) {
        final String username = StringUtils.trim(getString(usernamePreferenceKey, StringUtils.EMPTY));
        final String password = getString(passwordPreferenceKey, StringUtils.EMPTY);
        return new Credentials(username, password);
    }

    /**
     * Get login and password information.
     *
     * @param connector the connector to retrieve the login information from
     * @return the credential information
     */
    @NonNull
    public static Credentials getCredentials(@NonNull final ICredentials connector) {
        return getCredentials(connector.getUsernamePreferenceKey(), connector.getPasswordPreferenceKey());
    }

    /**
     * Set login and password information.
     *
     * @param connector the connector to retrieve the login information from
     * @param credentials the credential information to store
     */
    public static void setCredentials(@NonNull final ICredentials connector, final Credentials credentials) {
        putString(connector.getUsernamePreferenceKey(), credentials.getUsernameRaw());
        putString(connector.getPasswordPreferenceKey(), credentials.getPasswordRaw());
    }

    public static String getUserName() {
        return StringUtils.trim(getString(R.string.pref_username, StringUtils.EMPTY));
    }

    public static boolean isGCConnectorActive() {
        return getBoolean(R.string.pref_connectorGCActive, true);
    }

    public static boolean isECConnectorActive() {
        return getBoolean(R.string.pref_connectorECActive, false);
    }

    public static boolean isSUConnectorActive() {
        return getBoolean(R.string.pref_connectorSUActive, false);
    }

    public static boolean isGCPremiumMember() {
        return getGCMemberStatus().isPremium();
    }

    public static GCMemberState getGCMemberStatus() {
        return GCMemberState.fromString(getString(R.string.pref_memberstatus, ""));
    }

    public static void setGCMemberStatus(final GCMemberState memberStatus) {
        putString(R.string.pref_memberstatus, memberStatus.englishWebsite);
    }

    @NonNull
    public static ImmutablePair<String, String> getTokenPair(final int tokenPublicPrefKey, final int tokenSecretPrefKey) {
        return new ImmutablePair<>(getString(tokenPublicPrefKey, null), getString(tokenSecretPrefKey, null));
    }

    public static void setTokens(final int tokenPublicPrefKey, @Nullable final String tokenPublic, final int tokenSecretPrefKey, @Nullable final String tokenSecret) {
        if (tokenPublic == null) {
            remove(tokenPublicPrefKey);
        } else {
            putString(tokenPublicPrefKey, tokenPublic);
        }
        if (tokenSecret == null) {
            remove(tokenSecretPrefKey);
        } else {
            putString(tokenSecretPrefKey, tokenSecret);
        }
    }

    public static boolean isOCConnectorActive(final int isActivePrefKeyId) {
        return getBoolean(isActivePrefKeyId, false);
    }

    public static boolean hasOCAuthorization(final int tokenPublicPrefKeyId, final int tokenSecretPrefKeyId) {
        return StringUtils.isNotBlank(getString(tokenPublicPrefKeyId, ""))
                && StringUtils.isNotBlank(getString(tokenSecretPrefKeyId, ""));
    }

    public static boolean isGCVoteLoginValid() {
        return getGCVoteLogin().isValid();
    }

    @NonNull
    public static Credentials getGCVoteLogin() {
        final String username = StringUtils.trimToNull(getString(R.string.pref_username, null));
        final String password = getString(R.string.pref_pass_vote, null);
        return new Credentials(username, password);
    }

    @NonNull
    public static String getSignature() {
        return StringUtils.defaultString(getString(R.string.pref_signature, StringUtils.EMPTY));
    }

    public static void setUseGooglePlayServices(final boolean value) {
        putBoolean(R.string.pref_googleplayservices, value);
    }

    public static boolean useGooglePlayServices() {
        if (!GooglePlayServices.isAvailable()) {
            return false;
        }
        return outdatedPhoneModelOrSdk() || getBoolean(R.string.pref_googleplayservices, true);
    }

    public static boolean useLowPowerMode() {
        return getBoolean(R.string.pref_lowpowermode, false);
    }

    /**
     * @param cacheType
     *            The cache type used for future filtering
     */
    public static void setCacheType(final CacheType cacheType) {
        if (cacheType == null) {
            remove(R.string.pref_cachetype);
        } else {
            putString(R.string.pref_cachetype, cacheType.id);
        }
    }

    public static int getLastDisplayedList() {
        return getInt(R.string.pref_lastusedlist, StoredList.STANDARD_LIST_ID);
    }

    /**
     * remember the last displayed cache list
     */
    public static void setLastDisplayedList(final int listId) {
        putInt(R.string.pref_lastusedlist, listId);
    }

    public static Set<Integer> getLastSelectedLists() {
        final Set<Integer> lastSelectedLists = new HashSet<>();
        for (final String lastSelectedListString : getStringList(R.string.pref_last_selected_lists, StringUtils.EMPTY)) {
            try {
                lastSelectedLists.add(Integer.valueOf(lastSelectedListString));
            } catch (final NumberFormatException ignored) { }
        }
        return lastSelectedLists;
    }

    /**
     * remember the last selection in the dialog that assigns a cache to certain lists
     */
    public static void setLastSelectedLists(final Set<Integer> lastSelectedLists) {
        putStringList(R.string.pref_last_selected_lists, lastSelectedLists);
    }

    public static void setWebNameCode(final String name, final String code) {
        putString(R.string.pref_webDeviceName, name);
        putString(R.string.pref_webDeviceCode, code);
    }

    public static MapProvider getMapProvider() {
        return getMapSource().getMapProvider();
    }

    public static String getMapFile() {
        return getString(R.string.pref_mapfile, null);
    }

    static void setMapFile(final String mapFile) {
        putString(R.string.pref_mapfile, mapFile);
        if (mapFile != null) {
            setMapFileDirectory(new File(mapFile).getParent());
        }
    }

    public static String getMapFileDirectory() {
        final String mapDir = getString(R.string.pref_mapDirectory, null);
        if (mapDir != null) {
            return mapDir;
        }
        final String mapFile = getMapFile();
        if (mapFile != null) {
            return new File(mapFile).getParent();
        }
        return null;
    }

    static void setMapFileDirectory(final String mapFileDirectory) {
        putString(R.string.pref_mapDirectory, mapFileDirectory);
        MapsforgeMapProvider.getInstance().updateOfflineMaps();
    }

    private static boolean isValidMapFile() {
        return isValidMapFile(getMapFile());
    }

    public static boolean isValidMapFile(final String mapFileIn) {
        return MapsforgeMapProvider.isValidMapFile(mapFileIn);
    }

    public static boolean isScaleMapsforgeText() {
        return getBoolean(R.string.pref_mapsforge_scale_text, true);
    }

    public static CoordInputFormatEnum getCoordInputFormat() {
        return CoordInputFormatEnum.fromInt(getInt(R.string.pref_coordinputformat, CoordInputFormatEnum.DEFAULT_INT_VALUE));
    }

    public static void setCoordInputFormat(final CoordInputFormatEnum format) {
        putInt(R.string.pref_coordinputformat, format.ordinal());
    }

    public static boolean getLogOffline() {
        return getBoolean(R.string.pref_log_offline, false);
    }

    public static boolean getChooseList() {
        return getBoolean(R.string.pref_choose_list, false);
    }

    public static boolean getLoadDirImg() {
        return !isGCPremiumMember() && getBoolean(R.string.pref_loaddirectionimg, true);
    }

    public static void setGcCustomDate(final String format) {
        putString(R.string.pref_gccustomdate, format);
    }

    /**
     * @return User selected date format on GC.com
     */
    public static String getGcCustomDate() {
        // We might have some users whose stored value is null, which is invalid. In this case, we use the default.
        return StringUtils.defaultString(getString(R.string.pref_gccustomdate, GCConstants.DEFAULT_GC_DATE),
                GCConstants.DEFAULT_GC_DATE);
    }

    public static boolean isExcludeMyCaches() {
        return getBoolean(R.string.pref_excludemine, false);
    }

    public static boolean useEnglish() {
        return getBoolean(R.string.pref_useenglish, false);
    }

    public static void setUseEnglish(final boolean useEnglish) {
        putBoolean(R.string.pref_useenglish, useEnglish);
    }

    public static boolean isShowAddress() {
        return getBoolean(R.string.pref_showaddress, true);
    }

    public static boolean isExcludeDisabledCaches() {
        return getBoolean(R.string.pref_excludedisabled, false);
    }

    public static boolean isStoreOfflineMaps() {
        return getBoolean(R.string.pref_offlinemaps, true);
    }

    public static boolean isStoreOfflineWpMaps() {
        return getBoolean(R.string.pref_offlinewpmaps, false);
    }

    public static boolean isStoreLogImages() {
        return getBoolean(R.string.pref_logimages, false);
    }

    public static boolean isRatingWanted() {
        return getBoolean(R.string.pref_ratingwanted, true);
    }

    public static boolean isGeokretyConnectorActive() {
        return getBoolean(R.string.pref_connectorGeokretyActive, false);
    }

    public static boolean isGeokretyCacheActive() {
        return getBoolean(R.string.pref_geokrety_cache, true);
    }

    static boolean hasGeokretyAuthorization() {
        return StringUtils.isNotBlank(getGeokretySecId());
    }

    public static String getGeokretySecId() {
        return getString(R.string.pref_fakekey_geokrety_authorization, null);
    }

    public static void setGeokretySecId(final String secid) {
        putString(R.string.pref_fakekey_geokrety_authorization, secid);
    }

    public static String getTokenSecret(final int prefKeyId) {
        return getString(prefKeyId, StringUtils.EMPTY);
    }

    public static void setTokenSecret(final int prefKeyId, final String secretToken) {
        putString(prefKeyId, secretToken);
    }

    public static boolean isRegisteredForGeokretyLogging() {
        return getGeokretySecId() != null;
    }

    /**
     * Retrieve showed popup counter for warning about logging Trackable recommend Geocode
     *
     * @return number of times the popup has appeared
     */
    public static int getLogTrackableWithoutGeocodeShowCount() {
        return getInt(R.string.pref_logtrackablewithoutgeocodeshowcount, 0);
    }

    /**
     * Store showed popup counter for warning about logging Trackable recommend Geocode
     *
     * @param showCount the count to save
     */
    public static void setLogTrackableWithoutGeocodeShowCount(final int showCount) {
        putInt(R.string.pref_logtrackablewithoutgeocodeshowcount, showCount);
    }

    public static boolean isFriendLogsWanted() {
        if (!hasGCCredentials()) {
            // don't show a friends log if the user is anonymous
            return false;
        }
        return getBoolean(R.string.pref_friendlogswanted, true);
    }

    public static boolean isLiveList() {
        return getBoolean(R.string.pref_livelist, true);
    }

    public static boolean isTrackableAutoVisit() {
        return getBoolean(R.string.pref_trackautovisit, false);
    }

    public static boolean isAutoInsertSignature() {
        return getBoolean(R.string.pref_sigautoinsert, false);
    }

    static void setUseImperialUnits(final boolean useImperialUnits) {
        putBoolean(R.string.pref_units_imperial, useImperialUnits);
    }

    public static boolean useImperialUnits() {
        return getBoolean(R.string.pref_units_imperial, useImperialUnitsByDefault());
    }

    private static boolean useImperialUnitsByDefault() {
        final String countryCode = Locale.getDefault().getCountry();
        return "US".equals(countryCode)  // USA
            || "LR".equals(countryCode)  // Liberia
            || "MM".equals(countryCode); // Burma
    }

    public static boolean isLiveMap() {
        return getBoolean(R.string.pref_maplive, true);
    }

    public static void setLiveMap(final boolean live) {
        putBoolean(R.string.pref_maplive, live);
    }

    public static boolean isMapTrail() {
        return getBoolean(R.string.pref_maptrail, false);
    }

    public static void setMapTrail(final boolean showTrail) {
        putBoolean(R.string.pref_maptrail, showTrail);
    }

    /**
     * whether to show a direction line on the map
     */
    public static boolean isMapDirection() {
        return getBoolean(R.string.pref_map_direction, true);
    }

    public static void setMapDirection(final boolean showDirection) {
        putBoolean(R.string.pref_map_direction, showDirection);
    }

    /**
     * Get last used zoom of the internal map. Differentiate between two use cases for a map of multiple caches (e.g.
     * live map) and the map of a single cache (which is often zoomed in more deep).
     */
    public static int getMapZoom(final MapMode mapMode) {
        if (mapMode == MapMode.SINGLE || mapMode == MapMode.COORDS) {
            return getCacheZoom();
        }
        return getMapZoom();
    }

    public static void setMapZoom(final MapMode mapMode, final int zoomLevel) {
        if (mapMode == MapMode.SINGLE || mapMode == MapMode.COORDS) {
            setCacheZoom(zoomLevel);
        } else {
            setMapZoom(zoomLevel);
        }
    }

    /**
     * @return zoom used for the (live) map
     */
    private static int getMapZoom() {
        return Math.max(getInt(R.string.pref_lastmapzoom, 14), INITIAL_MAP_ZOOM_LIMIT);
    }

    private static void setMapZoom(final int mapZoomLevel) {
        putInt(R.string.pref_lastmapzoom, mapZoomLevel);
    }

    /**
     * @return zoom used for the map of a single cache
     */
    private static int getCacheZoom() {
        return Math.max(getInt(R.string.pref_cache_zoom, 14), INITIAL_MAP_ZOOM_LIMIT);
    }

    private static void setCacheZoom(final int zoomLevel) {
        putInt(R.string.pref_cache_zoom, zoomLevel);
    }

    public static GeoPointImpl getMapCenter() {
        return getMapProvider().getMapItemFactory()
                .getGeoPointBase(new Geopoint(getInt(R.string.pref_lastmaplat, 0) / 1e6,
                        getInt(R.string.pref_lastmaplon, 0) / 1e6));
    }

    public static void setMapCenter(final GeoPointImpl mapViewCenter) {
        putInt(R.string.pref_lastmaplat, mapViewCenter.getLatitudeE6());
        putInt(R.string.pref_lastmaplon, mapViewCenter.getLongitudeE6());
    }

    @NonNull
    public static synchronized MapSource getMapSource() {
        if (mapSource != null) {
            return mapSource;
        }
        final int id = getConvertedMapId();
        mapSource = MapProviderFactory.getMapSource(id);
        if (mapSource != null) {
            // don't use offline maps if the map file is not valid
            if (!(mapSource instanceof OfflineMapSource) || isValidMapFile()) {
                return mapSource;
            }
        }
        // fallback to first available map
        return MapProviderFactory.getDefaultSource();
    }

    private static final int GOOGLEMAP_BASEID = 30;
    private static final int MAP = 1;
    private static final int SATELLITE = 2;

    private static final int MFMAP_BASEID = 40;
    private static final int MAPNIK = 1;
    private static final int CYCLEMAP = 3;
    private static final int OFFLINE = 4;
    private static final int HISTORY_SIZE = 10;

    /**
     * Convert old preference ids for maps (based on constant values) into new hash based ids.
     */
    private static int getConvertedMapId() {
        final int id = Integer.parseInt(getString(R.string.pref_mapsource,
                String.valueOf(MAP_SOURCE_DEFAULT)));
        switch (id) {
            case GOOGLEMAP_BASEID + MAP:
                return GoogleMapProvider.GOOGLE_MAP_ID.hashCode();
            case GOOGLEMAP_BASEID + SATELLITE:
                return GoogleMapProvider.GOOGLE_SATELLITE_ID.hashCode();
            case MFMAP_BASEID + MAPNIK:
                return MapsforgeMapProvider.MAPSFORGE_MAPNIK_ID.hashCode();
            case MFMAP_BASEID + CYCLEMAP:
                return MapsforgeMapProvider.MAPSFORGE_CYCLEMAP_ID.hashCode();
            case MFMAP_BASEID + OFFLINE: {
                final String mapFile = getMapFile();
                if (StringUtils.isNotEmpty(mapFile)) {
                    return mapFile.hashCode();
                }
                break;
            }
            default:
                break;
        }
        return id;
    }

    public static synchronized void setMapSource(final MapSource newMapSource) {
        putString(R.string.pref_mapsource, String.valueOf(newMapSource.getNumericalId()));
        if (newMapSource instanceof OfflineMapSource) {
            setMapFile(((OfflineMapSource) newMapSource).getFileName());
        }
        // cache the value
        mapSource = newMapSource;
    }

    public static void setAnyCoordinates(final Geopoint coords) {
        if (coords != null) {
            putFloat(R.string.pref_anylatitude, (float) coords.getLatitude());
            putFloat(R.string.pref_anylongitude, (float) coords.getLongitude());
        } else {
            remove(R.string.pref_anylatitude);
            remove(R.string.pref_anylongitude);
        }
    }

    public static Geopoint getAnyCoordinates() {
        if (contains(R.string.pref_anylatitude) && contains(R.string.pref_anylongitude)) {
            final float lat = getFloat(R.string.pref_anylatitude, 0);
            final float lon = getFloat(R.string.pref_anylongitude, 0);
            return new Geopoint(lat, lon);
        }
        return null;
    }

    public static boolean isUseCompass() {
        return useCompass;
    }

    public static void setUseCompass(final boolean value) {
        useCompass = value;
    }

    public static boolean isLightSkin() {
        return getBoolean(R.string.pref_skin, false);
    }

    @NonNull
    public static String getTwitterKeyConsumerPublic() {
        return TWITTER_KEY_CONSUMER_PUBLIC;
    }

    @NonNull
    public static String getTwitterKeyConsumerSecret() {
        return TWITTER_KEY_CONSUMER_SECRET;
    }

    public static String getWebDeviceCode() {
        return getString(R.string.pref_webDeviceCode, null);
    }

    public static boolean isRegisteredForSend2cgeo() {
        return getWebDeviceCode() != null;
    }

    static String getWebDeviceName() {
        return getString(R.string.pref_webDeviceName, Build.MODEL);
    }

    /**
     * @return The cache type used for filtering or ALL if no filter is active.
     *         Returns never null
     */
    @NonNull
    public static CacheType getCacheType() {
        return CacheType.getById(getString(R.string.pref_cachetype, CacheType.ALL.id));
    }

    /**
     * The Threshold for the showing of child waypoints
     */
    public static int getWayPointsThreshold() {
        return getInt(R.string.pref_showwaypointsthreshold, SHOW_WP_THRESHOLD_DEFAULT);
    }

    static void setShowWaypointsThreshold(final int threshold) {
        putInt(R.string.pref_showwaypointsthreshold, threshold);
    }

    public static boolean isUseTwitter() {
        return getBoolean(R.string.pref_twitter, false);
    }

    private static void setUseTwitter(final boolean useTwitter) {
        putBoolean(R.string.pref_twitter, useTwitter);
    }

    public static boolean isTwitterLoginValid() {
        return !StringUtils.isBlank(getTokenPublic())
                && !StringUtils.isBlank(getTokenSecret());
    }

    public static String getTokenPublic() {
        return getString(R.string.pref_twitter_token_public, null);
    }

    public static String getTokenSecret() {
        return getString(R.string.pref_twitter_token_secret, null);

    }

    static boolean hasTwitterAuthorization() {
        return StringUtils.isNotBlank(getTokenPublic())
                && StringUtils.isNotBlank(getTokenSecret());
    }

    public static void setTwitterTokens(@Nullable final String tokenPublic,
            @Nullable final String tokenSecret, final boolean enableTwitter) {
        putString(R.string.pref_twitter_token_public, tokenPublic);
        putString(R.string.pref_twitter_token_secret, tokenSecret);
        if (tokenPublic != null) {
            remove(R.string.pref_temp_twitter_token_public);
            remove(R.string.pref_temp_twitter_token_secret);
        }
        setUseTwitter(enableTwitter);
    }

    public static void setTwitterTempTokens(@Nullable final String tokenPublic,
            @Nullable final String tokenSecret) {
        putString(R.string.pref_temp_twitter_token_public, tokenPublic);
        putString(R.string.pref_temp_twitter_token_secret, tokenSecret);
    }

    @NonNull
    public static ImmutablePair<String, String> getTempToken() {
        final String tokenPublic = getString(R.string.pref_temp_twitter_token_public, null);
        final String tokenSecret = getString(R.string.pref_temp_twitter_token_secret, null);
        return new ImmutablePair<>(tokenPublic, tokenSecret);
    }

    public static int getVersion() {
        return getInt(R.string.pref_version, 0);
    }

    public static void setVersion(final int version) {
        putInt(R.string.pref_version, version);
    }

    public static boolean isOpenLastDetailsPage() {
        return getBoolean(R.string.pref_opendetailslastpage, false);
    }

    public static int getLastDetailsPage() {
        return getInt(R.string.pref_lastdetailspage, 1);
    }

    public static void setLastDetailsPage(final int index) {
        putInt(R.string.pref_lastdetailspage, index);
    }

    public static int getDefaultNavigationTool() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool,
                String.valueOf(NavigationAppsEnum.COMPASS.id)));
    }

    public static int getDefaultNavigationTool2() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool2,
                String.valueOf(NavigationAppsEnum.INTERNAL_MAP.id)));
    }

    @NonNull
    public static LivemapStrategy getLiveMapStrategy() {
        return LivemapStrategy.getById(getInt(R.string.pref_livemapstrategy, LivemapStrategy.AUTO.id));
    }

    public static void setLiveMapStrategy(final LivemapStrategy strategy) {
        putInt(R.string.pref_livemapstrategy, strategy.id);
    }

    public static boolean isDebug() {
        return Log.isDebug();
    }

    public static int getLiveMapHintShowCount() {
        return getInt(R.string.pref_livemaphintshowcount, 0);
    }

    public static void setLiveMapHintShowCount(final int showCount) {
        putInt(R.string.pref_livemaphintshowcount, showCount);
    }

    public static boolean isDbOnSDCard() {
        return getBoolean(R.string.pref_dbonsdcard, false);
    }

    public static void setDbOnSDCard(final boolean dbOnSDCard) {
        putBoolean(R.string.pref_dbonsdcard, dbOnSDCard);
    }

    public static String getGpxExportDir() {
        return getString(R.string.pref_gpxExportDir,
                LocalStorage.getDefaultGpxDirectory().getPath());
    }

    public static String getGpxImportDir() {
        return getString(R.string.pref_gpxImportDir,
                LocalStorage.getDefaultGpxDirectory().getPath());
    }

    public static String getExternalPrivateCgeoDirectory() {
        return getString(R.string.pref_dataDir, null);
    }

    public static void setExternalPrivateCgeoDirectory(final String extDir) {
        putString(R.string.pref_dataDir, extDir);
    }

    public static boolean getShareAfterExport() {
        return getBoolean(R.string.pref_shareafterexport, true);
    }

    public static void setShareAfterExport(final boolean shareAfterExport) {
        putBoolean(R.string.pref_shareafterexport, shareAfterExport);
    }
    public static boolean getIncludeFoundStatus() {
        return getBoolean(R.string.pref_includefoundstatus, true);
    }

    public static void setIncludeFoundStatus(final boolean includeFoundStatus) {
        putBoolean(R.string.pref_includefoundstatus, includeFoundStatus);
    }
    /**
     * Get Trackable inventory sort method based on the last Trackable inventory sort method.
     *
     * @return
     *          The Trackable Sort Method position previously used.
     */
    public static int getTrackableInventorySortMethod() {
        return getInt(R.string.pref_trackable_inventory_sort, 0);
    }

    /**
     * Set Trackable inventory sort method.
     *
     * @param trackableSortMethod
     *          The Trackable Sort Method to remember
     */
    public static void setTrackableInventorySortMethod(final int trackableSortMethod) {
        putInt(R.string.pref_trackable_inventory_sort, trackableSortMethod);
    }
    /**
     * Obtain Trackable action from the last Trackable log.
     *
     * @return
     *          The last Trackable Action or RETRIEVED_IT
     */
    public static int getTrackableAction() {
        return getInt(R.string.pref_trackableaction, LogTypeTrackable.RETRIEVED_IT.id);
    }

    /**
     * Save Trackable action from the last Trackable log.
     *
     * @param trackableAction
     *          The Trackable Action to remember
     */
    public static void setTrackableAction(final int trackableAction) {
        putInt(R.string.pref_trackableaction, trackableAction);
    }

    private static String getCustomRenderThemeBaseFolder() {
        return getString(R.string.pref_renderthemepath, "");
    }

    public static String getCustomRenderThemeFilePath() {
        return getString(R.string.pref_renderthemefile, "");
    }

    public static void setCustomRenderThemeFile(final String customRenderThemeFile) {
        putString(R.string.pref_renderthemefile, customRenderThemeFile);
    }

    public static File[] getMapThemeFiles() {
        final File directory = new File(getCustomRenderThemeBaseFolder());
        final List<File> result = new ArrayList<>();
        FileUtils.listDir(result, directory, new ExtensionsBasedFileSelector(new String[] { "xml" }), null);

        return result.toArray(new File[result.size()]);
    }

    private static class ExtensionsBasedFileSelector implements FileSelector {
        private final String[] extensions;

        ExtensionsBasedFileSelector(final String[] extensions) {
            this.extensions = extensions;
        }

        @Override
        public boolean isSelected(final File file) {
            final String filename = file.getName();
            for (final String ext : extensions) {
                if (StringUtils.endsWithIgnoreCase(filename, ext)) {
                    return true;
                }
            }
            return false;
        }

        @Override
        public boolean shouldEnd() {
            return false;
        }
    }

    /**
     * @return true if plain text log wanted
     */
    public static boolean getPlainLogs() {
        return getBoolean(R.string.pref_plainLogs, false);
    }

    /**
     * Force set the plain text log preference
     *
     * @param plainLogs
     *            wanted or not
     */
    public static void setPlainLogs(final boolean plainLogs) {
        putBoolean(R.string.pref_plainLogs, plainLogs);
    }

    public static boolean getUseNativeUa() {
        return getBoolean(R.string.pref_nativeUa, false);
    }

    @NonNull
    public static String getCacheTwitterMessage() {
        return StringUtils.defaultString(getString(R.string.pref_twitter_cache_message, "I found [NAME] ([URL])."));
    }

    @NonNull
    public static String getTrackableTwitterMessage() {
        return StringUtils.defaultString(getString(R.string.pref_twitter_trackable_message, "I touched [NAME] ([URL])."));
    }

    public static int getLogImageScale() {
        return getInt(R.string.pref_logImageScale, -1);
    }

    public static void setLogImageScale(final int scale) {
        putInt(R.string.pref_logImageScale, scale);
    }

    public static void setExcludeMine(final boolean exclude) {
        putBoolean(R.string.pref_excludemine, exclude);
    }

    public static void setExcludeDisabled(final boolean exclude) {
        putBoolean(R.string.pref_excludedisabled, exclude);
    }

    static void setLogin(final String username, final String password) {
        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            // erase username and password
            remove(R.string.pref_username);
            remove(R.string.pref_password);
            return;
        }
        // save username and password
        putString(R.string.pref_username, StringUtils.trim(username));
        putString(R.string.pref_password, password);
    }

    public static long getFieldnoteExportDate() {
        return getLong(R.string.pref_fieldNoteExportDate, 0);
    }

    /**
     * Remember date of last field note export.
     */
    public static void setFieldnoteExportDate(final long date) {
        putLong(R.string.pref_fieldNoteExportDate, date);
    }

    public static boolean isUseNavigationApp(final NavigationAppsEnum navApp) {
        return getBoolean(navApp.preferenceKey, true);
    }

    /**
     * Remember the state of the "Upload" checkbox in the field notes export dialog.
     */
    public static void setFieldNoteExportUpload(final boolean upload) {
        putBoolean(R.string.pref_fieldNoteExportUpload, upload);
    }

    public static boolean getFieldNoteExportUpload() {
        return getBoolean(R.string.pref_fieldNoteExportUpload, true);
    }

    /**
     * Remember the state of the "Only new" checkbox in the field notes export dialog.
     */
    public static void setFieldNoteExportOnlyNew(final boolean onlyNew) {
        putBoolean(R.string.pref_fieldNoteExportOnlyNew, onlyNew);
    }

    public static boolean getFieldNoteExportOnlyNew() {
        return getBoolean(R.string.pref_fieldNoteExportOnlyNew, false);
    }

    public static String getECIconSet() {
        return getString(R.string.pref_ec_icons, "1");
    }

    /* Store last checksum of changelog for changelog display */
    public static long getLastChangelogChecksum() {
        return getLong(R.string.pref_changelog_last_checksum, 0);
    }

    public static void setLastChangelogChecksum(final long checksum) {
        putLong(R.string.pref_changelog_last_checksum, checksum);
    }

    public static List<String> getLastOpenedCaches() {
        final List<String> history = getStringList(R.string.pref_caches_history, StringUtils.EMPTY);
        return history.subList(0, Math.min(HISTORY_SIZE, history.size()));
    }

    public static void addCacheToHistory(@NonNull final String geocode) {
        final List<String> history = new ArrayList<>(getLastOpenedCaches());
        // bring entry to front, if it already existed
        history.remove(geocode);
        history.add(0, geocode);
        putStringList(R.string.pref_caches_history, history);
    }

    public static boolean useNewMapAsDefault() {
        return getBoolean(R.string.pref_new_map_as_default, false);
    }

    static void setUseNewMapAsDefault(final boolean useNewMapAsDefault) {
        putBoolean(R.string.pref_new_map_as_default, useNewMapAsDefault);
    }

    public static boolean useHardwareAcceleration() {
        return outdatedPhoneModelOrSdk() ? HwAccel.hwAccelShouldBeEnabled() :
                getBoolean(R.string.pref_hardware_acceleration, HwAccel.hwAccelShouldBeEnabled());
    }

    static void setUseHardwareAcceleration(final boolean useHardwareAcceleration) {
        putBoolean(R.string.pref_hardware_acceleration, useHardwareAcceleration);
        storePhoneModelAndSdk();
    }

    private static boolean outdatedPhoneModelOrSdk() {
        return !StringUtils.equals(PHONE_MODEL_AND_SDK, getString(R.string.pref_phone_model_and_sdk, null));
    }

    private static void storePhoneModelAndSdk() {
        putString(R.string.pref_phone_model_and_sdk, PHONE_MODEL_AND_SDK);
    }

    public static String getLastCacheLog() {
        return getString(R.string.pref_last_cache_log, StringUtils.EMPTY);
    }

    public static void setLastCacheLog(final String log) {
        putString(R.string.pref_last_cache_log, log);
    }

    public static String getLastTrackableLog() {
        return getString(R.string.pref_last_trackable_log, StringUtils.EMPTY);
    }

    public static void setLastTrackableLog(final String log) {
        putString(R.string.pref_last_trackable_log, log);
    }

    @Nullable
    public static String getHomeLocation() {
        return getString(R.string.pref_home_location, null);
    }

    public static void setHomeLocation(@NonNull final String homeLocation) {
        putString(R.string.pref_home_location, homeLocation);
    }

    public static void setForceOrientationSensor(final boolean forceOrientationSensor) {
        putBoolean(R.string.pref_force_orientation_sensor, forceOrientationSensor);
    }

    public static boolean useOrientationSensor(final Context context) {
        return OrientationProvider.hasOrientationSensor(context) &&
                (getBoolean(R.string.pref_force_orientation_sensor, false) ||
                    !(RotationProvider.hasRotationSensor(context) || MagnetometerAndAccelerometerProvider.hasMagnetometerAndAccelerometerSensors(context))
                );
    }

    /**
     * Get avatar URL by connector.
     *
     * @param connector the connector to retrieve the avatar information from
     * @return the avatar url
     */
    @NonNull
    public static String getAvatarUrl(@NonNull final ICredentials connector) {
        return getString(connector.getAvatarPreferenceKey(), null);
    }

    /**
     * Set avatar URL by connector.
     *
     * @param connector the connector to retrieve the avatar information from
     * @param avatarUrl the avatar url information to store
     */
    public static void setAvatarUrl(@NonNull final ICredentials connector, final String avatarUrl) {
        putString(connector.getAvatarPreferenceKey(), avatarUrl);
    }

    /**
     * Return the locale that should be used to display information to the user.
     *
     * @return either the system locale or an English one, depending on the settings
     */
    public static Locale getApplicationLocale() {
        return Settings.useEnglish() ? Locale.ENGLISH : Locale.getDefault();
    }

    public static void setRoutingMode(@NonNull final RoutingMode mode) {
        putString(R.string.pref_map_routing, mode.parameterValue);
        Routing.invalidateRouting();
    }

    public static RoutingMode getRoutingMode() {
        return RoutingMode.fromString(getString(R.string.pref_map_routing, "foot"));
    }

}
!@#$%
20190527_013756,C:\Users\Alice Borner\Desktop\projects\cgeo\git\.merge_file_c12788
package cgeo.geocaching.settings;

import cgeo.geocaching.CgeoApplication;
import cgeo.geocaching.R;
import cgeo.geocaching.apps.navi.NavigationAppFactory.NavigationAppsEnum;
import cgeo.geocaching.connector.capability.ICredentials;
import cgeo.geocaching.connector.gc.GCConnector;
import cgeo.geocaching.connector.gc.GCConstants;
import cgeo.geocaching.connector.gc.GCMemberState;
import cgeo.geocaching.enumerations.CacheType;
import cgeo.geocaching.list.StoredList;
import cgeo.geocaching.location.Geopoint;
import cgeo.geocaching.log.LogTypeTrackable;
import cgeo.geocaching.maps.LivemapStrategy;
import cgeo.geocaching.maps.MapMode;
import cgeo.geocaching.maps.MapProviderFactory;
import cgeo.geocaching.maps.google.v1.GoogleMapProvider;
import cgeo.geocaching.maps.interfaces.GeoPointImpl;
import cgeo.geocaching.maps.interfaces.MapProvider;
import cgeo.geocaching.maps.interfaces.MapSource;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider;
import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider.OfflineMapSource;
import cgeo.geocaching.maps.routing.Routing;
import cgeo.geocaching.maps.routing.RoutingMode;
import cgeo.geocaching.network.HtmlImage;
import cgeo.geocaching.playservices.GooglePlayServices;
import cgeo.geocaching.sensors.MagnetometerAndAccelerometerProvider;
import cgeo.geocaching.sensors.OrientationProvider;
import cgeo.geocaching.sensors.RotationProvider;
import cgeo.geocaching.storage.DataStore;
import cgeo.geocaching.storage.LocalStorage;
import cgeo.geocaching.utils.CryptUtils;
import cgeo.geocaching.utils.FileUtils;
import cgeo.geocaching.utils.FileUtils.FileSelector;
import cgeo.geocaching.utils.Log;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.os.Build;
import android.preference.PreferenceManager;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;

import java.io.File;
import java.io.FileFilter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Set;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;

/**
 * General c:geo preferences/settings set by the user
 */
public class Settings {

    /**
     * On opening a map, we limit the _initial_ zoom. The user can still zoom out afterwards.
     */
    private static final int INITIAL_MAP_ZOOM_LIMIT = 16;

    /**
     * Separator char for preferences with multiple elements.
     */
    private static final char SEPARATOR_CHAR = ',';

    private static final int SHOW_WP_THRESHOLD_DEFAULT = 10;
    public static final int SHOW_WP_THRESHOLD_MAX = 50;
    private static final int MAP_SOURCE_DEFAULT = GoogleMapProvider.GOOGLE_MAP_ID.hashCode();

    private static final String PHONE_MODEL_AND_SDK = Build.MODEL + "/" + Build.VERSION.SDK_INT;

    // twitter api keys
    @NonNull private static final String TWITTER_KEY_CONSUMER_PUBLIC = CryptUtils.rot13("ESnsCvAv3kEupF1GCR3jGj");
    @NonNull private static final String TWITTER_KEY_CONSUMER_SECRET = CryptUtils.rot13("7vQWceACV9umEjJucmlpFe9FCMZSeqIqfkQ2BnhV9x");

    private static boolean useCompass = true;

    public enum CoordInputFormatEnum {
        Plain,
        Deg,
        Min,
        Sec;

        static final int DEFAULT_INT_VALUE = Min.ordinal();

        public static CoordInputFormatEnum fromInt(final int id) {
            final CoordInputFormatEnum[] values = CoordInputFormatEnum.values();
            if (id < 0 || id >= values.length) {
                return Min;
            }
            return values[id];
        }
    }

    private static final SharedPreferences sharedPrefs = PreferenceManager
            .getDefaultSharedPreferences(CgeoApplication.getInstance().getBaseContext());
    static {
        migrateSettings();
        Log.setDebug(sharedPrefs.getBoolean(getKey(R.string.pref_debug), false));
    }

    /**
     * Cache the mapsource locally. If that is an offline map source, each request would potentially access the
     * underlying map file, leading to delays.
     */
    private static MapSource mapSource;

    protected Settings() {
        throw new InstantiationError();
    }

    private static void migrateSettings() {
        final int latestPreferencesVersion = 3;
        final int currentVersion = getInt(R.string.pref_settingsversion, 0);

        // No need to migrate if we are up to date.
        if (currentVersion == latestPreferencesVersion) {
            return;
        }

        // No need to migrate if we don't have older settings, defaults will be used instead.
        final String preferencesNameV0 = "cgeo.pref";
        final SharedPreferences prefsV0 = CgeoApplication.getInstance().getSharedPreferences(preferencesNameV0, Context.MODE_PRIVATE);
        if (currentVersion == 0 && prefsV0.getAll().isEmpty()) {
            final Editor e = sharedPrefs.edit();
            e.putInt(getKey(R.string.pref_settingsversion), latestPreferencesVersion);
            e.apply();
            return;
        }

        if (currentVersion < 1) {
            // migrate from non standard file location and integer based boolean types
            final Editor e = sharedPrefs.edit();

            e.putString(getKey(R.string.pref_temp_twitter_token_secret), prefsV0.getString(getKey(R.string.pref_temp_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_temp_twitter_token_public), prefsV0.getString(getKey(R.string.pref_temp_twitter_token_public), null));
            e.putBoolean(getKey(R.string.pref_help_shown), prefsV0.getInt(getKey(R.string.pref_help_shown), 0) != 0);
            e.putFloat(getKey(R.string.pref_anylongitude), prefsV0.getFloat(getKey(R.string.pref_anylongitude), 0));
            e.putFloat(getKey(R.string.pref_anylatitude), prefsV0.getFloat(getKey(R.string.pref_anylatitude), 0));
            e.putBoolean(getKey(R.string.pref_offlinemaps), prefsV0.getInt(getKey(R.string.pref_offlinemaps), 1) != 0);
            e.putBoolean(getKey(R.string.pref_offlinewpmaps), prefsV0.getInt(getKey(R.string.pref_offlinewpmaps), 0) != 0);
            e.putString(getKey(R.string.pref_webDeviceCode), prefsV0.getString(getKey(R.string.pref_webDeviceCode), null));
            e.putString(getKey(R.string.pref_webDeviceName), prefsV0.getString(getKey(R.string.pref_webDeviceName), null));
            e.putBoolean(getKey(R.string.pref_maplive), prefsV0.getInt(getKey(R.string.pref_maplive), 1) != 0);
            e.putInt(getKey(R.string.pref_mapsource), prefsV0.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT));
            e.putBoolean(getKey(R.string.pref_twitter), prefsV0.getInt(getKey(R.string.pref_twitter), 0) != 0);
            e.putBoolean(getKey(R.string.pref_showaddress), prefsV0.getInt(getKey(R.string.pref_showaddress), 1) != 0);
            e.putBoolean(getKey(R.string.pref_maptrail), prefsV0.getInt(getKey(R.string.pref_maptrail), 1) != 0);
            e.putInt(getKey(R.string.pref_lastmapzoom), prefsV0.getInt(getKey(R.string.pref_lastmapzoom), 14));
            e.putBoolean(getKey(R.string.pref_livelist), prefsV0.getInt(getKey(R.string.pref_livelist), 1) != 0);
            e.putBoolean(getKey(R.string.pref_units_imperial), prefsV0.getInt(getKey(R.string.pref_units_imperial), 1) != 1);
            e.putBoolean(getKey(R.string.pref_skin), prefsV0.getInt(getKey(R.string.pref_skin), 0) != 0);
            e.putInt(getKey(R.string.pref_lastusedlist), prefsV0.getInt(getKey(R.string.pref_lastusedlist), StoredList.STANDARD_LIST_ID));
            e.putString(getKey(R.string.pref_cachetype), prefsV0.getString(getKey(R.string.pref_cachetype), CacheType.ALL.id));
            e.putString(getKey(R.string.pref_twitter_token_secret), prefsV0.getString(getKey(R.string.pref_twitter_token_secret), null));
            e.putString(getKey(R.string.pref_twitter_token_public), prefsV0.getString(getKey(R.string.pref_twitter_token_public), null));
            e.putInt(getKey(R.string.pref_version), prefsV0.getInt(getKey(R.string.pref_version), 0));
            e.putBoolean(getKey(R.string.pref_ratingwanted), prefsV0.getBoolean(getKey(R.string.pref_ratingwanted), true));
            e.putBoolean(getKey(R.string.pref_friendlogswanted), prefsV0.getBoolean(getKey(R.string.pref_friendlogswanted), true));
            e.putBoolean(getKey(R.string.pref_useenglish), prefsV0.getBoolean(getKey(R.string.pref_useenglish), false));
            e.putBoolean(getKey(R.string.pref_usecompass), prefsV0.getInt(getKey(R.string.pref_usecompass), 1) != 0);
            e.putBoolean(getKey(R.string.pref_trackautovisit), prefsV0.getBoolean(getKey(R.string.pref_trackautovisit), false));
            e.putBoolean(getKey(R.string.pref_sigautoinsert), prefsV0.getBoolean(getKey(R.string.pref_sigautoinsert), false));
            e.putBoolean(getKey(R.string.pref_logimages), prefsV0.getBoolean(getKey(R.string.pref_logimages), false));
            e.putBoolean(getKey(R.string.pref_excludedisabled), prefsV0.getInt(getKey(R.string.pref_excludedisabled), 0) != 0);
            e.putBoolean(getKey(R.string.pref_excludemine), prefsV0.getInt(getKey(R.string.pref_excludemine), 0) != 0);
            e.putString(getKey(R.string.pref_mapfile), prefsV0.getString(getKey(R.string.pref_mapfile), null));
            e.putString(getKey(R.string.pref_signature), prefsV0.getString(getKey(R.string.pref_signature), null));
            e.putString(getKey(R.string.pref_pass_vote), prefsV0.getString(getKey(R.string.pref_pass_vote), null));
            e.putString(getKey(R.string.pref_password), prefsV0.getString(getKey(R.string.pref_password), null));
            e.putString(getKey(R.string.pref_username), prefsV0.getString(getKey(R.string.pref_username), null));
            e.putString(getKey(R.string.pref_memberstatus), prefsV0.getString(getKey(R.string.pref_memberstatus), ""));
            e.putInt(getKey(R.string.pref_coordinputformat), prefsV0.getInt(getKey(R.string.pref_coordinputformat), CoordInputFormatEnum.DEFAULT_INT_VALUE));
            e.putBoolean(getKey(R.string.pref_log_offline), prefsV0.getBoolean(getKey(R.string.pref_log_offline), false));
            e.putBoolean(getKey(R.string.pref_choose_list), prefsV0.getBoolean(getKey(R.string.pref_choose_list), true));
            e.putBoolean(getKey(R.string.pref_loaddirectionimg), prefsV0.getBoolean(getKey(R.string.pref_loaddirectionimg), true));
            e.putString(getKey(R.string.pref_gccustomdate), prefsV0.getString(getKey(R.string.pref_gccustomdate), GCConstants.DEFAULT_GC_DATE));
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), prefsV0.getInt(getKey(R.string.pref_showwaypointsthreshold), SHOW_WP_THRESHOLD_DEFAULT));
            e.putBoolean(getKey(R.string.pref_opendetailslastpage), prefsV0.getBoolean(getKey(R.string.pref_opendetailslastpage), false));
            e.putInt(getKey(R.string.pref_lastdetailspage), prefsV0.getInt(getKey(R.string.pref_lastdetailspage), 1));
            e.putInt(getKey(R.string.pref_defaultNavigationTool), prefsV0.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id));
            e.putInt(getKey(R.string.pref_defaultNavigationTool2), prefsV0.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id));
            e.putInt(getKey(R.string.pref_livemapstrategy), prefsV0.getInt(getKey(R.string.pref_livemapstrategy), LivemapStrategy.AUTO.id));
            e.putBoolean(getKey(R.string.pref_debug), prefsV0.getBoolean(getKey(R.string.pref_debug), false));
            e.putInt(getKey(R.string.pref_livemaphintshowcount), prefsV0.getInt(getKey(R.string.pref_livemaphintshowcount), 0));

            e.putInt(getKey(R.string.pref_settingsversion), 1); // mark migrated
            e.apply();
        }

        // changes for new settings dialog
        if (currentVersion < 2) {
            final Editor e = sharedPrefs.edit();

            e.putBoolean(getKey(R.string.pref_units_imperial), useImperialUnits());

            // show waypoints threshold now as a slider
            int wpThreshold = getWayPointsThreshold();
            if (wpThreshold < 0) {
                wpThreshold = 0;
            } else if (wpThreshold > SHOW_WP_THRESHOLD_MAX) {
                wpThreshold = SHOW_WP_THRESHOLD_MAX;
            }
            e.putInt(getKey(R.string.pref_showwaypointsthreshold), wpThreshold);

            // KEY_MAP_SOURCE must be string, because it is the key for a ListPreference now
            final int ms = sharedPrefs.getInt(getKey(R.string.pref_mapsource), MAP_SOURCE_DEFAULT);
            e.remove(getKey(R.string.pref_mapsource));
            e.putString(getKey(R.string.pref_mapsource), String.valueOf(ms));

            // navigation tool ids must be string, because ListPreference uses strings as keys
            final int dnt1 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool), NavigationAppsEnum.COMPASS.id);
            final int dnt2 = sharedPrefs.getInt(getKey(R.string.pref_defaultNavigationTool2), NavigationAppsEnum.INTERNAL_MAP.id);
            e.remove(getKey(R.string.pref_defaultNavigationTool));
            e.remove(getKey(R.string.pref_defaultNavigationTool2));
            e.putString(getKey(R.string.pref_defaultNavigationTool), String.valueOf(dnt1));
            e.putString(getKey(R.string.pref_defaultNavigationTool2), String.valueOf(dnt2));

            // defaults for gpx directories
            e.putString(getKey(R.string.pref_gpxImportDir), LocalStorage.getDefaultGpxDirectory().getPath());
            e.putString(getKey(R.string.pref_gpxExportDir), LocalStorage.getDefaultGpxDirectory().getPath());

            e.putInt(getKey(R.string.pref_settingsversion), 2); // mark migrated
            e.apply();
        }

        if (currentVersion < 3) {
            final Editor e = sharedPrefs.edit();

            Log.i("Moving field-notes");
            FileUtils.move(LocalStorage.getLegacyFieldNotesDirectory(), LocalStorage.getFieldNotesDirectory());

            Log.i("Moving gpx ex- and import dirs");
            if (getGpxExportDir().equals(LocalStorage.getLegacyGpxDirectory().getPath())) {
                e.putString(getKey(R.string.pref_gpxExportDir), LocalStorage.getDefaultGpxDirectory().getPath());
            }
            if (getGpxImportDir().equals(LocalStorage.getLegacyGpxDirectory().getPath())) {
                e.putString(getKey(R.string.pref_gpxImportDir), LocalStorage.getDefaultGpxDirectory().getPath());
            }
            FileUtils.move(LocalStorage.getLegacyGpxDirectory(), LocalStorage.getDefaultGpxDirectory());

            Log.i("Moving local spoilers");
            FileUtils.move(LocalStorage.getLegacyLocalSpoilersDirectory(), LocalStorage.getLocalSpoilersDirectory());

            Log.i("Moving db files");
            FileUtils.moveTo(new File(LocalStorage.getLegacyExternalCgeoDirectory(), DataStore.DB_FILE_NAME), LocalStorage.getExternalDbDirectory());
            FileUtils.moveTo(new File(LocalStorage.getLegacyExternalCgeoDirectory(), DataStore.DB_FILE_NAME + DataStore.DB_FILE_CORRUPTED_EXTENSION), LocalStorage.getBackupDirectory());
            FileUtils.moveTo(new File(LocalStorage.getLegacyExternalCgeoDirectory(), DataStore.DB_FILE_NAME_BACKUP), LocalStorage.getBackupDirectory());
            FileUtils.moveTo(new File(LocalStorage.getLegacyExternalCgeoDirectory(), DataStore.DB_FILE_NAME_BACKUP + DataStore.DB_FILE_CORRUPTED_EXTENSION), LocalStorage.getBackupDirectory());

            Log.i("Moving geocache data");
            final FileFilter geocacheDirectories = new FileFilter() {
                @Override
                public boolean accept(final File pathname) {
                    final String name = pathname.getName();
                    return pathname.isDirectory() &&
                            (HtmlImage.SHARED.equals(name) || LocalStorage.GEOCACHE_FILE_PATTERN.matcher(name).find());
                }
            };
            final File[] list = LocalStorage.getLegacyExternalCgeoDirectory().listFiles(geocacheDirectories);
            if (list != null) {
                for (final File file : list) {
                    FileUtils.moveTo(file, LocalStorage.getGeocacheDataDirectory());
                }
            }

            Log.i("Deleting legacy .cgeo dir");
            FileUtils.deleteIgnoringFailure(LocalStorage.getLegacyExternalCgeoDirectory());

            e.putString(getKey(R.string.pref_dataDir), LocalStorage.getExternalPrivateCgeoDirectory().getAbsolutePath());
            e.putInt(getKey(R.string.pref_settingsversion), 3); // mark migrated
            e.apply();
        }
    }

    private static String getKey(final int prefKeyId) {
        return CgeoApplication.getInstance().getString(prefKeyId);
    }

    static String getString(final int prefKeyId, final String defaultValue) {
        return sharedPrefs.getString(getKey(prefKeyId), defaultValue);
    }

    private static List<String> getStringList(final int prefKeyId, final String defaultValue) {
        return Arrays.asList(StringUtils.split(getString(prefKeyId, defaultValue), SEPARATOR_CHAR));
    }

    private static int getInt(final int prefKeyId, final int defaultValue) {
        return sharedPrefs.getInt(getKey(prefKeyId), defaultValue);
    }

    private static long getLong(final int prefKeyId, final long defaultValue) {
        return sharedPrefs.getLong(getKey(prefKeyId), defaultValue);
    }

    private static boolean getBoolean(final int prefKeyId, final boolean defaultValue) {
        return sharedPrefs.getBoolean(getKey(prefKeyId), defaultValue);
    }

    private static float getFloat(final int prefKeyId, final float defaultValue) {
        return sharedPrefs.getFloat(getKey(prefKeyId), defaultValue);
    }

    protected static void putString(final int prefKeyId, final String value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putString(getKey(prefKeyId), value);
        edit.apply();
    }

    private static void putStringList(final int prefKeyId, final Iterable<?> elements) {
        putString(prefKeyId, StringUtils.join(elements, SEPARATOR_CHAR));
    }


    protected static void putBoolean(final int prefKeyId, final boolean value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putBoolean(getKey(prefKeyId), value);
        edit.apply();
    }

    private static void putInt(final int prefKeyId, final int value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putInt(getKey(prefKeyId), value);
        edit.apply();
    }

    private static void putLong(final int prefKeyId, final long value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putLong(getKey(prefKeyId), value);
        edit.apply();
    }

    private static void putFloat(final int prefKeyId, final float value) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.putFloat(getKey(prefKeyId), value);
        edit.apply();
    }

    private static void remove(final int prefKeyId) {
        final SharedPreferences.Editor edit = sharedPrefs.edit();
        edit.remove(getKey(prefKeyId));
        edit.apply();
    }

    private static boolean contains(final int prefKeyId) {
        return sharedPrefs.contains(getKey(prefKeyId));
    }

    public static boolean hasGCCredentials() {
        return getGcCredentials().isValid();
    }

    /**
     * Get login and password information of Geocaching.com.
     *
     * @return a pair either with (login, password) or (empty, empty) if no valid information is stored
     */
    public static Credentials getGcCredentials() {
        return getCredentials(GCConnector.getInstance());
    }

    /**
     * Get login and password information from preference key id.
     *
     * @param usernamePreferenceKey Username preference key id
     * @param passwordPreferenceKey Password preference key id
     * @return the credential information
     */
    @NonNull
    public static Credentials getCredentials(final int usernamePreferenceKey, final int passwordPreferenceKey) {
        final String username = StringUtils.trim(getString(usernamePreferenceKey, StringUtils.EMPTY));
        final String password = getString(passwordPreferenceKey, StringUtils.EMPTY);
        return new Credentials(username, password);
    }

    /**
     * Get login and password information.
     *
     * @param connector the connector to retrieve the login information from
     * @return the credential information
     */
    @NonNull
    public static Credentials getCredentials(@NonNull final ICredentials connector) {
        return getCredentials(connector.getUsernamePreferenceKey(), connector.getPasswordPreferenceKey());
    }

    /**
     * Set login and password information.
     *
     * @param connector the connector to retrieve the login information from
     * @param credentials the credential information to store
     */
    public static void setCredentials(@NonNull final ICredentials connector, final Credentials credentials) {
        putString(connector.getUsernamePreferenceKey(), credentials.getUsernameRaw());
        putString(connector.getPasswordPreferenceKey(), credentials.getPasswordRaw());
    }

    public static String getUserName() {
        return StringUtils.trim(getString(R.string.pref_username, StringUtils.EMPTY));
    }

    public static boolean isGCConnectorActive() {
        return getBoolean(R.string.pref_connectorGCActive, true);
    }

    public static boolean isECConnectorActive() {
        return getBoolean(R.string.pref_connectorECActive, false);
    }

    public static boolean isSUConnectorActive() {
        return getBoolean(R.string.pref_connectorSUActive, false);
    }

    public static boolean isGCPremiumMember() {
        return getGCMemberStatus().isPremium();
    }

    public static GCMemberState getGCMemberStatus() {
        return GCMemberState.fromString(getString(R.string.pref_memberstatus, ""));
    }

    public static void setGCMemberStatus(final GCMemberState memberStatus) {
        putString(R.string.pref_memberstatus, memberStatus.englishWebsite);
    }

    @NonNull
    public static ImmutablePair<String, String> getTokenPair(final int tokenPublicPrefKey, final int tokenSecretPrefKey) {
        return new ImmutablePair<>(getString(tokenPublicPrefKey, null), getString(tokenSecretPrefKey, null));
    }

    public static void setTokens(final int tokenPublicPrefKey, @Nullable final String tokenPublic, final int tokenSecretPrefKey, @Nullable final String tokenSecret) {
        if (tokenPublic == null) {
            remove(tokenPublicPrefKey);
        } else {
            putString(tokenPublicPrefKey, tokenPublic);
        }
        if (tokenSecret == null) {
            remove(tokenSecretPrefKey);
        } else {
            putString(tokenSecretPrefKey, tokenSecret);
        }
    }

    public static boolean isOCConnectorActive(final int isActivePrefKeyId) {
        return getBoolean(isActivePrefKeyId, false);
    }

    public static boolean hasOCAuthorization(final int tokenPublicPrefKeyId, final int tokenSecretPrefKeyId) {
        return StringUtils.isNotBlank(getString(tokenPublicPrefKeyId, ""))
                && StringUtils.isNotBlank(getString(tokenSecretPrefKeyId, ""));
    }

    public static boolean isGCVoteLoginValid() {
        return getGCVoteLogin().isValid();
    }

    @NonNull
    public static Credentials getGCVoteLogin() {
        final String username = StringUtils.trimToNull(getString(R.string.pref_username, null));
        final String password = getString(R.string.pref_pass_vote, null);
        return new Credentials(username, password);
    }

    @NonNull
    public static String getSignature() {
        return StringUtils.defaultString(getString(R.string.pref_signature, StringUtils.EMPTY));
    }

    public static void setUseGooglePlayServices(final boolean value) {
        putBoolean(R.string.pref_googleplayservices, value);
    }

    public static boolean useGooglePlayServices() {
        if (!GooglePlayServices.isAvailable()) {
            return false;
        }
        return outdatedPhoneModelOrSdk() || getBoolean(R.string.pref_googleplayservices, true);
    }

    public static boolean useLowPowerMode() {
        return getBoolean(R.string.pref_lowpowermode, false);
    }

    /**
     * @param cacheType
     *            The cache type used for future filtering
     */
    public static void setCacheType(final CacheType cacheType) {
        if (cacheType == null) {
            remove(R.string.pref_cachetype);
        } else {
            putString(R.string.pref_cachetype, cacheType.id);
        }
    }

    public static int getLastDisplayedList() {
        return getInt(R.string.pref_lastusedlist, StoredList.STANDARD_LIST_ID);
    }

    /**
     * remember the last displayed cache list
     */
    public static void setLastDisplayedList(final int listId) {
        putInt(R.string.pref_lastusedlist, listId);
    }

    public static Set<Integer> getLastSelectedLists() {
        final Set<Integer> lastSelectedLists = new HashSet<>();
        for (final String lastSelectedListString : getStringList(R.string.pref_last_selected_lists, StringUtils.EMPTY)) {
            try {
                lastSelectedLists.add(Integer.valueOf(lastSelectedListString));
            } catch (final NumberFormatException ignored) { }
        }
        return lastSelectedLists;
    }

    /**
     * remember the last selection in the dialog that assigns a cache to certain lists
     */
    public static void setLastSelectedLists(final Set<Integer> lastSelectedLists) {
        putStringList(R.string.pref_last_selected_lists, lastSelectedLists);
    }

    public static void setWebNameCode(final String name, final String code) {
        putString(R.string.pref_webDeviceName, name);
        putString(R.string.pref_webDeviceCode, code);
    }

    public static MapProvider getMapProvider() {
        return getMapSource().getMapProvider();
    }

    public static String getMapFile() {
        return getString(R.string.pref_mapfile, null);
    }

    static void setMapFile(final String mapFile) {
        putString(R.string.pref_mapfile, mapFile);
        if (mapFile != null) {
            setMapFileDirectory(new File(mapFile).getParent());
        }
    }

    public static String getMapFileDirectory() {
        final String mapDir = getString(R.string.pref_mapDirectory, null);
        if (mapDir != null) {
            return mapDir;
        }
        final String mapFile = getMapFile();
        if (mapFile != null) {
            return new File(mapFile).getParent();
        }
        return null;
    }

    static void setMapFileDirectory(final String mapFileDirectory) {
        putString(R.string.pref_mapDirectory, mapFileDirectory);
        MapsforgeMapProvider.getInstance().updateOfflineMaps();
    }

    private static boolean isValidMapFile() {
        return isValidMapFile(getMapFile());
    }

    public static boolean isValidMapFile(final String mapFileIn) {
        return MapsforgeMapProvider.isValidMapFile(mapFileIn);
    }

    public static boolean isScaleMapsforgeText() {
        return getBoolean(R.string.pref_mapsforge_scale_text, true);
    }

    public static CoordInputFormatEnum getCoordInputFormat() {
        return CoordInputFormatEnum.fromInt(getInt(R.string.pref_coordinputformat, CoordInputFormatEnum.DEFAULT_INT_VALUE));
    }

    public static void setCoordInputFormat(final CoordInputFormatEnum format) {
        putInt(R.string.pref_coordinputformat, format.ordinal());
    }

    public static boolean getLogOffline() {
        return getBoolean(R.string.pref_log_offline, false);
    }

    public static boolean getChooseList() {
        return getBoolean(R.string.pref_choose_list, false);
    }

    public static boolean getLoadDirImg() {
        return !isGCPremiumMember() && getBoolean(R.string.pref_loaddirectionimg, true);
    }

    public static void setGcCustomDate(final String format) {
        putString(R.string.pref_gccustomdate, format);
    }

    /**
     * @return User selected date format on GC.com
     */
    public static String getGcCustomDate() {
        // We might have some users whose stored value is null, which is invalid. In this case, we use the default.
        return StringUtils.defaultString(getString(R.string.pref_gccustomdate, GCConstants.DEFAULT_GC_DATE),
                GCConstants.DEFAULT_GC_DATE);
    }

    public static boolean isExcludeMyCaches() {
        return getBoolean(R.string.pref_excludemine, false);
    }

    public static boolean useEnglish() {
        return getBoolean(R.string.pref_useenglish, false);
    }

    public static void setUseEnglish(final boolean useEnglish) {
        putBoolean(R.string.pref_useenglish, useEnglish);
    }

    public static boolean isShowAddress() {
        return getBoolean(R.string.pref_showaddress, true);
    }

    public static boolean isExcludeDisabledCaches() {
        return getBoolean(R.string.pref_excludedisabled, false);
    }

    public static boolean isStoreOfflineMaps() {
        return getBoolean(R.string.pref_offlinemaps, true);
    }

    public static boolean isStoreOfflineWpMaps() {
        return getBoolean(R.string.pref_offlinewpmaps, false);
    }

    public static boolean isStoreLogImages() {
        return getBoolean(R.string.pref_logimages, false);
    }

    public static boolean isRatingWanted() {
        return getBoolean(R.string.pref_ratingwanted, true);
    }

    public static boolean isGeokretyConnectorActive() {
        return getBoolean(R.string.pref_connectorGeokretyActive, false);
    }

    public static boolean isGeokretyCacheActive() {
        return getBoolean(R.string.pref_geokrety_cache, true);
    }

    static boolean hasGeokretyAuthorization() {
        return StringUtils.isNotBlank(getGeokretySecId());
    }

    public static String getGeokretySecId() {
        return getString(R.string.pref_fakekey_geokrety_authorization, null);
    }

    public static void setGeokretySecId(final String secid) {
        putString(R.string.pref_fakekey_geokrety_authorization, secid);
    }

    public static String getTokenSecret(final int prefKeyId) {
        return getString(prefKeyId, StringUtils.EMPTY);
    }

    public static void setTokenSecret(final int prefKeyId, final String secretToken) {
        putString(prefKeyId, secretToken);
    }

    public static boolean isRegisteredForGeokretyLogging() {
        return getGeokretySecId() != null;
    }

    /**
     * Retrieve showed popup counter for warning about logging Trackable recommend Geocode
     *
     * @return number of times the popup has appeared
     */
    public static int getLogTrackableWithoutGeocodeShowCount() {
        return getInt(R.string.pref_logtrackablewithoutgeocodeshowcount, 0);
    }

    /**
     * Store showed popup counter for warning about logging Trackable recommend Geocode
     *
     * @param showCount the count to save
     */
    public static void setLogTrackableWithoutGeocodeShowCount(final int showCount) {
        putInt(R.string.pref_logtrackablewithoutgeocodeshowcount, showCount);
    }

    public static boolean isFriendLogsWanted() {
        if (!hasGCCredentials()) {
            // don't show a friends log if the user is anonymous
            return false;
        }
        return getBoolean(R.string.pref_friendlogswanted, true);
    }

    public static boolean isLiveList() {
        return getBoolean(R.string.pref_livelist, true);
    }

    public static boolean isTrackableAutoVisit() {
        return getBoolean(R.string.pref_trackautovisit, false);
    }

    public static boolean isAutoInsertSignature() {
        return getBoolean(R.string.pref_sigautoinsert, false);
    }

    static void setUseImperialUnits(final boolean useImperialUnits) {
        putBoolean(R.string.pref_units_imperial, useImperialUnits);
    }

    public static boolean useImperialUnits() {
        return getBoolean(R.string.pref_units_imperial, useImperialUnitsByDefault());
    }

    private static boolean useImperialUnitsByDefault() {
        final String countryCode = Locale.getDefault().getCountry();
        return "US".equals(countryCode)  // USA
            || "LR".equals(countryCode)  // Liberia
            || "MM".equals(countryCode); // Burma
    }

    public static boolean isLiveMap() {
        return getBoolean(R.string.pref_maplive, true);
    }

    public static void setLiveMap(final boolean live) {
        putBoolean(R.string.pref_maplive, live);
    }

    public static boolean isMapTrail() {
        return getBoolean(R.string.pref_maptrail, false);
    }

    public static void setMapTrail(final boolean showTrail) {
        putBoolean(R.string.pref_maptrail, showTrail);
    }

    /**
     * whether to show a direction line on the map
     */
    public static boolean isMapDirection() {
        return getBoolean(R.string.pref_map_direction, true);
    }

    public static void setMapDirection(final boolean showDirection) {
        putBoolean(R.string.pref_map_direction, showDirection);
    }

    /**
     * Get last used zoom of the internal map. Differentiate between two use cases for a map of multiple caches (e.g.
     * live map) and the map of a single cache (which is often zoomed in more deep).
     */
    public static int getMapZoom(final MapMode mapMode) {
        if (mapMode == MapMode.SINGLE || mapMode == MapMode.COORDS) {
            return getCacheZoom();
        }
        return getMapZoom();
    }

    public static void setMapZoom(final MapMode mapMode, final int zoomLevel) {
        if (mapMode == MapMode.SINGLE || mapMode == MapMode.COORDS) {
            setCacheZoom(zoomLevel);
        } else {
            setMapZoom(zoomLevel);
        }
    }

    /**
     * @return zoom used for the (live) map
     */
    private static int getMapZoom() {
        return Math.max(getInt(R.string.pref_lastmapzoom, 14), INITIAL_MAP_ZOOM_LIMIT);
    }

    private static void setMapZoom(final int mapZoomLevel) {
        putInt(R.string.pref_lastmapzoom, mapZoomLevel);
    }

    /**
     * @return zoom used for the map of a single cache
     */
    private static int getCacheZoom() {
        return Math.max(getInt(R.string.pref_cache_zoom, 14), INITIAL_MAP_ZOOM_LIMIT);
    }

    private static void setCacheZoom(final int zoomLevel) {
        putInt(R.string.pref_cache_zoom, zoomLevel);
    }

    public static GeoPointImpl getMapCenter() {
        return getMapProvider().getMapItemFactory()
                .getGeoPointBase(new Geopoint(getInt(R.string.pref_lastmaplat, 0) / 1e6,
                        getInt(R.string.pref_lastmaplon, 0) / 1e6));
    }

    public static void setMapCenter(final GeoPointImpl mapViewCenter) {
        putInt(R.string.pref_lastmaplat, mapViewCenter.getLatitudeE6());
        putInt(R.string.pref_lastmaplon, mapViewCenter.getLongitudeE6());
    }

    @NonNull
    public static synchronized MapSource getMapSource() {
        if (mapSource != null) {
            return mapSource;
        }
        final int id = getConvertedMapId();
        mapSource = MapProviderFactory.getMapSource(id);
        if (mapSource != null) {
            // don't use offline maps if the map file is not valid
            if (!(mapSource instanceof OfflineMapSource) || isValidMapFile()) {
                return mapSource;
            }
        }
        // fallback to first available map
        return MapProviderFactory.getDefaultSource();
    }

    private static final int GOOGLEMAP_BASEID = 30;
    private static final int MAP = 1;
    private static final int SATELLITE = 2;

    private static final int MFMAP_BASEID = 40;
    private static final int MAPNIK = 1;
    private static final int CYCLEMAP = 3;
    private static final int OFFLINE = 4;
    private static final int HISTORY_SIZE = 10;

    /**
     * Convert old preference ids for maps (based on constant values) into new hash based ids.
     */
    private static int getConvertedMapId() {
        final int id = Integer.parseInt(getString(R.string.pref_mapsource,
                String.valueOf(MAP_SOURCE_DEFAULT)));
        switch (id) {
            case GOOGLEMAP_BASEID + MAP:
                return GoogleMapProvider.GOOGLE_MAP_ID.hashCode();
            case GOOGLEMAP_BASEID + SATELLITE:
                return GoogleMapProvider.GOOGLE_SATELLITE_ID.hashCode();
            case MFMAP_BASEID + MAPNIK:
                return MapsforgeMapProvider.MAPSFORGE_MAPNIK_ID.hashCode();
            case MFMAP_BASEID + CYCLEMAP:
                return MapsforgeMapProvider.MAPSFORGE_CYCLEMAP_ID.hashCode();
            case MFMAP_BASEID + OFFLINE: {
                final String mapFile = getMapFile();
                if (StringUtils.isNotEmpty(mapFile)) {
                    return mapFile.hashCode();
                }
                break;
            }
            default:
                break;
        }
        return id;
    }

    public static synchronized void setMapSource(final MapSource newMapSource) {
        putString(R.string.pref_mapsource, String.valueOf(newMapSource.getNumericalId()));
        if (newMapSource instanceof OfflineMapSource) {
            setMapFile(((OfflineMapSource) newMapSource).getFileName());
        }
        // cache the value
        mapSource = newMapSource;
    }

    public static void setAnyCoordinates(final Geopoint coords) {
        if (coords != null) {
            putFloat(R.string.pref_anylatitude, (float) coords.getLatitude());
            putFloat(R.string.pref_anylongitude, (float) coords.getLongitude());
        } else {
            remove(R.string.pref_anylatitude);
            remove(R.string.pref_anylongitude);
        }
    }

    public static Geopoint getAnyCoordinates() {
        if (contains(R.string.pref_anylatitude) && contains(R.string.pref_anylongitude)) {
            final float lat = getFloat(R.string.pref_anylatitude, 0);
            final float lon = getFloat(R.string.pref_anylongitude, 0);
            return new Geopoint(lat, lon);
        }
        return null;
    }

    public static boolean isUseCompass() {
        return useCompass;
    }

    public static void setUseCompass(final boolean value) {
        useCompass = value;
    }

    public static boolean isLightSkin() {
        return getBoolean(R.string.pref_skin, false);
    }

    @NonNull
    public static String getTwitterKeyConsumerPublic() {
        return TWITTER_KEY_CONSUMER_PUBLIC;
    }

    @NonNull
    public static String getTwitterKeyConsumerSecret() {
        return TWITTER_KEY_CONSUMER_SECRET;
    }

    public static String getWebDeviceCode() {
        return getString(R.string.pref_webDeviceCode, null);
    }

    public static boolean isRegisteredForSend2cgeo() {
        return getWebDeviceCode() != null;
    }

    static String getWebDeviceName() {
        return getString(R.string.pref_webDeviceName, Build.MODEL);
    }

    /**
     * @return The cache type used for filtering or ALL if no filter is active.
     *         Returns never null
     */
    @NonNull
    public static CacheType getCacheType() {
        return CacheType.getById(getString(R.string.pref_cachetype, CacheType.ALL.id));
    }

    /**
     * The Threshold for the showing of child waypoints
     */
    public static int getWayPointsThreshold() {
        return getInt(R.string.pref_showwaypointsthreshold, SHOW_WP_THRESHOLD_DEFAULT);
    }

    static void setShowWaypointsThreshold(final int threshold) {
        putInt(R.string.pref_showwaypointsthreshold, threshold);
    }

    public static boolean isUseTwitter() {
        return getBoolean(R.string.pref_twitter, false);
    }

    private static void setUseTwitter(final boolean useTwitter) {
        putBoolean(R.string.pref_twitter, useTwitter);
    }

    public static boolean isTwitterLoginValid() {
        return !StringUtils.isBlank(getTokenPublic())
                && !StringUtils.isBlank(getTokenSecret());
    }

    public static String getTokenPublic() {
        return getString(R.string.pref_twitter_token_public, null);
    }

    public static String getTokenSecret() {
        return getString(R.string.pref_twitter_token_secret, null);

    }

    static boolean hasTwitterAuthorization() {
        return StringUtils.isNotBlank(getTokenPublic())
                && StringUtils.isNotBlank(getTokenSecret());
    }

    public static void setTwitterTokens(@Nullable final String tokenPublic,
            @Nullable final String tokenSecret, final boolean enableTwitter) {
        putString(R.string.pref_twitter_token_public, tokenPublic);
        putString(R.string.pref_twitter_token_secret, tokenSecret);
        if (tokenPublic != null) {
            remove(R.string.pref_temp_twitter_token_public);
            remove(R.string.pref_temp_twitter_token_secret);
        }
        setUseTwitter(enableTwitter);
    }

    public static void setTwitterTempTokens(@Nullable final String tokenPublic,
            @Nullable final String tokenSecret) {
        putString(R.string.pref_temp_twitter_token_public, tokenPublic);
        putString(R.string.pref_temp_twitter_token_secret, tokenSecret);
    }

    @NonNull
    public static ImmutablePair<String, String> getTempToken() {
        final String tokenPublic = getString(R.string.pref_temp_twitter_token_public, null);
        final String tokenSecret = getString(R.string.pref_temp_twitter_token_secret, null);
        return new ImmutablePair<>(tokenPublic, tokenSecret);
    }

    public static int getVersion() {
        return getInt(R.string.pref_version, 0);
    }

    public static void setVersion(final int version) {
        putInt(R.string.pref_version, version);
    }

    public static boolean isOpenLastDetailsPage() {
        return getBoolean(R.string.pref_opendetailslastpage, false);
    }

    public static int getLastDetailsPage() {
        return getInt(R.string.pref_lastdetailspage, 1);
    }

    public static void setLastDetailsPage(final int index) {
        putInt(R.string.pref_lastdetailspage, index);
    }

    public static int getDefaultNavigationTool() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool,
                String.valueOf(NavigationAppsEnum.COMPASS.id)));
    }

    public static int getDefaultNavigationTool2() {
        return Integer.parseInt(getString(
                R.string.pref_defaultNavigationTool2,
                String.valueOf(NavigationAppsEnum.INTERNAL_MAP.id)));
    }

    @NonNull
    public static LivemapStrategy getLiveMapStrategy() {
        return LivemapStrategy.getById(getInt(R.string.pref_livemapstrategy, LivemapStrategy.AUTO.id));
    }

    public static void setLiveMapStrategy(final LivemapStrategy strategy) {
        putInt(R.string.pref_livemapstrategy, strategy.id);
    }

    public static boolean isDebug() {
        return Log.isDebug();
    }

    public static void setDebug(final boolean debug) {
        Log.setDebug(debug);
        putBoolean(R.string.pref_debug, debug);
    }

    public static int getLiveMapHintShowCount() {
        return getInt(R.string.pref_livemaphintshowcount, 0);
    }

    public static void setLiveMapHintShowCount(final int showCount) {
        putInt(R.string.pref_livemaphintshowcount, showCount);
    }

    public static boolean isDbOnSDCard() {
        return getBoolean(R.string.pref_dbonsdcard, false);
    }

    public static void setDbOnSDCard(final boolean dbOnSDCard) {
        putBoolean(R.string.pref_dbonsdcard, dbOnSDCard);
    }

    public static String getGpxExportDir() {
        return getString(R.string.pref_gpxExportDir,
                LocalStorage.getDefaultGpxDirectory().getPath());
    }

    public static String getGpxImportDir() {
        return getString(R.string.pref_gpxImportDir,
                LocalStorage.getDefaultGpxDirectory().getPath());
    }

    public static String getExternalPrivateCgeoDirectory() {
        return getString(R.string.pref_dataDir, null);
    }

    public static void setExternalPrivateCgeoDirectory(final String extDir) {
        putString(R.string.pref_dataDir, extDir);
    }

    public static boolean getShareAfterExport() {
        return getBoolean(R.string.pref_shareafterexport, true);
    }

    public static void setShareAfterExport(final boolean shareAfterExport) {
        putBoolean(R.string.pref_shareafterexport, shareAfterExport);
    }
    public static boolean getIncludeFoundStatus() {
        return getBoolean(R.string.pref_includefoundstatus, true);
    }

    public static void setIncludeFoundStatus(final boolean includeFoundStatus) {
        putBoolean(R.string.pref_includefoundstatus, includeFoundStatus);
    }
    /**
     * Get Trackable inventory sort method based on the last Trackable inventory sort method.
     *
     * @return
     *          The Trackable Sort Method position previously used.
     */
    public static int getTrackableInventorySortMethod() {
        return getInt(R.string.pref_trackable_inventory_sort, 0);
    }

    /**
     * Set Trackable inventory sort method.
     *
     * @param trackableSortMethod
     *          The Trackable Sort Method to remember
     */
    public static void setTrackableInventorySortMethod(final int trackableSortMethod) {
        putInt(R.string.pref_trackable_inventory_sort, trackableSortMethod);
    }
    /**
     * Obtain Trackable action from the last Trackable log.
     *
     * @return
     *          The last Trackable Action or RETRIEVED_IT
     */
    public static int getTrackableAction() {
        return getInt(R.string.pref_trackableaction, LogTypeTrackable.RETRIEVED_IT.id);
    }

    /**
     * Save Trackable action from the last Trackable log.
     *
     * @param trackableAction
     *          The Trackable Action to remember
     */
    public static void setTrackableAction(final int trackableAction) {
        putInt(R.string.pref_trackableaction, trackableAction);
    }

    private static String getCustomRenderThemeBaseFolder() {
        return getString(R.string.pref_renderthemepath, "");
    }

    public static String getCustomRenderThemeFilePath() {
        return getString(R.string.pref_renderthemefile, "");
    }

    public static void setCustomRenderThemeFile(final String customRenderThemeFile) {
        putString(R.string.pref_renderthemefile, customRenderThemeFile);
    }

    public static File[] getMapThemeFiles() {
        final File directory = new File(getCustomRenderThemeBaseFolder());
        final List<File> result = new ArrayList<>();
        FileUtils.listDir(result, directory, new ExtensionsBasedFileSelector(new String[] { "xml" }), null);

        return result.toArray(new File[result.size()]);
    }

    private static class ExtensionsBasedFileSelector implements FileSelector {
        private final String[] extensions;

        ExtensionsBasedFileSelector(final String[] extensions) {
            this.extensions = extensions;
        }

        @Override
        public boolean isSelected(final File file) {
            final String filename = file.getName();
            for (final String ext : extensions) {
                if (StringUtils.endsWithIgnoreCase(filename, ext)) {
                    return true;
                }
            }
            return false;
        }

        @Override
        public boolean shouldEnd() {
            return false;
        }
    }

    /**
     * @return true if plain text log wanted
     */
    public static boolean getPlainLogs() {
        return getBoolean(R.string.pref_plainLogs, false);
    }

    /**
     * Force set the plain text log preference
     *
     * @param plainLogs
     *            wanted or not
     */
    public static void setPlainLogs(final boolean plainLogs) {
        putBoolean(R.string.pref_plainLogs, plainLogs);
    }

    public static boolean getUseNativeUa() {
        return getBoolean(R.string.pref_nativeUa, false);
    }

    @NonNull
    public static String getCacheTwitterMessage() {
        return StringUtils.defaultString(getString(R.string.pref_twitter_cache_message, "I found [NAME] ([URL])."));
    }

    @NonNull
    public static String getTrackableTwitterMessage() {
        return StringUtils.defaultString(getString(R.string.pref_twitter_trackable_message, "I touched [NAME] ([URL])."));
    }

    public static int getLogImageScale() {
        return getInt(R.string.pref_logImageScale, -1);
    }

    public static void setLogImageScale(final int scale) {
        putInt(R.string.pref_logImageScale, scale);
    }

    public static void setExcludeMine(final boolean exclude) {
        putBoolean(R.string.pref_excludemine, exclude);
    }

    public static void setExcludeDisabled(final boolean exclude) {
        putBoolean(R.string.pref_excludedisabled, exclude);
    }

    static void setLogin(final String username, final String password) {
        if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
            // erase username and password
            remove(R.string.pref_username);
            remove(R.string.pref_password);
            return;
        }
        // save username and password
        putString(R.string.pref_username, StringUtils.trim(username));
        putString(R.string.pref_password, password);
    }

    public static long getFieldnoteExportDate() {
        return getLong(R.string.pref_fieldNoteExportDate, 0);
    }

    /**
     * Remember date of last field note export.
     */
    public static void setFieldnoteExportDate(final long date) {
        putLong(R.string.pref_fieldNoteExportDate, date);
    }

    public static boolean isUseNavigationApp(final NavigationAppsEnum navApp) {
        return getBoolean(navApp.preferenceKey, true);
    }

    /**
     * Remember the state of the "Upload" checkbox in the field notes export dialog.
     */
    public static void setFieldNoteExportUpload(final boolean upload) {
        putBoolean(R.string.pref_fieldNoteExportUpload, upload);
    }

    public static boolean getFieldNoteExportUpload() {
        return getBoolean(R.string.pref_fieldNoteExportUpload, true);
    }

    /**
     * Remember the state of the "Only new" checkbox in the field notes export dialog.
     */
    public static void setFieldNoteExportOnlyNew(final boolean onlyNew) {
        putBoolean(R.string.pref_fieldNoteExportOnlyNew, onlyNew);
    }

    public static boolean getFieldNoteExportOnlyNew() {
        return getBoolean(R.string.pref_fieldNoteExportOnlyNew, false);
    }

    public static String getECIconSet() {
        return getString(R.string.pref_ec_icons, "1");
    }

    /* Store last checksum of changelog for changelog display */
    public static long getLastChangelogChecksum() {
        return getLong(R.string.pref_changelog_last_checksum, 0);
    }

    public static void setLastChangelogChecksum(final long checksum) {
        putLong(R.string.pref_changelog_last_checksum, checksum);
    }

    public static List<String> getLastOpenedCaches() {
        final List<String> history = getStringList(R.string.pref_caches_history, StringUtils.EMPTY);
        return history.subList(0, Math.min(HISTORY_SIZE, history.size()));
    }

    public static void addCacheToHistory(@NonNull final String geocode) {
        final List<String> history = new ArrayList<>(getLastOpenedCaches());
        // bring entry to front, if it already existed
        history.remove(geocode);
        history.add(0, geocode);
        putStringList(R.string.pref_caches_history, history);
    }

    public static boolean useNewMapAsDefault() {
        return getBoolean(R.string.pref_new_map_as_default, false);
    }

    static void setUseNewMapAsDefault(final boolean useNewMapAsDefault) {
        putBoolean(R.string.pref_new_map_as_default, useNewMapAsDefault);
    }

    public static boolean useHardwareAcceleration() {
        return outdatedPhoneModelOrSdk() ? HwAccel.hwAccelShouldBeEnabled() :
                getBoolean(R.string.pref_hardware_acceleration, HwAccel.hwAccelShouldBeEnabled());
    }

    static void setUseHardwareAcceleration(final boolean useHardwareAcceleration) {
        putBoolean(R.string.pref_hardware_acceleration, useHardwareAcceleration);
        storePhoneModelAndSdk();
    }

    private static boolean outdatedPhoneModelOrSdk() {
        return !StringUtils.equals(PHONE_MODEL_AND_SDK, getString(R.string.pref_phone_model_and_sdk, null));
    }

    private static void storePhoneModelAndSdk() {
        putString(R.string.pref_phone_model_and_sdk, PHONE_MODEL_AND_SDK);
    }

    public static String getLastCacheLog() {
        return getString(R.string.pref_last_cache_log, StringUtils.EMPTY);
    }

    public static void setLastCacheLog(final String log) {
        putString(R.string.pref_last_cache_log, log);
    }

    public static String getLastTrackableLog() {
        return getString(R.string.pref_last_trackable_log, StringUtils.EMPTY);
    }

    public static void setLastTrackableLog(final String log) {
        putString(R.string.pref_last_trackable_log, log);
    }

    @Nullable
    public static String getHomeLocation() {
        return getString(R.string.pref_home_location, null);
    }

    public static void setHomeLocation(@NonNull final String homeLocation) {
        putString(R.string.pref_home_location, homeLocation);
    }

    public static void setForceOrientationSensor(final boolean forceOrientationSensor) {
        putBoolean(R.string.pref_force_orientation_sensor, forceOrientationSensor);
    }

    public static boolean useOrientationSensor(final Context context) {
        return OrientationProvider.hasOrientationSensor(context) &&
                (getBoolean(R.string.pref_force_orientation_sensor, false) ||
                    !(RotationProvider.hasRotationSensor(context) || MagnetometerAndAccelerometerProvider.hasMagnetometerAndAccelerometerSensors(context))
                );
    }

    /**
     * Get avatar URL by connector.
     *
     * @param connector the connector to retrieve the avatar information from
     * @return the avatar url
     */
    @NonNull
    public static String getAvatarUrl(@NonNull final ICredentials connector) {
        return getString(connector.getAvatarPreferenceKey(), null);
    }

    /**
     * Set avatar URL by connector.
     *
     * @param connector the connector to retrieve the avatar information from
     * @param avatarUrl the avatar url information to store
     */
    public static void setAvatarUrl(@NonNull final ICredentials connector, final String avatarUrl) {
        putString(connector.getAvatarPreferenceKey(), avatarUrl);
    }

    /**
     * Return the locale that should be used to display information to the user.
     *
     * @return either the system locale or an English one, depending on the settings
     */
    public static Locale getApplicationLocale() {
        return Settings.useEnglish() ? Locale.ENGLISH : Locale.getDefault();
    }

    public static void setRoutingMode(@NonNull final RoutingMode mode) {
        putString(R.string.pref_map_routing, mode.parameterValue);
        Routing.invalidateRouting();
    }

    public static RoutingMode getRoutingMode() {
        return RoutingMode.fromString(getString(R.string.pref_map_routing, "foot"));
    }

}
!@#$%
