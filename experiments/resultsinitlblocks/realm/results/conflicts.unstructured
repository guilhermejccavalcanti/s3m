C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b16816;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a16816;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c16816
<<<<<<< MINE
=======
	}

	private void defineTableStructure() {
		if (table != null && table.getTableSpec().getColumnCount() <= 0) {
			final TableSpec spec = new TableSpec();
			specifyStructure(spec);
			table.updateFromSpec(spec);
		}
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b13748;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a13748;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c13748
<<<<<<< MINE
	private ColumnType(int index) {
		this.index = index;
	}
	private int index;
=======
    private ColumnType(int nativeValue)
    {
        this.nativeValue = nativeValue;
    }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b13748;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a13748;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c13748
<<<<<<< MINE
	public boolean matchObject(Object obj) {
		switch (this.index) {
		case 0: return (obj instanceof Long || obj instanceof Integer || obj instanceof Short || 
				obj instanceof Byte);
		case 1: return (obj instanceof Boolean);
		case 2: return (obj instanceof String);
		case 4: return (obj instanceof byte[] || obj instanceof ByteBuffer);
		case 5: return (obj == null || obj instanceof Object[][]);
		case 6: return (obj instanceof Long || obj instanceof Integer || obj instanceof Short || 
				obj instanceof Byte || obj instanceof Boolean || obj instanceof String ||
				obj instanceof byte[] || obj instanceof ByteBuffer ||
				obj == null || obj instanceof Object[][] ||
				obj instanceof java.util.Date);
		case 7: return (obj instanceof java.util.Date);
		default: throw new RuntimeException("Invalid index in ColumnType.");
		}
	}
	
	public static ColumnType getColumnTypeForIndex(int index) {
		ColumnType[] columnTypes = values();
		for (int i=0; i<columnTypes.length; i++) {
			if (columnTypes[i].index == index)
				return columnTypes[i];
		}
		return null;
	}
}
=======
    private final int nativeValue;

    static ColumnType fromNativeValue(int value)
    {
        if (0 <= value && value < byNativeValue.length) {
            ColumnType e = byNativeValue[value];
            if (e != null) return e;
        }
        throw new IllegalArgumentException("Bad native column type");
    }

    // Note that if this array is too small, an
    // IndexOutOfBoundsException will be thrown during class loading.
    private static ColumnType[] byNativeValue = new ColumnType[10];

    static {
        ColumnType[] columnTypes = values();
        for(int i=0; i<columnTypes.length; ++i) {
            int v = columnTypes[i].nativeValue;
            byNativeValue[v] = columnTypes[i];
        }
    }
}
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b09840;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a09840;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c09840
<<<<<<< MINE
	// Experimental
	
	public long findSorted(long columnIndex, long value) {
		return table.findSortedLong(columnIndex, value);
	}

=======
	// experimental
	public void moveLastOver(long rowIndex) {
		table.moveLastOver(rowIndex);
	}
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b21284;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a21284;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c21284
<<<<<<< MINE
    public boolean hasChanged() {
        return nativeHasChanged(nativePtr);
    }

    protected native boolean nativeHasChanged(long nativePtr);

    private long nativePtr;
    private boolean activeTransaction;
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b07640;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a07640;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c07640
<<<<<<< MINE
    public String rowToString(long rowIndex) {
        return nativeRowToString(nativePtr, rowIndex);
    }

    protected native String nativeRowToString(long nativeTablePtr, long rowIndex);

    private void throwImmutable()
    {
=======
    private void throwImmutable() {
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b10928;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a10928;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c10928
<<<<<<< MINE
    public TableSchema getSubTableSchema(long columnIndex) {
=======
    @Override
    public TableDefinition getSubTableDefinition(long columnIndex) {
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b16472;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a16472;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c16472
<<<<<<< MINE
     * Returns a view sorted by the specified column by the default order
     * @param columnIndex
     * @return
     */
    public TableView getSortedView(long columnIndex){
        TableView view = this.where().findAll();
        view.sort(columnIndex);
        return view;
    }

    /**
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b03584;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a03584;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c03584
<<<<<<< MINE
=======

    public boolean isNullLink(long columnIndex, long rowIndex) {
        return nativeIsNullLink(nativePtr, columnIndex, rowIndex);
    }

    protected native boolean nativeIsNullLink(long nativePtr, long columnIndex, long rowIndex);

    public void nullifyLink(long columnIndex, long rowIndex) {
        nativeNullifyLink(nativePtr, columnIndex, rowIndex);
    }

    protected native void nativeNullifyLink(long nativePtr, long columnIndex, long rowIndex);


>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b04924;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a04924;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c04924
<<<<<<< MINE
    static {
        CASTING_TYPES = new HashMap<String, String>();
        CASTING_TYPES.put("byte", "long");
        CASTING_TYPES.put("short", "long");
        CASTING_TYPES.put("int", "long");
        CASTING_TYPES.put("long", "long");
        CASTING_TYPES.put("float", "float");
        CASTING_TYPES.put("double", "double");
        CASTING_TYPES.put("boolean", "boolean");
        CASTING_TYPES.put("Byte", "long");
        CASTING_TYPES.put("Short", "long");
        CASTING_TYPES.put("Integer", "long");
        CASTING_TYPES.put("Long", "long");
        CASTING_TYPES.put("Float", "float");
        CASTING_TYPES.put("Double", "double");
        CASTING_TYPES.put("Boolean", "boolean");
        CASTING_TYPES.put("java.lang.String", "String");
        CASTING_TYPES.put("byte[]", "byte[]");
=======
        int columnIndex = 0;

        for (FieldInfo field : fields) {
            String originalType = field.fieldElement.asType().toString();
            String fullType = convertSimpleTypesToObject(originalType);
            String shortType = fullType.substring(fullType.lastIndexOf(".") + 1);

            String returnCast = "";
            String camelCaseFieldName = Character.toUpperCase(field.fieldName.charAt(0)) + field.fieldName.substring(1);

            if (originalType.equals("int")) {
                fullType = "long";
                shortType = "Long";
                returnCast = "(" + originalType + ")";
            } else if (shortType.equals("Integer")) {
                fullType = "long";
                shortType = "Long";
                returnCast = "(int)";
            } else if (shortType.equals("byte[]")) {
                shortType = "BinaryByteArray";
                returnCast = "(byte[])";
            }

            String getterStmt = "return " + returnCast + "row.get" + shortType + "( " + columnIndex + " )";

            String setterStmt = "row.set" + shortType + "( " + columnIndex + ", value )";

            if (!field.fieldElement.asType().getKind().isPrimitive())
            {
                if (!originalType.equals("java.lang.String") &&
                	!originalType.equals("java.lang.Long") &&
                	!originalType.equals("java.lang.Integer") &&
                	!originalType.equals("java.lang.Float") &&
                	!originalType.equals("java.lang.Double") &&
                	!originalType.equals("java.lang.Boolean") &&
                	!originalType.equals("java.util.Date") &&
                	!originalType.equals("byte[]")) {
                	
                	// We now know this is a type derived from RealmObject - 
                	// this has already been checked in the RealmProcessor
                	setterStmt = String.format("if (value != null) {row.setLink( %d, value.realmGetRow().getIndex() );}", columnIndex);
                	getterStmt = String.format("return realmGetRow().getLink(%d)==-1?null:realm.get(%s.class, realmGetRow().getLink(%d))", columnIndex, fullType, columnIndex);
                    field.columnType = "ColumnType.LINK";
                }
            }
            
            columnIndex++;

            writer.emitAnnotation("Override").beginMethod(originalType, "get" + camelCaseFieldName, EnumSet.of(Modifier.PUBLIC))
                    .emitStatement(getterStmt)
                    .endMethod();

            writer.emitAnnotation("Override").beginMethod("void", "set" + camelCaseFieldName, EnumSet.of(Modifier.PUBLIC),
                    originalType, "value")
                    .emitStatement(setterStmt)
                    .endMethod().emitEmptyLine();
        }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b04924;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a04924;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c04924
<<<<<<< MINE
        writer.emitImports(
                "io.realm.internal.ColumnType",
                "io.realm.internal.Table",
                "io.realm.internal.ImplicitTransaction",
                "io.realm.internal.Row",
                "io.realm.internal.LinkView",
                "io.realm.RealmLinkList",
                "io.realm.RealmObject",
                "io.realm.RealmList")
                .emitEmptyLine();

        // Begin the class definition
        writer.beginType(
                qualifiedGeneratedClassName, // full qualified name of the item to generate
                "class",                     // the type of the item
                EnumSet.of(Modifier.PUBLIC), // modifiers to apply
                className)                   // class to extend
                .emitEmptyLine();

        // Accessors
        ListIterator<VariableElement> iterator = fields.listIterator();
        while (iterator.hasNext()) {
            int columnNumber = iterator.nextIndex();
            VariableElement field = iterator.next();

            String fieldName = field.getSimpleName().toString();
            String fieldTypeCanonicalName = field.asType().toString();

            if (JAVA_TO_REALM_TYPES.containsKey(fieldTypeCanonicalName)) {
                /**
                 * Primitives and boxed types
                 */
                String realmType = JAVA_TO_REALM_TYPES.get(fieldTypeCanonicalName);
                String castingType = CASTING_TYPES.get(fieldTypeCanonicalName);

                // Getter
                writer.emitAnnotation("Override");
                writer.beginMethod(fieldTypeCanonicalName, "get" + capitaliseFirstChar(fieldName), EnumSet.of(Modifier.PUBLIC));
                writer.emitStatement(
                        "return (%s) row.get%s(%d)",
                        fieldTypeCanonicalName, realmType, columnNumber);
                writer.endMethod();
                writer.emitEmptyLine();

                // Setter
                writer.emitAnnotation("Override");
                writer.beginMethod("void", "set" + capitaliseFirstChar(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
                writer.emitStatement(
                        "row.set%s(%d, (%s) value)",
                        realmType, columnNumber, castingType);
                writer.endMethod();
            } else if (typeUtils.isAssignable(field.asType(), realmObject)) {
                /**
                 * Links
                 */

                // Getter
                writer.emitAnnotation("Override");
                writer.beginMethod(fieldTypeCanonicalName, "get" + capitaliseFirstChar(fieldName), EnumSet.of(Modifier.PUBLIC));
                writer.beginControlFlow("if (realmGetRow().isNullLink(%d))", columnNumber);
                writer.emitStatement("return null");
                writer.endControlFlow();
                writer.emitStatement(
                        "return realm.get(%s.class, realmGetRow().getLink(%d))",
                        fieldTypeCanonicalName, columnNumber);
                writer.endMethod();
                writer.emitEmptyLine();

                // Setter
                writer.emitAnnotation("Override");
                writer.beginMethod("void", "set" + capitaliseFirstChar(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
                writer.beginControlFlow("if (value == null)");
                writer.emitStatement("realmGetRow().nullifyLink(%d)", columnNumber);
                writer.endControlFlow();
                writer.emitStatement("realmGetRow().setLink(%d, value.realmGetRow().getIndex())", columnNumber);
                writer.endMethod();
            } else if (typeUtils.isAssignable(field.asType(), realmList)) {
                /**
                 * LinkLists
                 */
                String genericCanonicalType = ((DeclaredType) field.asType()).getTypeArguments().get(0).toString();
                String genericType;
                if (genericCanonicalType.contains(".")) {
                    genericType = genericCanonicalType.substring(genericCanonicalType.lastIndexOf('.') + 1);
                } else {
                    genericType = genericCanonicalType;
                }

                // Getter
                writer.emitAnnotation("Override");
                writer.beginMethod(fieldTypeCanonicalName, "get" + capitaliseFirstChar(fieldName), EnumSet.of(Modifier.PUBLIC));
                writer.emitStatement(
                        "return new RealmLinkList(%s.class, realmGetRow().getLinkList(%d), realm)",
                        genericType, columnNumber);
                writer.endMethod();
                writer.emitEmptyLine();

                // Setter
                writer.emitAnnotation("Override");
                writer.beginMethod("void", "set" + capitaliseFirstChar(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
                writer.emitStatement("LinkView links = realmGetRow().getLinkList(%d)", columnNumber);
                writer.beginControlFlow("if (value == null)");
                writer.emitStatement("return"); // TODO: delete all the links instead
                writer.endControlFlow();
                writer.beginControlFlow("for (RealmObject linkedObject : (RealmList<? extends RealmObject>) value)");
                writer.emitStatement("links.add(linkedObject.realmGetRow().getIndex())");
                writer.endControlFlow();
                writer.endMethod();
            } else {
                throw new UnsupportedOperationException(
                        String.format("Type %s of field %s is not supported", fieldTypeCanonicalName, fieldName));
            }
            writer.emitEmptyLine();
        }

        /**
         * initTable method
         */
        writer.beginMethod(
                "Table", // Return type
                "initTable", // Method name
                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
                "ImplicitTransaction", "transaction"); // Argument type & argument name

        writer.beginControlFlow("if(!transaction.hasTable(\"" + this.className + "\"))");
        writer.emitStatement("Table table = transaction.getTable(\"%s\")", this.className);
=======
        // Generate initTable method, which is used to create the datqbase table

        String tableName = this.className.toLowerCase(Locale.getDefault());

        writer.beginMethod("Table", "initTable", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC),
                "ImplicitTransaction", "transaction").
                beginControlFlow("if(!transaction.hasTable(\"" + tableName + "\"))").
                emitStatement("Table table = transaction.getTable(\"" + tableName + "\")");
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b19744;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a19744;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c19744
<<<<<<< MINE
    // Class metadata for generating proxy classes
    private Elements elementUtils;
    private Types typeUtils;
    private TypeMirror realmObject;
    private DeclaredType realmList;

    public RealmProxyClassGenerator(ProcessingEnvironment processingEnvironment, String className, String packageName, List<VariableElement> fields, List<VariableElement> fieldsToIndex, VariableElement primaryKey) {
=======
    public RealmProxyClassGenerator(ProcessingEnvironment processingEnvironment,
                                    String className, String packageName,
                                    List<VariableElement> fields,
                                    Map<String, String> getters, Map<String, String> setters,
                                    List<VariableElement> fieldsToIndex) {
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b19744;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a19744;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c19744
<<<<<<< MINE
=======

        /**
         * initTable method
         */
        writer.beginMethod(
                "Table", // Return type
                "initTable", // Method name
                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
                "ImplicitTransaction", "transaction"); // Argument type & argument name

        writer.beginControlFlow("if(!transaction.hasTable(\"" + TABLE_PREFIX + this.className + "\"))");
        writer.emitStatement("Table table = transaction.getTable(\"%s%s\")", TABLE_PREFIX, this.className);

        // For each field generate corresponding table index constant
        for (VariableElement field : fields) {
            String fieldName = field.getSimpleName().toString();
            String fieldTypeCanonicalName = field.asType().toString();
            String fieldTypeName;
            if (fieldTypeCanonicalName.contains(".")) {
                fieldTypeName = fieldTypeCanonicalName.substring(fieldTypeCanonicalName.lastIndexOf('.') + 1);
            } else {
                fieldTypeName = fieldTypeCanonicalName;
            }

            if (JAVA_TO_REALM_TYPES.containsKey(fieldTypeCanonicalName)) {
                writer.emitStatement("table.addColumn(%s, \"%s\")",
                        JAVA_TO_COLUMN_TYPES.get(fieldTypeCanonicalName),
                        fieldName);
            } else if (typeUtils.isAssignable(field.asType(), realmObject)) {
                writer.beginControlFlow("if (!transaction.hasTable(\"%s%s\"))", TABLE_PREFIX, fieldTypeName);
                writer.emitStatement("%s%s.initTable(transaction)", fieldTypeName, PROXY_SUFFIX);
                writer.endControlFlow();
                writer.emitStatement("table.addColumnLink(ColumnType.LINK, \"%s\", transaction.getTable(\"%s%s\"))",
                        fieldName, TABLE_PREFIX, fieldTypeName);
            } else if (typeUtils.isAssignable(field.asType(), realmList)) {
                String genericCanonicalType = ((DeclaredType) field.asType()).getTypeArguments().get(0).toString();
                String genericType;
                if (genericCanonicalType.contains(".")) {
                    genericType = genericCanonicalType.substring(genericCanonicalType.lastIndexOf('.') + 1);
                } else {
                    genericType = genericCanonicalType;
                }
                writer.beginControlFlow("if (!transaction.hasTable(\"%s%s\"))", TABLE_PREFIX, genericType);
                writer.emitStatement("%s%s.initTable(transaction)", genericType, PROXY_SUFFIX);
                writer.endControlFlow();
                writer.emitStatement("table.addColumnLink(ColumnType.LINK_LIST, \"%s\", transaction.getTable(\"%s%s\"))",
                        fieldName, TABLE_PREFIX, genericType);
            }
        }

        for (VariableElement field : fieldsToIndex) {
            String fieldName = field.getSimpleName().toString();
            writer.emitStatement("table.setIndex(table.getColumnIndex(\"%s\"))", fieldName);
        }

        writer.emitStatement("return table");
        writer.endControlFlow();
        writer.emitStatement("return transaction.getTable(\"%s%s\")", TABLE_PREFIX, this.className);
        writer.endMethod();
        writer.emitEmptyLine();

        /**
         * validateTable method
         */
        writer.beginMethod(
                "void", // Return type
                "validateTable", // Method name
                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
                "ImplicitTransaction", "transaction"); // Argument type & argument name

        writer.beginControlFlow("if(transaction.hasTable(\"" + TABLE_PREFIX + this.className + "\"))");
        writer.emitStatement("Table table = transaction.getTable(\"%s%s\")", TABLE_PREFIX, this.className);

        // verify number of columns
        writer.beginControlFlow("if(table.getColumnCount() != " + fields.size() + ")");
        writer.emitStatement("throw new IllegalStateException(\"Column count does not match\")");
        writer.endControlFlow();

        // create type dictionary for lookup
        writer.emitStatement("Map<String, ColumnType> columnTypes = new HashMap<String, ColumnType>()");
        writer.beginControlFlow("for(long i = 0; i < " + fields.size() + "; i++)");
        writer.emitStatement("columnTypes.put(table.getColumnName(i), table.getColumnType(i))");
        writer.endControlFlow();

        // For each field verify there is a corresponding column
        for (VariableElement field : fields) {
            String fieldName = field.getSimpleName().toString();
            String fieldTypeCanonicalName = field.asType().toString();
            String fieldTypeName;
            if (fieldTypeCanonicalName.contains(".")) {
                fieldTypeName = fieldTypeCanonicalName.substring(fieldTypeCanonicalName.lastIndexOf('.') + 1);
            } else {
                fieldTypeName = fieldTypeCanonicalName;
            }

            if (JAVA_TO_REALM_TYPES.containsKey(fieldTypeCanonicalName)) {
                // make sure types align
                writer.beginControlFlow("if (!columnTypes.containsKey(\"%s\"))", fieldName);
                writer.emitStatement("throw new IllegalStateException(\"Missing column '%s'\")", fieldName);
                writer.endControlFlow();
                writer.beginControlFlow("if (columnTypes.get(\"%s\") != %s)", fieldName, JAVA_TO_COLUMN_TYPES.get(fieldTypeCanonicalName));
                writer.emitStatement("throw new IllegalStateException(\"Invalid type '%s' for column '%s'\")",
                        fieldTypeName, fieldName);
                writer.endControlFlow();
            } else if (typeUtils.isAssignable(field.asType(), realmObject)) { // Links
                writer.beginControlFlow("if (!columnTypes.containsKey(\"%s\"))", fieldName);
                writer.emitStatement("throw new IllegalStateException(\"Missing column '%s'\")", fieldName);
                writer.endControlFlow();
                writer.beginControlFlow("if (columnTypes.get(\"%s\") != ColumnType.LINK)", fieldName);
                writer.emitStatement("throw new IllegalStateException(\"Invalid type '%s' for column '%s'\")",
                        fieldTypeName, fieldName);
                writer.endControlFlow();
                writer.beginControlFlow("if (!transaction.hasTable(\"%s%s\"))", TABLE_PREFIX, fieldTypeName);
                writer.emitStatement("throw new IllegalStateException(\"Missing table '%s%s' for column '%s'\")",
                        TABLE_PREFIX, fieldTypeName, fieldName);
                writer.endControlFlow();
                // TODO: Replace with a proper comparison
//                writer.emitStatement("Table table_%d = transaction.getTable(\"%s%s\")", columnNumber, TABLE_PREFIX, fieldTypeName);
//                writer.beginControlFlow("if (table.getLinkTarget(%d).equals(table_%d))", columnNumber, columnNumber);
//                writer.emitStatement("throw new IllegalStateException(\"Mismatching link tables for column '%s'\")",
//                        fieldName);
//                writer.endControlFlow();
            } else if (typeUtils.isAssignable(field.asType(), realmList)) { // Link Lists
                String genericCanonicalType = ((DeclaredType) field.asType()).getTypeArguments().get(0).toString();
                String genericType;
                if (genericCanonicalType.contains(".")) {
                    genericType = genericCanonicalType.substring(genericCanonicalType.lastIndexOf('.') + 1);
                } else {
                    genericType = genericCanonicalType;
                }
                writer.beginControlFlow("if(!columnTypes.containsKey(\"%s\"))", fieldName);
                writer.emitStatement("throw new IllegalStateException(\"Missing column '%s'\")", fieldName);
                writer.endControlFlow();
                writer.beginControlFlow("if(columnTypes.get(\"%s\") != ColumnType.LINK_LIST)", fieldName);
                writer.emitStatement("throw new IllegalStateException(\"Invalid type '%s' for column '%s'\")",
                        genericType, fieldName);
                writer.endControlFlow();
                writer.beginControlFlow("if (!transaction.hasTable(\"%s%s\"))", TABLE_PREFIX, genericType);
                writer.emitStatement("throw new IllegalStateException(\"Missing table '%s%s' for column '%s'\")",
                        TABLE_PREFIX, genericType, fieldName);
                writer.endControlFlow();
                // TODO: Replace with a proper comparison
//                writer.emitStatement("Table table_%d = transaction.getTable(\"%s%s\")", columnNumber, TABLE_PREFIX, genericType);
//                writer.beginControlFlow("if (table.getLinkTarget(%d).equals(table_%d))", columnNumber, columnNumber);
//                writer.emitStatement("throw new IllegalStateException(\"Mismatching link list tables for column '%s'\")",
//                        fieldName);
//                writer.endControlFlow();
            }
        }
        writer.endControlFlow();
        writer.endMethod();
        writer.emitEmptyLine();

        /**
         * getFieldNames method
         */
        writer.beginMethod("List<String>", "getFieldNames", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC));
        List<String> entries = new ArrayList<String>();
        for (VariableElement field : fields) {
            String fieldName = field.getSimpleName().toString();
            entries.add(String.format("\"%s\"", fieldName));
        }
        String statementSection = joinStringList(entries, ", ");
        writer.emitStatement("return Arrays.asList(%s)", statementSection);
        writer.endMethod();
        writer.emitEmptyLine();

        /**
         * toString method
         */
        writer.emitAnnotation("Override");
        writer.beginMethod("String", "toString", EnumSet.of(Modifier.PUBLIC));
        writer.emitStatement("StringBuilder stringBuilder = new StringBuilder(\"%s = [\")", className);
        for (VariableElement field : fields) {
            String fieldName = field.getSimpleName().toString();
            writer.emitStatement("stringBuilder.append(\"{%s:\")", fieldName);
            writer.emitStatement("stringBuilder.append(%s())", getters.get(fieldName));
            writer.emitStatement("stringBuilder.append(\"} \")", fieldName);
        }
        writer.emitStatement("stringBuilder.append(\"]\")");
        writer.emitStatement("return stringBuilder.toString()");
        writer.endMethod();
        writer.emitEmptyLine();

        /**
         * hashCode method
         */
        writer.emitAnnotation("Override");
        writer.beginMethod("int", "hashCode", EnumSet.of(Modifier.PUBLIC));
        writer.emitStatement("int result = 17");
        int counter = 0;
        for (VariableElement field : fields) {
            String fieldName = field.getSimpleName().toString();
            String fieldTypeCanonicalName = field.asType().toString();
            if (HASHCODE.containsKey(fieldTypeCanonicalName)) {
                for (String statement : HASHCODE.get(fieldTypeCanonicalName)) {
                    if (statement.contains("%d") && statement.contains("%s")) {
                        // This statement introduces a temporary variable
                        writer.emitStatement(statement, counter, getters.get(fieldName));
                    } else if(statement.contains("%d")) {
                        // This statement uses the temporary variable
                        writer.emitStatement(statement, counter, counter);
                    } else if (statement.contains("%s")) {
                        // This is a normal statement with only one assignment
                        writer.emitStatement(statement, getters.get(fieldName));
                    } else {
                        // This should never happen
                        throw new AssertionError();
                    }
                }
            } else {
                // Links and Link lists
                writer.emitStatement("%s temp_%d = %s()", fieldTypeCanonicalName, counter, getters.get(fieldName));
                writer.emitStatement("result = 31 * result + (temp_%d != null ? temp_%d.hashCode() : 0)", counter, counter);
            }
            counter++;
        }
        writer.emitStatement("return result");
        writer.endMethod();
        writer.emitEmptyLine();

        /**
         * equals method
         */
        String proxyClassName = className + PROXY_SUFFIX;
        writer.emitAnnotation("Override");
        writer.beginMethod("boolean", "equals", EnumSet.of(Modifier.PUBLIC), "Object", "o");
        writer.emitStatement("if (this == o) return true");
        writer.emitStatement("if (o == null || getClass() != o.getClass()) return false");
        writer.emitStatement("%s a%s = (%s)o", proxyClassName, className, proxyClassName);  // FooRealmProxy aFoo = (FooRealmProxy)o

        for (VariableElement field : fields) {
            String fieldName = field.getSimpleName().toString();
            String capFieldName = capitaliseFirstChar(fieldName);
            String fieldTypeCanonicalName = field.asType().toString();
            if (HOW_TO_EQUAL.containsKey(fieldTypeCanonicalName)) {
                switch (HOW_TO_EQUAL.get(fieldTypeCanonicalName)) {
                    case EQUALS_DIRECT: // if (getField() != aFoo.getField()) return false
                        writer.emitStatement("if (%s() != a%s.%s()) return false", getters.get(fieldName), className, getters.get(fieldName));
                        break;
                    case EQUALS_NULL: // if (getField() != null = !getField().equals(aFoo.getField()) : aFoo.getField() != null) return false
                        writer.emitStatement("if (%s() != null ? !%s().equals(a%s.%s()) : a%s.%s() != null) return false",
                                getters.get(fieldName),
                                getters.get(fieldName), className, getters.get(fieldName),
                                className, getters.get(fieldName));
                        break;
                    case EQUALS_ARRAY: // if (!Arrays.equals(getField(), aFoo.getField())) return false
                        writer.emitStatement("if (!Arrays.equals(%s(), a%s.%s())) return false",
                                getters.get(fieldName),
                                className, getters.get(fieldName));
                        break;
                    case EQUALS_COMPARE: // if (
                        writer.emitStatement("if (%s.compare(%s(), a%s.%s()) != 0) return false",
                                capitaliseFirstChar(fieldTypeCanonicalName), getters.get(fieldName), className,
                                getters.get(fieldName));
                        break;
                }
            }
            else if (typeUtils.isAssignable(field.asType(), realmObject) || typeUtils.isAssignable(field.asType(), realmList)) {
                writer.emitStatement("if (%s() != null ? !%s().equals(a%s.%s()) : a%s.%s() != null) return false",
                        getters.get(fieldName),
                        getters.get(fieldName), className, getters.get(fieldName),
                        className, getters.get(fieldName));
            }
        }
        writer.emitStatement("return true");
        writer.endMethod();
        writer.emitEmptyLine();

        // End the class definition
        writer.endType();
        writer.close();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b03980;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a03980;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c03980
<<<<<<< MINE
=======
import java.io.BufferedWriter;
import java.io.IOException;
import java.util.*;
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b03980;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a03980;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c03980
<<<<<<< MINE

        // Add JSON methods
        emitPopulateUsingJsonObjectMethod(writer);
        emitPopulateUsingJsonStreamMethod(writer);

        // End the class definition
        writer.endType();
        writer.close();
    }

    private void emitPopulateUsingJsonObjectMethod(JavaWriter writer) throws IOException {
        writer.emitAnnotation(Override.class);
        writer.beginMethod(
                "void",
                "populateUsingJsonObject",
                EnumSet.of(Modifier.PROTECTED),
                Arrays.asList("JSONObject", "json"),
                Arrays.asList("JSONException"));

        for (VariableElement field : fields) {
            String fieldName = field.getSimpleName().toString();
            String fieldTypeCanonicalName = field.asType().toString();
            if (typeUtils.isAssignable(field.asType(), realmObject)) {
                RealmJsonTypeHelper.emitFillRealmObjectWithJsonValue(
                        fieldName,
                        fieldTypeCanonicalName,
                        writer);

            } else if (typeUtils.isAssignable(field.asType(), realmList)) {
                RealmJsonTypeHelper.emitFillRealmListWithJsonValue(
                        fieldName,
                        ((DeclaredType) field.asType()).getTypeArguments().get(0).toString(),
                        writer);

            } else {
                RealmJsonTypeHelper.emitFillJavaTypeWithJsonValue(
                        fieldName,
                        fieldTypeCanonicalName,
                        writer);
            }

        }

        writer.endMethod();
        writer.emitEmptyLine();
    }

    private void emitPopulateUsingJsonStreamMethod(JavaWriter writer) throws IOException {
        writer.emitAnnotation(Override.class);
        writer.beginMethod(
                "void",
                "populateUsingJsonStream",
                EnumSet.of(Modifier.PROTECTED),
                Arrays.asList("JsonReader", "reader"),
                Arrays.asList("IOException"));

        writer.emitStatement("reader.beginObject()");
        writer.beginControlFlow("while (reader.hasNext())");
        writer.emitStatement("String name = reader.nextName()");

        for (int i = 0; i < fields.size(); i++) {
            VariableElement field = fields.get(i);
            String fieldName = field.getSimpleName().toString();
            String fieldTypeCanonicalName = field.asType().toString();

            if (i == 0) {
                writer.beginControlFlow("if (name.equals(\"%s\") && reader.peek() != JsonToken.NULL)", fieldName);
            } else {
                writer.nextControlFlow("else if (name.equals(\"%s\")  && reader.peek() != JsonToken.NULL)", fieldName);
            }

            if (typeUtils.isAssignable(field.asType(), realmObject)) {
                RealmJsonTypeHelper.emitFillRealmObjectFromStream(
                        fieldName,
                        fieldTypeCanonicalName,
                        writer);

            } else if (typeUtils.isAssignable(field.asType(), realmList)) {
                RealmJsonTypeHelper.emitFillRealmListFromStream(
                        fieldName,
                        ((DeclaredType) field.asType()).getTypeArguments().get(0).toString(),
                        writer);

            } else {
                RealmJsonTypeHelper.emitFillJavaTypeFromStream(
                        fieldName,
                        fieldTypeCanonicalName,
                        writer);
            }
        }

        writer.nextControlFlow("else");
        writer.emitStatement("reader.skipValue()");
        writer.endControlFlow();
        writer.endControlFlow();
        writer.emitStatement("reader.endObject()");
        writer.endMethod();
        writer.emitEmptyLine();
    }

    private static String capitaliseFirstChar(String input) {
        return input.substring(0, 1).toUpperCase() + input.substring(1);
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b10436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a10436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c10436
<<<<<<< MINE
    // get the table name as it is in the associated publicKeyGroup.
    protected String getName() {
=======
    /**
     * Return the table name as it is in the associated group.
     *
     * @return Name of the the table or null if it not part of a group.
     */
    public String getName() {
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b10436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a10436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c10436
<<<<<<< MINE
import java.util.ArrayList;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
=======
import java.lang.Override;
import java.lang.String;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Set;
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b10436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a10436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c10436
<<<<<<< MINE
        emitToStringMethod(writer);
        emitHashCodeMethod(writer);
        emitEqualsMethod(writer);

        // End the class definition
        writer.endType();
        writer.close();
    }

    private void emitAccessors(JavaWriter writer) throws IOException {
=======
        emitPopulateUsingJsonObjectMethod(writer);
        emitPopulateUsingJsonStreamMethod(writer);
        emitCopyToRealmMethod(writer);
        emitToStringMethod(writer);
        emitHashcodeMethod(writer);
        emitEqualsMethod(writer);

        // End the class definition
        writer.endType();
        writer.close();
    }

    private void emitAccessors(JavaWriter writer) throws IOException {
        // Accessors
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b10436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a10436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c10436
<<<<<<< MINE
    private void emitToStringMethod(JavaWriter writer) throws IOException {
        writer.emitAnnotation("Override");
        writer.beginMethod("String", "toString", EnumSet.of(Modifier.PUBLIC));
        writer.emitStatement("StringBuilder stringBuilder = new StringBuilder(\"%s = [\")", className);
=======
    private void emitCopyToRealmMethod(JavaWriter writer) throws IOException {
        writer.beginMethod(
                className, // Return type
                "copyToRealm", // Method name
                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
                "Realm", "realm", className, "object"); // Argument type & argument name

        writer.emitStatement("%s realmObject = realm.createObject(%s.class)", className, className);

>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b10436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a10436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c10436
<<<<<<< MINE
    private void emitHashCodeMethod(JavaWriter writer) throws IOException {
=======
    private void emitHashcodeMethod(JavaWriter writer) throws IOException {
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b02284;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a02284;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c02284
<<<<<<< MINE
import java.util.EnumSet;
import java.util.HashMap;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;

import java.lang.String;
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b02284;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a02284;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c02284
<<<<<<< MINE
=======
import java.util.EnumSet;
import java.util.HashMap;
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b21236;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a21236;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c21236
<<<<<<< MINE
        return allObjects(clazz, new String[] {fieldName1, fieldName2, fieldName3}, new boolean[] {sortAscending1, sortAscending2, sortAscending3});
    }

    /**
     * Get all objects of a specific Class sorted by multiple fields.
     *
     * @param clazz the Class to get objects of.
     * @param sortAscending sort ascending if SORT_ORDER_ASCENDING, sort descending if SORT_ORDER_DESCENDING.
     * @param fieldNames an array of fieldnames to sort objects by.
     *        The objects are first sorted by fieldNames[0], then by fieldNames[1] and so forth.  
     * @return A sorted RealmResults containing the objects.
     * @throws java.lang.IllegalArgumentException if a field name does not exist.
     */
    @Deprecated
    public <E extends RealmObject> RealmResults<E> allObjects(Class<E> clazz, String fieldNames[], boolean sortAscending[]) {
        return allObjectsSorted(clazz, fieldNames, sortAscending);
=======
        return allObjectsSorted(clazz, new String[] {fieldName1, fieldName2, fieldName3},
                new boolean[] {sortAscending1, sortAscending2, sortAscending3});
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b05624;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a05624;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c05624
<<<<<<< MINE
    @Deprecated
    public <E extends RealmObject> RealmResults<E> allObjects(Class<E> clazz, String fieldName, boolean sortAscending) {
        checkIfValid();
        Table table = getTable(clazz);
        TableView.Order order = sortAscending ? TableView.Order.ascending : TableView.Order.descending;
        Long columnIndex = columnIndices.get(simpleClassNames.get(clazz)).get(fieldName);
        if (columnIndex == null || columnIndex < 0) {
            throw new IllegalArgumentException(String.format("Field name '%s' does not exist.", fieldName));
        }

        TableView tableView = table.getSortedView(columnIndex, order);
        return new RealmResults<E>(this, tableView, clazz);
    }

    /**
     * Get all objects of a specific Class sorted by a field.  If no objects exist, the returned
     * RealmResults will not be null. The RealmResults.size() to check the number of objects instead.
     *
     * @param clazz the Class to get objects of.
     * @param fieldName the field name to sort by.
     * @param sortAscending sort ascending if SORT_ORDER_ASCENDING, sort descending if SORT_ORDER_DESCENDING.
     * @return A sorted RealmResults containing the objects.
     * @throws java.lang.IllegalArgumentException if field name does not exist.
     */
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b05624;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a05624;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c05624
<<<<<<< MINE
    @Deprecated
    public <E extends RealmObject> RealmResults<E> allObjects(Class<E> clazz, String fieldName1, boolean sortAscending1,
                                                              String fieldName2, boolean sortAscending2) {
        return allObjects(clazz, new String[] {fieldName1, fieldName2}, new boolean[] {sortAscending1, sortAscending2});
    }

    /**
     * Get all objects of a specific class sorted by two field names.  If no objects exist, the
     * returned RealmResults will not be null. The RealmResults.size() to check the number of
     * objects instead.
     *
     * @param clazz the class ti get objects of.
     * @param fieldName1 first field name to sort by.
     * @param sortAscending1 sort order for first field.
     * @param fieldName2 second field name to sort by.
     * @param sortAscending2 sort order for second field.
     * @return A sorted RealmResults containing the objects.
     * @throws java.lang.IllegalArgumentException if a field name does not exist.
     */
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b05624;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a05624;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c05624
<<<<<<< MINE
        return allObjects(clazz, new String[] {fieldName1, fieldName2}, new boolean[] {sortAscending1, sortAscending2});
    }

    /**
     * Get all objects of a specific class sorted by two specific field names.  If no objects exist,
     * the returned RealmResults will not be null. The RealmResults.size() to check the number of
     * objects instead.
     *
     * @param clazz the class ti get objects of.
     * @param fieldName1 first field name to sort by.
     * @param sortAscending1 sort order for first field.
     * @param fieldName2 second field name to sort by.
     * @param sortAscending2 sort order for second field.
     * @param fieldName3 third field name to sort by.
     * @param sortAscending3 sort order for third field.
     * @return A sorted RealmResults containing the objects.
     * @throws java.lang.IllegalArgumentException if a field name does not exist.
     */
    @Deprecated
    public <E extends RealmObject> RealmResults<E> allObjects(Class<E> clazz, String fieldName1, boolean sortAscending1,
                                                              String fieldName2, boolean sortAscending2,
                                                              String fieldName3, boolean sortAscending3) {
        return allObjects(clazz, new String[] {fieldName1, fieldName2, fieldName3}, new boolean[] {sortAscending1, sortAscending2, sortAscending3});
=======
        return allObjectsSorted(clazz, new String[] {fieldName1, fieldName2}, new boolean[] {sortAscending1,
                sortAscending2});
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b05624;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a05624;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c05624
<<<<<<< MINE
        return allObjects(clazz, new String[] {fieldName1, fieldName2, fieldName3}, new boolean[] {sortAscending1, sortAscending2, sortAscending3});
    }

    /**
     * Get all objects of a specific Class sorted by multiple fields.  If no objects exist, the
     * returned RealmResults will not be null. The RealmResults.size() to check the number of
     * objects instead.
     *
     * @param clazz the Class to get objects of.
     * @param sortAscending sort ascending if SORT_ORDER_ASCENDING, sort descending if SORT_ORDER_DESCENDING.
     * @param fieldNames an array of fieldnames to sort objects by.
     *        The objects are first sorted by fieldNames[0], then by fieldNames[1] and so forth.  
     * @return A sorted RealmResults containing the objects.
     * @throws java.lang.IllegalArgumentException if a field name does not exist.
     */
    @Deprecated
    public <E extends RealmObject> RealmResults<E> allObjects(Class<E> clazz, String fieldNames[], boolean sortAscending[]) {
        // FIXME: This is not an optimal implementation. When core's Table::get_sorted_view() supports
        // FIXME: multi-column sorting, we can rewrite this method to a far better implementation.
        RealmResults<E> results = this.allObjects(clazz);
        results.sort(fieldNames, sortAscending);
        return results;
=======
        return allObjectsSorted(clazz, new String[] {fieldName1, fieldName2, fieldName3},
                new boolean[] {sortAscending1, sortAscending2, sortAscending3});
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b12172;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a12172;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c12172
<<<<<<< MINE
        return allObjects(clazz, new String[]{fieldName1, fieldName2}, new boolean[]{sortAscending1, sortAscending2});
=======
        return allObjectsSorted(clazz, new String[] {fieldName1, fieldName2}, new boolean[] {sortAscending1,
                sortAscending2});
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b12172;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a12172;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c12172
<<<<<<< MINE
    private <E extends RealmObject> Class<? extends RealmObject> getRealmClassFromObject(E object) {
        if (object.realm != null) {
            // This is already a proxy object, get superclass instead
            // INVARIANT: We don't support subclasses yet so super class is always correct type
            return (Class<? extends RealmObject>) object.getClass().getSuperclass();
        } else {
            return object.getClass();
        }
    }

    private <E extends RealmObject> E copyOrUpdate(E object, boolean update) {
        Class<? extends RealmObject> realmClass = getRealmClassFromObject(object);
        Class<?> proxyClass = getProxyClass(realmClass);
        Method method = insertOrUpdateMethods.get(realmClass);
        if (method == null) {
            try {
                method = proxyClass.getMethod("copyOrUpdate", new Class[]{Realm.class, realmClass, boolean.class});
            } catch (NoSuchMethodException e) {
                throw new RealmException("Could not find the copyOrUpdate() method in generated proxy class for " + proxyClass.getName() + ": " + APT_NOT_EXECUTED_MESSAGE, e);
            }
            insertOrUpdateMethods.put(proxyClass, method);
        }
        try {
            Object result = method.invoke(null, this, object, update);
            return (E) result;
        } catch (IllegalAccessException e) {
            throw new RealmException("Could not execute the copyToRealm method : " + APT_NOT_EXECUTED_MESSAGE, e);
        } catch (InvocationTargetException e) {
            throw new RealmException("An exception was thrown in the copyToRealm method in the proxy class  " + proxyClass.getName() + ": " + APT_NOT_EXECUTED_MESSAGE, e);
        }
    }

    private <E extends RealmObject> boolean isObjectInRealm(E object) {
        return (object.realm != null && object.realm.id == this.id);
    }

    private <E extends RealmObject> void checkNotNullObject(E object) {
        if (object == null) {
            throw new IllegalArgumentException("Null objects cannot be copied into Realm.");
        }
    }

    private <E extends RealmObject> void checkHasPrimaryKey(E object) {
        if (!getTable(object.getClass()).hasPrimaryKey()) {
            throw new IllegalArgumentException("RealmObject has no @PrimaryKey defined: " + simpleClassNames.get(object));
        }
    }

    private <E extends RealmObject> void checkHasPrimaryKey(Class<E> clazz) {
        if (!getTable(clazz).hasPrimaryKey()) {
            throw new IllegalArgumentException("A RealmObject with no @PrimaryKey cannot be updated: " + clazz.toString());
        }
    }

    @SuppressWarnings("UnusedDeclaration")
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b19496;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a19496;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c19496
<<<<<<< MINE
                        .emitStatement("%s cache%s = (%s) cache.get(%s)", Utils.getFieldTypeSimpleName(field), fieldName, Utils.getFieldTypeSimpleName(field), fieldName)
                        .beginControlFlow("if (cache%s != null)", fieldName)
                            .emitStatement("realmObject.%s(cache%s)", setters.get(fieldName), fieldName)
                        .nextControlFlow("else")
                            .emitStatement("realmObject.%s(%s.copyOrUpdate(realm, %s, realm.getTable(%s.class).hasPrimaryKey(), cache))",
                                    setters.get(fieldName),
                                    Utils.getProxyClassSimpleName(field),
                                    fieldName,
                                    Utils.getFieldTypeSimpleName(field)
                            )
                        .endControlFlow()
=======
                        .emitStatement("realmObject.%s(%s.copyOrUpdate(realm, %s, true))",
                                setters.get(fieldName),
                                Utils.getProxyClassSimpleName(field),
                                fieldName,
                                Utils.getFieldTypeSimpleName(field)
                        )
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b12564;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a12564;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c12564
<<<<<<< MINE
=======
    private final RealmJson realmJson = getRealmJson();
    private final Map<Class<?>, String> simpleClassNames = new HashMap<Class<?>, String>(); // Map between original class and their class name
    private final Map<String, Class<?>> generatedClasses = new HashMap<String, Class<?>>(); // Map between generated class names and their implementation
    private final Map<Class<?>, Constructor> constructors = new HashMap<Class<?>, Constructor>();
    private final Map<Class<?>, Method> initTableMethods = new HashMap<Class<?>, Method>();
    private final Map<Class<?>, Method> insertOrUpdateMethods = new HashMap<Class<?>, Method>();
    private final Map<Class<?>, Constructor> generatedConstructors = new HashMap<Class<?>, Constructor>();

    // Maps classes to the name of the proxied class. Examples: Dog.class -> Dog, DogRealmProxy -> Dog
    private final Map<Class<?>, String> proxiedClassNames = new HashMap<Class<?>, String>();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b12564;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a12564;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c12564
<<<<<<< MINE
    public Table getTable(Class<? extends RealmObject> clazz) {
        return transaction.getTable(proxyMediator.getTableName(clazz));
=======
    public Table getTable(Class<?> clazz) {
        final String proxySuffix = "RealmProxy";
        String proxiedClassName = proxiedClassNames.get(clazz);
        if (proxiedClassName == null) {
            String classSimpleName = clazz.getSimpleName();
            proxiedClassName = classSimpleName.replace(proxySuffix, "");
            proxiedClassNames.put(clazz, proxiedClassName);
        }
        return transaction.getTable(TABLE_PREFIX + proxiedClassName);
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b12564;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a12564;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c12564
<<<<<<< MINE
    private <E extends RealmObject> E getProxyClass(Class<E> clazz) {
        return proxyMediator.newInstance(clazz);
=======
    private Class<?> getProxyClass(Class<?> clazz) {

        String simpleClassName = getClassSimpleName(clazz);
        String generatedClassName = getProxyClassName(simpleClassName);

        Class<?> generatedClass = generatedClasses.get(generatedClassName);
        if (generatedClass == null) {
            try {
                generatedClass = Class.forName(generatedClassName);
            } catch (ClassNotFoundException e) {
                throw new RealmException("Could not find the generated proxy class: " + APT_NOT_EXECUTED_MESSAGE);
            }
            generatedClasses.put(generatedClassName, generatedClass);
        }

        return generatedClass;
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b12564;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a12564;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c12564
<<<<<<< MINE
    boolean contains(Class<? extends RealmObject> clazz) {
        return defaultModule.getModuleClasses().contains(clazz);
=======
    boolean contains(Class<?> clazz) {
        return transaction.hasTable(TABLE_PREFIX + getClassSimpleName(clazz));
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b12412;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a12412;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c12412
<<<<<<< MINE
        Table table = getTable(clazz);
        long rowIndex = table.addEmptyRow();
        return get(clazz, rowIndex);
=======
        Table table = initTable(clazz);
        long rowIndex = table.addEmptyRow();
        return get(clazz, rowIndex);
    }

    /**
     * Creates a new object inside the Realm with the Primary key value initially set.
     * If the value violates the primary key constraint, no object will be added and a
     * {@link RealmException} will be thrown.
     *
     * @param clazz The Class of the object to create
     * @param primaryKeyValue Value for the primary key field.
     * @return The new object
     * @throws {@link RealmException} if object could not be created.
     */
    <E extends RealmObject> E createObject(Class<E> clazz, Object primaryKeyValue) {
        Table table = initTable(clazz);
        long rowIndex = table.addEmptyRowWithPrimaryKey(primaryKeyValue);
        return get(clazz, rowIndex);
    }

    private <E extends RealmObject> Table initTable(Class<E> clazz) {
        Table table = tables.get(clazz);
        if (table == null) {
            Class<?> generatedClass = getProxyClass(clazz);

            Method method = initTableMethods.get(generatedClass);
            if (method == null) {
                try {
                    method = generatedClass.getMethod("initTable", new Class[]{ImplicitTransaction.class});
                } catch (NoSuchMethodException e) {
                    throw new RealmException("Could not find the initTable() method in generated proxy class: " + APT_NOT_EXECUTED_MESSAGE);
                }
                initTableMethods.put(generatedClass, method);
            }

            try {
                table = (Table) method.invoke(null, transaction);
                tables.put(clazz, table);
            } catch (IllegalAccessException e) {
                throw new RealmException("Could not launch the initTable method: " + APT_NOT_EXECUTED_MESSAGE);
            } catch (InvocationTargetException e) {
                e.printStackTrace();
                throw new RealmException("An exception occurred while running the initTable method: " + APT_NOT_EXECUTED_MESSAGE);
            }
        }

        return table;
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b12412;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a12412;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c12412
<<<<<<< MINE
    public static Simple copyOrUpdate(Realm realm, Simple object, boolean update, Map<RealmObject,RealmObjectProxy> cache) {
=======
    public static Simple copyOrUpdate(Realm realm, Simple object, boolean update, Map<RealmObject,RealmObject> cache) {
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b12412;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a12412;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c12412
<<<<<<< MINE
    public static Simple copy(Realm realm, Simple newObject, boolean update, Map<RealmObject,RealmObjectProxy> cache) {
=======
    public static Simple copy(Realm realm, Simple newObject, boolean update, Map<RealmObject,RealmObject> cache) {
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b12412;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a12412;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c12412
<<<<<<< MINE
    public static Booleans copyOrUpdate(Realm realm, Booleans object, boolean update, Map<RealmObject,RealmObjectProxy> cache) {
=======
    public static Booleans copyOrUpdate(Realm realm, Booleans object, boolean update, Map<RealmObject,RealmObject> cache) {
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b12412;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a12412;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c12412
<<<<<<< MINE
    public static Booleans copy(Realm realm, Booleans newObject, boolean update, Map<RealmObject,RealmObjectProxy> cache) {
=======
    public static Booleans copy(Realm realm, Booleans newObject, boolean update, Map<RealmObject,RealmObject> cache) {
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b12412;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a12412;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c12412
<<<<<<< MINE
    public static AllTypes copy(Realm realm, AllTypes newObject, boolean update, Map<RealmObject,RealmObjectProxy> cache) {
        AllTypes realmObject = realm.createObject(AllTypes.class);
        cache.put(newObject, (RealmObjectProxy) realmObject);
=======
    public static AllTypes copy(Realm realm, AllTypes newObject, boolean update, Map<RealmObject,RealmObject> cache) {
        AllTypes realmObject = realm.createObject(AllTypes.class, newObject.getColumnString());
        cache.put(newObject, realmObject);
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b12412;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a12412;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c12412
<<<<<<< MINE
        writer.emitStatement("%s realmObject = realm.createObject(%s.class)", className, className);
        writer.emitStatement("cache.put(newObject, (RealmObjectProxy) realmObject)");
=======
        if (metadata.hasPrimaryKey()) {
            writer.emitStatement("%s realmObject = realm.createObject(%s.class, newObject.%s())", className, className, metadata.getPrimaryKeyGetter());
        } else {
            writer.emitStatement("%s realmObject = realm.createObject(%s.class)", className, className);
        }
        writer.emitStatement("cache.put(newObject, realmObject)");
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b20836;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a20836;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c20836
<<<<<<< MINE
                proxyMediator.validateTable(modelClass, realm.transaction);
                columnIndices.addClass(modelClass, proxyMediator.getColumnIndices(modelClass));
=======

                // validate created table
                Method validateMethod;
                try {
                    validateMethod = generatedClass.getMethod("validateTable", new Class[]{ImplicitTransaction.class});
                } catch (NoSuchMethodException e) {
                    throw new RealmException("Could not find the validateTable method in the generated " + generatedClassName + " class: " + APT_NOT_EXECUTED_MESSAGE);
                }
                try {
                    validateMethod.invoke(null, realm.transaction);
                } catch (IllegalAccessException e) {
                    throw new RealmException("Could not execute the validateTable method in the " + generatedClassName + " class: " + APT_NOT_EXECUTED_MESSAGE);
                } catch (InvocationTargetException e) {
                    throw new RealmMigrationNeededException(e.getMessage(), e);
                }

                // Populate the columnIndices table
                Method columnIndiciesMethod;
                try {
                    columnIndiciesMethod = generatedClass.getMethod("getColumnIndices");
                } catch (NoSuchMethodException e) {
                    throw new RealmException("Could not find the getColumnIndices method in the generated " + generatedClassName + " class: " + APT_NOT_EXECUTED_MESSAGE);
                }
                Map<String,Long> indices;
                try {
                    //noinspection unchecked
                    indices = (Map<String,Long>) columnIndiciesMethod.invoke(null);
                } catch (IllegalAccessException e) {
                    throw new RealmException("Could not execute the getColumnIndices method in the generated " + generatedClassName + " class", e);
                } catch (InvocationTargetException e) {
                    throw new RealmException("An exception was thrown in the getColumnIndices method in the generated " + generatedClassName + " class", e);
                }
                realm.columnIndices.addClass((Class<? extends RealmObject>) generatedClass.getSuperclass(), indices);
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b14180;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a14180;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c14180
<<<<<<< MINE
    public static Simple copyOrUpdate(Realm realm, Simple object, boolean update, Map<RealmObject,RealmObjectProxy> cache) {
=======
    public static Simple copyOrUpdate(Realm realm, Simple object, boolean update, Map<RealmObject,RealmObject> cache) {
        if (object.realm != null && object.realm.getId() == realm.getId()) {
            return object;
        }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b14180;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a14180;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c14180
<<<<<<< MINE
    public static Booleans copyOrUpdate(Realm realm, Booleans object, boolean update, Map<RealmObject,RealmObjectProxy> cache) {
=======
    public static Booleans copyOrUpdate(Realm realm, Booleans object, boolean update, Map<RealmObject,RealmObject> cache) {
        if (object.realm != null && object.realm.getId() == realm.getId()) {
            return object;
        }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b14180;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a14180;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c14180
<<<<<<< MINE
    public static AllTypes copyOrUpdate(Realm realm, AllTypes object, boolean update, Map<RealmObject,RealmObjectProxy> cache) {
=======
    public static AllTypes copyOrUpdate(Realm realm, AllTypes object, boolean update, Map<RealmObject,RealmObject> cache) {
        if (object.realm != null && object.realm.getId() == realm.getId()) {
            return object;
        }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b12760;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a12760;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c12760
<<<<<<< MINE
            proxyMediator.populateUsingJsonStream(obj, reader);
            copyToRealmOrUpdate(obj);
        } catch (RuntimeException e) {
            throw new RealmException("Could not create Json object from string", e);
=======
            scanner = getFullStringScanner(in);
            JSONObject json = new JSONObject(scanner.next());
            return realmJson.createOrUpdateUsingJsonObject(clazz, this, json, true);
        } catch (JSONException e) {
            throw new RealmException("Failed to read JSON", e);
        } finally {
            if (scanner != null) {
                scanner.close();
            }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b09176;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a09176;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c09176
<<<<<<< MINE
    private static final Map<Integer, AtomicInteger> openRealms = new ConcurrentHashMap<Integer, AtomicInteger>();
=======
    private static final Map<String, AtomicInteger> openRealms = new ConcurrentHashMap<String, AtomicInteger>();
    private static final String APT_NOT_EXECUTED_MESSAGE = "Annotation processor may not have been executed.";
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b09176;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a09176;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c09176
<<<<<<< MINE
                proxyMediator.validateTable(modelClass, realm.transaction);
                realm.columnIndices.addClass(modelClass, proxyMediator.getColumnIndices(modelClass));
=======

                // validate created table
                Method validateMethod;
                try {
                    validateMethod = generatedClass.getMethod("validateTable", new Class[]{ImplicitTransaction.class});
                } catch (NoSuchMethodException e) {
                    throw new RealmException("Could not find the validateTable method in the generated " + generatedClassName + " class: " + APT_NOT_EXECUTED_MESSAGE);
                }
                try {
                    validateMethod.invoke(null, realm.transaction);
                } catch (IllegalAccessException e) {
                    throw new RealmException("Could not execute the validateTable method in the " + generatedClassName + " class: " + APT_NOT_EXECUTED_MESSAGE);
                } catch (InvocationTargetException e) {
                    throw new RealmMigrationNeededException(realm.getPath(), e.getMessage(), e);
                }

                // Populate the columnIndices table
                Method columnIndiciesMethod;
                try {
                    columnIndiciesMethod = generatedClass.getMethod("getColumnIndices");
                } catch (NoSuchMethodException e) {
                    throw new RealmException("Could not find the getColumnIndices method in the generated " + generatedClassName + " class: " + APT_NOT_EXECUTED_MESSAGE);
                }
                Map<String,Long> indices;
                try {
                    //noinspection unchecked
                    indices = (Map<String,Long>) columnIndiciesMethod.invoke(null);
                } catch (IllegalAccessException e) {
                    throw new RealmException("Could not execute the getColumnIndices method in the generated " + generatedClassName + " class", e);
                } catch (InvocationTargetException e) {
                    throw new RealmException("An exception was thrown in the getColumnIndices method in the generated " + generatedClassName + " class", e);
                }
                realm.columnIndices.addClass((Class<? extends RealmObject>) generatedClass.getSuperclass(), indices);
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b09176;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a09176;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c09176
<<<<<<< MINE
    public static Simple copyOrUpdate(Realm realm, Simple object, boolean update, Map<RealmObject,RealmObjectProxy> cache) {
        if (object.realm != null && object.realm.getId() == realm.getId()) {
=======
    public static Simple copyOrUpdate(Realm realm, Simple object, boolean update, Map<RealmObject,RealmObject> cache) {
        if (object.realm != null && object.realm.getPath().equals(realm.getPath())) {
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b09176;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a09176;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c09176
<<<<<<< MINE
    public static Booleans copyOrUpdate(Realm realm, Booleans object, boolean update, Map<RealmObject,RealmObjectProxy> cache) {
        if (object.realm != null && object.realm.getId() == realm.getId()) {
=======
    public static Booleans copyOrUpdate(Realm realm, Booleans object, boolean update, Map<RealmObject,RealmObject> cache) {
        if (object.realm != null && object.realm.getPath().equals(realm.getPath())) {
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b09176;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a09176;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c09176
<<<<<<< MINE
    public static AllTypes copyOrUpdate(Realm realm, AllTypes object, boolean update, Map<RealmObject,RealmObjectProxy> cache) {
		if (object.realm != null && object.realm.getId() == realm.getId()) {
=======
    public static AllTypes copyOrUpdate(Realm realm, AllTypes object, boolean update, Map<RealmObject,RealmObject> cache) {
        if (object.realm != null && object.realm.getPath().equals(realm.getPath())) {
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b20904;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a20904;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c20904
<<<<<<< MINE
    private final List<RealmChangeListener> changeListeners = new ArrayList<RealmChangeListener>();
=======
    // Maps classes to the name of the proxied class. Examples: Dog.class -> Dog, DogRealmProxy -> Dog
    private final Map<Class<?>, String> proxiedClassNames = new HashMap<Class<?>, String>();
    private final List<WeakReference<RealmChangeListener>> changeListeners = new ArrayList<WeakReference<RealmChangeListener>>();
    private final Map<Class<?>, Table> tables = new HashMap<Class<?>, Table>();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b17768;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a17768;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c17768
<<<<<<< MINE
=======
import java.util.HashSet;
import java.util.Iterator;
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b17768;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a17768;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c17768
<<<<<<< MINE
    private static RealmConfiguration defaultConfiguration;

    private static final String APT_NOT_EXECUTED_MESSAGE = "Annotation processor may not have been executed.";
=======
    // Maps ids to a boolean set to true if the Realm is open. This is only needed by deleteRealmFile
    private static final Map<String, AtomicInteger> openRealms = new ConcurrentHashMap<String, AtomicInteger>();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b17768;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a17768;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c17768
<<<<<<< MINE
    // Maps classes to the name of the proxied class. Examples: Dog.class -> Dog, DogRealmProxy -> Dog
    private final Map<Class<?>, String> proxiedClassNames = new HashMap<Class<?>, String>();
    private final List<RealmChangeListener> changeListeners = new ArrayList<RealmChangeListener>();
    private final Map<Class<?>, Table> tables = new HashMap<Class<?>, Table>();
=======
    private final List<WeakReference<RealmChangeListener>> changeListeners = new ArrayList<WeakReference<RealmChangeListener>>();
    private static RealmProxyMediator proxyMediator = getDefaultMediator();

>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b17768;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a17768;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c17768
<<<<<<< MINE
    private static void initializeRealm(Realm realm, RealmConfiguration config) {
        Class<?> validationClass;
        try {
            validationClass = Class.forName("io.realm.ValidationList");
        } catch (ClassNotFoundException e) {
            throw new RealmException("Could not find the generated ValidationList class: " + APT_NOT_EXECUTED_MESSAGE);
        }
        Method getProxyClassesMethod;
        try {
            getProxyClassesMethod = validationClass.getMethod("getProxyClasses");
        } catch (NoSuchMethodException e) {
            throw new RealmException("Could not find the getProxyClasses method in the ValidationList class: " + APT_NOT_EXECUTED_MESSAGE);
        }
        List<String> proxyClasses;
        try {
            proxyClasses = (List<String>) getProxyClassesMethod.invoke(null);
        } catch (IllegalAccessException e) {
            throw new RealmException("Could not execute the getProxyClasses method in the ValidationList class: " + APT_NOT_EXECUTED_MESSAGE);
        } catch (InvocationTargetException e) {
            throw new RealmException("An exception was thrown in the getProxyClasses method in the ValidationList class: " + APT_NOT_EXECUTED_MESSAGE);
        }

        // Custom schema overrides any schema already defined
        Set<Class<? extends RealmObject>> customSpec = config.getSchema();
        if (customSpec.size() > 0) {
            proxyClasses = new ArrayList<String>();
            for (Class<? extends RealmObject> clazz : customSpec) {
                proxyClasses.add(clazz.getName());
            }
        }

=======
    private static void initializeRealm(Realm realm) {
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b17768;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a17768;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c17768
<<<<<<< MINE
            for (String className : proxyClasses) {
                String[] splitted = className.split("\\.");
                String modelClassName = splitted[splitted.length - 1];
                String generatedClassName = getProxyClassName(modelClassName);

                // Verify that there is a proxy class for each supported model class
                Class<?> generatedClass;
                try {
                    generatedClass = Class.forName(generatedClassName);
                } catch (ClassNotFoundException e) {
                    throw new RealmException("Could not find the generated " + generatedClassName + " class: " + APT_NOT_EXECUTED_MESSAGE);
                }
=======

            for (Class<? extends RealmObject> modelClass : proxyMediator.getModelClasses()) {
                String modelClassName = modelClass.getSimpleName();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b17768;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a17768;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c17768
<<<<<<< MINE
                                                                    boolean sortAscending1, String fieldName2,
                                                                    boolean sortAscending2) {
=======
                                                               boolean sortAscending1, String fieldName2,
                                                               boolean sortAscending2) {
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b17768;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a17768;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c17768
<<<<<<< MINE
=======
     * Compact a Realm file. A Realm file usually contain free/unused space.
     * This method removes this free space and the file size is thereby reduced.
     * Objects within the Realm files are untouched.
     * <p>
     * The file must be closed before this method is called.<br>
     * The file system should have free space for at least a copy of the Realm file.<br>
     * The Realm file is left untouched if any file operation fails.<br>
     *
     * @param context an Android {@link android.content.Context}
     * @return true if successful, false if any file operation failed
     *
     * @throws java.lang.IllegalStateException if trying to compact a Realm that is already open.
     */
    public static boolean compactRealmFile(Context context) {
        return compactRealmFile(context, DEFAULT_REALM_NAME, null);
    }

    /**
     * Compact a Realm file. A Realm file usually contain free/unused space.
     * This method removes this free space and the file size is thereby reduced.
     * Objects within the Realm files are untouched.
     * <p>
     * The file must be closed before this method is called.<br>
     * The file system should have free space for at least a copy of the Realm file.<br>
     * The Realm file is left untouched if any file operation fails.<br>
     *
     * @param context an Android {@link android.content.Context}
     * @param fileName the name of the file to compact
     * @return true if successful, false if any file operation failed
     *
     * @throws java.lang.IllegalStateException if trying to compact a Realm that is already open.
     */
    public static synchronized boolean compactRealmFile(Context context, String fileName) {
        return compactRealmFile(context, fileName, null);
    }

    /**
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b17768;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a17768;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c17768
<<<<<<< MINE
=======
    }

    /**
     * Override the standard behavior of all classes extended RealmObject being part of the schema.
     * Use this method to define the schema as only the classes given here.
     *
     * This class must be called before calling {@link #getInstance(android.content.Context)}
     *
     * If {@code null} is given as parameter, the Schema is reset to use all known classes.
     *
     */
    @SafeVarargs
    static void setSchema(Class<? extends RealmObject>... schemaClass) {
        if (schemaClass != null) {
            // Filter default schema
            proxyMediator = new FilterableMediator(getDefaultMediator(), Arrays.asList(schemaClass));
        } else if (proxyMediator instanceof FilterableMediator) {
            // else reset filter if needed
            proxyMediator = ((FilterableMediator) proxyMediator).getOriginalMediator();
        }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b09652;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a09652;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c09652
<<<<<<< MINE

            if (table.getColumnCount() != 2) {
                throw new IllegalStateException("Column count does not match");
=======
            if (table.getColumnCount() != 2) {
                throw new RealmMigrationNeededException(transaction.getPath(), "Field count does not match");
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b09652;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a09652;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c09652
<<<<<<< MINE

            if (table.getColumnCount() != 3) {
                throw new IllegalStateException("Column count does not match");
=======
            if (table.getColumnCount() != 3) {
                throw new RealmMigrationNeededException(transaction.getPath(), "Field count does not match");
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b09652;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a09652;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c09652
<<<<<<< MINE

            if (table.getColumnCount() != 9) {
                throw new IllegalStateException("Column count does not match");
=======
            if(table.getColumnCount() != 9) {
                throw new RealmMigrationNeededException(transaction.getPath(), "Field count does not match");
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b09652;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a09652;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c09652
<<<<<<< MINE
            Table table_7 = transaction.getTable("class_AllTypes");
            if (!table.getLinkTarget(INDEX_COLUMNOBJECT).equals(table_7)) {
                throw new IllegalStateException("Mismatching link tables for column 'columnObject'");
            }
            if (!columnTypes.containsKey("columnRealmList")) {
                throw new IllegalStateException("Missing column 'columnRealmList'");
=======
            if(!columnTypes.containsKey("columnRealmList")) {
                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'columnRealmList'");
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b09652;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a09652;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c09652
<<<<<<< MINE
            if (columnTypes.get("columnRealmList") != ColumnType.LINK_LIST) {
                throw new IllegalStateException("Invalid type 'AllTypes' for column 'columnRealmList'");
=======
            if(columnTypes.get("columnRealmList") != ColumnType.LINK_LIST) {
                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'AllTypes' for field 'columnRealmList'");
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b09652;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a09652;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c09652
<<<<<<< MINE
        writer.emitStatement("throw new IllegalStateException(\"Column count does not match\")");
=======
        writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Field count does not match\")");
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b09652;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a09652;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c09652
<<<<<<< MINE
                writer.emitStatement("throw new IllegalStateException(\"Missing column '%s'\")", fieldName);
=======
                writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Missing field '%s'\")", fieldName);
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b09652;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a09652;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c09652
<<<<<<< MINE
                writer.emitStatement("throw new IllegalStateException(\"Invalid type '%s' for column '%s'\")",
=======
                writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Invalid type '%s' for field '%s'\")",
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b20736;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a20736;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c20736
<<<<<<< MINE
    private static RealmConfiguration defaultConfiguration;

    private static final String INCORRECT_THREAD_MESSAGE = "Realm access from incorrect thread. Realm objects can only be accessed on the thread they where created.";
=======
    // Maps ids to a boolean set to true if the Realm is open. This is only needed by deleteRealmFile
    private static final Map<String, AtomicInteger> openRealms = new ConcurrentHashMap<String, AtomicInteger>();
    private static final String INCORRECT_THREAD_MESSAGE = "Realm access from incorrect thread. Realm objects can only be accessed on the thread they were created.";
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b20736;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a20736;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c20736
<<<<<<< MINE
    private final List<WeakReference<RealmChangeListener>> changeListeners = new ArrayList<WeakReference<RealmChangeListener>>();
    protected RealmProxyMediator proxyMediator;
=======
    private final List<WeakReference<RealmChangeListener>> changeListeners =
            new CopyOnWriteArrayList<WeakReference<RealmChangeListener>>();
    private static RealmProxyMediator proxyMediator = getDefaultMediator();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b20736;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a20736;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c20736
<<<<<<< MINE
                realmPath.equals(canonicalPath)                       // It's the right realm
                && !handler.hasMessages(REALM_CHANGED)       // The right message
                && handler.getLooper().getThread().isAlive() // The receiving thread is alive
                && !handler.equals(this.handler)             // Don't notify yourself
=======
                    realmPath.equals(canonicalPath)              // It's the right realm
                    && !handler.hasMessages(REALM_CHANGED)       // The right message
                    && handler.getLooper().getThread().isAlive() // The receiving thread is alive
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b20736;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a20736;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c20736
<<<<<<< MINE
    // Get the canonical path for a given file
=======
    /**
     * Override the standard behavior of all classes extended RealmObject being part of the schema.
     * Use this method to define the schema as only the classes given here.
     *
     * This class must be called before calling {@link #getInstance(android.content.Context)}
     *
     * If {@code null} is given as parameter, the Schema is reset to use all known classes.
     *
     */
    @SafeVarargs
    static void setSchema(Class<? extends RealmObject>... schemaClass) {
        if (schemaClass != null) {
            // Filter default schema
            proxyMediator = new FilterableMediator(getDefaultMediator(), Arrays.asList(schemaClass));
        } else if (proxyMediator instanceof FilterableMediator) {
            // else reset filter if needed
            proxyMediator = ((FilterableMediator) proxyMediator).getOriginalMediator();
        }
    }

>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b16356;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a16356;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c16356
<<<<<<< MINE
import java.util.Scanner;

import io.realm.RealmObject;

=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b16356;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a16356;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c16356
<<<<<<< MINE
    public static boolean compactRealm(RealmConfiguration configuration) {
        if (configuration.getEncryptionKey() != null) {
=======
    public static synchronized boolean compactRealmFile(Context context, String fileName, byte[] key) {
        if (key != null) { // TODO: use proper key in SharedGroup init when encrypted realms are supported
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b16356;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a16356;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c16356
<<<<<<< MINE
            sharedGroup = new SharedGroup(canonicalPath, false, configuration.getEncryptionKey());
=======
            sharedGroup = new SharedGroup(canonicalPath, false, null);
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b03220;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a03220;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c03220
<<<<<<< MINE
    public long getNativePointer () {
        return nativePtr;
    }

    private native long createNativeWithImplicitTransactions(long nativeReplicationPtr, byte[] key);
=======
    private native long createNativeWithImplicitTransactions(long nativeReplicationPtr, int durability, byte[] key);
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b12632;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a12632;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c12632
<<<<<<< MINE
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b06444;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a06444;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c06444
<<<<<<< MINE
    private native long createNativeWithImplicitTransactions(long nativeReplicationPtr, int durability, byte[] key);
    
    public long getNativePointer () {
        return nativePtr;
    }

    public long getNativeReplicationPointer () {
        return nativeReplicationPtr;
    }

    private native long nativeCreateReplication(String databaseFile, byte[] key);

=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b06444;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a06444;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c06444
<<<<<<< MINE

    void advanceRead(VersionID versionID) {
        nativeAdvanceReadToVersion(nativePtr, nativeReplicationPtr, versionID.version, versionID.index);
    }

    private native void nativeAdvanceRead(long nativePtr, long nativeReplicationPtr);
    private native void nativeAdvanceReadToVersion(long nativePtr, long nativeReplicationPtr, long version, long index);
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b06444;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a06444;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c06444
<<<<<<< MINE
    private native void nativePromoteToWrite(long nativePtr, long nativeReplicationPtr);

=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b06444;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a06444;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c06444
<<<<<<< MINE

    private native void nativeRollbackAndContinueAsRead(long nativePtr, long nativeReplicationPtr);
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b06444;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a06444;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c06444
<<<<<<< MINE
    public VersionID getVersion () {
        long[] versionId = nativeGetVersionID (nativePtr);
        return new VersionID (versionId[0], versionId[1]);

    }

    private native long[] nativeGetVersionID (long nativePtr);

=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b21460;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a21460;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c21460
<<<<<<< MINE
import java.util.IdentityHashMap;
=======
import java.util.HashSet;
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b11636;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a11636;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c11636
<<<<<<< MINE
    }

    void advanceRead(VersionID versionID) {
        nativeAdvanceReadToVersion(nativePtr, nativeReplicationPtr, versionID.version,
                versionID.index);
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b18768;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a18768;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c18768
<<<<<<< MINE
    }

    void advanceRead(VersionID versionID) {
        nativeAdvanceReadToVersion(nativePtr, nativeReplicationPtr, versionID.version,
                versionID.index);
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b18768;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a18768;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c18768
<<<<<<< MINE
=======
    private native void nativeAdvanceRead(long nativePtr, long native_replication_ptr);
    private native void nativePromoteToWrite(long nativePtr, long native_replication_ptr);
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b18768;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a18768;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c18768
<<<<<<< MINE
=======
    private native void nativeRollbackAndContinueAsRead(long nativePtr, long native_replication_ptr);
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b04760;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a04760;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c04760
<<<<<<< MINE
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicInteger;
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b04760;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a04760;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c04760
<<<<<<< MINE
import io.realm.internal.android.DebugAndroidLogger;
import io.realm.internal.async.QueryUpdateTask;
import io.realm.internal.async.RealmThreadPoolExecutor;
import io.realm.internal.android.ReleaseAndroidLogger;
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b04760;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a04760;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c04760
<<<<<<< MINE
        @Override
        protected Map<RealmConfiguration, Realm> initialValue() {
            return new HashMap<RealmConfiguration, Realm>();
        }
    };
=======
                @Override
                protected Map<RealmConfiguration, Realm> initialValue() {
                    return new HashMap<RealmConfiguration, Realm>();
                }
            };
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b04760;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a04760;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c04760
<<<<<<< MINE
        @Override
        protected Map<RealmConfiguration, Integer> initialValue() {
            return new HashMap<RealmConfiguration, Integer>();
        }
    };

    // List of Realm files that has already been validated
    private static final Set<String> validatedRealmFiles = new HashSet<String>();

    // keep a WeakReference list to RealmResults obtained asynchronously in order to update them
    // RealmQuery is not WeakReference to prevent it from being GC'd. RealmQuery should be
    // cleaned if RealmResults is cleaned. we need to keep RealmQuery because it contains the query
    // pointer (to handover for each update) + all the arguments necessary to rerun the query:
    // sorting orders, soring columns, type (findAll, findFirst, findAllSorted etc.)
    final Map<WeakReference<RealmResults<?>>, RealmQuery<?>> asyncRealmResults =
            new IdentityHashMap<WeakReference<RealmResults<?>>, RealmQuery<?>>();
    final ReferenceQueue<RealmResults<?>> referenceQueue = new ReferenceQueue<RealmResults<?>>();
    final Map<WeakReference<RealmObject>, RealmQuery<?>> asyncRealmObjects =
            new IdentityHashMap<WeakReference<RealmObject>, RealmQuery<?>>();

    // thread pool for all async operations (Query & Write transaction)
    static final RealmThreadPoolExecutor asyncQueryExecutor = RealmThreadPoolExecutor.getInstance();
    // pending update of async queries
    private Future updateAsyncQueriesTask;
=======
                @Override
                protected Map<RealmConfiguration, Integer> initialValue() {
                    return new HashMap<RealmConfiguration, Integer>();
                }
            };
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b04760;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a04760;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c04760
<<<<<<< MINE
    // Map between all Realm file paths and all known configurations pointing to that file.
    private static final Map<String, List<RealmConfiguration>> globalPathConfigurationCache =
            new HashMap<String, List<RealmConfiguration>>();

    // Map how many times a Realm path has been opened across all threads.
    // This is only needed by deleteRealmFile.
    private static final Map<String, AtomicInteger> globalOpenInstanceCounter =
            new ConcurrentHashMap<String, AtomicInteger>();

    protected static final Map<Handler, String> handlers = new ConcurrentHashMap<Handler, String>();
    static final int REALM_CHANGED = 14930352; // Hopefully it won't clash with other message IDs.
    static final int REALM_UPDATE_ASYNC_QUERIES = 24157817;
    static final int REALM_COMPLETED_ASYNC_QUERY = 39088169;
    static final int REALM_COMPLETED_ASYNC_FIND_FIRST = 63245986;

    private static RealmConfiguration defaultConfiguration;
=======
    // List of Realm files that has already been validated
    private static final Set<String> validatedRealmFiles = new HashSet<String>();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b04760;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a04760;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c04760
<<<<<<< MINE
    private static final String INCORRECT_THREAD_MESSAGE = "Realm access from incorrect thread. Realm objects can only be accessed on the thread they were created.";
    private static final String INCORRECT_THREAD_CLOSE_MESSAGE = "Realm access from incorrect thread. Realm instance can only be closed on the thread it was created.";
    private static final String CLOSED_REALM_MESSAGE = "This Realm instance has already been closed, making it unusable.";
    private static final String DIFFERENT_KEY_MESSAGE = "Wrong key used to decrypt Realm.";

    @SuppressWarnings("UnusedDeclaration")
    private static SharedGroup.Durability defaultDurability = SharedGroup.Durability.FULL;
    private boolean autoRefresh;
    private Handler handler;

    private long threadId;
    private RealmConfiguration configuration;
    protected SharedGroup sharedGroup;
    private final ImplicitTransaction transaction;

    private final List<WeakReference<RealmChangeListener>> changeListeners =
            new CopyOnWriteArrayList<WeakReference<RealmChangeListener>>();

    private static final long UNVERSIONED = -1;

    final ColumnIndices columnIndices = new ColumnIndices();

    static {
        RealmLog.add(BuildConfig.DEBUG ? new DebugAndroidLogger() : new ReleaseAndroidLogger());
    }

    protected void checkIfValid() {
        // Check if the Realm instance has been closed
        if (sharedGroup == null) {
            throw new IllegalStateException(CLOSED_REALM_MESSAGE);
        }

        // Check if we are in the right thread
        if (threadId != Thread.currentThread().getId()) {
            throw new IllegalStateException(INCORRECT_THREAD_MESSAGE);
        }
    }
=======
    private static RealmConfiguration defaultConfiguration;
    protected ColumnIndices columnIndices = new ColumnIndices();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b04760;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a04760;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c04760
<<<<<<< MINE
    }

    /**
     * Closes the Realm instance and all its resources.
     * <p>
     * It's important to always remember to close Realm instances when you're done with it in order
     * not to leak memory, file descriptors or grow the size of Realm file out of measure.
     *
     * @throws java.lang.IllegalStateException if trying to close Realm on a different thread than the
     * one it was created on.
     */
    @Override
    public void close() {
        if (this.threadId != Thread.currentThread().getId()) {
            throw new IllegalStateException(INCORRECT_THREAD_CLOSE_MESSAGE);
        }

        Map<RealmConfiguration, Integer> localRefCount = referenceCount.get();
        String canonicalPath = configuration.getPath();
        Integer references = localRefCount.get(configuration);
        if (references == null) {
            references = 0;
        }
        if (sharedGroup != null && references == 1) {
            realmsCache.get().remove(configuration);
            sharedGroup.close();
            sharedGroup = null;

            // It is necessary to be synchronized here since there is a chance that before the counter removed,
            // the other thread could get the counter and increase it in createAndValidate.
            synchronized (Realm.class) {
                validatedRealmFiles.remove(configuration.getPath());
                List<RealmConfiguration>  pathConfigurationCache = globalPathConfigurationCache.get(canonicalPath);
                pathConfigurationCache.remove(configuration);
                if (pathConfigurationCache.isEmpty()) {
                    globalPathConfigurationCache.remove(canonicalPath);
                }
                AtomicInteger counter = globalOpenInstanceCounter.get(canonicalPath);
                if (counter.decrementAndGet() == 0) {
                    globalOpenInstanceCounter.remove(canonicalPath);
                }
            }
        }

        int refCount = references - 1;
        if (refCount < 0) {
            RealmLog.w("Calling close() on a Realm that is already closed: " + canonicalPath);
        }
        localRefCount.put(configuration, Math.max(0, refCount));

        if (handler != null && refCount <= 0) {
            removeHandler(handler);
            handler = null;
        }
    }

    private void removeHandler(Handler handler) {
        handler.removeCallbacksAndMessages(null);
        handlers.remove(handler);
    }

    private class RealmCallback implements Handler.Callback {
        @Override
        public boolean handleMessage(Message message) {
            switch (message.what) {
                case REALM_CHANGED: {
                    if (threadContainsAsyncQueries()) {
                        if (updateAsyncQueriesTask != null && !updateAsyncQueriesTask.isDone()) {
                            // try to cancel any pending update since we're submitting a new one anyway
                            updateAsyncQueriesTask.cancel(true);
                            asyncQueryExecutor.getQueue().remove(updateAsyncQueriesTask);
                            RealmLog.d("REALM_CHANGED realm:"+ Realm.this + " cancelling pending REALM_UPDATE_ASYNC_QUERIES updates");
                        }
                        RealmLog.d("REALM_CHANGED realm:"+ Realm.this + " updating async queries, total: " + asyncRealmResults.size());
                        // prepare a QueryUpdateTask to current async queries in this thread
                        QueryUpdateTask.Builder.UpdateQueryStep updateQueryStep = QueryUpdateTask.newBuilder()
                                .realmConfiguration(getConfiguration());
                        QueryUpdateTask.Builder.RealmResultsQueryStep realmResultsQueryStep = null;

                        // we iterate over non GC'd async RealmResults then add them to the list to be updated (in a batch)
                        Iterator<Map.Entry<WeakReference<RealmResults<?>>, RealmQuery<?>>> iterator = asyncRealmResults.entrySet().iterator();
                        while (iterator.hasNext()) {
                            Map.Entry<WeakReference<RealmResults<?>>, RealmQuery<?>> entry = iterator.next();
                            WeakReference<RealmResults<?>> weakReference = entry.getKey();
                            RealmResults<?> realmResults = weakReference.get();
                            if (realmResults == null) {
                                // GC'd instance remove from the list
                                iterator.remove();

                            } else {
                                realmResultsQueryStep = updateQueryStep.add(weakReference,
                                                  entry.getValue().handoverQueryPointer(),
                                                  entry.getValue().getArgument());
                            }

                            // Note: we're passing an WeakRef of a RealmResults to another thread
                            //       this is safe as long as we don't invoke any of the RealmResults methods.
                            //       we're just using it as a Key in an IdentityHashMap (i.e doesn't call
                            //       AbstractList's hashCode, that require accessing objects from another thread)
                            //
                            //       watch out when you debug, as you're IDE try to evaluate RealmResults
                            //       which break the Thread confinement constraints.
                        }
                        if (realmResultsQueryStep != null) {
                            QueryUpdateTask queryUpdateTask = realmResultsQueryStep
                                    .sendToHandler(handler, REALM_UPDATE_ASYNC_QUERIES)
                                    .build();
                            updateAsyncQueriesTask = asyncQueryExecutor.submit(queryUpdateTask);
                        }

                    } else {
                        RealmLog.d("REALM_CHANGED realm:"+ Realm.this + " no async queries, advance_read");
                        transaction.advanceRead();
                        sendNotifications();
                    }
                    break;
                }
                case REALM_COMPLETED_ASYNC_QUERY: {
                    // one async query has completed
                    QueryUpdateTask.Result result
                            = (QueryUpdateTask.Result) message.obj;

                    Set<WeakReference<RealmResults<?>>> updatedTableViewsKeys = result.updatedTableViews.keySet();
                    if (updatedTableViewsKeys.size() > 0) {
                        WeakReference<RealmResults<?>> weakRealmResults = updatedTableViewsKeys.iterator().next();

                        RealmResults<?> realmResults = weakRealmResults.get();
                        if (realmResults == null) {
                            asyncRealmResults.remove(weakRealmResults);
                            RealmLog.d("[REALM_COMPLETED_ASYNC_QUERY "+ weakRealmResults + "] realm:"+ Realm.this + " RealmResults GC'd ignore results");

                        } else {
                            SharedGroup.VersionID callerVersionID = sharedGroup.getVersion();
                            int compare = callerVersionID.compareTo(result.versionID);
                            if (compare == 0) {
                                // if the RealmResults is empty (has not completed yet) then use the value
                                // otherwise a task (grouped update) has already updated this RealmResults
                                if (!realmResults.isLoaded()) {
                                    RealmLog.d("[REALM_COMPLETED_ASYNC_QUERY "+ weakRealmResults + "] , realm:"+ Realm.this + " same versions, using results (RealmResults is not loaded)");
                                    // swap pointer
                                    realmResults.swapTableViewPointer(result.updatedTableViews.get(weakRealmResults));
                                    // notify callbacks
                                    realmResults.notifyChangeListeners();
                                } else {
                                    RealmLog.d("[REALM_COMPLETED_ASYNC_QUERY "+ weakRealmResults + "] , realm:"+ Realm.this + " ignoring result the RealmResults (is already loaded)");
                                }

                            } else if (compare > 0) {
                                // we have two use cases:
                                // 1- this RealmResults is not empty, this means that after we started the async
                                //    query, we received a REALM_CHANGE that triggered an update of all async queries
                                //    including the last async submitted, so no need to use the provided TableView pointer
                                //    (or the user forced the sync behaviour .load())
                                // 2- This RealmResults is still empty but this caller thread is advanced than the worker thread
                                //    this could happen if the current thread advanced the shared_group (via a write or refresh)
                                //    this means that we need to rerun the query against a newer worker thread.

                                if (!realmResults.isLoaded()) { // UC2
                                    // UC covered by this test: RealmAsyncQueryTests#testFindAllAsyncRetry
                                    RealmLog.d("[REALM_COMPLETED_ASYNC_QUERY " + weakRealmResults + "] , realm:"+ Realm.this + " caller is more advanced & RealmResults is not loaded, rerunning the query against the latest version");

                                    RealmQuery<?> query = asyncRealmResults.get(weakRealmResults);
                                    QueryUpdateTask queryUpdateTask = QueryUpdateTask.newBuilder()
                                            .realmConfiguration(getConfiguration())
                                            .add(weakRealmResults,
                                                    query.handoverQueryPointer(),
                                                    query.getArgument())
                                            .sendToHandler(handler, REALM_COMPLETED_ASYNC_QUERY)
                                            .build();

                                    asyncQueryExecutor.submit(queryUpdateTask);

                                } else {
                                    // UC covered by this test: RealmAsyncQueryTests#testFindAllCallerIsAdvanced
                                    RealmLog.d("[REALM_COMPLETED_ASYNC_QUERY "+ weakRealmResults + "] , realm:"+ Realm.this + " caller is more advanced & RealmResults is loaded ignore the outdated result");
                                }

                            } else {
                                // the caller thread is behind the worker thread,
                                // no need to rerun the query, since we're going to receive the update signal
                                // & batch update all async queries including this one
                                // UC covered by this test: RealmAsyncQueryTests#testFindAllCallerThreadBehind
                                RealmLog.d("[REALM_COMPLETED_ASYNC_QUERY "+ weakRealmResults + "] , realm:"+ Realm.this + " caller thread behind worker thread, ignore results (a batch update will update everything including this query)");
                            }
                        }
                    }
                    break;
                }
                case REALM_UPDATE_ASYNC_QUERIES: {
                    // this is called once the background thread completed the update of the async queries
                    QueryUpdateTask.Result result
                            = (QueryUpdateTask.Result) message.obj;

                    SharedGroup.VersionID callerVersionID = sharedGroup.getVersion();
                    int compare = callerVersionID.compareTo(result.versionID);
                    if (compare > 0) {
                        RealmLog.d("REALM_UPDATE_ASYNC_QUERIES realm:"+ Realm.this + " caller is more advanced, rerun updates");
                        // The caller is more advance than the updated queries ==>
                        // need to refresh them again (if there is still queries)
                        handler.sendEmptyMessage(REALM_CHANGED);

                    } else {
                        // We're behind or on the same version as the worker thread

                        // only advance if we're behind
                        if (compare != 0) {
                            // no need to remove old pointers from TableView, since they're
                            // imperative TV, they will not rerun if the SharedGroup advance

                            // UC covered by this test: RealmAsyncQueryTests#testFindAllCallerThreadBehind
                            RealmLog.d("REALM_UPDATE_ASYNC_QUERIES realm:"+ Realm.this + " caller is behind  advance_read");
                            // refresh the Realm to the version provided by the worker thread
                            // (advanceRead to the latest version may cause a version mismatch error) preventing us
                            // from importing correctly the handover table view
                            transaction.advanceRead(result.versionID);
                        }

                        ArrayList<RealmResults<?>> callbacksToNotify = new ArrayList<RealmResults<?>>(result.updatedTableViews.size());
                        // use updated TableViews pointers for the existing async RealmResults
                        for (Map.Entry<WeakReference<RealmResults<?>>, Long> query : result.updatedTableViews.entrySet()) {
                            WeakReference<RealmResults<?>> weakRealmResults = query.getKey();
                            RealmResults<?> realmResults = weakRealmResults.get();
                            if (realmResults == null) {
                                // don't update GC'd instance
                                asyncRealmResults.remove(weakRealmResults);

                            } else {
                                // it's dangerous to notify the callback about new results before updating
                                // the pointers, because the callback may use another RealmResults not updated yet
                                // this is why we defer the notification until we're done updating all pointers

                                // TODO find a way to only notify callbacks if the underlying data changed compared
                                //      to the existing value(s) for this RealmResults (use a hashCode?)
                                callbacksToNotify.add(realmResults);

                                RealmLog.d("REALM_UPDATE_ASYNC_QUERIES realm:"+ Realm.this + " updating RealmResults " + weakRealmResults);
                                // update the instance with the new pointer
                                realmResults.swapTableViewPointer(query.getValue());
                            }
                        }

                        for (RealmResults<?> query : callbacksToNotify) {
                            query.notifyChangeListeners();
                        }

                        // notify listeners only when we advanced
                        if (compare != 0) {
                            sendNotifications();
                        }

                        updateAsyncQueriesTask = null;
                    }
                    break;
                }
                case REALM_COMPLETED_ASYNC_FIND_FIRST: {
                    QueryUpdateTask.Result result = (QueryUpdateTask.Result) message.obj;
                    Set<WeakReference<RealmObject>> updatedRowKey = result.updatedRow.keySet();
                    if (updatedRowKey.size() > 0) {
                        WeakReference<RealmObject> realmObjectWeakReference = updatedRowKey.iterator().next();
                        RealmObject realmObject = realmObjectWeakReference.get();

                        if (realmObject != null) {
                            SharedGroup.VersionID callerVersionID = sharedGroup.getVersion();
                            int compare = callerVersionID.compareTo(result.versionID);
                            // we always query on the same version
                            // only two use cases could happen 1. we're on the same version or 2. the caller has advanced in the meanwhile
                            if (compare == 0) { //same version import the handover
                                realmObject.onCompleted(result.updatedRow.get(realmObjectWeakReference));
                                asyncRealmObjects.remove(realmObjectWeakReference);

                            } else if (compare > 0) {
                                // the caller has advanced we need to
                                // retry against the current version of the caller
                                RealmQuery<?> realmQuery = asyncRealmObjects.get(realmObjectWeakReference);

                                QueryUpdateTask queryUpdateTask = QueryUpdateTask.newBuilder()
                                        .realmConfiguration(getConfiguration())
                                        .addObject(realmObjectWeakReference,
                                                realmQuery.handoverQueryPointer(),
                                                realmQuery.getArgument())
                                        .sendToHandler(handler, REALM_COMPLETED_ASYNC_FIND_FIRST)
                                        .build();

                                asyncQueryExecutor.submit(queryUpdateTask);
                            } else {
                                // should not happen, since the the background thread position itself against the provided version
                                // and the caller thread can only go forward (advance_read)
                                throw new IllegalStateException("Caller thread behind the worker thread");
                            }
                        } // else: element GC'd in the meanwhile
                    }
                    break;
                }
            }
            return true;
        }
    }

    /**
     * Retrieve the auto-refresh status of the Realm instance.
     * @return the auto-refresh status
     */
    public boolean isAutoRefresh() {
        return autoRefresh;
    }

    /**
     * Indicates if there are currently any RealmResults being used in this thread (obtained
     * previously asynchronously). This will prevent advanceRead accidentally the current transaction
     * resulting in re-running the queries in this thread.
     * @return {@code true} if there is at least one (non GC'd) instance of {@link RealmResults} {@code false} otherwise
     */
    private boolean threadContainsAsyncQueries () {
        deleteWeakReferences();
        boolean isEmpty = true;
        Iterator<Map.Entry<WeakReference<RealmResults<?>>, RealmQuery<?>>> iterator = asyncRealmResults.entrySet().iterator();
        while (iterator.hasNext()) {
            Map.Entry<WeakReference<RealmResults<?>>, RealmQuery<?>> next = iterator.next();
            if (next.getKey().get() == null) {
                // clean the GC'd instance
                // we could've avoided this if we had a 'WeakIdentityHashmap' data structure. miss Guava :(
                iterator.remove();
            } else {
                isEmpty = false;
            }
        }

        return !isEmpty;
    }

    private void deleteWeakReferences() {
        // From the AOSP FinalizationTest:
        // https://android.googlesource.com/platform/libcore/+/master/support/src/test/java/libcore/
        // java/lang/ref/FinalizationTester.java
        // System.gc() does not garbage collect every time. Runtime.gc() is
        // more likely to perform a gc.
        Runtime.getRuntime().gc();
        Reference<? extends RealmResults<?>> weakReference;
        while ((weakReference = referenceQueue.poll()) != null ) { // Does not wait for a reference to become available.
            RealmLog.d("deleted 1 reference: " + weakReference);
            asyncRealmResults.remove(weakReference);
        }
    }

    /**
     * Set the auto-refresh status of the Realm instance.
     * <p>
     * Auto-refresh is a feature that enables automatic update of the current Realm instance and all its derived objects
     * (RealmResults and RealmObjects instances) when a commit is performed on a Realm acting on the same file in another thread.
     * This feature is only available if the Realm instance lives is a {@link android.os.Looper} enabled thread.
     *
     * @param autoRefresh true will turn auto-refresh on, false will turn it off.
     * @throws java.lang.IllegalStateException if trying to enable auto-refresh in a thread without Looper.
     */
    public void setAutoRefresh(boolean autoRefresh) {
        if (autoRefresh && Looper.myLooper() == null) {
            throw new IllegalStateException("Cannot set auto-refresh in a Thread without a Looper");
        }

        if (autoRefresh && !this.autoRefresh) { // Switch it on
            handler = new Handler(new RealmCallback());
            handlers.put(handler, configuration.getPath());
        } else if (!autoRefresh && this.autoRefresh && handler != null) { // Switch it off
            removeHandler(handler);
        }
        this.autoRefresh = autoRefresh;
    }

    // Public because of migrations
    public Table getTable(Class<? extends RealmObject> clazz) {
        Table table = classToTable.get(clazz);
        if (table == null) {
            clazz = Util.getOriginalModelClass(clazz);
            table = transaction.getTable(configuration.getSchemaMediator().getTableName(clazz));
            classToTable.put(clazz, table);
        }
        return table;
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b04760;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a04760;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c04760
<<<<<<< MINE
    }

    // package protected so unit tests can access it

    // Returns the Handler for this Realm on the calling thread
    Handler getHandler() {
        return handler;
    }

    void setHandler (Handler handler) {
        // remove the old one
        handlers.remove(this.handler);
        handlers.put(handler, configuration.getPath());
        this.handler = handler;
    }

    long getVersion() {
        if (!transaction.hasTable("metadata")) {
            return UNVERSIONED;
        }
        Table metadataTable = transaction.getTable("metadata");
        return metadataTable.getLong(0, 0);
    }

    // package protected so unit tests can access it
    void setVersion(long version) {
        Table metadataTable = transaction.getTable("metadata");
        if (metadataTable.getColumnCount() == 0) {
            metadataTable.addColumn(ColumnType.INTEGER, "version");
            metadataTable.addEmptyRow();
        }
        metadataTable.setLong(0, 0, version);
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b11608;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a11608;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c11608
<<<<<<< MINE
    protected void addAsyncRealmResults (WeakReference<RealmResults<? extends RealmObject>> weakRealmResults,
                                         RealmQuery<? extends RealmObject> realmQuery) {
        handlerController.asyncRealmResults.put(weakRealmResults, realmQuery);
    }

    protected void addAsyncRealmObject (WeakReference<RealmObject> realmObjectWeakReference,
                                         RealmQuery<? extends RealmObject> realmQuery) {
        handlerController.asyncRealmObjects.put(realmObjectWeakReference, realmQuery);
    }

    protected ReferenceQueue<RealmResults<? extends RealmObject>> getReferenceQueue () {
        return handlerController.referenceQueue;
=======
    // Internal Handler callback for Realm messages
    private class RealmCallback implements Handler.Callback {
        @Override
        public boolean handleMessage(Message message) {
            // Due to how a ConcurrentHashMap iterator is created we cannot be sure that other threads are
            // aware when this threads handler is removed before they send messages to it. We don't wish to synchronize
            // access to the handlers as they are the prime mean of notifying about updates. Instead we make sure
            // that if a message does slip though (however unlikely), it will not try to update a SharedGroup that no
            // longer exists. `sharedGroupManager` will only be null if a Realm is really closed.
            if (message.what == REALM_CHANGED && sharedGroupManager != null) {
                sharedGroupManager.advanceRead();
                sendNotifications();
            }
            return true;
        }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b18776;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a18776;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c18776
<<<<<<< MINE
import java.util.Iterator;
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b10436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a10436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c10436
<<<<<<< MINE
    public static Simple copy(Realm realm, Simple newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
        RealmObjectProxy cachedRealmObject = cache.get(newObject);
        if (cachedRealmObject != null) {
            return (Simple) cachedRealmObject;
        } else {
            Simple realmObject = realm.createObject(Simple.class);
            cache.put(newObject, (RealmObjectProxy) realmObject);
            ((SimpleRealmProxyInterface) realmObject).realmSet$name(((SimpleRealmProxyInterface) newObject).realmGet$name());
            ((SimpleRealmProxyInterface) realmObject).realmSet$age(((SimpleRealmProxyInterface) newObject).realmGet$age());
            return realmObject;
        }
    }

    public static long insert(Realm realm, Simple object, Map<RealmModel,Long> cache) {
        Table table = realm.getTable(Simple.class);
        long tableNativePtr = table.getNativeTablePointer();
        SimpleColumnInfo columnInfo = (SimpleColumnInfo) realm.schema.getColumnInfo(Simple.class);
        long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
        cache.put(object, rowIndex);
        String realmGet$name = ((SimpleRealmProxyInterface)object).realmGet$name();
        if (realmGet$name != null) {
            Table.nativeSetString(tableNativePtr, columnInfo.nameIndex, rowIndex, realmGet$name);
        }
        Table.nativeSetLong(tableNativePtr, columnInfo.ageIndex, rowIndex, ((SimpleRealmProxyInterface)object).realmGet$age());
        return rowIndex;
    }

    public static void insert(Realm realm, Iterator<? extends RealmModel> objects, Map<RealmModel,Long> cache) {
        Table table = realm.getTable(Simple.class);
        long tableNativePtr = table.getNativeTablePointer();
        SimpleColumnInfo columnInfo = (SimpleColumnInfo) realm.schema.getColumnInfo(Simple.class);
        Simple object = null;
        while (objects.hasNext()) {
            object = (Simple) objects.next();
            if(!cache.containsKey(object)) {
                long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
                cache.put(object, rowIndex);
                String realmGet$name = ((SimpleRealmProxyInterface)object).realmGet$name();
                if (realmGet$name != null) {
                    Table.nativeSetString(tableNativePtr, columnInfo.nameIndex, rowIndex, realmGet$name);
                }
                Table.nativeSetLong(tableNativePtr, columnInfo.ageIndex, rowIndex, ((SimpleRealmProxyInterface)object).realmGet$age());
            }
        }
    }

    public static long insertOrUpdate(Realm realm, Simple object, Map<RealmModel,Long> cache) {
        Table table = realm.getTable(Simple.class);
        long tableNativePtr = table.getNativeTablePointer();
        SimpleColumnInfo columnInfo = (SimpleColumnInfo) realm.schema.getColumnInfo(Simple.class);
        long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
        cache.put(object, rowIndex);
        String realmGet$name = ((SimpleRealmProxyInterface)object).realmGet$name();
        if (realmGet$name != null) {
            Table.nativeSetString(tableNativePtr, columnInfo.nameIndex, rowIndex, realmGet$name);
        } else {
            Table.nativeSetNull(tableNativePtr, columnInfo.nameIndex, rowIndex);
        }
        Table.nativeSetLong(tableNativePtr, columnInfo.ageIndex, rowIndex, ((SimpleRealmProxyInterface)object).realmGet$age());
        return rowIndex;
    }

    public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> objects, Map<RealmModel,Long> cache) {
        Table table = realm.getTable(Simple.class);
        long tableNativePtr = table.getNativeTablePointer();
        SimpleColumnInfo columnInfo = (SimpleColumnInfo) realm.schema.getColumnInfo(Simple.class);
        Simple object = null;
        while (objects.hasNext()) {
            object = (Simple) objects.next();
            if(!cache.containsKey(object)) {
                long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
                cache.put(object, rowIndex);
                String realmGet$name = ((SimpleRealmProxyInterface)object).realmGet$name();
                if (realmGet$name != null) {
                    Table.nativeSetString(tableNativePtr, columnInfo.nameIndex, rowIndex, realmGet$name);
                } else {
                    Table.nativeSetNull(tableNativePtr, columnInfo.nameIndex, rowIndex);
                }
                Table.nativeSetLong(tableNativePtr, columnInfo.ageIndex, rowIndex, ((SimpleRealmProxyInterface)object).realmGet$age());
            }
        }
=======
    public static some.test.Simple copy(Realm realm, some.test.Simple newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
        some.test.Simple realmObject = realm.createObject(some.test.Simple.class);
        cache.put(newObject, (RealmObjectProxy) realmObject);
        ((SimpleRealmProxyInterface) realmObject).realmSet$name(((SimpleRealmProxyInterface) newObject).realmGet$name());
        ((SimpleRealmProxyInterface) realmObject).realmSet$age(((SimpleRealmProxyInterface) newObject).realmGet$age());
        return realmObject;
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b10436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a10436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c10436
<<<<<<< MINE
    public static NullTypes copy(Realm realm, NullTypes newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
        RealmObjectProxy cachedRealmObject = cache.get(newObject);
        if (cachedRealmObject != null) {
            return (NullTypes) cachedRealmObject;
=======
    public static some.test.NullTypes copy(Realm realm, some.test.NullTypes newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
        some.test.NullTypes realmObject = realm.createObject(some.test.NullTypes.class);
        cache.put(newObject, (RealmObjectProxy) realmObject);
        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldStringNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldStringNotNull());
        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldStringNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldStringNull());
        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldBooleanNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldBooleanNotNull());
        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldBooleanNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldBooleanNull());
        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldBytesNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldBytesNotNull());
        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldBytesNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldBytesNull());
        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldByteNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldByteNotNull());
        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldByteNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldByteNull());
        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldShortNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldShortNotNull());
        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldShortNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldShortNull());
        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldIntegerNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldIntegerNotNull());
        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldIntegerNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldIntegerNull());
        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldLongNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldLongNotNull());
        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldLongNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldLongNull());
        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldFloatNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldFloatNotNull());
        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldFloatNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldFloatNull());
        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldDoubleNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldDoubleNotNull());
        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldDoubleNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldDoubleNull());
        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldDateNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldDateNotNull());
        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldDateNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldDateNull());

        some.test.NullTypes fieldObjectNullObj = ((NullTypesRealmProxyInterface) newObject).realmGet$fieldObjectNull();
        if (fieldObjectNullObj != null) {
            some.test.NullTypes cachefieldObjectNull = (some.test.NullTypes) cache.get(fieldObjectNullObj);
            if (cachefieldObjectNull != null) {
                ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldObjectNull(cachefieldObjectNull);
            } else {
                ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldObjectNull(NullTypesRealmProxy.copyOrUpdate(realm, fieldObjectNullObj, update, cache));
            }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b10436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a10436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c10436
<<<<<<< MINE
    public static Booleans copy(Realm realm, Booleans newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
        RealmObjectProxy cachedRealmObject = cache.get(newObject);
        if (cachedRealmObject != null) {
            return (Booleans) cachedRealmObject;
        } else {
            Booleans realmObject = realm.createObject(Booleans.class);
            cache.put(newObject, (RealmObjectProxy) realmObject);
            ((BooleansRealmProxyInterface) realmObject).realmSet$done(((BooleansRealmProxyInterface) newObject).realmGet$done());
            ((BooleansRealmProxyInterface) realmObject).realmSet$isReady(((BooleansRealmProxyInterface) newObject).realmGet$isReady());
            ((BooleansRealmProxyInterface) realmObject).realmSet$mCompleted(((BooleansRealmProxyInterface) newObject).realmGet$mCompleted());
            ((BooleansRealmProxyInterface) realmObject).realmSet$anotherBoolean(((BooleansRealmProxyInterface) newObject).realmGet$anotherBoolean());
            return realmObject;
        }
    }

    public static long insert(Realm realm, Booleans object, Map<RealmModel,Long> cache) {
        Table table = realm.getTable(Booleans.class);
        long tableNativePtr = table.getNativeTablePointer();
        BooleansColumnInfo columnInfo = (BooleansColumnInfo) realm.schema.getColumnInfo(Booleans.class);
        long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
        cache.put(object, rowIndex);
        Table.nativeSetBoolean(tableNativePtr, columnInfo.doneIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$done());
        Table.nativeSetBoolean(tableNativePtr, columnInfo.isReadyIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$isReady());
        Table.nativeSetBoolean(tableNativePtr, columnInfo.mCompletedIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$mCompleted());
        Table.nativeSetBoolean(tableNativePtr, columnInfo.anotherBooleanIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$anotherBoolean());
        return rowIndex;
    }

    public static void insert(Realm realm, Iterator<? extends RealmModel> objects, Map<RealmModel,Long> cache) {
        Table table = realm.getTable(Booleans.class);
        long tableNativePtr = table.getNativeTablePointer();
        BooleansColumnInfo columnInfo = (BooleansColumnInfo) realm.schema.getColumnInfo(Booleans.class);
        Booleans object = null;
        while (objects.hasNext()) {
            object = (Booleans) objects.next();
            if(!cache.containsKey(object)) {
                long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
                cache.put(object, rowIndex);
                Table.nativeSetBoolean(tableNativePtr, columnInfo.doneIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$done());
                Table.nativeSetBoolean(tableNativePtr, columnInfo.isReadyIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$isReady());
                Table.nativeSetBoolean(tableNativePtr, columnInfo.mCompletedIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$mCompleted());
                Table.nativeSetBoolean(tableNativePtr, columnInfo.anotherBooleanIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$anotherBoolean());
            }
        }
    }

    public static long insertOrUpdate(Realm realm, Booleans object, Map<RealmModel,Long> cache) {
        Table table = realm.getTable(Booleans.class);
        long tableNativePtr = table.getNativeTablePointer();
        BooleansColumnInfo columnInfo = (BooleansColumnInfo) realm.schema.getColumnInfo(Booleans.class);
        long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
        cache.put(object, rowIndex);
        Table.nativeSetBoolean(tableNativePtr, columnInfo.doneIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$done());
        Table.nativeSetBoolean(tableNativePtr, columnInfo.isReadyIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$isReady());
        Table.nativeSetBoolean(tableNativePtr, columnInfo.mCompletedIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$mCompleted());
        Table.nativeSetBoolean(tableNativePtr, columnInfo.anotherBooleanIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$anotherBoolean());
        return rowIndex;
    }

    public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> objects, Map<RealmModel,Long> cache) {
        Table table = realm.getTable(Booleans.class);
        long tableNativePtr = table.getNativeTablePointer();
        BooleansColumnInfo columnInfo = (BooleansColumnInfo) realm.schema.getColumnInfo(Booleans.class);
        Booleans object = null;
        while (objects.hasNext()) {
            object = (Booleans) objects.next();
            if(!cache.containsKey(object)) {
                long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
                cache.put(object, rowIndex);
                Table.nativeSetBoolean(tableNativePtr, columnInfo.doneIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$done());
                Table.nativeSetBoolean(tableNativePtr, columnInfo.isReadyIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$isReady());
                Table.nativeSetBoolean(tableNativePtr, columnInfo.mCompletedIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$mCompleted());
                Table.nativeSetBoolean(tableNativePtr, columnInfo.anotherBooleanIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$anotherBoolean());
            }
        }
=======
    public static some.test.Booleans copy(Realm realm, some.test.Booleans newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
        some.test.Booleans realmObject = realm.createObject(some.test.Booleans.class);
        cache.put(newObject, (RealmObjectProxy) realmObject);
        ((BooleansRealmProxyInterface) realmObject).realmSet$done(((BooleansRealmProxyInterface) newObject).realmGet$done());
        ((BooleansRealmProxyInterface) realmObject).realmSet$isReady(((BooleansRealmProxyInterface) newObject).realmGet$isReady());
        ((BooleansRealmProxyInterface) realmObject).realmSet$mCompleted(((BooleansRealmProxyInterface) newObject).realmGet$mCompleted());
        ((BooleansRealmProxyInterface) realmObject).realmSet$anotherBoolean(((BooleansRealmProxyInterface) newObject).realmGet$anotherBoolean());
        return realmObject;
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b10436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a10436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c10436
<<<<<<< MINE
        RealmObjectProxy cachedRealmObject = cache.get(object);
        if (cachedRealmObject != null) {
            return (AllTypes) cachedRealmObject;
=======
        some.test.AllTypes realmObject = null;
        boolean canUpdate = update;
        if (canUpdate) {
            Table table = realm.getTable(some.test.AllTypes.class);
            long pkColumnIndex = table.getPrimaryKey();
            String value = ((AllTypesRealmProxyInterface) object).realmGet$columnString();
            long rowIndex = TableOrView.NO_MATCH;
            if (value == null) {
                rowIndex = table.findFirstNull(pkColumnIndex);
            } else {
                rowIndex = table.findFirstString(pkColumnIndex, value);
            }
            if (rowIndex != TableOrView.NO_MATCH) {
                realmObject = new io.realm.AllTypesRealmProxy(realm.schema.getColumnInfo(some.test.AllTypes.class));
                ((RealmObjectProxy)realmObject).realmGet$proxyState().setRealm$realm(realm);
                ((RealmObjectProxy)realmObject).realmGet$proxyState().setRow$realm(table.getUncheckedRow(rowIndex));
                cache.put(object, (RealmObjectProxy) realmObject);
            } else {
                canUpdate = false;
            }
        }

        if (canUpdate) {
            return update(realm, realmObject, object, cache);
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b10436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a10436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c10436
<<<<<<< MINE
    public static AllTypes copy(Realm realm, AllTypes newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
        RealmObjectProxy cachedRealmObject = cache.get(newObject);
        if (cachedRealmObject != null) {
            return (AllTypes) cachedRealmObject;
=======
    public static some.test.AllTypes copy(Realm realm, some.test.AllTypes newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
        some.test.AllTypes realmObject = realm.createObject(some.test.AllTypes.class, ((AllTypesRealmProxyInterface) newObject).realmGet$columnString());
        cache.put(newObject, (RealmObjectProxy) realmObject);
        ((AllTypesRealmProxyInterface) realmObject).realmSet$columnString(((AllTypesRealmProxyInterface) newObject).realmGet$columnString());
        ((AllTypesRealmProxyInterface) realmObject).realmSet$columnLong(((AllTypesRealmProxyInterface) newObject).realmGet$columnLong());
        ((AllTypesRealmProxyInterface) realmObject).realmSet$columnFloat(((AllTypesRealmProxyInterface) newObject).realmGet$columnFloat());
        ((AllTypesRealmProxyInterface) realmObject).realmSet$columnDouble(((AllTypesRealmProxyInterface) newObject).realmGet$columnDouble());
        ((AllTypesRealmProxyInterface) realmObject).realmSet$columnBoolean(((AllTypesRealmProxyInterface) newObject).realmGet$columnBoolean());
        ((AllTypesRealmProxyInterface) realmObject).realmSet$columnDate(((AllTypesRealmProxyInterface) newObject).realmGet$columnDate());
        ((AllTypesRealmProxyInterface) realmObject).realmSet$columnBinary(((AllTypesRealmProxyInterface) newObject).realmGet$columnBinary());

        some.test.AllTypes columnObjectObj = ((AllTypesRealmProxyInterface) newObject).realmGet$columnObject();
        if (columnObjectObj != null) {
            some.test.AllTypes cachecolumnObject = (some.test.AllTypes) cache.get(columnObjectObj);
            if (cachecolumnObject != null) {
                ((AllTypesRealmProxyInterface) realmObject).realmSet$columnObject(cachecolumnObject);
            } else {
                ((AllTypesRealmProxyInterface) realmObject).realmSet$columnObject(AllTypesRealmProxy.copyOrUpdate(realm, columnObjectObj, update, cache));
            }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b10436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a10436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c10436
<<<<<<< MINE
            some.test.AllTypes columnObjectObj = ((AllTypesRealmProxyInterface) newObject).realmGet$columnObject();
            if (columnObjectObj != null) {
                some.test.AllTypes cachecolumnObject = (some.test.AllTypes) cache.get(columnObjectObj);
                if (cachecolumnObject != null) {
                    ((AllTypesRealmProxyInterface) realmObject).realmSet$columnObject(cachecolumnObject);
=======
        RealmList<some.test.AllTypes> columnRealmListList = ((AllTypesRealmProxyInterface) newObject).realmGet$columnRealmList();
        if (columnRealmListList != null) {
            RealmList<some.test.AllTypes> columnRealmListRealmList = ((AllTypesRealmProxyInterface) realmObject).realmGet$columnRealmList();
            for (int i = 0; i < columnRealmListList.size(); i++) {
                some.test.AllTypes columnRealmListItem = columnRealmListList.get(i);
                some.test.AllTypes cachecolumnRealmList = (some.test.AllTypes) cache.get(columnRealmListItem);
                if (cachecolumnRealmList != null) {
                    columnRealmListRealmList.add(cachecolumnRealmList);
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b17964;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a17964;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c17964
<<<<<<< MINE
    public SharedGroupManager sharedGroupManager;
=======
    protected SharedRealm sharedRealm;

>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b13224;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a13224;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c13224
<<<<<<< MINE
    // Map between a Handler and the canonical path to a Realm file
    public static final Map<Handler, String> handlers = new ConcurrentHashMap<Handler, String>();

=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b13224;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a13224;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c13224
<<<<<<< MINE
    public Handler handler;
    public HandlerController handlerController;
=======
    HandlerController handlerController;
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b20468;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a20468;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c20468
<<<<<<< MINE
import io.realm.RealmFieldType;
import io.realm.RealmObjectSchema;
import io.realm.RealmSchema;
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b20468;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a20468;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c20468
<<<<<<< MINE
    public RealmObjectSchema createRealmObjectSchema(Class<? extends RealmModel> clazz, RealmSchema realmSchema) {
        checkClass(clazz);

        if (clazz.equals(some.test.AllTypes.class)) {
            return io.realm.AllTypesRealmProxy.createRealmObjectSchema(realmSchema);
        } else {
            throw getMissingProxyClassException(clazz);
        }
    }

    @Override
    public ColumnInfo validateTable(Class<? extends RealmModel> clazz, SharedRealm sharedRealm) {
=======
    public ColumnInfo validateTable(Class<? extends RealmModel> clazz, SharedRealm sharedRealm, boolean allowExtraColumns) {
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b20468;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a20468;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c20468
<<<<<<< MINE
import io.realm.RealmFieldType;
import io.realm.RealmObjectSchema;
import io.realm.RealmSchema;
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b20468;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a20468;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c20468
<<<<<<< MINE
import io.realm.RealmFieldType;
import io.realm.RealmObjectSchema;
import io.realm.RealmSchema;
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b20468;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a20468;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c20468
<<<<<<< MINE
import io.realm.RealmFieldType;
import io.realm.RealmObjectSchema;
import io.realm.RealmSchema;
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b07552;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a07552;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c07552
<<<<<<< MINE
    // We need to enumerate all parameters since SyncConfiguration and RealmConfiguration supports different
    // subsets of them.
    protected RealmConfiguration(File realmDirectory,
                              String realmFileName,
                              String canonicalPath,
                              String assetFilePath,
                              byte[] key,
                              long schemaVersion,
                              RealmMigration migration,
                              boolean deleteRealmIfMigrationNeeded,
                              SharedRealm.Durability durability,
                              RealmProxyMediator schemaMediator,
                              RxObservableFactory rxObservableFactory,
                              Realm.Transaction initialDataTransaction,
                              WeakReference<Context> contextWeakRef) {
        this.realmDirectory = realmDirectory;
        this.realmFileName = realmFileName;
        this.canonicalPath = canonicalPath;
        this.assetFilePath = assetFilePath;
        this.key = key;
        this.schemaVersion = schemaVersion;
        this.migration = migration;
        this.deleteRealmIfMigrationNeeded = deleteRealmIfMigrationNeeded;
        this.durability = durability;
        this.schemaMediator = schemaMediator;
        this.rxObservableFactory = rxObservableFactory;
        this.initialDataTransaction = initialDataTransaction;
        this.contextWeakRef = contextWeakRef;
=======
    private RealmConfiguration(Builder builder) {
        this.realmDirectory = builder.directory;
        this.realmFileName = builder.fileName;
        this.canonicalPath = Realm.getCanonicalPath(new File(realmDirectory, realmFileName));
        this.assetFilePath = builder.assetFilePath;
        this.key = builder.key;
        this.schemaVersion = builder.schemaVersion;
        this.deleteRealmIfMigrationNeeded = builder.deleteRealmIfMigrationNeeded;
        this.migration = builder.migration;
        this.durability = builder.durability;
        this.schemaMediator = createSchemaMediator(builder);
        this.rxObservableFactory = builder.rxFactory;
        this.initialDataTransaction = builder.initialDataTransaction;
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b07552;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a07552;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c07552
<<<<<<< MINE
    // Thread pool for all async operations (Query / transaction / network requests)
=======
    volatile static Context applicationContext;

    // Thread pool for all async operations (Query & transaction)
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b07304;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a07304;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c07304
<<<<<<< MINE
            Class syncFacadeClass = Class.forName("io.realm.internal.objectserver.SyncObjectServerFacade");
            //noinspection unchecked
            syncFacade = (ObjectServerFacade) syncFacadeClass.getDeclaredConstructor().newInstance();
=======
            Class syncFacadeClass = Class.forName("io.realm.internal.SyncObjectServerFacade");
            syncFacade = (ObjectServerFacade) syncFacadeClass.newInstance();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b00892;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a00892;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c00892
<<<<<<< MINE
            @SuppressWarnings("LiteralClassName")
            Class syncFacadeClass = Class.forName("io.realm.internal.objectserver.SyncObjectServerFacade");
=======
            Class syncFacadeClass = Class.forName("io.realm.internal.SyncObjectServerFacade");
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b09024;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a09024;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c09024
<<<<<<< MINE
    void checkLegalName(String fieldName) {
=======
    // Invariant: Field was just added. This method is responsible for cleaning up attributes if it fails.
    private void addModifiers(String fieldName, FieldAttribute[] attributes) {
        boolean indexAdded = false;
        try {
            if (attributes != null && attributes.length > 0) {
                if (containsAttribute(attributes, FieldAttribute.INDEXED)) {
                    addIndex(fieldName);
                    indexAdded = true;
                }

                if (containsAttribute(attributes, FieldAttribute.PRIMARY_KEY)) {
                    // Note : adding primary key implies application of FieldAttribute.INDEXED attribute.
                    addPrimaryKey(fieldName);
                    indexAdded = true;
                }

                // REQUIRED is being handled when adding the column using addField through the nullable parameter.
            }
        } catch (Exception e) {
            // If something went wrong, revert all attributes.
            long columnIndex = getColumnIndex(fieldName);
            if (indexAdded) {
                table.removeSearchIndex(columnIndex);
            }
            throw (RuntimeException) e;
        }
    }

    static boolean containsAttribute(FieldAttribute[] attributeList, FieldAttribute attribute) {
        if (attributeList == null || attributeList.length == 0) {
            return false;
        }
        for (FieldAttribute anAttributeList : attributeList) {
            if (anAttributeList == attribute) {
                return true;
            }
        }
        return false;
    }

    private void checkNewFieldName(String fieldName) {
        checkLegalName(fieldName);
        checkFieldNameIsAvailable(fieldName);
    }

    static void checkLegalName(String fieldName) {
>>>>>>> YOURS
