C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b16816;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a16816;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c16816
<<<<<<< MINE
=======
private void defineTableStructure() {
		if (table != null && table.getTableSpec().getColumnCount() <= 0) {
			final TableSpec spec = new TableSpec();
			specifyStructure(spec);
			table.updateFromSpec(spec);
		}
	}
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b16596;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a16596;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c16596
<<<<<<< MINE
private void processAnnotatedElements(Set<? extends Element> elements)
			throws IOException {
		logger.info("Processing " + elements.size() + " elements...");

		URI uri = filer.getResource(StandardLocation.SOURCE_OUTPUT, "", "foo")
				.toUri();
		if (uri.toString().equals("foo")) {
			throw new RuntimeException(
					"The path of the Java source and generated files must be configured as source output! (see -s option of javac)");
		}

		List<File> sourcesPath = new LinkedList<File>();

		// FIXME: Workaround for OS X - resolve relative URIs against current working directory
		uri = new File(".").getAbsoluteFile().toURI().resolve(uri);

		File file = new File(uri);
		File outputFolder = file.getParentFile();
		File generatedSourcesPath = outputFolder;

		String[] sourceFolders = getSourceFolders();
		while (generatedSourcesPath != null) {
			for (String sourceFolder : sourceFolders) {
				File potentialPath = new File(generatedSourcesPath, sourceFolder);
				if (potentialPath.exists()) {
					sourcesPath.add(potentialPath);
					logger.info("Configured source folder: " + potentialPath);
				}
			}
			generatedSourcesPath = generatedSourcesPath.getParentFile();
		}

		// add the sources output folder as the last option to search sources
		sourcesPath.add(outputFolder);
		logger.info("Configured destination folder: " + outputFolder);

		prepareTables(elements);

		for (Element element : elements) {
			if (element instanceof TypeElement) {
				TypeElement model = (TypeElement) element;
				setupModelInfo(model);
			}
		}

		for (Element element : elements) {
			if (element instanceof TypeElement) {
				TypeElement model = (TypeElement) element;
				processModel(sourcesPath, model);
			}
		}
	}
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b17376;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a17376;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c17376
<<<<<<< MINE
//TODO: change to return index number
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b17376;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a17376;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c17376
<<<<<<< MINE
=======
//
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b09840;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a09840;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c09840
<<<<<<< MINE
//TODO: change to return index number
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b09840;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a09840;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c09840
<<<<<<< MINE
//
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b21436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a21436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c21436
<<<<<<< MINE
public static final long REQUIRED_JNI_VERSION = 19;
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b11088;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a11088;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c11088
<<<<<<< MINE
=======
/*

        public void insertBinary(long columnIndex, long rowIndex, ByteBuffer data) {
            if (immutable) throwImmutable();
            //System.err.printf("\ninsertBinary(col %d, row %d, ByteBuffer)\n", columnIndex, rowIndex);
            //System.err.println("-- HasArray: " + (data.hasArray() ? "yes":"no") + " len= " + data.array().length);
            if (data.isDirect())
                nativeInsertByteBuffer(nativePtr, columnIndex, rowIndex, data);
            else
                throw new RuntimeException("Currently ByteBuffer must be allocateDirect().");   // FIXME: support other than allocateDirect
        }

        */
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b11088;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a11088;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c11088
<<<<<<< MINE
=======
/**
     * Get the value of a (binary) cell.
     *
     * @param columnIndex
     *            0 based index value of the cell column
     * @param rowIndex
     *            0 based index value of the cell row
     * @return value of the particular cell.
     */
    /*
    public ByteBuffer getBinaryByteBuffer(long columnIndex, long rowIndex) {
        return nativeGetByteBuffer(nativePtr, columnIndex, rowIndex);
    }

    protected native ByteBuffer nativeGetByteBuffer(long nativeTablePtr, long columnIndex, long rowIndex);
    */
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b11088;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a11088;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c11088
<<<<<<< MINE
=======
/**
     * Sets the value for a (binary) cell.
     *
     * @param columnIndex
     *            column index of the cell
     * @param rowIndex
     *            row index of the cell
     * @param data
     *            the ByteBuffer must be allocated with ByteBuffer.allocateDirect(len)
     */

    /*
    public void setBinaryByteBuffer(long columnIndex, long rowIndex, ByteBuffer data) {
        if (immutable) throwImmutable();
        if (data == null)
            throw new NullPointerException("Null array");
        if (data.isDirect())
            nativeSetByteBuffer(nativePtr, columnIndex, rowIndex, data);
        else
            throw new RuntimeException("Currently ByteBuffer must be allocateDirect()."); // FIXME: support other than allocateDirect
    }

    protected native void nativeSetByteBuffer(long nativeTablePtr, long columnIndex, long rowIndex, ByteBuffer data);
    */
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b07640;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a07640;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c07640
<<<<<<< MINE
=======
/**
     * Appends the specified row to the end of the table
     * @param values
     * @return The row index of the appended row
     */
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b07640;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a07640;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c07640
<<<<<<< MINE
=======
/**
     * Replaces the row at the specified position with the specified row.
     * @param rowIndex
     * @param values
     */
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b07640;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a07640;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c07640
<<<<<<< MINE
=======
/**
     * Get the value of a (binary) cell.
     *
     * @param columnIndex
     *            0 based index value of the cell column
     * @param rowIndex
     *            0 based index value of the cell row
     * @return value of the particular cell.
     */
    /*
    public ByteBuffer getBinaryByteBuffer(long columnIndex, long rowIndex) {
        return nativeGetByteBuffer(nativePtr, columnIndex, rowIndex);
    }

    protected native ByteBuffer nativeGetByteBuffer(long nativeTablePtr, long columnIndex, long rowIndex);
    */
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b07640;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a07640;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c07640
<<<<<<< MINE
=======
/**
     * Sets the value for a (binary) cell.
     *
     * @param columnIndex
     *            column index of the cell
     * @param rowIndex
     *            row index of the cell
     * @param data
     *            the ByteBuffer must be allocated with ByteBuffer.allocateDirect(len)
     */

    /*
    public void setBinaryByteBuffer(long columnIndex, long rowIndex, ByteBuffer data) {
        if (immutable) throwImmutable();
        if (data == null)
            throw new NullPointerException("Null array");
        if (data.isDirect())
            nativeSetByteBuffer(nativePtr, columnIndex, rowIndex, data);
        else
            throw new RuntimeException("Currently ByteBuffer must be allocateDirect()."); // FIXME: support other than allocateDirect
    }

    protected native void nativeSetByteBuffer(long nativeTablePtr, long columnIndex, long rowIndex, ByteBuffer data);
    */
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b12328;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a12328;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c12328
<<<<<<< MINE
=======
/*
    protected void insertBinary(long columnIndex, long rowIndex, ByteBuffer value) {
        table.getInternalMethods().insertBinary(columnIndex, rowIndex, value);
    }
    */
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b12328;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a12328;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c12328
<<<<<<< MINE
=======
/* // Experimental
    public long lookup(String value) {
        return table.lookup(value);
    }*/
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b10928;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a10928;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c10928
<<<<<<< MINE
=======
@Override
    public TableDefinition getSubTableDefinition(long columnIndex) {
        if(nativeIsRootTable(nativePtr) == false)
            throw new UnsupportedOperationException("This is a subtable. Can only be called on root table.");

        long[] newPath = new long[1];
        newPath[0] = columnIndex;
        return new SubTableDefinition(nativePtr, newPath);
    }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b06404;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a06404;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c06404
<<<<<<< MINE
=======
/*
    protected void insertBinary(long columnIndex, long rowIndex, ByteBuffer value) {
        table.getInternalMethods().insertBinary(columnIndex, rowIndex, value);
    }
    */
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b06404;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a06404;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c06404
<<<<<<< MINE
=======
/* // Experimental
    public long lookup(String value) {
        return table.lookup(value);
    }*/
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b15340;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a15340;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c15340
<<<<<<< MINE
// If close() is called, no penalty is paid for delayed disposal
    // via the context
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b00232;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a00232;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c00232
<<<<<<< MINE
// If close() is called, no penalty is paid for delayed disposal
    // via the context
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b19012;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a19012;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c19012
<<<<<<< MINE
=======
//ASYNC(2); // TODO: re-enable when possible
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b04924;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a04924;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c04924
<<<<<<< MINE
=======
public void emitFields() throws IOException {

        int columnIndex = 0;

        for (FieldInfo field : fields) {
            String originalType = field.fieldElement.asType().toString();
            String fullType = convertSimpleTypesToObject(originalType);
            String shortType = fullType.substring(fullType.lastIndexOf(".") + 1);

            String returnCast = "";
            String camelCaseFieldName = Character.toUpperCase(field.fieldName.charAt(0)) + field.fieldName.substring(1);

            if (originalType.equals("int")) {
                fullType = "long";
                shortType = "Long";
                returnCast = "(" + originalType + ")";
            } else if (shortType.equals("Integer")) {
                fullType = "long";
                shortType = "Long";
                returnCast = "(int)";
            } else if (shortType.equals("byte[]")) {
                shortType = "BinaryByteArray";
                returnCast = "(byte[])";
            }

            String getterStmt = "return " + returnCast + "row.get" + shortType + "( " + columnIndex + " )";

            String setterStmt = "row.set" + shortType + "( " + columnIndex + ", value )";

            if (!field.fieldElement.asType().getKind().isPrimitive())
            {
                if (!originalType.equals("java.lang.String") &&
                	!originalType.equals("java.lang.Long") &&
                	!originalType.equals("java.lang.Integer") &&
                	!originalType.equals("java.lang.Float") &&
                	!originalType.equals("java.lang.Double") &&
                	!originalType.equals("java.lang.Boolean") &&
                	!originalType.equals("java.util.Date") &&
                	!originalType.equals("byte[]")) {
                	
                	// We now know this is a type derived from RealmObject - 
                	// this has already been checked in the RealmProcessor
                	setterStmt = String.format("if (value != null) {row.setLink( %d, value.realmGetRow().getIndex() );}", columnIndex);
                	getterStmt = String.format("return realmGetRow().getLink(%d)==-1?null:realm.get(%s.class, realmGetRow().getLink(%d))", columnIndex, fullType, columnIndex);
                    field.columnType = "ColumnType.LINK";
                }
            }
            
            columnIndex++;

            writer.emitAnnotation("Override").beginMethod(originalType, "get" + camelCaseFieldName, EnumSet.of(Modifier.PUBLIC))
                    .emitStatement(getterStmt)
                    .endMethod();

            writer.emitAnnotation("Override").beginMethod("void", "set" + camelCaseFieldName, EnumSet.of(Modifier.PUBLIC),
                    originalType, "value")
                    .emitStatement(setterStmt)
                    .endMethod().emitEmptyLine();
        }
    }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b04924;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a04924;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c04924
<<<<<<< MINE
            String fieldName = field.getSimpleName().toString();
            String fieldTypeCanonicalName = field.asType().toString();

            if (JAVA_TO_REALM_TYPES.containsKey(fieldTypeCanonicalName)) {
                /**
                 * Primitives and boxed types
                 */
                String realmType = JAVA_TO_REALM_TYPES.get(fieldTypeCanonicalName);
                String castingType = CASTING_TYPES.get(fieldTypeCanonicalName);

                // Getter
                writer.emitAnnotation("Override");
                writer.beginMethod(fieldTypeCanonicalName, "get" + capitaliseFirstChar(fieldName), EnumSet.of(Modifier.PUBLIC));
                writer.emitStatement(
                        "return (%s) row.get%s(%d)",
                        fieldTypeCanonicalName, realmType, columnNumber);
                writer.endMethod();
                writer.emitEmptyLine();

                // Setter
                writer.emitAnnotation("Override");
                writer.beginMethod("void", "set" + capitaliseFirstChar(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
                writer.emitStatement(
                        "row.set%s(%d, (%s) value)",
                        realmType, columnNumber, castingType);
                writer.endMethod();
            } else if (typeUtils.isAssignable(field.asType(), realmObject)) {
                /**
                 * Links
                 */

                // Getter
                writer.emitAnnotation("Override");
                writer.beginMethod(fieldTypeCanonicalName, "get" + capitaliseFirstChar(fieldName), EnumSet.of(Modifier.PUBLIC));
                writer.beginControlFlow("if (realmGetRow().isNullLink(%d))", columnNumber);
                writer.emitStatement("return null");
                writer.endControlFlow();
                writer.emitStatement(
                        "return realm.get(%s.class, realmGetRow().getLink(%d))",
                        fieldTypeCanonicalName, columnNumber);
                writer.endMethod();
                writer.emitEmptyLine();

                // Setter
                writer.emitAnnotation("Override");
                writer.beginMethod("void", "set" + capitaliseFirstChar(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
                writer.beginControlFlow("if (value == null)");
                writer.emitStatement("realmGetRow().nullifyLink(%d)", columnNumber);
                writer.endControlFlow();
                writer.emitStatement("realmGetRow().setLink(%d, value.realmGetRow().getIndex())", columnNumber);
                writer.endMethod();
            } else if (typeUtils.isAssignable(field.asType(), realmList)) {
                /**
                 * LinkLists
                 */
                String genericCanonicalType = ((DeclaredType) field.asType()).getTypeArguments().get(0).toString();
                String genericType;
                if (genericCanonicalType.contains(".")) {
                    genericType = genericCanonicalType.substring(genericCanonicalType.lastIndexOf('.') + 1);
                } else {
                    genericType = genericCanonicalType;
                }

                // Getter
                writer.emitAnnotation("Override");
                writer.beginMethod(fieldTypeCanonicalName, "get" + capitaliseFirstChar(fieldName), EnumSet.of(Modifier.PUBLIC));
                writer.emitStatement(
                        "return new RealmLinkList(%s.class, realmGetRow().getLinkList(%d), realm)",
                        genericType, columnNumber);
                writer.endMethod();
                writer.emitEmptyLine();

                // Setter
                writer.emitAnnotation("Override");
                writer.beginMethod("void", "set" + capitaliseFirstChar(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
                writer.emitStatement("LinkView links = realmGetRow().getLinkList(%d)", columnNumber);
                writer.beginControlFlow("if (value == null)");
                writer.emitStatement("return"); // TODO: delete all the links instead
                writer.endControlFlow();
                writer.beginControlFlow("for (RealmObject linkedObject : (RealmList<? extends RealmObject>) value)");
                writer.emitStatement("links.add(linkedObject.realmGetRow().getIndex())");
                writer.endControlFlow();
                writer.endMethod();
            } else {
                throw new UnsupportedOperationException(
                        String.format("Type %s of field %s is not supported", fieldTypeCanonicalName, fieldName));
            }
            writer.emitEmptyLine();
        }

        /**
         * initTable method
         */
        writer.beginMethod(
                "Table", // Return type
                "initTable", // Method name
                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
                "ImplicitTransaction", "transaction"); // Argument type & argument name

        writer.beginControlFlow("if(!transaction.hasTable(\"" + this.className + "\"))");
        writer.emitStatement("Table table = transaction.getTable(\"%s\")", this.className);
=======
        // Generate initTable method, which is used to create the datqbase table

        String tableName = this.className.toLowerCase(Locale.getDefault());

        writer.beginMethod("Table", "initTable", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC),
                "ImplicitTransaction", "transaction").
                beginControlFlow("if(!transaction.hasTable(\"" + tableName + "\"))").
                emitStatement("Table table = transaction.getTable(\"" + tableName + "\")");
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b19744;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a19744;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c19744
<<<<<<< MINE
        emitAccessors(writer);
        emitInitTableMethod(writer);
        emitValidateTableMethod(writer);
        emitGetFieldNamesMethod(writer);
        emitToStringMethod(writer);
        emitHashcodeMethod(writer);
        emitEqualsMethod(writer);
=======
        // Accessors
        for (VariableElement field : fields) {
            String fieldName = field.getSimpleName().toString();
            String fieldTypeCanonicalName = field.asType().toString();

            if (JAVA_TO_REALM_TYPES.containsKey(fieldTypeCanonicalName)) {
                /**
                 * Primitives and boxed types
                 */
                String realmType = JAVA_TO_REALM_TYPES.get(fieldTypeCanonicalName);
                String castingType = CASTING_TYPES.get(fieldTypeCanonicalName);

                // Getter
                writer.emitAnnotation("Override");
                writer.beginMethod(fieldTypeCanonicalName, getters.get(fieldName), EnumSet.of(Modifier.PUBLIC));
                writer.emitStatement(
                        "realm.assertThread()"
                );
                writer.emitStatement(
                        "return (%s) row.get%s(Realm.columnIndices.get(\"%s\").get(\"%s\"))",
                        fieldTypeCanonicalName, realmType, className, fieldName);
                writer.endMethod();
                writer.emitEmptyLine();

                // Setter
                writer.emitAnnotation("Override");
                writer.beginMethod("void", setters.get(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
                writer.emitStatement(
                        "realm.assertThread()"
                );
                writer.emitStatement(
                        "row.set%s(Realm.columnIndices.get(\"%s\").get(\"%s\"), (%s) value)",
                        realmType, className, fieldName, castingType);
                writer.endMethod();
            } else if (typeUtils.isAssignable(field.asType(), realmObject)) {
                /**
                 * Links
                 */

                // Getter
                writer.emitAnnotation("Override");
                writer.beginMethod(fieldTypeCanonicalName, getters.get(fieldName), EnumSet.of(Modifier.PUBLIC));
                writer.beginControlFlow("if (row.isNullLink(Realm.columnIndices.get(\"%s\").get(\"%s\")))", className, fieldName);
                writer.emitStatement("return null");
                writer.endControlFlow();
                writer.emitStatement(
                        "return realm.get(%s.class, row.getLink(Realm.columnIndices.get(\"%s\").get(\"%s\")))",
                        fieldTypeCanonicalName, className, fieldName);
                writer.endMethod();
                writer.emitEmptyLine();

                // Setter
                writer.emitAnnotation("Override");
                writer.beginMethod("void", setters.get(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
                writer.beginControlFlow("if (value == null)");
                writer.emitStatement("row.nullifyLink(Realm.columnIndices.get(\"%s\").get(\"%s\"))", className, fieldName);
                writer.endControlFlow();
                writer.emitStatement("row.setLink(Realm.columnIndices.get(\"%s\").get(\"%s\"), value.row.getIndex())", className, fieldName);
                writer.endMethod();
            } else if (typeUtils.isAssignable(field.asType(), realmList)) {
                /**
                 * LinkLists
                 */
                String genericCanonicalType = ((DeclaredType) field.asType()).getTypeArguments().get(0).toString();
                String genericType;
                if (genericCanonicalType.contains(".")) {
                    genericType = genericCanonicalType.substring(genericCanonicalType.lastIndexOf('.') + 1);
                } else {
                    genericType = genericCanonicalType;
                }

                // Getter
                writer.emitAnnotation("Override");
                writer.beginMethod(fieldTypeCanonicalName, getters.get(fieldName), EnumSet.of(Modifier.PUBLIC));
                writer.emitStatement(
                        "return new RealmList(%s.class, row.getLinkList(Realm.columnIndices.get(\"%s\").get(\"%s\")), realm)",
                        genericType, className, fieldName);
                writer.endMethod();
                writer.emitEmptyLine();

                // Setter
                writer.emitAnnotation("Override");
                writer.beginMethod("void", setters.get(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
                writer.emitStatement("LinkView links = row.getLinkList(Realm.columnIndices.get(\"%s\").get(\"%s\"))", className, fieldName);
                writer.beginControlFlow("if (value == null)");
                writer.emitStatement("return"); // TODO: delete all the links instead
                writer.endControlFlow();
                writer.beginControlFlow("for (RealmObject linkedObject : (RealmList<? extends RealmObject>) value)");
                writer.emitStatement("links.add(linkedObject.row.getIndex())");
                writer.endControlFlow();
                writer.endMethod();
            } else {
                throw new UnsupportedOperationException(
                        String.format("Type %s of field %s is not supported", fieldTypeCanonicalName, fieldName));
            }
            writer.emitEmptyLine();
        }

        /**
         * initTable method
         */
        writer.beginMethod(
                "Table", // Return type
                "initTable", // Method name
                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
                "ImplicitTransaction", "transaction"); // Argument type & argument name

        writer.beginControlFlow("if(!transaction.hasTable(\"" + TABLE_PREFIX + this.className + "\"))");
        writer.emitStatement("Table table = transaction.getTable(\"%s%s\")", TABLE_PREFIX, this.className);

        // For each field generate corresponding table index constant
        for (VariableElement field : fields) {
            String fieldName = field.getSimpleName().toString();
            String fieldTypeCanonicalName = field.asType().toString();
            String fieldTypeName;
            if (fieldTypeCanonicalName.contains(".")) {
                fieldTypeName = fieldTypeCanonicalName.substring(fieldTypeCanonicalName.lastIndexOf('.') + 1);
            } else {
                fieldTypeName = fieldTypeCanonicalName;
            }

            if (JAVA_TO_REALM_TYPES.containsKey(fieldTypeCanonicalName)) {
                writer.emitStatement("table.addColumn(%s, \"%s\")",
                        JAVA_TO_COLUMN_TYPES.get(fieldTypeCanonicalName),
                        fieldName);
            } else if (typeUtils.isAssignable(field.asType(), realmObject)) {
                writer.beginControlFlow("if (!transaction.hasTable(\"%s%s\"))", TABLE_PREFIX, fieldTypeName);
                writer.emitStatement("%s%s.initTable(transaction)", fieldTypeName, PROXY_SUFFIX);
                writer.endControlFlow();
                writer.emitStatement("table.addColumnLink(ColumnType.LINK, \"%s\", transaction.getTable(\"%s%s\"))",
                        fieldName, TABLE_PREFIX, fieldTypeName);
            } else if (typeUtils.isAssignable(field.asType(), realmList)) {
                String genericCanonicalType = ((DeclaredType) field.asType()).getTypeArguments().get(0).toString();
                String genericType;
                if (genericCanonicalType.contains(".")) {
                    genericType = genericCanonicalType.substring(genericCanonicalType.lastIndexOf('.') + 1);
                } else {
                    genericType = genericCanonicalType;
                }
                writer.beginControlFlow("if (!transaction.hasTable(\"%s%s\"))", TABLE_PREFIX, genericType);
                writer.emitStatement("%s%s.initTable(transaction)", genericType, PROXY_SUFFIX);
                writer.endControlFlow();
                writer.emitStatement("table.addColumnLink(ColumnType.LINK_LIST, \"%s\", transaction.getTable(\"%s%s\"))",
                        fieldName, TABLE_PREFIX, genericType);
            }
        }

        for (VariableElement field : fieldsToIndex) {
            String fieldName = field.getSimpleName().toString();
            writer.emitStatement("table.setIndex(table.getColumnIndex(\"%s\"))", fieldName);
        }

        writer.emitStatement("return table");
        writer.endControlFlow();
        writer.emitStatement("return transaction.getTable(\"%s%s\")", TABLE_PREFIX, this.className);
        writer.endMethod();
        writer.emitEmptyLine();

        /**
         * validateTable method
         */
        writer.beginMethod(
                "void", // Return type
                "validateTable", // Method name
                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
                "ImplicitTransaction", "transaction"); // Argument type & argument name

        writer.beginControlFlow("if(transaction.hasTable(\"" + TABLE_PREFIX + this.className + "\"))");
        writer.emitStatement("Table table = transaction.getTable(\"%s%s\")", TABLE_PREFIX, this.className);

        // verify number of columns
        writer.beginControlFlow("if(table.getColumnCount() != " + fields.size() + ")");
        writer.emitStatement("throw new IllegalStateException(\"Column count does not match\")");
        writer.endControlFlow();

        // create type dictionary for lookup
        writer.emitStatement("Map<String, ColumnType> columnTypes = new HashMap<String, ColumnType>()");
        writer.beginControlFlow("for(long i = 0; i < " + fields.size() + "; i++)");
        writer.emitStatement("columnTypes.put(table.getColumnName(i), table.getColumnType(i))");
        writer.endControlFlow();

        // For each field verify there is a corresponding column
        for (VariableElement field : fields) {
            String fieldName = field.getSimpleName().toString();
            String fieldTypeCanonicalName = field.asType().toString();
            String fieldTypeName;
            if (fieldTypeCanonicalName.contains(".")) {
                fieldTypeName = fieldTypeCanonicalName.substring(fieldTypeCanonicalName.lastIndexOf('.') + 1);
            } else {
                fieldTypeName = fieldTypeCanonicalName;
            }

            if (JAVA_TO_REALM_TYPES.containsKey(fieldTypeCanonicalName)) {
                // make sure types align
                writer.beginControlFlow("if (!columnTypes.containsKey(\"%s\"))", fieldName);
                writer.emitStatement("throw new IllegalStateException(\"Missing column '%s'\")", fieldName);
                writer.endControlFlow();
                writer.beginControlFlow("if (columnTypes.get(\"%s\") != %s)", fieldName, JAVA_TO_COLUMN_TYPES.get(fieldTypeCanonicalName));
                writer.emitStatement("throw new IllegalStateException(\"Invalid type '%s' for column '%s'\")",
                        fieldTypeName, fieldName);
                writer.endControlFlow();
            } else if (typeUtils.isAssignable(field.asType(), realmObject)) { // Links
                writer.beginControlFlow("if (!columnTypes.containsKey(\"%s\"))", fieldName);
                writer.emitStatement("throw new IllegalStateException(\"Missing column '%s'\")", fieldName);
                writer.endControlFlow();
                writer.beginControlFlow("if (columnTypes.get(\"%s\") != ColumnType.LINK)", fieldName);
                writer.emitStatement("throw new IllegalStateException(\"Invalid type '%s' for column '%s'\")",
                        fieldTypeName, fieldName);
                writer.endControlFlow();
                writer.beginControlFlow("if (!transaction.hasTable(\"%s%s\"))", TABLE_PREFIX, fieldTypeName);
                writer.emitStatement("throw new IllegalStateException(\"Missing table '%s%s' for column '%s'\")",
                        TABLE_PREFIX, fieldTypeName, fieldName);
                writer.endControlFlow();
                // TODO: Replace with a proper comparison
//                writer.emitStatement("Table table_%d = transaction.getTable(\"%s%s\")", columnNumber, TABLE_PREFIX, fieldTypeName);
//                writer.beginControlFlow("if (table.getLinkTarget(%d).equals(table_%d))", columnNumber, columnNumber);
//                writer.emitStatement("throw new IllegalStateException(\"Mismatching link tables for column '%s'\")",
//                        fieldName);
//                writer.endControlFlow();
            } else if (typeUtils.isAssignable(field.asType(), realmList)) { // Link Lists
                String genericCanonicalType = ((DeclaredType) field.asType()).getTypeArguments().get(0).toString();
                String genericType;
                if (genericCanonicalType.contains(".")) {
                    genericType = genericCanonicalType.substring(genericCanonicalType.lastIndexOf('.') + 1);
                } else {
                    genericType = genericCanonicalType;
                }
                writer.beginControlFlow("if(!columnTypes.containsKey(\"%s\"))", fieldName);
                writer.emitStatement("throw new IllegalStateException(\"Missing column '%s'\")", fieldName);
                writer.endControlFlow();
                writer.beginControlFlow("if(columnTypes.get(\"%s\") != ColumnType.LINK_LIST)", fieldName);
                writer.emitStatement("throw new IllegalStateException(\"Invalid type '%s' for column '%s'\")",
                        genericType, fieldName);
                writer.endControlFlow();
                writer.beginControlFlow("if (!transaction.hasTable(\"%s%s\"))", TABLE_PREFIX, genericType);
                writer.emitStatement("throw new IllegalStateException(\"Missing table '%s%s' for column '%s'\")",
                        TABLE_PREFIX, genericType, fieldName);
                writer.endControlFlow();
                // TODO: Replace with a proper comparison
//                writer.emitStatement("Table table_%d = transaction.getTable(\"%s%s\")", columnNumber, TABLE_PREFIX, genericType);
//                writer.beginControlFlow("if (table.getLinkTarget(%d).equals(table_%d))", columnNumber, columnNumber);
//                writer.emitStatement("throw new IllegalStateException(\"Mismatching link list tables for column '%s'\")",
//                        fieldName);
//                writer.endControlFlow();
            }
        }
        writer.endControlFlow();
        writer.endMethod();
        writer.emitEmptyLine();

        /**
         * getFieldNames method
         */
        writer.beginMethod("List<String>", "getFieldNames", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC));
        List<String> entries = new ArrayList<String>();
        for (VariableElement field : fields) {
            String fieldName = field.getSimpleName().toString();
            entries.add(String.format("\"%s\"", fieldName));
        }
        String statementSection = joinStringList(entries, ", ");
        writer.emitStatement("return Arrays.asList(%s)", statementSection);
        writer.endMethod();
        writer.emitEmptyLine();

        /**
         * toString method
         */
        writer.emitAnnotation("Override");
        writer.beginMethod("String", "toString", EnumSet.of(Modifier.PUBLIC));
        writer.emitStatement("StringBuilder stringBuilder = new StringBuilder(\"%s = [\")", className);
        for (VariableElement field : fields) {
            String fieldName = field.getSimpleName().toString();
            writer.emitStatement("stringBuilder.append(\"{%s:\")", fieldName);
            writer.emitStatement("stringBuilder.append(%s())", getters.get(fieldName));
            writer.emitStatement("stringBuilder.append(\"} \")", fieldName);
        }
        writer.emitStatement("stringBuilder.append(\"]\")");
        writer.emitStatement("return stringBuilder.toString()");
        writer.endMethod();
        writer.emitEmptyLine();

        /**
         * hashCode method
         */
        writer.emitAnnotation("Override");
        writer.beginMethod("int", "hashCode", EnumSet.of(Modifier.PUBLIC));
        writer.emitStatement("int result = 17");
        int counter = 0;
        for (VariableElement field : fields) {
            String fieldName = field.getSimpleName().toString();
            String fieldTypeCanonicalName = field.asType().toString();
            if (HASHCODE.containsKey(fieldTypeCanonicalName)) {
                for (String statement : HASHCODE.get(fieldTypeCanonicalName)) {
                    if (statement.contains("%d") && statement.contains("%s")) {
                        // This statement introduces a temporary variable
                        writer.emitStatement(statement, counter, getters.get(fieldName));
                    } else if(statement.contains("%d")) {
                        // This statement uses the temporary variable
                        writer.emitStatement(statement, counter, counter);
                    } else if (statement.contains("%s")) {
                        // This is a normal statement with only one assignment
                        writer.emitStatement(statement, getters.get(fieldName));
                    } else {
                        // This should never happen
                        throw new AssertionError();
                    }
                }
            } else {
                // Links and Link lists
                writer.emitStatement("%s temp_%d = %s()", fieldTypeCanonicalName, counter, getters.get(fieldName));
                writer.emitStatement("result = 31 * result + (temp_%d != null ? temp_%d.hashCode() : 0)", counter, counter);
            }
            counter++;
        }
        writer.emitStatement("return result");
        writer.endMethod();
        writer.emitEmptyLine();

        /**
         * equals method
         */
        String proxyClassName = className + PROXY_SUFFIX;
        writer.emitAnnotation("Override");
        writer.beginMethod("boolean", "equals", EnumSet.of(Modifier.PUBLIC), "Object", "o");
        writer.emitStatement("if (this == o) return true");
        writer.emitStatement("if (o == null || getClass() != o.getClass()) return false");
        writer.emitStatement("%s a%s = (%s)o", proxyClassName, className, proxyClassName);  // FooRealmProxy aFoo = (FooRealmProxy)o

        for (VariableElement field : fields) {
            String fieldName = field.getSimpleName().toString();
            String capFieldName = capitaliseFirstChar(fieldName);
            String fieldTypeCanonicalName = field.asType().toString();
            if (HOW_TO_EQUAL.containsKey(fieldTypeCanonicalName)) {
                switch (HOW_TO_EQUAL.get(fieldTypeCanonicalName)) {
                    case EQUALS_DIRECT: // if (getField() != aFoo.getField()) return false
                        writer.emitStatement("if (%s() != a%s.%s()) return false", getters.get(fieldName), className, getters.get(fieldName));
                        break;
                    case EQUALS_NULL: // if (getField() != null = !getField().equals(aFoo.getField()) : aFoo.getField() != null) return false
                        writer.emitStatement("if (%s() != null ? !%s().equals(a%s.%s()) : a%s.%s() != null) return false",
                                getters.get(fieldName),
                                getters.get(fieldName), className, getters.get(fieldName),
                                className, getters.get(fieldName));
                        break;
                    case EQUALS_ARRAY: // if (!Arrays.equals(getField(), aFoo.getField())) return false
                        writer.emitStatement("if (!Arrays.equals(%s(), a%s.%s())) return false",
                                getters.get(fieldName),
                                className, getters.get(fieldName));
                        break;
                    case EQUALS_COMPARE: // if (
                        writer.emitStatement("if (%s.compare(%s(), a%s.%s()) != 0) return false",
                                capitaliseFirstChar(fieldTypeCanonicalName), getters.get(fieldName), className,
                                getters.get(fieldName));
                        break;
                }
            }
            else if (typeUtils.isAssignable(field.asType(), realmObject) || typeUtils.isAssignable(field.asType(), realmList)) {
                writer.emitStatement("if (%s() != null ? !%s().equals(a%s.%s()) : a%s.%s() != null) return false",
                        getters.get(fieldName),
                        getters.get(fieldName), className, getters.get(fieldName),
                        className, getters.get(fieldName));
            }
        }
        writer.emitStatement("return true");
        writer.endMethod();
        writer.emitEmptyLine();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b14100;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a14100;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c14100
<<<<<<< MINE
        emitAccessors(writer);
        emitInitTableMethod(writer);
        emitValidateTableMethod(writer);
        emitGetFieldNamesMethod(writer);
        emitToStringMethod(writer);
        emitHashCodeMethod(writer);
        emitEqualsMethod(writer);
=======
        // Accessors
        for (VariableElement field : fields) {
            String fieldName = field.getSimpleName().toString();
            String fieldTypeCanonicalName = field.asType().toString();

            if (JAVA_TO_REALM_TYPES.containsKey(fieldTypeCanonicalName)) {
                /**
                 * Primitives and boxed types
                 */
                String realmType = JAVA_TO_REALM_TYPES.get(fieldTypeCanonicalName);
                String castingType = CASTING_TYPES.get(fieldTypeCanonicalName);

                // Getter
                writer.emitAnnotation("Override");
                writer.beginMethod(fieldTypeCanonicalName, getters.get(fieldName), EnumSet.of(Modifier.PUBLIC));
                writer.emitStatement(
                        "realm.assertThread()"
                );
                writer.emitStatement(
                        "return (%s) row.get%s(Realm.columnIndices.get(\"%s\").get(\"%s\"))",
                        fieldTypeCanonicalName, realmType, className, fieldName);
                writer.endMethod();
                writer.emitEmptyLine();

                // Setter
                writer.emitAnnotation("Override");
                writer.beginMethod("void", setters.get(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
                writer.emitStatement(
                        "realm.assertThread()"
                );
                writer.emitStatement(
                        "row.set%s(Realm.columnIndices.get(\"%s\").get(\"%s\"), (%s) value)",
                        realmType, className, fieldName, castingType);
                writer.endMethod();
            } else if (typeUtils.isAssignable(field.asType(), realmObject)) {
                /**
                 * Links
                 */

                // Getter
                writer.emitAnnotation("Override");
                writer.beginMethod(fieldTypeCanonicalName, getters.get(fieldName), EnumSet.of(Modifier.PUBLIC));
                writer.beginControlFlow("if (row.isNullLink(Realm.columnIndices.get(\"%s\").get(\"%s\")))", className, fieldName);
                writer.emitStatement("return null");
                writer.endControlFlow();
                writer.emitStatement(
                        "return realm.get(%s.class, row.getLink(Realm.columnIndices.get(\"%s\").get(\"%s\")))",
                        fieldTypeCanonicalName, className, fieldName);
                writer.endMethod();
                writer.emitEmptyLine();

                // Setter
                writer.emitAnnotation("Override");
                writer.beginMethod("void", setters.get(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
                writer.beginControlFlow("if (value == null)");
                writer.emitStatement("row.nullifyLink(Realm.columnIndices.get(\"%s\").get(\"%s\"))", className, fieldName);
                writer.endControlFlow();
                writer.emitStatement("row.setLink(Realm.columnIndices.get(\"%s\").get(\"%s\"), value.row.getIndex())", className, fieldName);
                writer.endMethod();
            } else if (typeUtils.isAssignable(field.asType(), realmList)) {
                /**
                 * LinkLists
                 */
                String genericCanonicalType = ((DeclaredType) field.asType()).getTypeArguments().get(0).toString();
                String genericType;
                if (genericCanonicalType.contains(".")) {
                    genericType = genericCanonicalType.substring(genericCanonicalType.lastIndexOf('.') + 1);
                } else {
                    genericType = genericCanonicalType;
                }

                // Getter
                writer.emitAnnotation("Override");
                writer.beginMethod(fieldTypeCanonicalName, getters.get(fieldName), EnumSet.of(Modifier.PUBLIC));
                writer.emitStatement(
                        "return new RealmList<%s>(%s.class, row.getLinkList(Realm.columnIndices.get(\"%s\").get(\"%s\")), realm)",
                        genericType, genericType, className, fieldName);
                writer.endMethod();
                writer.emitEmptyLine();

                // Setter
                writer.emitAnnotation("Override");
                writer.beginMethod("void", setters.get(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
                writer.emitStatement("LinkView links = row.getLinkList(Realm.columnIndices.get(\"%s\").get(\"%s\"))", className, fieldName);
                writer.beginControlFlow("if (value == null)");
                writer.emitStatement("return"); // TODO: delete all the links instead
                writer.endControlFlow();
                writer.beginControlFlow("for (RealmObject linkedObject : (RealmList<? extends RealmObject>) value)");
                writer.emitStatement("links.add(linkedObject.row.getIndex())");
                writer.endControlFlow();
                writer.endMethod();
            } else {
                throw new UnsupportedOperationException(
                        String.format("Type %s of field %s is not supported", fieldTypeCanonicalName, fieldName));
            }
            writer.emitEmptyLine();
        }

        /**
         * initTable method
         */
        writer.beginMethod(
                "Table", // Return type
                "initTable", // Method name
                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
                "ImplicitTransaction", "transaction"); // Argument type & argument name

        writer.beginControlFlow("if(!transaction.hasTable(\"" + TABLE_PREFIX + this.className + "\"))");
        writer.emitStatement("Table table = transaction.getTable(\"%s%s\")", TABLE_PREFIX, this.className);

        // For each field generate corresponding table index constant
        for (VariableElement field : fields) {
            String fieldName = field.getSimpleName().toString();
            String fieldTypeCanonicalName = field.asType().toString();
            String fieldTypeName;
            if (fieldTypeCanonicalName.contains(".")) {
                fieldTypeName = fieldTypeCanonicalName.substring(fieldTypeCanonicalName.lastIndexOf('.') + 1);
            } else {
                fieldTypeName = fieldTypeCanonicalName;
            }

            if (JAVA_TO_REALM_TYPES.containsKey(fieldTypeCanonicalName)) {
                writer.emitStatement("table.addColumn(%s, \"%s\")",
                        JAVA_TO_COLUMN_TYPES.get(fieldTypeCanonicalName),
                        fieldName);
            } else if (typeUtils.isAssignable(field.asType(), realmObject)) {
                writer.beginControlFlow("if (!transaction.hasTable(\"%s%s\"))", TABLE_PREFIX, fieldTypeName);
                writer.emitStatement("%s%s.initTable(transaction)", fieldTypeName, PROXY_SUFFIX);
                writer.endControlFlow();
                writer.emitStatement("table.addColumnLink(ColumnType.LINK, \"%s\", transaction.getTable(\"%s%s\"))",
                        fieldName, TABLE_PREFIX, fieldTypeName);
            } else if (typeUtils.isAssignable(field.asType(), realmList)) {
                String genericCanonicalType = ((DeclaredType) field.asType()).getTypeArguments().get(0).toString();
                String genericType;
                if (genericCanonicalType.contains(".")) {
                    genericType = genericCanonicalType.substring(genericCanonicalType.lastIndexOf('.') + 1);
                } else {
                    genericType = genericCanonicalType;
                }
                writer.beginControlFlow("if (!transaction.hasTable(\"%s%s\"))", TABLE_PREFIX, genericType);
                writer.emitStatement("%s%s.initTable(transaction)", genericType, PROXY_SUFFIX);
                writer.endControlFlow();
                writer.emitStatement("table.addColumnLink(ColumnType.LINK_LIST, \"%s\", transaction.getTable(\"%s%s\"))",
                        fieldName, TABLE_PREFIX, genericType);
            }
        }

        for (VariableElement field : fieldsToIndex) {
            String fieldName = field.getSimpleName().toString();
            writer.emitStatement("table.setIndex(table.getColumnIndex(\"%s\"))", fieldName);
        }

        writer.emitStatement("return table");
        writer.endControlFlow();
        writer.emitStatement("return transaction.getTable(\"%s%s\")", TABLE_PREFIX, this.className);
        writer.endMethod();
        writer.emitEmptyLine();

        /**
         * validateTable method
         */
        writer.beginMethod(
                "void", // Return type
                "validateTable", // Method name
                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
                "ImplicitTransaction", "transaction"); // Argument type & argument name

        writer.beginControlFlow("if(transaction.hasTable(\"" + TABLE_PREFIX + this.className + "\"))");
        writer.emitStatement("Table table = transaction.getTable(\"%s%s\")", TABLE_PREFIX, this.className);

        // verify number of columns
        writer.beginControlFlow("if(table.getColumnCount() != " + fields.size() + ")");
        writer.emitStatement("throw new IllegalStateException(\"Column count does not match\")");
        writer.endControlFlow();

        // create type dictionary for lookup
        writer.emitStatement("Map<String, ColumnType> columnTypes = new HashMap<String, ColumnType>()");
        writer.beginControlFlow("for(long i = 0; i < " + fields.size() + "; i++)");
        writer.emitStatement("columnTypes.put(table.getColumnName(i), table.getColumnType(i))");
        writer.endControlFlow();

        // For each field verify there is a corresponding column
        for (VariableElement field : fields) {
            String fieldName = field.getSimpleName().toString();
            String fieldTypeCanonicalName = field.asType().toString();
            String fieldTypeName;
            if (fieldTypeCanonicalName.contains(".")) {
                fieldTypeName = fieldTypeCanonicalName.substring(fieldTypeCanonicalName.lastIndexOf('.') + 1);
            } else {
                fieldTypeName = fieldTypeCanonicalName;
            }

            if (JAVA_TO_REALM_TYPES.containsKey(fieldTypeCanonicalName)) {
                // make sure types align
                writer.beginControlFlow("if (!columnTypes.containsKey(\"%s\"))", fieldName);
                writer.emitStatement("throw new IllegalStateException(\"Missing column '%s'\")", fieldName);
                writer.endControlFlow();
                writer.beginControlFlow("if (columnTypes.get(\"%s\") != %s)", fieldName, JAVA_TO_COLUMN_TYPES.get(fieldTypeCanonicalName));
                writer.emitStatement("throw new IllegalStateException(\"Invalid type '%s' for column '%s'\")",
                        fieldTypeName, fieldName);
                writer.endControlFlow();
            } else if (typeUtils.isAssignable(field.asType(), realmObject)) { // Links
                writer.beginControlFlow("if (!columnTypes.containsKey(\"%s\"))", fieldName);
                writer.emitStatement("throw new IllegalStateException(\"Missing column '%s'\")", fieldName);
                writer.endControlFlow();
                writer.beginControlFlow("if (columnTypes.get(\"%s\") != ColumnType.LINK)", fieldName);
                writer.emitStatement("throw new IllegalStateException(\"Invalid type '%s' for column '%s'\")",
                        fieldTypeName, fieldName);
                writer.endControlFlow();
                writer.beginControlFlow("if (!transaction.hasTable(\"%s%s\"))", TABLE_PREFIX, fieldTypeName);
                writer.emitStatement("throw new IllegalStateException(\"Missing table '%s%s' for column '%s'\")",
                        TABLE_PREFIX, fieldTypeName, fieldName);
                writer.endControlFlow();
                // TODO: Replace with a proper comparison
//                writer.emitStatement("Table table_%d = transaction.getTable(\"%s%s\")", columnNumber, TABLE_PREFIX, fieldTypeName);
//                writer.beginControlFlow("if (table.getLinkTarget(%d).equals(table_%d))", columnNumber, columnNumber);
//                writer.emitStatement("throw new IllegalStateException(\"Mismatching link tables for column '%s'\")",
//                        fieldName);
//                writer.endControlFlow();
            } else if (typeUtils.isAssignable(field.asType(), realmList)) { // Link Lists
                String genericCanonicalType = ((DeclaredType) field.asType()).getTypeArguments().get(0).toString();
                String genericType;
                if (genericCanonicalType.contains(".")) {
                    genericType = genericCanonicalType.substring(genericCanonicalType.lastIndexOf('.') + 1);
                } else {
                    genericType = genericCanonicalType;
                }
                writer.beginControlFlow("if(!columnTypes.containsKey(\"%s\"))", fieldName);
                writer.emitStatement("throw new IllegalStateException(\"Missing column '%s'\")", fieldName);
                writer.endControlFlow();
                writer.beginControlFlow("if(columnTypes.get(\"%s\") != ColumnType.LINK_LIST)", fieldName);
                writer.emitStatement("throw new IllegalStateException(\"Invalid type '%s' for column '%s'\")",
                        genericType, fieldName);
                writer.endControlFlow();
                writer.beginControlFlow("if (!transaction.hasTable(\"%s%s\"))", TABLE_PREFIX, genericType);
                writer.emitStatement("throw new IllegalStateException(\"Missing table '%s%s' for column '%s'\")",
                        TABLE_PREFIX, genericType, fieldName);
                writer.endControlFlow();
                // TODO: Replace with a proper comparison
//                writer.emitStatement("Table table_%d = transaction.getTable(\"%s%s\")", columnNumber, TABLE_PREFIX, genericType);
//                writer.beginControlFlow("if (table.getLinkTarget(%d).equals(table_%d))", columnNumber, columnNumber);
//                writer.emitStatement("throw new IllegalStateException(\"Mismatching link list tables for column '%s'\")",
//                        fieldName);
//                writer.endControlFlow();
            }
        }
        writer.endControlFlow();
        writer.endMethod();
        writer.emitEmptyLine();

        /**
         * getFieldNames method
         */
        writer.beginMethod("List<String>", "getFieldNames", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC));
        List<String> entries = new ArrayList<String>();
        for (VariableElement field : fields) {
            String fieldName = field.getSimpleName().toString();
            entries.add(String.format("\"%s\"", fieldName));
        }
        String statementSection = joinStringList(entries, ", ");
        writer.emitStatement("return Arrays.asList(%s)", statementSection);
        writer.endMethod();
        writer.emitEmptyLine();

        /**
         * toString method
         */
        writer.emitAnnotation("Override");
        writer.beginMethod("String", "toString", EnumSet.of(Modifier.PUBLIC));
        writer.emitStatement("StringBuilder stringBuilder = new StringBuilder(\"%s = [\")", className);
        for (VariableElement field : fields) {
            String fieldName = field.getSimpleName().toString();
            writer.emitStatement("stringBuilder.append(\"{%s:\")", fieldName);
            writer.emitStatement("stringBuilder.append(%s())", getters.get(fieldName));
            writer.emitStatement("stringBuilder.append(\"} \")", fieldName);
        }
        writer.emitStatement("stringBuilder.append(\"]\")");
        writer.emitStatement("return stringBuilder.toString()");
        writer.endMethod();
        writer.emitEmptyLine();

        /**
         * hashCode method
         */
        writer.emitAnnotation("Override");
        writer.beginMethod("int", "hashCode", EnumSet.of(Modifier.PUBLIC));
        writer.emitStatement("int result = 17");
        int counter = 0;
        for (VariableElement field : fields) {
            String fieldName = field.getSimpleName().toString();
            String fieldTypeCanonicalName = field.asType().toString();
            if (HASHCODE.containsKey(fieldTypeCanonicalName)) {
                for (String statement : HASHCODE.get(fieldTypeCanonicalName)) {
                    if (statement.contains("%d") && statement.contains("%s")) {
                        // This statement introduces a temporary variable
                        writer.emitStatement(statement, counter, getters.get(fieldName));
                    } else if(statement.contains("%d")) {
                        // This statement uses the temporary variable
                        writer.emitStatement(statement, counter, counter);
                    } else if (statement.contains("%s")) {
                        // This is a normal statement with only one assignment
                        writer.emitStatement(statement, getters.get(fieldName));
                    } else {
                        // This should never happen
                        throw new AssertionError();
                    }
                }
            } else {
                // Links and Link lists
                writer.emitStatement("%s temp_%d = %s()", fieldTypeCanonicalName, counter, getters.get(fieldName));
                writer.emitStatement("result = 31 * result + (temp_%d != null ? temp_%d.hashCode() : 0)", counter, counter);
            }
            counter++;
        }
        writer.emitStatement("return result");
        writer.endMethod();
        writer.emitEmptyLine();

        /**
         * equals method
         */
        String proxyClassName = className + PROXY_SUFFIX;
        writer.emitAnnotation("Override");
        writer.beginMethod("boolean", "equals", EnumSet.of(Modifier.PUBLIC), "Object", "o");
        writer.emitStatement("if (this == o) return true");
        writer.emitStatement("if (o == null || getClass() != o.getClass()) return false");
        writer.emitStatement("%s a%s = (%s)o", proxyClassName, className, proxyClassName);  // FooRealmProxy aFoo = (FooRealmProxy)o

        for (VariableElement field : fields) {
            String fieldName = field.getSimpleName().toString();
            String capFieldName = capitaliseFirstChar(fieldName);
            String fieldTypeCanonicalName = field.asType().toString();
            if (HOW_TO_EQUAL.containsKey(fieldTypeCanonicalName)) {
                switch (HOW_TO_EQUAL.get(fieldTypeCanonicalName)) {
                    case EQUALS_DIRECT: // if (getField() != aFoo.getField()) return false
                        writer.emitStatement("if (%s() != a%s.%s()) return false", getters.get(fieldName), className, getters.get(fieldName));
                        break;
                    case EQUALS_NULL: // if (getField() != null = !getField().equals(aFoo.getField()) : aFoo.getField() != null) return false
                        writer.emitStatement("if (%s() != null ? !%s().equals(a%s.%s()) : a%s.%s() != null) return false",
                                getters.get(fieldName),
                                getters.get(fieldName), className, getters.get(fieldName),
                                className, getters.get(fieldName));
                        break;
                    case EQUALS_ARRAY: // if (!Arrays.equals(getField(), aFoo.getField())) return false
                        writer.emitStatement("if (!Arrays.equals(%s(), a%s.%s())) return false",
                                getters.get(fieldName),
                                className, getters.get(fieldName));
                        break;
                    case EQUALS_COMPARE: // if (
                        writer.emitStatement("if (%s.compare(%s(), a%s.%s()) != 0) return false",
                                capitaliseFirstChar(fieldTypeCanonicalName), getters.get(fieldName), className,
                                getters.get(fieldName));
                        break;
                }
            }
            else if (typeUtils.isAssignable(field.asType(), realmObject) || typeUtils.isAssignable(field.asType(), realmList)) {
                writer.emitStatement("if (%s() != null ? !%s().equals(a%s.%s()) : a%s.%s() != null) return false",
                        getters.get(fieldName),
                        getters.get(fieldName), className, getters.get(fieldName),
                        className, getters.get(fieldName));
            }
        }
        writer.emitStatement("return true");
        writer.endMethod();
        writer.emitEmptyLine();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b03252;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a03252;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c03252
<<<<<<< MINE
        emitAccessors(writer);
        emitInitTableMethod(writer);
        emitValidateTableMethod(writer);
        emitGetFieldNamesMethod(writer);
        emitToStringMethod(writer);
        emitHashcodeMethod(writer);
        emitEqualsMethod(writer);
=======
        // Accessors
        for (VariableElement field : fields) {
            String fieldName = field.getSimpleName().toString();
            String fieldTypeCanonicalName = field.asType().toString();

            if (JAVA_TO_REALM_TYPES.containsKey(fieldTypeCanonicalName)) {
                /**
                 * Primitives and boxed types
                 */
                String realmType = JAVA_TO_REALM_TYPES.get(fieldTypeCanonicalName);
                String castingType = CASTING_TYPES.get(fieldTypeCanonicalName);

                // Getter
                writer.emitAnnotation("Override");
                writer.beginMethod(fieldTypeCanonicalName, getters.get(fieldName), EnumSet.of(Modifier.PUBLIC));
                writer.emitStatement(
                        "realm.checkIfValid()"
                );
                writer.emitStatement(
                        "return (%s) row.get%s(Realm.columnIndices.get(\"%s\").get(\"%s\"))",
                        fieldTypeCanonicalName, realmType, className, fieldName);
                writer.endMethod();
                writer.emitEmptyLine();

                // Setter
                writer.emitAnnotation("Override");
                writer.beginMethod("void", setters.get(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
                writer.emitStatement(
                        "realm.checkIfValid()"
                );
                writer.emitStatement(
                        "row.set%s(Realm.columnIndices.get(\"%s\").get(\"%s\"), (%s) value)",
                        realmType, className, fieldName, castingType);
                writer.endMethod();
            } else if (typeUtils.isAssignable(field.asType(), realmObject)) {
                /**
                 * Links
                 */

                // Getter
                writer.emitAnnotation("Override");
                writer.beginMethod(fieldTypeCanonicalName, getters.get(fieldName), EnumSet.of(Modifier.PUBLIC));
                writer.beginControlFlow("if (row.isNullLink(Realm.columnIndices.get(\"%s\").get(\"%s\")))", className, fieldName);
                writer.emitStatement("return null");
                writer.endControlFlow();
                writer.emitStatement(
                        "return realm.get(%s.class, row.getLink(Realm.columnIndices.get(\"%s\").get(\"%s\")))",
                        fieldTypeCanonicalName, className, fieldName);
                writer.endMethod();
                writer.emitEmptyLine();

                // Setter
                writer.emitAnnotation("Override");
                writer.beginMethod("void", setters.get(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
                writer.beginControlFlow("if (value == null)");
                writer.emitStatement("row.nullifyLink(Realm.columnIndices.get(\"%s\").get(\"%s\"))", className, fieldName);
                writer.endControlFlow();
                writer.emitStatement("row.setLink(Realm.columnIndices.get(\"%s\").get(\"%s\"), value.row.getIndex())", className, fieldName);
                writer.endMethod();
            } else if (typeUtils.isAssignable(field.asType(), realmList)) {
                /**
                 * LinkLists
                 */
                String genericCanonicalType = ((DeclaredType) field.asType()).getTypeArguments().get(0).toString();
                String genericType;
                if (genericCanonicalType.contains(".")) {
                    genericType = genericCanonicalType.substring(genericCanonicalType.lastIndexOf('.') + 1);
                } else {
                    genericType = genericCanonicalType;
                }

                // Getter
                writer.emitAnnotation("Override");
                writer.beginMethod(fieldTypeCanonicalName, getters.get(fieldName), EnumSet.of(Modifier.PUBLIC));
                writer.emitStatement(
                        "return new RealmList<%s>(%s.class, row.getLinkList(Realm.columnIndices.get(\"%s\").get(\"%s\")), realm)",
                        genericType, genericType, className, fieldName);
                writer.endMethod();
                writer.emitEmptyLine();

                // Setter
                writer.emitAnnotation("Override");
                writer.beginMethod("void", setters.get(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
                writer.emitStatement("LinkView links = row.getLinkList(Realm.columnIndices.get(\"%s\").get(\"%s\"))", className, fieldName);
                writer.beginControlFlow("if (value == null)");
                writer.emitStatement("return"); // TODO: delete all the links instead
                writer.endControlFlow();
                writer.beginControlFlow("for (RealmObject linkedObject : (RealmList<? extends RealmObject>) value)");
                writer.emitStatement("links.add(linkedObject.row.getIndex())");
                writer.endControlFlow();
                writer.endMethod();
            } else {
                throw new UnsupportedOperationException(
                        String.format("Type %s of field %s is not supported", fieldTypeCanonicalName, fieldName));
            }
            writer.emitEmptyLine();
        }

        /**
         * initTable method
         */
        writer.beginMethod(
                "Table", // Return type
                "initTable", // Method name
                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
                "ImplicitTransaction", "transaction"); // Argument type & argument name

        writer.beginControlFlow("if(!transaction.hasTable(\"" + TABLE_PREFIX + this.className + "\"))");
        writer.emitStatement("Table table = transaction.getTable(\"%s%s\")", TABLE_PREFIX, this.className);

        // For each field generate corresponding table index constant
        for (VariableElement field : fields) {
            String fieldName = field.getSimpleName().toString();
            String fieldTypeCanonicalName = field.asType().toString();
            String fieldTypeName;
            if (fieldTypeCanonicalName.contains(".")) {
                fieldTypeName = fieldTypeCanonicalName.substring(fieldTypeCanonicalName.lastIndexOf('.') + 1);
            } else {
                fieldTypeName = fieldTypeCanonicalName;
            }

            if (JAVA_TO_REALM_TYPES.containsKey(fieldTypeCanonicalName)) {
                writer.emitStatement("table.addColumn(%s, \"%s\")",
                        JAVA_TO_COLUMN_TYPES.get(fieldTypeCanonicalName),
                        fieldName);
            } else if (typeUtils.isAssignable(field.asType(), realmObject)) {
                writer.beginControlFlow("if (!transaction.hasTable(\"%s%s\"))", TABLE_PREFIX, fieldTypeName);
                writer.emitStatement("%s%s.initTable(transaction)", fieldTypeName, PROXY_SUFFIX);
                writer.endControlFlow();
                writer.emitStatement("table.addColumnLink(ColumnType.LINK, \"%s\", transaction.getTable(\"%s%s\"))",
                        fieldName, TABLE_PREFIX, fieldTypeName);
            } else if (typeUtils.isAssignable(field.asType(), realmList)) {
                String genericCanonicalType = ((DeclaredType) field.asType()).getTypeArguments().get(0).toString();
                String genericType;
                if (genericCanonicalType.contains(".")) {
                    genericType = genericCanonicalType.substring(genericCanonicalType.lastIndexOf('.') + 1);
                } else {
                    genericType = genericCanonicalType;
                }
                writer.beginControlFlow("if (!transaction.hasTable(\"%s%s\"))", TABLE_PREFIX, genericType);
                writer.emitStatement("%s%s.initTable(transaction)", genericType, PROXY_SUFFIX);
                writer.endControlFlow();
                writer.emitStatement("table.addColumnLink(ColumnType.LINK_LIST, \"%s\", transaction.getTable(\"%s%s\"))",
                        fieldName, TABLE_PREFIX, genericType);
            }
        }

        for (VariableElement field : fieldsToIndex) {
            String fieldName = field.getSimpleName().toString();
            writer.emitStatement("table.setIndex(table.getColumnIndex(\"%s\"))", fieldName);
        }

        writer.emitStatement("return table");
        writer.endControlFlow();
        writer.emitStatement("return transaction.getTable(\"%s%s\")", TABLE_PREFIX, this.className);
        writer.endMethod();
        writer.emitEmptyLine();

        /**
         * validateTable method
         */
        writer.beginMethod(
                "void", // Return type
                "validateTable", // Method name
                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
                "ImplicitTransaction", "transaction"); // Argument type & argument name

        writer.beginControlFlow("if(transaction.hasTable(\"" + TABLE_PREFIX + this.className + "\"))");
        writer.emitStatement("Table table = transaction.getTable(\"%s%s\")", TABLE_PREFIX, this.className);

        // verify number of columns
        writer.beginControlFlow("if(table.getColumnCount() != " + fields.size() + ")");
        writer.emitStatement("throw new IllegalStateException(\"Column count does not match\")");
        writer.endControlFlow();

        // create type dictionary for lookup
        writer.emitStatement("Map<String, ColumnType> columnTypes = new HashMap<String, ColumnType>()");
        writer.beginControlFlow("for(long i = 0; i < " + fields.size() + "; i++)");
        writer.emitStatement("columnTypes.put(table.getColumnName(i), table.getColumnType(i))");
        writer.endControlFlow();

        // For each field verify there is a corresponding column
        for (VariableElement field : fields) {
            String fieldName = field.getSimpleName().toString();
            String fieldTypeCanonicalName = field.asType().toString();
            String fieldTypeName;
            if (fieldTypeCanonicalName.contains(".")) {
                fieldTypeName = fieldTypeCanonicalName.substring(fieldTypeCanonicalName.lastIndexOf('.') + 1);
            } else {
                fieldTypeName = fieldTypeCanonicalName;
            }

            if (JAVA_TO_REALM_TYPES.containsKey(fieldTypeCanonicalName)) {
                // make sure types align
                writer.beginControlFlow("if (!columnTypes.containsKey(\"%s\"))", fieldName);
                writer.emitStatement("throw new IllegalStateException(\"Missing column '%s'\")", fieldName);
                writer.endControlFlow();
                writer.beginControlFlow("if (columnTypes.get(\"%s\") != %s)", fieldName, JAVA_TO_COLUMN_TYPES.get(fieldTypeCanonicalName));
                writer.emitStatement("throw new IllegalStateException(\"Invalid type '%s' for column '%s'\")",
                        fieldTypeName, fieldName);
                writer.endControlFlow();
            } else if (typeUtils.isAssignable(field.asType(), realmObject)) { // Links
                writer.beginControlFlow("if (!columnTypes.containsKey(\"%s\"))", fieldName);
                writer.emitStatement("throw new IllegalStateException(\"Missing column '%s'\")", fieldName);
                writer.endControlFlow();
                writer.beginControlFlow("if (columnTypes.get(\"%s\") != ColumnType.LINK)", fieldName);
                writer.emitStatement("throw new IllegalStateException(\"Invalid type '%s' for column '%s'\")",
                        fieldTypeName, fieldName);
                writer.endControlFlow();
                writer.beginControlFlow("if (!transaction.hasTable(\"%s%s\"))", TABLE_PREFIX, fieldTypeName);
                writer.emitStatement("throw new IllegalStateException(\"Missing table '%s%s' for column '%s'\")",
                        TABLE_PREFIX, fieldTypeName, fieldName);
                writer.endControlFlow();
                // TODO: Replace with a proper comparison
//                writer.emitStatement("Table table_%d = transaction.getTable(\"%s%s\")", columnNumber, TABLE_PREFIX, fieldTypeName);
//                writer.beginControlFlow("if (table.getLinkTarget(%d).equals(table_%d))", columnNumber, columnNumber);
//                writer.emitStatement("throw new IllegalStateException(\"Mismatching link tables for column '%s'\")",
//                        fieldName);
//                writer.endControlFlow();
            } else if (typeUtils.isAssignable(field.asType(), realmList)) { // Link Lists
                String genericCanonicalType = ((DeclaredType) field.asType()).getTypeArguments().get(0).toString();
                String genericType;
                if (genericCanonicalType.contains(".")) {
                    genericType = genericCanonicalType.substring(genericCanonicalType.lastIndexOf('.') + 1);
                } else {
                    genericType = genericCanonicalType;
                }
                writer.beginControlFlow("if(!columnTypes.containsKey(\"%s\"))", fieldName);
                writer.emitStatement("throw new IllegalStateException(\"Missing column '%s'\")", fieldName);
                writer.endControlFlow();
                writer.beginControlFlow("if(columnTypes.get(\"%s\") != ColumnType.LINK_LIST)", fieldName);
                writer.emitStatement("throw new IllegalStateException(\"Invalid type '%s' for column '%s'\")",
                        genericType, fieldName);
                writer.endControlFlow();
                writer.beginControlFlow("if (!transaction.hasTable(\"%s%s\"))", TABLE_PREFIX, genericType);
                writer.emitStatement("throw new IllegalStateException(\"Missing table '%s%s' for column '%s'\")",
                        TABLE_PREFIX, genericType, fieldName);
                writer.endControlFlow();
                // TODO: Replace with a proper comparison
//                writer.emitStatement("Table table_%d = transaction.getTable(\"%s%s\")", columnNumber, TABLE_PREFIX, genericType);
//                writer.beginControlFlow("if (table.getLinkTarget(%d).equals(table_%d))", columnNumber, columnNumber);
//                writer.emitStatement("throw new IllegalStateException(\"Mismatching link list tables for column '%s'\")",
//                        fieldName);
//                writer.endControlFlow();
            }
        }
        writer.endControlFlow();
        writer.endMethod();
        writer.emitEmptyLine();

        /**
         * getFieldNames method
         */
        writer.beginMethod("List<String>", "getFieldNames", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC));
        List<String> entries = new ArrayList<String>();
        for (VariableElement field : fields) {
            String fieldName = field.getSimpleName().toString();
            entries.add(String.format("\"%s\"", fieldName));
        }
        String statementSection = joinStringList(entries, ", ");
        writer.emitStatement("return Arrays.asList(%s)", statementSection);
        writer.endMethod();
        writer.emitEmptyLine();

        /**
         * toString method
         */
        writer.emitAnnotation("Override");
        writer.beginMethod("String", "toString", EnumSet.of(Modifier.PUBLIC));
        writer.emitStatement("StringBuilder stringBuilder = new StringBuilder(\"%s = [\")", className);
        for (VariableElement field : fields) {
            String fieldName = field.getSimpleName().toString();
            writer.emitStatement("stringBuilder.append(\"{%s:\")", fieldName);
            writer.emitStatement("stringBuilder.append(%s())", getters.get(fieldName));
            writer.emitStatement("stringBuilder.append(\"} \")", fieldName);
        }
        writer.emitStatement("stringBuilder.append(\"]\")");
        writer.emitStatement("return stringBuilder.toString()");
        writer.endMethod();
        writer.emitEmptyLine();

        /**
         * hashCode method
         */
        writer.emitAnnotation("Override");
        writer.beginMethod("int", "hashCode", EnumSet.of(Modifier.PUBLIC));
        writer.emitStatement("int result = 17");
        int counter = 0;
        for (VariableElement field : fields) {
            String fieldName = field.getSimpleName().toString();
            String fieldTypeCanonicalName = field.asType().toString();
            if (HASHCODE.containsKey(fieldTypeCanonicalName)) {
                for (String statement : HASHCODE.get(fieldTypeCanonicalName)) {
                    if (statement.contains("%d") && statement.contains("%s")) {
                        // This statement introduces a temporary variable
                        writer.emitStatement(statement, counter, getters.get(fieldName));
                    } else if(statement.contains("%d")) {
                        // This statement uses the temporary variable
                        writer.emitStatement(statement, counter, counter);
                    } else if (statement.contains("%s")) {
                        // This is a normal statement with only one assignment
                        writer.emitStatement(statement, getters.get(fieldName));
                    } else {
                        // This should never happen
                        throw new AssertionError();
                    }
                }
            } else {
                // Links and Link lists
                writer.emitStatement("%s temp_%d = %s()", fieldTypeCanonicalName, counter, getters.get(fieldName));
                writer.emitStatement("result = 31 * result + (temp_%d != null ? temp_%d.hashCode() : 0)", counter, counter);
            }
            counter++;
        }
        writer.emitStatement("return result");
        writer.endMethod();
        writer.emitEmptyLine();

        /**
         * equals method
         */
        String proxyClassName = className + PROXY_SUFFIX;
        writer.emitAnnotation("Override");
        writer.beginMethod("boolean", "equals", EnumSet.of(Modifier.PUBLIC), "Object", "o");
        writer.emitStatement("if (this == o) return true");
        writer.emitStatement("if (o == null || getClass() != o.getClass()) return false");
        writer.emitStatement("%s a%s = (%s)o", proxyClassName, className, proxyClassName);  // FooRealmProxy aFoo = (FooRealmProxy)o

        for (VariableElement field : fields) {
            String fieldName = field.getSimpleName().toString();
            String capFieldName = capitaliseFirstChar(fieldName);
            String fieldTypeCanonicalName = field.asType().toString();
            if (HOW_TO_EQUAL.containsKey(fieldTypeCanonicalName)) {
                switch (HOW_TO_EQUAL.get(fieldTypeCanonicalName)) {
                    case EQUALS_DIRECT: // if (getField() != aFoo.getField()) return false
                        writer.emitStatement("if (%s() != a%s.%s()) return false", getters.get(fieldName), className, getters.get(fieldName));
                        break;
                    case EQUALS_NULL: // if (getField() != null = !getField().equals(aFoo.getField()) : aFoo.getField() != null) return false
                        writer.emitStatement("if (%s() != null ? !%s().equals(a%s.%s()) : a%s.%s() != null) return false",
                                getters.get(fieldName),
                                getters.get(fieldName), className, getters.get(fieldName),
                                className, getters.get(fieldName));
                        break;
                    case EQUALS_ARRAY: // if (!Arrays.equals(getField(), aFoo.getField())) return false
                        writer.emitStatement("if (!Arrays.equals(%s(), a%s.%s())) return false",
                                getters.get(fieldName),
                                className, getters.get(fieldName));
                        break;
                    case EQUALS_COMPARE: // if (
                        writer.emitStatement("if (%s.compare(%s(), a%s.%s()) != 0) return false",
                                capitaliseFirstChar(fieldTypeCanonicalName), getters.get(fieldName), className,
                                getters.get(fieldName));
                        break;
                }
            }
            else if (typeUtils.isAssignable(field.asType(), realmObject) || typeUtils.isAssignable(field.asType(), realmList)) {
                writer.emitStatement("if (%s() != null ? !%s().equals(a%s.%s()) : a%s.%s() != null) return false",
                        getters.get(fieldName),
                        getters.get(fieldName), className, getters.get(fieldName),
                        className, getters.get(fieldName));
            }
        }
        writer.emitStatement("return true");
        writer.endMethod();
        writer.emitEmptyLine();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b10436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a10436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c10436
<<<<<<< MINE
// get the table name as it is in the associated publicKeyGroup.
=======
/**
     * Return the table name as it is in the associated group.
     *
     * @return Name of the the table or null if it not part of a group.
     */
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b10436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a10436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c10436
<<<<<<< MINE
        emitToStringMethod(writer);
        emitHashCodeMethod(writer);
=======
        emitPopulateUsingJsonObjectMethod(writer);
        emitPopulateUsingJsonStreamMethod(writer);
        emitCopyToRealmMethod(writer);
        emitToStringMethod(writer);
        emitHashcodeMethod(writer);
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b10436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a10436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c10436
<<<<<<< MINE
        for (VariableElement field : fields) {
            String fieldName = field.getSimpleName().toString();
            String fieldTypeCanonicalName = field.asType().toString();

            if (JAVA_TO_REALM_TYPES.containsKey(fieldTypeCanonicalName)) {
                /**
                 * Primitives and boxed types
                 */
                String realmType = JAVA_TO_REALM_TYPES.get(fieldTypeCanonicalName);
                String castingType = CASTING_TYPES.get(fieldTypeCanonicalName);

                // Getter
                writer.emitAnnotation("Override");
                writer.beginMethod(fieldTypeCanonicalName, getters.get(fieldName), EnumSet.of(Modifier.PUBLIC));
                writer.emitStatement(
                        "realm.assertThread()"
                );
                writer.emitStatement(
                        "return (%s) row.get%s(Realm.columnIndices.get(\"%s\").get(\"%s\"))",
                        fieldTypeCanonicalName, realmType, className, fieldName);
                writer.endMethod();
                writer.emitEmptyLine();

                // Setter
                writer.emitAnnotation("Override");
                writer.beginMethod("void", setters.get(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
                writer.emitStatement(
                        "realm.assertThread()"
                );
                writer.emitStatement(
                        "row.set%s(Realm.columnIndices.get(\"%s\").get(\"%s\"), (%s) value)",
                        realmType, className, fieldName, castingType);
                writer.endMethod();
            } else if (typeUtils.isAssignable(field.asType(), realmObject)) {
                /**
                 * Links
                 */

                // Getter
                writer.emitAnnotation("Override");
                writer.beginMethod(fieldTypeCanonicalName, getters.get(fieldName), EnumSet.of(Modifier.PUBLIC));
                writer.beginControlFlow("if (row.isNullLink(Realm.columnIndices.get(\"%s\").get(\"%s\")))", className, fieldName);
                writer.emitStatement("return null");
                writer.endControlFlow();
                writer.emitStatement(
                        "return realm.get(%s.class, row.getLink(Realm.columnIndices.get(\"%s\").get(\"%s\")))",
                        fieldTypeCanonicalName, className, fieldName);
                writer.endMethod();
                writer.emitEmptyLine();

                // Setter
                writer.emitAnnotation("Override");
                writer.beginMethod("void", setters.get(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
                writer.beginControlFlow("if (value == null)");
                writer.emitStatement("row.nullifyLink(Realm.columnIndices.get(\"%s\").get(\"%s\"))", className, fieldName);
                writer.endControlFlow();
                writer.emitStatement("row.setLink(Realm.columnIndices.get(\"%s\").get(\"%s\"), value.row.getIndex())", className, fieldName);
                writer.endMethod();
            } else if (typeUtils.isAssignable(field.asType(), realmList)) {
                /**
                 * LinkLists
                 */
                String genericCanonicalType = ((DeclaredType) field.asType()).getTypeArguments().get(0).toString();
                String genericType;
                if (genericCanonicalType.contains(".")) {
                    genericType = genericCanonicalType.substring(genericCanonicalType.lastIndexOf('.') + 1);
                } else {
                    genericType = genericCanonicalType;
                }
=======
        // Accessors
        for (VariableElement field : fields) {
            String fieldName = field.getSimpleName().toString();
            String fieldTypeCanonicalName = field.asType().toString();

            if (JAVA_TO_REALM_TYPES.containsKey(fieldTypeCanonicalName)) {
                /**
                 * Primitives and boxed types
                 */
                String realmType = JAVA_TO_REALM_TYPES.get(fieldTypeCanonicalName);
                String castingType = CASTING_TYPES.get(fieldTypeCanonicalName);

                // Getter
                writer.emitAnnotation("Override");
                writer.beginMethod(fieldTypeCanonicalName, getters.get(fieldName), EnumSet.of(Modifier.PUBLIC));
                writer.emitStatement(
                        "realm.checkIfValid()"
                );
                writer.emitStatement(
                        "return (%s) row.get%s(Realm.columnIndices.get(\"%s\").get(\"%s\"))",
                        fieldTypeCanonicalName, realmType, className, fieldName);
                writer.endMethod();
                writer.emitEmptyLine();

                // Setter
                writer.emitAnnotation("Override");
                writer.beginMethod("void", setters.get(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
                writer.emitStatement(
                        "realm.checkIfValid()"
                );
                writer.emitStatement(
                        "row.set%s(Realm.columnIndices.get(\"%s\").get(\"%s\"), (%s) value)",
                        realmType, className, fieldName, castingType);
                writer.endMethod();
            } else if (typeUtils.isAssignable(field.asType(), realmObject)) {
                /**
                 * Links
                 */

                // Getter
                writer.emitAnnotation("Override");
                writer.beginMethod(fieldTypeCanonicalName, getters.get(fieldName), EnumSet.of(Modifier.PUBLIC));
                writer.beginControlFlow("if (row.isNullLink(Realm.columnIndices.get(\"%s\").get(\"%s\")))", className, fieldName);
                writer.emitStatement("return null");
                writer.endControlFlow();
                writer.emitStatement(
                        "return realm.get(%s.class, row.getLink(Realm.columnIndices.get(\"%s\").get(\"%s\")))",
                        fieldTypeCanonicalName, className, fieldName);
                writer.endMethod();
                writer.emitEmptyLine();

                // Setter
                writer.emitAnnotation("Override");
                writer.beginMethod("void", setters.get(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
                writer.beginControlFlow("if (value == null)");
                writer.emitStatement("row.nullifyLink(Realm.columnIndices.get(\"%s\").get(\"%s\"))", className, fieldName);
                writer.emitStatement("return");
                writer.endControlFlow();
                writer.emitStatement("row.setLink(Realm.columnIndices.get(\"%s\").get(\"%s\"), value.row.getIndex())", className, fieldName);
                writer.endMethod();
            } else if (typeUtils.isAssignable(field.asType(), realmList)) {
                /**
                 * LinkLists
                 */
                String genericType = getGenericType(field);
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b10436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a10436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c10436
<<<<<<< MINE
            String fieldTypeName;
            if (fieldTypeCanonicalName.contains(".")) {
                fieldTypeName = fieldTypeCanonicalName.substring(fieldTypeCanonicalName.lastIndexOf('.') + 1);
            } else {
                fieldTypeName = fieldTypeCanonicalName;
            }

            if (JAVA_TO_REALM_TYPES.containsKey(fieldTypeCanonicalName)) {
                writer.emitStatement("table.addColumn(%s, \"%s\")",
                        JAVA_TO_COLUMN_TYPES.get(fieldTypeCanonicalName),
                        fieldName);
            } else if (typeUtils.isAssignable(field.asType(), realmObject)) {
                writer.beginControlFlow("if (!transaction.hasTable(\"%s%s\"))", TABLE_PREFIX, fieldTypeName);
                writer.emitStatement("%s%s.initTable(transaction)", fieldTypeName, PROXY_SUFFIX);
                writer.endControlFlow();
                writer.emitStatement("table.addColumnLink(ColumnType.LINK, \"%s\", transaction.getTable(\"%s%s\"))",
                        fieldName, TABLE_PREFIX, fieldTypeName);
            } else if (typeUtils.isAssignable(field.asType(), realmList)) {
                String genericCanonicalType = ((DeclaredType) field.asType()).getTypeArguments().get(0).toString();
                String genericType;
                if (genericCanonicalType.contains(".")) {
                    genericType = genericCanonicalType.substring(genericCanonicalType.lastIndexOf('.') + 1);
                } else {
                    genericType = genericCanonicalType;
                }
                writer.beginControlFlow("if (!transaction.hasTable(\"%s%s\"))", TABLE_PREFIX, genericType);
                writer.emitStatement("%s%s.initTable(transaction)", genericType, PROXY_SUFFIX);
                writer.endControlFlow();
                writer.emitStatement("table.addColumnLink(ColumnType.LINK_LIST, \"%s\", transaction.getTable(\"%s%s\"))",
                        fieldName, TABLE_PREFIX, genericType);
            }
        }

        for (VariableElement field : fieldsToIndex) {
            String fieldName = field.getSimpleName().toString();
            writer.emitStatement("table.setIndex(table.getColumnIndex(\"%s\"))", fieldName);
        }

        if (primaryKey != null) {
            String fieldName = primaryKey.getSimpleName().toString();
            writer.emitStatement("table.setPrimaryKey(\"%s\")", fieldName);
        } else {
            writer.emitStatement("table.setPrimaryKey(\"\")");
=======
            String fieldTypeSimpleName = getFieldTypeSimpleName(field);

            if (JAVA_TO_REALM_TYPES.containsKey(fieldTypeCanonicalName)) {
                writer.emitStatement("table.addColumn(%s, \"%s\")",
                        JAVA_TO_COLUMN_TYPES.get(fieldTypeCanonicalName),
                        fieldName);
            } else if (typeUtils.isAssignable(field.asType(), realmObject)) {
                writer.beginControlFlow("if (!transaction.hasTable(\"%s%s\"))", TABLE_PREFIX, fieldTypeSimpleName);
                writer.emitStatement("%s%s.initTable(transaction)", fieldTypeSimpleName, PROXY_SUFFIX);
                writer.endControlFlow();
                writer.emitStatement("table.addColumnLink(ColumnType.LINK, \"%s\", transaction.getTable(\"%s%s\"))",
                        fieldName, TABLE_PREFIX, fieldTypeSimpleName);
            } else if (typeUtils.isAssignable(field.asType(), realmList)) {
                String genericType = getGenericType(field);
                writer.beginControlFlow("if (!transaction.hasTable(\"%s%s\"))", TABLE_PREFIX, genericType);
                writer.emitStatement("%s%s.initTable(transaction)", genericType, PROXY_SUFFIX);
                writer.endControlFlow();
                writer.emitStatement("table.addColumnLink(ColumnType.LINK_LIST, \"%s\", transaction.getTable(\"%s%s\"))",
                        fieldName, TABLE_PREFIX, genericType);
            }
        }

        for (VariableElement field : fieldsToIndex) {
            String fieldName = field.getSimpleName().toString();
            writer.emitStatement("table.setIndex(table.getColumnIndex(\"%s\"))", fieldName);
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b10436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a10436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c10436
<<<<<<< MINE
            String fieldTypeName;
            if (fieldTypeCanonicalName.contains(".")) {
                fieldTypeName = fieldTypeCanonicalName.substring(fieldTypeCanonicalName.lastIndexOf('.') + 1);
            } else {
                fieldTypeName = fieldTypeCanonicalName;
            }

            if (JAVA_TO_REALM_TYPES.containsKey(fieldTypeCanonicalName)) {
                // make sure types align
                writer.beginControlFlow("if (!columnTypes.containsKey(\"%s\"))", fieldName);
                writer.emitStatement("throw new IllegalStateException(\"Missing column '%s'\")", fieldName);
                writer.endControlFlow();
                writer.beginControlFlow("if (columnTypes.get(\"%s\") != %s)", fieldName, JAVA_TO_COLUMN_TYPES.get(fieldTypeCanonicalName));
                writer.emitStatement("throw new IllegalStateException(\"Invalid type '%s' for column '%s'\")",
                        fieldTypeName, fieldName);
                writer.endControlFlow();
            } else if (typeUtils.isAssignable(field.asType(), realmObject)) { // Links
                writer.beginControlFlow("if (!columnTypes.containsKey(\"%s\"))", fieldName);
                writer.emitStatement("throw new IllegalStateException(\"Missing column '%s'\")", fieldName);
                writer.endControlFlow();
                writer.beginControlFlow("if (columnTypes.get(\"%s\") != ColumnType.LINK)", fieldName);
                writer.emitStatement("throw new IllegalStateException(\"Invalid type '%s' for column '%s'\")",
                        fieldTypeName, fieldName);
                writer.endControlFlow();
                writer.beginControlFlow("if (!transaction.hasTable(\"%s%s\"))", TABLE_PREFIX, fieldTypeName);
                writer.emitStatement("throw new IllegalStateException(\"Missing table '%s%s' for column '%s'\")",
                        TABLE_PREFIX, fieldTypeName, fieldName);
                writer.endControlFlow();
                // TODO: Replace with a proper comparison
//                writer.emitStatement("Table table_%d = transaction.getTable(\"%s%s\")", columnNumber, TABLE_PREFIX, fieldTypeName);
//                writer.beginControlFlow("if (table.getLinkTarget(%d).equals(table_%d))", columnNumber, columnNumber);
//                writer.emitStatement("throw new IllegalStateException(\"Mismatching link tables for column '%s'\")",
//                        fieldName);
//                writer.endControlFlow();
            } else if (typeUtils.isAssignable(field.asType(), realmList)) { // Link Lists
                String genericCanonicalType = ((DeclaredType) field.asType()).getTypeArguments().get(0).toString();
                String genericType;
                if (genericCanonicalType.contains(".")) {
                    genericType = genericCanonicalType.substring(genericCanonicalType.lastIndexOf('.') + 1);
                } else {
                    genericType = genericCanonicalType;
                }
=======
            String fieldTypeSimpleName = getFieldTypeSimpleName(field);

            if (JAVA_TO_REALM_TYPES.containsKey(fieldTypeCanonicalName)) {
                // make sure types align
                writer.beginControlFlow("if (!columnTypes.containsKey(\"%s\"))", fieldName);
                writer.emitStatement("throw new IllegalStateException(\"Missing column '%s'\")", fieldName);
                writer.endControlFlow();
                writer.beginControlFlow("if (columnTypes.get(\"%s\") != %s)", fieldName, JAVA_TO_COLUMN_TYPES.get(fieldTypeCanonicalName));
                writer.emitStatement("throw new IllegalStateException(\"Invalid type '%s' for column '%s'\")",
                        fieldTypeSimpleName, fieldName);
                writer.endControlFlow();
            } else if (typeUtils.isAssignable(field.asType(), realmObject)) { // Links
                writer.beginControlFlow("if (!columnTypes.containsKey(\"%s\"))", fieldName);
                writer.emitStatement("throw new IllegalStateException(\"Missing column '%s'\")", fieldName);
                writer.endControlFlow();
                writer.beginControlFlow("if (columnTypes.get(\"%s\") != ColumnType.LINK)", fieldName);
                writer.emitStatement("throw new IllegalStateException(\"Invalid type '%s' for column '%s'\")",
                        fieldTypeSimpleName, fieldName);
                writer.endControlFlow();
                writer.beginControlFlow("if (!transaction.hasTable(\"%s%s\"))", TABLE_PREFIX, fieldTypeSimpleName);
                writer.emitStatement("throw new IllegalStateException(\"Missing table '%s%s' for column '%s'\")",
                        TABLE_PREFIX, fieldTypeSimpleName, fieldName);
                writer.endControlFlow();
                // TODO: Replace with a proper comparison
//                writer.emitStatement("Table table_%d = transaction.getTable(\"%s%s\")", columnNumber, TABLE_PREFIX, fieldTypeName);
//                writer.beginControlFlow("if (table.getLinkTarget(%d).equals(table_%d))", columnNumber, columnNumber);
//                writer.emitStatement("throw new IllegalStateException(\"Mismatching link tables for column '%s'\")",
//                        fieldName);
//                writer.endControlFlow();
            } else if (typeUtils.isAssignable(field.asType(), realmList)) { // Link Lists
                String genericType = getGenericType(field);
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b10436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a10436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c10436
<<<<<<< MINE
        writer.emitStatement("StringBuilder stringBuilder = new StringBuilder(\"%s = [\")", className);
        for (VariableElement field : fields) {
            String fieldName = field.getSimpleName().toString();
            writer.emitStatement("stringBuilder.append(\"{%s:\")", fieldName);
            writer.emitStatement("stringBuilder.append(%s())", getters.get(fieldName));
            writer.emitStatement("stringBuilder.append(\"} \")", fieldName);
        }
=======
        writer.beginControlFlow("if (!isValid())");
        writer.emitStatement("return \"Invalid object\"");
        writer.endControlFlow();
        writer.emitStatement("StringBuilder stringBuilder = new StringBuilder(\"%s = [\")", className);
        for (int i = 0; i < fields.size(); i++) {
            VariableElement field = fields.get(i);
            String fieldName = field.getSimpleName().toString();

            writer.emitStatement("stringBuilder.append(\"{%s:\")", fieldName);
            if (typeUtils.isAssignable(field.asType(), realmObject)) {
                String fieldTypeSimpleName = getFieldTypeSimpleName(field);
                writer.emitStatement(
                        "stringBuilder.append(%s() != null ? \"%s\" : \"null\")",
                        getters.get(fieldName),
                        fieldTypeSimpleName
                );
            } else if (typeUtils.isAssignable(field.asType(), realmList)) {
                String genericType = getGenericType(field);
                writer.emitStatement("stringBuilder.append(\"RealmList<%s>[\").append(%s().size()).append(\"]\")",
                        genericType,
                        getters.get(fieldName));
            } else {
                writer.emitStatement("stringBuilder.append(%s())", getters.get(fieldName));
            }
            writer.emitStatement("stringBuilder.append(\"}\")");

            if (i < fields.size() - 1) {
                writer.emitStatement("stringBuilder.append(\",\")");
            }
        }

>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b10436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a10436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c10436
<<<<<<< MINE

        for (VariableElement field : fields) {
            String fieldName = field.getSimpleName().toString();
            String capFieldName = capitaliseFirstChar(fieldName);
            String fieldTypeCanonicalName = field.asType().toString();
            if (HOW_TO_EQUAL.containsKey(fieldTypeCanonicalName)) {
                switch (HOW_TO_EQUAL.get(fieldTypeCanonicalName)) {
                    case EQUALS_DIRECT: // if (getField() != aFoo.getField()) return false
                        writer.emitStatement("if (%s() != a%s.%s()) return false", getters.get(fieldName), className, getters.get(fieldName));
                        break;
                    case EQUALS_NULL: // if (getField() != null = !getField().equals(aFoo.getField()) : aFoo.getField() != null) return false
                        writer.emitStatement("if (%s() != null ? !%s().equals(a%s.%s()) : a%s.%s() != null) return false",
                                getters.get(fieldName),
                                getters.get(fieldName), className, getters.get(fieldName),
                                className, getters.get(fieldName));
                        break;
                    case EQUALS_ARRAY: // if (!Arrays.equals(getField(), aFoo.getField())) return false
                        writer.emitStatement("if (!Arrays.equals(%s(), a%s.%s())) return false",
                                getters.get(fieldName),
                                className, getters.get(fieldName));
                        break;
                    case EQUALS_COMPARE: // if (
                        writer.emitStatement("if (%s.compare(%s(), a%s.%s()) != 0) return false",
                                capitaliseFirstChar(fieldTypeCanonicalName), getters.get(fieldName), className,
                                getters.get(fieldName));
                        break;
                }
            }
            else if (typeUtils.isAssignable(field.asType(), realmObject) || typeUtils.isAssignable(field.asType(), realmList)) {
                writer.emitStatement("if (%s() != null ? !%s().equals(a%s.%s()) : a%s.%s() != null) return false",
                        getters.get(fieldName),
                        getters.get(fieldName), className, getters.get(fieldName),
                        className, getters.get(fieldName));
            }
        }
=======
        writer.emitEmptyLine();
        writer.emitStatement("String path = realm.getPath()");
        writer.emitStatement("String otherPath = a%s.realm.getPath()", className);
        writer.emitStatement("if (path != null ? !path.equals(otherPath) : otherPath != null) return false;");
        writer.emitEmptyLine();
        writer.emitStatement("String tableName = row.getTable().getName()");
        writer.emitStatement("String otherTableName = a%s.row.getTable().getName()", className);
        writer.emitStatement("if (tableName != null ? !tableName.equals(otherTableName) : otherTableName != null) return false");
        writer.emitEmptyLine();
        writer.emitStatement("if (row.getIndex() != a%s.row.getIndex()) return false", className);
        writer.emitEmptyLine();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b21236;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a21236;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c21236
<<<<<<< MINE
/**
     * Get all objects of a specific Class sorted by a field.
     *
     * @param clazz the Class to get objects of.
     * @param fieldName the field name to sort by.
     * @param sortAscending sort ascending if SORT_ORDER_ASCENDING, sort descending if SORT_ORDER_DESCENDING.
     * @return A sorted RealmResults containing the objects.
     * @throws java.lang.IllegalArgumentException if field name does not exist.
     */
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b21236;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a21236;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c21236
<<<<<<< MINE
@Deprecated
    public <E extends RealmObject> RealmResults<E> allObjects(Class<E> clazz, String fieldName, boolean sortAscending) {
        checkIfValid();
        Table table = getTable(clazz);
        TableView.Order order = sortAscending ? TableView.Order.ascending : TableView.Order.descending;
        Long columnIndex = columnIndices.get(simpleClassNames.get(clazz)).get(fieldName);
        if (columnIndex == null || columnIndex < 0) {
            throw new IllegalArgumentException(String.format("Field name '%s' does not exist.", fieldName));
        }

        TableView tableView = table.getSortedView(columnIndex, order);
        return new RealmResults<E>(this, tableView, clazz);
    }
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b16360;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a16360;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c16360
<<<<<<< MINE
=======
/**
     * Get all objects of a specific Class sorted by multiple fields.
     *
     * @param clazz the Class to get objects of.
     * @param sortAscending sort ascending if SORT_ORDER_ASCENDING, sort descending if SORT_ORDER_DESCENDING.
     * @param fieldNames an array of fieldnames to sort objects by.
     *        The objects are first sorted by fieldNames[0], then by fieldNames[1] and so forth.  
     * @return A sorted RealmResults containing the objects.
     * @throws java.lang.IllegalArgumentException if a field name does not exist.
     */
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b16360;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a16360;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c16360
<<<<<<< MINE
=======
@Deprecated
    public <E extends RealmObject> RealmResults<E> allObjects(Class<E> clazz, String fieldNames[], boolean sortAscending[]) {
        return allObjectsSorted(clazz, fieldNames, sortAscending);
    }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b05624;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a05624;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c05624
<<<<<<< MINE
/**
     * Get all objects of a specific Class sorted by a field.  If no objects exist, the returned
     * RealmResults will not be null. The RealmResults.size() to check the number of objects instead.
     *
     * @param clazz the Class to get objects of.
     * @param fieldName the field name to sort by.
     * @param sortAscending sort ascending if SORT_ORDER_ASCENDING, sort descending if SORT_ORDER_DESCENDING.
     * @return A sorted RealmResults containing the objects.
     * @throws java.lang.IllegalArgumentException if field name does not exist.
     */
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b05624;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a05624;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c05624
<<<<<<< MINE
/**
     * Get all objects of a specific class sorted by two field names.  If no objects exist, the
     * returned RealmResults will not be null. The RealmResults.size() to check the number of
     * objects instead.
     *
     * @param clazz the class ti get objects of.
     * @param fieldName1 first field name to sort by.
     * @param sortAscending1 sort order for first field.
     * @param fieldName2 second field name to sort by.
     * @param sortAscending2 sort order for second field.
     * @return A sorted RealmResults containing the objects.
     * @throws java.lang.IllegalArgumentException if a field name does not exist.
     */
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b05624;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a05624;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c05624
<<<<<<< MINE
/**
     * Get all objects of a specific class sorted by two specific field names.  If no objects exist,
     * the returned RealmResults will not be null. The RealmResults.size() to check the number of
     * objects instead.
     *
     * @param clazz the class ti get objects of.
     * @param fieldName1 first field name to sort by.
     * @param sortAscending1 sort order for first field.
     * @param fieldName2 second field name to sort by.
     * @param sortAscending2 sort order for second field.
     * @param fieldName3 third field name to sort by.
     * @param sortAscending3 sort order for third field.
     * @return A sorted RealmResults containing the objects.
     * @throws java.lang.IllegalArgumentException if a field name does not exist.
     */
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b05624;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a05624;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c05624
<<<<<<< MINE
/**
     * Get all objects of a specific Class sorted by a field.  If no objects exist, the returned
     * RealmResults will not be null. The RealmResults.size() to check the number of objects instead.
     *
     * @param clazz the Class to get objects of.
     * @param fieldName the field name to sort by.
     * @param sortAscending sort ascending if SORT_ORDER_ASCENDING, sort descending if SORT_ORDER_DESCENDING.
     * @return A sorted RealmResults containing the objects.
     * @throws java.lang.IllegalArgumentException if field name does not exist.
     */
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b05624;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a05624;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c05624
<<<<<<< MINE
@Deprecated
    public <E extends RealmObject> RealmResults<E> allObjects(Class<E> clazz, String fieldName, boolean sortAscending) {
        checkIfValid();
        Table table = getTable(clazz);
        TableView.Order order = sortAscending ? TableView.Order.ascending : TableView.Order.descending;
        Long columnIndex = columnIndices.get(simpleClassNames.get(clazz)).get(fieldName);
        if (columnIndex == null || columnIndex < 0) {
            throw new IllegalArgumentException(String.format("Field name '%s' does not exist.", fieldName));
        }

        TableView tableView = table.getSortedView(columnIndex, order);
        return new RealmResults<E>(this, tableView, clazz);
    }
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b05624;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a05624;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c05624
<<<<<<< MINE
     * Get all objects of a specific Class sorted by a field.  If no objects exist, the returned
     * RealmResults will not be null. The RealmResults.size() to check the number of objects instead.
=======
     * Get all objects of a specific Class sorted by multiple fields.
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b12172;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a12172;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c12172
<<<<<<< MINE
/**
     * Get all objects of a specific Class sorted by a field.
     *
     * @param clazz the Class to get objects of.
     * @param fieldName the field name to sort by.
     * @param sortAscending sort ascending if SORT_ORDER_ASCENDING, sort descending if SORT_ORDER_DESCENDING.
     * @return A sorted RealmResults containing the objects.
     * @throws java.lang.IllegalArgumentException if field name does not exist.
     */
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b12172;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a12172;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c12172
<<<<<<< MINE
@Deprecated
    public <E extends RealmObject> RealmResults<E> allObjects(Class<E> clazz, String fieldName, boolean sortAscending) {
        checkIfValid();
        Table table = getTable(clazz);
        TableView.Order order = sortAscending ? TableView.Order.ascending : TableView.Order.descending;
        Long columnIndex = columnIndices.get(simpleClassNames.get(clazz)).get(fieldName);
        if (columnIndex == null || columnIndex < 0) {
            throw new IllegalArgumentException(String.format("Field name '%s' does not exist.", fieldName));
        }

        TableView tableView = table.getSortedView(columnIndex, order);
        return new RealmResults<E>(this, tableView, clazz);
    }
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b20736;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a20736;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c20736
<<<<<<< MINE
/**
     * Get all objects of a specific Class sorted by a field.
     *
     * @param clazz the Class to get objects of.
     * @param fieldName the field name to sort by.
     * @param sortAscending sort ascending if SORT_ORDER_ASCENDING, sort descending if SORT_ORDER_DESCENDING.
     * @return A sorted RealmResults containing the objects.
     * @throws java.lang.IllegalArgumentException if field name does not exist.
     */
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b20736;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a20736;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c20736
<<<<<<< MINE
@Deprecated
    public <E extends RealmObject> RealmResults<E> allObjects(Class<E> clazz, String fieldName, boolean sortAscending) {
        checkIfValid();
        Table table = getTable(clazz);
        TableView.Order order = sortAscending ? TableView.Order.ascending : TableView.Order.descending;
        Long columnIndex = columnIndices.get(simpleClassNames.get(clazz)).get(fieldName);
        if (columnIndex == null || columnIndex < 0) {
            throw new IllegalArgumentException(String.format("Field name '%s' does not exist.", fieldName));
        }

        TableView tableView = table.getSortedView(columnIndex, order);
        return new RealmResults<E>(this, tableView, clazz);
    }
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b19496;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a19496;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c19496
<<<<<<< MINE
                        .emitStatement("%s cache%s = (%s) cache.get(%s)", Utils.getFieldTypeSimpleName(field), fieldName, Utils.getFieldTypeSimpleName(field), fieldName)
                        .beginControlFlow("if (cache%s != null)", fieldName)
                            .emitStatement("realmObject.%s(cache%s)", setters.get(fieldName), fieldName)
                        .nextControlFlow("else")
                            .emitStatement("realmObject.%s(%s.copyOrUpdate(realm, %s, realm.getTable(%s.class).hasPrimaryKey(), cache))",
=======
                        .emitStatement("realmObject.%s(%s.copyOrUpdate(realm, %s, true))",
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b07120;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a07120;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c07120
<<<<<<< MINE
public <E extends RealmObject> RealmResults<E> allObjectsSorted(Class<E> clazz, String fieldName,
                                                               boolean sortAscending) {
        checkIfValid();
        Table table = getTable(clazz);
        TableView.Order order = sortAscending ? TableView.Order.ascending : TableView.Order.descending;
        Long columnIndex = columnIndices.get(getClassSimpleName(clazz)).get(fieldName);
        if (columnIndex == null || columnIndex < 0) {
            throw new IllegalArgumentException(String.format("Field name '%s' does not exist.", fieldName));
=======
@SuppressWarnings("unchecked")
    public <E extends RealmObject> RealmResults<E> allObjectsSorted(Class<E> clazz, String fieldNames[],
                                                               boolean sortAscending[]) {
        if (fieldNames == null) {
            throw new IllegalArgumentException("fieldNames must be provided.");
        } else if (sortAscending == null) {
            throw new IllegalArgumentException("sortAscending must be provided.");
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b16152;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a16152;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c16152
<<<<<<< MINE
// Realms are thread singletons. This maps between a RealmId and its open instance on this thread.
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b16152;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a16152;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c16152
<<<<<<< MINE
// Map between RealmId and how many open instances are on this thread.
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b14052;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a14052;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c14052
<<<<<<< MINE
public <E extends RealmObject> RealmResults<E> allObjectsSorted(Class<E> clazz, String fieldName,
                                                               boolean sortAscending) {
        checkIfValid();
        Table table = getTable(clazz);
        TableView.Order order = sortAscending ? TableView.Order.ascending : TableView.Order.descending;
        long columnIndex = columnIndices.getColumnIndex(clazz, fieldName);
        if (columnIndex < 0) {
            throw new IllegalArgumentException(String.format("Field name '%s' does not exist.", fieldName));
=======
@SuppressWarnings("unchecked")
    public <E extends RealmObject> RealmResults<E> allObjectsSorted(Class<E> clazz, String fieldNames[],
                                                               boolean sortAscending[]) {
        if (fieldNames == null) {
            throw new IllegalArgumentException("fieldNames must be provided.");
        } else if (sortAscending == null) {
            throw new IllegalArgumentException("sortAscending must be provided.");
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b12564;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a12564;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c12564
<<<<<<< MINE
=======
public Table getTable(Class<?> clazz) {
        final String proxySuffix = "RealmProxy";
        String proxiedClassName = proxiedClassNames.get(clazz);
        if (proxiedClassName == null) {
            String classSimpleName = clazz.getSimpleName();
            proxiedClassName = classSimpleName.replace(proxySuffix, "");
            proxiedClassNames.put(clazz, proxiedClassName);
        }
        return transaction.getTable(TABLE_PREFIX + proxiedClassName);
    }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b12564;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a12564;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c12564
<<<<<<< MINE
=======
private Class<?> getProxyClass(Class<?> clazz) {

        String simpleClassName = getClassSimpleName(clazz);
        String generatedClassName = getProxyClassName(simpleClassName);

        Class<?> generatedClass = generatedClasses.get(generatedClassName);
        if (generatedClass == null) {
            try {
                generatedClass = Class.forName(generatedClassName);
            } catch (ClassNotFoundException e) {
                throw new RealmException("Could not find the generated proxy class: " + APT_NOT_EXECUTED_MESSAGE);
            }
            generatedClasses.put(generatedClassName, generatedClass);
        }

        return generatedClass;
    }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b12564;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a12564;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c12564
<<<<<<< MINE
=======
boolean contains(Class<?> clazz) {
        return transaction.hasTable(TABLE_PREFIX + getClassSimpleName(clazz));
    }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b12564;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a12564;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c12564
<<<<<<< MINE
public <E extends RealmObject> RealmResults<E> allObjectsSorted(Class<E> clazz, String fieldName,
                                                               boolean sortAscending) {
        checkIfValid();
        Table table = getTable(clazz);
        TableView.Order order = sortAscending ? TableView.Order.ascending : TableView.Order.descending;
        Long columnIndex = columnIndices.get(clazz.getSimpleName()).get(fieldName);
        if (columnIndex == null || columnIndex < 0) {
            throw new IllegalArgumentException(String.format("Field name '%s' does not exist.", fieldName));
=======
@SuppressWarnings("unchecked")
    public <E extends RealmObject> RealmResults<E> allObjectsSorted(Class<E> clazz, String fieldNames[],
                                                               boolean sortAscending[]) {
        if (fieldNames == null) {
            throw new IllegalArgumentException("fieldNames must be provided.");
        } else if (sortAscending == null) {
            throw new IllegalArgumentException("sortAscending must be provided.");
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b19624;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a19624;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c19624
<<<<<<< MINE
public <E extends RealmObject> RealmResults<E> allObjectsSorted(Class<E> clazz, String fieldName,
                                                               boolean sortAscending) {
        checkIfValid();
        Table table = getTable(clazz);
        TableView.Order order = sortAscending ? TableView.Order.ascending : TableView.Order.descending;
        Long columnIndex = columnIndices.get(clazz.getSimpleName()).get(fieldName);
        if (columnIndex == null || columnIndex < 0) {
            throw new IllegalArgumentException(String.format("Field name '%s' does not exist.", fieldName));
=======
@SuppressWarnings("unchecked")
    public <E extends RealmObject> RealmResults<E> allObjectsSorted(Class<E> clazz, String fieldNames[],
                                                               boolean sortAscending[]) {
        if (fieldNames == null) {
            throw new IllegalArgumentException("fieldNames must be provided.");
        } else if (sortAscending == null) {
            throw new IllegalArgumentException("sortAscending must be provided.");
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b08980;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a08980;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c08980
<<<<<<< MINE
public <E extends RealmObject> RealmResults<E> allObjectsSorted(Class<E> clazz, String fieldName,
                                                               boolean sortAscending) {
        checkIfValid();
        Table table = getTable(clazz);
        TableView.Order order = sortAscending ? TableView.Order.ascending : TableView.Order.descending;
        long columnIndex = columnIndices.getColumnIndex(clazz, fieldName);
        if (columnIndex < 0) {
            throw new IllegalArgumentException(String.format("Field name '%s' does not exist.", fieldName));
=======
@SuppressWarnings("unchecked")
    public <E extends RealmObject> RealmResults<E> allObjectsSorted(Class<E> clazz, String fieldNames[],
                                                               boolean sortAscending[]) {
        if (fieldNames == null) {
            throw new IllegalArgumentException("fieldNames must be provided.");
        } else if (sortAscending == null) {
            throw new IllegalArgumentException("sortAscending must be provided.");
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b12408;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a12408;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c12408
<<<<<<< MINE
public <E extends RealmObject> RealmResults<E> allObjectsSorted(Class<E> clazz, String fieldName,
                                                               boolean sortAscending) {
        checkIfValid();
        Table table = getTable(clazz);
        TableView.Order order = sortAscending ? TableView.Order.ascending : TableView.Order.descending;
        long columnIndex = columnIndices.getColumnIndex(clazz, fieldName);
        if (columnIndex < 0) {
            throw new IllegalArgumentException(String.format("Field name '%s' does not exist.", fieldName));
=======
@SuppressWarnings("unchecked")
    public <E extends RealmObject> RealmResults<E> allObjectsSorted(Class<E> clazz, String fieldNames[],
                                                               boolean sortAscending[]) {
        if (fieldNames == null) {
            throw new IllegalArgumentException("fieldNames must be provided.");
        } else if (sortAscending == null) {
            throw new IllegalArgumentException("sortAscending must be provided.");
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b12412;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a12412;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c12412
<<<<<<< MINE
        Table table = getTable(clazz);
=======
        Table table = initTable(clazz);
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b12412;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a12412;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c12412
<<<<<<< MINE
public <E extends RealmObject> RealmResults<E> allObjectsSorted(Class<E> clazz, String fieldName,
                                                               boolean sortAscending) {
        checkIfValid();
        Table table = getTable(clazz);
        TableView.Order order = sortAscending ? TableView.Order.ascending : TableView.Order.descending;
        Long columnIndex = columnIndices.get(clazz.getSimpleName()).get(fieldName);
        if (columnIndex == null || columnIndex < 0) {
            throw new IllegalArgumentException(String.format("Field name '%s' does not exist.", fieldName));
=======
@SuppressWarnings("unchecked")
    public <E extends RealmObject> RealmResults<E> allObjectsSorted(Class<E> clazz, String fieldNames[],
                                                               boolean sortAscending[]) {
        if (fieldNames == null) {
            throw new IllegalArgumentException("fieldNames must be provided.");
        } else if (sortAscending == null) {
            throw new IllegalArgumentException("sortAscending must be provided.");
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b12412;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a12412;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c12412
<<<<<<< MINE
=======
public static AllTypes copy(Realm realm, AllTypes newObject, boolean update, Map<RealmObject,RealmObject> cache) {
        AllTypes realmObject = realm.createObject(AllTypes.class, newObject.getColumnString());
        cache.put(newObject, realmObject);
        realmObject.setColumnString(newObject.getColumnString() != null ? newObject.getColumnString() : "");
        realmObject.setColumnLong(newObject.getColumnLong());
        realmObject.setColumnFloat(newObject.getColumnFloat());
        realmObject.setColumnDouble(newObject.getColumnDouble());
        realmObject.setColumnBoolean(newObject.isColumnBoolean());
        realmObject.setColumnDate(newObject.getColumnDate() != null ? newObject.getColumnDate() : new Date(0));
        realmObject.setColumnBinary(newObject.getColumnBinary() != null ? newObject.getColumnBinary() : new byte[0]);

        some.test.AllTypes columnObjectObj = newObject.getColumnObject();
        if (columnObjectObj != null) {
            some.test.AllTypes cachecolumnObject = (some.test.AllTypes) cache.get(columnObjectObj);
            if (cachecolumnObject != null) {
                realmObject.setColumnObject(cachecolumnObject);
            } else {
                realmObject.setColumnObject(AllTypesRealmProxy.copyOrUpdate(realm, columnObjectObj, update, cache));
            }
        }

        RealmList<AllTypes> columnRealmListList = newObject.getColumnRealmList();
        if (columnRealmListList != null) {
            RealmList<AllTypes> columnRealmListRealmList = realmObject.getColumnRealmList();
            for (int i = 0; i < columnRealmListList.size(); i++) {
                AllTypes columnRealmListItem = columnRealmListList.get(i);
                AllTypes cachecolumnRealmList = (AllTypes) cache.get(columnRealmListItem);
                if (cachecolumnRealmList != null) {
                    columnRealmListRealmList.add(cachecolumnRealmList);
                } else {
                    columnRealmListRealmList.add(AllTypesRealmProxy.copyOrUpdate(realm, columnRealmListList.get(i), update, cache));
                }
            }
        }

        return realmObject;
    }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b12412;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a12412;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c12412
<<<<<<< MINE
        writer.emitStatement("cache.put(newObject, (RealmObjectProxy) realmObject)");
=======
        }
        writer.emitStatement("cache.put(newObject, realmObject)");
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b20836;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a20836;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c20836
<<<<<<< MINE
                proxyMediator.validateTable(modelClass, realm.transaction);
                columnIndices.addClass(modelClass, proxyMediator.getColumnIndices(modelClass));
=======
                    try {
                        initTableMethod.invoke(null, realm.transaction);
                        commitNeeded = true;
                    } catch (IllegalAccessException e) {
                        throw new RealmException("Could not execute the initTable method in the " + generatedClassName + " class: " + APT_NOT_EXECUTED_MESSAGE);
                    } catch (InvocationTargetException e) {
                        throw new RealmException("An exception was thrown in the initTable method in the " + generatedClassName + " class: " + APT_NOT_EXECUTED_MESSAGE);
                    }
                }

                // validate created table
                Method validateMethod;
                try {
                    validateMethod = generatedClass.getMethod("validateTable", new Class[]{ImplicitTransaction.class});
                } catch (NoSuchMethodException e) {
                    throw new RealmException("Could not find the validateTable method in the generated " + generatedClassName + " class: " + APT_NOT_EXECUTED_MESSAGE);
                }
                try {
                    validateMethod.invoke(null, realm.transaction);
                } catch (IllegalAccessException e) {
                    throw new RealmException("Could not execute the validateTable method in the " + generatedClassName + " class: " + APT_NOT_EXECUTED_MESSAGE);
                } catch (InvocationTargetException e) {
                    throw new RealmMigrationNeededException(e.getMessage(), e);
                }

                // Populate the columnIndices table
                Method columnIndiciesMethod;
                try {
                    columnIndiciesMethod = generatedClass.getMethod("getColumnIndices");
                } catch (NoSuchMethodException e) {
                    throw new RealmException("Could not find the getColumnIndices method in the generated " + generatedClassName + " class: " + APT_NOT_EXECUTED_MESSAGE);
                }
                Map<String,Long> indices;
                try {
                    //noinspection unchecked
                    indices = (Map<String,Long>) columnIndiciesMethod.invoke(null);
                } catch (IllegalAccessException e) {
                    throw new RealmException("Could not execute the getColumnIndices method in the generated " + generatedClassName + " class", e);
                } catch (InvocationTargetException e) {
                    throw new RealmException("An exception was thrown in the getColumnIndices method in the generated " + generatedClassName + " class", e);
                }
                realm.columnIndices.addClass((Class<? extends RealmObject>) generatedClass.getSuperclass(), indices);
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b20752;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a20752;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c20752
<<<<<<< MINE
public static synchronized boolean deleteRealmFile(Context context, String fileName) {
        boolean result = true;
        File writableFolder = context.getFilesDir();

        File realmFile = new File(writableFolder, fileName);
        int realmId = realmFile.getAbsolutePath().hashCode();

        AtomicInteger counter = openRealms.get(realmId);
        if (counter != null && counter.get() > 0) {
            throw new IllegalStateException("It's not allowed to delete the file associated with an open Realm. " +
                    "Remember to close() all the instances of the Realm before deleting its file.");
        }

        List<File> filesToDelete = Arrays.asList(realmFile, new File(writableFolder, fileName + ".lock"));
        for (File fileToDelete : filesToDelete) {
            if (fileToDelete.exists()) {
                boolean deleteResult = fileToDelete.delete();
                if (!deleteResult) {
                    result = false;
                    RealmLog.w("Could not delete the file " + fileToDelete);
                }
            }
        }
        return result;
=======
public static boolean deleteRealmFile(Context context, String fileName) {
        return deleteRealmFile(new File(context.getFilesDir(), fileName));
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b14180;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a14180;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c14180
<<<<<<< MINE
=======
public static Simple copyOrUpdate(Realm realm, Simple object, boolean update, Map<RealmObject,RealmObject> cache) {
        if (object.realm != null && object.realm.getId() == realm.getId()) {
            return object;
        }
        return copy(realm, object, update, cache);
    }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b14180;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a14180;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c14180
<<<<<<< MINE
=======
public static Booleans copyOrUpdate(Realm realm, Booleans object, boolean update, Map<RealmObject,RealmObject> cache) {
        if (object.realm != null && object.realm.getId() == realm.getId()) {
            return object;
        }
        return copy(realm, object, update, cache);
    }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b14180;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a14180;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c14180
<<<<<<< MINE
=======
public static AllTypes copyOrUpdate(Realm realm, AllTypes object, boolean update, Map<RealmObject,RealmObject> cache) {
        if (object.realm != null && object.realm.getId() == realm.getId()) {
            return object;
        }
        AllTypes realmObject = null;
        boolean canUpdate = update;
        if (canUpdate) {
            Table table = realm.getTable(AllTypes.class);
            long pkColumnIndex = table.getPrimaryKey();
            long rowIndex = table.findFirstString(pkColumnIndex, object.getColumnString());
            if (rowIndex != TableOrView.NO_MATCH) {
                realmObject = new AllTypesRealmProxy();
                realmObject.realm = realm;
                realmObject.row = table.getRow(rowIndex);
                cache.put(object, realmObject);
            } else {
                canUpdate = false;
            }
        }

        if (canUpdate) {
            return update(realm, realmObject, object, cache);
        } else {
            return copy(realm, object, update, cache);
        }
    }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b12760;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a12760;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c12760
<<<<<<< MINE
            proxyMediator.populateUsingJsonStream(obj, reader);
            copyToRealmOrUpdate(obj);
        } catch (RuntimeException e) {
            throw new RealmException("Could not create Json object from string", e);
=======
            scanner = getFullStringScanner(in);
            JSONObject json = new JSONObject(scanner.next());
            return realmJson.createOrUpdateUsingJsonObject(clazz, this, json, true);
        } catch (JSONException e) {
            throw new RealmException("Failed to read JSON", e);
        } finally {
            if (scanner != null) {
                scanner.close();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b09176;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a09176;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c09176
<<<<<<< MINE
                proxyMediator.validateTable(modelClass, realm.transaction);
                realm.columnIndices.addClass(modelClass, proxyMediator.getColumnIndices(modelClass));
=======
                    try {
                        initTableMethod.invoke(null, realm.transaction);
                        commitNeeded = true;
                    } catch (IllegalAccessException e) {
                        throw new RealmException("Could not execute the initTable method in the " + generatedClassName + " class: " + APT_NOT_EXECUTED_MESSAGE);
                    } catch (InvocationTargetException e) {
                        throw new RealmException("An exception was thrown in the initTable method in the " + generatedClassName + " class: " + APT_NOT_EXECUTED_MESSAGE);
                    }
                }

                // validate created table
                Method validateMethod;
                try {
                    validateMethod = generatedClass.getMethod("validateTable", new Class[]{ImplicitTransaction.class});
                } catch (NoSuchMethodException e) {
                    throw new RealmException("Could not find the validateTable method in the generated " + generatedClassName + " class: " + APT_NOT_EXECUTED_MESSAGE);
                }
                try {
                    validateMethod.invoke(null, realm.transaction);
                } catch (IllegalAccessException e) {
                    throw new RealmException("Could not execute the validateTable method in the " + generatedClassName + " class: " + APT_NOT_EXECUTED_MESSAGE);
                } catch (InvocationTargetException e) {
                    throw new RealmMigrationNeededException(realm.getPath(), e.getMessage(), e);
                }

                // Populate the columnIndices table
                Method columnIndiciesMethod;
                try {
                    columnIndiciesMethod = generatedClass.getMethod("getColumnIndices");
                } catch (NoSuchMethodException e) {
                    throw new RealmException("Could not find the getColumnIndices method in the generated " + generatedClassName + " class: " + APT_NOT_EXECUTED_MESSAGE);
                }
                Map<String,Long> indices;
                try {
                    //noinspection unchecked
                    indices = (Map<String,Long>) columnIndiciesMethod.invoke(null);
                } catch (IllegalAccessException e) {
                    throw new RealmException("Could not execute the getColumnIndices method in the generated " + generatedClassName + " class", e);
                } catch (InvocationTargetException e) {
                    throw new RealmException("An exception was thrown in the getColumnIndices method in the generated " + generatedClassName + " class", e);
                }
                realm.columnIndices.addClass((Class<? extends RealmObject>) generatedClass.getSuperclass(), indices);
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b09176;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a09176;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c09176
<<<<<<< MINE
=======
public static Simple copyOrUpdate(Realm realm, Simple object, boolean update, Map<RealmObject,RealmObject> cache) {
        if (object.realm != null && object.realm.getPath().equals(realm.getPath())) {
            return object;
        }
        return copy(realm, object, update, cache);
    }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b09176;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a09176;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c09176
<<<<<<< MINE
=======
public static Booleans copyOrUpdate(Realm realm, Booleans object, boolean update, Map<RealmObject,RealmObject> cache) {
        if (object.realm != null && object.realm.getPath().equals(realm.getPath())) {
            return object;
        }
        return copy(realm, object, update, cache);
    }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b09176;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a09176;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c09176
<<<<<<< MINE
=======
public static AllTypes copyOrUpdate(Realm realm, AllTypes object, boolean update, Map<RealmObject,RealmObject> cache) {
        if (object.realm != null && object.realm.getPath().equals(realm.getPath())) {
            return object;
        }
        AllTypes realmObject = null;
        boolean canUpdate = update;
        if (canUpdate) {
            Table table = realm.getTable(AllTypes.class);
            long pkColumnIndex = table.getPrimaryKey();
            if (object.getColumnString() == null) {
                throw new IllegalArgumentException("Primary key value must not be null.");
            }
            long rowIndex = table.findFirstString(pkColumnIndex, object.getColumnString());
            if (rowIndex != TableOrView.NO_MATCH) {
                realmObject = new AllTypesRealmProxy();
                realmObject.realm = realm;
                realmObject.row = table.getRow(rowIndex);
                cache.put(object, realmObject);
            } else {
                canUpdate = false;
            }
        }

        if (canUpdate) {
            return update(realm, realmObject, object, cache);
        } else {
            return copy(realm, object, update, cache);
        }
    }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b17768;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a17768;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c17768
<<<<<<< MINE
=======
@SuppressWarnings("unchecked")
    private static void initializeRealm(Realm realm) {
        long version = realm.getVersion();
        boolean commitNeeded = false;
        try {
            realm.beginTransaction();
            if (version == UNVERSIONED) {
                realm.setVersion(0);
                commitNeeded = true;
            }

            for (Class<? extends RealmObject> modelClass : proxyMediator.getModelClasses()) {
                String modelClassName = modelClass.getSimpleName();

                // Create and validate table
                if (version == UNVERSIONED) {
                    proxyMediator.createTable(modelClass, realm.transaction);
                }
                proxyMediator.validateTable(modelClass, realm.transaction);
                realm.columnIndices.addClass(modelClass, proxyMediator.getColumnIndices(modelClass));
            }
        } finally {
            if (commitNeeded) {
                realm.commitTransaction();
            } else {
                realm.cancelTransaction();
            }
        }
    }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b17768;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a17768;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c17768
<<<<<<< MINE
=======
/**
     * Compact a Realm file. A Realm file usually contain free/unused space.
     * This method removes this free space and the file size is thereby reduced.
     * Objects within the Realm files are untouched.
     * <p>
     * The file must be closed before this method is called.<br>
     * The file system should have free space for at least a copy of the Realm file.<br>
     * The realm file is left untouched if any file operation fails.<br>
     * Currently it is not possible to compact an encrypted Realm.<br>
     *
     * @param context an Android {@link android.content.Context}
     * @param fileName the name of the file to compact
     * @param key Key for opening an encrypted Realm.
     * @return true if successful, false if any file operation failed
     *
     * @throws java.lang.IllegalStateException if trying to compact a Realm that is already open.
     */
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b17768;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a17768;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c17768
<<<<<<< MINE
=======
     *
     * @throws java.lang.IllegalStateException if trying to compact a Realm that is already open.
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b17768;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a17768;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c17768
<<<<<<< MINE
=======
/**
     * Override the standard behavior of all classes extended RealmObject being part of the schema.
     * Use this method to define the schema as only the classes given here.
     *
     * This class must be called before calling {@link #getInstance(android.content.Context)}
     *
     * If {@code null} is given as parameter, the Schema is reset to use all known classes.
     *
     */
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b17768;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a17768;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c17768
<<<<<<< MINE
=======
@SafeVarargs
    static void setSchema(Class<? extends RealmObject>... schemaClass) {
        if (schemaClass != null) {
            // Filter default schema
            proxyMediator = new FilterableMediator(getDefaultMediator(), Arrays.asList(schemaClass));
        } else if (proxyMediator instanceof FilterableMediator) {
            // else reset filter if needed
            proxyMediator = ((FilterableMediator) proxyMediator).getOriginalMediator();
        }
    }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b20736;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a20736;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c20736
<<<<<<< MINE
=======
/**
     * Delete the Realm file from the filesystem for a custom named Realm.
     * The Realm must be unused and closed before calling this method.
     *
     * @param realmFile The reference to the Realm file.
     * @return false if a file could not be deleted. The failing file will be logged.
     *
     * @throws java.lang.IllegalStateException if trying to delete a Realm that is already open.
     */
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b20736;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a20736;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c20736
<<<<<<< MINE
=======
/**
     * Override the standard behavior of all classes extended RealmObject being part of the schema.
     * Use this method to define the schema as only the classes given here.
     *
     * This class must be called before calling {@link #getInstance(android.content.Context)}
     *
     * If {@code null} is given as parameter, the Schema is reset to use all known classes.
     *
     */
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b20736;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a20736;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c20736
<<<<<<< MINE
// Get the canonical path for a given file
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b16236;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a16236;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c16236
<<<<<<< MINE
// Get the canonical path for a given file
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b16356;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a16356;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c16356
<<<<<<< MINE
=======
public static synchronized boolean compactRealmFile(Context context, String fileName, byte[] key) {
        if (key != null) { // TODO: use proper key in SharedGroup init when encrypted realms are supported
            throw new IllegalArgumentException("Cannot currently compact an encrypted Realm.");
        }

        File realmFile = new File(context.getFilesDir(), fileName);
        String canonicalPath = getCanonicalPath(realmFile);
        if (openRealms.get(canonicalPath).get() > 0) {
            throw new IllegalStateException("Cannot compact an open Realm");
        }
        SharedGroup sharedGroup = null;
        boolean result = false;
        try {
            sharedGroup = new SharedGroup(canonicalPath, false, null);
            result = sharedGroup.compact();
        } finally {
            if (sharedGroup != null) {
                sharedGroup.close();
            }
        }
        return result;
    }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b16356;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a16356;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c16356
<<<<<<< MINE
// Get the canonical path for a given file
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b16428;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a16428;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c16428
<<<<<<< MINE
// Get the canonical path for a given file
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b08028;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a08028;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c08028
<<<<<<< MINE
=======
// Get the canonical path for a given file
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b11636;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a11636;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c11636
<<<<<<< MINE
private native void nativeAdvanceRead(long nativePtr, long nativeReplicationPtr);
=======
private native void nativeAdvanceRead(long nativePtr, long native_replication_ptr);
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b11636;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a11636;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c11636
<<<<<<< MINE
private native void nativePromoteToWrite(long nativePtr, long nativeReplicationPtr);
=======
private native void nativePromoteToWrite(long nativePtr, long native_replication_ptr);
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b11636;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a11636;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c11636
<<<<<<< MINE
private native void nativeRollbackAndContinueAsRead(long nativePtr, long nativeReplicationPtr);
=======
private native void nativeRollbackAndContinueAsRead(long nativePtr, long native_replication_ptr);
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b18768;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a18768;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c18768
<<<<<<< MINE
private native void nativeAdvanceRead(long nativePtr, long nativeReplicationPtr);
=======
private native void nativeAdvanceRead(long nativePtr, long native_replication_ptr);
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b18768;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a18768;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c18768
<<<<<<< MINE
private native void nativePromoteToWrite(long nativePtr, long nativeReplicationPtr);
=======
private native void nativePromoteToWrite(long nativePtr, long native_replication_ptr);
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b18768;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a18768;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c18768
<<<<<<< MINE
private native void nativeRollbackAndContinueAsRead(long nativePtr, long nativeReplicationPtr);
=======
private native void nativeRollbackAndContinueAsRead(long nativePtr, long native_replication_ptr);
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b04760;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a04760;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c04760
<<<<<<< MINE
static final int REALM_CHANGED = 14930352;
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b04760;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a04760;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c04760
<<<<<<< MINE
protected SharedGroup sharedGroup;
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b04760;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a04760;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c04760
<<<<<<< MINE
@Override
    public void close() {
        if (this.threadId != Thread.currentThread().getId()) {
            throw new IllegalStateException(INCORRECT_THREAD_CLOSE_MESSAGE);
        }

        Map<RealmConfiguration, Integer> localRefCount = referenceCount.get();
        String canonicalPath = configuration.getPath();
        Integer references = localRefCount.get(configuration);
        if (references == null) {
            references = 0;
        }
        if (sharedGroup != null && references == 1) {
            realmsCache.get().remove(configuration);
            sharedGroup.close();
            sharedGroup = null;

            // It is necessary to be synchronized here since there is a chance that before the counter removed,
            // the other thread could get the counter and increase it in createAndValidate.
            synchronized (Realm.class) {
                validatedRealmFiles.remove(configuration.getPath());
                List<RealmConfiguration>  pathConfigurationCache = globalPathConfigurationCache.get(canonicalPath);
                pathConfigurationCache.remove(configuration);
                if (pathConfigurationCache.isEmpty()) {
                    globalPathConfigurationCache.remove(canonicalPath);
                }
                AtomicInteger counter = globalOpenInstanceCounter.get(canonicalPath);
                if (counter.decrementAndGet() == 0) {
                    globalOpenInstanceCounter.remove(canonicalPath);
                }
            }
        }

        int refCount = references - 1;
        if (refCount < 0) {
            RealmLog.w("Calling close() on a Realm that is already closed: " + canonicalPath);
        }
        localRefCount.put(configuration, Math.max(0, refCount));

        if (handler != null && refCount <= 0) {
            removeHandler(handler);
            handler = null;
        }
    }
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b04760;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a04760;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c04760
<<<<<<< MINE
@Override
        public boolean handleMessage(Message message) {
            switch (message.what) {
                case REALM_CHANGED: {
                    if (threadContainsAsyncQueries()) {
                        if (updateAsyncQueriesTask != null && !updateAsyncQueriesTask.isDone()) {
                            // try to cancel any pending update since we're submitting a new one anyway
                            updateAsyncQueriesTask.cancel(true);
                            asyncQueryExecutor.getQueue().remove(updateAsyncQueriesTask);
                            RealmLog.d("REALM_CHANGED realm:"+ Realm.this + " cancelling pending REALM_UPDATE_ASYNC_QUERIES updates");
                        }
                        RealmLog.d("REALM_CHANGED realm:"+ Realm.this + " updating async queries, total: " + asyncRealmResults.size());
                        // prepare a QueryUpdateTask to current async queries in this thread
                        QueryUpdateTask.Builder.UpdateQueryStep updateQueryStep = QueryUpdateTask.newBuilder()
                                .realmConfiguration(getConfiguration());
                        QueryUpdateTask.Builder.RealmResultsQueryStep realmResultsQueryStep = null;

                        // we iterate over non GC'd async RealmResults then add them to the list to be updated (in a batch)
                        Iterator<Map.Entry<WeakReference<RealmResults<?>>, RealmQuery<?>>> iterator = asyncRealmResults.entrySet().iterator();
                        while (iterator.hasNext()) {
                            Map.Entry<WeakReference<RealmResults<?>>, RealmQuery<?>> entry = iterator.next();
                            WeakReference<RealmResults<?>> weakReference = entry.getKey();
                            RealmResults<?> realmResults = weakReference.get();
                            if (realmResults == null) {
                                // GC'd instance remove from the list
                                iterator.remove();

                            } else {
                                realmResultsQueryStep = updateQueryStep.add(weakReference,
                                                  entry.getValue().handoverQueryPointer(),
                                                  entry.getValue().getArgument());
                            }

                            // Note: we're passing an WeakRef of a RealmResults to another thread
                            //       this is safe as long as we don't invoke any of the RealmResults methods.
                            //       we're just using it as a Key in an IdentityHashMap (i.e doesn't call
                            //       AbstractList's hashCode, that require accessing objects from another thread)
                            //
                            //       watch out when you debug, as you're IDE try to evaluate RealmResults
                            //       which break the Thread confinement constraints.
                        }
                        if (realmResultsQueryStep != null) {
                            QueryUpdateTask queryUpdateTask = realmResultsQueryStep
                                    .sendToHandler(handler, REALM_UPDATE_ASYNC_QUERIES)
                                    .build();
                            updateAsyncQueriesTask = asyncQueryExecutor.submit(queryUpdateTask);
                        }

                    } else {
                        RealmLog.d("REALM_CHANGED realm:"+ Realm.this + " no async queries, advance_read");
                        transaction.advanceRead();
                        sendNotifications();
                    }
                    break;
                }
                case REALM_COMPLETED_ASYNC_QUERY: {
                    // one async query has completed
                    QueryUpdateTask.Result result
                            = (QueryUpdateTask.Result) message.obj;

                    Set<WeakReference<RealmResults<?>>> updatedTableViewsKeys = result.updatedTableViews.keySet();
                    if (updatedTableViewsKeys.size() > 0) {
                        WeakReference<RealmResults<?>> weakRealmResults = updatedTableViewsKeys.iterator().next();

                        RealmResults<?> realmResults = weakRealmResults.get();
                        if (realmResults == null) {
                            asyncRealmResults.remove(weakRealmResults);
                            RealmLog.d("[REALM_COMPLETED_ASYNC_QUERY "+ weakRealmResults + "] realm:"+ Realm.this + " RealmResults GC'd ignore results");

                        } else {
                            SharedGroup.VersionID callerVersionID = sharedGroup.getVersion();
                            int compare = callerVersionID.compareTo(result.versionID);
                            if (compare == 0) {
                                // if the RealmResults is empty (has not completed yet) then use the value
                                // otherwise a task (grouped update) has already updated this RealmResults
                                if (!realmResults.isLoaded()) {
                                    RealmLog.d("[REALM_COMPLETED_ASYNC_QUERY "+ weakRealmResults + "] , realm:"+ Realm.this + " same versions, using results (RealmResults is not loaded)");
                                    // swap pointer
                                    realmResults.swapTableViewPointer(result.updatedTableViews.get(weakRealmResults));
                                    // notify callbacks
                                    realmResults.notifyChangeListeners();
                                } else {
                                    RealmLog.d("[REALM_COMPLETED_ASYNC_QUERY "+ weakRealmResults + "] , realm:"+ Realm.this + " ignoring result the RealmResults (is already loaded)");
                                }

                            } else if (compare > 0) {
                                // we have two use cases:
                                // 1- this RealmResults is not empty, this means that after we started the async
                                //    query, we received a REALM_CHANGE that triggered an update of all async queries
                                //    including the last async submitted, so no need to use the provided TableView pointer
                                //    (or the user forced the sync behaviour .load())
                                // 2- This RealmResults is still empty but this caller thread is advanced than the worker thread
                                //    this could happen if the current thread advanced the shared_group (via a write or refresh)
                                //    this means that we need to rerun the query against a newer worker thread.

                                if (!realmResults.isLoaded()) { // UC2
                                    // UC covered by this test: RealmAsyncQueryTests#testFindAllAsyncRetry
                                    RealmLog.d("[REALM_COMPLETED_ASYNC_QUERY " + weakRealmResults + "] , realm:"+ Realm.this + " caller is more advanced & RealmResults is not loaded, rerunning the query against the latest version");

                                    RealmQuery<?> query = asyncRealmResults.get(weakRealmResults);
                                    QueryUpdateTask queryUpdateTask = QueryUpdateTask.newBuilder()
                                            .realmConfiguration(getConfiguration())
                                            .add(weakRealmResults,
                                                    query.handoverQueryPointer(),
                                                    query.getArgument())
                                            .sendToHandler(handler, REALM_COMPLETED_ASYNC_QUERY)
                                            .build();

                                    asyncQueryExecutor.submit(queryUpdateTask);

                                } else {
                                    // UC covered by this test: RealmAsyncQueryTests#testFindAllCallerIsAdvanced
                                    RealmLog.d("[REALM_COMPLETED_ASYNC_QUERY "+ weakRealmResults + "] , realm:"+ Realm.this + " caller is more advanced & RealmResults is loaded ignore the outdated result");
                                }

                            } else {
                                // the caller thread is behind the worker thread,
                                // no need to rerun the query, since we're going to receive the update signal
                                // & batch update all async queries including this one
                                // UC covered by this test: RealmAsyncQueryTests#testFindAllCallerThreadBehind
                                RealmLog.d("[REALM_COMPLETED_ASYNC_QUERY "+ weakRealmResults + "] , realm:"+ Realm.this + " caller thread behind worker thread, ignore results (a batch update will update everything including this query)");
                            }
                        }
                    }
                    break;
                }
                case REALM_UPDATE_ASYNC_QUERIES: {
                    // this is called once the background thread completed the update of the async queries
                    QueryUpdateTask.Result result
                            = (QueryUpdateTask.Result) message.obj;

                    SharedGroup.VersionID callerVersionID = sharedGroup.getVersion();
                    int compare = callerVersionID.compareTo(result.versionID);
                    if (compare > 0) {
                        RealmLog.d("REALM_UPDATE_ASYNC_QUERIES realm:"+ Realm.this + " caller is more advanced, rerun updates");
                        // The caller is more advance than the updated queries ==>
                        // need to refresh them again (if there is still queries)
                        handler.sendEmptyMessage(REALM_CHANGED);

                    } else {
                        // We're behind or on the same version as the worker thread

                        // only advance if we're behind
                        if (compare != 0) {
                            // no need to remove old pointers from TableView, since they're
                            // imperative TV, they will not rerun if the SharedGroup advance

                            // UC covered by this test: RealmAsyncQueryTests#testFindAllCallerThreadBehind
                            RealmLog.d("REALM_UPDATE_ASYNC_QUERIES realm:"+ Realm.this + " caller is behind  advance_read");
                            // refresh the Realm to the version provided by the worker thread
                            // (advanceRead to the latest version may cause a version mismatch error) preventing us
                            // from importing correctly the handover table view
                            transaction.advanceRead(result.versionID);
                        }

                        ArrayList<RealmResults<?>> callbacksToNotify = new ArrayList<RealmResults<?>>(result.updatedTableViews.size());
                        // use updated TableViews pointers for the existing async RealmResults
                        for (Map.Entry<WeakReference<RealmResults<?>>, Long> query : result.updatedTableViews.entrySet()) {
                            WeakReference<RealmResults<?>> weakRealmResults = query.getKey();
                            RealmResults<?> realmResults = weakRealmResults.get();
                            if (realmResults == null) {
                                // don't update GC'd instance
                                asyncRealmResults.remove(weakRealmResults);

                            } else {
                                // it's dangerous to notify the callback about new results before updating
                                // the pointers, because the callback may use another RealmResults not updated yet
                                // this is why we defer the notification until we're done updating all pointers

                                // TODO find a way to only notify callbacks if the underlying data changed compared
                                //      to the existing value(s) for this RealmResults (use a hashCode?)
                                callbacksToNotify.add(realmResults);

                                RealmLog.d("REALM_UPDATE_ASYNC_QUERIES realm:"+ Realm.this + " updating RealmResults " + weakRealmResults);
                                // update the instance with the new pointer
                                realmResults.swapTableViewPointer(query.getValue());
                            }
                        }

                        for (RealmResults<?> query : callbacksToNotify) {
                            query.notifyChangeListeners();
                        }

                        // notify listeners only when we advanced
                        if (compare != 0) {
                            sendNotifications();
                        }

                        updateAsyncQueriesTask = null;
                    }
                    break;
                }
                case REALM_COMPLETED_ASYNC_FIND_FIRST: {
                    QueryUpdateTask.Result result = (QueryUpdateTask.Result) message.obj;
                    Set<WeakReference<RealmObject>> updatedRowKey = result.updatedRow.keySet();
                    if (updatedRowKey.size() > 0) {
                        WeakReference<RealmObject> realmObjectWeakReference = updatedRowKey.iterator().next();
                        RealmObject realmObject = realmObjectWeakReference.get();

                        if (realmObject != null) {
                            SharedGroup.VersionID callerVersionID = sharedGroup.getVersion();
                            int compare = callerVersionID.compareTo(result.versionID);
                            // we always query on the same version
                            // only two use cases could happen 1. we're on the same version or 2. the caller has advanced in the meanwhile
                            if (compare == 0) { //same version import the handover
                                realmObject.onCompleted(result.updatedRow.get(realmObjectWeakReference));
                                asyncRealmObjects.remove(realmObjectWeakReference);

                            } else if (compare > 0) {
                                // the caller has advanced we need to
                                // retry against the current version of the caller
                                RealmQuery<?> realmQuery = asyncRealmObjects.get(realmObjectWeakReference);

                                QueryUpdateTask queryUpdateTask = QueryUpdateTask.newBuilder()
                                        .realmConfiguration(getConfiguration())
                                        .addObject(realmObjectWeakReference,
                                                realmQuery.handoverQueryPointer(),
                                                realmQuery.getArgument())
                                        .sendToHandler(handler, REALM_COMPLETED_ASYNC_FIND_FIRST)
                                        .build();

                                asyncQueryExecutor.submit(queryUpdateTask);
                            } else {
                                // should not happen, since the the background thread position itself against the provided version
                                // and the caller thread can only go forward (advance_read)
                                throw new IllegalStateException("Caller thread behind the worker thread");
                            }
                        } // else: element GC'd in the meanwhile
                    }
                    break;
                }
            }
            return true;
        }
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b04760;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a04760;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c04760
<<<<<<< MINE
// package protected so unit tests can access it

    // Returns the Handler for this Realm on the calling thread
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b04760;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a04760;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c04760
<<<<<<< MINE
Handler getHandler() {
        return handler;
    }
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b11608;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a11608;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c11608
<<<<<<< MINE
=======
@Override
        public boolean handleMessage(Message message) {
            // Due to how a ConcurrentHashMap iterator is created we cannot be sure that other threads are
            // aware when this threads handler is removed before they send messages to it. We don't wish to synchronize
            // access to the handlers as they are the prime mean of notifying about updates. Instead we make sure
            // that if a message does slip though (however unlikely), it will not try to update a SharedGroup that no
            // longer exists. `sharedGroupManager` will only be null if a Realm is really closed.
            if (message.what == REALM_CHANGED && sharedGroupManager != null) {
                sharedGroupManager.advanceRead();
                sendNotifications();
            }
            return true;
        }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b10436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a10436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c10436
<<<<<<< MINE
public static Simple copyOrUpdate(Realm realm, Simple object, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
        if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().threadId != realm.threadId) {
            throw new IllegalArgumentException("Objects which belong to Realm instances in other threads cannot be copied into this Realm instance.");
        }
        if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
            return object;
        }
        RealmObjectProxy cachedRealmObject = cache.get(object);
        if (cachedRealmObject != null) {
            return (Simple) cachedRealmObject;
        } else {
            return copy(realm, object, update, cache);
        }
    }
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b10436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a10436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c10436
<<<<<<< MINE
public static Simple copy(Realm realm, Simple newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
        RealmObjectProxy cachedRealmObject = cache.get(newObject);
        if (cachedRealmObject != null) {
            return (Simple) cachedRealmObject;
        } else {
            Simple realmObject = realm.createObject(Simple.class);
            cache.put(newObject, (RealmObjectProxy) realmObject);
            ((SimpleRealmProxyInterface) realmObject).realmSet$name(((SimpleRealmProxyInterface) newObject).realmGet$name());
            ((SimpleRealmProxyInterface) realmObject).realmSet$age(((SimpleRealmProxyInterface) newObject).realmGet$age());
            return realmObject;
        }
    }
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b10436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a10436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c10436
<<<<<<< MINE
public static NullTypes copyOrUpdate(Realm realm, NullTypes object, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
        if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().threadId != realm.threadId) {
            throw new IllegalArgumentException("Objects which belong to Realm instances in other threads cannot be copied into this Realm instance.");
        }
        if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
            return object;
        }
        RealmObjectProxy cachedRealmObject = cache.get(object);
        if (cachedRealmObject != null) {
            return (NullTypes) cachedRealmObject;
        } else {
            return copy(realm, object, update, cache);
        }
    }
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b10436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a10436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c10436
<<<<<<< MINE
public static NullTypes copy(Realm realm, NullTypes newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
        RealmObjectProxy cachedRealmObject = cache.get(newObject);
        if (cachedRealmObject != null) {
            return (NullTypes) cachedRealmObject;
        } else {
            NullTypes realmObject = realm.createObject(NullTypes.class);
            cache.put(newObject, (RealmObjectProxy) realmObject);
            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldStringNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldStringNotNull());
            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldStringNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldStringNull());
            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldBooleanNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldBooleanNotNull());
            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldBooleanNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldBooleanNull());
            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldBytesNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldBytesNotNull());
            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldBytesNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldBytesNull());
            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldByteNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldByteNotNull());
            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldByteNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldByteNull());
            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldShortNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldShortNotNull());
            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldShortNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldShortNull());
            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldIntegerNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldIntegerNotNull());
            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldIntegerNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldIntegerNull());
            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldLongNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldLongNotNull());
            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldLongNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldLongNull());
            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldFloatNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldFloatNotNull());
            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldFloatNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldFloatNull());
            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldDoubleNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldDoubleNotNull());
            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldDoubleNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldDoubleNull());
            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldDateNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldDateNotNull());
            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldDateNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldDateNull());

            some.test.NullTypes fieldObjectNullObj = ((NullTypesRealmProxyInterface) newObject).realmGet$fieldObjectNull();
            if (fieldObjectNullObj != null) {
                some.test.NullTypes cachefieldObjectNull = (some.test.NullTypes) cache.get(fieldObjectNullObj);
                if (cachefieldObjectNull != null) {
                    ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldObjectNull(cachefieldObjectNull);
                } else {
                    ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldObjectNull(NullTypesRealmProxy.copyOrUpdate(realm, fieldObjectNullObj, update, cache));
                }
            } else {
                ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldObjectNull(null);
            }
            return realmObject;
        }
    }
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b10436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a10436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c10436
<<<<<<< MINE
public static Booleans copyOrUpdate(Realm realm, Booleans object, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
        if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().threadId != realm.threadId) {
            throw new IllegalArgumentException("Objects which belong to Realm instances in other threads cannot be copied into this Realm instance.");
        }
        if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
            return object;
        }
        RealmObjectProxy cachedRealmObject = cache.get(object);
        if (cachedRealmObject != null) {
            return (Booleans) cachedRealmObject;
        } else {
            return copy(realm, object, update, cache);
        }
    }
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b10436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a10436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c10436
<<<<<<< MINE
public static Booleans copy(Realm realm, Booleans newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
        RealmObjectProxy cachedRealmObject = cache.get(newObject);
        if (cachedRealmObject != null) {
            return (Booleans) cachedRealmObject;
        } else {
            Booleans realmObject = realm.createObject(Booleans.class);
            cache.put(newObject, (RealmObjectProxy) realmObject);
            ((BooleansRealmProxyInterface) realmObject).realmSet$done(((BooleansRealmProxyInterface) newObject).realmGet$done());
            ((BooleansRealmProxyInterface) realmObject).realmSet$isReady(((BooleansRealmProxyInterface) newObject).realmGet$isReady());
            ((BooleansRealmProxyInterface) realmObject).realmSet$mCompleted(((BooleansRealmProxyInterface) newObject).realmGet$mCompleted());
            ((BooleansRealmProxyInterface) realmObject).realmSet$anotherBoolean(((BooleansRealmProxyInterface) newObject).realmGet$anotherBoolean());
            return realmObject;
        }
    }
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b10436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a10436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c10436
<<<<<<< MINE
public static AllTypes copyOrUpdate(Realm realm, AllTypes object, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
        if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().threadId != realm.threadId) {
            throw new IllegalArgumentException("Objects which belong to Realm instances in other threads cannot be copied into this Realm instance.");
        }
        if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
            return object;
        }
        RealmObjectProxy cachedRealmObject = cache.get(object);
        if (cachedRealmObject != null) {
            return (AllTypes) cachedRealmObject;
        } else {
            AllTypes realmObject = null;
            boolean canUpdate = update;
            if (canUpdate) {
                Table table = realm.getTable(AllTypes.class);
                long pkColumnIndex = table.getPrimaryKey();
                String value = ((AllTypesRealmProxyInterface) object).realmGet$columnString();
                long rowIndex = TableOrView.NO_MATCH;
                if (value == null) {
                    rowIndex = table.findFirstNull(pkColumnIndex);
                } else {
                    rowIndex = table.findFirstString(pkColumnIndex, value);
                }
                if (rowIndex != TableOrView.NO_MATCH) {
                    realmObject = new AllTypesRealmProxy(realm.schema.getColumnInfo(AllTypes.class));
                    ((RealmObjectProxy)realmObject).realmGet$proxyState().setRealm$realm(realm);
                    ((RealmObjectProxy)realmObject).realmGet$proxyState().setRow$realm(table.getUncheckedRow(rowIndex));
                    cache.put(object, (RealmObjectProxy) realmObject);
                } else {
                    canUpdate = false;
                }
            }

            if (canUpdate) {
                return update(realm, realmObject, object, cache);
            } else {
                return copy(realm, object, update, cache);
            }
        }
    }
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b10436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a10436;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c10436
<<<<<<< MINE
public static AllTypes copy(Realm realm, AllTypes newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
        RealmObjectProxy cachedRealmObject = cache.get(newObject);
        if (cachedRealmObject != null) {
            return (AllTypes) cachedRealmObject;
        } else {
            AllTypes realmObject = realm.createObject(AllTypes.class, ((AllTypesRealmProxyInterface) newObject).realmGet$columnString());
            cache.put(newObject, (RealmObjectProxy) realmObject);
            ((AllTypesRealmProxyInterface) realmObject).realmSet$columnString(((AllTypesRealmProxyInterface) newObject).realmGet$columnString());
            ((AllTypesRealmProxyInterface) realmObject).realmSet$columnLong(((AllTypesRealmProxyInterface) newObject).realmGet$columnLong());
            ((AllTypesRealmProxyInterface) realmObject).realmSet$columnFloat(((AllTypesRealmProxyInterface) newObject).realmGet$columnFloat());
            ((AllTypesRealmProxyInterface) realmObject).realmSet$columnDouble(((AllTypesRealmProxyInterface) newObject).realmGet$columnDouble());
            ((AllTypesRealmProxyInterface) realmObject).realmSet$columnBoolean(((AllTypesRealmProxyInterface) newObject).realmGet$columnBoolean());
            ((AllTypesRealmProxyInterface) realmObject).realmSet$columnDate(((AllTypesRealmProxyInterface) newObject).realmGet$columnDate());
            ((AllTypesRealmProxyInterface) realmObject).realmSet$columnBinary(((AllTypesRealmProxyInterface) newObject).realmGet$columnBinary());

            some.test.AllTypes columnObjectObj = ((AllTypesRealmProxyInterface) newObject).realmGet$columnObject();
            if (columnObjectObj != null) {
                some.test.AllTypes cachecolumnObject = (some.test.AllTypes) cache.get(columnObjectObj);
                if (cachecolumnObject != null) {
                    ((AllTypesRealmProxyInterface) realmObject).realmSet$columnObject(cachecolumnObject);
                } else {
                    ((AllTypesRealmProxyInterface) realmObject).realmSet$columnObject(AllTypesRealmProxy.copyOrUpdate(realm, columnObjectObj, update, cache));
                }
            } else {
                ((AllTypesRealmProxyInterface) realmObject).realmSet$columnObject(null);
            }

            RealmList<AllTypes> columnRealmListList = ((AllTypesRealmProxyInterface) newObject).realmGet$columnRealmList();
            if (columnRealmListList != null) {
                RealmList<AllTypes> columnRealmListRealmList = ((AllTypesRealmProxyInterface) realmObject).realmGet$columnRealmList();
                for (int i = 0; i < columnRealmListList.size(); i++) {
                    AllTypes columnRealmListItem = columnRealmListList.get(i);
                    AllTypes cachecolumnRealmList = (AllTypes) cache.get(columnRealmListItem);
                    if (cachecolumnRealmList != null) {
                        columnRealmListRealmList.add(cachecolumnRealmList);
                    } else {
                        columnRealmListRealmList.add(AllTypesRealmProxy.copyOrUpdate(realm, columnRealmListList.get(i), update, cache));
                    }
                }
            }

            return realmObject;
        }
    }
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b17964;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a17964;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c17964
<<<<<<< MINE
public SharedGroupManager sharedGroupManager;
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b13224;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a13224;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c13224
<<<<<<< MINE
public static final Map<Handler, String> handlers = new ConcurrentHashMap<Handler, String>();
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b13224;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a13224;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c13224
<<<<<<< MINE
public Handler handler;
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b13224;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a13224;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c13224
<<<<<<< MINE
        setAutoRefresh(autoRefresh, true);
=======
        checkIfValid();
        handlerController.checkCanBeAutoRefreshed();
        handlerController.setAutoRefresh(autoRefresh);
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b06140;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a06140;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c06140
<<<<<<< MINE
/**
         * IMPORTANT: When adding any new methods to this class also add them to ObjectServerConfiguration.Builder
         */
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b07552;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a07552;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c07552
<<<<<<< MINE
=======
private RealmConfiguration(Builder builder) {
        this.realmDirectory = builder.directory;
        this.realmFileName = builder.fileName;
        this.canonicalPath = Realm.getCanonicalPath(new File(realmDirectory, realmFileName));
        this.assetFilePath = builder.assetFilePath;
        this.key = builder.key;
        this.schemaVersion = builder.schemaVersion;
        this.deleteRealmIfMigrationNeeded = builder.deleteRealmIfMigrationNeeded;
        this.migration = builder.migration;
        this.durability = builder.durability;
        this.schemaMediator = createSchemaMediator(builder);
        this.rxObservableFactory = builder.rxFactory;
        this.initialDataTransaction = builder.initialDataTransaction;
    }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b07552;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a07552;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c07552
<<<<<<< MINE
// IMPORTANT: When adding any new methods to this class also add them to SyncConfiguration.
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b17192;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a17192;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c17192
<<<<<<< MINE
=======
// FIXME: Set to a default once we merge global init
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b12272;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a12272;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c12272
<<<<<<< MINE
=======
private void injectObjectContext() {
        final BaseRealm.RealmObjectContext context = BaseRealm.objectContext.get();
        this.columnInfo = (SimpleColumnInfo) context.getColumnInfo();
        this.proxyState = new ProxyState<some.test.Simple>(this);
        proxyState.setRealm$realm(context.getRealm());
        proxyState.setRow$realm(context.getRow());
        proxyState.setAcceptDefaultValue$realm(context.getAcceptDefaultValue());
        proxyState.setExcludeFields$realm(context.getExcludeFields());
    }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b12272;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a12272;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c12272
<<<<<<< MINE
=======
private void injectObjectContext() {
        final BaseRealm.RealmObjectContext context = BaseRealm.objectContext.get();
        this.columnInfo = (NullTypesColumnInfo) context.getColumnInfo();
        this.proxyState = new ProxyState<some.test.NullTypes>(this);
        proxyState.setRealm$realm(context.getRealm());
        proxyState.setRow$realm(context.getRow());
        proxyState.setAcceptDefaultValue$realm(context.getAcceptDefaultValue());
        proxyState.setExcludeFields$realm(context.getExcludeFields());
    }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b12272;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a12272;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c12272
<<<<<<< MINE
=======
private void injectObjectContext() {
        final BaseRealm.RealmObjectContext context = BaseRealm.objectContext.get();
        this.columnInfo = (BooleansColumnInfo) context.getColumnInfo();
        this.proxyState = new ProxyState<some.test.Booleans>(this);
        proxyState.setRealm$realm(context.getRealm());
        proxyState.setRow$realm(context.getRow());
        proxyState.setAcceptDefaultValue$realm(context.getAcceptDefaultValue());
        proxyState.setExcludeFields$realm(context.getExcludeFields());
    }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b12272;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a12272;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c12272
<<<<<<< MINE
=======
private void injectObjectContext() {
        final BaseRealm.RealmObjectContext context = BaseRealm.objectContext.get();
        this.columnInfo = (AllTypesColumnInfo) context.getColumnInfo();
        this.proxyState = new ProxyState<some.test.AllTypes>(this);
        proxyState.setRealm$realm(context.getRealm());
        proxyState.setRow$realm(context.getRow());
        proxyState.setAcceptDefaultValue$realm(context.getAcceptDefaultValue());
        proxyState.setExcludeFields$realm(context.getExcludeFields());
    }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b09024;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a09024;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c09024
<<<<<<< MINE
=======
static boolean containsAttribute(FieldAttribute[] attributeList, FieldAttribute attribute) {
        if (attributeList == null || attributeList.length == 0) {
            return false;
        }
        for (FieldAttribute anAttributeList : attributeList) {
            if (anAttributeList == attribute) {
                return true;
            }
        }
        return false;
    }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b09024;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a09024;C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c09024
<<<<<<< MINE
void checkLegalName(String fieldName) {
=======
static void checkLegalName(String fieldName) {
>>>>>>> YOURS
