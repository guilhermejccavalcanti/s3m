20190530_004534,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_b02736
package net.osmand.osm;

import gnu.trove.list.array.TIntArrayList;
import gnu.trove.map.hash.TLongObjectHashMap;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;


public class MapRoutingTypes {

	private static Set<String> TAGS_TO_SAVE = new HashSet<String>();
	private static Set<String> TAGS_TO_ACCEPT = new HashSet<String>();
	private static Set<String> TAGS_TEXT = new HashSet<String>();
	private static char TAG_DELIMETER = '/'; //$NON-NLS-1$
	static {
		TAGS_TO_ACCEPT.add("highway");
		TAGS_TO_ACCEPT.add("junction");
		TAGS_TO_ACCEPT.add("cycleway");
		TAGS_TO_ACCEPT.add("route");
		
		// TEXT tags
		TAGS_TEXT.add("int_ref");
		TAGS_TEXT.add("ref");
		TAGS_TEXT.add("name");
		TAGS_TEXT.add("direction");
		TAGS_TEXT.add("destination");
		TAGS_TEXT.add("destination:lanes");
		TAGS_TEXT.add("duration");
		
		TAGS_TO_SAVE.add("agricultural");
		TAGS_TO_SAVE.add("barrier");
		TAGS_TO_SAVE.add("bicycle");
		TAGS_TO_SAVE.add("boat");
		TAGS_TO_SAVE.add("bridge");
		TAGS_TO_SAVE.add("bus");
		TAGS_TO_SAVE.add("construction");
		TAGS_TO_SAVE.add("direction");
		TAGS_TO_SAVE.add("ferry");
		TAGS_TO_SAVE.add("foot");
		TAGS_TO_SAVE.add("goods");
		TAGS_TO_SAVE.add("hgv");
		TAGS_TO_SAVE.add("horse");
		TAGS_TO_SAVE.add("lanes");
		TAGS_TO_SAVE.add("lanes:forward");
		TAGS_TO_SAVE.add("lanes:backward");
		TAGS_TO_SAVE.add("maxspeed");
		TAGS_TO_SAVE.add("maxweight");
		TAGS_TO_SAVE.add("minspeed");
		TAGS_TO_SAVE.add("moped");
		TAGS_TO_SAVE.add("motorboat");
		TAGS_TO_SAVE.add("motorcar");
		TAGS_TO_SAVE.add("motorcycle");
		TAGS_TO_SAVE.add("motor_vehicle");
		TAGS_TO_SAVE.add("vehicle");
		TAGS_TO_SAVE.add("oneway");
		TAGS_TO_SAVE.add("roundabout");
		TAGS_TO_SAVE.add("route");
		TAGS_TO_SAVE.add("service");
		TAGS_TO_SAVE.add("ship");
		TAGS_TO_SAVE.add("toll");
		TAGS_TO_SAVE.add("toll_booth");
		TAGS_TO_SAVE.add("train");
		TAGS_TO_SAVE.add("tracktype");
		TAGS_TO_SAVE.add("traffic_calming");
		TAGS_TO_SAVE.add("turn:lanes");
		TAGS_TO_SAVE.add("turn");
		TAGS_TO_SAVE.add("tunnel");
		TAGS_TO_SAVE.add("railway");
		
	}
	
	private Map<String, MapRouteType> types = new LinkedHashMap<String, MapRoutingTypes.MapRouteType>();
	private List<MapRouteType> listTypes = new ArrayList<MapRoutingTypes.MapRouteType>(); 
	
	public static String constructRuleKey(String tag, String val) {
		if(val == null || val.length() == 0){
			return tag;
		}
		return tag + TAG_DELIMETER + val;
	}
	
	protected static String getTagKey(String tagValue) {
		int i = tagValue.indexOf(TAG_DELIMETER);
		if(i >= 0){
			return tagValue.substring(0, i);
		}
		return tagValue;
	}
	
	protected static String getValueKey(String tagValue) {
		int i = tagValue.indexOf(TAG_DELIMETER);
		if(i >= 0){
			return tagValue.substring(i + 1);
		}
		return null;
	}
	
	private boolean contains(Set<String> s, String tag, String value) {
		if(s.contains(tag) || s.contains(tag + TAG_DELIMETER + value)){
			return true;
		}
		return false;
	}
	
	
	public boolean encodeEntity(Way et, TIntArrayList outTypes, Map<MapRouteType, String> names){
		Way e = (Way) et;
		boolean init = false;
		for(Entry<String, String> es : e.getTags().entrySet()) {
			String tag = es.getKey();
			String value = es.getValue();
			if (contains(TAGS_TO_ACCEPT, tag, value)) {
				init = true;
				break;
			}
		}
		if(!init) {
			return false;
		}
		outTypes.clear();
		names.clear();
		for(Entry<String, String> es : e.getTags().entrySet()) {
			String tag = es.getKey();
			String value = converBooleanValue(es.getValue());
			if(contains(TAGS_TO_ACCEPT, tag, value) || contains(TAGS_TO_SAVE, tag, value) || tag.startsWith("access")) {
				outTypes.add(registerRule(tag, value).id);
			}
			if(TAGS_TEXT.contains(tag)) {
				names.put(registerRule(tag, null), value);
			}
		}
		return true;
	}
	
	private String converBooleanValue(String value){
		if(value.equals("true")) {
			return "yes";
		} else if(value.equals("false")) {
			return "no";
		}
		return value;
	}
	
	public void encodePointTypes(Way e, TLongObjectHashMap<TIntArrayList> pointTypes){
		pointTypes.clear();
		for(Node nd : e.getNodes() ) {
			if (nd != null) {
				for (Entry<String, String> es : nd.getTags().entrySet()) {
					String tag = es.getKey();
					String value = converBooleanValue(es.getValue());
					if (contains(TAGS_TO_ACCEPT, tag, value) || contains(TAGS_TO_SAVE, tag, value) || tag.startsWith("access")) {
						if (!pointTypes.containsKey(nd.getId())) {
							pointTypes.put(nd.getId(), new TIntArrayList());
						}
						pointTypes.get(nd.getId()).add(registerRule(tag, value).id);
					}
				}
			}
		}
	}
	
	public MapRouteType getTypeByInternalId(int id) {
		return listTypes.get(id - 1);
	}
	
	private MapRouteType registerRule(String tag, String val) {
		String id = constructRuleKey(tag, val);
		if(!types.containsKey(id)) {
			MapRouteType rt = new MapRouteType();
			// first one is always 1
			rt.id = types.size() + 1;
			rt.tag = tag;
			rt.value = val;
			types.put(id, rt);
			listTypes.add(rt);
		}
		MapRouteType type = types.get(id);
		type.freq ++;
		return type;
	}
	
	public static class MapRouteType {
		int freq = 0;
		int id;
		int targetId;
		String tag;
		String value;
		
		public int getInternalId() {
			return id;
		}
		
		public int getFreq() {
			return freq;
		}
		
		public int getTargetId() {
			return targetId;
		}
		
		public String getTag() {
			return tag;
		}
		
		public String getValue() {
			return value;
		}
		
		public void setTargetId(int targetId) {
			this.targetId = targetId;
		}
		
	}

	public List<MapRouteType> getEncodingRuleTypes() {
		return listTypes;
	}
}
!@#$%
20190530_004534,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_a02736
package net.osmand.osm;

import gnu.trove.list.array.TIntArrayList;
import gnu.trove.map.hash.TLongObjectHashMap;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;


public class MapRoutingTypes {

	private static Set<String> TAGS_TO_SAVE = new HashSet<String>();
	private static Set<String> TAGS_TO_ACCEPT = new HashSet<String>();
	private static Set<String> TAGS_TEXT = new HashSet<String>();
	private static char TAG_DELIMETER = '/'; //$NON-NLS-1$
	static {
		TAGS_TO_ACCEPT.add("highway");
		TAGS_TO_ACCEPT.add("junction");
		TAGS_TO_ACCEPT.add("cycleway");
		TAGS_TO_ACCEPT.add("route");
		
		// TEXT tags
		TAGS_TEXT.add("int_ref");
		TAGS_TEXT.add("ref");
		TAGS_TEXT.add("name");
		TAGS_TEXT.add("direction");
		TAGS_TEXT.add("destination");
		TAGS_TEXT.add("destination:lanes");
		TAGS_TEXT.add("duration");
		
		TAGS_TO_SAVE.add("agricultural");
		TAGS_TO_SAVE.add("barrier");
		TAGS_TO_SAVE.add("bicycle");
		TAGS_TO_SAVE.add("boat");
		TAGS_TO_SAVE.add("bridge");
		TAGS_TO_SAVE.add("bus");
		TAGS_TO_SAVE.add("construction");
		TAGS_TO_SAVE.add("direction");
		TAGS_TO_SAVE.add("ferry");
		TAGS_TO_SAVE.add("foot");
		TAGS_TO_SAVE.add("goods");
		TAGS_TO_SAVE.add("hgv");
		TAGS_TO_SAVE.add("horse");
		TAGS_TO_SAVE.add("lanes");
		TAGS_TO_SAVE.add("lanes:forward");
		TAGS_TO_SAVE.add("lanes:backward");
		TAGS_TO_SAVE.add("maxspeed");
		TAGS_TO_SAVE.add("maxweight");
		TAGS_TO_SAVE.add("minspeed");
		TAGS_TO_SAVE.add("moped");
		TAGS_TO_SAVE.add("motorboat");
		TAGS_TO_SAVE.add("motorcar");
		TAGS_TO_SAVE.add("motorcycle");
		TAGS_TO_SAVE.add("motor_vehicle");
		TAGS_TO_SAVE.add("oneway");
		TAGS_TO_SAVE.add("roundabout");
		TAGS_TO_SAVE.add("route");
		TAGS_TO_SAVE.add("service");
		TAGS_TO_SAVE.add("ship");
		TAGS_TO_SAVE.add("toll");
		TAGS_TO_SAVE.add("toll_booth");
		TAGS_TO_SAVE.add("train");
		TAGS_TO_SAVE.add("tracktype");
		TAGS_TO_SAVE.add("traffic_calming");
		TAGS_TO_SAVE.add("turn:lanes");
		TAGS_TO_SAVE.add("turn");
		TAGS_TO_SAVE.add("tunnel");
		TAGS_TO_SAVE.add("railway");
		
	}
	
	private Map<String, MapRouteType> types = new LinkedHashMap<String, MapRoutingTypes.MapRouteType>();
	private List<MapRouteType> listTypes = new ArrayList<MapRoutingTypes.MapRouteType>(); 
	
	public static String constructRuleKey(String tag, String val) {
		if(val == null || val.length() == 0){
			return tag;
		}
		return tag + TAG_DELIMETER + val;
	}
	
	protected static String getTagKey(String tagValue) {
		int i = tagValue.indexOf(TAG_DELIMETER);
		if(i >= 0){
			return tagValue.substring(0, i);
		}
		return tagValue;
	}
	
	protected static String getValueKey(String tagValue) {
		int i = tagValue.indexOf(TAG_DELIMETER);
		if(i >= 0){
			return tagValue.substring(i + 1);
		}
		return null;
	}
	
	private boolean contains(Set<String> s, String tag, String value) {
		if(s.contains(tag) || s.contains(tag + TAG_DELIMETER + value)){
			return true;
		}
		return false;
	}
	
	
	public boolean encodeEntity(Way et, TIntArrayList outTypes, Map<MapRouteType, String> names){
		Way e = (Way) et;
		boolean init = false;
		for(Entry<String, String> es : e.getTags().entrySet()) {
			String tag = es.getKey();
			String value = es.getValue();
			if (contains(TAGS_TO_ACCEPT, tag, value)) {
				init = true;
				break;
			}
		}
		if(!init) {
			return false;
		}
		outTypes.clear();
		names.clear();
		for(Entry<String, String> es : e.getTags().entrySet()) {
			String tag = es.getKey();
			String value = converBooleanValue(es.getValue());
			if(contains(TAGS_TO_ACCEPT, tag, value) || contains(TAGS_TO_SAVE, tag, value) || tag.startsWith("access")) {
				outTypes.add(registerRule(tag, value).id);
			}
			if(TAGS_TEXT.contains(tag)) {
				names.put(registerRule(tag, null), value);
			}
		}
		return true;
	}
	
	private String converBooleanValue(String value){
		if(value.equals("true")) {
			return "yes";
		} else if(value.equals("false")) {
			return "no";
		}
		return value;
	}
	
	public void encodePointTypes(Way e, TLongObjectHashMap<TIntArrayList> pointTypes){
		pointTypes.clear();
		for(Node nd : e.getNodes() ) {
			if (nd != null) {
				for (Entry<String, String> es : nd.getTags().entrySet()) {
					String tag = es.getKey();
					String value = converBooleanValue(es.getValue());
					if (contains(TAGS_TO_ACCEPT, tag, value) || contains(TAGS_TO_SAVE, tag, value) || tag.startsWith("access")) {
						if (!pointTypes.containsKey(nd.getId())) {
							pointTypes.put(nd.getId(), new TIntArrayList());
						}
						pointTypes.get(nd.getId()).add(registerRule(tag, value).id);
					}
				}
			}
		}
	}
	
	public MapRouteType getTypeByInternalId(int id) {
		return listTypes.get(id - 1);
	}
	
	private MapRouteType registerRule(String tag, String val) {
		String id = constructRuleKey(tag, val);
		if(!types.containsKey(id)) {
			MapRouteType rt = new MapRouteType();
			// first one is always 1
			rt.id = types.size() + 1;
			rt.tag = tag;
			rt.value = val;
			types.put(id, rt);
			listTypes.add(rt);
		}
		MapRouteType type = types.get(id);
		type.freq ++;
		return type;
	}
	
	public static class MapRouteType {
		int freq = 0;
		int id;
		int targetId;
		String tag;
		String value;
		
		public int getInternalId() {
			return id;
		}
		
		public int getFreq() {
			return freq;
		}
		
		public int getTargetId() {
			return targetId;
		}
		
		public String getTag() {
			return tag;
		}
		
		public String getValue() {
			return value;
		}
		
		public void setTargetId(int targetId) {
			this.targetId = targetId;
		}
		
	}

	public List<MapRouteType> getEncodingRuleTypes() {
		return listTypes;
	}
}
!@#$%
20190530_004534,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_c02736
package net.osmand.osm;

import gnu.trove.list.array.TIntArrayList;
import gnu.trove.map.hash.TLongObjectHashMap;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;


public class MapRoutingTypes {

	private static Set<String> TAGS_TO_SAVE = new HashSet<String>();
	private static Set<String> TAGS_TO_ACCEPT = new HashSet<String>();
	private static Set<String> TAGS_TEXT = new HashSet<String>();
	private static Set<String> BASE_TAGS_TEXT = new HashSet<String>();
	private static Set<String> BASE_TAGS_TO_SAVE = new HashSet<String>();
	private static char TAG_DELIMETER = '/'; //$NON-NLS-1$
	static {
		TAGS_TO_ACCEPT.add("highway");
		TAGS_TO_ACCEPT.add("junction");
		TAGS_TO_ACCEPT.add("cycleway");
		TAGS_TO_ACCEPT.add("route");
		
		BASE_TAGS_TEXT.add("int_ref");
		BASE_TAGS_TEXT.add("name");
		BASE_TAGS_TEXT.add("ref");
		
		BASE_TAGS_TO_SAVE.add("toll");
		BASE_TAGS_TO_SAVE.add("maxspeed");
		
		// TEXT tags
		TAGS_TEXT.add("int_ref");
		TAGS_TEXT.add("ref");
		TAGS_TEXT.add("name");
		TAGS_TEXT.add("direction");
		TAGS_TEXT.add("destination");
		TAGS_TEXT.add("destination:lanes");
		TAGS_TEXT.add("duration");
		
		TAGS_TO_SAVE.add("agricultural");
		TAGS_TO_SAVE.add("barrier");
		TAGS_TO_SAVE.add("bicycle");
		TAGS_TO_SAVE.add("boat");
		TAGS_TO_SAVE.add("bridge");
		TAGS_TO_SAVE.add("bus");
		TAGS_TO_SAVE.add("construction");
		TAGS_TO_SAVE.add("direction");
		TAGS_TO_SAVE.add("ferry");
		TAGS_TO_SAVE.add("foot");
		TAGS_TO_SAVE.add("goods");
		TAGS_TO_SAVE.add("hgv");
		TAGS_TO_SAVE.add("horse");
		TAGS_TO_SAVE.add("lanes");
		TAGS_TO_SAVE.add("lanes:forward");
		TAGS_TO_SAVE.add("lanes:backward");
		TAGS_TO_SAVE.add("maxspeed");
		TAGS_TO_SAVE.add("maxweight");
		TAGS_TO_SAVE.add("minspeed");
		TAGS_TO_SAVE.add("moped");
		TAGS_TO_SAVE.add("motorboat");
		TAGS_TO_SAVE.add("motorcar");
		TAGS_TO_SAVE.add("motorcycle");
		TAGS_TO_SAVE.add("motor_vehicle");
		TAGS_TO_SAVE.add("vehicle");
		TAGS_TO_SAVE.add("oneway");
		TAGS_TO_SAVE.add("roundabout");
		TAGS_TO_SAVE.add("route");
		TAGS_TO_SAVE.add("service");
		TAGS_TO_SAVE.add("ship");
		TAGS_TO_SAVE.add("toll");
		TAGS_TO_SAVE.add("toll_booth");
		TAGS_TO_SAVE.add("train");
		TAGS_TO_SAVE.add("tracktype");
		TAGS_TO_SAVE.add("traffic_calming");
		TAGS_TO_SAVE.add("turn:lanes");
		TAGS_TO_SAVE.add("turn");
		TAGS_TO_SAVE.add("tunnel");
		TAGS_TO_SAVE.add("railway");
		
	}
	
	private Map<String, MapRouteType> types = new LinkedHashMap<String, MapRoutingTypes.MapRouteType>();
	private List<MapRouteType> listTypes = new ArrayList<MapRoutingTypes.MapRouteType>();
	private MapRouteType refRuleType;
	private MapRouteType nameRuleType; 
	
	public static String constructRuleKey(String tag, String val) {
		if(val == null || val.length() == 0){
			return tag;
		}
		return tag + TAG_DELIMETER + val;
	}
	
	protected static String getTagKey(String tagValue) {
		int i = tagValue.indexOf(TAG_DELIMETER);
		if(i >= 0){
			return tagValue.substring(0, i);
		}
		return tagValue;
	}
	
	protected static String getValueKey(String tagValue) {
		int i = tagValue.indexOf(TAG_DELIMETER);
		if(i >= 0){
			return tagValue.substring(i + 1);
		}
		return null;
	}
	
	public MapRouteType getRefRuleType() {
		return refRuleType;
	}
	
	
	public MapRouteType getNameRuleType() {
		return nameRuleType;
	}
	
	private boolean contains(Set<String> s, String tag, String value) {
		if(s.contains(tag) || s.contains(tag + TAG_DELIMETER + value)){
			return true;
		}
		return false;
	}
	
	
	public boolean encodeEntity(Way et, TIntArrayList outTypes, Map<MapRouteType, String> names){
		Way e = (Way) et;
		boolean init = false;
		for(Entry<String, String> es : e.getTags().entrySet()) {
			String tag = es.getKey();
			String value = es.getValue();
			if (contains(TAGS_TO_ACCEPT, tag, value)) {
				init = true;
				break;
			}
		}
		if(!init) {
			return false;
		}
		outTypes.clear();
		names.clear();
		for(Entry<String, String> es : e.getTags().entrySet()) {
			String tag = es.getKey();
			String value = converBooleanValue(es.getValue());
			if(contains(TAGS_TO_ACCEPT, tag, value) || contains(TAGS_TO_SAVE, tag, value) || tag.startsWith("access")) {
				outTypes.add(registerRule(tag, value).id);
			}
			if(TAGS_TEXT.contains(tag)) {
				names.put(registerRule(tag, null), value);
			}
		}
		return true;
	}
	
	public boolean encodeBaseEntity(Way et, TIntArrayList outTypes, Map<MapRouteType, String> names){
		Way e = (Way) et;
		boolean init = false;
		for(Entry<String, String> es : e.getTags().entrySet()) {
			String tag = es.getKey();
			String value = es.getValue();
			if (contains(TAGS_TO_ACCEPT, tag, value)) {
				if(value.startsWith("trunk") || value.startsWith("motorway")
						|| value.startsWith("primary") || value.startsWith("secondary")
						|| value.startsWith("tertiary")
						|| value.startsWith("ferry")
						) {
					init = true;
					break;
				}
			}
		}
		if(!init) {
			return false;
		}
		outTypes.clear();
		names.clear();
		for(Entry<String, String> es : e.getTags().entrySet()) {
			String tag = es.getKey();
			String value = converBooleanValue(es.getValue());
			if(BASE_TAGS_TEXT.contains(tag)) {
				names.put(registerRule(tag, null), value);
			}
			if(contains(TAGS_TO_ACCEPT, tag, value) ||
					contains(BASE_TAGS_TO_SAVE, tag, value)) {
				outTypes.add(registerRule(tag, value).id);
			}
		}
		return true;
	}
	
	private String converBooleanValue(String value){
		if(value.equals("true")) {
			return "yes";
		} else if(value.equals("false")) {
			return "no";
		}
		return value;
	}
	
	public void encodePointTypes(Way e, TLongObjectHashMap<TIntArrayList> pointTypes){
		pointTypes.clear();
		for(Node nd : e.getNodes() ) {
			if (nd != null) {
				for (Entry<String, String> es : nd.getTags().entrySet()) {
					String tag = es.getKey();
					String value = converBooleanValue(es.getValue());
					if (contains(TAGS_TO_ACCEPT, tag, value) || contains(TAGS_TO_SAVE, tag, value) || tag.startsWith("access")) {
						if (!pointTypes.containsKey(nd.getId())) {
							pointTypes.put(nd.getId(), new TIntArrayList());
						}
						pointTypes.get(nd.getId()).add(registerRule(tag, value).id);
					}
				}
			}
		}
	}
	
	public MapRouteType getTypeByInternalId(int id) {
		return listTypes.get(id - 1);
	}
	
	private MapRouteType registerRule(String tag, String val) {
		String id = constructRuleKey(tag, val);
		if(!types.containsKey(id)) {
			MapRouteType rt = new MapRouteType();
			// first one is always 1
			rt.id = types.size() + 1;
			rt.tag = tag;
			rt.value = val;
			types.put(id, rt);
			listTypes.add(rt);
			if(tag.equals("ref")){
				refRuleType = rt;
			}
			if(tag.equals("name")){
				nameRuleType = rt;
			}
		}
		MapRouteType type = types.get(id);
		type.freq ++;
		return type;
	}
	
	public static class MapRouteType {
		int freq = 0;
		int id;
		int targetId;
		String tag;
		String value;
		
		public int getInternalId() {
			return id;
		}
		
		public int getFreq() {
			return freq;
		}
		
		public int getTargetId() {
			return targetId;
		}
		
		public String getTag() {
			return tag;
		}
		
		public String getValue() {
			return value;
		}
		
		public void setTargetId(int targetId) {
			this.targetId = targetId;
		}
		
		@Override
		public String toString() {
			if (value == null) {
				return "'" + tag + "'";
			}
			return tag + "='" + value + "'";
		}

	}

	public List<MapRouteType> getEncodingRuleTypes() {
		return listTypes;
	}
}
!@#$%
20190530_010518,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_b04640
package net.osmand.plus;

import java.io.BufferedWriter;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintStream;
import java.lang.Thread.UncaughtExceptionHandler;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

import net.osmand.IndexConstants;
import net.osmand.PlatformUtil;
import net.osmand.access.AccessibilityPlugin;
import net.osmand.access.AccessibleAlertBuilder;
import net.osmand.access.AccessibleToast;
import net.osmand.data.FavouritePoint;
import net.osmand.plus.GPXUtilities.GPXFile;
import net.osmand.plus.GPXUtilities.WptPt;
import net.osmand.plus.access.AccessibilityMode;
import net.osmand.plus.activities.DayNightHelper;
import net.osmand.plus.activities.SavingTrackHelper;
import net.osmand.plus.activities.SettingsActivity;
import net.osmand.plus.api.SQLiteAPI;
import net.osmand.plus.api.SQLiteAPIImpl;
import net.osmand.plus.monitoring.LiveMonitoringHelper;
import net.osmand.plus.render.NativeOsmandLibrary;
import net.osmand.plus.render.RendererRegistry;
import net.osmand.plus.resources.ResourceManager;
import net.osmand.plus.routing.RoutingHelper;
import net.osmand.plus.voice.CommandPlayer;
import net.osmand.plus.voice.CommandPlayerException;
import net.osmand.plus.voice.CommandPlayerFactory;
import net.osmand.render.RenderingRulesStorage;
import net.osmand.router.RoutingConfiguration;
import net.osmand.util.Algorithms;

import org.xmlpull.v1.XmlPullParserException;

import android.app.Activity;
import android.app.AlarmManager;
import android.app.AlertDialog;
import android.app.AlertDialog.Builder;
import android.app.Application;
import android.app.PendingIntent;
import android.app.ProgressDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager.NameNotFoundException;
import android.content.res.Configuration;
import android.graphics.Shader.TileMode;
import android.graphics.drawable.BitmapDrawable;
import android.os.Build;
import android.os.Handler;
import android.os.Message;
import android.text.format.DateFormat;
import android.util.TypedValue;
import android.view.accessibility.AccessibilityManager;
import android.widget.CheckBox;
import android.widget.LinearLayout;
import android.widget.ProgressBar;
import android.widget.LinearLayout.LayoutParams;
import android.widget.TextView;
import android.widget.Toast;
import btools.routingapp.BRouterServiceConnection;
import btools.routingapp.IBRouterService;

import com.actionbarsherlock.app.ActionBar;
import com.actionbarsherlock.app.SherlockActivity;
import com.actionbarsherlock.app.SherlockExpandableListActivity;
import com.actionbarsherlock.app.SherlockListActivity;


public class OsmandApplication extends Application {
	public static final String EXCEPTION_PATH = "exception.log"; //$NON-NLS-1$
	private static final org.apache.commons.logging.Log LOG = PlatformUtil.getLog(OsmandApplication.class);

	
	ResourceManager resourceManager = null;
	PoiFiltersHelper poiFilters = null;
	RoutingHelper routingHelper = null;
	FavouritesDbHelper favorites = null;
	CommandPlayer player = null;

	OsmandSettings osmandSettings = null;

	OsmAndAppCustomization appCustomization;
	DayNightHelper daynightHelper;
	NavigationService navigationService;
	RendererRegistry rendererRegistry;
	OsmAndLocationProvider locationProvider;
	OsmAndTaskManager taskManager;

	// start variables
	private ProgressImplementation startDialog;
	private Handler uiHandler;
	private GPXFile gpxFileToDisplay;
	private SavingTrackHelper savingTrackHelper;
	private LiveMonitoringHelper liveMonitoringHelper;
	private TargetPointsHelper targetPointsHelper;
	private RoutingConfiguration.Builder defaultRoutingConfig;

	private boolean applicationInitializing = false;
	private Locale prefferedLocale = null;
	
	SQLiteAPI sqliteAPI;
	BRouterServiceConnection bRouterServiceConnection;

	@Override
	public void onCreate() {
		long timeToStart = System.currentTimeMillis();
		if (Version.getAppName(this).equals("OsmAnd~")) {
			if (android.os.Build.VERSION.SDK_INT >= 9) {
				try {
					Class.forName("net.osmand.plus.base.EnableStrictMode").newInstance();
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		}
		super.onCreate();
		appCustomization = new OsmAndAppCustomization();
		appCustomization.setup(this);
		 
		sqliteAPI = new SQLiteAPIImpl(this);
		try {
			bRouterServiceConnection = BRouterServiceConnection.connect(this);
		} catch(Exception e) {
			e.printStackTrace();
		}

		// settings used everywhere so they need to be created first
		osmandSettings = appCustomization.createSettings(new net.osmand.plus.api.SettingsAPIImpl(this));
		// always update application mode to default
		if(!osmandSettings.FOLLOW_THE_ROUTE.get()){
			osmandSettings.APPLICATION_MODE.set(osmandSettings.DEFAULT_APPLICATION_MODE.get());
		}
		
		applyTheme(this);
		
		routingHelper = new RoutingHelper(this, player);
		taskManager = new OsmAndTaskManager(this);
		resourceManager = new ResourceManager(this);
		daynightHelper = new DayNightHelper(this);
		locationProvider = new OsmAndLocationProvider(this);
		savingTrackHelper = new SavingTrackHelper(this);
		liveMonitoringHelper = new LiveMonitoringHelper(this);
		uiHandler = new Handler();
		rendererRegistry = new RendererRegistry();
		targetPointsHelper = new TargetPointsHelper(this);
//		if(!osmandSettings.FOLLOW_THE_ROUTE.get()) {
//			targetPointsHelper.clearPointToNavigate(false);
//		}
		
		checkPrefferedLocale();
		startApplication();
		if (LOG.isDebugEnabled()) {
			LOG.debug("Time to start application " + (System.currentTimeMillis() - timeToStart) + " ms. Should be less < 800 ms");
		}
		timeToStart = System.currentTimeMillis();
		OsmandPlugin.initPlugins(this);

		if (LOG.isDebugEnabled()) {
			LOG.debug("Time to init plugins " + (System.currentTimeMillis() - timeToStart) + " ms. Should be less < 800 ms");
		}
		
		
	}

	@Override
	public void onTerminate() {
		super.onTerminate();
		if (routingHelper != null) {
			routingHelper.getVoiceRouter().onApplicationTerminate(this);
		}
	}

	public RendererRegistry getRendererRegistry() {
		return rendererRegistry;
	}
	
	public OsmAndTaskManager getTaskManager() {
		return taskManager;
	}

	
	public OsmAndLocationProvider getLocationProvider() {
		return locationProvider;
	}
	
	public OsmAndAppCustomization getAppCustomization() {
		return appCustomization;
	}
	
	public void setAppCustomization(OsmAndAppCustomization appCustomization) {
		this.appCustomization = appCustomization;
		this.appCustomization.setup(this);
	}

	/**
	 * Application settings
	 * 
	 * @return Reference to instance of OsmandSettings
	 */
	public OsmandSettings getSettings() {
		if (osmandSettings == null) {
			LOG.error("Trying to access settings before they were created");
		}
		return osmandSettings;
	}

	public SavingTrackHelper getSavingTrackHelper() {
		return savingTrackHelper;
	}

	public LiveMonitoringHelper getLiveMonitoringHelper() {
		return liveMonitoringHelper;
	}

	public PoiFiltersHelper getPoiFilters() {
		if (poiFilters == null) {
			poiFilters = new PoiFiltersHelper(this);
		}
		return poiFilters;
	}

	public void setGpxFileToDisplay(GPXFile gpxFileToDisplay, boolean showCurrentGpxFile) {
		this.gpxFileToDisplay = gpxFileToDisplay;
		osmandSettings.SHOW_CURRENT_GPX_TRACK.set(showCurrentGpxFile);
		if (gpxFileToDisplay == null) {
			getFavorites().setFavoritePointsFromGPXFile(null);
		} else {
			List<FavouritePoint> pts = new ArrayList<FavouritePoint>();
			for (WptPt p : gpxFileToDisplay.points) {
				FavouritePoint pt = new FavouritePoint();
				pt.setLatitude(p.lat);
				pt.setLongitude(p.lon);
				if (p.name == null) {
					p.name = "";
				}
				pt.setName(p.name);
				pts.add(pt);
			}
			gpxFileToDisplay.proccessPoints();
			getFavorites().setFavoritePointsFromGPXFile(pts);
		}
	}

	public GPXFile getGpxFileToDisplay() {
		return gpxFileToDisplay;
	}

	public FavouritesDbHelper getFavorites() {
		if (favorites == null) {
			favorites = new FavouritesDbHelper(this);
		}
		return favorites;
	}

	public ResourceManager getResourceManager() {
		return resourceManager;
	}

	public DayNightHelper getDaynightHelper() {
		return daynightHelper;
	}

	@Override
	public void onLowMemory() {
		super.onLowMemory();
		resourceManager.onLowMemory();
	}

	@Override
	public void onConfigurationChanged(Configuration newConfig) {
		if (prefferedLocale != null && !newConfig.locale.getLanguage().equals(prefferedLocale.getLanguage())) {
			super.onConfigurationChanged(newConfig);
			// ugly fix ! On devices after 4.0 screen is blinking when you rotate device!
			if (Build.VERSION.SDK_INT < 14) {
				newConfig.locale = prefferedLocale;
			}
			getBaseContext().getResources().updateConfiguration(newConfig, getBaseContext().getResources().getDisplayMetrics());
			Locale.setDefault(prefferedLocale);
		} else {
			super.onConfigurationChanged(newConfig);
		}
	}

	public void checkPrefferedLocale() {
		Configuration config = getBaseContext().getResources().getConfiguration();
		String lang = osmandSettings.PREFERRED_LOCALE.get();
		if (!"".equals(lang) && !config.locale.getLanguage().equals(lang)) {
			prefferedLocale = new Locale(lang);
			Locale.setDefault(prefferedLocale);
			config.locale = prefferedLocale;
			getBaseContext().getResources().updateConfiguration(config, getBaseContext().getResources().getDisplayMetrics());
		}
		String clang = "".equals(lang) ? config.locale.getLanguage() : lang;
		resourceManager.getOsmandRegions().setLocale(clang);

	}

	public static final int PROGRESS_DIALOG = 5;

	public void checkApplicationIsBeingInitialized(Activity activity, ProgressDialog progressDialog) {
		// start application if it was previously closed
		startApplication();
		synchronized (OsmandApplication.this) {
			if (startDialog != null) {
				progressDialog.setTitle(getString(R.string.loading_data));
				progressDialog.setMessage(getString(R.string.reading_indexes));
				activity.showDialog(PROGRESS_DIALOG);
				startDialog.setDialog(progressDialog);
			} else {
				progressDialog.dismiss();
			}
		}
	}
	
	public void checkApplicationIsBeingInitialized(Activity activity, TextView tv, ProgressBar progressBar,
			Runnable onClose) {
		// start application if it was previously closed
		startApplication();
		synchronized (OsmandApplication.this) {
			if (startDialog != null ) {
				tv.setText(getString(R.string.loading_data));
				startDialog.setProgressBar(tv, progressBar, onClose);
			} else if (onClose != null) {
				onClose.run();
			}
		}
	}

	public boolean isApplicationInitializing() {
		return startDialog != null;
	}

	public RoutingHelper getRoutingHelper() {
		return routingHelper;
	}

	public CommandPlayer getPlayer() {
		return player;
	}

	public void initVoiceCommandPlayer(final Activity uiContext) {
		showDialogInitializingCommandPlayer(uiContext, true, null, false);
	}

	public void showDialogInitializingCommandPlayer(final Activity uiContext, boolean warningNoneProvider) {
		showDialogInitializingCommandPlayer(uiContext, warningNoneProvider, null, true);
	}

	public void showDialogInitializingCommandPlayer(final Activity uiContext, boolean warningNoneProvider, Runnable run, boolean showDialog) {
		String voiceProvider = osmandSettings.VOICE_PROVIDER.get();
		if (voiceProvider == null || OsmandSettings.VOICE_PROVIDER_NOT_USE.equals(voiceProvider)) {
			if (warningNoneProvider && voiceProvider == null) {
				Builder builder = new AccessibleAlertBuilder(uiContext);
				LinearLayout ll = new LinearLayout(uiContext);
				ll.setOrientation(LinearLayout.VERTICAL);
				final TextView tv = new TextView(uiContext);
				tv.setPadding(7, 3, 7, 0);
				tv.setText(R.string.voice_is_not_available_msg);
				tv.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 19);
				ll.addView(tv);
				
				final CheckBox cb = new CheckBox(uiContext);
				cb.setText(R.string.remember_choice);
				LinearLayout.LayoutParams lp = new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);
				lp.setMargins(7, 10, 7, 0);
				cb.setLayoutParams(lp);
				ll.addView(cb);
				
				builder.setCancelable(true);
				builder.setNegativeButton(R.string.default_buttons_cancel, new DialogInterface.OnClickListener() {
					@Override
					public void onClick(DialogInterface dialog, int which) {
						if(cb.isChecked()) {
							osmandSettings.VOICE_PROVIDER.set(OsmandSettings.VOICE_PROVIDER_NOT_USE);
						}
					}
				});
				builder.setPositiveButton(R.string.default_buttons_ok, new DialogInterface.OnClickListener() {
					@Override
					public void onClick(DialogInterface dialog, int which) {
						Intent intent = new Intent(uiContext, SettingsActivity.class);
						intent.putExtra(SettingsActivity.INTENT_KEY_SETTINGS_SCREEN, SettingsActivity.SCREEN_GENERAL_SETTINGS);
						uiContext.startActivity(intent);
					}
				});
				
				
				builder.setTitle(R.string.voice_is_not_available_title);
				builder.setView(ll);
				//builder.setMessage(R.string.voice_is_not_available_msg);
				builder.show();
			}

		} else {
			if (player == null || !Algorithms.objectEquals(voiceProvider, player.getCurrentVoice())) {
				initVoiceDataInDifferentThread(uiContext, voiceProvider, run, showDialog);
			}
		}

	}

	private void initVoiceDataInDifferentThread(final Activity uiContext, final String voiceProvider, final Runnable run, boolean showDialog) {
		final ProgressDialog dlg = showDialog ? ProgressDialog.show(uiContext, getString(R.string.loading_data),
				getString(R.string.voice_data_initializing)) : null;
		new Thread(new Runnable() {
			@Override
			public void run() {
				try {
					if (player != null) {
						player.clear();
					}
					player = CommandPlayerFactory.createCommandPlayer(voiceProvider, OsmandApplication.this, uiContext);
					routingHelper.getVoiceRouter().setPlayer(player);
					if(dlg != null) {
						dlg.dismiss();
					}
					if (run != null && uiContext != null) {
						uiContext.runOnUiThread(run);
					}
				} catch (CommandPlayerException e) {
					if(dlg != null) {
						dlg.dismiss();
					}
					showToastMessage(e.getError());
				}
			}
		}).start();
	}

	public NavigationService getNavigationService() {
		return navigationService;
	}

	public void setNavigationService(NavigationService navigationService) {
		this.navigationService = navigationService;
	}


	private void fullExit() {
		// http://stackoverflow.com/questions/2092951/how-to-close-android-application
		System.runFinalizersOnExit(true);
		System.exit(0);
	}

	public synchronized void closeApplication(final Activity activity) {
		if (getNavigationService() != null) {
			Builder bld = new AlertDialog.Builder(activity);
			bld.setMessage(R.string.background_service_is_enabled_question);
			bld.setPositiveButton(R.string.default_buttons_yes, new DialogInterface.OnClickListener() {
				@Override
				public void onClick(DialogInterface dialog, int which) {
					closeApplicationAnyway(activity, true);
				}
			});
			bld.setNegativeButton(R.string.default_buttons_no, new DialogInterface.OnClickListener() {
				@Override
				public void onClick(DialogInterface dialog, int which) {
					closeApplicationAnyway(activity, false);
				}
			});
			bld.show();
		} else {
			closeApplicationAnyway(activity, true);
		}
	}

	private void closeApplicationAnyway(final Activity activity, boolean disableService) {
		if (applicationInitializing) {
			resourceManager.close();
		}
		applicationInitializing = false;

		activity.finish();

		if (getNavigationService() == null) {
			fullExit();
		}
		else if (disableService) {
			final Intent serviceIntent = new Intent(this, NavigationService.class);
			stopService(serviceIntent);

			new Thread(new Runnable() {
				public void run() {
					//wait until the service has fully stopped
					while (getNavigationService() != null) {
						try {
							Thread.sleep(100);
						}
							catch (InterruptedException e) {
						}
					}

					fullExit();
				}
			}).start();
		}
	}

	public synchronized void startApplication() {
		if (applicationInitializing) {
			return;
		}
		applicationInitializing = true;
		startDialog = new ProgressImplementation(this, null, false);

		startDialog.setRunnable("Initializing app", new Runnable() { //$NON-NLS-1$
					@Override
					public void run() {
						startApplicationBackground();
					}
				});
		startDialog.run();

		Thread.setDefaultUncaughtExceptionHandler(new DefaultExceptionHandler());

	}

	private void startApplicationBackground() {
		List<String> warnings = new ArrayList<String>();
		try {
			try {
				SpecialPhrases.setLanguage(this, osmandSettings);
			} catch (IOException e) {
				LOG.error("I/O exception", e);
				warnings.add("Error while reading the special phrases. Restart OsmAnd if possible");
			}
			if (!Version.isBlackberry(this)) {
				if (osmandSettings.NATIVE_RENDERING_FAILED.get()) {
					osmandSettings.SAFE_MODE.set(true);
					osmandSettings.NATIVE_RENDERING_FAILED.set(false);
					warnings.add(getString(R.string.native_library_not_supported));
				} else {
					osmandSettings.SAFE_MODE.set(false);
					osmandSettings.NATIVE_RENDERING_FAILED.set(true);
					startDialog.startTask(getString(R.string.init_native_library), -1);
					RenderingRulesStorage storage = rendererRegistry.getCurrentSelectedRenderer();
					boolean initialized = NativeOsmandLibrary.getLibrary(storage, this) != null;
					osmandSettings.NATIVE_RENDERING_FAILED.set(false);
					if (!initialized) {
						LOG.info("Native library could not be loaded!");
					}
				}
			}
			warnings.addAll(resourceManager.reloadIndexes(startDialog));
			player = null;
			if (savingTrackHelper.hasDataToSave()) {
				startDialog.startTask(getString(R.string.saving_gpx_tracks), -1);
				try {
					warnings.addAll(savingTrackHelper.saveDataToGpx());
				} catch (RuntimeException e) {
					warnings.add(e.getMessage());
				}
			}

			// restore backuped favorites to normal file
			final File appDir = getAppPath(null);
			File save = new File(appDir, FavouritesDbHelper.FILE_TO_SAVE);
			File bak = new File(appDir, FavouritesDbHelper.FILE_TO_BACKUP);
			if (bak.exists() && (!save.exists() || bak.lastModified() > save.lastModified())) {
				if (save.exists()) {
					save.delete();
				}
				bak.renameTo(save);
			}
		} catch (RuntimeException e) {
			e.printStackTrace();
			warnings.add(e.getMessage());
		} finally {
			synchronized (OsmandApplication.this) {
				final ProgressDialog toDismiss;
				final Runnable pb;
				if (startDialog != null) {
					toDismiss = startDialog.getDialog();
					pb = startDialog.getFinishRunnable();
				} else {
					toDismiss = null;
					pb = null;
				}
				startDialog = null;

				if (toDismiss != null || pb != null) {
					uiHandler.post(new Runnable() {
						@Override
						public void run() {
							if(pb != null) {
								pb.run();
							}
							if (toDismiss != null) {
								// TODO handling this dialog is bad, we need a better standard way
								toDismiss.dismiss();
								// toDismiss.getOwnerActivity().dismissDialog(PROGRESS_DIALOG);
							}
						}
					});
				}
				if (warnings != null && !warnings.isEmpty()) {
					showToastMessage(formatWarnings(warnings).toString());
				}
			}
		}
	}

	private StringBuilder formatWarnings(List<String> warnings) {
		final StringBuilder b = new StringBuilder();
		boolean f = true;
		for (String w : warnings) {
			if (f) {
				f = false;
			} else {
				b.append('\n');
			}
			b.append(w);
		}
		return b;
	}


	private class DefaultExceptionHandler implements UncaughtExceptionHandler {

		private UncaughtExceptionHandler defaultHandler;
		private PendingIntent intent;

		public DefaultExceptionHandler() {
			defaultHandler = Thread.getDefaultUncaughtExceptionHandler();
			intent = PendingIntent.getActivity(OsmandApplication.this.getBaseContext(), 0,
					new Intent(OsmandApplication.this.getBaseContext(),
							getAppCustomization().getMainMenuActivity()), 0);
		}

		@Override
		public void uncaughtException(final Thread thread, final Throwable ex) {
			File file = getAppPath(EXCEPTION_PATH);
			try {
				ByteArrayOutputStream out = new ByteArrayOutputStream();
				PrintStream printStream = new PrintStream(out);
				ex.printStackTrace(printStream);
				StringBuilder msg = new StringBuilder();
				msg.append("Version  " + Version.getFullVersion(OsmandApplication.this) + "\n"). //$NON-NLS-1$ 
						append(DateFormat.format("dd.MM.yyyy h:mm:ss", System.currentTimeMillis()));
				try {
					PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), 0);
					if (info != null) {
						msg.append("\nApk Version : ").append(info.versionName).append(" ").append(info.versionCode); //$NON-NLS-1$ //$NON-NLS-2$
					}
				} catch (Throwable e) {
				}
				msg.append("\n"). //$NON-NLS-1$//$NON-NLS-2$
						append("Exception occured in thread " + thread.toString() + " : \n"). //$NON-NLS-1$ //$NON-NLS-2$
						append(new String(out.toByteArray()));

				if (file.getParentFile().canWrite()) {
					BufferedWriter writer = new BufferedWriter(new FileWriter(file, true));
					writer.write(msg.toString());
					writer.close();
				}
				if (routingHelper.isFollowingMode()) {
					AlarmManager mgr = (AlarmManager) getSystemService(Context.ALARM_SERVICE);
					mgr.set(AlarmManager.RTC, System.currentTimeMillis() + 2000, intent);
					System.exit(2);
				}
				defaultHandler.uncaughtException(thread, ex);
			} catch (Exception e) {
				// swallow all exceptions
				android.util.Log.e(PlatformUtil.TAG, "Exception while handle other exception", e); //$NON-NLS-1$
			}

		}
	}

	
	public TargetPointsHelper getTargetPointsHelper() {
		return targetPointsHelper;
	}
	
	public void showShortToastMessage(int msgId, Object... args) {
		AccessibleToast.makeText(this, getString(msgId, args), Toast.LENGTH_SHORT).show();
	}

	public void showToastMessage(int msgId, Object... args) {
		AccessibleToast.makeText(this, getString(msgId, args), Toast.LENGTH_LONG).show();
	}

	public void showToastMessage(String msg) {
		AccessibleToast.makeText(this, msg, Toast.LENGTH_LONG).show();
	}
	
	public SQLiteAPI getSQLiteAPI() {
		return sqliteAPI;
	}

	public void runInUIThread(Runnable run) {
		uiHandler.post(run);
	}

	public void runInUIThread(Runnable run, long delay) {
		uiHandler.postDelayed(run, delay);
	}
	
	public void runMessageInUIThreadAndCancelPrevious(final int messageId, final Runnable run, long delay) {
		Message msg = Message.obtain(uiHandler, new Runnable() {
			
			@Override
			public void run() {
				if(!uiHandler.hasMessages(messageId)) {
					run.run();
				}
			}
		});
		msg.what = messageId;
		uiHandler.removeMessages(messageId);
		uiHandler.sendMessageDelayed(msg, delay);
	}
	
	public File getAppPath(String path) {
		if(path == null) {
			path = "";
		}
		return new File(getSettings().getExternalStorageDirectory(), IndexConstants.APP_DIR + path);
	}

	public void applyTheme(Context c) {
		int t = R.style.OsmandLightDarkActionBarTheme;
		if (osmandSettings.OSMAND_THEME.get() == OsmandSettings.OSMAND_DARK_THEME) {
			t = R.style.OsmandDarkTheme;
		} else if (osmandSettings.OSMAND_THEME.get() == OsmandSettings.OSMAND_LIGHT_THEME) {
			t = R.style.OsmandLightTheme;
		} else if (osmandSettings.OSMAND_THEME.get() == OsmandSettings.OSMAND_LIGHT_DARK_ACTIONBAR_THEME) {
			t = R.style.OsmandLightDarkActionBarTheme;
		}
		setLanguage(c);
		c.setTheme(t);
		if (osmandSettings.OSMAND_THEME.get() == OsmandSettings.OSMAND_LIGHT_DARK_ACTIONBAR_THEME
				&& Build.VERSION.SDK_INT < Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
			ActionBar ab = null;
			if (c instanceof SherlockActivity) {
				ab = ((SherlockActivity) c).getSupportActionBar();
			} else if (c instanceof SherlockListActivity) {
				ab = ((SherlockListActivity) c).getSupportActionBar();
			} else if (c instanceof SherlockExpandableListActivity) {
				ab = ((SherlockExpandableListActivity) c).getSupportActionBar();
			}
			if (ab != null) {
				BitmapDrawable bg = (BitmapDrawable) getResources().getDrawable(R.drawable.bg_striped);
				bg.setTileModeXY(TileMode.REPEAT, TileMode.REPEAT);
				ab.setBackgroundDrawable(bg);
			}
		}
	}
	
	public IBRouterService getBRouterService() {
		if(bRouterServiceConnection == null) {
			return null;
		}
		return bRouterServiceConnection.getBrouterService();
	}
	
	public void setLanguage(Context context) {
		if (prefferedLocale != null) {
			Configuration config = context.getResources().getConfiguration();
			String lang = prefferedLocale.getLanguage();
			if (!"".equals(lang) && !config.locale.getLanguage().equals(lang)) {
				prefferedLocale = new Locale(lang);
				Locale.setDefault(prefferedLocale);
				config.locale = prefferedLocale;
				context.getResources().updateConfiguration(config, context.getResources().getDisplayMetrics());
			}
		}
	}
	
	public RoutingConfiguration.Builder getDefaultRoutingConfig() {
		if (defaultRoutingConfig == null) {
			File routingXml = getAppPath(IndexConstants.ROUTING_XML_FILE);
			if (routingXml.exists() && routingXml.canRead()) {
				try {
					defaultRoutingConfig = RoutingConfiguration.parseFromInputStream(new FileInputStream(routingXml));
				} catch (XmlPullParserException e) {
					throw new IllegalStateException(e);
				} catch (IOException e) {
					throw new IllegalStateException(e);
				}
			} else {
				defaultRoutingConfig = RoutingConfiguration.getDefault();
			}
		}
		return defaultRoutingConfig;
	}
	
	public boolean accessibilityExtensions() {
		return (Build.VERSION.SDK_INT < 14) ? getSettings().ACCESSIBILITY_EXTENSIONS.get() : false;
	}
	
	public boolean accessibilityEnabled() {
		final AccessibilityMode mode = getSettings().ACCESSIBILITY_MODE.get();
		if(OsmandPlugin.getEnabledPlugin(AccessibilityPlugin.class) == null) {
			return false;
		}
		if (mode == AccessibilityMode.ON) {
			return true;
		} else if (mode == AccessibilityMode.OFF) {
			return false;
		}
		return ((AccessibilityManager) getSystemService(Context.ACCESSIBILITY_SERVICE)).isEnabled();
	}

	public String getVersionName() {
		try {
			PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), 0);
			return info.versionName;
		} catch (NameNotFoundException e) {
			return "";
		}
	}

	public int getVersionCode() {
		try {
			PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), 0);
			return info.versionCode;
		} catch (NameNotFoundException e) {
			return 0;
		}
	}

	public void startNavigationService(int intent) {
		final Intent serviceIntent = new Intent(this, NavigationService.class);
		serviceIntent.putExtra(NavigationService.USAGE_INTENT, intent);
		if (getNavigationService() == null) {
			getSettings().SERVICE_OFF_INTERVAL.set(0);
			startService(serviceIntent);
		} else {
			getNavigationService().addUsageIntent(intent);
		}		
	}
}
!@#$%
20190530_010518,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_a04640
package net.osmand.plus;

import java.io.BufferedWriter;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintStream;
import java.lang.Thread.UncaughtExceptionHandler;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

import net.osmand.IndexConstants;
import net.osmand.PlatformUtil;
import net.osmand.access.AccessibilityPlugin;
import net.osmand.access.AccessibleAlertBuilder;
import net.osmand.access.AccessibleToast;
import net.osmand.data.FavouritePoint;
import net.osmand.plus.GPXUtilities.GPXFile;
import net.osmand.plus.GPXUtilities.WptPt;
import net.osmand.plus.access.AccessibilityMode;
import net.osmand.plus.activities.DayNightHelper;
import net.osmand.plus.activities.SavingTrackHelper;
import net.osmand.plus.activities.SettingsActivity;
import net.osmand.plus.api.SQLiteAPI;
import net.osmand.plus.api.SQLiteAPIImpl;
import net.osmand.plus.monitoring.LiveMonitoringHelper;
import net.osmand.plus.render.NativeOsmandLibrary;
import net.osmand.plus.render.RendererRegistry;
import net.osmand.plus.resources.ResourceManager;
import net.osmand.plus.routing.RoutingHelper;
import net.osmand.plus.voice.CommandPlayer;
import net.osmand.plus.voice.CommandPlayerException;
import net.osmand.plus.voice.CommandPlayerFactory;
import net.osmand.render.RenderingRulesStorage;
import net.osmand.router.RoutingConfiguration;
import net.osmand.util.Algorithms;

import org.xmlpull.v1.XmlPullParserException;

import android.app.Activity;
import android.app.AlarmManager;
import android.app.AlertDialog;
import android.app.AlertDialog.Builder;
import android.app.Application;
import android.app.PendingIntent;
import android.app.ProgressDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager.NameNotFoundException;
import android.content.res.Configuration;
import android.graphics.Shader.TileMode;
import android.graphics.drawable.BitmapDrawable;
import android.os.Build;
import android.os.Handler;
import android.os.Message;
import android.text.format.DateFormat;
import android.util.TypedValue;
import android.view.accessibility.AccessibilityManager;
import android.widget.CheckBox;
import android.widget.LinearLayout;
import android.widget.ProgressBar;
import android.widget.LinearLayout.LayoutParams;
import android.widget.TextView;
import android.widget.Toast;
import btools.routingapp.BRouterServiceConnection;
import btools.routingapp.IBRouterService;

import com.actionbarsherlock.app.ActionBar;
import com.actionbarsherlock.app.SherlockActivity;
import com.actionbarsherlock.app.SherlockExpandableListActivity;
import com.actionbarsherlock.app.SherlockListActivity;


public class OsmandApplication extends Application {
	public static final String EXCEPTION_PATH = "exception.log"; //$NON-NLS-1$
	private static final org.apache.commons.logging.Log LOG = PlatformUtil.getLog(OsmandApplication.class);

	
	ResourceManager resourceManager = null;
	PoiFiltersHelper poiFilters = null;
	RoutingHelper routingHelper = null;
	FavouritesDbHelper favorites = null;
	CommandPlayer player = null;

	OsmandSettings osmandSettings = null;

	OsmAndAppCustomization appCustomization;
	DayNightHelper daynightHelper;
	NavigationService navigationService;
	RendererRegistry rendererRegistry;
	OsmAndLocationProvider locationProvider;
	OsmAndTaskManager taskManager;

	// start variables
	private ProgressImplementation startDialog;
	private Handler uiHandler;
	private GPXFile gpxFileToDisplay;
	private SavingTrackHelper savingTrackHelper;
	private LiveMonitoringHelper liveMonitoringHelper;
	private TargetPointsHelper targetPointsHelper;
	private RoutingConfiguration.Builder defaultRoutingConfig;

	private boolean applicationInitializing = false;
	private Locale prefferedLocale = null;
	
	SQLiteAPI sqliteAPI;
	BRouterServiceConnection bRouterServiceConnection;

	@Override
	public void onCreate() {
		long timeToStart = System.currentTimeMillis();
		if (Version.getAppName(this).equals("OsmAnd~")) {
			if (android.os.Build.VERSION.SDK_INT >= 9) {
				try {
					Class.forName("net.osmand.plus.base.EnableStrictMode").newInstance();
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		}
		super.onCreate();
		appCustomization = new OsmAndAppCustomization();
		appCustomization.setup(this);
		 
		sqliteAPI = new SQLiteAPIImpl(this);
		try {
			bRouterServiceConnection = BRouterServiceConnection.connect(this);
		} catch(Exception e) {
			e.printStackTrace();
		}

		// settings used everywhere so they need to be created first
		osmandSettings = appCustomization.createSettings(new net.osmand.plus.api.SettingsAPIImpl(this));
		// always update application mode to default
		if(!osmandSettings.FOLLOW_THE_ROUTE.get()){
			osmandSettings.APPLICATION_MODE.set(osmandSettings.DEFAULT_APPLICATION_MODE.get());
		}
		
		applyTheme(this);
		
		routingHelper = new RoutingHelper(this, player);
		taskManager = new OsmAndTaskManager(this);
		resourceManager = new ResourceManager(this);
		daynightHelper = new DayNightHelper(this);
		locationProvider = new OsmAndLocationProvider(this);
		savingTrackHelper = new SavingTrackHelper(this);
		liveMonitoringHelper = new LiveMonitoringHelper(this);
		uiHandler = new Handler();
		rendererRegistry = new RendererRegistry();
		targetPointsHelper = new TargetPointsHelper(this);
//		if(!osmandSettings.FOLLOW_THE_ROUTE.get()) {
//			targetPointsHelper.clearPointToNavigate(false);
//		}
		
		checkPrefferedLocale();
		startApplication();
		if (LOG.isDebugEnabled()) {
			LOG.debug("Time to start application " + (System.currentTimeMillis() - timeToStart) + " ms. Should be less < 800 ms");
		}
		timeToStart = System.currentTimeMillis();
		OsmandPlugin.initPlugins(this);

		if (LOG.isDebugEnabled()) {
			LOG.debug("Time to init plugins " + (System.currentTimeMillis() - timeToStart) + " ms. Should be less < 800 ms");
		}
		
		
	}

	@Override
	public void onTerminate() {
		super.onTerminate();
		if (routingHelper != null) {
			routingHelper.getVoiceRouter().onApplicationTerminate(this);
		}
	}

	public RendererRegistry getRendererRegistry() {
		return rendererRegistry;
	}
	
	public OsmAndTaskManager getTaskManager() {
		return taskManager;
	}

	
	public OsmAndLocationProvider getLocationProvider() {
		return locationProvider;
	}
	
	public OsmAndAppCustomization getAppCustomization() {
		return appCustomization;
	}
	
	public void setAppCustomization(OsmAndAppCustomization appCustomization) {
		this.appCustomization = appCustomization;
		this.appCustomization.setup(this);
	}

	/**
	 * Application settings
	 * 
	 * @return Reference to instance of OsmandSettings
	 */
	public OsmandSettings getSettings() {
		if (osmandSettings == null) {
			LOG.error("Trying to access settings before they were created");
		}
		return osmandSettings;
	}

	public SavingTrackHelper getSavingTrackHelper() {
		return savingTrackHelper;
	}

	public LiveMonitoringHelper getLiveMonitoringHelper() {
		return liveMonitoringHelper;
	}

	public PoiFiltersHelper getPoiFilters() {
		if (poiFilters == null) {
			poiFilters = new PoiFiltersHelper(this);
		}
		return poiFilters;
	}

	public void setGpxFileToDisplay(GPXFile gpxFileToDisplay, boolean showCurrentGpxFile) {
		this.gpxFileToDisplay = gpxFileToDisplay;
		osmandSettings.SHOW_CURRENT_GPX_TRACK.set(showCurrentGpxFile);
		if (gpxFileToDisplay == null) {
			getFavorites().setFavoritePointsFromGPXFile(null);
		} else {
			List<FavouritePoint> pts = new ArrayList<FavouritePoint>();
			for (WptPt p : gpxFileToDisplay.points) {
				FavouritePoint pt = new FavouritePoint();
				pt.setLatitude(p.lat);
				pt.setLongitude(p.lon);
				if (p.name == null) {
					p.name = "";
				}
				pt.setName(p.name);
				pts.add(pt);
			}
			gpxFileToDisplay.proccessPoints();
			getFavorites().setFavoritePointsFromGPXFile(pts);
		}
	}

	public GPXFile getGpxFileToDisplay() {
		return gpxFileToDisplay;
	}

	public FavouritesDbHelper getFavorites() {
		if (favorites == null) {
			favorites = new FavouritesDbHelper(this);
		}
		return favorites;
	}

	public ResourceManager getResourceManager() {
		return resourceManager;
	}

	public DayNightHelper getDaynightHelper() {
		return daynightHelper;
	}

	@Override
	public void onLowMemory() {
		super.onLowMemory();
		resourceManager.onLowMemory();
	}

	@Override
	public void onConfigurationChanged(Configuration newConfig) {
		if (prefferedLocale != null && !newConfig.locale.getLanguage().equals(prefferedLocale.getLanguage())) {
			super.onConfigurationChanged(newConfig);
			// ugly fix ! On devices after 4.0 screen is blinking when you rotate device!
			if (Build.VERSION.SDK_INT < 14) {
				newConfig.locale = prefferedLocale;
			}
			getBaseContext().getResources().updateConfiguration(newConfig, getBaseContext().getResources().getDisplayMetrics());
			Locale.setDefault(prefferedLocale);
		} else {
			super.onConfigurationChanged(newConfig);
		}
	}

	public void checkPrefferedLocale() {
		Configuration config = getBaseContext().getResources().getConfiguration();
		String lang = osmandSettings.PREFERRED_LOCALE.get();
		if (!"".equals(lang) && !config.locale.getLanguage().equals(lang)) {
			prefferedLocale = new Locale(lang);
			Locale.setDefault(prefferedLocale);
			config.locale = prefferedLocale;
			getBaseContext().getResources().updateConfiguration(config, getBaseContext().getResources().getDisplayMetrics());
		}
		String clang = "".equals(lang) ? config.locale.getLanguage() : lang;
		resourceManager.getOsmandRegions().setLocale(clang);

	}

	public static final int PROGRESS_DIALOG = 5;

	public void checkApplicationIsBeingInitialized(Activity activity, ProgressDialog progressDialog) {
		// start application if it was previously closed
		startApplication();
		synchronized (OsmandApplication.this) {
			if (startDialog != null) {
				progressDialog.setTitle(getString(R.string.loading_data));
				progressDialog.setMessage(getString(R.string.reading_indexes));
				activity.showDialog(PROGRESS_DIALOG);
				startDialog.setDialog(progressDialog);
			} else {
				progressDialog.dismiss();
			}
		}
	}
	
	public void checkApplicationIsBeingInitialized(Activity activity, TextView tv, ProgressBar progressBar,
			Runnable onClose) {
		// start application if it was previously closed
		startApplication();
		synchronized (OsmandApplication.this) {
			if (startDialog != null ) {
				tv.setText(getString(R.string.loading_data));
				startDialog.setProgressBar(tv, progressBar, onClose);
			} else if (onClose != null) {
				onClose.run();
			}
		}
	}

	public boolean isApplicationInitializing() {
		return startDialog != null;
	}

	public RoutingHelper getRoutingHelper() {
		return routingHelper;
	}

	public CommandPlayer getPlayer() {
		return player;
	}

	public void initVoiceCommandPlayer(final Activity uiContext) {
		showDialogInitializingCommandPlayer(uiContext, true, null, false);
	}

	public void showDialogInitializingCommandPlayer(final Activity uiContext, boolean warningNoneProvider) {
		showDialogInitializingCommandPlayer(uiContext, warningNoneProvider, null, true);
	}

	public void showDialogInitializingCommandPlayer(final Activity uiContext, boolean warningNoneProvider, Runnable run, boolean showDialog) {
		String voiceProvider = osmandSettings.VOICE_PROVIDER.get();
		if (voiceProvider == null || OsmandSettings.VOICE_PROVIDER_NOT_USE.equals(voiceProvider)) {
			if (warningNoneProvider && voiceProvider == null) {
				Builder builder = new AccessibleAlertBuilder(uiContext);
				LinearLayout ll = new LinearLayout(uiContext);
				ll.setOrientation(LinearLayout.VERTICAL);
				final TextView tv = new TextView(uiContext);
				tv.setPadding(7, 3, 7, 0);
				tv.setText(R.string.voice_is_not_available_msg);
				tv.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 19);
				ll.addView(tv);
				
				final CheckBox cb = new CheckBox(uiContext);
				cb.setText(R.string.remember_choice);
				LinearLayout.LayoutParams lp = new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);
				lp.setMargins(7, 10, 7, 0);
				cb.setLayoutParams(lp);
				ll.addView(cb);
				
				builder.setCancelable(true);
				builder.setNegativeButton(R.string.default_buttons_cancel, new DialogInterface.OnClickListener() {
					@Override
					public void onClick(DialogInterface dialog, int which) {
						if(cb.isChecked()) {
							osmandSettings.VOICE_PROVIDER.set(OsmandSettings.VOICE_PROVIDER_NOT_USE);
						}
					}
				});
				builder.setPositiveButton(R.string.default_buttons_ok, new DialogInterface.OnClickListener() {
					@Override
					public void onClick(DialogInterface dialog, int which) {
						Intent intent = new Intent(uiContext, SettingsActivity.class);
						intent.putExtra(SettingsActivity.INTENT_KEY_SETTINGS_SCREEN, SettingsActivity.SCREEN_GENERAL_SETTINGS);
						uiContext.startActivity(intent);
					}
				});
				
				
				builder.setTitle(R.string.voice_is_not_available_title);
				builder.setView(ll);
				//builder.setMessage(R.string.voice_is_not_available_msg);
				builder.show();
			}

		} else {
			if (player == null || !Algorithms.objectEquals(voiceProvider, player.getCurrentVoice())) {
				initVoiceDataInDifferentThread(uiContext, voiceProvider, run, showDialog);
			}
		}

	}

	private void initVoiceDataInDifferentThread(final Activity uiContext, final String voiceProvider, final Runnable run, boolean showDialog) {
		final ProgressDialog dlg = showDialog ? ProgressDialog.show(uiContext, getString(R.string.loading_data),
				getString(R.string.voice_data_initializing)) : null;
		new Thread(new Runnable() {
			@Override
			public void run() {
				try {
					if (player != null) {
						player.clear();
					}
					player = CommandPlayerFactory.createCommandPlayer(voiceProvider, OsmandApplication.this, uiContext);
					routingHelper.getVoiceRouter().setPlayer(player);
					if(dlg != null) {
						dlg.dismiss();
					}
					if (run != null && uiContext != null) {
						uiContext.runOnUiThread(run);
					}
				} catch (CommandPlayerException e) {
					if(dlg != null) {
						dlg.dismiss();
					}
					showToastMessage(e.getError());
				}
			}
		}).start();
	}

	public NavigationService getNavigationService() {
		return navigationService;
	}

	public void setNavigationService(NavigationService navigationService) {
		this.navigationService = navigationService;
	}


	private void fullExit() {
		// http://stackoverflow.com/questions/2092951/how-to-close-android-application
		System.runFinalizersOnExit(true);
		System.exit(0);
	}

	public synchronized void closeApplication(final Activity activity) {
		if (getNavigationService() != null) {
			Builder bld = new AlertDialog.Builder(activity);
			bld.setMessage(R.string.background_service_is_enabled_question);
			bld.setPositiveButton(R.string.default_buttons_yes, new DialogInterface.OnClickListener() {
				@Override
				public void onClick(DialogInterface dialog, int which) {
					closeApplicationAnyway(activity, true);
				}
			});
			bld.setNegativeButton(R.string.default_buttons_no, new DialogInterface.OnClickListener() {
				@Override
				public void onClick(DialogInterface dialog, int which) {
					closeApplicationAnyway(activity, false);
				}
			});
			bld.show();
		} else {
			closeApplicationAnyway(activity, true);
		}
	}

	private void closeApplicationAnyway(final Activity activity, boolean disableService) {
		if (applicationInitializing) {
			resourceManager.close();
		}
		applicationInitializing = false;

		activity.finish();

		if (getNavigationService() == null) {
			fullExit();
		}
		else if (disableService) {
			final Intent serviceIntent = new Intent(this, NavigationService.class);
			stopService(serviceIntent);

			new Thread(new Runnable() {
				public void run() {
					//wait until the service has fully stopped
					while (getNavigationService() != null) {
						try {
							Thread.sleep(100);
						}
							catch (InterruptedException e) {
						}
					}

					fullExit();
				}
			}).start();
		}
	}

	public synchronized void startApplication() {
		if (applicationInitializing) {
			return;
		}
		applicationInitializing = true;
		startDialog = new ProgressImplementation(this, null, false);

		startDialog.setRunnable("Initializing app", new Runnable() { //$NON-NLS-1$
					@Override
					public void run() {
						startApplicationBackground();
					}
				});
		startDialog.run();

		Thread.setDefaultUncaughtExceptionHandler(new DefaultExceptionHandler());

	}

	private void startApplicationBackground() {
		List<String> warnings = new ArrayList<String>();
		try {
			try {
				SpecialPhrases.setLanguage(this, osmandSettings);
			} catch (IOException e) {
				LOG.error("I/O exception", e);
				warnings.add("Error while reading the special phrases. Restart OsmAnd if possible");
			}
			if (!Version.isBlackberry(this)) {
				if (osmandSettings.NATIVE_RENDERING_FAILED.get()) {
					osmandSettings.SAFE_MODE.set(true);
					osmandSettings.NATIVE_RENDERING_FAILED.set(false);
					warnings.add(getString(R.string.native_library_not_supported));
				} else {
					osmandSettings.SAFE_MODE.set(false);
					osmandSettings.NATIVE_RENDERING_FAILED.set(true);
					startDialog.startTask(getString(R.string.init_native_library), -1);
					RenderingRulesStorage storage = rendererRegistry.getCurrentSelectedRenderer();
					boolean initialized = NativeOsmandLibrary.getLibrary(storage, this) != null;
					osmandSettings.NATIVE_RENDERING_FAILED.set(false);
					if (!initialized) {
						LOG.info("Native library could not be loaded!");
					}
				}
			}
			warnings.addAll(resourceManager.reloadIndexes(startDialog));
			player = null;
			if (savingTrackHelper.hasDataToSave()) {
				startDialog.startTask(getString(R.string.saving_gpx_tracks), -1);
				try {
					warnings.addAll(savingTrackHelper.saveDataToGpx());
				} catch (RuntimeException e) {
					warnings.add(e.getMessage());
				}
			}

			// restore backuped favorites to normal file
			final File appDir = getAppPath(null);
			File save = new File(appDir, FavouritesDbHelper.FILE_TO_SAVE);
			File bak = new File(appDir, FavouritesDbHelper.FILE_TO_BACKUP);
			if (bak.exists() && (!save.exists() || bak.lastModified() > save.lastModified())) {
				if (save.exists()) {
					save.delete();
				}
				bak.renameTo(save);
			}
		} catch (RuntimeException e) {
			e.printStackTrace();
			warnings.add(e.getMessage());
		} finally {
			synchronized (OsmandApplication.this) {
				final ProgressDialog toDismiss;
				final Runnable pb;
				if (startDialog != null) {
					toDismiss = startDialog.getDialog();
					pb = startDialog.getFinishRunnable();
				} else {
					toDismiss = null;
					pb = null;
				}
				startDialog = null;

				if (toDismiss != null || pb != null) {
					uiHandler.post(new Runnable() {
						@Override
						public void run() {
							if(pb != null) {
								pb.run();
							}
							if (toDismiss != null) {
								// TODO handling this dialog is bad, we need a better standard way
								toDismiss.dismiss();
								// toDismiss.getOwnerActivity().dismissDialog(PROGRESS_DIALOG);
							}
						}
					});
				}
				if (warnings != null && !warnings.isEmpty()) {
					showToastMessage(formatWarnings(warnings).toString());
				}
			}
		}
	}

	private StringBuilder formatWarnings(List<String> warnings) {
		final StringBuilder b = new StringBuilder();
		boolean f = true;
		for (String w : warnings) {
			if (f) {
				f = false;
			} else {
				b.append('\n');
			}
			b.append(w);
		}
		return b;
	}


	private class DefaultExceptionHandler implements UncaughtExceptionHandler {

		private UncaughtExceptionHandler defaultHandler;
		private PendingIntent intent;

		public DefaultExceptionHandler() {
			defaultHandler = Thread.getDefaultUncaughtExceptionHandler();
			intent = PendingIntent.getActivity(OsmandApplication.this.getBaseContext(), 0,
					new Intent(OsmandApplication.this.getBaseContext(),
							getAppCustomization().getMainMenuActivity()), 0);
		}

		@Override
		public void uncaughtException(final Thread thread, final Throwable ex) {
			File file = getAppPath(EXCEPTION_PATH);
			try {
				ByteArrayOutputStream out = new ByteArrayOutputStream();
				PrintStream printStream = new PrintStream(out);
				ex.printStackTrace(printStream);
				StringBuilder msg = new StringBuilder();
				msg.append("Version  " + Version.getFullVersion(OsmandApplication.this) + "\n"). //$NON-NLS-1$ 
						append(DateFormat.format("dd.MM.yyyy h:mm:ss", System.currentTimeMillis()));
				try {
					PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), 0);
					if (info != null) {
						msg.append("\nApk Version : ").append(info.versionName).append(" ").append(info.versionCode); //$NON-NLS-1$ //$NON-NLS-2$
					}
				} catch (Throwable e) {
				}
				msg.append("\n"). //$NON-NLS-1$//$NON-NLS-2$
						append("Exception occured in thread " + thread.toString() + " : \n"). //$NON-NLS-1$ //$NON-NLS-2$
						append(new String(out.toByteArray()));

				if (file.getParentFile().canWrite()) {
					BufferedWriter writer = new BufferedWriter(new FileWriter(file, true));
					writer.write(msg.toString());
					writer.close();
				}
				if (routingHelper.isFollowingMode()) {
					AlarmManager mgr = (AlarmManager) getSystemService(Context.ALARM_SERVICE);
					mgr.set(AlarmManager.RTC, System.currentTimeMillis() + 2000, intent);
					System.exit(2);
				}
				defaultHandler.uncaughtException(thread, ex);
			} catch (Exception e) {
				// swallow all exceptions
				android.util.Log.e(PlatformUtil.TAG, "Exception while handle other exception", e); //$NON-NLS-1$
			}

		}
	}

	
	public TargetPointsHelper getTargetPointsHelper() {
		return targetPointsHelper;
	}
	
	public void showShortToastMessage(int msgId, Object... args) {
		AccessibleToast.makeText(this, getString(msgId, args), Toast.LENGTH_SHORT).show();
	}

	public void showToastMessage(int msgId, Object... args) {
		AccessibleToast.makeText(this, getString(msgId, args), Toast.LENGTH_LONG).show();
	}

	public void showToastMessage(String msg) {
		AccessibleToast.makeText(this, msg, Toast.LENGTH_LONG).show();		
	}
	
	public SQLiteAPI getSQLiteAPI() {
		return sqliteAPI;
	}

	public void runInUIThread(Runnable run) {
		uiHandler.post(run);
	}

	public void runInUIThread(Runnable run, long delay) {
		uiHandler.postDelayed(run, delay);
	}
	
	public void runMessageInUIThreadAndCancelPrevious(final int messageId, final Runnable run, long delay) {
		Message msg = Message.obtain(uiHandler, new Runnable() {
			
			@Override
			public void run() {
				if(!uiHandler.hasMessages(messageId)) {
					run.run();
				}
			}
		});
		msg.what = messageId;
		uiHandler.removeMessages(messageId);
		uiHandler.sendMessageDelayed(msg, delay);
	}
	
	public File getAppPath(String path) {
		if(path == null) {
			path = "";
		}
		return new File(getSettings().getExternalStorageDirectory(), IndexConstants.APP_DIR + path);
	}

	public void applyTheme(Context c) {
		int t = R.style.OsmandLightDarkActionBarTheme;
		if (osmandSettings.OSMAND_THEME.get() == OsmandSettings.OSMAND_DARK_THEME) {
			t = R.style.OsmandDarkTheme;
		} else if (osmandSettings.OSMAND_THEME.get() == OsmandSettings.OSMAND_LIGHT_THEME) {
			t = R.style.OsmandLightTheme;
		} else if (osmandSettings.OSMAND_THEME.get() == OsmandSettings.OSMAND_LIGHT_DARK_ACTIONBAR_THEME) {
			t = R.style.OsmandLightDarkActionBarTheme;
		}
		setLanguage(c);
		c.setTheme(t);
		if (osmandSettings.OSMAND_THEME.get() == OsmandSettings.OSMAND_LIGHT_DARK_ACTIONBAR_THEME
				&& Build.VERSION.SDK_INT < Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
			ActionBar ab = null;
			if (c instanceof SherlockActivity) {
				ab = ((SherlockActivity) c).getSupportActionBar();
			} else if (c instanceof SherlockListActivity) {
				ab = ((SherlockListActivity) c).getSupportActionBar();
			} else if (c instanceof SherlockExpandableListActivity) {
				ab = ((SherlockExpandableListActivity) c).getSupportActionBar();
			}
			if (ab != null) {
				BitmapDrawable bg = (BitmapDrawable) getResources().getDrawable(R.drawable.bg_striped);
				bg.setTileModeXY(TileMode.REPEAT, TileMode.REPEAT);
				ab.setBackgroundDrawable(bg);
			}
		}
	}
	
	public IBRouterService getBRouterService() {
		if(bRouterServiceConnection == null) {
			return null;
		}
		return bRouterServiceConnection.getBrouterService();
	}
	
	public void setLanguage(Context context) {
		if (prefferedLocale != null) {
			Configuration config = context.getResources().getConfiguration();
			String lang = prefferedLocale.getLanguage();
			if (!"".equals(lang) && !config.locale.getLanguage().equals(lang)) {
				prefferedLocale = new Locale(lang);
				Locale.setDefault(prefferedLocale);
				config.locale = prefferedLocale;
				context.getResources().updateConfiguration(config, context.getResources().getDisplayMetrics());
			}
		}
	}
	
	public RoutingConfiguration.Builder getDefaultRoutingConfig() {
		if (defaultRoutingConfig == null) {
			File routingXml = getAppPath(IndexConstants.ROUTING_XML_FILE);
			if (routingXml.exists() && routingXml.canRead()) {
				try {
					defaultRoutingConfig = RoutingConfiguration.parseFromInputStream(new FileInputStream(routingXml));
				} catch (XmlPullParserException e) {
					throw new IllegalStateException(e);
				} catch (IOException e) {
					throw new IllegalStateException(e);
				}
			} else {
				defaultRoutingConfig = RoutingConfiguration.getDefault();
			}
		}
		return defaultRoutingConfig;
	}
	
	public boolean accessibilityExtensions() {
		return (Build.VERSION.SDK_INT < 14) ? getSettings().ACCESSIBILITY_EXTENSIONS.get() : false;
	}
	
	public boolean accessibilityEnabled() {
		final AccessibilityMode mode = getSettings().ACCESSIBILITY_MODE.get();
		if(OsmandPlugin.getEnabledPlugin(AccessibilityPlugin.class) == null) {
			return false;
		}
		if (mode == AccessibilityMode.ON) {
			return true;
		} else if (mode == AccessibilityMode.OFF) {
			return false;
		}
		return ((AccessibilityManager) getSystemService(Context.ACCESSIBILITY_SERVICE)).isEnabled();
	}

	public String getVersionName() {
		try {
			PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), 0);
			return info.versionName;
		} catch (NameNotFoundException e) {
			return "";
		}
	}

	public int getVersionCode() {
		try {
			PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), 0);
			return info.versionCode;
		} catch (NameNotFoundException e) {
			return 0;
		}
	}

	public void startNavigationService(int intent) {
		final Intent serviceIntent = new Intent(this, NavigationService.class);
		serviceIntent.putExtra(NavigationService.USAGE_INTENT, intent);
		if (getNavigationService() == null) {
			getSettings().SERVICE_OFF_INTERVAL.set(0);
			startService(serviceIntent);
		} else {
			getNavigationService().addUsageIntent(intent);
		}		
	}
}
!@#$%
20190530_010518,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_c04640
package net.osmand.plus;

import java.io.BufferedWriter;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintStream;
import java.lang.Thread.UncaughtExceptionHandler;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

import net.osmand.IndexConstants;
import net.osmand.PlatformUtil;
import net.osmand.access.AccessibilityPlugin;
import net.osmand.access.AccessibleAlertBuilder;
import net.osmand.access.AccessibleToast;
import net.osmand.plus.access.AccessibilityMode;
import net.osmand.plus.activities.DayNightHelper;
import net.osmand.plus.activities.SavingTrackHelper;
import net.osmand.plus.activities.SettingsActivity;
import net.osmand.plus.api.SQLiteAPI;
import net.osmand.plus.api.SQLiteAPIImpl;
import net.osmand.plus.monitoring.LiveMonitoringHelper;
import net.osmand.plus.render.NativeOsmandLibrary;
import net.osmand.plus.render.RendererRegistry;
import net.osmand.plus.resources.ResourceManager;
import net.osmand.plus.routing.RoutingHelper;
import net.osmand.plus.voice.CommandPlayer;
import net.osmand.plus.voice.CommandPlayerException;
import net.osmand.plus.voice.CommandPlayerFactory;
import net.osmand.render.RenderingRulesStorage;
import net.osmand.router.RoutingConfiguration;
import net.osmand.util.Algorithms;

import org.xmlpull.v1.XmlPullParserException;

import android.app.Activity;
import android.app.AlarmManager;
import android.app.AlertDialog;
import android.app.AlertDialog.Builder;
import android.app.Application;
import android.app.PendingIntent;
import android.app.ProgressDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager.NameNotFoundException;
import android.content.res.Configuration;
import android.graphics.Shader.TileMode;
import android.graphics.drawable.BitmapDrawable;
import android.os.Build;
import android.os.Handler;
import android.os.Message;
import android.text.format.DateFormat;
import android.util.TypedValue;
import android.view.accessibility.AccessibilityManager;
import android.widget.CheckBox;
import android.widget.LinearLayout;
import android.widget.LinearLayout.LayoutParams;
import android.widget.ProgressBar;
import android.widget.TextView;
import android.widget.Toast;
import btools.routingapp.BRouterServiceConnection;
import btools.routingapp.IBRouterService;

import com.actionbarsherlock.app.ActionBar;
import com.actionbarsherlock.app.SherlockActivity;
import com.actionbarsherlock.app.SherlockExpandableListActivity;
import com.actionbarsherlock.app.SherlockListActivity;


public class OsmandApplication extends Application {
	public static final String EXCEPTION_PATH = "exception.log"; //$NON-NLS-1$
	private static final org.apache.commons.logging.Log LOG = PlatformUtil.getLog(OsmandApplication.class);

	
	ResourceManager resourceManager = null;
	PoiFiltersHelper poiFilters = null;
	RoutingHelper routingHelper = null;
	FavouritesDbHelper favorites = null;
	CommandPlayer player = null;

	OsmandSettings osmandSettings = null;

	OsmAndAppCustomization appCustomization;
	DayNightHelper daynightHelper;
	NavigationService navigationService;
	RendererRegistry rendererRegistry;
	OsmAndLocationProvider locationProvider;
	OsmAndTaskManager taskManager;

	// start variables
	private ProgressImplementation startDialog;
	private Handler uiHandler;
	private GpxSelectionHelper selectedGpxHelper;
	private SavingTrackHelper savingTrackHelper;
	private LiveMonitoringHelper liveMonitoringHelper;
	private TargetPointsHelper targetPointsHelper;
	private RoutingConfiguration.Builder defaultRoutingConfig;

	private boolean applicationInitializing = false;
	private Locale prefferedLocale = null;
	
	SQLiteAPI sqliteAPI;
	BRouterServiceConnection bRouterServiceConnection;

	@Override
	public void onCreate() {
		long timeToStart = System.currentTimeMillis();
		if (Version.getAppName(this).equals("OsmAnd~")) {
			if (android.os.Build.VERSION.SDK_INT >= 9) {
				try {
					Class.forName("net.osmand.plus.base.EnableStrictMode").newInstance();
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		}
		super.onCreate();
		appCustomization = new OsmAndAppCustomization();
		appCustomization.setup(this);
		 
		sqliteAPI = new SQLiteAPIImpl(this);
		try {
			bRouterServiceConnection = BRouterServiceConnection.connect(this);
		} catch(Exception e) {
			e.printStackTrace();
		}

		// settings used everywhere so they need to be created first
		osmandSettings = appCustomization.createSettings(new net.osmand.plus.api.SettingsAPIImpl(this));
		// always update application mode to default
		if(!osmandSettings.FOLLOW_THE_ROUTE.get()){
			osmandSettings.APPLICATION_MODE.set(osmandSettings.DEFAULT_APPLICATION_MODE.get());
		}
		
		applyTheme(this);
		
		routingHelper = new RoutingHelper(this, player);
		taskManager = new OsmAndTaskManager(this);
		resourceManager = new ResourceManager(this);
		daynightHelper = new DayNightHelper(this);
		locationProvider = new OsmAndLocationProvider(this);
		savingTrackHelper = new SavingTrackHelper(this);
		liveMonitoringHelper = new LiveMonitoringHelper(this);
		selectedGpxHelper = new GpxSelectionHelper(this);
		uiHandler = new Handler();
		rendererRegistry = new RendererRegistry();
		targetPointsHelper = new TargetPointsHelper(this);
//		if(!osmandSettings.FOLLOW_THE_ROUTE.get()) {
//			targetPointsHelper.clearPointToNavigate(false);
//		}
		
		checkPrefferedLocale();
		startApplication();
		if (LOG.isDebugEnabled()) {
			LOG.debug("Time to start application " + (System.currentTimeMillis() - timeToStart) + " ms. Should be less < 800 ms");
		}
		timeToStart = System.currentTimeMillis();
		OsmandPlugin.initPlugins(this);

		if (LOG.isDebugEnabled()) {
			LOG.debug("Time to init plugins " + (System.currentTimeMillis() - timeToStart) + " ms. Should be less < 800 ms");
		}
		
		
	}

	@Override
	public void onTerminate() {
		super.onTerminate();
		if (routingHelper != null) {
			routingHelper.getVoiceRouter().onApplicationTerminate(this);
		}
	}

	public RendererRegistry getRendererRegistry() {
		return rendererRegistry;
	}
	
	public OsmAndTaskManager getTaskManager() {
		return taskManager;
	}

	
	public OsmAndLocationProvider getLocationProvider() {
		return locationProvider;
	}
	
	public OsmAndAppCustomization getAppCustomization() {
		return appCustomization;
	}
	
	public void setAppCustomization(OsmAndAppCustomization appCustomization) {
		this.appCustomization = appCustomization;
		this.appCustomization.setup(this);
	}

	/**
	 * Application settings
	 * 
	 * @return Reference to instance of OsmandSettings
	 */
	public OsmandSettings getSettings() {
		if (osmandSettings == null) {
			LOG.error("Trying to access settings before they were created");
		}
		return osmandSettings;
	}

	public SavingTrackHelper getSavingTrackHelper() {
		return savingTrackHelper;
	}

	public LiveMonitoringHelper getLiveMonitoringHelper() {
		return liveMonitoringHelper;
	}

	public PoiFiltersHelper getPoiFilters() {
		if (poiFilters == null) {
			poiFilters = new PoiFiltersHelper(this);
		}
		return poiFilters;
	}


	public GpxSelectionHelper getSelectedGpxHelper() {
		return selectedGpxHelper;
	}

	public FavouritesDbHelper getFavorites() {
		if (favorites == null) {
			favorites = new FavouritesDbHelper(this);
		}
		return favorites;
	}

	public ResourceManager getResourceManager() {
		return resourceManager;
	}

	public DayNightHelper getDaynightHelper() {
		return daynightHelper;
	}

	@Override
	public void onLowMemory() {
		super.onLowMemory();
		resourceManager.onLowMemory();
	}

	@Override
	public void onConfigurationChanged(Configuration newConfig) {
		if (prefferedLocale != null && !newConfig.locale.getLanguage().equals(prefferedLocale.getLanguage())) {
			super.onConfigurationChanged(newConfig);
			// ugly fix ! On devices after 4.0 screen is blinking when you rotate device!
			if (Build.VERSION.SDK_INT < 14) {
				newConfig.locale = prefferedLocale;
			}
			getBaseContext().getResources().updateConfiguration(newConfig, getBaseContext().getResources().getDisplayMetrics());
			Locale.setDefault(prefferedLocale);
		} else {
			super.onConfigurationChanged(newConfig);
		}
	}

	public void checkPrefferedLocale() {
		Configuration config = getBaseContext().getResources().getConfiguration();
		String lang = osmandSettings.PREFERRED_LOCALE.get();
		if (!"".equals(lang) && !config.locale.getLanguage().equals(lang)) {
			prefferedLocale = new Locale(lang);
			Locale.setDefault(prefferedLocale);
			config.locale = prefferedLocale;
			getBaseContext().getResources().updateConfiguration(config, getBaseContext().getResources().getDisplayMetrics());
		}
		String clang = "".equals(lang) ? config.locale.getLanguage() : lang;
		resourceManager.getOsmandRegions().setLocale(clang);

	}

	public static final int PROGRESS_DIALOG = 5;

	public void checkApplicationIsBeingInitialized(Activity activity, ProgressDialog progressDialog) {
		// start application if it was previously closed
		startApplication();
		synchronized (OsmandApplication.this) {
			if (startDialog != null) {
				progressDialog.setTitle(getString(R.string.loading_data));
				progressDialog.setMessage(getString(R.string.reading_indexes));
				activity.showDialog(PROGRESS_DIALOG);
				startDialog.setDialog(progressDialog);
			} else {
				progressDialog.dismiss();
			}
		}
	}
	
	public void checkApplicationIsBeingInitialized(Activity activity, TextView tv, ProgressBar progressBar,
			Runnable onClose) {
		// start application if it was previously closed
		startApplication();
		synchronized (OsmandApplication.this) {
			if (startDialog != null ) {
				tv.setText(getString(R.string.loading_data));
				startDialog.setProgressBar(tv, progressBar, onClose);
			} else if (onClose != null) {
				onClose.run();
			}
		}
	}

	public boolean isApplicationInitializing() {
		return startDialog != null;
	}

	public RoutingHelper getRoutingHelper() {
		return routingHelper;
	}

	public CommandPlayer getPlayer() {
		return player;
	}

	public void initVoiceCommandPlayer(final Activity uiContext) {
		showDialogInitializingCommandPlayer(uiContext, true, null, false);
	}

	public void showDialogInitializingCommandPlayer(final Activity uiContext, boolean warningNoneProvider) {
		showDialogInitializingCommandPlayer(uiContext, warningNoneProvider, null, true);
	}

	public void showDialogInitializingCommandPlayer(final Activity uiContext, boolean warningNoneProvider, Runnable run, boolean showDialog) {
		String voiceProvider = osmandSettings.VOICE_PROVIDER.get();
		if (voiceProvider == null || OsmandSettings.VOICE_PROVIDER_NOT_USE.equals(voiceProvider)) {
			if (warningNoneProvider && voiceProvider == null) {
				Builder builder = new AccessibleAlertBuilder(uiContext);
				LinearLayout ll = new LinearLayout(uiContext);
				ll.setOrientation(LinearLayout.VERTICAL);
				final TextView tv = new TextView(uiContext);
				tv.setPadding(7, 3, 7, 0);
				tv.setText(R.string.voice_is_not_available_msg);
				tv.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 19);
				ll.addView(tv);
				
				final CheckBox cb = new CheckBox(uiContext);
				cb.setText(R.string.remember_choice);
				LinearLayout.LayoutParams lp = new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);
				lp.setMargins(7, 10, 7, 0);
				cb.setLayoutParams(lp);
				ll.addView(cb);
				
				builder.setCancelable(true);
				builder.setNegativeButton(R.string.default_buttons_cancel, new DialogInterface.OnClickListener() {
					@Override
					public void onClick(DialogInterface dialog, int which) {
						if(cb.isChecked()) {
							osmandSettings.VOICE_PROVIDER.set(OsmandSettings.VOICE_PROVIDER_NOT_USE);
						}
					}
				});
				builder.setPositiveButton(R.string.default_buttons_ok, new DialogInterface.OnClickListener() {
					@Override
					public void onClick(DialogInterface dialog, int which) {
						Intent intent = new Intent(uiContext, SettingsActivity.class);
						intent.putExtra(SettingsActivity.INTENT_KEY_SETTINGS_SCREEN, SettingsActivity.SCREEN_GENERAL_SETTINGS);
						uiContext.startActivity(intent);
					}
				});
				
				
				builder.setTitle(R.string.voice_is_not_available_title);
				builder.setView(ll);
				//builder.setMessage(R.string.voice_is_not_available_msg);
				builder.show();
			}

		} else {
			if (player == null || !Algorithms.objectEquals(voiceProvider, player.getCurrentVoice())) {
				initVoiceDataInDifferentThread(uiContext, voiceProvider, run, showDialog);
			}
		}

	}

	private void initVoiceDataInDifferentThread(final Activity uiContext, final String voiceProvider, final Runnable run, boolean showDialog) {
		final ProgressDialog dlg = showDialog ? ProgressDialog.show(uiContext, getString(R.string.loading_data),
				getString(R.string.voice_data_initializing)) : null;
		new Thread(new Runnable() {
			@Override
			public void run() {
				try {
					if (player != null) {
						player.clear();
					}
					player = CommandPlayerFactory.createCommandPlayer(voiceProvider, OsmandApplication.this, uiContext);
					routingHelper.getVoiceRouter().setPlayer(player);
					if(dlg != null) {
						dlg.dismiss();
					}
					if (run != null && uiContext != null) {
						uiContext.runOnUiThread(run);
					}
				} catch (CommandPlayerException e) {
					if(dlg != null) {
						dlg.dismiss();
					}
					showToastMessage(e.getError());
				}
			}
		}).start();
	}

	public NavigationService getNavigationService() {
		return navigationService;
	}

	public void setNavigationService(NavigationService navigationService) {
		this.navigationService = navigationService;
	}


	private void fullExit() {
		// http://stackoverflow.com/questions/2092951/how-to-close-android-application
		System.runFinalizersOnExit(true);
		System.exit(0);
	}

	public synchronized void closeApplication(final Activity activity) {
		if (getNavigationService() != null) {
			Builder bld = new AlertDialog.Builder(activity);
			bld.setMessage(R.string.background_service_is_enabled_question);
			bld.setPositiveButton(R.string.default_buttons_yes, new DialogInterface.OnClickListener() {
				@Override
				public void onClick(DialogInterface dialog, int which) {
					closeApplicationAnyway(activity, true);
				}
			});
			bld.setNegativeButton(R.string.default_buttons_no, new DialogInterface.OnClickListener() {
				@Override
				public void onClick(DialogInterface dialog, int which) {
					closeApplicationAnyway(activity, false);
				}
			});
			bld.show();
		} else {
			closeApplicationAnyway(activity, true);
		}
	}

	private void closeApplicationAnyway(final Activity activity, boolean disableService) {
		if (applicationInitializing) {
			resourceManager.close();
		}
		applicationInitializing = false;

		activity.finish();

		if (getNavigationService() == null) {
			fullExit();
		}
		else if (disableService) {
			final Intent serviceIntent = new Intent(this, NavigationService.class);
			stopService(serviceIntent);

			new Thread(new Runnable() {
				public void run() {
					//wait until the service has fully stopped
					while (getNavigationService() != null) {
						try {
							Thread.sleep(100);
						}
							catch (InterruptedException e) {
						}
					}

					fullExit();
				}
			}).start();
		}
	}

	public synchronized void startApplication() {
		if (applicationInitializing) {
			return;
		}
		applicationInitializing = true;
		startDialog = new ProgressImplementation(this, null, false);

		startDialog.setRunnable("Initializing app", new Runnable() { //$NON-NLS-1$
					@Override
					public void run() {
						startApplicationBackground();
					}
				});
		startDialog.run();

		Thread.setDefaultUncaughtExceptionHandler(new DefaultExceptionHandler());

	}

	private void startApplicationBackground() {
		List<String> warnings = new ArrayList<String>();
		try {
			try {
				SpecialPhrases.setLanguage(this, osmandSettings);
			} catch (IOException e) {
				LOG.error("I/O exception", e);
				warnings.add("Error while reading the special phrases. Restart OsmAnd if possible");
			}
			if (!Version.isBlackberry(this)) {
				if (osmandSettings.NATIVE_RENDERING_FAILED.get()) {
					osmandSettings.SAFE_MODE.set(true);
					osmandSettings.NATIVE_RENDERING_FAILED.set(false);
					warnings.add(getString(R.string.native_library_not_supported));
				} else {
					osmandSettings.SAFE_MODE.set(false);
					osmandSettings.NATIVE_RENDERING_FAILED.set(true);
					startDialog.startTask(getString(R.string.init_native_library), -1);
					RenderingRulesStorage storage = rendererRegistry.getCurrentSelectedRenderer();
					boolean initialized = NativeOsmandLibrary.getLibrary(storage, this) != null;
					osmandSettings.NATIVE_RENDERING_FAILED.set(false);
					if (!initialized) {
						LOG.info("Native library could not be loaded!");
					}
				}
			}
			warnings.addAll(resourceManager.reloadIndexes(startDialog));
			player = null;
			if (savingTrackHelper.hasDataToSave()) {
				startDialog.startTask(getString(R.string.saving_gpx_tracks), -1);
				try {
					warnings.addAll(savingTrackHelper.saveDataToGpx());
				} catch (RuntimeException e) {
					warnings.add(e.getMessage());
				}
			}

			// restore backuped favorites to normal file
			final File appDir = getAppPath(null);
			File save = new File(appDir, FavouritesDbHelper.FILE_TO_SAVE);
			File bak = new File(appDir, FavouritesDbHelper.FILE_TO_BACKUP);
			if (bak.exists() && (!save.exists() || bak.lastModified() > save.lastModified())) {
				if (save.exists()) {
					save.delete();
				}
				bak.renameTo(save);
			}
		} catch (RuntimeException e) {
			e.printStackTrace();
			warnings.add(e.getMessage());
		} finally {
			synchronized (OsmandApplication.this) {
				final ProgressDialog toDismiss;
				final Runnable pb;
				if (startDialog != null) {
					toDismiss = startDialog.getDialog();
					pb = startDialog.getFinishRunnable();
				} else {
					toDismiss = null;
					pb = null;
				}
				startDialog = null;

				if (toDismiss != null || pb != null) {
					uiHandler.post(new Runnable() {
						@Override
						public void run() {
							if(pb != null) {
								pb.run();
							}
							if (toDismiss != null) {
								// TODO handling this dialog is bad, we need a better standard way
								toDismiss.dismiss();
								// toDismiss.getOwnerActivity().dismissDialog(PROGRESS_DIALOG);
							}
						}
					});
				}
				if (warnings != null && !warnings.isEmpty()) {
					showToastMessage(formatWarnings(warnings).toString());
				}
			}
		}
	}

	private StringBuilder formatWarnings(List<String> warnings) {
		final StringBuilder b = new StringBuilder();
		boolean f = true;
		for (String w : warnings) {
			if (f) {
				f = false;
			} else {
				b.append('\n');
			}
			b.append(w);
		}
		return b;
	}


	private class DefaultExceptionHandler implements UncaughtExceptionHandler {

		private UncaughtExceptionHandler defaultHandler;
		private PendingIntent intent;

		public DefaultExceptionHandler() {
			defaultHandler = Thread.getDefaultUncaughtExceptionHandler();
			intent = PendingIntent.getActivity(OsmandApplication.this.getBaseContext(), 0,
					new Intent(OsmandApplication.this.getBaseContext(),
							getAppCustomization().getMainMenuActivity()), 0);
		}

		@Override
		public void uncaughtException(final Thread thread, final Throwable ex) {
			File file = getAppPath(EXCEPTION_PATH);
			try {
				ByteArrayOutputStream out = new ByteArrayOutputStream();
				PrintStream printStream = new PrintStream(out);
				ex.printStackTrace(printStream);
				StringBuilder msg = new StringBuilder();
				msg.append("Version  " + Version.getFullVersion(OsmandApplication.this) + "\n"). //$NON-NLS-1$ 
						append(DateFormat.format("dd.MM.yyyy h:mm:ss", System.currentTimeMillis()));
				try {
					PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), 0);
					if (info != null) {
						msg.append("\nApk Version : ").append(info.versionName).append(" ").append(info.versionCode); //$NON-NLS-1$ //$NON-NLS-2$
					}
				} catch (Throwable e) {
				}
				msg.append("\n"). //$NON-NLS-1$//$NON-NLS-2$
						append("Exception occured in thread " + thread.toString() + " : \n"). //$NON-NLS-1$ //$NON-NLS-2$
						append(new String(out.toByteArray()));

				if (file.getParentFile().canWrite()) {
					BufferedWriter writer = new BufferedWriter(new FileWriter(file, true));
					writer.write(msg.toString());
					writer.close();
				}
				if (routingHelper.isFollowingMode()) {
					AlarmManager mgr = (AlarmManager) getSystemService(Context.ALARM_SERVICE);
					mgr.set(AlarmManager.RTC, System.currentTimeMillis() + 2000, intent);
					System.exit(2);
				}
				defaultHandler.uncaughtException(thread, ex);
			} catch (Exception e) {
				// swallow all exceptions
				android.util.Log.e(PlatformUtil.TAG, "Exception while handle other exception", e); //$NON-NLS-1$
			}

		}
	}

	
	public TargetPointsHelper getTargetPointsHelper() {
		return targetPointsHelper;
	}
	
	public void showShortToastMessage(int msgId, Object... args) {
		AccessibleToast.makeText(this, getString(msgId, args), Toast.LENGTH_SHORT).show();
	}

	public void showToastMessage(int msgId, Object... args) {
		AccessibleToast.makeText(this, getString(msgId, args), Toast.LENGTH_LONG).show();
	}

	public void showToastMessage(String msg) {
		AccessibleToast.makeText(this, msg, Toast.LENGTH_LONG).show();		
	}
	
	public SQLiteAPI getSQLiteAPI() {
		return sqliteAPI;
	}

	public void runInUIThread(Runnable run) {
		uiHandler.post(run);
	}

	public void runInUIThread(Runnable run, long delay) {
		uiHandler.postDelayed(run, delay);
	}
	
	public void runMessageInUIThreadAndCancelPrevious(final int messageId, final Runnable run, long delay) {
		Message msg = Message.obtain(uiHandler, new Runnable() {
			
			@Override
			public void run() {
				if(!uiHandler.hasMessages(messageId)) {
					run.run();
				}
			}
		});
		msg.what = messageId;
		uiHandler.removeMessages(messageId);
		uiHandler.sendMessageDelayed(msg, delay);
	}
	
	public File getAppPath(String path) {
		if(path == null) {
			path = "";
		}
		return new File(getSettings().getExternalStorageDirectory(), IndexConstants.APP_DIR + path);
	}

	public void applyTheme(Context c) {
		int t = R.style.OsmandLightDarkActionBarTheme;
		if (osmandSettings.OSMAND_THEME.get() == OsmandSettings.OSMAND_DARK_THEME) {
			t = R.style.OsmandDarkTheme;
		} else if (osmandSettings.OSMAND_THEME.get() == OsmandSettings.OSMAND_LIGHT_THEME) {
			t = R.style.OsmandLightTheme;
		} else if (osmandSettings.OSMAND_THEME.get() == OsmandSettings.OSMAND_LIGHT_DARK_ACTIONBAR_THEME) {
			t = R.style.OsmandLightDarkActionBarTheme;
		}
		setLanguage(c);
		c.setTheme(t);
		if (osmandSettings.OSMAND_THEME.get() == OsmandSettings.OSMAND_LIGHT_DARK_ACTIONBAR_THEME
				&& Build.VERSION.SDK_INT < Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
			ActionBar ab = null;
			if (c instanceof SherlockActivity) {
				ab = ((SherlockActivity) c).getSupportActionBar();
			} else if (c instanceof SherlockListActivity) {
				ab = ((SherlockListActivity) c).getSupportActionBar();
			} else if (c instanceof SherlockExpandableListActivity) {
				ab = ((SherlockExpandableListActivity) c).getSupportActionBar();
			}
			if (ab != null) {
				BitmapDrawable bg = (BitmapDrawable) getResources().getDrawable(R.drawable.bg_striped);
				bg.setTileModeXY(TileMode.REPEAT, TileMode.REPEAT);
				ab.setBackgroundDrawable(bg);
			}
		}
	}
	
	public IBRouterService getBRouterService() {
		if(bRouterServiceConnection == null) {
			return null;
		}
		return bRouterServiceConnection.getBrouterService();
	}
	
	public void setLanguage(Context context) {
		if (prefferedLocale != null) {
			Configuration config = context.getResources().getConfiguration();
			String lang = prefferedLocale.getLanguage();
			if (!"".equals(lang) && !config.locale.getLanguage().equals(lang)) {
				prefferedLocale = new Locale(lang);
				Locale.setDefault(prefferedLocale);
				config.locale = prefferedLocale;
				context.getResources().updateConfiguration(config, context.getResources().getDisplayMetrics());
			}
		}
	}
	
	public RoutingConfiguration.Builder getDefaultRoutingConfig() {
		if (defaultRoutingConfig == null) {
			File routingXml = getAppPath(IndexConstants.ROUTING_XML_FILE);
			if (routingXml.exists() && routingXml.canRead()) {
				try {
					defaultRoutingConfig = RoutingConfiguration.parseFromInputStream(new FileInputStream(routingXml));
				} catch (XmlPullParserException e) {
					throw new IllegalStateException(e);
				} catch (IOException e) {
					throw new IllegalStateException(e);
				}
			} else {
				defaultRoutingConfig = RoutingConfiguration.getDefault();
			}
		}
		return defaultRoutingConfig;
	}
	
	public boolean accessibilityExtensions() {
		return (Build.VERSION.SDK_INT < 14) ? getSettings().ACCESSIBILITY_EXTENSIONS.get() : false;
	}
	
	public boolean accessibilityEnabled() {
		final AccessibilityMode mode = getSettings().ACCESSIBILITY_MODE.get();
		if(OsmandPlugin.getEnabledPlugin(AccessibilityPlugin.class) == null) {
			return false;
		}
		if (mode == AccessibilityMode.ON) {
			return true;
		} else if (mode == AccessibilityMode.OFF) {
			return false;
		}
		return ((AccessibilityManager) getSystemService(Context.ACCESSIBILITY_SERVICE)).isEnabled();
	}

	public String getVersionName() {
		try {
			PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), 0);
			return info.versionName;
		} catch (NameNotFoundException e) {
			return "";
		}
	}

	public int getVersionCode() {
		try {
			PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), 0);
			return info.versionCode;
		} catch (NameNotFoundException e) {
			return 0;
		}
	}

	public void startNavigationService(int intent) {
		final Intent serviceIntent = new Intent(this, NavigationService.class);
		serviceIntent.putExtra(NavigationService.USAGE_INTENT, intent);
		if (getNavigationService() == null) {
			getSettings().SERVICE_OFF_INTERVAL.set(0);
			startService(serviceIntent);
		} else {
			getNavigationService().addUsageIntent(intent);
		}		
	}
}
!@#$%
20190530_010530,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_b00688
package net.osmand.plus;

import java.io.BufferedWriter;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintStream;
import java.lang.Thread.UncaughtExceptionHandler;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

import net.osmand.IndexConstants;
import net.osmand.PlatformUtil;
import net.osmand.access.AccessibilityPlugin;
import net.osmand.access.AccessibleAlertBuilder;
import net.osmand.access.AccessibleToast;
import net.osmand.plus.access.AccessibilityMode;
import net.osmand.plus.activities.DayNightHelper;
import net.osmand.plus.activities.SavingTrackHelper;
import net.osmand.plus.activities.SettingsActivity;
import net.osmand.plus.api.SQLiteAPI;
import net.osmand.plus.api.SQLiteAPIImpl;
import net.osmand.plus.monitoring.LiveMonitoringHelper;
import net.osmand.plus.render.NativeOsmandLibrary;
import net.osmand.plus.render.RendererRegistry;
import net.osmand.plus.resources.ResourceManager;
import net.osmand.plus.routing.RoutingHelper;
import net.osmand.plus.voice.CommandPlayer;
import net.osmand.plus.voice.CommandPlayerException;
import net.osmand.plus.voice.CommandPlayerFactory;
import net.osmand.render.RenderingRulesStorage;
import net.osmand.router.RoutingConfiguration;
import net.osmand.util.Algorithms;

import org.xmlpull.v1.XmlPullParserException;

import android.app.Activity;
import android.app.AlarmManager;
import android.app.AlertDialog;
import android.app.AlertDialog.Builder;
import android.app.Application;
import android.app.PendingIntent;
import android.app.ProgressDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager.NameNotFoundException;
import android.content.res.Configuration;
import android.graphics.Shader.TileMode;
import android.graphics.drawable.BitmapDrawable;
import android.os.Build;
import android.os.Handler;
import android.os.Message;
import android.text.format.DateFormat;
import android.util.TypedValue;
import android.view.accessibility.AccessibilityManager;
import android.widget.CheckBox;
import android.widget.LinearLayout;
import android.widget.LinearLayout.LayoutParams;
import android.widget.ProgressBar;
import android.widget.TextView;
import android.widget.Toast;
import btools.routingapp.BRouterServiceConnection;
import btools.routingapp.IBRouterService;

import com.actionbarsherlock.app.ActionBar;
import com.actionbarsherlock.app.SherlockActivity;
import com.actionbarsherlock.app.SherlockExpandableListActivity;
import com.actionbarsherlock.app.SherlockListActivity;


public class OsmandApplication extends Application {
	public static final String EXCEPTION_PATH = "exception.log"; //$NON-NLS-1$
	private static final org.apache.commons.logging.Log LOG = PlatformUtil.getLog(OsmandApplication.class);

	
	ResourceManager resourceManager = null;
	PoiFiltersHelper poiFilters = null;
	RoutingHelper routingHelper = null;
	FavouritesDbHelper favorites = null;
	CommandPlayer player = null;

	OsmandSettings osmandSettings = null;

	OsmAndAppCustomization appCustomization;
	DayNightHelper daynightHelper;
	NavigationService navigationService;
	RendererRegistry rendererRegistry;
	OsmAndLocationProvider locationProvider;
	OsmAndTaskManager taskManager;

	// start variables
	private ProgressImplementation startDialog;
	private Handler uiHandler;
	private GpxSelectionHelper selectedGpxHelper;
	private SavingTrackHelper savingTrackHelper;
	private LiveMonitoringHelper liveMonitoringHelper;
	private TargetPointsHelper targetPointsHelper;
	private RoutingConfiguration.Builder defaultRoutingConfig;

	private boolean applicationInitializing = false;
	private Locale prefferedLocale = null;
	
	SQLiteAPI sqliteAPI;
	BRouterServiceConnection bRouterServiceConnection;

	@Override
	public void onCreate() {
		long timeToStart = System.currentTimeMillis();
		if (Version.getAppName(this).equals("OsmAnd~")) {
			if (android.os.Build.VERSION.SDK_INT >= 9) {
				try {
					Class.forName("net.osmand.plus.base.EnableStrictMode").newInstance();
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		}
		super.onCreate();
		appCustomization = new OsmAndAppCustomization();
		appCustomization.setup(this);
		 
		sqliteAPI = new SQLiteAPIImpl(this);
		try {
			bRouterServiceConnection = BRouterServiceConnection.connect(this);
		} catch(Exception e) {
			e.printStackTrace();
		}

		// settings used everywhere so they need to be created first
		osmandSettings = appCustomization.createSettings(new net.osmand.plus.api.SettingsAPIImpl(this));
		// always update application mode to default
		if(!osmandSettings.FOLLOW_THE_ROUTE.get()){
			osmandSettings.APPLICATION_MODE.set(osmandSettings.DEFAULT_APPLICATION_MODE.get());
		}
		
		applyTheme(this);
		
		routingHelper = new RoutingHelper(this, player);
		taskManager = new OsmAndTaskManager(this);
		resourceManager = new ResourceManager(this);
		daynightHelper = new DayNightHelper(this);
		locationProvider = new OsmAndLocationProvider(this);
		savingTrackHelper = new SavingTrackHelper(this);
		liveMonitoringHelper = new LiveMonitoringHelper(this);
		selectedGpxHelper = new GpxSelectionHelper(this);
		uiHandler = new Handler();
		rendererRegistry = new RendererRegistry();
		targetPointsHelper = new TargetPointsHelper(this);
//		if(!osmandSettings.FOLLOW_THE_ROUTE.get()) {
//			targetPointsHelper.clearPointToNavigate(false);
//		}
		
		checkPrefferedLocale();
		startApplication();
		if (LOG.isDebugEnabled()) {
			LOG.debug("Time to start application " + (System.currentTimeMillis() - timeToStart) + " ms. Should be less < 800 ms");
		}
		timeToStart = System.currentTimeMillis();
		OsmandPlugin.initPlugins(this);

		if (LOG.isDebugEnabled()) {
			LOG.debug("Time to init plugins " + (System.currentTimeMillis() - timeToStart) + " ms. Should be less < 800 ms");
		}
		
		
	}

	@Override
	public void onTerminate() {
		super.onTerminate();
		if (routingHelper != null) {
			routingHelper.getVoiceRouter().onApplicationTerminate(this);
		}
	}

	public RendererRegistry getRendererRegistry() {
		return rendererRegistry;
	}
	
	public OsmAndTaskManager getTaskManager() {
		return taskManager;
	}

	
	public OsmAndLocationProvider getLocationProvider() {
		return locationProvider;
	}
	
	public OsmAndAppCustomization getAppCustomization() {
		return appCustomization;
	}
	
	public void setAppCustomization(OsmAndAppCustomization appCustomization) {
		this.appCustomization = appCustomization;
		this.appCustomization.setup(this);
	}

	/**
	 * Application settings
	 * 
	 * @return Reference to instance of OsmandSettings
	 */
	public OsmandSettings getSettings() {
		if (osmandSettings == null) {
			LOG.error("Trying to access settings before they were created");
		}
		return osmandSettings;
	}

	public SavingTrackHelper getSavingTrackHelper() {
		return savingTrackHelper;
	}

	public LiveMonitoringHelper getLiveMonitoringHelper() {
		return liveMonitoringHelper;
	}

	public PoiFiltersHelper getPoiFilters() {
		if (poiFilters == null) {
			poiFilters = new PoiFiltersHelper(this);
		}
		return poiFilters;
	}


	public GpxSelectionHelper getSelectedGpxHelper() {
		return selectedGpxHelper;
	}

	public FavouritesDbHelper getFavorites() {
		if (favorites == null) {
			favorites = new FavouritesDbHelper(this);
		}
		return favorites;
	}

	public ResourceManager getResourceManager() {
		return resourceManager;
	}

	public DayNightHelper getDaynightHelper() {
		return daynightHelper;
	}

	@Override
	public void onLowMemory() {
		super.onLowMemory();
		resourceManager.onLowMemory();
	}

	@Override
	public void onConfigurationChanged(Configuration newConfig) {
		if (prefferedLocale != null && !newConfig.locale.getLanguage().equals(prefferedLocale.getLanguage())) {
			super.onConfigurationChanged(newConfig);
			// ugly fix ! On devices after 4.0 screen is blinking when you rotate device!
			if (Build.VERSION.SDK_INT < 14) {
				newConfig.locale = prefferedLocale;
			}
			getBaseContext().getResources().updateConfiguration(newConfig, getBaseContext().getResources().getDisplayMetrics());
			Locale.setDefault(prefferedLocale);
		} else {
			super.onConfigurationChanged(newConfig);
		}
	}

	public void checkPrefferedLocale() {
		Configuration config = getBaseContext().getResources().getConfiguration();
		String lang = osmandSettings.PREFERRED_LOCALE.get();
		if (!"".equals(lang) && !config.locale.getLanguage().equals(lang)) {
			prefferedLocale = new Locale(lang);
			Locale.setDefault(prefferedLocale);
			config.locale = prefferedLocale;
			getBaseContext().getResources().updateConfiguration(config, getBaseContext().getResources().getDisplayMetrics());
		}
		String clang = "".equals(lang) ? config.locale.getLanguage() : lang;
		resourceManager.getOsmandRegions().setLocale(clang);

	}

	public static final int PROGRESS_DIALOG = 5;

	public void checkApplicationIsBeingInitialized(Activity activity, ProgressDialog progressDialog) {
		// start application if it was previously closed
		startApplication();
		synchronized (OsmandApplication.this) {
			if (startDialog != null) {
				progressDialog.setTitle(getString(R.string.loading_data));
				progressDialog.setMessage(getString(R.string.reading_indexes));
				activity.showDialog(PROGRESS_DIALOG);
				startDialog.setDialog(progressDialog);
			} else {
				progressDialog.dismiss();
			}
		}
	}
	
	public void checkApplicationIsBeingInitialized(Activity activity, TextView tv, ProgressBar progressBar,
			Runnable onClose) {
		// start application if it was previously closed
		startApplication();
		synchronized (OsmandApplication.this) {
			if (startDialog != null ) {
				tv.setText(getString(R.string.loading_data));
				startDialog.setProgressBar(tv, progressBar, onClose);
			} else if (onClose != null) {
				onClose.run();
			}
		}
	}

	public boolean isApplicationInitializing() {
		return startDialog != null;
	}

	public RoutingHelper getRoutingHelper() {
		return routingHelper;
	}

	public CommandPlayer getPlayer() {
		return player;
	}

	public void initVoiceCommandPlayer(final Activity uiContext) {
		showDialogInitializingCommandPlayer(uiContext, true, null, false);
	}

	public void showDialogInitializingCommandPlayer(final Activity uiContext, boolean warningNoneProvider) {
		showDialogInitializingCommandPlayer(uiContext, warningNoneProvider, null, true);
	}

	public void showDialogInitializingCommandPlayer(final Activity uiContext, boolean warningNoneProvider, Runnable run, boolean showDialog) {
		String voiceProvider = osmandSettings.VOICE_PROVIDER.get();
		if (voiceProvider == null || OsmandSettings.VOICE_PROVIDER_NOT_USE.equals(voiceProvider)) {
			if (warningNoneProvider && voiceProvider == null) {
				Builder builder = new AccessibleAlertBuilder(uiContext);
				LinearLayout ll = new LinearLayout(uiContext);
				ll.setOrientation(LinearLayout.VERTICAL);
				final TextView tv = new TextView(uiContext);
				tv.setPadding(7, 3, 7, 0);
				tv.setText(R.string.voice_is_not_available_msg);
				tv.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 19);
				ll.addView(tv);
				
				final CheckBox cb = new CheckBox(uiContext);
				cb.setText(R.string.remember_choice);
				LinearLayout.LayoutParams lp = new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);
				lp.setMargins(7, 10, 7, 0);
				cb.setLayoutParams(lp);
				ll.addView(cb);
				
				builder.setCancelable(true);
				builder.setNegativeButton(R.string.default_buttons_cancel, new DialogInterface.OnClickListener() {
					@Override
					public void onClick(DialogInterface dialog, int which) {
						if(cb.isChecked()) {
							osmandSettings.VOICE_PROVIDER.set(OsmandSettings.VOICE_PROVIDER_NOT_USE);
						}
					}
				});
				builder.setPositiveButton(R.string.default_buttons_ok, new DialogInterface.OnClickListener() {
					@Override
					public void onClick(DialogInterface dialog, int which) {
						Intent intent = new Intent(uiContext, SettingsActivity.class);
						intent.putExtra(SettingsActivity.INTENT_KEY_SETTINGS_SCREEN, SettingsActivity.SCREEN_GENERAL_SETTINGS);
						uiContext.startActivity(intent);
					}
				});
				
				
				builder.setTitle(R.string.voice_is_not_available_title);
				builder.setView(ll);
				//builder.setMessage(R.string.voice_is_not_available_msg);
				builder.show();
			}

		} else {
			if (player == null || !Algorithms.objectEquals(voiceProvider, player.getCurrentVoice())) {
				initVoiceDataInDifferentThread(uiContext, voiceProvider, run, showDialog);
			}
		}

	}

	private void initVoiceDataInDifferentThread(final Activity uiContext, final String voiceProvider, final Runnable run, boolean showDialog) {
		final ProgressDialog dlg = showDialog ? ProgressDialog.show(uiContext, getString(R.string.loading_data),
				getString(R.string.voice_data_initializing)) : null;
		new Thread(new Runnable() {
			@Override
			public void run() {
				try {
					if (player != null) {
						player.clear();
					}
					player = CommandPlayerFactory.createCommandPlayer(voiceProvider, OsmandApplication.this, uiContext);
					routingHelper.getVoiceRouter().setPlayer(player);
					if(dlg != null) {
						dlg.dismiss();
					}
					if (run != null && uiContext != null) {
						uiContext.runOnUiThread(run);
					}
				} catch (CommandPlayerException e) {
					if(dlg != null) {
						dlg.dismiss();
					}
					showToastMessage(e.getError());
				}
			}
		}).start();
	}

	public NavigationService getNavigationService() {
		return navigationService;
	}

	public void setNavigationService(NavigationService navigationService) {
		this.navigationService = navigationService;
	}


	private void fullExit() {
		// http://stackoverflow.com/questions/2092951/how-to-close-android-application
		System.runFinalizersOnExit(true);
		System.exit(0);
	}

	public synchronized void closeApplication(final Activity activity) {
		if (getNavigationService() != null) {
			Builder bld = new AlertDialog.Builder(activity);
			bld.setMessage(R.string.background_service_is_enabled_question);
			bld.setPositiveButton(R.string.default_buttons_yes, new DialogInterface.OnClickListener() {
				@Override
				public void onClick(DialogInterface dialog, int which) {
					closeApplicationAnyway(activity, true);
				}
			});
			bld.setNegativeButton(R.string.default_buttons_no, new DialogInterface.OnClickListener() {
				@Override
				public void onClick(DialogInterface dialog, int which) {
					closeApplicationAnyway(activity, false);
				}
			});
			bld.show();
		} else {
			closeApplicationAnyway(activity, true);
		}
	}

	private void closeApplicationAnyway(final Activity activity, boolean disableService) {
		if (applicationInitializing) {
			resourceManager.close();
		}
		applicationInitializing = false;

		activity.finish();

		if (getNavigationService() == null) {
			fullExit();
		}
		else if (disableService) {
			final Intent serviceIntent = new Intent(this, NavigationService.class);
			stopService(serviceIntent);

			new Thread(new Runnable() {
				public void run() {
					//wait until the service has fully stopped
					while (getNavigationService() != null) {
						try {
							Thread.sleep(100);
						}
							catch (InterruptedException e) {
						}
					}

					fullExit();
				}
			}).start();
		}
	}

	public synchronized void startApplication() {
		if (applicationInitializing) {
			return;
		}
		applicationInitializing = true;
		startDialog = new ProgressImplementation(this, null, false);

		startDialog.setRunnable("Initializing app", new Runnable() { //$NON-NLS-1$
					@Override
					public void run() {
						startApplicationBackground();
					}
				});
		startDialog.run();

		Thread.setDefaultUncaughtExceptionHandler(new DefaultExceptionHandler());

	}

	private void startApplicationBackground() {
		List<String> warnings = new ArrayList<String>();
		try {
			try {
				SpecialPhrases.setLanguage(this, osmandSettings);
			} catch (IOException e) {
				LOG.error("I/O exception", e);
				warnings.add("Error while reading the special phrases. Restart OsmAnd if possible");
			}
			if (!Version.isBlackberry(this)) {
				if (osmandSettings.NATIVE_RENDERING_FAILED.get()) {
					osmandSettings.SAFE_MODE.set(true);
					osmandSettings.NATIVE_RENDERING_FAILED.set(false);
					warnings.add(getString(R.string.native_library_not_supported));
				} else {
					osmandSettings.SAFE_MODE.set(false);
					osmandSettings.NATIVE_RENDERING_FAILED.set(true);
					startDialog.startTask(getString(R.string.init_native_library), -1);
					RenderingRulesStorage storage = rendererRegistry.getCurrentSelectedRenderer();
					boolean initialized = NativeOsmandLibrary.getLibrary(storage, this) != null;
					osmandSettings.NATIVE_RENDERING_FAILED.set(false);
					if (!initialized) {
						LOG.info("Native library could not be loaded!");
					}
				}
			}
			warnings.addAll(resourceManager.reloadIndexes(startDialog));
			player = null;
			if (savingTrackHelper.hasDataToSave()) {
				startDialog.startTask(getString(R.string.saving_gpx_tracks), -1);
				try {
					warnings.addAll(savingTrackHelper.saveDataToGpx());
				} catch (RuntimeException e) {
					warnings.add(e.getMessage());
				}
			}

			// restore backuped favorites to normal file
			final File appDir = getAppPath(null);
			File save = new File(appDir, FavouritesDbHelper.FILE_TO_SAVE);
			File bak = new File(appDir, FavouritesDbHelper.FILE_TO_BACKUP);
			if (bak.exists() && (!save.exists() || bak.lastModified() > save.lastModified())) {
				if (save.exists()) {
					save.delete();
				}
				bak.renameTo(save);
			}
		} catch (RuntimeException e) {
			e.printStackTrace();
			warnings.add(e.getMessage());
		} finally {
			synchronized (OsmandApplication.this) {
				final ProgressDialog toDismiss;
				final Runnable pb;
				if (startDialog != null) {
					toDismiss = startDialog.getDialog();
					pb = startDialog.getFinishRunnable();
				} else {
					toDismiss = null;
					pb = null;
				}
				startDialog = null;

				if (toDismiss != null || pb != null) {
					uiHandler.post(new Runnable() {
						@Override
						public void run() {
							if(pb != null) {
								pb.run();
							}
							if (toDismiss != null) {
								// TODO handling this dialog is bad, we need a better standard way
								toDismiss.dismiss();
								// toDismiss.getOwnerActivity().dismissDialog(PROGRESS_DIALOG);
							}
						}
					});
				}
				if (warnings != null && !warnings.isEmpty()) {
					showToastMessage(formatWarnings(warnings).toString());
				}
			}
		}
	}

	private StringBuilder formatWarnings(List<String> warnings) {
		final StringBuilder b = new StringBuilder();
		boolean f = true;
		for (String w : warnings) {
			if (f) {
				f = false;
			} else {
				b.append('\n');
			}
			b.append(w);
		}
		return b;
	}


	private class DefaultExceptionHandler implements UncaughtExceptionHandler {

		private UncaughtExceptionHandler defaultHandler;
		private PendingIntent intent;

		public DefaultExceptionHandler() {
			defaultHandler = Thread.getDefaultUncaughtExceptionHandler();
			intent = PendingIntent.getActivity(OsmandApplication.this.getBaseContext(), 0,
					new Intent(OsmandApplication.this.getBaseContext(),
							getAppCustomization().getMainMenuActivity()), 0);
		}

		@Override
		public void uncaughtException(final Thread thread, final Throwable ex) {
			File file = getAppPath(EXCEPTION_PATH);
			try {
				ByteArrayOutputStream out = new ByteArrayOutputStream();
				PrintStream printStream = new PrintStream(out);
				ex.printStackTrace(printStream);
				StringBuilder msg = new StringBuilder();
				msg.append("Version  " + Version.getFullVersion(OsmandApplication.this) + "\n"). //$NON-NLS-1$ 
						append(DateFormat.format("dd.MM.yyyy h:mm:ss", System.currentTimeMillis()));
				try {
					PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), 0);
					if (info != null) {
						msg.append("\nApk Version : ").append(info.versionName).append(" ").append(info.versionCode); //$NON-NLS-1$ //$NON-NLS-2$
					}
				} catch (Throwable e) {
				}
				msg.append("\n"). //$NON-NLS-1$//$NON-NLS-2$
						append("Exception occured in thread " + thread.toString() + " : \n"). //$NON-NLS-1$ //$NON-NLS-2$
						append(new String(out.toByteArray()));

				if (file.getParentFile().canWrite()) {
					BufferedWriter writer = new BufferedWriter(new FileWriter(file, true));
					writer.write(msg.toString());
					writer.close();
				}
				if (routingHelper.isFollowingMode()) {
					AlarmManager mgr = (AlarmManager) getSystemService(Context.ALARM_SERVICE);
					mgr.set(AlarmManager.RTC, System.currentTimeMillis() + 2000, intent);
					System.exit(2);
				}
				defaultHandler.uncaughtException(thread, ex);
			} catch (Exception e) {
				// swallow all exceptions
				android.util.Log.e(PlatformUtil.TAG, "Exception while handle other exception", e); //$NON-NLS-1$
			}

		}
	}

	
	public TargetPointsHelper getTargetPointsHelper() {
		return targetPointsHelper;
	}
	
	public void showShortToastMessage(int msgId, Object... args) {
		AccessibleToast.makeText(this, getString(msgId, args), Toast.LENGTH_SHORT).show();
	}

	public void showToastMessage(int msgId, Object... args) {
		AccessibleToast.makeText(this, getString(msgId, args), Toast.LENGTH_LONG).show();
	}

	public void showToastMessage(String msg) {
		AccessibleToast.makeText(this, msg, Toast.LENGTH_LONG).show();		
	}
	
	public SQLiteAPI getSQLiteAPI() {
		return sqliteAPI;
	}

	public void runInUIThread(Runnable run) {
		uiHandler.post(run);
	}

	public void runInUIThread(Runnable run, long delay) {
		uiHandler.postDelayed(run, delay);
	}
	
	public void runMessageInUIThreadAndCancelPrevious(final int messageId, final Runnable run, long delay) {
		Message msg = Message.obtain(uiHandler, new Runnable() {
			
			@Override
			public void run() {
				if(!uiHandler.hasMessages(messageId)) {
					run.run();
				}
			}
		});
		msg.what = messageId;
		uiHandler.removeMessages(messageId);
		uiHandler.sendMessageDelayed(msg, delay);
	}
	
	public File getAppPath(String path) {
		if(path == null) {
			path = "";
		}
		return new File(getSettings().getExternalStorageDirectory(), IndexConstants.APP_DIR + path);
	}

	public void applyTheme(Context c) {
		int t = R.style.OsmandLightDarkActionBarTheme;
		if (osmandSettings.OSMAND_THEME.get() == OsmandSettings.OSMAND_DARK_THEME) {
			t = R.style.OsmandDarkTheme;
		} else if (osmandSettings.OSMAND_THEME.get() == OsmandSettings.OSMAND_LIGHT_THEME) {
			t = R.style.OsmandLightTheme;
		} else if (osmandSettings.OSMAND_THEME.get() == OsmandSettings.OSMAND_LIGHT_DARK_ACTIONBAR_THEME) {
			t = R.style.OsmandLightDarkActionBarTheme;
		}
		setLanguage(c);
		c.setTheme(t);
		if (osmandSettings.OSMAND_THEME.get() == OsmandSettings.OSMAND_LIGHT_DARK_ACTIONBAR_THEME
				&& Build.VERSION.SDK_INT < Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
			ActionBar ab = null;
			if (c instanceof SherlockActivity) {
				ab = ((SherlockActivity) c).getSupportActionBar();
			} else if (c instanceof SherlockListActivity) {
				ab = ((SherlockListActivity) c).getSupportActionBar();
			} else if (c instanceof SherlockExpandableListActivity) {
				ab = ((SherlockExpandableListActivity) c).getSupportActionBar();
			}
			if (ab != null) {
				BitmapDrawable bg = (BitmapDrawable) getResources().getDrawable(R.drawable.bg_striped);
				bg.setTileModeXY(TileMode.REPEAT, TileMode.REPEAT);
				ab.setBackgroundDrawable(bg);
			}
		}
	}
	
	public IBRouterService getBRouterService() {
		if(bRouterServiceConnection == null) {
			return null;
		}
		return bRouterServiceConnection.getBrouterService();
	}
	
	public void setLanguage(Context context) {
		if (prefferedLocale != null) {
			Configuration config = context.getResources().getConfiguration();
			String lang = prefferedLocale.getLanguage();
			if (!"".equals(lang) && !config.locale.getLanguage().equals(lang)) {
				prefferedLocale = new Locale(lang);
				Locale.setDefault(prefferedLocale);
				config.locale = prefferedLocale;
				context.getResources().updateConfiguration(config, context.getResources().getDisplayMetrics());
			}
		}
	}
	
	public RoutingConfiguration.Builder getDefaultRoutingConfig() {
		if (defaultRoutingConfig == null) {
			File routingXml = getAppPath(IndexConstants.ROUTING_XML_FILE);
			if (routingXml.exists() && routingXml.canRead()) {
				try {
					defaultRoutingConfig = RoutingConfiguration.parseFromInputStream(new FileInputStream(routingXml));
				} catch (XmlPullParserException e) {
					throw new IllegalStateException(e);
				} catch (IOException e) {
					throw new IllegalStateException(e);
				}
			} else {
				defaultRoutingConfig = RoutingConfiguration.getDefault();
			}
		}
		return defaultRoutingConfig;
	}
	
	public boolean accessibilityExtensions() {
		return (Build.VERSION.SDK_INT < 14) ? getSettings().ACCESSIBILITY_EXTENSIONS.get() : false;
	}
	
	public boolean accessibilityEnabled() {
		final AccessibilityMode mode = getSettings().ACCESSIBILITY_MODE.get();
		if(OsmandPlugin.getEnabledPlugin(AccessibilityPlugin.class) == null) {
			return false;
		}
		if (mode == AccessibilityMode.ON) {
			return true;
		} else if (mode == AccessibilityMode.OFF) {
			return false;
		}
		return ((AccessibilityManager) getSystemService(Context.ACCESSIBILITY_SERVICE)).isEnabled();
	}

	public String getVersionName() {
		try {
			PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), 0);
			return info.versionName;
		} catch (NameNotFoundException e) {
			return "";
		}
	}

	public int getVersionCode() {
		try {
			PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), 0);
			return info.versionCode;
		} catch (NameNotFoundException e) {
			return 0;
		}
	}

	public void startNavigationService(int intent) {
		final Intent serviceIntent = new Intent(this, NavigationService.class);
		serviceIntent.putExtra(NavigationService.USAGE_INTENT, intent);
		if (getNavigationService() == null) {
			getSettings().SERVICE_OFF_INTERVAL.set(0);
			startService(serviceIntent);
		} else {
			getNavigationService().addUsageIntent(intent);
		}		
	}
}
!@#$%
20190530_010530,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_a00688
package net.osmand.plus;

import java.io.BufferedWriter;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintStream;
import java.lang.Thread.UncaughtExceptionHandler;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

import net.osmand.IndexConstants;
import net.osmand.PlatformUtil;
import net.osmand.access.AccessibilityPlugin;
import net.osmand.access.AccessibleAlertBuilder;
import net.osmand.access.AccessibleToast;
import net.osmand.data.FavouritePoint;
import net.osmand.plus.GPXUtilities.GPXFile;
import net.osmand.plus.GPXUtilities.WptPt;
import net.osmand.plus.access.AccessibilityMode;
import net.osmand.plus.activities.DayNightHelper;
import net.osmand.plus.activities.SavingTrackHelper;
import net.osmand.plus.activities.SettingsActivity;
import net.osmand.plus.api.SQLiteAPI;
import net.osmand.plus.api.SQLiteAPIImpl;
import net.osmand.plus.monitoring.LiveMonitoringHelper;
import net.osmand.plus.render.NativeOsmandLibrary;
import net.osmand.plus.render.RendererRegistry;
import net.osmand.plus.resources.ResourceManager;
import net.osmand.plus.routing.RoutingHelper;
import net.osmand.plus.voice.CommandPlayer;
import net.osmand.plus.voice.CommandPlayerException;
import net.osmand.plus.voice.CommandPlayerFactory;
import net.osmand.render.RenderingRulesStorage;
import net.osmand.router.RoutingConfiguration;
import net.osmand.util.Algorithms;

import org.xmlpull.v1.XmlPullParserException;

import android.app.Activity;
import android.app.AlarmManager;
import android.app.AlertDialog;
import android.app.AlertDialog.Builder;
import android.app.Application;
import android.app.PendingIntent;
import android.app.ProgressDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager.NameNotFoundException;
import android.content.res.Configuration;
import android.graphics.Shader.TileMode;
import android.graphics.drawable.BitmapDrawable;
import android.os.Build;
import android.os.Handler;
import android.os.Message;
import android.text.format.DateFormat;
import android.util.TypedValue;
import android.view.accessibility.AccessibilityManager;
import android.widget.CheckBox;
import android.widget.LinearLayout;
import android.widget.ProgressBar;
import android.widget.LinearLayout.LayoutParams;
import android.widget.TextView;
import android.widget.Toast;
import btools.routingapp.BRouterServiceConnection;
import btools.routingapp.IBRouterService;

import com.actionbarsherlock.app.ActionBar;
import com.actionbarsherlock.app.SherlockActivity;
import com.actionbarsherlock.app.SherlockExpandableListActivity;
import com.actionbarsherlock.app.SherlockListActivity;


public class OsmandApplication extends Application {
	public static final String EXCEPTION_PATH = "exception.log"; //$NON-NLS-1$
	private static final org.apache.commons.logging.Log LOG = PlatformUtil.getLog(OsmandApplication.class);

	
	ResourceManager resourceManager = null;
	PoiFiltersHelper poiFilters = null;
	RoutingHelper routingHelper = null;
	FavouritesDbHelper favorites = null;
	CommandPlayer player = null;

	OsmandSettings osmandSettings = null;

	OsmAndAppCustomization appCustomization;
	DayNightHelper daynightHelper;
	NavigationService navigationService;
	RendererRegistry rendererRegistry;
	OsmAndLocationProvider locationProvider;
	OsmAndTaskManager taskManager;

	// start variables
	private ProgressImplementation startDialog;
	private Handler uiHandler;
	private GPXFile gpxFileToDisplay;
	private SavingTrackHelper savingTrackHelper;
	private LiveMonitoringHelper liveMonitoringHelper;
	private TargetPointsHelper targetPointsHelper;
	private RoutingConfiguration.Builder defaultRoutingConfig;

	private boolean applicationInitializing = false;
	private Locale prefferedLocale = null;
	
	SQLiteAPI sqliteAPI;
	BRouterServiceConnection bRouterServiceConnection;

	@Override
	public void onCreate() {
		long timeToStart = System.currentTimeMillis();
		if (Version.getAppName(this).equals("OsmAnd~")) {
			if (android.os.Build.VERSION.SDK_INT >= 9) {
				try {
					Class.forName("net.osmand.plus.base.EnableStrictMode").newInstance();
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		}
		super.onCreate();
		appCustomization = new OsmAndAppCustomization();
		appCustomization.setup(this);
		 
		sqliteAPI = new SQLiteAPIImpl(this);
		try {
			bRouterServiceConnection = BRouterServiceConnection.connect(this);
		} catch(Exception e) {
			e.printStackTrace();
		}

		// settings used everywhere so they need to be created first
		osmandSettings = appCustomization.createSettings(new net.osmand.plus.api.SettingsAPIImpl(this));
		// always update application mode to default
		if(!osmandSettings.FOLLOW_THE_ROUTE.get()){
			osmandSettings.APPLICATION_MODE.set(osmandSettings.DEFAULT_APPLICATION_MODE.get());
		}
		
		applyTheme(this);
		
		routingHelper = new RoutingHelper(this, player);
		taskManager = new OsmAndTaskManager(this);
		resourceManager = new ResourceManager(this);
		daynightHelper = new DayNightHelper(this);
		locationProvider = new OsmAndLocationProvider(this);
		savingTrackHelper = new SavingTrackHelper(this);
		liveMonitoringHelper = new LiveMonitoringHelper(this);
		uiHandler = new Handler();
		rendererRegistry = new RendererRegistry();
		targetPointsHelper = new TargetPointsHelper(this);
//		if(!osmandSettings.FOLLOW_THE_ROUTE.get()) {
//			targetPointsHelper.clearPointToNavigate(false);
//		}
		
		checkPrefferedLocale();
		startApplication();
		if (LOG.isDebugEnabled()) {
			LOG.debug("Time to start application " + (System.currentTimeMillis() - timeToStart) + " ms. Should be less < 800 ms");
		}
		timeToStart = System.currentTimeMillis();
		OsmandPlugin.initPlugins(this);

		if (LOG.isDebugEnabled()) {
			LOG.debug("Time to init plugins " + (System.currentTimeMillis() - timeToStart) + " ms. Should be less < 800 ms");
		}
		
		
	}

	@Override
	public void onTerminate() {
		super.onTerminate();
		if (routingHelper != null) {
			routingHelper.getVoiceRouter().onApplicationTerminate(this);
		}
	}

	public RendererRegistry getRendererRegistry() {
		return rendererRegistry;
	}
	
	public OsmAndTaskManager getTaskManager() {
		return taskManager;
	}

	
	public OsmAndLocationProvider getLocationProvider() {
		return locationProvider;
	}
	
	public OsmAndAppCustomization getAppCustomization() {
		return appCustomization;
	}
	
	public void setAppCustomization(OsmAndAppCustomization appCustomization) {
		this.appCustomization = appCustomization;
		this.appCustomization.setup(this);
	}

	/**
	 * Application settings
	 * 
	 * @return Reference to instance of OsmandSettings
	 */
	public OsmandSettings getSettings() {
		if (osmandSettings == null) {
			LOG.error("Trying to access settings before they were created");
		}
		return osmandSettings;
	}

	public SavingTrackHelper getSavingTrackHelper() {
		return savingTrackHelper;
	}

	public LiveMonitoringHelper getLiveMonitoringHelper() {
		return liveMonitoringHelper;
	}

	public PoiFiltersHelper getPoiFilters() {
		if (poiFilters == null) {
			poiFilters = new PoiFiltersHelper(this);
		}
		return poiFilters;
	}

	public void setGpxFileToDisplay(GPXFile gpxFileToDisplay, boolean showCurrentGpxFile) {
		this.gpxFileToDisplay = gpxFileToDisplay;
		osmandSettings.SHOW_CURRENT_GPX_TRACK.set(showCurrentGpxFile);
		if (gpxFileToDisplay == null) {
			getFavorites().setFavoritePointsFromGPXFile(null);
		} else {
			List<FavouritePoint> pts = new ArrayList<FavouritePoint>();
			for (WptPt p : gpxFileToDisplay.points) {
				FavouritePoint pt = new FavouritePoint();
				pt.setLatitude(p.lat);
				pt.setLongitude(p.lon);
				if (p.name == null) {
					p.name = "";
				}
				pt.setName(p.name);
				pts.add(pt);
			}
			gpxFileToDisplay.proccessPoints();
			getFavorites().setFavoritePointsFromGPXFile(pts);
		}
	}

	public GPXFile getGpxFileToDisplay() {
		return gpxFileToDisplay;
	}

	public FavouritesDbHelper getFavorites() {
		if (favorites == null) {
			favorites = new FavouritesDbHelper(this);
		}
		return favorites;
	}

	public ResourceManager getResourceManager() {
		return resourceManager;
	}

	public DayNightHelper getDaynightHelper() {
		return daynightHelper;
	}

	@Override
	public void onLowMemory() {
		super.onLowMemory();
		resourceManager.onLowMemory();
	}

	@Override
	public void onConfigurationChanged(Configuration newConfig) {
		if (prefferedLocale != null && !newConfig.locale.getLanguage().equals(prefferedLocale.getLanguage())) {
			super.onConfigurationChanged(newConfig);
			// ugly fix ! On devices after 4.0 screen is blinking when you rotate device!
			if (Build.VERSION.SDK_INT < 14) {
				newConfig.locale = prefferedLocale;
			}
			getBaseContext().getResources().updateConfiguration(newConfig, getBaseContext().getResources().getDisplayMetrics());
			Locale.setDefault(prefferedLocale);
		} else {
			super.onConfigurationChanged(newConfig);
		}
	}

	public void checkPrefferedLocale() {
		Configuration config = getBaseContext().getResources().getConfiguration();
		String lang = osmandSettings.PREFERRED_LOCALE.get();
		if (!"".equals(lang) && !config.locale.getLanguage().equals(lang)) {
			prefferedLocale = new Locale(lang);
			Locale.setDefault(prefferedLocale);
			config.locale = prefferedLocale;
			getBaseContext().getResources().updateConfiguration(config, getBaseContext().getResources().getDisplayMetrics());
		}
		String clang = "".equals(lang) ? config.locale.getLanguage() : lang;
		resourceManager.getOsmandRegions().setLocale(clang);

	}

	public static final int PROGRESS_DIALOG = 5;

	public void checkApplicationIsBeingInitialized(Activity activity, ProgressDialog progressDialog) {
		// start application if it was previously closed
		startApplication();
		synchronized (OsmandApplication.this) {
			if (startDialog != null) {
				progressDialog.setTitle(getString(R.string.loading_data));
				progressDialog.setMessage(getString(R.string.reading_indexes));
				activity.showDialog(PROGRESS_DIALOG);
				startDialog.setDialog(progressDialog);
			} else {
				progressDialog.dismiss();
			}
		}
	}
	
	public void checkApplicationIsBeingInitialized(Activity activity, TextView tv, ProgressBar progressBar,
			Runnable onClose) {
		// start application if it was previously closed
		startApplication();
		synchronized (OsmandApplication.this) {
			if (startDialog != null ) {
				tv.setText(getString(R.string.loading_data));
				startDialog.setProgressBar(tv, progressBar, onClose);
			} else if (onClose != null) {
				onClose.run();
			}
		}
	}

	public boolean isApplicationInitializing() {
		return startDialog != null;
	}

	public RoutingHelper getRoutingHelper() {
		return routingHelper;
	}

	public CommandPlayer getPlayer() {
		return player;
	}

	public void initVoiceCommandPlayer(final Activity uiContext) {
		showDialogInitializingCommandPlayer(uiContext, true, null, false);
	}

	public void showDialogInitializingCommandPlayer(final Activity uiContext, boolean warningNoneProvider) {
		showDialogInitializingCommandPlayer(uiContext, warningNoneProvider, null, true);
	}

	public void showDialogInitializingCommandPlayer(final Activity uiContext, boolean warningNoneProvider, Runnable run, boolean showDialog) {
		String voiceProvider = osmandSettings.VOICE_PROVIDER.get();
		if (voiceProvider == null || OsmandSettings.VOICE_PROVIDER_NOT_USE.equals(voiceProvider)) {
			if (warningNoneProvider && voiceProvider == null) {
				Builder builder = new AccessibleAlertBuilder(uiContext);
				LinearLayout ll = new LinearLayout(uiContext);
				ll.setOrientation(LinearLayout.VERTICAL);
				final TextView tv = new TextView(uiContext);
				tv.setPadding(7, 3, 7, 0);
				tv.setText(R.string.voice_is_not_available_msg);
				tv.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 19);
				ll.addView(tv);
				
				final CheckBox cb = new CheckBox(uiContext);
				cb.setText(R.string.remember_choice);
				LinearLayout.LayoutParams lp = new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);
				lp.setMargins(7, 10, 7, 0);
				cb.setLayoutParams(lp);
				ll.addView(cb);
				
				builder.setCancelable(true);
				builder.setNegativeButton(R.string.default_buttons_cancel, new DialogInterface.OnClickListener() {
					@Override
					public void onClick(DialogInterface dialog, int which) {
						if(cb.isChecked()) {
							osmandSettings.VOICE_PROVIDER.set(OsmandSettings.VOICE_PROVIDER_NOT_USE);
						}
					}
				});
				builder.setPositiveButton(R.string.default_buttons_ok, new DialogInterface.OnClickListener() {
					@Override
					public void onClick(DialogInterface dialog, int which) {
						Intent intent = new Intent(uiContext, SettingsActivity.class);
						intent.putExtra(SettingsActivity.INTENT_KEY_SETTINGS_SCREEN, SettingsActivity.SCREEN_GENERAL_SETTINGS);
						uiContext.startActivity(intent);
					}
				});
				
				
				builder.setTitle(R.string.voice_is_not_available_title);
				builder.setView(ll);
				//builder.setMessage(R.string.voice_is_not_available_msg);
				builder.show();
			}

		} else {
			if (player == null || !Algorithms.objectEquals(voiceProvider, player.getCurrentVoice())) {
				initVoiceDataInDifferentThread(uiContext, voiceProvider, run, showDialog);
			}
		}

	}

	private void initVoiceDataInDifferentThread(final Activity uiContext, final String voiceProvider, final Runnable run, boolean showDialog) {
		final ProgressDialog dlg = showDialog ? ProgressDialog.show(uiContext, getString(R.string.loading_data),
				getString(R.string.voice_data_initializing)) : null;
		new Thread(new Runnable() {
			@Override
			public void run() {
				try {
					if (player != null) {
						player.clear();
					}
					player = CommandPlayerFactory.createCommandPlayer(voiceProvider, OsmandApplication.this, uiContext);
					routingHelper.getVoiceRouter().setPlayer(player);
					if(dlg != null) {
						dlg.dismiss();
					}
					if (run != null && uiContext != null) {
						uiContext.runOnUiThread(run);
					}
				} catch (CommandPlayerException e) {
					if(dlg != null) {
						dlg.dismiss();
					}
					showToastMessage(e.getError());
				}
			}
		}).start();
	}

	public NavigationService getNavigationService() {
		return navigationService;
	}

	public void setNavigationService(NavigationService navigationService) {
		this.navigationService = navigationService;
	}


	private void fullExit() {
		// http://stackoverflow.com/questions/2092951/how-to-close-android-application
		System.runFinalizersOnExit(true);
		System.exit(0);
	}

	public synchronized void closeApplication(final Activity activity) {
		if (getNavigationService() != null) {
			Builder bld = new AlertDialog.Builder(activity);
			bld.setMessage(R.string.background_service_is_enabled_question);
			bld.setPositiveButton(R.string.default_buttons_yes, new DialogInterface.OnClickListener() {
				@Override
				public void onClick(DialogInterface dialog, int which) {
					closeApplicationAnyway(activity, true);
				}
			});
			bld.setNegativeButton(R.string.default_buttons_no, new DialogInterface.OnClickListener() {
				@Override
				public void onClick(DialogInterface dialog, int which) {
					closeApplicationAnyway(activity, false);
				}
			});
			bld.show();
		} else {
			closeApplicationAnyway(activity, true);
		}
	}

	private void closeApplicationAnyway(final Activity activity, boolean disableService) {
		if (applicationInitializing) {
			resourceManager.close();
		}
		applicationInitializing = false;

		activity.finish();

		if (getNavigationService() == null) {
			fullExit();
		}
		else if (disableService) {
			final Intent serviceIntent = new Intent(this, NavigationService.class);
			stopService(serviceIntent);

			new Thread(new Runnable() {
				public void run() {
					//wait until the service has fully stopped
					while (getNavigationService() != null) {
						try {
							Thread.sleep(100);
						}
							catch (InterruptedException e) {
						}
					}

					fullExit();
				}
			}).start();
		}
	}

	public synchronized void startApplication() {
		if (applicationInitializing) {
			return;
		}
		applicationInitializing = true;
		startDialog = new ProgressImplementation(this, null, false);

		startDialog.setRunnable("Initializing app", new Runnable() { //$NON-NLS-1$
					@Override
					public void run() {
						startApplicationBackground();
					}
				});
		startDialog.run();

		Thread.setDefaultUncaughtExceptionHandler(new DefaultExceptionHandler());

	}

	private void startApplicationBackground() {
		List<String> warnings = new ArrayList<String>();
		try {
			try {
				SpecialPhrases.setLanguage(this, osmandSettings);
			} catch (IOException e) {
				LOG.error("I/O exception", e);
				warnings.add("Error while reading the special phrases. Restart OsmAnd if possible");
			}
			if (!Version.isBlackberry(this)) {
				if (osmandSettings.NATIVE_RENDERING_FAILED.get()) {
					osmandSettings.SAFE_MODE.set(true);
					osmandSettings.NATIVE_RENDERING_FAILED.set(false);
					warnings.add(getString(R.string.native_library_not_supported));
				} else {
					osmandSettings.SAFE_MODE.set(false);
					osmandSettings.NATIVE_RENDERING_FAILED.set(true);
					startDialog.startTask(getString(R.string.init_native_library), -1);
					RenderingRulesStorage storage = rendererRegistry.getCurrentSelectedRenderer();
					boolean initialized = NativeOsmandLibrary.getLibrary(storage, this) != null;
					osmandSettings.NATIVE_RENDERING_FAILED.set(false);
					if (!initialized) {
						LOG.info("Native library could not be loaded!");
					}
				}
			}
			warnings.addAll(resourceManager.reloadIndexes(startDialog));
			player = null;
			if (savingTrackHelper.hasDataToSave()) {
				startDialog.startTask(getString(R.string.saving_gpx_tracks), -1);
				try {
					warnings.addAll(savingTrackHelper.saveDataToGpx());
				} catch (RuntimeException e) {
					warnings.add(e.getMessage());
				}
			}

			// restore backuped favorites to normal file
			final File appDir = getAppPath(null);
			File save = new File(appDir, FavouritesDbHelper.FILE_TO_SAVE);
			File bak = new File(appDir, FavouritesDbHelper.FILE_TO_BACKUP);
			if (bak.exists() && (!save.exists() || bak.lastModified() > save.lastModified())) {
				if (save.exists()) {
					save.delete();
				}
				bak.renameTo(save);
			}
		} catch (RuntimeException e) {
			e.printStackTrace();
			warnings.add(e.getMessage());
		} finally {
			synchronized (OsmandApplication.this) {
				final ProgressDialog toDismiss;
				final Runnable pb;
				if (startDialog != null) {
					toDismiss = startDialog.getDialog();
					pb = startDialog.getFinishRunnable();
				} else {
					toDismiss = null;
					pb = null;
				}
				startDialog = null;

				if (toDismiss != null || pb != null) {
					uiHandler.post(new Runnable() {
						@Override
						public void run() {
							if(pb != null) {
								pb.run();
							}
							if (toDismiss != null) {
								// TODO handling this dialog is bad, we need a better standard way
								toDismiss.dismiss();
								// toDismiss.getOwnerActivity().dismissDialog(PROGRESS_DIALOG);
							}
						}
					});
				}
				if (warnings != null && !warnings.isEmpty()) {
					showToastMessage(formatWarnings(warnings).toString());
				}
			}
		}
	}

	private StringBuilder formatWarnings(List<String> warnings) {
		final StringBuilder b = new StringBuilder();
		boolean f = true;
		for (String w : warnings) {
			if (f) {
				f = false;
			} else {
				b.append('\n');
			}
			b.append(w);
		}
		return b;
	}


	private class DefaultExceptionHandler implements UncaughtExceptionHandler {

		private UncaughtExceptionHandler defaultHandler;
		private PendingIntent intent;

		public DefaultExceptionHandler() {
			defaultHandler = Thread.getDefaultUncaughtExceptionHandler();
			intent = PendingIntent.getActivity(OsmandApplication.this.getBaseContext(), 0,
					new Intent(OsmandApplication.this.getBaseContext(),
							getAppCustomization().getMainMenuActivity()), 0);
		}

		@Override
		public void uncaughtException(final Thread thread, final Throwable ex) {
			File file = getAppPath(EXCEPTION_PATH);
			try {
				ByteArrayOutputStream out = new ByteArrayOutputStream();
				PrintStream printStream = new PrintStream(out);
				ex.printStackTrace(printStream);
				StringBuilder msg = new StringBuilder();
				msg.append("Version  " + Version.getFullVersion(OsmandApplication.this) + "\n"). //$NON-NLS-1$ 
						append(DateFormat.format("dd.MM.yyyy h:mm:ss", System.currentTimeMillis()));
				try {
					PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), 0);
					if (info != null) {
						msg.append("\nApk Version : ").append(info.versionName).append(" ").append(info.versionCode); //$NON-NLS-1$ //$NON-NLS-2$
					}
				} catch (Throwable e) {
				}
				msg.append("\n"). //$NON-NLS-1$//$NON-NLS-2$
						append("Exception occured in thread " + thread.toString() + " : \n"). //$NON-NLS-1$ //$NON-NLS-2$
						append(new String(out.toByteArray()));

				if (file.getParentFile().canWrite()) {
					BufferedWriter writer = new BufferedWriter(new FileWriter(file, true));
					writer.write(msg.toString());
					writer.close();
				}
				if (routingHelper.isFollowingMode()) {
					AlarmManager mgr = (AlarmManager) getSystemService(Context.ALARM_SERVICE);
					mgr.set(AlarmManager.RTC, System.currentTimeMillis() + 2000, intent);
					System.exit(2);
				}
				defaultHandler.uncaughtException(thread, ex);
			} catch (Exception e) {
				// swallow all exceptions
				android.util.Log.e(PlatformUtil.TAG, "Exception while handle other exception", e); //$NON-NLS-1$
			}

		}
	}

	
	public TargetPointsHelper getTargetPointsHelper() {
		return targetPointsHelper;
	}
	
	public void showShortToastMessage(int msgId, Object... args) {
		AccessibleToast.makeText(this, getString(msgId, args), Toast.LENGTH_SHORT).show();
	}

	public void showToastMessage(int msgId, Object... args) {
		AccessibleToast.makeText(this, getString(msgId, args), Toast.LENGTH_LONG).show();
	}

	public void showToastMessage(String msg) {
		AccessibleToast.makeText(this, msg, Toast.LENGTH_LONG).show();		
	}
	
	public SQLiteAPI getSQLiteAPI() {
		return sqliteAPI;
	}

	public void runInUIThread(Runnable run) {
		uiHandler.post(run);
	}

	public void runInUIThread(Runnable run, long delay) {
		uiHandler.postDelayed(run, delay);
	}
	
	public void runMessageInUIThreadAndCancelPrevious(final int messageId, final Runnable run, long delay) {
		Message msg = Message.obtain(uiHandler, new Runnable() {
			
			@Override
			public void run() {
				if(!uiHandler.hasMessages(messageId)) {
					run.run();
				}
			}
		});
		msg.what = messageId;
		uiHandler.removeMessages(messageId);
		uiHandler.sendMessageDelayed(msg, delay);
	}
	
	public File getAppPath(String path) {
		if(path == null) {
			path = "";
		}
		return new File(getSettings().getExternalStorageDirectory(), IndexConstants.APP_DIR + path);
	}

	public void applyTheme(Context c) {
		int t = R.style.OsmandLightDarkActionBarTheme;
		if (osmandSettings.OSMAND_THEME.get() == OsmandSettings.OSMAND_DARK_THEME) {
			t = R.style.OsmandDarkTheme;
		} else if (osmandSettings.OSMAND_THEME.get() == OsmandSettings.OSMAND_LIGHT_THEME) {
			t = R.style.OsmandLightTheme;
		} else if (osmandSettings.OSMAND_THEME.get() == OsmandSettings.OSMAND_LIGHT_DARK_ACTIONBAR_THEME) {
			t = R.style.OsmandLightDarkActionBarTheme;
		}
		setLanguage(c);
		c.setTheme(t);
		if (osmandSettings.OSMAND_THEME.get() == OsmandSettings.OSMAND_LIGHT_DARK_ACTIONBAR_THEME
				&& Build.VERSION.SDK_INT < Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
			ActionBar ab = null;
			if (c instanceof SherlockActivity) {
				ab = ((SherlockActivity) c).getSupportActionBar();
			} else if (c instanceof SherlockListActivity) {
				ab = ((SherlockListActivity) c).getSupportActionBar();
			} else if (c instanceof SherlockExpandableListActivity) {
				ab = ((SherlockExpandableListActivity) c).getSupportActionBar();
			}
			if (ab != null) {
				BitmapDrawable bg = (BitmapDrawable) getResources().getDrawable(R.drawable.bg_striped);
				bg.setTileModeXY(TileMode.REPEAT, TileMode.REPEAT);
				ab.setBackgroundDrawable(bg);
			}
		}
	}
	
	public IBRouterService getBRouterService() {
		if(bRouterServiceConnection == null) {
			return null;
		}
		return bRouterServiceConnection.getBrouterService();
	}
	
	public void setLanguage(Context context) {
		if (prefferedLocale != null) {
			Configuration config = context.getResources().getConfiguration();
			String lang = prefferedLocale.getLanguage();
			if (!"".equals(lang) && !config.locale.getLanguage().equals(lang)) {
				prefferedLocale = new Locale(lang);
				Locale.setDefault(prefferedLocale);
				config.locale = prefferedLocale;
				context.getResources().updateConfiguration(config, context.getResources().getDisplayMetrics());
			}
		}
	}
	
	public RoutingConfiguration.Builder getDefaultRoutingConfig() {
		if (defaultRoutingConfig == null) {
			File routingXml = getAppPath(IndexConstants.ROUTING_XML_FILE);
			if (routingXml.exists() && routingXml.canRead()) {
				try {
					defaultRoutingConfig = RoutingConfiguration.parseFromInputStream(new FileInputStream(routingXml));
				} catch (XmlPullParserException e) {
					throw new IllegalStateException(e);
				} catch (IOException e) {
					throw new IllegalStateException(e);
				}
			} else {
				defaultRoutingConfig = RoutingConfiguration.getDefault();
			}
		}
		return defaultRoutingConfig;
	}
	
	public boolean accessibilityExtensions() {
		return (Build.VERSION.SDK_INT < 14) ? getSettings().ACCESSIBILITY_EXTENSIONS.get() : false;
	}
	
	public boolean accessibilityEnabled() {
		final AccessibilityMode mode = getSettings().ACCESSIBILITY_MODE.get();
		if(OsmandPlugin.getEnabledPlugin(AccessibilityPlugin.class) == null) {
			return false;
		}
		if (mode == AccessibilityMode.ON) {
			return true;
		} else if (mode == AccessibilityMode.OFF) {
			return false;
		}
		return ((AccessibilityManager) getSystemService(Context.ACCESSIBILITY_SERVICE)).isEnabled();
	}

	public String getVersionName() {
		try {
			PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), 0);
			return info.versionName;
		} catch (NameNotFoundException e) {
			return "";
		}
	}

	public int getVersionCode() {
		try {
			PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), 0);
			return info.versionCode;
		} catch (NameNotFoundException e) {
			return 0;
		}
	}

	public void startNavigationService(int intent) {
		final Intent serviceIntent = new Intent(this, NavigationService.class);
		serviceIntent.putExtra(NavigationService.USAGE_INTENT, intent);
		if (getNavigationService() == null) {
			getSettings().SERVICE_OFF_INTERVAL.set(0);
			startService(serviceIntent);
		} else {
			getNavigationService().addUsageIntent(intent);
		}		
	}
}
!@#$%
20190530_010530,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_c00688
package net.osmand.plus;

import java.io.BufferedWriter;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintStream;
import java.lang.Thread.UncaughtExceptionHandler;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

import net.osmand.IndexConstants;
import net.osmand.PlatformUtil;
import net.osmand.access.AccessibilityPlugin;
import net.osmand.access.AccessibleAlertBuilder;
import net.osmand.access.AccessibleToast;
import net.osmand.data.FavouritePoint;
import net.osmand.plus.GPXUtilities.GPXFile;
import net.osmand.plus.GPXUtilities.WptPt;
import net.osmand.plus.access.AccessibilityMode;
import net.osmand.plus.activities.DayNightHelper;
import net.osmand.plus.activities.SavingTrackHelper;
import net.osmand.plus.activities.SettingsActivity;
import net.osmand.plus.api.SQLiteAPI;
import net.osmand.plus.api.SQLiteAPIImpl;
import net.osmand.plus.monitoring.LiveMonitoringHelper;
import net.osmand.plus.render.NativeOsmandLibrary;
import net.osmand.plus.render.RendererRegistry;
import net.osmand.plus.resources.ResourceManager;
import net.osmand.plus.routing.RoutingHelper;
import net.osmand.plus.voice.CommandPlayer;
import net.osmand.plus.voice.CommandPlayerException;
import net.osmand.plus.voice.CommandPlayerFactory;
import net.osmand.render.RenderingRulesStorage;
import net.osmand.router.RoutingConfiguration;
import net.osmand.util.Algorithms;

import org.xmlpull.v1.XmlPullParserException;

import android.app.Activity;
import android.app.AlarmManager;
import android.app.AlertDialog;
import android.app.AlertDialog.Builder;
import android.app.Application;
import android.app.PendingIntent;
import android.app.ProgressDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager.NameNotFoundException;
import android.content.res.Configuration;
import android.graphics.Shader.TileMode;
import android.graphics.drawable.BitmapDrawable;
import android.os.Build;
import android.os.Handler;
import android.os.Message;
import android.text.format.DateFormat;
import android.util.TypedValue;
import android.view.accessibility.AccessibilityManager;
import android.widget.CheckBox;
import android.widget.LinearLayout;
import android.widget.ProgressBar;
import android.widget.LinearLayout.LayoutParams;
import android.widget.TextView;
import android.widget.Toast;
import btools.routingapp.BRouterServiceConnection;
import btools.routingapp.IBRouterService;

import com.actionbarsherlock.app.ActionBar;
import com.actionbarsherlock.app.SherlockActivity;
import com.actionbarsherlock.app.SherlockExpandableListActivity;
import com.actionbarsherlock.app.SherlockListActivity;


public class OsmandApplication extends Application {
	public static final String EXCEPTION_PATH = "exception.log"; //$NON-NLS-1$
	private static final org.apache.commons.logging.Log LOG = PlatformUtil.getLog(OsmandApplication.class);

	
	ResourceManager resourceManager = null;
	PoiFiltersHelper poiFilters = null;
	RoutingHelper routingHelper = null;
	FavouritesDbHelper favorites = null;
	CommandPlayer player = null;

	OsmandSettings osmandSettings = null;

	OsmAndAppCustomization appCustomization;
	DayNightHelper daynightHelper;
	NavigationService navigationService;
	RendererRegistry rendererRegistry;
	OsmAndLocationProvider locationProvider;
	OsmAndTaskManager taskManager;

	// start variables
	private ProgressImplementation startDialog;
	private Handler uiHandler;
	private GPXFile gpxFileToDisplay;
	private SavingTrackHelper savingTrackHelper;
	private LiveMonitoringHelper liveMonitoringHelper;
	private TargetPointsHelper targetPointsHelper;
	private RoutingConfiguration.Builder defaultRoutingConfig;

	private boolean applicationInitializing = false;
	private Locale prefferedLocale = null;
	
	SQLiteAPI sqliteAPI;
	BRouterServiceConnection bRouterServiceConnection;

	@Override
	public void onCreate() {
		long timeToStart = System.currentTimeMillis();
		if (Version.getAppName(this).equals("OsmAnd~")) {
			if (android.os.Build.VERSION.SDK_INT >= 9) {
				try {
					Class.forName("net.osmand.plus.base.EnableStrictMode").newInstance();
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		}
		super.onCreate();
		appCustomization = new OsmAndAppCustomization();
		appCustomization.setup(this);
		 
		sqliteAPI = new SQLiteAPIImpl(this);
		try {
			bRouterServiceConnection = BRouterServiceConnection.connect(this);
		} catch(Exception e) {
			e.printStackTrace();
		}

		// settings used everywhere so they need to be created first
		osmandSettings = appCustomization.createSettings(new net.osmand.plus.api.SettingsAPIImpl(this));
		// always update application mode to default
		if(!osmandSettings.FOLLOW_THE_ROUTE.get()){
			osmandSettings.APPLICATION_MODE.set(osmandSettings.DEFAULT_APPLICATION_MODE.get());
		}
		
		applyTheme(this);
		
		routingHelper = new RoutingHelper(this, player);
		taskManager = new OsmAndTaskManager(this);
		resourceManager = new ResourceManager(this);
		daynightHelper = new DayNightHelper(this);
		locationProvider = new OsmAndLocationProvider(this);
		savingTrackHelper = new SavingTrackHelper(this);
		liveMonitoringHelper = new LiveMonitoringHelper(this);
		uiHandler = new Handler();
		rendererRegistry = new RendererRegistry();
		targetPointsHelper = new TargetPointsHelper(this);
//		if(!osmandSettings.FOLLOW_THE_ROUTE.get()) {
//			targetPointsHelper.clearPointToNavigate(false);
//		}
		
		checkPrefferedLocale();
		startApplication();
		if (LOG.isDebugEnabled()) {
			LOG.debug("Time to start application " + (System.currentTimeMillis() - timeToStart) + " ms. Should be less < 800 ms");
		}
		timeToStart = System.currentTimeMillis();
		OsmandPlugin.initPlugins(this);

		if (LOG.isDebugEnabled()) {
			LOG.debug("Time to init plugins " + (System.currentTimeMillis() - timeToStart) + " ms. Should be less < 800 ms");
		}
		
		
	}

	@Override
	public void onTerminate() {
		super.onTerminate();
		if (routingHelper != null) {
			routingHelper.getVoiceRouter().onApplicationTerminate(this);
		}
	}

	public RendererRegistry getRendererRegistry() {
		return rendererRegistry;
	}
	
	public OsmAndTaskManager getTaskManager() {
		return taskManager;
	}

	
	public OsmAndLocationProvider getLocationProvider() {
		return locationProvider;
	}
	
	public OsmAndAppCustomization getAppCustomization() {
		return appCustomization;
	}
	
	public void setAppCustomization(OsmAndAppCustomization appCustomization) {
		this.appCustomization = appCustomization;
		this.appCustomization.setup(this);
	}

	/**
	 * Application settings
	 * 
	 * @return Reference to instance of OsmandSettings
	 */
	public OsmandSettings getSettings() {
		if (osmandSettings == null) {
			LOG.error("Trying to access settings before they were created");
		}
		return osmandSettings;
	}

	public SavingTrackHelper getSavingTrackHelper() {
		return savingTrackHelper;
	}

	public LiveMonitoringHelper getLiveMonitoringHelper() {
		return liveMonitoringHelper;
	}

	public PoiFiltersHelper getPoiFilters() {
		if (poiFilters == null) {
			poiFilters = new PoiFiltersHelper(this);
		}
		return poiFilters;
	}

	public void setGpxFileToDisplay(GPXFile gpxFileToDisplay, boolean showCurrentGpxFile) {
		this.gpxFileToDisplay = gpxFileToDisplay;
		osmandSettings.SHOW_CURRENT_GPX_TRACK.set(showCurrentGpxFile);
		if (gpxFileToDisplay == null) {
			getFavorites().setFavoritePointsFromGPXFile(null);
		} else {
			List<FavouritePoint> pts = new ArrayList<FavouritePoint>();
			for (WptPt p : gpxFileToDisplay.points) {
				FavouritePoint pt = new FavouritePoint();
				pt.setLatitude(p.lat);
				pt.setLongitude(p.lon);
				if (p.name == null) {
					p.name = "";
				}
				pt.setName(p.name);
				pts.add(pt);
			}
			gpxFileToDisplay.proccessPoints();
			getFavorites().setFavoritePointsFromGPXFile(pts);
		}
	}

	public GPXFile getGpxFileToDisplay() {
		return gpxFileToDisplay;
	}

	public FavouritesDbHelper getFavorites() {
		if (favorites == null) {
			favorites = new FavouritesDbHelper(this);
		}
		return favorites;
	}

	public ResourceManager getResourceManager() {
		return resourceManager;
	}

	public DayNightHelper getDaynightHelper() {
		return daynightHelper;
	}

	@Override
	public void onLowMemory() {
		super.onLowMemory();
		resourceManager.onLowMemory();
	}

	@Override
	public void onConfigurationChanged(Configuration newConfig) {
		if (prefferedLocale != null && !newConfig.locale.getLanguage().equals(prefferedLocale.getLanguage())) {
			super.onConfigurationChanged(newConfig);
			// ugly fix ! On devices after 4.0 screen is blinking when you rotate device!
			if (Build.VERSION.SDK_INT < 14) {
				newConfig.locale = prefferedLocale;
			}
			getBaseContext().getResources().updateConfiguration(newConfig, getBaseContext().getResources().getDisplayMetrics());
			Locale.setDefault(prefferedLocale);
		} else {
			super.onConfigurationChanged(newConfig);
		}
	}

	public void checkPrefferedLocale() {
		Configuration config = getBaseContext().getResources().getConfiguration();
		String lang = osmandSettings.PREFERRED_LOCALE.get();
		if (!"".equals(lang) && !config.locale.getLanguage().equals(lang)) {
			prefferedLocale = new Locale(lang);
			Locale.setDefault(prefferedLocale);
			config.locale = prefferedLocale;
			getBaseContext().getResources().updateConfiguration(config, getBaseContext().getResources().getDisplayMetrics());
		}
		String clang = "".equals(lang) ? config.locale.getLanguage() : lang;
		resourceManager.getOsmandRegions().setLocale(clang);

	}

	public static final int PROGRESS_DIALOG = 5;

	public void checkApplicationIsBeingInitialized(Activity activity, ProgressDialog progressDialog) {
		// start application if it was previously closed
		startApplication();
		synchronized (OsmandApplication.this) {
			if (startDialog != null) {
				progressDialog.setTitle(getString(R.string.loading_data));
				progressDialog.setMessage(getString(R.string.reading_indexes));
				activity.showDialog(PROGRESS_DIALOG);
				startDialog.setDialog(progressDialog);
			} else {
				progressDialog.dismiss();
			}
		}
	}
	
	public void checkApplicationIsBeingInitialized(Activity activity, TextView tv, ProgressBar progressBar,
			Runnable onClose) {
		// start application if it was previously closed
		startApplication();
		synchronized (OsmandApplication.this) {
			if (startDialog != null ) {
				tv.setText(getString(R.string.loading_data));
				startDialog.setProgressBar(tv, progressBar, onClose);
			} else if (onClose != null) {
				onClose.run();
			}
		}
	}

	public boolean isApplicationInitializing() {
		return startDialog != null;
	}

	public RoutingHelper getRoutingHelper() {
		return routingHelper;
	}

	public CommandPlayer getPlayer() {
		return player;
	}

	public void initVoiceCommandPlayer(final Activity uiContext) {
		showDialogInitializingCommandPlayer(uiContext, true, null, false);
	}

	public void showDialogInitializingCommandPlayer(final Activity uiContext, boolean warningNoneProvider) {
		showDialogInitializingCommandPlayer(uiContext, warningNoneProvider, null, true);
	}

	public void showDialogInitializingCommandPlayer(final Activity uiContext, boolean warningNoneProvider, Runnable run, boolean showDialog) {
		String voiceProvider = osmandSettings.VOICE_PROVIDER.get();
		if (voiceProvider == null || OsmandSettings.VOICE_PROVIDER_NOT_USE.equals(voiceProvider)) {
			if (warningNoneProvider && voiceProvider == null) {
				Builder builder = new AccessibleAlertBuilder(uiContext);
				LinearLayout ll = new LinearLayout(uiContext);
				ll.setOrientation(LinearLayout.VERTICAL);
				final TextView tv = new TextView(uiContext);
				tv.setPadding(7, 3, 7, 0);
				tv.setText(R.string.voice_is_not_available_msg);
				tv.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 19);
				ll.addView(tv);
				
				final CheckBox cb = new CheckBox(uiContext);
				cb.setText(R.string.remember_choice);
				LinearLayout.LayoutParams lp = new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);
				lp.setMargins(7, 10, 7, 0);
				cb.setLayoutParams(lp);
				ll.addView(cb);
				
				builder.setCancelable(true);
				builder.setNegativeButton(R.string.default_buttons_cancel, new DialogInterface.OnClickListener() {
					@Override
					public void onClick(DialogInterface dialog, int which) {
						if(cb.isChecked()) {
							osmandSettings.VOICE_PROVIDER.set(OsmandSettings.VOICE_PROVIDER_NOT_USE);
						}
					}
				});
				builder.setPositiveButton(R.string.default_buttons_ok, new DialogInterface.OnClickListener() {
					@Override
					public void onClick(DialogInterface dialog, int which) {
						Intent intent = new Intent(uiContext, SettingsActivity.class);
						intent.putExtra(SettingsActivity.INTENT_KEY_SETTINGS_SCREEN, SettingsActivity.SCREEN_GENERAL_SETTINGS);
						uiContext.startActivity(intent);
					}
				});
				
				
				builder.setTitle(R.string.voice_is_not_available_title);
				builder.setView(ll);
				//builder.setMessage(R.string.voice_is_not_available_msg);
				builder.show();
			}

		} else {
			if (player == null || !Algorithms.objectEquals(voiceProvider, player.getCurrentVoice())) {
				initVoiceDataInDifferentThread(uiContext, voiceProvider, run, showDialog);
			}
		}

	}

	private void initVoiceDataInDifferentThread(final Activity uiContext, final String voiceProvider, final Runnable run, boolean showDialog) {
		final ProgressDialog dlg = showDialog ? ProgressDialog.show(uiContext, getString(R.string.loading_data),
				getString(R.string.voice_data_initializing)) : null;
		new Thread(new Runnable() {
			@Override
			public void run() {
				try {
					if (player != null) {
						player.clear();
					}
					player = CommandPlayerFactory.createCommandPlayer(voiceProvider, OsmandApplication.this, uiContext);
					routingHelper.getVoiceRouter().setPlayer(player);
					if(dlg != null) {
						dlg.dismiss();
					}
					if (run != null && uiContext != null) {
						uiContext.runOnUiThread(run);
					}
				} catch (CommandPlayerException e) {
					if(dlg != null) {
						dlg.dismiss();
					}
					showToastMessage(e.getError());
				}
			}
		}).start();
	}

	public NavigationService getNavigationService() {
		return navigationService;
	}

	public void setNavigationService(NavigationService navigationService) {
		this.navigationService = navigationService;
	}


	private void fullExit() {
		// http://stackoverflow.com/questions/2092951/how-to-close-android-application
		System.runFinalizersOnExit(true);
		System.exit(0);
	}

	public synchronized void closeApplication(final Activity activity) {
		if (getNavigationService() != null) {
			Builder bld = new AlertDialog.Builder(activity);
			bld.setMessage(R.string.background_service_is_enabled_question);
			bld.setPositiveButton(R.string.default_buttons_yes, new DialogInterface.OnClickListener() {
				@Override
				public void onClick(DialogInterface dialog, int which) {
					closeApplicationAnyway(activity, true);
				}
			});
			bld.setNegativeButton(R.string.default_buttons_no, new DialogInterface.OnClickListener() {
				@Override
				public void onClick(DialogInterface dialog, int which) {
					closeApplicationAnyway(activity, false);
				}
			});
			bld.show();
		} else {
			closeApplicationAnyway(activity, true);
		}
	}

	private void closeApplicationAnyway(final Activity activity, boolean disableService) {
		if (applicationInitializing) {
			resourceManager.close();
		}
		applicationInitializing = false;

		activity.finish();

		if (getNavigationService() == null) {
			fullExit();
		}
		else if (disableService) {
			final Intent serviceIntent = new Intent(this, NavigationService.class);
			stopService(serviceIntent);

			new Thread(new Runnable() {
				public void run() {
					//wait until the service has fully stopped
					while (getNavigationService() != null) {
						try {
							Thread.sleep(100);
						}
							catch (InterruptedException e) {
						}
					}

					fullExit();
				}
			}).start();
		}
	}

	public synchronized void startApplication() {
		if (applicationInitializing) {
			return;
		}
		applicationInitializing = true;
		startDialog = new ProgressImplementation(this, null, false);

		startDialog.setRunnable("Initializing app", new Runnable() { //$NON-NLS-1$
					@Override
					public void run() {
						startApplicationBackground();
					}
				});
		startDialog.run();

		Thread.setDefaultUncaughtExceptionHandler(new DefaultExceptionHandler());

	}

	private void startApplicationBackground() {
		List<String> warnings = new ArrayList<String>();
		try {
			try {
				SpecialPhrases.setLanguage(this, osmandSettings);
			} catch (IOException e) {
				LOG.error("I/O exception", e);
				warnings.add("Error while reading the special phrases. Restart OsmAnd if possible");
			}
			if (!Version.isBlackberry(this)) {
				if (osmandSettings.NATIVE_RENDERING_FAILED.get()) {
					osmandSettings.SAFE_MODE.set(true);
					osmandSettings.NATIVE_RENDERING_FAILED.set(false);
					warnings.add(getString(R.string.native_library_not_supported));
				} else {
					osmandSettings.SAFE_MODE.set(false);
					osmandSettings.NATIVE_RENDERING_FAILED.set(true);
					startDialog.startTask(getString(R.string.init_native_library), -1);
					RenderingRulesStorage storage = rendererRegistry.getCurrentSelectedRenderer();
					boolean initialized = NativeOsmandLibrary.getLibrary(storage, this) != null;
					osmandSettings.NATIVE_RENDERING_FAILED.set(false);
					if (!initialized) {
						LOG.info("Native library could not be loaded!");
					}
				}
			}
			warnings.addAll(resourceManager.reloadIndexes(startDialog));
			player = null;
			if (savingTrackHelper.hasDataToSave()) {
				startDialog.startTask(getString(R.string.saving_gpx_tracks), -1);
				try {
					warnings.addAll(savingTrackHelper.saveDataToGpx());
				} catch (RuntimeException e) {
					warnings.add(e.getMessage());
				}
			}

			// restore backuped favorites to normal file
			final File appDir = getAppPath(null);
			File save = new File(appDir, FavouritesDbHelper.FILE_TO_SAVE);
			File bak = new File(appDir, FavouritesDbHelper.FILE_TO_BACKUP);
			if (bak.exists() && (!save.exists() || bak.lastModified() > save.lastModified())) {
				if (save.exists()) {
					save.delete();
				}
				bak.renameTo(save);
			}
		} catch (RuntimeException e) {
			e.printStackTrace();
			warnings.add(e.getMessage());
		} finally {
			synchronized (OsmandApplication.this) {
				final ProgressDialog toDismiss;
				final Runnable pb;
				if (startDialog != null) {
					toDismiss = startDialog.getDialog();
					pb = startDialog.getFinishRunnable();
				} else {
					toDismiss = null;
					pb = null;
				}
				startDialog = null;

				if (toDismiss != null || pb != null) {
					uiHandler.post(new Runnable() {
						@Override
						public void run() {
							if(pb != null) {
								pb.run();
							}
							if (toDismiss != null) {
								// TODO handling this dialog is bad, we need a better standard way
								toDismiss.dismiss();
								// toDismiss.getOwnerActivity().dismissDialog(PROGRESS_DIALOG);
							}
						}
					});
				}
				if (warnings != null && !warnings.isEmpty()) {
					showToastMessage(formatWarnings(warnings).toString());
				}
			}
		}
	}

	private StringBuilder formatWarnings(List<String> warnings) {
		final StringBuilder b = new StringBuilder();
		boolean f = true;
		for (String w : warnings) {
			if (f) {
				f = false;
			} else {
				b.append('\n');
			}
			b.append(w);
		}
		return b;
	}


	private class DefaultExceptionHandler implements UncaughtExceptionHandler {

		private UncaughtExceptionHandler defaultHandler;
		private PendingIntent intent;

		public DefaultExceptionHandler() {
			defaultHandler = Thread.getDefaultUncaughtExceptionHandler();
			intent = PendingIntent.getActivity(OsmandApplication.this.getBaseContext(), 0,
					new Intent(OsmandApplication.this.getBaseContext(),
							getAppCustomization().getMainMenuActivity()), 0);
		}

		@Override
		public void uncaughtException(final Thread thread, final Throwable ex) {
			File file = getAppPath(EXCEPTION_PATH);
			try {
				ByteArrayOutputStream out = new ByteArrayOutputStream();
				PrintStream printStream = new PrintStream(out);
				ex.printStackTrace(printStream);
				StringBuilder msg = new StringBuilder();
				msg.append("Version  " + Version.getFullVersion(OsmandApplication.this) + "\n"). //$NON-NLS-1$ 
						append(DateFormat.format("dd.MM.yyyy h:mm:ss", System.currentTimeMillis()));
				try {
					PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), 0);
					if (info != null) {
						msg.append("\nApk Version : ").append(info.versionName).append(" ").append(info.versionCode); //$NON-NLS-1$ //$NON-NLS-2$
					}
				} catch (Throwable e) {
				}
				msg.append("\n"). //$NON-NLS-1$//$NON-NLS-2$
						append("Exception occured in thread " + thread.toString() + " : \n"). //$NON-NLS-1$ //$NON-NLS-2$
						append(new String(out.toByteArray()));

				if (file.getParentFile().canWrite()) {
					BufferedWriter writer = new BufferedWriter(new FileWriter(file, true));
					writer.write(msg.toString());
					writer.close();
				}
				if (routingHelper.isFollowingMode()) {
					AlarmManager mgr = (AlarmManager) getSystemService(Context.ALARM_SERVICE);
					mgr.set(AlarmManager.RTC, System.currentTimeMillis() + 2000, intent);
					System.exit(2);
				}
				defaultHandler.uncaughtException(thread, ex);
			} catch (Exception e) {
				// swallow all exceptions
				android.util.Log.e(PlatformUtil.TAG, "Exception while handle other exception", e); //$NON-NLS-1$
			}

		}
	}

	
	public TargetPointsHelper getTargetPointsHelper() {
		return targetPointsHelper;
	}
	
	public void showShortToastMessage(int msgId, Object... args) {
		AccessibleToast.makeText(this, getString(msgId, args), Toast.LENGTH_SHORT).show();
	}

	public void showToastMessage(int msgId, Object... args) {
		AccessibleToast.makeText(this, getString(msgId, args), Toast.LENGTH_LONG).show();
	}

	public void showToastMessage(String msg) {
		AccessibleToast.makeText(this, msg, Toast.LENGTH_LONG).show();
	}
	
	public SQLiteAPI getSQLiteAPI() {
		return sqliteAPI;
	}

	public void runInUIThread(Runnable run) {
		uiHandler.post(run);
	}

	public void runInUIThread(Runnable run, long delay) {
		uiHandler.postDelayed(run, delay);
	}
	
	public void runMessageInUIThreadAndCancelPrevious(final int messageId, final Runnable run, long delay) {
		Message msg = Message.obtain(uiHandler, new Runnable() {
			
			@Override
			public void run() {
				if(!uiHandler.hasMessages(messageId)) {
					run.run();
				}
			}
		});
		msg.what = messageId;
		uiHandler.removeMessages(messageId);
		uiHandler.sendMessageDelayed(msg, delay);
	}
	
	public File getAppPath(String path) {
		if(path == null) {
			path = "";
		}
		return new File(getSettings().getExternalStorageDirectory(), IndexConstants.APP_DIR + path);
	}

	public void applyTheme(Context c) {
		int t = R.style.OsmandLightDarkActionBarTheme;
		if (osmandSettings.OSMAND_THEME.get() == OsmandSettings.OSMAND_DARK_THEME) {
			t = R.style.OsmandDarkTheme;
		} else if (osmandSettings.OSMAND_THEME.get() == OsmandSettings.OSMAND_LIGHT_THEME) {
			t = R.style.OsmandLightTheme;
		} else if (osmandSettings.OSMAND_THEME.get() == OsmandSettings.OSMAND_LIGHT_DARK_ACTIONBAR_THEME) {
			t = R.style.OsmandLightDarkActionBarTheme;
		}
		setLanguage(c);
		c.setTheme(t);
		if (osmandSettings.OSMAND_THEME.get() == OsmandSettings.OSMAND_LIGHT_DARK_ACTIONBAR_THEME
				&& Build.VERSION.SDK_INT < Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
			ActionBar ab = null;
			if (c instanceof SherlockActivity) {
				ab = ((SherlockActivity) c).getSupportActionBar();
			} else if (c instanceof SherlockListActivity) {
				ab = ((SherlockListActivity) c).getSupportActionBar();
			} else if (c instanceof SherlockExpandableListActivity) {
				ab = ((SherlockExpandableListActivity) c).getSupportActionBar();
			}
			if (ab != null) {
				BitmapDrawable bg = (BitmapDrawable) getResources().getDrawable(R.drawable.bg_striped);
				bg.setTileModeXY(TileMode.REPEAT, TileMode.REPEAT);
				ab.setBackgroundDrawable(bg);
			}
		}
	}
	
	public IBRouterService getBRouterService() {
		if(bRouterServiceConnection == null) {
			return null;
		}
		return bRouterServiceConnection.getBrouterService();
	}
	
	public void setLanguage(Context context) {
		if (prefferedLocale != null) {
			Configuration config = context.getResources().getConfiguration();
			String lang = prefferedLocale.getLanguage();
			if (!"".equals(lang) && !config.locale.getLanguage().equals(lang)) {
				prefferedLocale = new Locale(lang);
				Locale.setDefault(prefferedLocale);
				config.locale = prefferedLocale;
				context.getResources().updateConfiguration(config, context.getResources().getDisplayMetrics());
			}
		}
	}
	
	public RoutingConfiguration.Builder getDefaultRoutingConfig() {
		if (defaultRoutingConfig == null) {
			File routingXml = getAppPath(IndexConstants.ROUTING_XML_FILE);
			if (routingXml.exists() && routingXml.canRead()) {
				try {
					defaultRoutingConfig = RoutingConfiguration.parseFromInputStream(new FileInputStream(routingXml));
				} catch (XmlPullParserException e) {
					throw new IllegalStateException(e);
				} catch (IOException e) {
					throw new IllegalStateException(e);
				}
			} else {
				defaultRoutingConfig = RoutingConfiguration.getDefault();
			}
		}
		return defaultRoutingConfig;
	}
	
	public boolean accessibilityExtensions() {
		return (Build.VERSION.SDK_INT < 14) ? getSettings().ACCESSIBILITY_EXTENSIONS.get() : false;
	}
	
	public boolean accessibilityEnabled() {
		final AccessibilityMode mode = getSettings().ACCESSIBILITY_MODE.get();
		if(OsmandPlugin.getEnabledPlugin(AccessibilityPlugin.class) == null) {
			return false;
		}
		if (mode == AccessibilityMode.ON) {
			return true;
		} else if (mode == AccessibilityMode.OFF) {
			return false;
		}
		return ((AccessibilityManager) getSystemService(Context.ACCESSIBILITY_SERVICE)).isEnabled();
	}

	public String getVersionName() {
		try {
			PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), 0);
			return info.versionName;
		} catch (NameNotFoundException e) {
			return "";
		}
	}

	public int getVersionCode() {
		try {
			PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), 0);
			return info.versionCode;
		} catch (NameNotFoundException e) {
			return 0;
		}
	}

	public void startNavigationService(int intent) {
		final Intent serviceIntent = new Intent(this, NavigationService.class);
		serviceIntent.putExtra(NavigationService.USAGE_INTENT, intent);
		if (getNavigationService() == null) {
			getSettings().SERVICE_OFF_INTERVAL.set(0);
			startService(serviceIntent);
		} else {
			getNavigationService().addUsageIntent(intent);
		}		
	}
}
!@#$%
20190530_010539,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_b10816
package net.osmand.plus;

import java.io.BufferedWriter;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintStream;
import java.lang.Thread.UncaughtExceptionHandler;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

import net.osmand.IndexConstants;
import net.osmand.PlatformUtil;
import net.osmand.access.AccessibilityPlugin;
import net.osmand.access.AccessibleAlertBuilder;
import net.osmand.access.AccessibleToast;
import net.osmand.data.FavouritePoint;
import net.osmand.plus.GPXUtilities.GPXFile;
import net.osmand.plus.GPXUtilities.WptPt;
import net.osmand.plus.access.AccessibilityMode;
import net.osmand.plus.activities.DayNightHelper;
import net.osmand.plus.activities.SavingTrackHelper;
import net.osmand.plus.activities.SettingsActivity;
import net.osmand.plus.api.SQLiteAPI;
import net.osmand.plus.api.SQLiteAPIImpl;
import net.osmand.plus.monitoring.LiveMonitoringHelper;
import net.osmand.plus.render.NativeOsmandLibrary;
import net.osmand.plus.render.RendererRegistry;
import net.osmand.plus.resources.ResourceManager;
import net.osmand.plus.routing.RoutingHelper;
import net.osmand.plus.voice.CommandPlayer;
import net.osmand.plus.voice.CommandPlayerException;
import net.osmand.plus.voice.CommandPlayerFactory;
import net.osmand.render.RenderingRulesStorage;
import net.osmand.router.RoutingConfiguration;
import net.osmand.util.Algorithms;

import org.xmlpull.v1.XmlPullParserException;

import android.app.Activity;
import android.app.AlarmManager;
import android.app.AlertDialog;
import android.app.AlertDialog.Builder;
import android.app.Application;
import android.app.PendingIntent;
import android.app.ProgressDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager.NameNotFoundException;
import android.content.res.Configuration;
import android.graphics.Shader.TileMode;
import android.graphics.drawable.BitmapDrawable;
import android.os.Build;
import android.os.Handler;
import android.os.Message;
import android.text.format.DateFormat;
import android.util.TypedValue;
import android.view.accessibility.AccessibilityManager;
import android.widget.CheckBox;
import android.widget.LinearLayout;
import android.widget.ProgressBar;
import android.widget.LinearLayout.LayoutParams;
import android.widget.TextView;
import android.widget.Toast;
import btools.routingapp.BRouterServiceConnection;
import btools.routingapp.IBRouterService;

import com.actionbarsherlock.app.ActionBar;
import com.actionbarsherlock.app.SherlockActivity;
import com.actionbarsherlock.app.SherlockExpandableListActivity;
import com.actionbarsherlock.app.SherlockListActivity;


public class OsmandApplication extends Application {
	public static final String EXCEPTION_PATH = "exception.log"; //$NON-NLS-1$
	private static final org.apache.commons.logging.Log LOG = PlatformUtil.getLog(OsmandApplication.class);

	
	ResourceManager resourceManager = null;
	PoiFiltersHelper poiFilters = null;
	RoutingHelper routingHelper = null;
	FavouritesDbHelper favorites = null;
	CommandPlayer player = null;

	OsmandSettings osmandSettings = null;

	OsmAndAppCustomization appCustomization;
	DayNightHelper daynightHelper;
	NavigationService navigationService;
	RendererRegistry rendererRegistry;
	OsmAndLocationProvider locationProvider;
	OsmAndTaskManager taskManager;

	// start variables
	private ProgressImplementation startDialog;
	private Handler uiHandler;
	private GPXFile gpxFileToDisplay;
	private SavingTrackHelper savingTrackHelper;
	private LiveMonitoringHelper liveMonitoringHelper;
	private TargetPointsHelper targetPointsHelper;
	private RoutingConfiguration.Builder defaultRoutingConfig;

	private boolean applicationInitializing = false;
	private Locale prefferedLocale = null;
	
	SQLiteAPI sqliteAPI;
	BRouterServiceConnection bRouterServiceConnection;

	@Override
	public void onCreate() {
		long timeToStart = System.currentTimeMillis();
		if (Version.getAppName(this).equals("OsmAnd~")) {
			if (android.os.Build.VERSION.SDK_INT >= 9) {
				try {
					Class.forName("net.osmand.plus.base.EnableStrictMode").newInstance();
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		}
		super.onCreate();
		appCustomization = new OsmAndAppCustomization();
		appCustomization.setup(this);
		 
		sqliteAPI = new SQLiteAPIImpl(this);
		try {
			bRouterServiceConnection = BRouterServiceConnection.connect(this);
		} catch(Exception e) {
			e.printStackTrace();
		}

		// settings used everywhere so they need to be created first
		osmandSettings = appCustomization.createSettings(new net.osmand.plus.api.SettingsAPIImpl(this));
		// always update application mode to default
		if(!osmandSettings.FOLLOW_THE_ROUTE.get()){
			osmandSettings.APPLICATION_MODE.set(osmandSettings.DEFAULT_APPLICATION_MODE.get());
		}
		
		applyTheme(this);
		
		routingHelper = new RoutingHelper(this, player);
		taskManager = new OsmAndTaskManager(this);
		resourceManager = new ResourceManager(this);
		daynightHelper = new DayNightHelper(this);
		locationProvider = new OsmAndLocationProvider(this);
		savingTrackHelper = new SavingTrackHelper(this);
		liveMonitoringHelper = new LiveMonitoringHelper(this);
		uiHandler = new Handler();
		rendererRegistry = new RendererRegistry();
		targetPointsHelper = new TargetPointsHelper(this);
//		if(!osmandSettings.FOLLOW_THE_ROUTE.get()) {
//			targetPointsHelper.clearPointToNavigate(false);
//		}
		
		checkPrefferedLocale();
		startApplication();
		if (LOG.isDebugEnabled()) {
			LOG.debug("Time to start application " + (System.currentTimeMillis() - timeToStart) + " ms. Should be less < 800 ms");
		}
		timeToStart = System.currentTimeMillis();
		OsmandPlugin.initPlugins(this);

		if (LOG.isDebugEnabled()) {
			LOG.debug("Time to init plugins " + (System.currentTimeMillis() - timeToStart) + " ms. Should be less < 800 ms");
		}
		
		
	}

	@Override
	public void onTerminate() {
		super.onTerminate();
		if (routingHelper != null) {
			routingHelper.getVoiceRouter().onApplicationTerminate(this);
		}
	}

	public RendererRegistry getRendererRegistry() {
		return rendererRegistry;
	}
	
	public OsmAndTaskManager getTaskManager() {
		return taskManager;
	}

	
	public OsmAndLocationProvider getLocationProvider() {
		return locationProvider;
	}
	
	public OsmAndAppCustomization getAppCustomization() {
		return appCustomization;
	}
	
	public void setAppCustomization(OsmAndAppCustomization appCustomization) {
		this.appCustomization = appCustomization;
		this.appCustomization.setup(this);
	}

	/**
	 * Application settings
	 * 
	 * @return Reference to instance of OsmandSettings
	 */
	public OsmandSettings getSettings() {
		if (osmandSettings == null) {
			LOG.error("Trying to access settings before they were created");
		}
		return osmandSettings;
	}

	public SavingTrackHelper getSavingTrackHelper() {
		return savingTrackHelper;
	}

	public LiveMonitoringHelper getLiveMonitoringHelper() {
		return liveMonitoringHelper;
	}

	public PoiFiltersHelper getPoiFilters() {
		if (poiFilters == null) {
			poiFilters = new PoiFiltersHelper(this);
		}
		return poiFilters;
	}

	public void setGpxFileToDisplay(GPXFile gpxFileToDisplay, boolean showCurrentGpxFile) {
		this.gpxFileToDisplay = gpxFileToDisplay;
		osmandSettings.SHOW_CURRENT_GPX_TRACK.set(showCurrentGpxFile);
		if (gpxFileToDisplay == null) {
			getFavorites().setFavoritePointsFromGPXFile(null);
		} else {
			List<FavouritePoint> pts = new ArrayList<FavouritePoint>();
			for (WptPt p : gpxFileToDisplay.points) {
				FavouritePoint pt = new FavouritePoint();
				pt.setLatitude(p.lat);
				pt.setLongitude(p.lon);
				if (p.name == null) {
					p.name = "";
				}
				pt.setName(p.name);
				pts.add(pt);
			}
			gpxFileToDisplay.proccessPoints();
			getFavorites().setFavoritePointsFromGPXFile(pts);
		}
	}

	public GPXFile getGpxFileToDisplay() {
		return gpxFileToDisplay;
	}

	public FavouritesDbHelper getFavorites() {
		if (favorites == null) {
			favorites = new FavouritesDbHelper(this);
		}
		return favorites;
	}

	public ResourceManager getResourceManager() {
		return resourceManager;
	}

	public DayNightHelper getDaynightHelper() {
		return daynightHelper;
	}

	@Override
	public void onLowMemory() {
		super.onLowMemory();
		resourceManager.onLowMemory();
	}

	@Override
	public void onConfigurationChanged(Configuration newConfig) {
		if (prefferedLocale != null && !newConfig.locale.getLanguage().equals(prefferedLocale.getLanguage())) {
			super.onConfigurationChanged(newConfig);
			// ugly fix ! On devices after 4.0 screen is blinking when you rotate device!
			if (Build.VERSION.SDK_INT < 14) {
				newConfig.locale = prefferedLocale;
			}
			getBaseContext().getResources().updateConfiguration(newConfig, getBaseContext().getResources().getDisplayMetrics());
			Locale.setDefault(prefferedLocale);
		} else {
			super.onConfigurationChanged(newConfig);
		}
	}

	public void checkPrefferedLocale() {
		Configuration config = getBaseContext().getResources().getConfiguration();
		String lang = osmandSettings.PREFERRED_LOCALE.get();
		if (!"".equals(lang) && !config.locale.getLanguage().equals(lang)) {
			prefferedLocale = new Locale(lang);
			Locale.setDefault(prefferedLocale);
			config.locale = prefferedLocale;
			getBaseContext().getResources().updateConfiguration(config, getBaseContext().getResources().getDisplayMetrics());
		}
		String clang = "".equals(lang) ? config.locale.getLanguage() : lang;
		resourceManager.getOsmandRegions().setLocale(clang);

	}

	public static final int PROGRESS_DIALOG = 5;

	public void checkApplicationIsBeingInitialized(Activity activity, ProgressDialog progressDialog) {
		// start application if it was previously closed
		startApplication();
		synchronized (OsmandApplication.this) {
			if (startDialog != null) {
				progressDialog.setTitle(getString(R.string.loading_data));
				progressDialog.setMessage(getString(R.string.reading_indexes));
				activity.showDialog(PROGRESS_DIALOG);
				startDialog.setDialog(progressDialog);
			} else {
				progressDialog.dismiss();
			}
		}
	}
	
	public void checkApplicationIsBeingInitialized(Activity activity, TextView tv, ProgressBar progressBar,
			Runnable onClose) {
		// start application if it was previously closed
		startApplication();
		synchronized (OsmandApplication.this) {
			if (startDialog != null ) {
				tv.setText(getString(R.string.loading_data));
				startDialog.setProgressBar(tv, progressBar, onClose);
			} else if (onClose != null) {
				onClose.run();
			}
		}
	}

	public boolean isApplicationInitializing() {
		return startDialog != null;
	}

	public RoutingHelper getRoutingHelper() {
		return routingHelper;
	}

	public CommandPlayer getPlayer() {
		return player;
	}

	public void initVoiceCommandPlayer(final Activity uiContext) {
		showDialogInitializingCommandPlayer(uiContext, true, null, false);
	}

	public void showDialogInitializingCommandPlayer(final Activity uiContext, boolean warningNoneProvider) {
		showDialogInitializingCommandPlayer(uiContext, warningNoneProvider, null, true);
	}

	public void showDialogInitializingCommandPlayer(final Activity uiContext, boolean warningNoneProvider, Runnable run, boolean showDialog) {
		String voiceProvider = osmandSettings.VOICE_PROVIDER.get();
		if (voiceProvider == null || OsmandSettings.VOICE_PROVIDER_NOT_USE.equals(voiceProvider)) {
			if (warningNoneProvider && voiceProvider == null) {
				Builder builder = new AccessibleAlertBuilder(uiContext);
				LinearLayout ll = new LinearLayout(uiContext);
				ll.setOrientation(LinearLayout.VERTICAL);
				final TextView tv = new TextView(uiContext);
				tv.setPadding(7, 3, 7, 0);
				tv.setText(R.string.voice_is_not_available_msg);
				tv.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 19);
				ll.addView(tv);
				
				final CheckBox cb = new CheckBox(uiContext);
				cb.setText(R.string.remember_choice);
				LinearLayout.LayoutParams lp = new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);
				lp.setMargins(7, 10, 7, 0);
				cb.setLayoutParams(lp);
				ll.addView(cb);
				
				builder.setCancelable(true);
				builder.setNegativeButton(R.string.default_buttons_cancel, new DialogInterface.OnClickListener() {
					@Override
					public void onClick(DialogInterface dialog, int which) {
						if(cb.isChecked()) {
							osmandSettings.VOICE_PROVIDER.set(OsmandSettings.VOICE_PROVIDER_NOT_USE);
						}
					}
				});
				builder.setPositiveButton(R.string.default_buttons_ok, new DialogInterface.OnClickListener() {
					@Override
					public void onClick(DialogInterface dialog, int which) {
						Intent intent = new Intent(uiContext, SettingsActivity.class);
						intent.putExtra(SettingsActivity.INTENT_KEY_SETTINGS_SCREEN, SettingsActivity.SCREEN_GENERAL_SETTINGS);
						uiContext.startActivity(intent);
					}
				});
				
				
				builder.setTitle(R.string.voice_is_not_available_title);
				builder.setView(ll);
				//builder.setMessage(R.string.voice_is_not_available_msg);
				builder.show();
			}

		} else {
			if (player == null || !Algorithms.objectEquals(voiceProvider, player.getCurrentVoice())) {
				initVoiceDataInDifferentThread(uiContext, voiceProvider, run, showDialog);
			}
		}

	}

	private void initVoiceDataInDifferentThread(final Activity uiContext, final String voiceProvider, final Runnable run, boolean showDialog) {
		final ProgressDialog dlg = showDialog ? ProgressDialog.show(uiContext, getString(R.string.loading_data),
				getString(R.string.voice_data_initializing)) : null;
		new Thread(new Runnable() {
			@Override
			public void run() {
				try {
					if (player != null) {
						player.clear();
					}
					player = CommandPlayerFactory.createCommandPlayer(voiceProvider, OsmandApplication.this, uiContext);
					routingHelper.getVoiceRouter().setPlayer(player);
					if(dlg != null) {
						dlg.dismiss();
					}
					if (run != null && uiContext != null) {
						uiContext.runOnUiThread(run);
					}
				} catch (CommandPlayerException e) {
					if(dlg != null) {
						dlg.dismiss();
					}
					showToastMessage(e.getError());
				}
			}
		}).start();
	}

	public NavigationService getNavigationService() {
		return navigationService;
	}

	public void setNavigationService(NavigationService navigationService) {
		this.navigationService = navigationService;
	}


	private void fullExit() {
		// http://stackoverflow.com/questions/2092951/how-to-close-android-application
		System.runFinalizersOnExit(true);
		System.exit(0);
	}

	public synchronized void closeApplication(final Activity activity) {
		if (getNavigationService() != null) {
			Builder bld = new AlertDialog.Builder(activity);
			bld.setMessage(R.string.background_service_is_enabled_question);
			bld.setPositiveButton(R.string.default_buttons_yes, new DialogInterface.OnClickListener() {
				@Override
				public void onClick(DialogInterface dialog, int which) {
					closeApplicationAnyway(activity, true);
				}
			});
			bld.setNegativeButton(R.string.default_buttons_no, new DialogInterface.OnClickListener() {
				@Override
				public void onClick(DialogInterface dialog, int which) {
					closeApplicationAnyway(activity, false);
				}
			});
			bld.show();
		} else {
			closeApplicationAnyway(activity, true);
		}
	}

	private void closeApplicationAnyway(final Activity activity, boolean disableService) {
		if (applicationInitializing) {
			resourceManager.close();
		}
		applicationInitializing = false;

		activity.finish();

		if (getNavigationService() == null) {
			fullExit();
		}
		else if (disableService) {
			final Intent serviceIntent = new Intent(this, NavigationService.class);
			stopService(serviceIntent);

			new Thread(new Runnable() {
				public void run() {
					//wait until the service has fully stopped
					while (getNavigationService() != null) {
						try {
							Thread.sleep(100);
						}
							catch (InterruptedException e) {
						}
					}

					fullExit();
				}
			}).start();
		}
	}

	public synchronized void startApplication() {
		if (applicationInitializing) {
			return;
		}
		applicationInitializing = true;
		startDialog = new ProgressImplementation(this, null, false);

		startDialog.setRunnable("Initializing app", new Runnable() { //$NON-NLS-1$
					@Override
					public void run() {
						startApplicationBackground();
					}
				});
		startDialog.run();

		Thread.setDefaultUncaughtExceptionHandler(new DefaultExceptionHandler());

	}

	private void startApplicationBackground() {
		List<String> warnings = new ArrayList<String>();
		try {
			try {
				SpecialPhrases.setLanguage(this, osmandSettings);
			} catch (IOException e) {
				LOG.error("I/O exception", e);
				warnings.add("Error while reading the special phrases. Restart OsmAnd if possible");
			}
			if (!Version.isBlackberry(this)) {
				if (osmandSettings.NATIVE_RENDERING_FAILED.get()) {
					osmandSettings.SAFE_MODE.set(true);
					osmandSettings.NATIVE_RENDERING_FAILED.set(false);
					warnings.add(getString(R.string.native_library_not_supported));
				} else {
					osmandSettings.SAFE_MODE.set(false);
					osmandSettings.NATIVE_RENDERING_FAILED.set(true);
					startDialog.startTask(getString(R.string.init_native_library), -1);
					RenderingRulesStorage storage = rendererRegistry.getCurrentSelectedRenderer();
					boolean initialized = NativeOsmandLibrary.getLibrary(storage, this) != null;
					osmandSettings.NATIVE_RENDERING_FAILED.set(false);
					if (!initialized) {
						LOG.info("Native library could not be loaded!");
					}
				}
			}
			warnings.addAll(resourceManager.reloadIndexes(startDialog));
			player = null;
			if (savingTrackHelper.hasDataToSave()) {
				startDialog.startTask(getString(R.string.saving_gpx_tracks), -1);
				try {
					warnings.addAll(savingTrackHelper.saveDataToGpx());
				} catch (RuntimeException e) {
					warnings.add(e.getMessage());
				}
			}

			// restore backuped favorites to normal file
			final File appDir = getAppPath(null);
			File save = new File(appDir, FavouritesDbHelper.FILE_TO_SAVE);
			File bak = new File(appDir, FavouritesDbHelper.FILE_TO_BACKUP);
			if (bak.exists() && (!save.exists() || bak.lastModified() > save.lastModified())) {
				if (save.exists()) {
					save.delete();
				}
				bak.renameTo(save);
			}
		} catch (RuntimeException e) {
			e.printStackTrace();
			warnings.add(e.getMessage());
		} finally {
			synchronized (OsmandApplication.this) {
				final ProgressDialog toDismiss;
				final Runnable pb;
				if (startDialog != null) {
					toDismiss = startDialog.getDialog();
					pb = startDialog.getFinishRunnable();
				} else {
					toDismiss = null;
					pb = null;
				}
				startDialog = null;

				if (toDismiss != null || pb != null) {
					uiHandler.post(new Runnable() {
						@Override
						public void run() {
							if(pb != null) {
								pb.run();
							}
							if (toDismiss != null) {
								// TODO handling this dialog is bad, we need a better standard way
								toDismiss.dismiss();
								// toDismiss.getOwnerActivity().dismissDialog(PROGRESS_DIALOG);
							}
						}
					});
				}
				if (warnings != null && !warnings.isEmpty()) {
					showToastMessage(formatWarnings(warnings).toString());
				}
			}
		}
	}

	private StringBuilder formatWarnings(List<String> warnings) {
		final StringBuilder b = new StringBuilder();
		boolean f = true;
		for (String w : warnings) {
			if (f) {
				f = false;
			} else {
				b.append('\n');
			}
			b.append(w);
		}
		return b;
	}


	private class DefaultExceptionHandler implements UncaughtExceptionHandler {

		private UncaughtExceptionHandler defaultHandler;
		private PendingIntent intent;

		public DefaultExceptionHandler() {
			defaultHandler = Thread.getDefaultUncaughtExceptionHandler();
			intent = PendingIntent.getActivity(OsmandApplication.this.getBaseContext(), 0,
					new Intent(OsmandApplication.this.getBaseContext(),
							getAppCustomization().getMainMenuActivity()), 0);
		}

		@Override
		public void uncaughtException(final Thread thread, final Throwable ex) {
			File file = getAppPath(EXCEPTION_PATH);
			try {
				ByteArrayOutputStream out = new ByteArrayOutputStream();
				PrintStream printStream = new PrintStream(out);
				ex.printStackTrace(printStream);
				StringBuilder msg = new StringBuilder();
				msg.append("Version  " + Version.getFullVersion(OsmandApplication.this) + "\n"). //$NON-NLS-1$ 
						append(DateFormat.format("dd.MM.yyyy h:mm:ss", System.currentTimeMillis()));
				try {
					PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), 0);
					if (info != null) {
						msg.append("\nApk Version : ").append(info.versionName).append(" ").append(info.versionCode); //$NON-NLS-1$ //$NON-NLS-2$
					}
				} catch (Throwable e) {
				}
				msg.append("\n"). //$NON-NLS-1$//$NON-NLS-2$
						append("Exception occured in thread " + thread.toString() + " : \n"). //$NON-NLS-1$ //$NON-NLS-2$
						append(new String(out.toByteArray()));

				if (file.getParentFile().canWrite()) {
					BufferedWriter writer = new BufferedWriter(new FileWriter(file, true));
					writer.write(msg.toString());
					writer.close();
				}
				if (routingHelper.isFollowingMode()) {
					AlarmManager mgr = (AlarmManager) getSystemService(Context.ALARM_SERVICE);
					mgr.set(AlarmManager.RTC, System.currentTimeMillis() + 2000, intent);
					System.exit(2);
				}
				defaultHandler.uncaughtException(thread, ex);
			} catch (Exception e) {
				// swallow all exceptions
				android.util.Log.e(PlatformUtil.TAG, "Exception while handle other exception", e); //$NON-NLS-1$
			}

		}
	}

	
	public TargetPointsHelper getTargetPointsHelper() {
		return targetPointsHelper;
	}
	
	public void showShortToastMessage(int msgId, Object... args) {
		AccessibleToast.makeText(this, getString(msgId, args), Toast.LENGTH_SHORT).show();
	}

	public void showToastMessage(int msgId, Object... args) {
		AccessibleToast.makeText(this, getString(msgId, args), Toast.LENGTH_LONG).show();
	}

	public void showToastMessage(String msg) {
		AccessibleToast.makeText(this, msg, Toast.LENGTH_LONG).show();
	}
	
	public SQLiteAPI getSQLiteAPI() {
		return sqliteAPI;
	}

	public void runInUIThread(Runnable run) {
		uiHandler.post(run);
	}

	public void runInUIThread(Runnable run, long delay) {
		uiHandler.postDelayed(run, delay);
	}
	
	public void runMessageInUIThreadAndCancelPrevious(final int messageId, final Runnable run, long delay) {
		Message msg = Message.obtain(uiHandler, new Runnable() {
			
			@Override
			public void run() {
				if(!uiHandler.hasMessages(messageId)) {
					run.run();
				}
			}
		});
		msg.what = messageId;
		uiHandler.removeMessages(messageId);
		uiHandler.sendMessageDelayed(msg, delay);
	}
	
	public File getAppPath(String path) {
		if(path == null) {
			path = "";
		}
		return new File(getSettings().getExternalStorageDirectory(), IndexConstants.APP_DIR + path);
	}

	public void applyTheme(Context c) {
		int t = R.style.OsmandLightDarkActionBarTheme;
		if (osmandSettings.OSMAND_THEME.get() == OsmandSettings.OSMAND_DARK_THEME) {
			t = R.style.OsmandDarkTheme;
		} else if (osmandSettings.OSMAND_THEME.get() == OsmandSettings.OSMAND_LIGHT_THEME) {
			t = R.style.OsmandLightTheme;
		} else if (osmandSettings.OSMAND_THEME.get() == OsmandSettings.OSMAND_LIGHT_DARK_ACTIONBAR_THEME) {
			t = R.style.OsmandLightDarkActionBarTheme;
		}
		setLanguage(c);
		c.setTheme(t);
		if (osmandSettings.OSMAND_THEME.get() == OsmandSettings.OSMAND_LIGHT_DARK_ACTIONBAR_THEME
				&& Build.VERSION.SDK_INT < Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
			ActionBar ab = null;
			if (c instanceof SherlockActivity) {
				ab = ((SherlockActivity) c).getSupportActionBar();
			} else if (c instanceof SherlockListActivity) {
				ab = ((SherlockListActivity) c).getSupportActionBar();
			} else if (c instanceof SherlockExpandableListActivity) {
				ab = ((SherlockExpandableListActivity) c).getSupportActionBar();
			}
			if (ab != null) {
				BitmapDrawable bg = (BitmapDrawable) getResources().getDrawable(R.drawable.bg_striped);
				bg.setTileModeXY(TileMode.REPEAT, TileMode.REPEAT);
				ab.setBackgroundDrawable(bg);
			}
		}
	}
	
	public IBRouterService getBRouterService() {
		if(bRouterServiceConnection == null) {
			return null;
		}
		return bRouterServiceConnection.getBrouterService();
	}
	
	public void setLanguage(Context context) {
		if (prefferedLocale != null) {
			Configuration config = context.getResources().getConfiguration();
			String lang = prefferedLocale.getLanguage();
			if (!"".equals(lang) && !config.locale.getLanguage().equals(lang)) {
				prefferedLocale = new Locale(lang);
				Locale.setDefault(prefferedLocale);
				config.locale = prefferedLocale;
				context.getResources().updateConfiguration(config, context.getResources().getDisplayMetrics());
			}
		}
	}
	
	public RoutingConfiguration.Builder getDefaultRoutingConfig() {
		if (defaultRoutingConfig == null) {
			File routingXml = getAppPath(IndexConstants.ROUTING_XML_FILE);
			if (routingXml.exists() && routingXml.canRead()) {
				try {
					defaultRoutingConfig = RoutingConfiguration.parseFromInputStream(new FileInputStream(routingXml));
				} catch (XmlPullParserException e) {
					throw new IllegalStateException(e);
				} catch (IOException e) {
					throw new IllegalStateException(e);
				}
			} else {
				defaultRoutingConfig = RoutingConfiguration.getDefault();
			}
		}
		return defaultRoutingConfig;
	}
	
	public boolean accessibilityExtensions() {
		return (Build.VERSION.SDK_INT < 14) ? getSettings().ACCESSIBILITY_EXTENSIONS.get() : false;
	}
	
	public boolean accessibilityEnabled() {
		final AccessibilityMode mode = getSettings().ACCESSIBILITY_MODE.get();
		if(OsmandPlugin.getEnabledPlugin(AccessibilityPlugin.class) == null) {
			return false;
		}
		if (mode == AccessibilityMode.ON) {
			return true;
		} else if (mode == AccessibilityMode.OFF) {
			return false;
		}
		return ((AccessibilityManager) getSystemService(Context.ACCESSIBILITY_SERVICE)).isEnabled();
	}

	public String getVersionName() {
		try {
			PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), 0);
			return info.versionName;
		} catch (NameNotFoundException e) {
			return "";
		}
	}

	public int getVersionCode() {
		try {
			PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), 0);
			return info.versionCode;
		} catch (NameNotFoundException e) {
			return 0;
		}
	}

	public void startNavigationService(int intent) {
		final Intent serviceIntent = new Intent(this, NavigationService.class);
		serviceIntent.putExtra(NavigationService.USAGE_INTENT, intent);
		if (getNavigationService() == null) {
			getSettings().SERVICE_OFF_INTERVAL.set(0);
			startService(serviceIntent);
		} else {
			getNavigationService().addUsageIntent(intent);
		}		
	}
}
!@#$%
20190530_010539,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_a10816
package net.osmand.plus;

import java.io.BufferedWriter;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintStream;
import java.lang.Thread.UncaughtExceptionHandler;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

import net.osmand.IndexConstants;
import net.osmand.PlatformUtil;
import net.osmand.access.AccessibilityPlugin;
import net.osmand.access.AccessibleAlertBuilder;
import net.osmand.access.AccessibleToast;
import net.osmand.data.FavouritePoint;
import net.osmand.plus.GPXUtilities.GPXFile;
import net.osmand.plus.GPXUtilities.WptPt;
import net.osmand.plus.access.AccessibilityMode;
import net.osmand.plus.activities.DayNightHelper;
import net.osmand.plus.activities.SavingTrackHelper;
import net.osmand.plus.activities.SettingsActivity;
import net.osmand.plus.api.SQLiteAPI;
import net.osmand.plus.api.SQLiteAPIImpl;
import net.osmand.plus.monitoring.LiveMonitoringHelper;
import net.osmand.plus.render.NativeOsmandLibrary;
import net.osmand.plus.render.RendererRegistry;
import net.osmand.plus.resources.ResourceManager;
import net.osmand.plus.routing.RoutingHelper;
import net.osmand.plus.voice.CommandPlayer;
import net.osmand.plus.voice.CommandPlayerException;
import net.osmand.plus.voice.CommandPlayerFactory;
import net.osmand.render.RenderingRulesStorage;
import net.osmand.router.RoutingConfiguration;
import net.osmand.util.Algorithms;

import org.xmlpull.v1.XmlPullParserException;

import android.app.Activity;
import android.app.AlarmManager;
import android.app.AlertDialog;
import android.app.AlertDialog.Builder;
import android.app.Application;
import android.app.PendingIntent;
import android.app.ProgressDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager.NameNotFoundException;
import android.content.res.Configuration;
import android.graphics.Shader.TileMode;
import android.graphics.drawable.BitmapDrawable;
import android.os.Build;
import android.os.Handler;
import android.os.Message;
import android.text.format.DateFormat;
import android.util.TypedValue;
import android.view.accessibility.AccessibilityManager;
import android.widget.CheckBox;
import android.widget.LinearLayout;
import android.widget.ProgressBar;
import android.widget.LinearLayout.LayoutParams;
import android.widget.TextView;
import android.widget.Toast;
import btools.routingapp.BRouterServiceConnection;
import btools.routingapp.IBRouterService;

import com.actionbarsherlock.app.ActionBar;
import com.actionbarsherlock.app.SherlockActivity;
import com.actionbarsherlock.app.SherlockExpandableListActivity;
import com.actionbarsherlock.app.SherlockListActivity;


public class OsmandApplication extends Application {
	public static final String EXCEPTION_PATH = "exception.log"; //$NON-NLS-1$
	private static final org.apache.commons.logging.Log LOG = PlatformUtil.getLog(OsmandApplication.class);

	
	ResourceManager resourceManager = null;
	PoiFiltersHelper poiFilters = null;
	RoutingHelper routingHelper = null;
	FavouritesDbHelper favorites = null;
	CommandPlayer player = null;

	OsmandSettings osmandSettings = null;

	OsmAndAppCustomization appCustomization;
	DayNightHelper daynightHelper;
	NavigationService navigationService;
	RendererRegistry rendererRegistry;
	OsmAndLocationProvider locationProvider;
	OsmAndTaskManager taskManager;

	// start variables
	private ProgressImplementation startDialog;
	private Handler uiHandler;
	private GPXFile gpxFileToDisplay;
	private SavingTrackHelper savingTrackHelper;
	private LiveMonitoringHelper liveMonitoringHelper;
	private TargetPointsHelper targetPointsHelper;
	private RoutingConfiguration.Builder defaultRoutingConfig;

	private boolean applicationInitializing = false;
	private Locale prefferedLocale = null;
	
	SQLiteAPI sqliteAPI;
	BRouterServiceConnection bRouterServiceConnection;

	@Override
	public void onCreate() {
		long timeToStart = System.currentTimeMillis();
		if (Version.getAppName(this).equals("OsmAnd~")) {
			if (android.os.Build.VERSION.SDK_INT >= 9) {
				try {
					Class.forName("net.osmand.plus.base.EnableStrictMode").newInstance();
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		}
		super.onCreate();
		appCustomization = new OsmAndAppCustomization();
		appCustomization.setup(this);
		 
		sqliteAPI = new SQLiteAPIImpl(this);
		try {
			bRouterServiceConnection = BRouterServiceConnection.connect(this);
		} catch(Exception e) {
			e.printStackTrace();
		}

		// settings used everywhere so they need to be created first
		osmandSettings = appCustomization.createSettings(new net.osmand.plus.api.SettingsAPIImpl(this));
		// always update application mode to default
		if(!osmandSettings.FOLLOW_THE_ROUTE.get()){
			osmandSettings.APPLICATION_MODE.set(osmandSettings.DEFAULT_APPLICATION_MODE.get());
		}
		
		applyTheme(this);
		
		routingHelper = new RoutingHelper(this, player);
		taskManager = new OsmAndTaskManager(this);
		resourceManager = new ResourceManager(this);
		daynightHelper = new DayNightHelper(this);
		locationProvider = new OsmAndLocationProvider(this);
		savingTrackHelper = new SavingTrackHelper(this);
		liveMonitoringHelper = new LiveMonitoringHelper(this);
		uiHandler = new Handler();
		rendererRegistry = new RendererRegistry();
		targetPointsHelper = new TargetPointsHelper(this);
//		if(!osmandSettings.FOLLOW_THE_ROUTE.get()) {
//			targetPointsHelper.clearPointToNavigate(false);
//		}
		
		checkPrefferedLocale();
		startApplication();
		if (LOG.isDebugEnabled()) {
			LOG.debug("Time to start application " + (System.currentTimeMillis() - timeToStart) + " ms. Should be less < 800 ms");
		}
		timeToStart = System.currentTimeMillis();
		OsmandPlugin.initPlugins(this);

		if (LOG.isDebugEnabled()) {
			LOG.debug("Time to init plugins " + (System.currentTimeMillis() - timeToStart) + " ms. Should be less < 800 ms");
		}
		
		
	}

	@Override
	public void onTerminate() {
		super.onTerminate();
		if (routingHelper != null) {
			routingHelper.getVoiceRouter().onApplicationTerminate(this);
		}
	}

	public RendererRegistry getRendererRegistry() {
		return rendererRegistry;
	}
	
	public OsmAndTaskManager getTaskManager() {
		return taskManager;
	}

	
	public OsmAndLocationProvider getLocationProvider() {
		return locationProvider;
	}
	
	public OsmAndAppCustomization getAppCustomization() {
		return appCustomization;
	}
	
	public void setAppCustomization(OsmAndAppCustomization appCustomization) {
		this.appCustomization = appCustomization;
		this.appCustomization.setup(this);
	}

	/**
	 * Application settings
	 * 
	 * @return Reference to instance of OsmandSettings
	 */
	public OsmandSettings getSettings() {
		if (osmandSettings == null) {
			LOG.error("Trying to access settings before they were created");
		}
		return osmandSettings;
	}

	public SavingTrackHelper getSavingTrackHelper() {
		return savingTrackHelper;
	}

	public LiveMonitoringHelper getLiveMonitoringHelper() {
		return liveMonitoringHelper;
	}

	public PoiFiltersHelper getPoiFilters() {
		if (poiFilters == null) {
			poiFilters = new PoiFiltersHelper(this);
		}
		return poiFilters;
	}

	public void setGpxFileToDisplay(GPXFile gpxFileToDisplay, boolean showCurrentGpxFile) {
		this.gpxFileToDisplay = gpxFileToDisplay;
		osmandSettings.SHOW_CURRENT_GPX_TRACK.set(showCurrentGpxFile);
		if (gpxFileToDisplay == null) {
			getFavorites().setFavoritePointsFromGPXFile(null);
		} else {
			List<FavouritePoint> pts = new ArrayList<FavouritePoint>();
			for (WptPt p : gpxFileToDisplay.points) {
				FavouritePoint pt = new FavouritePoint();
				pt.setLatitude(p.lat);
				pt.setLongitude(p.lon);
				if (p.name == null) {
					p.name = "";
				}
				pt.setName(p.name);
				pts.add(pt);
			}
			gpxFileToDisplay.proccessPoints();
			getFavorites().setFavoritePointsFromGPXFile(pts);
		}
	}

	public GPXFile getGpxFileToDisplay() {
		return gpxFileToDisplay;
	}

	public FavouritesDbHelper getFavorites() {
		if (favorites == null) {
			favorites = new FavouritesDbHelper(this);
		}
		return favorites;
	}

	public ResourceManager getResourceManager() {
		return resourceManager;
	}

	public DayNightHelper getDaynightHelper() {
		return daynightHelper;
	}

	@Override
	public void onLowMemory() {
		super.onLowMemory();
		resourceManager.onLowMemory();
	}

	@Override
	public void onConfigurationChanged(Configuration newConfig) {
		if (prefferedLocale != null && !newConfig.locale.getLanguage().equals(prefferedLocale.getLanguage())) {
			super.onConfigurationChanged(newConfig);
			// ugly fix ! On devices after 4.0 screen is blinking when you rotate device!
			if (Build.VERSION.SDK_INT < 14) {
				newConfig.locale = prefferedLocale;
			}
			getBaseContext().getResources().updateConfiguration(newConfig, getBaseContext().getResources().getDisplayMetrics());
			Locale.setDefault(prefferedLocale);
		} else {
			super.onConfigurationChanged(newConfig);
		}
	}

	public void checkPrefferedLocale() {
		Configuration config = getBaseContext().getResources().getConfiguration();
		String lang = osmandSettings.PREFERRED_LOCALE.get();
		if (!"".equals(lang) && !config.locale.getLanguage().equals(lang)) {
			prefferedLocale = new Locale(lang);
			Locale.setDefault(prefferedLocale);
			config.locale = prefferedLocale;
			getBaseContext().getResources().updateConfiguration(config, getBaseContext().getResources().getDisplayMetrics());
		}
		String clang = "".equals(lang) ? config.locale.getLanguage() : lang;
		resourceManager.getOsmandRegions().setLocale(clang);

	}

	public static final int PROGRESS_DIALOG = 5;

	public void checkApplicationIsBeingInitialized(Activity activity, ProgressDialog progressDialog) {
		// start application if it was previously closed
		startApplication();
		synchronized (OsmandApplication.this) {
			if (startDialog != null) {
				progressDialog.setTitle(getString(R.string.loading_data));
				progressDialog.setMessage(getString(R.string.reading_indexes));
				activity.showDialog(PROGRESS_DIALOG);
				startDialog.setDialog(progressDialog);
			} else {
				progressDialog.dismiss();
			}
		}
	}
	
	public void checkApplicationIsBeingInitialized(Activity activity, TextView tv, ProgressBar progressBar,
			Runnable onClose) {
		// start application if it was previously closed
		startApplication();
		synchronized (OsmandApplication.this) {
			if (startDialog != null ) {
				tv.setText(getString(R.string.loading_data));
				startDialog.setProgressBar(tv, progressBar, onClose);
			} else if (onClose != null) {
				onClose.run();
			}
		}
	}

	public boolean isApplicationInitializing() {
		return startDialog != null;
	}

	public RoutingHelper getRoutingHelper() {
		return routingHelper;
	}

	public CommandPlayer getPlayer() {
		return player;
	}

	public void initVoiceCommandPlayer(final Activity uiContext) {
		showDialogInitializingCommandPlayer(uiContext, true, null, false);
	}

	public void showDialogInitializingCommandPlayer(final Activity uiContext, boolean warningNoneProvider) {
		showDialogInitializingCommandPlayer(uiContext, warningNoneProvider, null, true);
	}

	public void showDialogInitializingCommandPlayer(final Activity uiContext, boolean warningNoneProvider, Runnable run, boolean showDialog) {
		String voiceProvider = osmandSettings.VOICE_PROVIDER.get();
		if (voiceProvider == null || OsmandSettings.VOICE_PROVIDER_NOT_USE.equals(voiceProvider)) {
			if (warningNoneProvider && voiceProvider == null) {
				Builder builder = new AccessibleAlertBuilder(uiContext);
				LinearLayout ll = new LinearLayout(uiContext);
				ll.setOrientation(LinearLayout.VERTICAL);
				final TextView tv = new TextView(uiContext);
				tv.setPadding(7, 3, 7, 0);
				tv.setText(R.string.voice_is_not_available_msg);
				tv.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 19);
				ll.addView(tv);
				
				final CheckBox cb = new CheckBox(uiContext);
				cb.setText(R.string.remember_choice);
				LinearLayout.LayoutParams lp = new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);
				lp.setMargins(7, 10, 7, 0);
				cb.setLayoutParams(lp);
				ll.addView(cb);
				
				builder.setCancelable(true);
				builder.setNegativeButton(R.string.default_buttons_cancel, new DialogInterface.OnClickListener() {
					@Override
					public void onClick(DialogInterface dialog, int which) {
						if(cb.isChecked()) {
							osmandSettings.VOICE_PROVIDER.set(OsmandSettings.VOICE_PROVIDER_NOT_USE);
						}
					}
				});
				builder.setPositiveButton(R.string.default_buttons_ok, new DialogInterface.OnClickListener() {
					@Override
					public void onClick(DialogInterface dialog, int which) {
						Intent intent = new Intent(uiContext, SettingsActivity.class);
						intent.putExtra(SettingsActivity.INTENT_KEY_SETTINGS_SCREEN, SettingsActivity.SCREEN_GENERAL_SETTINGS);
						uiContext.startActivity(intent);
					}
				});
				
				
				builder.setTitle(R.string.voice_is_not_available_title);
				builder.setView(ll);
				//builder.setMessage(R.string.voice_is_not_available_msg);
				builder.show();
			}

		} else {
			if (player == null || !Algorithms.objectEquals(voiceProvider, player.getCurrentVoice())) {
				initVoiceDataInDifferentThread(uiContext, voiceProvider, run, showDialog);
			}
		}

	}

	private void initVoiceDataInDifferentThread(final Activity uiContext, final String voiceProvider, final Runnable run, boolean showDialog) {
		final ProgressDialog dlg = showDialog ? ProgressDialog.show(uiContext, getString(R.string.loading_data),
				getString(R.string.voice_data_initializing)) : null;
		new Thread(new Runnable() {
			@Override
			public void run() {
				try {
					if (player != null) {
						player.clear();
					}
					player = CommandPlayerFactory.createCommandPlayer(voiceProvider, OsmandApplication.this, uiContext);
					routingHelper.getVoiceRouter().setPlayer(player);
					if(dlg != null) {
						dlg.dismiss();
					}
					if (run != null && uiContext != null) {
						uiContext.runOnUiThread(run);
					}
				} catch (CommandPlayerException e) {
					if(dlg != null) {
						dlg.dismiss();
					}
					showToastMessage(e.getError());
				}
			}
		}).start();
	}

	public NavigationService getNavigationService() {
		return navigationService;
	}

	public void setNavigationService(NavigationService navigationService) {
		this.navigationService = navigationService;
	}


	private void fullExit() {
		// http://stackoverflow.com/questions/2092951/how-to-close-android-application
		System.runFinalizersOnExit(true);
		System.exit(0);
	}

	public synchronized void closeApplication(final Activity activity) {
		if (getNavigationService() != null) {
			Builder bld = new AlertDialog.Builder(activity);
			bld.setMessage(R.string.background_service_is_enabled_question);
			bld.setPositiveButton(R.string.default_buttons_yes, new DialogInterface.OnClickListener() {
				@Override
				public void onClick(DialogInterface dialog, int which) {
					closeApplicationAnyway(activity, true);
				}
			});
			bld.setNegativeButton(R.string.default_buttons_no, new DialogInterface.OnClickListener() {
				@Override
				public void onClick(DialogInterface dialog, int which) {
					closeApplicationAnyway(activity, false);
				}
			});
			bld.show();
		} else {
			closeApplicationAnyway(activity, true);
		}
	}

	private void closeApplicationAnyway(final Activity activity, boolean disableService) {
		if (applicationInitializing) {
			resourceManager.close();
		}
		applicationInitializing = false;

		activity.finish();

		if (getNavigationService() == null) {
			fullExit();
		}
		else if (disableService) {
			final Intent serviceIntent = new Intent(this, NavigationService.class);
			stopService(serviceIntent);

			new Thread(new Runnable() {
				public void run() {
					//wait until the service has fully stopped
					while (getNavigationService() != null) {
						try {
							Thread.sleep(100);
						}
							catch (InterruptedException e) {
						}
					}

					fullExit();
				}
			}).start();
		}
	}

	public synchronized void startApplication() {
		if (applicationInitializing) {
			return;
		}
		applicationInitializing = true;
		startDialog = new ProgressImplementation(this, null, false);

		startDialog.setRunnable("Initializing app", new Runnable() { //$NON-NLS-1$
					@Override
					public void run() {
						startApplicationBackground();
					}
				});
		startDialog.run();

		Thread.setDefaultUncaughtExceptionHandler(new DefaultExceptionHandler());

	}

	private void startApplicationBackground() {
		List<String> warnings = new ArrayList<String>();
		try {
			try {
				SpecialPhrases.setLanguage(this, osmandSettings);
			} catch (IOException e) {
				LOG.error("I/O exception", e);
				warnings.add("Error while reading the special phrases. Restart OsmAnd if possible");
			}
			if (!Version.isBlackberry(this)) {
				if (osmandSettings.NATIVE_RENDERING_FAILED.get()) {
					osmandSettings.SAFE_MODE.set(true);
					osmandSettings.NATIVE_RENDERING_FAILED.set(false);
					warnings.add(getString(R.string.native_library_not_supported));
				} else {
					osmandSettings.SAFE_MODE.set(false);
					osmandSettings.NATIVE_RENDERING_FAILED.set(true);
					startDialog.startTask(getString(R.string.init_native_library), -1);
					RenderingRulesStorage storage = rendererRegistry.getCurrentSelectedRenderer();
					boolean initialized = NativeOsmandLibrary.getLibrary(storage, this) != null;
					osmandSettings.NATIVE_RENDERING_FAILED.set(false);
					if (!initialized) {
						LOG.info("Native library could not be loaded!");
					}
				}
			}
			warnings.addAll(resourceManager.reloadIndexes(startDialog));
			player = null;
			if (savingTrackHelper.hasDataToSave()) {
				startDialog.startTask(getString(R.string.saving_gpx_tracks), -1);
				try {
					warnings.addAll(savingTrackHelper.saveDataToGpx());
				} catch (RuntimeException e) {
					warnings.add(e.getMessage());
				}
			}

			// restore backuped favorites to normal file
			final File appDir = getAppPath(null);
			File save = new File(appDir, FavouritesDbHelper.FILE_TO_SAVE);
			File bak = new File(appDir, FavouritesDbHelper.FILE_TO_BACKUP);
			if (bak.exists() && (!save.exists() || bak.lastModified() > save.lastModified())) {
				if (save.exists()) {
					save.delete();
				}
				bak.renameTo(save);
			}
		} catch (RuntimeException e) {
			e.printStackTrace();
			warnings.add(e.getMessage());
		} finally {
			synchronized (OsmandApplication.this) {
				final ProgressDialog toDismiss;
				final Runnable pb;
				if (startDialog != null) {
					toDismiss = startDialog.getDialog();
					pb = startDialog.getFinishRunnable();
				} else {
					toDismiss = null;
					pb = null;
				}
				startDialog = null;

				if (toDismiss != null || pb != null) {
					uiHandler.post(new Runnable() {
						@Override
						public void run() {
							if(pb != null) {
								pb.run();
							}
							if (toDismiss != null) {
								// TODO handling this dialog is bad, we need a better standard way
								toDismiss.dismiss();
								// toDismiss.getOwnerActivity().dismissDialog(PROGRESS_DIALOG);
							}
						}
					});
				}
				if (warnings != null && !warnings.isEmpty()) {
					showToastMessage(formatWarnings(warnings).toString());
				}
			}
		}
	}

	private StringBuilder formatWarnings(List<String> warnings) {
		final StringBuilder b = new StringBuilder();
		boolean f = true;
		for (String w : warnings) {
			if (f) {
				f = false;
			} else {
				b.append('\n');
			}
			b.append(w);
		}
		return b;
	}


	private class DefaultExceptionHandler implements UncaughtExceptionHandler {

		private UncaughtExceptionHandler defaultHandler;
		private PendingIntent intent;

		public DefaultExceptionHandler() {
			defaultHandler = Thread.getDefaultUncaughtExceptionHandler();
			intent = PendingIntent.getActivity(OsmandApplication.this.getBaseContext(), 0,
					new Intent(OsmandApplication.this.getBaseContext(),
							getAppCustomization().getMainMenuActivity()), 0);
		}

		@Override
		public void uncaughtException(final Thread thread, final Throwable ex) {
			File file = getAppPath(EXCEPTION_PATH);
			try {
				ByteArrayOutputStream out = new ByteArrayOutputStream();
				PrintStream printStream = new PrintStream(out);
				ex.printStackTrace(printStream);
				StringBuilder msg = new StringBuilder();
				msg.append("Version  " + Version.getFullVersion(OsmandApplication.this) + "\n"). //$NON-NLS-1$ 
						append(DateFormat.format("dd.MM.yyyy h:mm:ss", System.currentTimeMillis()));
				try {
					PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), 0);
					if (info != null) {
						msg.append("\nApk Version : ").append(info.versionName).append(" ").append(info.versionCode); //$NON-NLS-1$ //$NON-NLS-2$
					}
				} catch (Throwable e) {
				}
				msg.append("\n"). //$NON-NLS-1$//$NON-NLS-2$
						append("Exception occured in thread " + thread.toString() + " : \n"). //$NON-NLS-1$ //$NON-NLS-2$
						append(new String(out.toByteArray()));

				if (file.getParentFile().canWrite()) {
					BufferedWriter writer = new BufferedWriter(new FileWriter(file, true));
					writer.write(msg.toString());
					writer.close();
				}
				if (routingHelper.isFollowingMode()) {
					AlarmManager mgr = (AlarmManager) getSystemService(Context.ALARM_SERVICE);
					mgr.set(AlarmManager.RTC, System.currentTimeMillis() + 2000, intent);
					System.exit(2);
				}
				defaultHandler.uncaughtException(thread, ex);
			} catch (Exception e) {
				// swallow all exceptions
				android.util.Log.e(PlatformUtil.TAG, "Exception while handle other exception", e); //$NON-NLS-1$
			}

		}
	}

	
	public TargetPointsHelper getTargetPointsHelper() {
		return targetPointsHelper;
	}
	
	public void showShortToastMessage(int msgId, Object... args) {
		AccessibleToast.makeText(this, getString(msgId, args), Toast.LENGTH_SHORT).show();
	}

	public void showToastMessage(int msgId, Object... args) {
		AccessibleToast.makeText(this, getString(msgId, args), Toast.LENGTH_LONG).show();
	}

	public void showToastMessage(String msg) {
		AccessibleToast.makeText(this, msg, Toast.LENGTH_LONG).show();		
	}
	
	public SQLiteAPI getSQLiteAPI() {
		return sqliteAPI;
	}

	public void runInUIThread(Runnable run) {
		uiHandler.post(run);
	}

	public void runInUIThread(Runnable run, long delay) {
		uiHandler.postDelayed(run, delay);
	}
	
	public void runMessageInUIThreadAndCancelPrevious(final int messageId, final Runnable run, long delay) {
		Message msg = Message.obtain(uiHandler, new Runnable() {
			
			@Override
			public void run() {
				if(!uiHandler.hasMessages(messageId)) {
					run.run();
				}
			}
		});
		msg.what = messageId;
		uiHandler.removeMessages(messageId);
		uiHandler.sendMessageDelayed(msg, delay);
	}
	
	public File getAppPath(String path) {
		if(path == null) {
			path = "";
		}
		return new File(getSettings().getExternalStorageDirectory(), IndexConstants.APP_DIR + path);
	}

	public void applyTheme(Context c) {
		int t = R.style.OsmandLightDarkActionBarTheme;
		if (osmandSettings.OSMAND_THEME.get() == OsmandSettings.OSMAND_DARK_THEME) {
			t = R.style.OsmandDarkTheme;
		} else if (osmandSettings.OSMAND_THEME.get() == OsmandSettings.OSMAND_LIGHT_THEME) {
			t = R.style.OsmandLightTheme;
		} else if (osmandSettings.OSMAND_THEME.get() == OsmandSettings.OSMAND_LIGHT_DARK_ACTIONBAR_THEME) {
			t = R.style.OsmandLightDarkActionBarTheme;
		}
		setLanguage(c);
		c.setTheme(t);
		if (osmandSettings.OSMAND_THEME.get() == OsmandSettings.OSMAND_LIGHT_DARK_ACTIONBAR_THEME
				&& Build.VERSION.SDK_INT < Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
			ActionBar ab = null;
			if (c instanceof SherlockActivity) {
				ab = ((SherlockActivity) c).getSupportActionBar();
			} else if (c instanceof SherlockListActivity) {
				ab = ((SherlockListActivity) c).getSupportActionBar();
			} else if (c instanceof SherlockExpandableListActivity) {
				ab = ((SherlockExpandableListActivity) c).getSupportActionBar();
			}
			if (ab != null) {
				BitmapDrawable bg = (BitmapDrawable) getResources().getDrawable(R.drawable.bg_striped);
				bg.setTileModeXY(TileMode.REPEAT, TileMode.REPEAT);
				ab.setBackgroundDrawable(bg);
			}
		}
	}
	
	public IBRouterService getBRouterService() {
		if(bRouterServiceConnection == null) {
			return null;
		}
		return bRouterServiceConnection.getBrouterService();
	}
	
	public void setLanguage(Context context) {
		if (prefferedLocale != null) {
			Configuration config = context.getResources().getConfiguration();
			String lang = prefferedLocale.getLanguage();
			if (!"".equals(lang) && !config.locale.getLanguage().equals(lang)) {
				prefferedLocale = new Locale(lang);
				Locale.setDefault(prefferedLocale);
				config.locale = prefferedLocale;
				context.getResources().updateConfiguration(config, context.getResources().getDisplayMetrics());
			}
		}
	}
	
	public RoutingConfiguration.Builder getDefaultRoutingConfig() {
		if (defaultRoutingConfig == null) {
			File routingXml = getAppPath(IndexConstants.ROUTING_XML_FILE);
			if (routingXml.exists() && routingXml.canRead()) {
				try {
					defaultRoutingConfig = RoutingConfiguration.parseFromInputStream(new FileInputStream(routingXml));
				} catch (XmlPullParserException e) {
					throw new IllegalStateException(e);
				} catch (IOException e) {
					throw new IllegalStateException(e);
				}
			} else {
				defaultRoutingConfig = RoutingConfiguration.getDefault();
			}
		}
		return defaultRoutingConfig;
	}
	
	public boolean accessibilityExtensions() {
		return (Build.VERSION.SDK_INT < 14) ? getSettings().ACCESSIBILITY_EXTENSIONS.get() : false;
	}
	
	public boolean accessibilityEnabled() {
		final AccessibilityMode mode = getSettings().ACCESSIBILITY_MODE.get();
		if(OsmandPlugin.getEnabledPlugin(AccessibilityPlugin.class) == null) {
			return false;
		}
		if (mode == AccessibilityMode.ON) {
			return true;
		} else if (mode == AccessibilityMode.OFF) {
			return false;
		}
		return ((AccessibilityManager) getSystemService(Context.ACCESSIBILITY_SERVICE)).isEnabled();
	}

	public String getVersionName() {
		try {
			PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), 0);
			return info.versionName;
		} catch (NameNotFoundException e) {
			return "";
		}
	}

	public int getVersionCode() {
		try {
			PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), 0);
			return info.versionCode;
		} catch (NameNotFoundException e) {
			return 0;
		}
	}

	public void startNavigationService(int intent) {
		final Intent serviceIntent = new Intent(this, NavigationService.class);
		serviceIntent.putExtra(NavigationService.USAGE_INTENT, intent);
		if (getNavigationService() == null) {
			getSettings().SERVICE_OFF_INTERVAL.set(0);
			startService(serviceIntent);
		} else {
			getNavigationService().addUsageIntent(intent);
		}		
	}
}
!@#$%
20190530_010539,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_c10816
package net.osmand.plus;

import java.io.BufferedWriter;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintStream;
import java.lang.Thread.UncaughtExceptionHandler;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

import net.osmand.IndexConstants;
import net.osmand.PlatformUtil;
import net.osmand.access.AccessibilityPlugin;
import net.osmand.access.AccessibleAlertBuilder;
import net.osmand.access.AccessibleToast;
import net.osmand.plus.access.AccessibilityMode;
import net.osmand.plus.activities.DayNightHelper;
import net.osmand.plus.activities.SavingTrackHelper;
import net.osmand.plus.activities.SettingsActivity;
import net.osmand.plus.api.SQLiteAPI;
import net.osmand.plus.api.SQLiteAPIImpl;
import net.osmand.plus.monitoring.LiveMonitoringHelper;
import net.osmand.plus.render.NativeOsmandLibrary;
import net.osmand.plus.render.RendererRegistry;
import net.osmand.plus.resources.ResourceManager;
import net.osmand.plus.routing.RoutingHelper;
import net.osmand.plus.voice.CommandPlayer;
import net.osmand.plus.voice.CommandPlayerException;
import net.osmand.plus.voice.CommandPlayerFactory;
import net.osmand.render.RenderingRulesStorage;
import net.osmand.router.RoutingConfiguration;
import net.osmand.util.Algorithms;

import org.xmlpull.v1.XmlPullParserException;

import android.app.Activity;
import android.app.AlarmManager;
import android.app.AlertDialog;
import android.app.AlertDialog.Builder;
import android.app.Application;
import android.app.PendingIntent;
import android.app.ProgressDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager.NameNotFoundException;
import android.content.res.Configuration;
import android.graphics.Shader.TileMode;
import android.graphics.drawable.BitmapDrawable;
import android.os.Build;
import android.os.Handler;
import android.os.Message;
import android.text.format.DateFormat;
import android.util.TypedValue;
import android.view.accessibility.AccessibilityManager;
import android.widget.CheckBox;
import android.widget.LinearLayout;
import android.widget.LinearLayout.LayoutParams;
import android.widget.ProgressBar;
import android.widget.TextView;
import android.widget.Toast;
import btools.routingapp.BRouterServiceConnection;
import btools.routingapp.IBRouterService;

import com.actionbarsherlock.app.ActionBar;
import com.actionbarsherlock.app.SherlockActivity;
import com.actionbarsherlock.app.SherlockExpandableListActivity;
import com.actionbarsherlock.app.SherlockListActivity;


public class OsmandApplication extends Application {
	public static final String EXCEPTION_PATH = "exception.log"; //$NON-NLS-1$
	private static final org.apache.commons.logging.Log LOG = PlatformUtil.getLog(OsmandApplication.class);

	
	ResourceManager resourceManager = null;
	PoiFiltersHelper poiFilters = null;
	RoutingHelper routingHelper = null;
	FavouritesDbHelper favorites = null;
	CommandPlayer player = null;

	OsmandSettings osmandSettings = null;

	OsmAndAppCustomization appCustomization;
	DayNightHelper daynightHelper;
	NavigationService navigationService;
	RendererRegistry rendererRegistry;
	OsmAndLocationProvider locationProvider;
	OsmAndTaskManager taskManager;

	// start variables
	private ProgressImplementation startDialog;
	private Handler uiHandler;
	private GpxSelectionHelper selectedGpxHelper;
	private SavingTrackHelper savingTrackHelper;
	private LiveMonitoringHelper liveMonitoringHelper;
	private TargetPointsHelper targetPointsHelper;
	private RoutingConfiguration.Builder defaultRoutingConfig;

	private boolean applicationInitializing = false;
	private Locale prefferedLocale = null;
	
	SQLiteAPI sqliteAPI;
	BRouterServiceConnection bRouterServiceConnection;

	@Override
	public void onCreate() {
		long timeToStart = System.currentTimeMillis();
		if (Version.getAppName(this).equals("OsmAnd~")) {
			if (android.os.Build.VERSION.SDK_INT >= 9) {
				try {
					Class.forName("net.osmand.plus.base.EnableStrictMode").newInstance();
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		}
		super.onCreate();
		appCustomization = new OsmAndAppCustomization();
		appCustomization.setup(this);
		 
		sqliteAPI = new SQLiteAPIImpl(this);
		try {
			bRouterServiceConnection = BRouterServiceConnection.connect(this);
		} catch(Exception e) {
			e.printStackTrace();
		}

		// settings used everywhere so they need to be created first
		osmandSettings = appCustomization.createSettings(new net.osmand.plus.api.SettingsAPIImpl(this));
		// always update application mode to default
		if(!osmandSettings.FOLLOW_THE_ROUTE.get()){
			osmandSettings.APPLICATION_MODE.set(osmandSettings.DEFAULT_APPLICATION_MODE.get());
		}
		
		applyTheme(this);
		
		routingHelper = new RoutingHelper(this, player);
		taskManager = new OsmAndTaskManager(this);
		resourceManager = new ResourceManager(this);
		daynightHelper = new DayNightHelper(this);
		locationProvider = new OsmAndLocationProvider(this);
		savingTrackHelper = new SavingTrackHelper(this);
		liveMonitoringHelper = new LiveMonitoringHelper(this);
		selectedGpxHelper = new GpxSelectionHelper(this);
		uiHandler = new Handler();
		rendererRegistry = new RendererRegistry();
		targetPointsHelper = new TargetPointsHelper(this);
//		if(!osmandSettings.FOLLOW_THE_ROUTE.get()) {
//			targetPointsHelper.clearPointToNavigate(false);
//		}
		
		checkPrefferedLocale();
		startApplication();
		if (LOG.isDebugEnabled()) {
			LOG.debug("Time to start application " + (System.currentTimeMillis() - timeToStart) + " ms. Should be less < 800 ms");
		}
		timeToStart = System.currentTimeMillis();
		OsmandPlugin.initPlugins(this);

		if (LOG.isDebugEnabled()) {
			LOG.debug("Time to init plugins " + (System.currentTimeMillis() - timeToStart) + " ms. Should be less < 800 ms");
		}
		
		
	}

	@Override
	public void onTerminate() {
		super.onTerminate();
		if (routingHelper != null) {
			routingHelper.getVoiceRouter().onApplicationTerminate(this);
		}
	}

	public RendererRegistry getRendererRegistry() {
		return rendererRegistry;
	}
	
	public OsmAndTaskManager getTaskManager() {
		return taskManager;
	}

	
	public OsmAndLocationProvider getLocationProvider() {
		return locationProvider;
	}
	
	public OsmAndAppCustomization getAppCustomization() {
		return appCustomization;
	}
	
	public void setAppCustomization(OsmAndAppCustomization appCustomization) {
		this.appCustomization = appCustomization;
		this.appCustomization.setup(this);
	}

	/**
	 * Application settings
	 * 
	 * @return Reference to instance of OsmandSettings
	 */
	public OsmandSettings getSettings() {
		if (osmandSettings == null) {
			LOG.error("Trying to access settings before they were created");
		}
		return osmandSettings;
	}

	public SavingTrackHelper getSavingTrackHelper() {
		return savingTrackHelper;
	}

	public LiveMonitoringHelper getLiveMonitoringHelper() {
		return liveMonitoringHelper;
	}

	public PoiFiltersHelper getPoiFilters() {
		if (poiFilters == null) {
			poiFilters = new PoiFiltersHelper(this);
		}
		return poiFilters;
	}


	public GpxSelectionHelper getSelectedGpxHelper() {
		return selectedGpxHelper;
	}

	public FavouritesDbHelper getFavorites() {
		if (favorites == null) {
			favorites = new FavouritesDbHelper(this);
		}
		return favorites;
	}

	public ResourceManager getResourceManager() {
		return resourceManager;
	}

	public DayNightHelper getDaynightHelper() {
		return daynightHelper;
	}

	@Override
	public void onLowMemory() {
		super.onLowMemory();
		resourceManager.onLowMemory();
	}

	@Override
	public void onConfigurationChanged(Configuration newConfig) {
		if (prefferedLocale != null && !newConfig.locale.getLanguage().equals(prefferedLocale.getLanguage())) {
			super.onConfigurationChanged(newConfig);
			// ugly fix ! On devices after 4.0 screen is blinking when you rotate device!
			if (Build.VERSION.SDK_INT < 14) {
				newConfig.locale = prefferedLocale;
			}
			getBaseContext().getResources().updateConfiguration(newConfig, getBaseContext().getResources().getDisplayMetrics());
			Locale.setDefault(prefferedLocale);
		} else {
			super.onConfigurationChanged(newConfig);
		}
	}

	public void checkPrefferedLocale() {
		Configuration config = getBaseContext().getResources().getConfiguration();
		String lang = osmandSettings.PREFERRED_LOCALE.get();
		if (!"".equals(lang) && !config.locale.getLanguage().equals(lang)) {
			prefferedLocale = new Locale(lang);
			Locale.setDefault(prefferedLocale);
			config.locale = prefferedLocale;
			getBaseContext().getResources().updateConfiguration(config, getBaseContext().getResources().getDisplayMetrics());
		}
		String clang = "".equals(lang) ? config.locale.getLanguage() : lang;
		resourceManager.getOsmandRegions().setLocale(clang);

	}

	public static final int PROGRESS_DIALOG = 5;

	public void checkApplicationIsBeingInitialized(Activity activity, ProgressDialog progressDialog) {
		// start application if it was previously closed
		startApplication();
		synchronized (OsmandApplication.this) {
			if (startDialog != null) {
				progressDialog.setTitle(getString(R.string.loading_data));
				progressDialog.setMessage(getString(R.string.reading_indexes));
				activity.showDialog(PROGRESS_DIALOG);
				startDialog.setDialog(progressDialog);
			} else {
				progressDialog.dismiss();
			}
		}
	}
	
	public void checkApplicationIsBeingInitialized(Activity activity, TextView tv, ProgressBar progressBar,
			Runnable onClose) {
		// start application if it was previously closed
		startApplication();
		synchronized (OsmandApplication.this) {
			if (startDialog != null ) {
				tv.setText(getString(R.string.loading_data));
				startDialog.setProgressBar(tv, progressBar, onClose);
			} else if (onClose != null) {
				onClose.run();
			}
		}
	}

	public boolean isApplicationInitializing() {
		return startDialog != null;
	}

	public RoutingHelper getRoutingHelper() {
		return routingHelper;
	}

	public CommandPlayer getPlayer() {
		return player;
	}

	public void initVoiceCommandPlayer(final Activity uiContext) {
		showDialogInitializingCommandPlayer(uiContext, true, null, false);
	}

	public void showDialogInitializingCommandPlayer(final Activity uiContext, boolean warningNoneProvider) {
		showDialogInitializingCommandPlayer(uiContext, warningNoneProvider, null, true);
	}

	public void showDialogInitializingCommandPlayer(final Activity uiContext, boolean warningNoneProvider, Runnable run, boolean showDialog) {
		String voiceProvider = osmandSettings.VOICE_PROVIDER.get();
		if (voiceProvider == null || OsmandSettings.VOICE_PROVIDER_NOT_USE.equals(voiceProvider)) {
			if (warningNoneProvider && voiceProvider == null) {
				Builder builder = new AccessibleAlertBuilder(uiContext);
				LinearLayout ll = new LinearLayout(uiContext);
				ll.setOrientation(LinearLayout.VERTICAL);
				final TextView tv = new TextView(uiContext);
				tv.setPadding(7, 3, 7, 0);
				tv.setText(R.string.voice_is_not_available_msg);
				tv.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 19);
				ll.addView(tv);
				
				final CheckBox cb = new CheckBox(uiContext);
				cb.setText(R.string.remember_choice);
				LinearLayout.LayoutParams lp = new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);
				lp.setMargins(7, 10, 7, 0);
				cb.setLayoutParams(lp);
				ll.addView(cb);
				
				builder.setCancelable(true);
				builder.setNegativeButton(R.string.default_buttons_cancel, new DialogInterface.OnClickListener() {
					@Override
					public void onClick(DialogInterface dialog, int which) {
						if(cb.isChecked()) {
							osmandSettings.VOICE_PROVIDER.set(OsmandSettings.VOICE_PROVIDER_NOT_USE);
						}
					}
				});
				builder.setPositiveButton(R.string.default_buttons_ok, new DialogInterface.OnClickListener() {
					@Override
					public void onClick(DialogInterface dialog, int which) {
						Intent intent = new Intent(uiContext, SettingsActivity.class);
						intent.putExtra(SettingsActivity.INTENT_KEY_SETTINGS_SCREEN, SettingsActivity.SCREEN_GENERAL_SETTINGS);
						uiContext.startActivity(intent);
					}
				});
				
				
				builder.setTitle(R.string.voice_is_not_available_title);
				builder.setView(ll);
				//builder.setMessage(R.string.voice_is_not_available_msg);
				builder.show();
			}

		} else {
			if (player == null || !Algorithms.objectEquals(voiceProvider, player.getCurrentVoice())) {
				initVoiceDataInDifferentThread(uiContext, voiceProvider, run, showDialog);
			}
		}

	}

	private void initVoiceDataInDifferentThread(final Activity uiContext, final String voiceProvider, final Runnable run, boolean showDialog) {
		final ProgressDialog dlg = showDialog ? ProgressDialog.show(uiContext, getString(R.string.loading_data),
				getString(R.string.voice_data_initializing)) : null;
		new Thread(new Runnable() {
			@Override
			public void run() {
				try {
					if (player != null) {
						player.clear();
					}
					player = CommandPlayerFactory.createCommandPlayer(voiceProvider, OsmandApplication.this, uiContext);
					routingHelper.getVoiceRouter().setPlayer(player);
					if(dlg != null) {
						dlg.dismiss();
					}
					if (run != null && uiContext != null) {
						uiContext.runOnUiThread(run);
					}
				} catch (CommandPlayerException e) {
					if(dlg != null) {
						dlg.dismiss();
					}
					showToastMessage(e.getError());
				}
			}
		}).start();
	}

	public NavigationService getNavigationService() {
		return navigationService;
	}

	public void setNavigationService(NavigationService navigationService) {
		this.navigationService = navigationService;
	}


	private void fullExit() {
		// http://stackoverflow.com/questions/2092951/how-to-close-android-application
		System.runFinalizersOnExit(true);
		System.exit(0);
	}

	public synchronized void closeApplication(final Activity activity) {
		if (getNavigationService() != null) {
			Builder bld = new AlertDialog.Builder(activity);
			bld.setMessage(R.string.background_service_is_enabled_question);
			bld.setPositiveButton(R.string.default_buttons_yes, new DialogInterface.OnClickListener() {
				@Override
				public void onClick(DialogInterface dialog, int which) {
					closeApplicationAnyway(activity, true);
				}
			});
			bld.setNegativeButton(R.string.default_buttons_no, new DialogInterface.OnClickListener() {
				@Override
				public void onClick(DialogInterface dialog, int which) {
					closeApplicationAnyway(activity, false);
				}
			});
			bld.show();
		} else {
			closeApplicationAnyway(activity, true);
		}
	}

	private void closeApplicationAnyway(final Activity activity, boolean disableService) {
		if (applicationInitializing) {
			resourceManager.close();
		}
		applicationInitializing = false;

		activity.finish();

		if (getNavigationService() == null) {
			fullExit();
		}
		else if (disableService) {
			final Intent serviceIntent = new Intent(this, NavigationService.class);
			stopService(serviceIntent);

			new Thread(new Runnable() {
				public void run() {
					//wait until the service has fully stopped
					while (getNavigationService() != null) {
						try {
							Thread.sleep(100);
						}
							catch (InterruptedException e) {
						}
					}

					fullExit();
				}
			}).start();
		}
	}

	public synchronized void startApplication() {
		if (applicationInitializing) {
			return;
		}
		applicationInitializing = true;
		startDialog = new ProgressImplementation(this, null, false);

		startDialog.setRunnable("Initializing app", new Runnable() { //$NON-NLS-1$
					@Override
					public void run() {
						startApplicationBackground();
					}
				});
		startDialog.run();

		Thread.setDefaultUncaughtExceptionHandler(new DefaultExceptionHandler());

	}

	private void startApplicationBackground() {
		List<String> warnings = new ArrayList<String>();
		try {
			try {
				SpecialPhrases.setLanguage(this, osmandSettings);
			} catch (IOException e) {
				LOG.error("I/O exception", e);
				warnings.add("Error while reading the special phrases. Restart OsmAnd if possible");
			}
			if (!Version.isBlackberry(this)) {
				if (osmandSettings.NATIVE_RENDERING_FAILED.get()) {
					osmandSettings.SAFE_MODE.set(true);
					osmandSettings.NATIVE_RENDERING_FAILED.set(false);
					warnings.add(getString(R.string.native_library_not_supported));
				} else {
					osmandSettings.SAFE_MODE.set(false);
					osmandSettings.NATIVE_RENDERING_FAILED.set(true);
					startDialog.startTask(getString(R.string.init_native_library), -1);
					RenderingRulesStorage storage = rendererRegistry.getCurrentSelectedRenderer();
					boolean initialized = NativeOsmandLibrary.getLibrary(storage, this) != null;
					osmandSettings.NATIVE_RENDERING_FAILED.set(false);
					if (!initialized) {
						LOG.info("Native library could not be loaded!");
					}
				}
			}
			warnings.addAll(resourceManager.reloadIndexes(startDialog));
			player = null;
			if (savingTrackHelper.hasDataToSave()) {
				startDialog.startTask(getString(R.string.saving_gpx_tracks), -1);
				try {
					warnings.addAll(savingTrackHelper.saveDataToGpx());
				} catch (RuntimeException e) {
					warnings.add(e.getMessage());
				}
			}

			// restore backuped favorites to normal file
			final File appDir = getAppPath(null);
			File save = new File(appDir, FavouritesDbHelper.FILE_TO_SAVE);
			File bak = new File(appDir, FavouritesDbHelper.FILE_TO_BACKUP);
			if (bak.exists() && (!save.exists() || bak.lastModified() > save.lastModified())) {
				if (save.exists()) {
					save.delete();
				}
				bak.renameTo(save);
			}
		} catch (RuntimeException e) {
			e.printStackTrace();
			warnings.add(e.getMessage());
		} finally {
			synchronized (OsmandApplication.this) {
				final ProgressDialog toDismiss;
				final Runnable pb;
				if (startDialog != null) {
					toDismiss = startDialog.getDialog();
					pb = startDialog.getFinishRunnable();
				} else {
					toDismiss = null;
					pb = null;
				}
				startDialog = null;

				if (toDismiss != null || pb != null) {
					uiHandler.post(new Runnable() {
						@Override
						public void run() {
							if(pb != null) {
								pb.run();
							}
							if (toDismiss != null) {
								// TODO handling this dialog is bad, we need a better standard way
								toDismiss.dismiss();
								// toDismiss.getOwnerActivity().dismissDialog(PROGRESS_DIALOG);
							}
						}
					});
				}
				if (warnings != null && !warnings.isEmpty()) {
					showToastMessage(formatWarnings(warnings).toString());
				}
			}
		}
	}

	private StringBuilder formatWarnings(List<String> warnings) {
		final StringBuilder b = new StringBuilder();
		boolean f = true;
		for (String w : warnings) {
			if (f) {
				f = false;
			} else {
				b.append('\n');
			}
			b.append(w);
		}
		return b;
	}


	private class DefaultExceptionHandler implements UncaughtExceptionHandler {

		private UncaughtExceptionHandler defaultHandler;
		private PendingIntent intent;

		public DefaultExceptionHandler() {
			defaultHandler = Thread.getDefaultUncaughtExceptionHandler();
			intent = PendingIntent.getActivity(OsmandApplication.this.getBaseContext(), 0,
					new Intent(OsmandApplication.this.getBaseContext(),
							getAppCustomization().getMainMenuActivity()), 0);
		}

		@Override
		public void uncaughtException(final Thread thread, final Throwable ex) {
			File file = getAppPath(EXCEPTION_PATH);
			try {
				ByteArrayOutputStream out = new ByteArrayOutputStream();
				PrintStream printStream = new PrintStream(out);
				ex.printStackTrace(printStream);
				StringBuilder msg = new StringBuilder();
				msg.append("Version  " + Version.getFullVersion(OsmandApplication.this) + "\n"). //$NON-NLS-1$ 
						append(DateFormat.format("dd.MM.yyyy h:mm:ss", System.currentTimeMillis()));
				try {
					PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), 0);
					if (info != null) {
						msg.append("\nApk Version : ").append(info.versionName).append(" ").append(info.versionCode); //$NON-NLS-1$ //$NON-NLS-2$
					}
				} catch (Throwable e) {
				}
				msg.append("\n"). //$NON-NLS-1$//$NON-NLS-2$
						append("Exception occured in thread " + thread.toString() + " : \n"). //$NON-NLS-1$ //$NON-NLS-2$
						append(new String(out.toByteArray()));

				if (file.getParentFile().canWrite()) {
					BufferedWriter writer = new BufferedWriter(new FileWriter(file, true));
					writer.write(msg.toString());
					writer.close();
				}
				if (routingHelper.isFollowingMode()) {
					AlarmManager mgr = (AlarmManager) getSystemService(Context.ALARM_SERVICE);
					mgr.set(AlarmManager.RTC, System.currentTimeMillis() + 2000, intent);
					System.exit(2);
				}
				defaultHandler.uncaughtException(thread, ex);
			} catch (Exception e) {
				// swallow all exceptions
				android.util.Log.e(PlatformUtil.TAG, "Exception while handle other exception", e); //$NON-NLS-1$
			}

		}
	}

	
	public TargetPointsHelper getTargetPointsHelper() {
		return targetPointsHelper;
	}
	
	public void showShortToastMessage(int msgId, Object... args) {
		AccessibleToast.makeText(this, getString(msgId, args), Toast.LENGTH_SHORT).show();
	}

	public void showToastMessage(int msgId, Object... args) {
		AccessibleToast.makeText(this, getString(msgId, args), Toast.LENGTH_LONG).show();
	}

	public void showToastMessage(String msg) {
		AccessibleToast.makeText(this, msg, Toast.LENGTH_LONG).show();		
	}
	
	public SQLiteAPI getSQLiteAPI() {
		return sqliteAPI;
	}

	public void runInUIThread(Runnable run) {
		uiHandler.post(run);
	}

	public void runInUIThread(Runnable run, long delay) {
		uiHandler.postDelayed(run, delay);
	}
	
	public void runMessageInUIThreadAndCancelPrevious(final int messageId, final Runnable run, long delay) {
		Message msg = Message.obtain(uiHandler, new Runnable() {
			
			@Override
			public void run() {
				if(!uiHandler.hasMessages(messageId)) {
					run.run();
				}
			}
		});
		msg.what = messageId;
		uiHandler.removeMessages(messageId);
		uiHandler.sendMessageDelayed(msg, delay);
	}
	
	public File getAppPath(String path) {
		if(path == null) {
			path = "";
		}
		return new File(getSettings().getExternalStorageDirectory(), IndexConstants.APP_DIR + path);
	}

	public void applyTheme(Context c) {
		int t = R.style.OsmandLightDarkActionBarTheme;
		if (osmandSettings.OSMAND_THEME.get() == OsmandSettings.OSMAND_DARK_THEME) {
			t = R.style.OsmandDarkTheme;
		} else if (osmandSettings.OSMAND_THEME.get() == OsmandSettings.OSMAND_LIGHT_THEME) {
			t = R.style.OsmandLightTheme;
		} else if (osmandSettings.OSMAND_THEME.get() == OsmandSettings.OSMAND_LIGHT_DARK_ACTIONBAR_THEME) {
			t = R.style.OsmandLightDarkActionBarTheme;
		}
		setLanguage(c);
		c.setTheme(t);
		if (osmandSettings.OSMAND_THEME.get() == OsmandSettings.OSMAND_LIGHT_DARK_ACTIONBAR_THEME
				&& Build.VERSION.SDK_INT < Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
			ActionBar ab = null;
			if (c instanceof SherlockActivity) {
				ab = ((SherlockActivity) c).getSupportActionBar();
			} else if (c instanceof SherlockListActivity) {
				ab = ((SherlockListActivity) c).getSupportActionBar();
			} else if (c instanceof SherlockExpandableListActivity) {
				ab = ((SherlockExpandableListActivity) c).getSupportActionBar();
			}
			if (ab != null) {
				BitmapDrawable bg = (BitmapDrawable) getResources().getDrawable(R.drawable.bg_striped);
				bg.setTileModeXY(TileMode.REPEAT, TileMode.REPEAT);
				ab.setBackgroundDrawable(bg);
			}
		}
	}
	
	public IBRouterService getBRouterService() {
		if(bRouterServiceConnection == null) {
			return null;
		}
		return bRouterServiceConnection.getBrouterService();
	}
	
	public void setLanguage(Context context) {
		if (prefferedLocale != null) {
			Configuration config = context.getResources().getConfiguration();
			String lang = prefferedLocale.getLanguage();
			if (!"".equals(lang) && !config.locale.getLanguage().equals(lang)) {
				prefferedLocale = new Locale(lang);
				Locale.setDefault(prefferedLocale);
				config.locale = prefferedLocale;
				context.getResources().updateConfiguration(config, context.getResources().getDisplayMetrics());
			}
		}
	}
	
	public RoutingConfiguration.Builder getDefaultRoutingConfig() {
		if (defaultRoutingConfig == null) {
			File routingXml = getAppPath(IndexConstants.ROUTING_XML_FILE);
			if (routingXml.exists() && routingXml.canRead()) {
				try {
					defaultRoutingConfig = RoutingConfiguration.parseFromInputStream(new FileInputStream(routingXml));
				} catch (XmlPullParserException e) {
					throw new IllegalStateException(e);
				} catch (IOException e) {
					throw new IllegalStateException(e);
				}
			} else {
				defaultRoutingConfig = RoutingConfiguration.getDefault();
			}
		}
		return defaultRoutingConfig;
	}
	
	public boolean accessibilityExtensions() {
		return (Build.VERSION.SDK_INT < 14) ? getSettings().ACCESSIBILITY_EXTENSIONS.get() : false;
	}
	
	public boolean accessibilityEnabled() {
		final AccessibilityMode mode = getSettings().ACCESSIBILITY_MODE.get();
		if(OsmandPlugin.getEnabledPlugin(AccessibilityPlugin.class) == null) {
			return false;
		}
		if (mode == AccessibilityMode.ON) {
			return true;
		} else if (mode == AccessibilityMode.OFF) {
			return false;
		}
		return ((AccessibilityManager) getSystemService(Context.ACCESSIBILITY_SERVICE)).isEnabled();
	}

	public String getVersionName() {
		try {
			PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), 0);
			return info.versionName;
		} catch (NameNotFoundException e) {
			return "";
		}
	}

	public int getVersionCode() {
		try {
			PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), 0);
			return info.versionCode;
		} catch (NameNotFoundException e) {
			return 0;
		}
	}

	public void startNavigationService(int intent) {
		final Intent serviceIntent = new Intent(this, NavigationService.class);
		serviceIntent.putExtra(NavigationService.USAGE_INTENT, intent);
		if (getNavigationService() == null) {
			getSettings().SERVICE_OFF_INTERVAL.set(0);
			startService(serviceIntent);
		} else {
			getNavigationService().addUsageIntent(intent);
		}		
	}
}
!@#$%
20190530_010735,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_b03868
package net.osmand.plus.routepointsnavigation;

import java.io.File;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.List;

import net.osmand.data.LatLon;
import net.osmand.plus.ApplicationMode;
import net.osmand.plus.GPXUtilities;
import net.osmand.plus.GPXUtilities.GPXFile;
import net.osmand.plus.GPXUtilities.Route;
import net.osmand.plus.GPXUtilities.WptPt;
import net.osmand.plus.OsmAndFormatter;
import net.osmand.plus.OsmandApplication;
import net.osmand.plus.OsmandPlugin;
import net.osmand.plus.R;
import net.osmand.plus.TargetPointsHelper;
import net.osmand.plus.activities.MapActivity;
import net.osmand.plus.views.MapInfoLayer;
import net.osmand.plus.views.OsmandMapLayer;
import net.osmand.plus.views.OsmandMapTileView;
import net.osmand.plus.views.mapwidgets.TextInfoWidget;
import net.osmand.util.MapUtils;
import android.content.Intent;
import android.graphics.Paint;
import android.text.format.DateFormat;
import android.view.View;

/**
 * Created by Barsik on 10.06.2014.
 */
public class RoutePointsPlugin extends OsmandPlugin {

	public static final String ID = "osmand.route.stepsPlugin";

	private static final String VISITED_KEY = "VISITED_KEY";

	private OsmandApplication app;
	private TextInfoWidget routeStepsControl;
	private SelectedRouteGpxFile currentRoute;
	
	public RoutePointsPlugin(OsmandApplication app) {
		ApplicationMode.regWidget("route_steps", ApplicationMode.CAR, ApplicationMode.DEFAULT);
		this.app = app;
	}

	public SelectedRouteGpxFile getCurrentRoute() {
		return currentRoute;
	}

	
	public void setCurrentRoute(GPXFile gpx) {
		if(gpx == null) {
			currentRoute = null;
		} else {
			currentRoute = new SelectedRouteGpxFile(gpx);
		}
	}
	
	
	@Override
	public void destinationReached() {
		if(currentRoute != null) {
			currentRoute.naviateToNextPoint();
		}
	}

	@Override
	public String getId() {
		return ID;
	}

	@Override
	public String getDescription() {
		return app.getString(R.string.route_plugin_descr);
	}

	@Override
	public String getName() {
		return app.getString(R.string.route_plugin_name);
	}

	@Override
	public boolean init(OsmandApplication app) {
		return true;
	}

	private void registerWidget(MapActivity activity) {
		MapInfoLayer mapInfoLayer = activity.getMapLayers().getMapInfoLayer();
		if (mapInfoLayer != null) {
			routeStepsControl = createRouteStepsInfoControl(activity, mapInfoLayer.getPaintSubText(), mapInfoLayer.getPaintSubText());
			mapInfoLayer.getMapInfoControls().registerSideWidget(routeStepsControl,
					R.drawable.widget_target, R.string.map_widget_route_points, "route_steps", false, 8);
			mapInfoLayer.recreateControls();
		}
	}


	@Override
	public void updateLayers(OsmandMapTileView mapView, MapActivity activity) {
		if (routeStepsControl == null) {
			registerWidget(activity);
		}
	}

	public String getVisitedAllString() {
		if (currentRoute != null) {
			return String.valueOf(currentRoute.getVisitedCount()) + "/" + String.valueOf(currentRoute.getCount());
		} else {
			return app.getString(R.string.route_points_no_gpx);

		}
	}

	private TextInfoWidget createRouteStepsInfoControl(final MapActivity map, Paint paintText, Paint paintSubText) {
		TextInfoWidget routeStepsControl = new TextInfoWidget(map, 0, paintText, paintSubText) {

			@Override()
			public boolean updateInfo(OsmandMapLayer.DrawSettings drawSettings) {
				setText(getVisitedAllString(), "");
				return true;
			}

		};
		routeStepsControl.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				Intent intent = new Intent(app, RoutePointsActivity.class);
				intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
				app.startActivity(intent);
			}
		});
		routeStepsControl.setText(null, null);
		routeStepsControl.setImageDrawable(map.getResources().getDrawable(R.drawable.widget_target));
		return routeStepsControl;
	}

	
	public class RoutePoint {
		boolean isNextNavigate;
		int gpxOrder;
		long visitedTime; // 0 not visited
		WptPt wpt;
		
		public String getName() {
			return wpt.name;
		}
		
		public WptPt getWpt() {
			return wpt;
		}
		
		public boolean isNextNavigate() {
			return isNextNavigate;
		}
		public boolean isVisited() {
			return visitedTime != 0;
		}
		
		public int getGpxOrder() {
			return gpxOrder;
		}
		
		public String getDistance(RoutePoint rp) {
			double d = MapUtils.getDistance(rp.getPoint(), getPoint());
			String distance = OsmAndFormatter.getFormattedDistance((float) d, app);
			return distance;
		}
		
		public String getTime() {
			if(visitedTime == 0) {
				return "";
			}
			String dateString;
			Date date = new Date(visitedTime);
			if (DateFormat.is24HourFormat(app)) {
				dateString = DateFormat.format("MM/dd k:mm", date).toString();
			} else {
				dateString = DateFormat.format("MM/dd h:mm", date).toString() + DateFormat.format("aa", date).toString();
			}
			return dateString;
		}
		
		public LatLon getPoint() {
			return new LatLon(wpt.lat, wpt.lon);
		}

		public void setVisitedTime(long currentTimeMillis) {
			visitedTime = currentTimeMillis;
			wpt.getExtensionsToWrite().put(VISITED_KEY, visitedTime+"");
		}
		
	}
	
	public class SelectedRouteGpxFile {
		private GPXUtilities.GPXFile gpx;
		private List<RoutePoint> currentPoints = new ArrayList<RoutePointsPlugin.RoutePoint>();
		
		
		public SelectedRouteGpxFile(GPXUtilities.GPXFile gpx) {
			this.gpx = gpx;
			parseGPXFile(gpx);
		}
		
		public List<RoutePoint> getCurrentPoints() {
			return currentPoints;
		}
		
		public int getVisitedCount() {
			int k = 0;
			for(RoutePoint rp : currentPoints) {
				if(rp.isVisited()) {
					k++;
				}
			}
			return k;
		}
		
		public int getCount() {
			return currentPoints.size();
		}
		
		public GPXUtilities.Route getRoute() {
			if(gpx.routes.isEmpty()) {
				return null;
			}
			return gpx.routes.get(0);
		}
		
		public String saveFile() {
			return GPXUtilities.writeGpxFile(new File(gpx.path), gpx, app);
		}
		
		public void markPoint(RoutePoint point, boolean visited) {
			if(point.isNextNavigate() && visited) {
				naviateToNextPoint();
				return;
			}
			if(visited) {
				point.setVisitedTime(System.currentTimeMillis());
			} else {
				point.setVisitedTime(0);
			}
			sortPoints();
		}
		
		public void naviateToNextPoint() {
			if(!currentPoints.isEmpty()) {
				RoutePoint rp = currentPoints.get(0);
				if(rp.isNextNavigate) {
					rp.setVisitedTime(System.currentTimeMillis());
					sortPoints();
				}
				RoutePoint first = currentPoints.get(0);
				if(!first.isVisited()) {
					app.getTargetPointsHelper().navigateToPoint(first.getPoint(), true, -1, first.getName());
					first.isNextNavigate = true;
				} else {
					app.getTargetPointsHelper().clearPointToNavigate(true);
				}
				
			}
		}

		private void sortPoints() {
			Collections.sort(currentPoints, new Comparator<RoutePoint>() {

				@Override
				public int compare(RoutePoint lhs, RoutePoint rhs) {
					if(lhs.isNextNavigate || rhs.isNextNavigate) {
						return lhs.isNextNavigate? -1 : 1;
					}
					if(!lhs.isVisited() || !rhs.isVisited()) {
						if(lhs.isVisited()) {
							return 1;
						}
						if(rhs.isVisited()) {
							return -1;
						}
						return Integer.compare(lhs.gpxOrder, rhs.gpxOrder);
					}
					return -Long.compare(lhs.visitedTime, rhs.visitedTime);
				}
			});
		}

		
		private void parseGPXFile(GPXFile gpx) {
			this.gpx = gpx;
			Route rt = getRoute();
			currentPoints.clear();
			if(rt != null) {
				TargetPointsHelper targetPointsHelper = app.getTargetPointsHelper();
				String locName = targetPointsHelper.getPointNavigateDescription();
				for(int i = 0; i < rt.points.size(); i++) {
					WptPt wptPt = rt.points.get(i);
					RoutePoint rtp = new RoutePoint();
					rtp.gpxOrder = i;
					rtp.wpt = wptPt;
					String time = wptPt.getExtensionsToRead().get(VISITED_KEY);
					try {
						rtp.visitedTime = Long.parseLong(time);
					} catch (NumberFormatException e) {
					}
					rtp.isNextNavigate = rtp.visitedTime == 0 && locName != null && locName.equals(wptPt.name);
					if(rtp.isNextNavigate) {
						locName = null;
					}
					currentPoints.add(rtp);
				}
				sortPoints();
			}
		}

		public String getName() {
			return gpx.path.substring(gpx.path.lastIndexOf("/") + 1, gpx.path.lastIndexOf("."));
		}

		public void navigateToPoint(RoutePoint rp) {
			if (!currentPoints.isEmpty()) {
				if (currentPoints.get(0).isNextNavigate()) {
					currentPoints.get(0).isNextNavigate = false;
				}
			}
			rp.isNextNavigate = true;
			sortPoints();
			app.getTargetPointsHelper().navigateToPoint(rp.getPoint(), true, -1, rp.getName());
		}

		public void updateCurrentTargetPoint() {
			TargetPointsHelper targetPointsHelper = app.getTargetPointsHelper();
			String locName = targetPointsHelper.getPointNavigateDescription();
			for(int i = 0; i < currentPoints.size(); i++) {
				RoutePoint rtp = currentPoints.get(i);
				rtp.isNextNavigate = rtp.visitedTime == 0 && locName != null && locName.equals(rtp.getName());
				if(rtp.isNextNavigate) {
					locName = null;
				}
				
			}
			sortPoints();
		}
	
	}

}
!@#$%
20190530_010735,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_a03868
package net.osmand.plus.routepointsnavigation;

import java.io.File;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.List;

import net.osmand.data.LatLon;
import net.osmand.plus.ApplicationMode;
import net.osmand.plus.GPXUtilities;
import net.osmand.plus.GPXUtilities.GPXFile;
import net.osmand.plus.GPXUtilities.Route;
import net.osmand.plus.GPXUtilities.WptPt;
import net.osmand.plus.OsmAndFormatter;
import net.osmand.plus.OsmandApplication;
import net.osmand.plus.OsmandPlugin;
import net.osmand.plus.R;
import net.osmand.plus.TargetPointsHelper;
import net.osmand.plus.activities.MapActivity;
import net.osmand.plus.views.MapInfoLayer;
import net.osmand.plus.views.OsmandMapLayer;
import net.osmand.plus.views.OsmandMapTileView;
import net.osmand.plus.views.mapwidgets.TextInfoWidget;
import net.osmand.util.MapUtils;
import android.content.Intent;
import android.graphics.Paint;
import android.text.format.DateFormat;
import android.view.View;

/**
 * Created by Barsik on 10.06.2014.
 */
public class RoutePointsPlugin extends OsmandPlugin {

	public static final String ID = "osmand.route.stepsPlugin";

	private static final String VISITED_KEY = "VISITED_KEY";

	private OsmandApplication app;
	private TextInfoWidget routeStepsControl;
	private SelectedRouteGpxFile currentRoute;
	
	public RoutePointsPlugin(OsmandApplication app) {
		ApplicationMode.regWidget("route_steps", ApplicationMode.CAR, ApplicationMode.DEFAULT);
		this.app = app;
	}

	public SelectedRouteGpxFile getCurrentRoute() {
		return currentRoute;
	}

	
	public void setCurrentRoute(GPXFile gpx) {
		if(gpx == null) {
			currentRoute = null;
		} else {
			currentRoute = new SelectedRouteGpxFile(gpx);
		}
	}
	
	
	@Override
	public void destinationReached() {
		if(currentRoute != null) {
			currentRoute.naviateToNextPoint();
		}
	}

	@Override
	public String getId() {
		return ID;
	}

	@Override
	public String getDescription() {
		return app.getString(R.string.route_plugin_descr);
	}

	@Override
	public String getName() {
		return app.getString(R.string.route_plugin_name);
	}

	@Override
	public boolean init(OsmandApplication app) {
		return true;
	}

	private void registerWidget(MapActivity activity) {
		MapInfoLayer mapInfoLayer = activity.getMapLayers().getMapInfoLayer();
		if (mapInfoLayer != null) {
			routeStepsControl = createRouteStepsInfoControl(activity, mapInfoLayer.getPaintSubText(), mapInfoLayer.getPaintSubText());
			mapInfoLayer.getMapInfoControls().registerSideWidget(routeStepsControl,
					R.drawable.widget_target, R.string.map_widget_route_points, "route_steps", false, 8);
			mapInfoLayer.recreateControls();
		}
	}


	@Override
	public void updateLayers(OsmandMapTileView mapView, MapActivity activity) {

		if (routeStepsControl == null) {
			registerWidget(activity);
		}
	}

	public String getVisitedAllString() {
		if (currentRoute != null) {
			return String.valueOf(currentRoute.getVisitedCount()) + "/" + String.valueOf(currentRoute.getCount());
		} else {
			return app.getString(R.string.route_points_no_gpx);

		}
	}

	private TextInfoWidget createRouteStepsInfoControl(final MapActivity map, Paint paintText, Paint paintSubText) {
		TextInfoWidget routeStepsControl = new TextInfoWidget(map, 0, paintText, paintSubText) {

			@Override()
			public boolean updateInfo(OsmandMapLayer.DrawSettings drawSettings) {
				setText(getVisitedAllString(), "");
				return true;
			}

		};
		routeStepsControl.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				Intent intent = new Intent(app, RoutePointsActivity.class);
				intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
				app.startActivity(intent);
			}
		});
		routeStepsControl.setText(null, null);
		routeStepsControl.setImageDrawable(map.getResources().getDrawable(R.drawable.widget_target));
		return routeStepsControl;
	}

	
	public class RoutePoint {
		boolean isNextNavigate;
		int gpxOrder;
		long visitedTime; // 0 not visited
		WptPt wpt;
		
		public String getName() {
			return wpt.name;
		}
		
		public WptPt getWpt() {
			return wpt;
		}
		
		public boolean isNextNavigate() {
			return isNextNavigate;
		}
		public boolean isVisited() {
			return visitedTime != 0;
		}
		
		public int getGpxOrder() {
			return gpxOrder;
		}
		
		public String getDistance(RoutePoint rp) {
			double d = MapUtils.getDistance(rp.getPoint(), getPoint());
			String distance = OsmAndFormatter.getFormattedDistance((float) d, app);
			return distance;
		}
		
		public String getTime() {
			if(visitedTime == 0) {
				return "";
			}
			String dateString;
			Date date = new Date(visitedTime);
			if (DateFormat.is24HourFormat(app)) {
				dateString = DateFormat.format("MM/dd k:mm", date).toString();
			} else {
				dateString = DateFormat.format("MM/dd h:mm", date).toString() + DateFormat.format("aa", date).toString();
			}
			return dateString;
		}
		
		public LatLon getPoint() {
			return new LatLon(wpt.lat, wpt.lon);
		}

		public void setVisitedTime(long currentTimeMillis) {
			visitedTime = currentTimeMillis;
			wpt.getExtensionsToWrite().put(VISITED_KEY, visitedTime+"");
		}
		
	}
	
	public class SelectedRouteGpxFile {
		private GPXUtilities.GPXFile gpx;
		private List<RoutePoint> currentPoints = new ArrayList<RoutePointsPlugin.RoutePoint>();
		
		
		public SelectedRouteGpxFile(GPXUtilities.GPXFile gpx) {
			this.gpx = gpx;
			parseGPXFile(gpx);
		}
		
		public List<RoutePoint> getCurrentPoints() {
			return currentPoints;
		}
		
		public int getVisitedCount() {
			int k = 0;
			for(RoutePoint rp : currentPoints) {
				if(rp.isVisited()) {
					k++;
				}
			}
			return k;
		}
		
		public int getCount() {
			return currentPoints.size();
		}
		
		public GPXUtilities.Route getRoute() {
			if(gpx.routes.isEmpty()) {
				return null;
			}
			return gpx.routes.get(0);
		}
		
		public String saveFile() {
			return GPXUtilities.writeGpxFile(new File(gpx.path), gpx, app);
		}
		
		public void markPoint(RoutePoint point, boolean visited) {
			if(point.isNextNavigate() && visited) {
				naviateToNextPoint();
				return;
			}
			if(visited) {
				point.setVisitedTime(System.currentTimeMillis());
			} else {
				point.setVisitedTime(0);
			}
			sortPoints();
		}
		
		public void naviateToNextPoint() {
			if(!currentPoints.isEmpty()) {
				RoutePoint rp = currentPoints.get(0);
				if(rp.isNextNavigate) {
					rp.setVisitedTime(System.currentTimeMillis());
					sortPoints();
				}
				RoutePoint first = currentPoints.get(0);
				if(!first.isVisited()) {
					app.getTargetPointsHelper().navigateToPoint(first.getPoint(), true, -1, first.getName());
					first.isNextNavigate = true;
				} else {
					app.getTargetPointsHelper().clearPointToNavigate(true);
				}
				
			}
		}

		private void sortPoints() {
			Collections.sort(currentPoints, new Comparator<RoutePoint>() {

				@Override
				public int compare(RoutePoint lhs, RoutePoint rhs) {
					if(lhs.isNextNavigate || rhs.isNextNavigate) {
						return lhs.isNextNavigate? -1 : 1;
					}
					if(!lhs.isVisited() || !rhs.isVisited()) {
						if(lhs.isVisited()) {
							return 1;
						}
						if(rhs.isVisited()) {
							return -1;
						}
						return Integer.compare(lhs.gpxOrder, rhs.gpxOrder);
					}
					return -Long.compare(lhs.visitedTime, rhs.visitedTime);
				}
			});
		}

		
		private void parseGPXFile(GPXFile gpx) {
			this.gpx = gpx;
			Route rt = getRoute();
			currentPoints.clear();
			if(rt != null) {
				TargetPointsHelper targetPointsHelper = app.getTargetPointsHelper();
				String locName = targetPointsHelper.getPointNavigateDescription();
				for(int i = 0; i < rt.points.size(); i++) {
					WptPt wptPt = rt.points.get(i);
					RoutePoint rtp = new RoutePoint();
					rtp.gpxOrder = i;
					rtp.wpt = wptPt;
					String time = wptPt.getExtensionsToRead().get(VISITED_KEY);
					try {
						rtp.visitedTime = Long.parseLong(time);
					} catch (NumberFormatException e) {
					}
					rtp.isNextNavigate = rtp.visitedTime == 0 && locName != null && locName.equals(wptPt.name);
					if(rtp.isNextNavigate) {
						locName = null;
					}
					currentPoints.add(rtp);
				}
				sortPoints();
			}
		}

		public String getName() {
			return gpx.path.substring(gpx.path.lastIndexOf("/") + 1, gpx.path.lastIndexOf("."));
		}

		public void navigateToPoint(RoutePoint rp) {
			if (!currentPoints.isEmpty()) {
				if (currentPoints.get(0).isNextNavigate()) {
					currentPoints.get(0).isNextNavigate = false;
				}
			}
			rp.isNextNavigate = true;
			sortPoints();
			app.getTargetPointsHelper().navigateToPoint(rp.getPoint(), true, -1, rp.getName());
		}

		public void updateCurrentTargetPoint() {
			TargetPointsHelper targetPointsHelper = app.getTargetPointsHelper();
			String locName = targetPointsHelper.getPointNavigateDescription();
			for(int i = 0; i < currentPoints.size(); i++) {
				RoutePoint rtp = currentPoints.get(i);
				rtp.isNextNavigate = rtp.visitedTime == 0 && locName != null && locName.equals(rtp.getName());
				if(rtp.isNextNavigate) {
					locName = null;
				}
				
			}
			sortPoints();
		}
	
	}

}
!@#$%
20190530_010735,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_c03868
package net.osmand.plus.routepointsnavigation;

import java.io.File;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.List;

import net.osmand.data.LatLon;
import net.osmand.plus.ApplicationMode;
import net.osmand.plus.GPXUtilities;
import net.osmand.plus.GPXUtilities.GPXFile;
import net.osmand.plus.GPXUtilities.Route;
import net.osmand.plus.GPXUtilities.WptPt;
import net.osmand.plus.OsmAndFormatter;
import net.osmand.plus.OsmandApplication;
import net.osmand.plus.OsmandPlugin;
import net.osmand.plus.R;
import net.osmand.plus.TargetPointsHelper;
import net.osmand.plus.activities.MapActivity;
import net.osmand.plus.views.MapInfoLayer;
import net.osmand.plus.views.OsmandMapLayer;
import net.osmand.plus.views.OsmandMapTileView;
import net.osmand.plus.views.mapwidgets.TextInfoWidget;
import net.osmand.util.MapUtils;
import android.content.Intent;
import android.graphics.Paint;
import android.text.format.DateFormat;
import android.view.View;

/**
 * Created by Barsik on 10.06.2014.
 */
public class RoutePointsPlugin extends OsmandPlugin {

	public static final String ID = "osmand.route.stepsPlugin";

	private static final String VISITED_KEY = "VISITED_KEY";

	private OsmandApplication app;
	private TextInfoWidget routeStepsControl;
	private SelectedRouteGpxFile currentRoute;
	
	public RoutePointsPlugin(OsmandApplication app) {
		ApplicationMode.regWidget("route_steps", ApplicationMode.CAR, ApplicationMode.DEFAULT);
		this.app = app;
	}

	public SelectedRouteGpxFile getCurrentRoute() {
		return currentRoute;
	}

	
	public void setCurrentRoute(GPXFile gpx) {
		if(gpx == null) {
			currentRoute = null;
		} else {
			currentRoute = new SelectedRouteGpxFile(gpx);
		}
	}
	
	
	@Override
	public boolean destinationReached() {
		if(currentRoute != null) {
			boolean naviateToNextPoint = currentRoute.naviateToNextPoint();
			if(naviateToNextPoint) {
				return false;
			}
		}
		return true;
	}

	@Override
	public String getId() {
		return ID;
	}

	@Override
	public String getDescription() {
		return app.getString(R.string.route_plugin_descr);
	}

	@Override
	public String getName() {
		return app.getString(R.string.route_plugin_name);
	}

	@Override
	public boolean init(OsmandApplication app) {
		return true;
	}

	private void registerWidget(MapActivity activity) {
		MapInfoLayer mapInfoLayer = activity.getMapLayers().getMapInfoLayer();
		if (mapInfoLayer != null) {
			routeStepsControl = createRouteStepsInfoControl(activity, mapInfoLayer.getPaintSubText(), mapInfoLayer.getPaintSubText());
			mapInfoLayer.getMapInfoControls().registerSideWidget(routeStepsControl,
					R.drawable.widget_target, R.string.map_widget_route_points, "route_steps", false, 8);
			mapInfoLayer.recreateControls();
		}
	}

	@Override
	public void registerLayers(MapActivity activity) {
		super.registerLayers(activity);
		registerWidget(activity);
	}

	@Override
	public void updateLayers(OsmandMapTileView mapView, MapActivity activity) {
		if (routeStepsControl == null) {
			registerWidget(activity);
		}
	}

	public String getVisitedAllString() {
		if (currentRoute != null) {
			return String.valueOf(currentRoute.getVisitedCount()) + "/" + String.valueOf(currentRoute.getCount());
		} else {
			return app.getString(R.string.route_points_no_gpx);

		}
	}

	private TextInfoWidget createRouteStepsInfoControl(final MapActivity map, Paint paintText, Paint paintSubText) {
		TextInfoWidget routeStepsControl = new TextInfoWidget(map, 0, paintText, paintSubText) {

			@Override()
			public boolean updateInfo(OsmandMapLayer.DrawSettings drawSettings) {
				setText(getVisitedAllString(), "");
				return true;
			}

		};
		routeStepsControl.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				Intent intent = new Intent(app, RoutePointsActivity.class);
				intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
				app.startActivity(intent);
			}
		});
		routeStepsControl.setText(null, null);
		routeStepsControl.setImageDrawable(map.getResources().getDrawable(R.drawable.widget_target));
		return routeStepsControl;
	}

	
	public class RoutePoint {
		boolean isNextNavigate;
		int gpxOrder;
		long visitedTime; // 0 not visited
		WptPt wpt;
		
		public String getName() {
			return wpt.name;
		}
		
		public WptPt getWpt() {
			return wpt;
		}
		
		public boolean isNextNavigate() {
			return isNextNavigate;
		}
		public boolean isVisited() {
			return visitedTime != 0;
		}
		
		public int getGpxOrder() {
			return gpxOrder;
		}
		
		public String getDistance(RoutePoint rp) {
			double d = MapUtils.getDistance(rp.getPoint(), getPoint());
			String distance = OsmAndFormatter.getFormattedDistance((float) d, app);
			return distance;
		}
		
		public String getTime() {
			if(visitedTime == 0) {
				return "";
			}
			String dateString;
			Date date = new Date(visitedTime);
			if (DateFormat.is24HourFormat(app)) {
				dateString = DateFormat.format("MM/dd k:mm", date).toString();
			} else {
				dateString = DateFormat.format("MM/dd h:mm", date).toString() + DateFormat.format("aa", date).toString();
			}
			return dateString;
		}
		
		public LatLon getPoint() {
			return new LatLon(wpt.lat, wpt.lon);
		}

		public void setVisitedTime(long currentTimeMillis) {
			visitedTime = currentTimeMillis;
			wpt.getExtensionsToWrite().put(VISITED_KEY, visitedTime+"");
		}
		
	}
	
	public class SelectedRouteGpxFile {
		private GPXUtilities.GPXFile gpx;
		private List<RoutePoint> currentPoints = new ArrayList<RoutePointsPlugin.RoutePoint>();
		
		
		public SelectedRouteGpxFile(GPXUtilities.GPXFile gpx) {
			this.gpx = gpx;
			parseGPXFile(gpx);
		}
		
		public List<RoutePoint> getCurrentPoints() {
			return currentPoints;
		}
		
		public int getVisitedCount() {
			int k = 0;
			for(RoutePoint rp : currentPoints) {
				if(rp.isVisited()) {
					k++;
				}
			}
			return k;
		}
		
		public int getCount() {
			return currentPoints.size();
		}
		
		public GPXUtilities.Route getRoute() {
			if(gpx.routes.isEmpty()) {
				return null;
			}
			return gpx.routes.get(0);
		}
		
		public String saveFile() {
			return GPXUtilities.writeGpxFile(new File(gpx.path), gpx, app);
		}
		
		public void markPoint(RoutePoint point, boolean visited) {
			if(point.isNextNavigate() && visited) {
				naviateToNextPoint();
				return;
			}
			if(visited) {
				point.setVisitedTime(System.currentTimeMillis());
			} else {
				point.setVisitedTime(0);
			}
			sortPoints();
		}
		
		public boolean naviateToNextPoint() {
			if(!currentPoints.isEmpty()) {
				RoutePoint rp = currentPoints.get(0);
				if(rp.isNextNavigate) {
					rp.setVisitedTime(System.currentTimeMillis());
					sortPoints();
				}
				RoutePoint first = currentPoints.get(0);
				if(!first.isVisited()) {
					app.getTargetPointsHelper().navigateToPoint(first.getPoint(), true, -1, first.getName());
					first.isNextNavigate = true;
					return true;
				} else {
					app.getTargetPointsHelper().clearPointToNavigate(true);
				}
			}
			return false;
		}

		private void sortPoints() {
			Collections.sort(currentPoints, new Comparator<RoutePoint>() {

				@Override
				public int compare(RoutePoint lhs, RoutePoint rhs) {
					if(lhs.isNextNavigate || rhs.isNextNavigate) {
						return lhs.isNextNavigate? -1 : 1;
					}
					if(!lhs.isVisited() || !rhs.isVisited()) {
						if(lhs.isVisited()) {
							return 1;
						}
						if(rhs.isVisited()) {
							return -1;
						}
						return lcompare(lhs.gpxOrder, rhs.gpxOrder);
					}
					return -lcompare(lhs.visitedTime, rhs.visitedTime);
				}
				
				public int lcompare(long lhs, long rhs) {
			        return lhs < rhs ? -1 : (lhs == rhs ? 0 : 1);
			    }
			});
		}

		
		private void parseGPXFile(GPXFile gpx) {
			this.gpx = gpx;
			Route rt = getRoute();
			currentPoints.clear();
			if(rt != null) {
				TargetPointsHelper targetPointsHelper = app.getTargetPointsHelper();
				String locName = targetPointsHelper.getPointNavigateDescription();
				for(int i = 0; i < rt.points.size(); i++) {
					WptPt wptPt = rt.points.get(i);
					RoutePoint rtp = new RoutePoint();
					rtp.gpxOrder = i;
					rtp.wpt = wptPt;
					String time = wptPt.getExtensionsToRead().get(VISITED_KEY);
					try {
						rtp.visitedTime = Long.parseLong(time);
					} catch (NumberFormatException e) {
					}
					rtp.isNextNavigate = rtp.visitedTime == 0 && locName != null && locName.equals(wptPt.name);
					if(rtp.isNextNavigate) {
						locName = null;
					}
					currentPoints.add(rtp);
				}
				sortPoints();
			}
		}

		public String getName() {
			return gpx.path.substring(gpx.path.lastIndexOf("/") + 1, gpx.path.lastIndexOf("."));
		}

		public void navigateToPoint(RoutePoint rp) {
			if (!currentPoints.isEmpty()) {
				if (currentPoints.get(0).isNextNavigate()) {
					currentPoints.get(0).isNextNavigate = false;
				}
			}
			rp.isNextNavigate = true;
			sortPoints();
			app.getTargetPointsHelper().navigateToPoint(rp.getPoint(), true, -1, rp.getName());
		}

		public void updateCurrentTargetPoint() {
			TargetPointsHelper targetPointsHelper = app.getTargetPointsHelper();
			String locName = targetPointsHelper.getPointNavigateDescription();
			for(int i = 0; i < currentPoints.size(); i++) {
				RoutePoint rtp = currentPoints.get(i);
				rtp.isNextNavigate = rtp.visitedTime == 0 && locName != null && locName.equals(rtp.getName());
				if(rtp.isNextNavigate) {
					locName = null;
				}
				
			}
			sortPoints();
		}
	
	}

}
!@#$%
20190530_012152,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_b11932
package net.osmand.plus.sherpafy;

import android.app.AlertDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.graphics.Color;
import android.os.AsyncTask;
import android.os.SystemClock;
import android.text.Spannable;
import android.text.style.ForegroundColorSpan;
import android.util.TypedValue;
import android.view.Gravity;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.*;
import net.osmand.Location;
import net.osmand.data.LocationPoint;
import net.osmand.plus.*;
import net.osmand.plus.activities.FavouritesActivity;
import net.osmand.plus.activities.MapActivity;
import net.osmand.plus.base.FavoriteImageDrawable;
import net.osmand.plus.views.MapControlsLayer;
import net.osmand.util.MapUtils;

import java.util.List;

/**
 * Created by Denis on 25.07.2014.
 */
public class WaypointDialogHelper {
	private MapActivity mapActivity;
	private OsmandApplication app;
	private FrameLayout mainLayout;
	private OsmAndLocationProvider locationProvider;

	public static boolean OVERLAP_LAYOUT = true;
	private long uiModified;
	private View closePointDialog;

	public WaypointDialogHelper(MapActivity mapActivity) {
		this.app = mapActivity.getMyApplication();
		locationProvider = this.app.getLocationProvider();
		this.mapActivity = mapActivity;
		this.mainLayout = (FrameLayout) ((FrameLayout) mapActivity.getLayout()).getChildAt(0);
	}

	public void updateDialog() {
		List<LocationPoint> vlp = locationProvider.getVisibleLocationPoints();
		long locationPointsModified = locationProvider.getLocationPointsModified();
		if (locationPointsModified != uiModified) {
			uiModified = locationPointsModified;
			if (vlp.isEmpty()) {
				removeDialog();
			} else {
				final LocationPoint point = vlp.get(0);
				boolean created = false;
				if (closePointDialog == null) {
					created = true;
					final LayoutInflater vi = (LayoutInflater) app.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
					closePointDialog = vi.inflate(R.layout.waypoint_reached, null);
				}

				updatePointInfoView(closePointDialog, point);
				closePointDialog.setBackgroundColor(mapActivity.getResources().getColor(R.color.color_black));
				((TextView) closePointDialog.findViewById(R.id.waypoint_text)).setTextColor(Color.WHITE);
				View all = closePointDialog.findViewById(R.id.all_points);
				all.setVisibility(vlp.size() <= 1 ? View.GONE : View.VISIBLE);
				all.setOnClickListener(new View.OnClickListener() {
					@Override
					public void onClick(View view) {
						showAllDialog();
					}
				});

				View btnN = closePointDialog.findViewById(R.id.info_close);
				btnN.setOnClickListener(new View.OnClickListener() {
					@Override
					public void onClick(View view) {
						locationProvider.removeVisibleLocationPoint(point);
						updateDialog();
					}
				});

				if (created) {
					mainLayout.addView(closePointDialog, getDialogLayoutParams());
					waitBeforeLayoutIsResized(closePointDialog);
				}
			}
		}
	}

	private void updatePointInfoView(View localView, final LocationPoint point) {
		TextView text = (TextView) localView.findViewById(R.id.waypoint_text);
		text.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View view) {
				itemClick(point);
			}
		});

		((ImageView) localView.findViewById(R.id.waypoint_icon)).setImageDrawable(FavoriteImageDrawable.getOrCreate(mapActivity, point.getColor()));
		Location lastKnownMapLocation = app.getLocationProvider().getLastKnownLocation();
		String distance;
		if (lastKnownMapLocation != null) {
			int dist = (int) (MapUtils.getDistance(point.getLatitude(), point.getLongitude(),
					lastKnownMapLocation.getLatitude(), lastKnownMapLocation.getLongitude()));
			distance = OsmAndFormatter.getFormattedDistance(dist, app) + "  ";
		} else {
			distance = "";
		}
		text.setText(distance + point.getName(), TextView.BufferType.SPANNABLE);
		if (distance.length() > 0) {
			((Spannable) text.getText()).setSpan(
					new ForegroundColorSpan(mapActivity.getResources().getColor(R.color.color_distance)), 0, distance.length() - 1,
					0);
		}
	}

	private void itemClick(LocationPoint point) {
		final Intent favorites = new Intent(mapActivity, app.getAppCustomization().getFavoritesActivity());
		favorites.setFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);
		favorites.putExtra(FavouritesActivity.TAB_PARAM,
				point instanceof GPXUtilities.WptPt ? FavouritesActivity.GPX_TAB : FavouritesActivity.FAVORITES_TAB);
		mapActivity.startActivity(favorites);
	}

	public void removeDialog() {
		if (closePointDialog != null) {
			mainLayout.removeView(closePointDialog);
			closePointDialog = null;
			shiftButtons(0);
		}
	}

	private FrameLayout.LayoutParams getDialogLayoutParams() {
		FrameLayout.LayoutParams params = new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.WRAP_CONTENT);
		params.gravity = Gravity.BOTTOM | Gravity.CENTER_HORIZONTAL;
		return params;
	}

	private boolean checkIfDialogExists() {
		if (mainLayout == null) {
			return true;
		}

		if (mainLayout.findViewById(R.id.package_delivered_layout) != null) {
			return false;
		}
		return true;
	}

	private void shiftButtons(int height) {
		MapControlsLayer mapControls = mapActivity.getMapLayers().getMapControlsLayer();
		if (mapControls != null) {
			mapControls.shiftLayout(height);
		}
	}


	private void waitBeforeLayoutIsResized(View reachedView) {
		//this async task is needed because layout height is not set
		// right after you add it so we need to w8 some time
		new AsyncTask<View, Void, Void>() {
			int height;

			@Override
			protected Void doInBackground(View... params) {
				for (int i = 0; i < 10; i++) {
					SystemClock.sleep(50);
					height = params[0].getHeight();
					if (params[0].getHeight() > 0) {
						break;
					}
				}
				return null;
			}

			protected void onPostExecute(Void result) {
				if (height > 0 && OVERLAP_LAYOUT) {
					shiftButtons(height);
				}
			}
		}.execute(reachedView);
	}

	public void showAllDialog(){
		final List<LocationPoint> visibleLocationPoints = locationProvider.getVisibleLocationPoints();
		final ArrayAdapter<LocationPoint> listAdapter = new ArrayAdapter<LocationPoint>(mapActivity, R.layout.waypoint_reached, R.id.title,
				visibleLocationPoints) {
			@Override
			public View getView(final int position, View convertView, ViewGroup parent) {
				// User super class to create the View
				View v = convertView;
				if (v == null) {
					v = mapActivity.getLayoutInflater().inflate(R.layout.waypoint_reached, null);
					int vl = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 32, mapActivity.getResources()
							.getDisplayMetrics());
					final LinearLayout.LayoutParams ll = new LinearLayout.LayoutParams(vl, vl);
					ll.setMargins(vl / 4, vl / 4, vl / 4, vl / 4);
					v.findViewById(R.id.waypoint_icon).setLayoutParams(ll);
				}
				updatePointInfoView(v, getItem(position));
				TextView text = (TextView) v.findViewById(R.id.waypoint_text);
				text.setOnClickListener(new View.OnClickListener() {
					@Override
					public void onClick(View view) {
						showOnMap(visibleLocationPoints.get(position));
					}
				});

				View remove = v.findViewById(R.id.info_close);
				((ImageButton) remove).setImageDrawable(mapActivity.getResources().getDrawable(
						app.getSettings().isLightContent()? R.drawable.ic_action_gremove_light:
								R.drawable.ic_action_gremove_dark));
				remove.setOnClickListener(new View.OnClickListener() {
					@Override
					public void onClick(View view) {
						LocationPoint point = locationProvider.getVisibleLocationPoints().get(position);
						remove(point);
						locationProvider.removeVisibleLocationPoint(point);
						notifyDataSetChanged();
					}
				});

				return v;
			}
		};

		ListView listView = new ListView(mapActivity);
		listView.setAdapter(listAdapter);
		listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
			@Override
			public void onItemClick(AdapterView<?> adapterView, View view, int i, long l) {
				showOnMap(visibleLocationPoints.get(i));
			}
		});

//		Dialog dlg = new Dialog(mapActivity);
//		dlg.setContentView(listView);
//		dlg.show();
		AlertDialog.Builder builder = new AlertDialog.Builder(mapActivity);
		builder.setView(listView);
		builder.setPositiveButton(R.string.default_buttons_ok, null);
		builder.setNegativeButton(mapActivity.getString(R.string.hide_all_waypoints), new DialogInterface.OnClickListener() {
			@Override
			public void onClick(DialogInterface dialogInterface, int i) {
				locationProvider.clearAllVisiblePoints();
				updateDialog();
			}
		});
		builder.show();
	}

	private void showOnMap(LocationPoint locationPoint) {
		// AnimateDraggingMapThread thread = mapActivity.getMapView().getAnimatedDraggingThread();
		int fZoom = mapActivity.getMapView().getZoom() < 15 ? 15 : mapActivity.getMapView().getZoom();
		// thread.startMoving(pointToNavigate.getLatitude(), pointToNavigate.getLongitude(), fZoom, true);
		mapActivity.getMapView().setIntZoom(fZoom);
		mapActivity.getMapView().setLatLon(locationPoint.getLatitude(), locationPoint.getLongitude());
	}
}
!@#$%
20190530_012152,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_a11932
package net.osmand.plus.sherpafy;

import android.app.AlertDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.graphics.Color;
import android.os.AsyncTask;
import android.os.SystemClock;
import android.text.Spannable;
import android.text.style.ForegroundColorSpan;
import android.util.TypedValue;
import android.view.Gravity;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.*;
import net.osmand.Location;
import net.osmand.data.LocationPoint;
import net.osmand.plus.*;
import net.osmand.plus.activities.FavouritesActivity;
import net.osmand.plus.activities.MapActivity;
import net.osmand.plus.base.FavoriteImageDrawable;
import net.osmand.plus.views.MapControlsLayer;
import net.osmand.util.MapUtils;

import java.util.List;

/**
 * Created by Denis on 25.07.2014.
 */
public class WaypointDialogHelper {
	private MapActivity mapActivity;
	private OsmandApplication app;
	private FrameLayout mainLayout;
	private OsmAndLocationProvider locationProvider;

	public static boolean OVERLAP_LAYOUT = true;
	private long uiModified;
	private View closePointDialog;

	public WaypointDialogHelper(MapActivity mapActivity) {
		this.app = mapActivity.getMyApplication();
		locationProvider = this.app.getLocationProvider();
		this.mapActivity = mapActivity;
		this.mainLayout = (FrameLayout) ((FrameLayout) mapActivity.getLayout()).getChildAt(0);
	}

	public void updateDialog() {
		List<LocationPoint> vlp = locationProvider.getVisibleLocationPoints();
		long locationPointsModified = locationProvider.getLocationPointsModified();
		if (locationPointsModified != uiModified) {
			uiModified = locationPointsModified;
			if (vlp.isEmpty()) {
				removeDialog();
			} else {
				final LocationPoint point = vlp.get(0);
				boolean created = false;
				if (closePointDialog == null) {
					created = true;
					final LayoutInflater vi = (LayoutInflater) app.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
					closePointDialog = vi.inflate(R.layout.waypoint_reached, null);
				}

				updatePointInfoView(closePointDialog, point);
				closePointDialog.setBackgroundColor(mapActivity.getResources().getColor(R.color.color_black));
				((TextView)closePointDialog.findViewById(R.id.waypoint_text)).setTextColor(Color.WHITE);
				View all = closePointDialog.findViewById(R.id.all_points);
				all.setVisibility(vlp.size() <= 1 ? View.GONE : View.VISIBLE);
				all.setOnClickListener(new View.OnClickListener() {
					@Override
					public void onClick(View view) {
						showAllDialog();
					}
				});

				View btnN = closePointDialog.findViewById(R.id.info_close);
				btnN.setOnClickListener(new View.OnClickListener() {
					@Override
					public void onClick(View view) {
						locationProvider.removeVisibleLocationPoint(point);
						updateDialog();
					}
				});

				if (created) {
					mainLayout.addView(closePointDialog, getDialogLayoutParams());
					waitBeforeLayoutIsResized(closePointDialog);
				}
			}
		}
	}

	private void updatePointInfoView(View localView, final LocationPoint point) {
		TextView text = (TextView) localView.findViewById(R.id.waypoint_text);
		text.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View view) {
				itemClick(point);
			}
		});

		((ImageView) localView.findViewById(R.id.waypoint_icon)).setImageDrawable(FavoriteImageDrawable.getOrCreate(mapActivity, point.getColor()));
		Location lastKnownMapLocation = app.getLocationProvider().getLastKnownLocation();
		String distance;
		if (lastKnownMapLocation != null) {
			int dist = (int) (MapUtils.getDistance(point.getLatitude(), point.getLongitude(),
					lastKnownMapLocation.getLatitude(), lastKnownMapLocation.getLongitude()));
			distance = OsmAndFormatter.getFormattedDistance(dist, app) + "  ";
		} else {
			distance = "";
		}
		text.setText(distance + point.getName(), TextView.BufferType.SPANNABLE);
		if (distance.length() > 0) {
			((Spannable) text.getText()).setSpan(
					new ForegroundColorSpan(mapActivity.getResources().getColor(R.color.color_distance)), 0, distance.length() - 1,
					0);
		}
	}

	private void itemClick(LocationPoint point) {
		final Intent favorites = new Intent(mapActivity, app.getAppCustomization().getFavoritesActivity());
		favorites.setFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);
		favorites.putExtra(FavouritesActivity.TAB_PARAM,
				point instanceof GPXUtilities.WptPt ? FavouritesActivity.GPX_TAB : FavouritesActivity.FAVORITES_TAB);
		mapActivity.startActivity(favorites);
	}

	public void removeDialog() {
		if (closePointDialog != null) {
			mainLayout.removeView(closePointDialog);
			closePointDialog = null;
			shiftButtons(0);
		}
	}

	private FrameLayout.LayoutParams getDialogLayoutParams() {
		FrameLayout.LayoutParams params = new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.WRAP_CONTENT);
		params.gravity = Gravity.BOTTOM | Gravity.CENTER_HORIZONTAL;
		return params;
	}

	private boolean checkIfDialogExists() {
		if (mainLayout == null) {
			return true;
		}

		if (mainLayout.findViewById(R.id.package_delivered_layout) != null) {
			return false;
		}
		return true;
	}

	private void shiftButtons(int height) {
		MapControlsLayer mapControls = mapActivity.getMapLayers().getMapControlsLayer();
		if (mapControls != null) {
			mapControls.shiftLayout(height);
		}
	}


	private void waitBeforeLayoutIsResized(View reachedView) {
		//this async task is needed because layout height is not set
		// right after you add it so we need to w8 some time
		new AsyncTask<View, Void, Void>() {
			int height;

			@Override
			protected Void doInBackground(View... params) {
				for (int i = 0; i < 10; i++) {
					SystemClock.sleep(50);
					height = params[0].getHeight();
					if (params[0].getHeight() > 0) {
						break;
					}
				}
				return null;
			}

			protected void onPostExecute(Void result) {
				if (height > 0 && OVERLAP_LAYOUT) {
					shiftButtons(height);
				}
			}
		}.execute(reachedView);
	}

	public void showAllDialog(){
		final List<LocationPoint> visibleLocationPoints = locationProvider.getVisibleLocationPoints();
		final ArrayAdapter<LocationPoint> listAdapter = new ArrayAdapter<LocationPoint>(mapActivity, R.layout.waypoint_reached, R.id.title,
				visibleLocationPoints) {
			@Override
			public View getView(final int position, View convertView, ViewGroup parent) {
				// User super class to create the View
				View v = convertView;
				if (v == null) {
					v = mapActivity.getLayoutInflater().inflate(R.layout.waypoint_reached, null);
					int vl = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 32, mapActivity.getResources()
							.getDisplayMetrics());
					final LinearLayout.LayoutParams ll = new LinearLayout.LayoutParams(vl, vl);
					ll.setMargins(vl / 4, vl / 4, vl / 4, vl / 4);
					v.findViewById(R.id.waypoint_icon).setLayoutParams(ll);
				}
				updatePointInfoView(v, getItem(position));
				TextView text = (TextView) v.findViewById(R.id.waypoint_text);
				text.setOnClickListener(new View.OnClickListener() {
					@Override
					public void onClick(View view) {
						showOnMap(visibleLocationPoints.get(position));
					}
				});

				View remove = v.findViewById(R.id.info_close);
				((ImageButton) remove).setImageDrawable(mapActivity.getResources().getDrawable(
						app.getSettings().isLightContent()? R.drawable.ic_action_gremove_light:
								R.drawable.ic_action_gremove_dark));
				remove.setOnClickListener(new View.OnClickListener() {
					@Override
					public void onClick(View view) {
						LocationPoint point = locationProvider.getVisibleLocationPoints().get(position);
						remove(point);
						locationProvider.removeVisibleLocationPoint(point);
						notifyDataSetChanged();
					}
				});

				return v;
			}
		};

		ListView listView = new ListView(mapActivity);
		listView.setAdapter(listAdapter);
		listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
			@Override
			public void onItemClick(AdapterView<?> adapterView, View view, int i, long l) {
				showOnMap(visibleLocationPoints.get(i));
			}
		});

//		Dialog dlg = new Dialog(mapActivity);
//		dlg.setContentView(listView);
//		dlg.show();
		AlertDialog.Builder builder = new AlertDialog.Builder(mapActivity);
		builder.setView(listView);
		builder.setPositiveButton(R.string.default_buttons_ok, null);
		builder.setNegativeButton(mapActivity.getString(R.string.hide_all_waypoints), new DialogInterface.OnClickListener() {
			@Override
			public void onClick(DialogInterface dialogInterface, int i) {
				locationProvider.clearAllVisiblePoints();
				updateDialog();
			}
		});
		builder.show();
	}

	private void showOnMap(LocationPoint locationPoint) {
		// AnimateDraggingMapThread thread = mapActivity.getMapView().getAnimatedDraggingThread();
		int fZoom = mapActivity.getMapView().getZoom() < 15 ? 15 : mapActivity.getMapView().getZoom();
		// thread.startMoving(pointToNavigate.getLatitude(), pointToNavigate.getLongitude(), fZoom, true);
		mapActivity.getMapView().setIntZoom(fZoom);
		mapActivity.getMapView().setLatLon(locationPoint.getLatitude(), locationPoint.getLongitude());
	}
}
!@#$%
20190530_012152,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_c11932
package net.osmand.plus.helpers;

import android.app.AlertDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.graphics.Color;
import android.os.AsyncTask;
import android.os.SystemClock;
import android.text.Spannable;
import android.text.style.ForegroundColorSpan;
import android.util.TypedValue;
import android.view.Gravity;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.*;
import net.osmand.Location;
import net.osmand.data.LocationPoint;
import net.osmand.plus.*;
import net.osmand.plus.activities.FavouritesActivity;
import net.osmand.plus.activities.MapActivity;
import net.osmand.plus.base.FavoriteImageDrawable;
import net.osmand.plus.views.MapControlsLayer;
import net.osmand.util.MapUtils;

import java.util.List;

/**
 * Created by Denis on 25.07.2014.
 */
public class WaypointDialogHelper {
	private MapActivity mapActivity;
	private OsmandApplication app;
	private FrameLayout mainLayout;
	private WaypointHelper waypointHelper;

	public static boolean OVERLAP_LAYOUT = true;
	private long uiModified;
	private View closePointDialog;

	public WaypointDialogHelper(MapActivity mapActivity) {
		this.app = mapActivity.getMyApplication();
		waypointHelper = this.app.getWaypointHelper();
		this.mapActivity = mapActivity;
		this.mainLayout = (FrameLayout) ((FrameLayout) mapActivity.getLayout()).getChildAt(0);
	}

	public void updateDialog() {
		List<LocationPoint> vlp = waypointHelper.getVisibleLocationPoints();
		long locationPointsModified = waypointHelper.getLocationPointsModified();
		if (locationPointsModified != uiModified) {
			uiModified = locationPointsModified;
			if (vlp.isEmpty()) {
				removeDialog();
			} else {
				final LocationPoint point = vlp.get(0);
				boolean created = false;
				if (closePointDialog == null) {
					created = true;
					final LayoutInflater vi = (LayoutInflater) app.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
					closePointDialog = vi.inflate(R.layout.waypoint_reached, null);
				}

				updatePointInfoView(closePointDialog, point);
				closePointDialog.setBackgroundColor(mapActivity.getResources().getColor(R.color.color_black));
				((TextView)closePointDialog.findViewById(R.id.waypoint_text)).setTextColor(Color.WHITE);
				View all = closePointDialog.findViewById(R.id.all_points);
				all.setVisibility(vlp.size() <= 1 ? View.GONE : View.VISIBLE);
				all.setOnClickListener(new View.OnClickListener() {
					@Override
					public void onClick(View view) {
						showAllDialog();
					}
				});

				View btnN = closePointDialog.findViewById(R.id.info_close);
				btnN.setOnClickListener(new View.OnClickListener() {
					@Override
					public void onClick(View view) {
						waypointHelper.removeVisibleLocationPoint(point);
						updateDialog();
					}
				});

				if (created) {
					mainLayout.addView(closePointDialog, getDialogLayoutParams());
					waitBeforeLayoutIsResized(closePointDialog);
				}
			}
		}
	}

	private void updatePointInfoView(View localView, final LocationPoint point) {
		TextView text = (TextView) localView.findViewById(R.id.waypoint_text);
		text.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View view) {
				itemClick(point);
			}
		});

		((ImageView) localView.findViewById(R.id.waypoint_icon)).setImageDrawable(FavoriteImageDrawable.getOrCreate(mapActivity, point.getColor()));
		Location lastKnownMapLocation = app.getLocationProvider().getLastKnownLocation();
		String distance;
		if (lastKnownMapLocation != null) {
			int dist = (int) (MapUtils.getDistance(point.getLatitude(), point.getLongitude(),
					lastKnownMapLocation.getLatitude(), lastKnownMapLocation.getLongitude()));
			distance = OsmAndFormatter.getFormattedDistance(dist, app) + "  ";
		} else {
			distance = "";
		}
		text.setText(distance + point.getName(), TextView.BufferType.SPANNABLE);
		if (distance.length() > 0) {
			((Spannable) text.getText()).setSpan(
					new ForegroundColorSpan(mapActivity.getResources().getColor(R.color.color_distance)), 0, distance.length() - 1,
					0);
		}
	}

	private void itemClick(LocationPoint point) {
		final Intent favorites = new Intent(mapActivity, app.getAppCustomization().getFavoritesActivity());
		favorites.setFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);
		favorites.putExtra(FavouritesActivity.TAB_PARAM,
				point instanceof GPXUtilities.WptPt ? FavouritesActivity.GPX_TAB : FavouritesActivity.FAVORITES_TAB);
		mapActivity.startActivity(favorites);
	}

	public void removeDialog() {
		if (closePointDialog != null) {
			mainLayout.removeView(closePointDialog);
			closePointDialog = null;
			shiftButtons(0);
		}
	}

	private FrameLayout.LayoutParams getDialogLayoutParams() {
		FrameLayout.LayoutParams params = new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.WRAP_CONTENT);
		params.gravity = Gravity.BOTTOM | Gravity.CENTER_HORIZONTAL;
		return params;
	}

	private boolean checkIfDialogExists() {
		if (mainLayout == null) {
			return true;
		}

		if (mainLayout.findViewById(R.id.package_delivered_layout) != null) {
			return false;
		}
		return true;
	}

	private void shiftButtons(int height) {
		MapControlsLayer mapControls = mapActivity.getMapLayers().getMapControlsLayer();
		if (mapControls != null) {
			mapControls.shiftLayout(height);
		}
	}


	private void waitBeforeLayoutIsResized(View reachedView) {
		//this async task is needed because layout height is not set
		// right after you add it so we need to w8 some time
		new AsyncTask<View, Void, Void>() {
			int height;

			@Override
			protected Void doInBackground(View... params) {
				for (int i = 0; i < 10; i++) {
					SystemClock.sleep(50);
					height = params[0].getHeight();
					if (params[0].getHeight() > 0) {
						break;
					}
				}
				return null;
			}

			protected void onPostExecute(Void result) {
				if (height > 0 && OVERLAP_LAYOUT) {
					shiftButtons(height);
				}
			}
		}.execute(reachedView);
	}

	public void showAllDialog(){
		final List<LocationPoint> visibleLocationPoints = waypointHelper.getVisibleLocationPoints();
		final ArrayAdapter<LocationPoint> listAdapter = new ArrayAdapter<LocationPoint>(mapActivity, R.layout.waypoint_reached, R.id.title,
				visibleLocationPoints) {
			@Override
			public View getView(final int position, View convertView, ViewGroup parent) {
				// User super class to create the View
				View v = convertView;
				if (v == null) {
					v = mapActivity.getLayoutInflater().inflate(R.layout.waypoint_reached, null);
					int vl = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 32, mapActivity.getResources()
							.getDisplayMetrics());
					final LinearLayout.LayoutParams ll = new LinearLayout.LayoutParams(vl, vl);
					ll.setMargins(vl / 4, vl / 4, vl / 4, vl / 4);
					v.findViewById(R.id.waypoint_icon).setLayoutParams(ll);
				}
				updatePointInfoView(v, getItem(position));
				TextView text = (TextView) v.findViewById(R.id.waypoint_text);
				text.setOnClickListener(new View.OnClickListener() {
					@Override
					public void onClick(View view) {
						showOnMap(visibleLocationPoints.get(position));
					}
				});

				View remove = v.findViewById(R.id.info_close);
				((ImageButton) remove).setImageDrawable(mapActivity.getResources().getDrawable(
						app.getSettings().isLightContent()? R.drawable.ic_action_gremove_light:
								R.drawable.ic_action_gremove_dark));
				remove.setOnClickListener(new View.OnClickListener() {
					@Override
					public void onClick(View view) {
						LocationPoint point = waypointHelper.getVisibleLocationPoints().get(position);
						remove(point);
						waypointHelper.removeVisibleLocationPoint(point);
						notifyDataSetChanged();
					}
				});

				return v;
			}
		};

		ListView listView = new ListView(mapActivity);
		listView.setAdapter(listAdapter);
		listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
			@Override
			public void onItemClick(AdapterView<?> adapterView, View view, int i, long l) {
				showOnMap(visibleLocationPoints.get(i));
			}
		});

//		Dialog dlg = new Dialog(mapActivity);
//		dlg.setContentView(listView);
//		dlg.show();
		AlertDialog.Builder builder = new AlertDialog.Builder(mapActivity);
		builder.setView(listView);
		builder.setPositiveButton(R.string.default_buttons_ok, null);
		builder.setNegativeButton(mapActivity.getString(R.string.hide_all_waypoints), new DialogInterface.OnClickListener() {
			@Override
			public void onClick(DialogInterface dialogInterface, int i) {
				waypointHelper.clearAllVisiblePoints();
				updateDialog();
			}
		});
		builder.show();
	}

	private void showOnMap(LocationPoint locationPoint) {
		// AnimateDraggingMapThread thread = mapActivity.getMapView().getAnimatedDraggingThread();
		int fZoom = mapActivity.getMapView().getZoom() < 15 ? 15 : mapActivity.getMapView().getZoom();
		// thread.startMoving(pointToNavigate.getLatitude(), pointToNavigate.getLongitude(), fZoom, true);
		mapActivity.getMapView().setIntZoom(fZoom);
		mapActivity.getMapView().setLatLon(locationPoint.getLatitude(), locationPoint.getLongitude());
	}
}
!@#$%
20190530_012237,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_b05756
package net.osmand.plus.helpers;

import android.app.AlertDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.graphics.Color;
import android.os.AsyncTask;
import android.os.SystemClock;
import android.text.Spannable;
import android.text.style.ForegroundColorSpan;
import android.util.TypedValue;
import android.view.Gravity;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.*;
import net.osmand.Location;
import net.osmand.data.LocationPoint;
import net.osmand.plus.*;
import net.osmand.plus.activities.FavouritesActivity;
import net.osmand.plus.activities.MapActivity;
import net.osmand.plus.base.FavoriteImageDrawable;
import net.osmand.plus.views.MapControlsLayer;
import net.osmand.util.MapUtils;

import java.util.List;

/**
 * Created by Denis on 25.07.2014.
 */
public class WaypointDialogHelper {
	private MapActivity mapActivity;
	private OsmandApplication app;
	private FrameLayout mainLayout;
	private WaypointHelper waypointHelper;

	public static boolean OVERLAP_LAYOUT = true;
	private long uiModified;
	private View closePointDialog;

	private static final String GPX_WAYPOINTS = "GPX waypoints";
	private static final String FAVORITES = "Favorites";
	private static final String POI = "POI";
	private static final String TARGETS = "Targets";

	public WaypointDialogHelper(MapActivity mapActivity) {
		this.app = mapActivity.getMyApplication();
		waypointHelper = this.app.getWaypointHelper();
		this.mapActivity = mapActivity;
		this.mainLayout = (FrameLayout) ((FrameLayout) mapActivity.getLayout()).getChildAt(0);
	}

	public void updateDialog() {
		List<LocationPoint> vlp = waypointHelper.getAllVisibleLocationPoints();
		long locationPointsModified = waypointHelper.getLocationPointsModified();
		if (locationPointsModified != uiModified) {
			uiModified = locationPointsModified;
			if (vlp.isEmpty()) {
				removeDialog();
			} else {
				final LocationPoint point = vlp.get(0);
				boolean created = false;
				if (closePointDialog == null) {
					created = true;
					final LayoutInflater vi = (LayoutInflater) app.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
					closePointDialog = vi.inflate(R.layout.waypoint_reached, null);
				}

				updatePointInfoView(closePointDialog, point);
				closePointDialog.setBackgroundColor(mapActivity.getResources().getColor(R.color.color_black));
				((TextView)closePointDialog.findViewById(R.id.waypoint_text)).setTextColor(Color.WHITE);
				View all = closePointDialog.findViewById(R.id.all_points);
				all.setVisibility(vlp.size() <= 1 ? View.GONE : View.VISIBLE);
				all.setOnClickListener(new View.OnClickListener() {
					@Override
					public void onClick(View view) {
						showAllDialog(waypointHelper.getAllVisibleLocationPoints());
					}
				});

				View btnN = closePointDialog.findViewById(R.id.info_close);
				btnN.setOnClickListener(new View.OnClickListener() {
					@Override
					public void onClick(View view) {
						waypointHelper.removeVisibleLocationPoint(point);
						updateDialog();
					}
				});

				if (created) {
					mainLayout.addView(closePointDialog, getDialogLayoutParams());
					waitBeforeLayoutIsResized(closePointDialog);
				}
			}
		}
	}

	private void updatePointInfoView(View localView, final LocationPoint point) {
		TextView text = (TextView) localView.findViewById(R.id.waypoint_text);
		text.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View view) {
				itemClick(point);
			}
		});

		((ImageView) localView.findViewById(R.id.waypoint_icon)).setImageDrawable(FavoriteImageDrawable.getOrCreate(mapActivity, point.getColor()));
		Location lastKnownMapLocation = app.getLocationProvider().getLastKnownLocation();
		String distance;
		if (lastKnownMapLocation != null) {
			int dist = (int) (MapUtils.getDistance(point.getLatitude(), point.getLongitude(),
					lastKnownMapLocation.getLatitude(), lastKnownMapLocation.getLongitude()));
			distance = OsmAndFormatter.getFormattedDistance(dist, app) + "  ";
		} else {
			distance = "";
		}
		text.setText(distance + point.getName(), TextView.BufferType.SPANNABLE);
		if (distance.length() > 0) {
			((Spannable) text.getText()).setSpan(
					new ForegroundColorSpan(mapActivity.getResources().getColor(R.color.color_distance)), 0, distance.length() - 1,
					0);
		}
	}

	private void itemClick(LocationPoint point) {
		final Intent favorites = new Intent(mapActivity, app.getAppCustomization().getFavoritesActivity());
		favorites.setFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);
		favorites.putExtra(FavouritesActivity.TAB_PARAM,
				point instanceof GPXUtilities.WptPt ? FavouritesActivity.GPX_TAB : FavouritesActivity.FAVORITES_TAB);
		mapActivity.startActivity(favorites);
	}

	public void removeDialog() {
		if (closePointDialog != null) {
			mainLayout.removeView(closePointDialog);
			closePointDialog = null;
			shiftButtons(0);
		}
	}

	private FrameLayout.LayoutParams getDialogLayoutParams() {
		FrameLayout.LayoutParams params = new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.WRAP_CONTENT);
		params.gravity = Gravity.BOTTOM | Gravity.CENTER_HORIZONTAL;
		return params;
	}

	private boolean checkIfDialogExists() {
		if (mainLayout == null) {
			return true;
		}

		if (mainLayout.findViewById(R.id.package_delivered_layout) != null) {
			return false;
		}
		return true;
	}

	private void shiftButtons(int height) {
		MapControlsLayer mapControls = mapActivity.getMapLayers().getMapControlsLayer();
		if (mapControls != null) {
			mapControls.shiftLayout(height);
		}
	}


	private void waitBeforeLayoutIsResized(View reachedView) {
		//this async task is needed because layout height is not set
		// right after you add it so we need to w8 some time
		new AsyncTask<View, Void, Void>() {
			int height;

			@Override
			protected Void doInBackground(View... params) {
				for (int i = 0; i < 10; i++) {
					SystemClock.sleep(50);
					height = params[0].getHeight();
					if (params[0].getHeight() > 0) {
						break;
					}
				}
				return null;
			}

			protected void onPostExecute(Void result) {
				if (height > 0 && OVERLAP_LAYOUT) {
					shiftButtons(height);
				}
			}
		}.execute(reachedView);
	}

	public void showWaypointsSettingsDialog(){
		final List<Object> points = getItemsList(waypointHelper.getAllVisibleLocationPoints());

		final ArrayAdapter<Object> listAdapter = new ArrayAdapter<Object>(mapActivity, R.layout.waypoint_reached, R.id.title,
				points) {
			@Override
			public View getView(final int position, View convertView, ViewGroup parent) {
				// User super class to create the View
				View v = convertView;
				if (v == null) {
					if (points.get(position) instanceof LocationPoint){
						v = mapActivity.getLayoutInflater().inflate(R.layout.waypoint_reached, null);
						int vl = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 32, mapActivity.getResources()
								.getDisplayMetrics());
						final LinearLayout.LayoutParams ll = new LinearLayout.LayoutParams(vl, vl);
						ll.setMargins(vl / 4, vl / 4, vl / 4, vl / 4);
						v.findViewById(R.id.waypoint_icon).setLayoutParams(ll);
					} else if (points.get(position) instanceof String){
						String header = (String)points.get(position);
						v = mapActivity.getLayoutInflater().inflate(R.layout.waypoint_header, null);
						TextView headerText = (TextView) v.findViewById(R.id.header_text);
						headerText.setText(header);
						ImageButton allpoints = (ImageButton) v.findViewById(R.id.all_points);
						if (header.equals(FAVORITES)){
							allpoints.setOnClickListener(new View.OnClickListener() {
								@Override
								public void onClick(View view) {
									showAllDialog(waypointHelper.getVisibleFavorites());
								}
							});
						} else if (header.equals(TARGETS)){
							allpoints.setOnClickListener(new View.OnClickListener() {
								@Override
								public void onClick(View view) {
									showAllDialog(waypointHelper.getVisibleTargets());
								}
							});
						} else if (header.equals(GPX_WAYPOINTS)){
							allpoints.setOnClickListener(new View.OnClickListener() {
								@Override
								public void onClick(View view) {
									showAllDialog(waypointHelper.getVisibleGpxPoints());
								}
							});
						} else if (header.equals(POI)){
							allpoints.setOnClickListener(new View.OnClickListener() {
								@Override
								public void onClick(View view) {
									showAllDialog(waypointHelper.getVisiblePOI());
								}
							});
						}
					}

				}
				updatePointInfoView(v, (LocationPoint)getItem(position));
				TextView text = (TextView) v.findViewById(R.id.waypoint_text);
				text.setOnClickListener(new View.OnClickListener() {
					@Override
					public void onClick(View view) {
						showOnMap((LocationPoint)points.get(position));
					}
				});

				View remove = v.findViewById(R.id.info_close);
				((ImageButton) remove).setImageDrawable(mapActivity.getResources().getDrawable(
						app.getSettings().isLightContent()? R.drawable.ic_action_gremove_light:
								R.drawable.ic_action_gremove_dark));
				remove.setOnClickListener(new View.OnClickListener() {
					@Override
					public void onClick(View view) {
						LocationPoint point = waypointHelper.getAllVisibleLocationPoints().get(position);
						remove(point);
						waypointHelper.removeVisibleLocationPoint(point);
						notifyDataSetChanged();
					}
				});

				return v;
			}

		};
	}

	private List<Object> getItemsList(List<LocationPoint> visibleLocationPoints) {
		return null;
	}

	public void showAllDialog(final List<LocationPoint> visibleLocationPoints){
		final ArrayAdapter<LocationPoint> listAdapter = new ArrayAdapter<LocationPoint>(mapActivity, R.layout.waypoint_reached, R.id.title,
				visibleLocationPoints) {
			@Override
			public View getView(final int position, View convertView, ViewGroup parent) {
				// User super class to create the View
				View v = convertView;
				if (v == null) {
					v = mapActivity.getLayoutInflater().inflate(R.layout.waypoint_reached, null);
					int vl = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 32, mapActivity.getResources()
							.getDisplayMetrics());
					final LinearLayout.LayoutParams ll = new LinearLayout.LayoutParams(vl, vl);
					ll.setMargins(vl / 4, vl / 4, vl / 4, vl / 4);
					v.findViewById(R.id.waypoint_icon).setLayoutParams(ll);
				}
				updatePointInfoView(v, getItem(position));
				TextView text = (TextView) v.findViewById(R.id.waypoint_text);
				text.setOnClickListener(new View.OnClickListener() {
					@Override
					public void onClick(View view) {
						showOnMap(visibleLocationPoints.get(position));
					}
				});

				View remove = v.findViewById(R.id.info_close);
				((ImageButton) remove).setImageDrawable(mapActivity.getResources().getDrawable(
						app.getSettings().isLightContent()? R.drawable.ic_action_gremove_light:
								R.drawable.ic_action_gremove_dark));
				remove.setOnClickListener(new View.OnClickListener() {
					@Override
					public void onClick(View view) {
						LocationPoint point = waypointHelper.getAllVisibleLocationPoints().get(position);
						remove(point);
						waypointHelper.removeVisibleLocationPoint(point);
						notifyDataSetChanged();
					}
				});

				return v;
			}
		};

		ListView listView = new ListView(mapActivity);
		listView.setAdapter(listAdapter);
		listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
			@Override
			public void onItemClick(AdapterView<?> adapterView, View view, int i, long l) {
				showOnMap(visibleLocationPoints.get(i));
			}
		});

//		Dialog dlg = new Dialog(mapActivity);
//		dlg.setContentView(listView);
//		dlg.show();
		AlertDialog.Builder builder = new AlertDialog.Builder(mapActivity);
		builder.setView(listView);
		builder.setPositiveButton(R.string.default_buttons_ok, null);
		builder.setNegativeButton(mapActivity.getString(R.string.hide_all_waypoints), new DialogInterface.OnClickListener() {
			@Override
			public void onClick(DialogInterface dialogInterface, int i) {
				waypointHelper.clearAllVisiblePoints();
				updateDialog();
			}
		});
		builder.show();
	}

	private void showOnMap(LocationPoint locationPoint) {
		// AnimateDraggingMapThread thread = mapActivity.getMapView().getAnimatedDraggingThread();
		int fZoom = mapActivity.getMapView().getZoom() < 15 ? 15 : mapActivity.getMapView().getZoom();
		// thread.startMoving(pointToNavigate.getLatitude(), pointToNavigate.getLongitude(), fZoom, true);
		mapActivity.getMapView().setIntZoom(fZoom);
		mapActivity.getMapView().setLatLon(locationPoint.getLatitude(), locationPoint.getLongitude());
	}
}
!@#$%
20190530_012237,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_a05756
package net.osmand.plus.helpers;

import android.app.AlertDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.graphics.Color;
import android.os.AsyncTask;
import android.os.SystemClock;
import android.text.Spannable;
import android.text.style.ForegroundColorSpan;
import android.util.TypedValue;
import android.view.Gravity;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.*;
import net.osmand.Location;
import net.osmand.data.LocationPoint;
import net.osmand.plus.*;
import net.osmand.plus.activities.FavouritesActivity;
import net.osmand.plus.activities.MapActivity;
import net.osmand.plus.base.FavoriteImageDrawable;
import net.osmand.plus.views.MapControlsLayer;
import net.osmand.util.MapUtils;

import java.util.List;

/**
 * Created by Denis on 25.07.2014.
 */
public class WaypointDialogHelper {
	private MapActivity mapActivity;
	private OsmandApplication app;
	private FrameLayout mainLayout;
	private WaypointHelper waypointHelper;

	public static boolean OVERLAP_LAYOUT = true;
	private long uiModified;
	private View closePointDialog;

	public WaypointDialogHelper(MapActivity mapActivity) {
		this.app = mapActivity.getMyApplication();
		waypointHelper = this.app.getWaypointHelper();
		this.mapActivity = mapActivity;
		this.mainLayout = (FrameLayout) ((FrameLayout) mapActivity.getLayout()).getChildAt(0);
	}

	public void updateDialog() {
		List<LocationPoint> vlp = waypointHelper.getVisibleLocationPoints();
		long locationPointsModified = waypointHelper.getLocationPointsModified();
		if (locationPointsModified != uiModified) {
			uiModified = locationPointsModified;
			if (vlp.isEmpty()) {
				removeDialog();
			} else {
				final LocationPoint point = vlp.get(0);
				boolean created = false;
				if (closePointDialog == null) {
					created = true;
					final LayoutInflater vi = (LayoutInflater) app.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
					closePointDialog = vi.inflate(R.layout.waypoint_reached, null);
				}

				updatePointInfoView(closePointDialog, point);
				closePointDialog.setBackgroundColor(mapActivity.getResources().getColor(R.color.color_black));
				((TextView)closePointDialog.findViewById(R.id.waypoint_text)).setTextColor(Color.WHITE);
				View all = closePointDialog.findViewById(R.id.all_points);
				all.setVisibility(vlp.size() <= 1 ? View.GONE : View.VISIBLE);
				all.setOnClickListener(new View.OnClickListener() {
					@Override
					public void onClick(View view) {
						showAllDialog();
					}
				});

				View btnN = closePointDialog.findViewById(R.id.info_close);
				btnN.setOnClickListener(new View.OnClickListener() {
					@Override
					public void onClick(View view) {
						waypointHelper.removeVisibleLocationPoint(point);
						updateDialog();
					}
				});

				if (created) {
					mainLayout.addView(closePointDialog, getDialogLayoutParams());
					waitBeforeLayoutIsResized(closePointDialog);
				}
			}
		}
	}

	private void updatePointInfoView(View localView, final LocationPoint point) {
		TextView text = (TextView) localView.findViewById(R.id.waypoint_text);
		text.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View view) {
				itemClick(point);
			}
		});

		((ImageView) localView.findViewById(R.id.waypoint_icon)).setImageDrawable(FavoriteImageDrawable.getOrCreate(mapActivity, point.getColor()));
		Location lastKnownMapLocation = app.getLocationProvider().getLastKnownLocation();
		String distance;
		if (lastKnownMapLocation != null) {
			int dist = (int) (MapUtils.getDistance(point.getLatitude(), point.getLongitude(),
					lastKnownMapLocation.getLatitude(), lastKnownMapLocation.getLongitude()));
			distance = OsmAndFormatter.getFormattedDistance(dist, app) + "  ";
		} else {
			distance = "";
		}
		text.setText(distance + point.getName(), TextView.BufferType.SPANNABLE);
		if (distance.length() > 0) {
			((Spannable) text.getText()).setSpan(
					new ForegroundColorSpan(mapActivity.getResources().getColor(R.color.color_distance)), 0, distance.length() - 1,
					0);
		}
	}

	private void itemClick(LocationPoint point) {
		final Intent favorites = new Intent(mapActivity, app.getAppCustomization().getFavoritesActivity());
		favorites.setFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);
		favorites.putExtra(FavouritesActivity.TAB_PARAM,
				point instanceof GPXUtilities.WptPt ? FavouritesActivity.GPX_TAB : FavouritesActivity.FAVORITES_TAB);
		mapActivity.startActivity(favorites);
	}

	public void removeDialog() {
		if (closePointDialog != null) {
			mainLayout.removeView(closePointDialog);
			closePointDialog = null;
			shiftButtons(0);
		}
	}

	private FrameLayout.LayoutParams getDialogLayoutParams() {
		FrameLayout.LayoutParams params = new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.WRAP_CONTENT);
		params.gravity = Gravity.BOTTOM | Gravity.CENTER_HORIZONTAL;
		return params;
	}

	private boolean checkIfDialogExists() {
		if (mainLayout == null) {
			return true;
		}

		if (mainLayout.findViewById(R.id.package_delivered_layout) != null) {
			return false;
		}
		return true;
	}

	private void shiftButtons(int height) {
		MapControlsLayer mapControls = mapActivity.getMapLayers().getMapControlsLayer();
		if (mapControls != null) {
			mapControls.shiftLayout(height);
		}
	}


	private void waitBeforeLayoutIsResized(View reachedView) {
		//this async task is needed because layout height is not set
		// right after you add it so we need to w8 some time
		new AsyncTask<View, Void, Void>() {
			int height;

			@Override
			protected Void doInBackground(View... params) {
				for (int i = 0; i < 10; i++) {
					SystemClock.sleep(50);
					height = params[0].getHeight();
					if (params[0].getHeight() > 0) {
						break;
					}
				}
				return null;
			}

			protected void onPostExecute(Void result) {
				if (height > 0 && OVERLAP_LAYOUT) {
					shiftButtons(height);
				}
			}
		}.execute(reachedView);
	}

	public void showAllDialog(){
		final List<LocationPoint> visibleLocationPoints = waypointHelper.getVisibleLocationPoints();
		final ArrayAdapter<LocationPoint> listAdapter = new ArrayAdapter<LocationPoint>(mapActivity, R.layout.waypoint_reached, R.id.title,
				visibleLocationPoints) {
			@Override
			public View getView(final int position, View convertView, ViewGroup parent) {
				// User super class to create the View
				View v = convertView;
				if (v == null) {
					v = mapActivity.getLayoutInflater().inflate(R.layout.waypoint_reached, null);
					int vl = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 32, mapActivity.getResources()
							.getDisplayMetrics());
					final LinearLayout.LayoutParams ll = new LinearLayout.LayoutParams(vl, vl);
					ll.setMargins(vl / 4, vl / 4, vl / 4, vl / 4);
					v.findViewById(R.id.waypoint_icon).setLayoutParams(ll);
				}
				updatePointInfoView(v, getItem(position));
				TextView text = (TextView) v.findViewById(R.id.waypoint_text);
				text.setOnClickListener(new View.OnClickListener() {
					@Override
					public void onClick(View view) {
						showOnMap(visibleLocationPoints.get(position));
					}
				});

				View remove = v.findViewById(R.id.info_close);
				((ImageButton) remove).setImageDrawable(mapActivity.getResources().getDrawable(
						app.getSettings().isLightContent()? R.drawable.ic_action_gremove_light:
								R.drawable.ic_action_gremove_dark));
				remove.setOnClickListener(new View.OnClickListener() {
					@Override
					public void onClick(View view) {
						LocationPoint point = waypointHelper.getVisibleLocationPoints().get(position);
						remove(point);
						waypointHelper.removeVisibleLocationPoint(point);
						notifyDataSetChanged();
					}
				});

				return v;
			}
		};

		ListView listView = new ListView(mapActivity);
		listView.setAdapter(listAdapter);
		listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
			@Override
			public void onItemClick(AdapterView<?> adapterView, View view, int i, long l) {
				showOnMap(visibleLocationPoints.get(i));
			}
		});

//		Dialog dlg = new Dialog(mapActivity);
//		dlg.setContentView(listView);
//		dlg.show();
		AlertDialog.Builder builder = new AlertDialog.Builder(mapActivity);
		builder.setView(listView);
		builder.setPositiveButton(R.string.default_buttons_ok, null);
		builder.setNegativeButton(mapActivity.getString(R.string.hide_all_waypoints), new DialogInterface.OnClickListener() {
			@Override
			public void onClick(DialogInterface dialogInterface, int i) {
				waypointHelper.clearAllVisiblePoints();
				updateDialog();
			}
		});
		builder.show();
	}

	private void showOnMap(LocationPoint locationPoint) {
		// AnimateDraggingMapThread thread = mapActivity.getMapView().getAnimatedDraggingThread();
		int fZoom = mapActivity.getMapView().getZoom() < 15 ? 15 : mapActivity.getMapView().getZoom();
		// thread.startMoving(pointToNavigate.getLatitude(), pointToNavigate.getLongitude(), fZoom, true);
		mapActivity.getMapView().setIntZoom(fZoom);
		mapActivity.getMapView().setLatLon(locationPoint.getLatitude(), locationPoint.getLongitude());
	}
}
!@#$%
20190530_012237,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_c05756
package net.osmand.plus.helpers;

import android.app.AlertDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.graphics.Color;
import android.os.AsyncTask;
import android.os.SystemClock;
import android.text.Spannable;
import android.text.style.ForegroundColorSpan;
import android.util.TypedValue;
import android.view.Gravity;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.*;
import net.osmand.Location;
import net.osmand.data.LocationPoint;
import net.osmand.plus.*;
import net.osmand.plus.activities.FavouritesActivity;
import net.osmand.plus.activities.MapActivity;
import net.osmand.plus.base.FavoriteImageDrawable;
import net.osmand.plus.views.MapControlsLayer;
import net.osmand.util.MapUtils;

import java.util.List;

/**
 * Created by Denis on 25.07.2014.
 */
public class WaypointDialogHelper {
	private MapActivity mapActivity;
	private OsmandApplication app;
	private FrameLayout mainLayout;
	private WaypointHelper waypointHelper;

	public static boolean OVERLAP_LAYOUT = true;
	private long uiModified;
	private View closePointDialog;

	public WaypointDialogHelper(MapActivity mapActivity) {
		this.app = mapActivity.getMyApplication();
		waypointHelper = this.app.getWaypointHelper();
		this.mapActivity = mapActivity;
		this.mainLayout = (FrameLayout) ((FrameLayout) mapActivity.getLayout()).getChildAt(0);
	}

	public void updateDialog() {
		List<LocationPoint> vlp = waypointHelper.getVisibleLocationPoints();
		long locationPointsModified = waypointHelper.getLocationPointsModified();
		if (locationPointsModified != uiModified) {
			uiModified = locationPointsModified;
			if (vlp.isEmpty()) {
				removeDialog();
			} else {
				final LocationPoint point = vlp.get(0);
				boolean created = false;
				if (closePointDialog == null) {
					created = true;
					final LayoutInflater vi = (LayoutInflater) app.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
					closePointDialog = vi.inflate(R.layout.waypoint_reached, null);
				}

				updatePointInfoView(closePointDialog, point);
				closePointDialog.setBackgroundColor(mapActivity.getResources().getColor(R.color.color_black));
				((TextView) closePointDialog.findViewById(R.id.waypoint_text)).setTextColor(Color.WHITE);
				View all = closePointDialog.findViewById(R.id.all_points);
				all.setVisibility(vlp.size() <= 1 ? View.GONE : View.VISIBLE);
				all.setOnClickListener(new View.OnClickListener() {
					@Override
					public void onClick(View view) {
						showAllDialog();
					}
				});

				View btnN = closePointDialog.findViewById(R.id.info_close);
				btnN.setOnClickListener(new View.OnClickListener() {
					@Override
					public void onClick(View view) {
						waypointHelper.removeVisibleLocationPoint(point);
						updateDialog();
					}
				});

				if (created) {
					mainLayout.addView(closePointDialog, getDialogLayoutParams());
					waitBeforeLayoutIsResized(closePointDialog);
				}
			}
		}
	}

	private void updatePointInfoView(View localView, final LocationPoint point) {
		TextView text = (TextView) localView.findViewById(R.id.waypoint_text);
		text.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View view) {
				itemClick(point);
			}
		});

		((ImageView) localView.findViewById(R.id.waypoint_icon)).setImageDrawable(FavoriteImageDrawable.getOrCreate(mapActivity, point.getColor()));
		Location lastKnownMapLocation = app.getLocationProvider().getLastKnownLocation();
		String distance;
		if (lastKnownMapLocation != null) {
			int dist = (int) (MapUtils.getDistance(point.getLatitude(), point.getLongitude(),
					lastKnownMapLocation.getLatitude(), lastKnownMapLocation.getLongitude()));
			distance = OsmAndFormatter.getFormattedDistance(dist, app) + "  ";
		} else {
			distance = "";
		}
		text.setText(distance + point.getName(), TextView.BufferType.SPANNABLE);
		if (distance.length() > 0) {
			((Spannable) text.getText()).setSpan(
					new ForegroundColorSpan(mapActivity.getResources().getColor(R.color.color_distance)), 0, distance.length() - 1,
					0);
		}
	}

	private void itemClick(LocationPoint point) {
		final Intent favorites = new Intent(mapActivity, app.getAppCustomization().getFavoritesActivity());
		favorites.setFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);
		favorites.putExtra(FavouritesActivity.TAB_PARAM,
				point instanceof GPXUtilities.WptPt ? FavouritesActivity.GPX_TAB : FavouritesActivity.FAVORITES_TAB);
		mapActivity.startActivity(favorites);
	}

	public void removeDialog() {
		if (closePointDialog != null) {
			mainLayout.removeView(closePointDialog);
			closePointDialog = null;
			shiftButtons(0);
		}
	}

	private FrameLayout.LayoutParams getDialogLayoutParams() {
		FrameLayout.LayoutParams params = new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.WRAP_CONTENT);
		params.gravity = Gravity.BOTTOM | Gravity.CENTER_HORIZONTAL;
		return params;
	}

	private boolean checkIfDialogExists() {
		if (mainLayout == null) {
			return true;
		}

		if (mainLayout.findViewById(R.id.package_delivered_layout) != null) {
			return false;
		}
		return true;
	}

	private void shiftButtons(int height) {
		MapControlsLayer mapControls = mapActivity.getMapLayers().getMapControlsLayer();
		if (mapControls != null) {
			mapControls.shiftLayout(height);
		}
	}


	private void waitBeforeLayoutIsResized(View reachedView) {
		//this async task is needed because layout height is not set
		// right after you add it so we need to w8 some time
		new AsyncTask<View, Void, Void>() {
			int height;

			@Override
			protected Void doInBackground(View... params) {
				for (int i = 0; i < 10; i++) {
					SystemClock.sleep(50);
					height = params[0].getHeight();
					if (params[0].getHeight() > 0) {
						break;
					}
				}
				return null;
			}

			protected void onPostExecute(Void result) {
				if (height > 0 && OVERLAP_LAYOUT) {
					shiftButtons(height);
				}
			}
		}.execute(reachedView);
	}

	public void showAllDialog(){
		final List<LocationPoint> visibleLocationPoints = waypointHelper.getVisibleLocationPoints();
		final ArrayAdapter<LocationPoint> listAdapter = new ArrayAdapter<LocationPoint>(mapActivity, R.layout.waypoint_reached, R.id.title,
				visibleLocationPoints) {
			@Override
			public View getView(final int position, View convertView, ViewGroup parent) {
				// User super class to create the View
				View v = convertView;
				if (v == null) {
					v = mapActivity.getLayoutInflater().inflate(R.layout.waypoint_reached, null);
					int vl = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 32, mapActivity.getResources()
							.getDisplayMetrics());
					final LinearLayout.LayoutParams ll = new LinearLayout.LayoutParams(vl, vl);
					ll.setMargins(vl / 4, vl / 4, vl / 4, vl / 4);
					v.findViewById(R.id.waypoint_icon).setLayoutParams(ll);
				}
				updatePointInfoView(v, getItem(position));
				TextView text = (TextView) v.findViewById(R.id.waypoint_text);
				text.setOnClickListener(new View.OnClickListener() {
					@Override
					public void onClick(View view) {
						showOnMap(visibleLocationPoints.get(position));
					}
				});

				View remove = v.findViewById(R.id.info_close);
				((ImageButton) remove).setImageDrawable(mapActivity.getResources().getDrawable(
						app.getSettings().isLightContent()? R.drawable.ic_action_gremove_light:
								R.drawable.ic_action_gremove_dark));
				remove.setOnClickListener(new View.OnClickListener() {
					@Override
					public void onClick(View view) {
						LocationPoint point = waypointHelper.getVisibleLocationPoints().get(position);
						remove(point);
						waypointHelper.removeVisibleLocationPoint(point);
						notifyDataSetChanged();
					}
				});

				return v;
			}
		};

		ListView listView = new ListView(mapActivity);
		listView.setAdapter(listAdapter);
		listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
			@Override
			public void onItemClick(AdapterView<?> adapterView, View view, int i, long l) {
				showOnMap(visibleLocationPoints.get(i));
			}
		});

//		Dialog dlg = new Dialog(mapActivity);
//		dlg.setContentView(listView);
//		dlg.show();
		AlertDialog.Builder builder = new AlertDialog.Builder(mapActivity);
		builder.setView(listView);
		builder.setPositiveButton(R.string.default_buttons_ok, null);
		builder.setNegativeButton(mapActivity.getString(R.string.hide_all_waypoints), new DialogInterface.OnClickListener() {
			@Override
			public void onClick(DialogInterface dialogInterface, int i) {
				waypointHelper.clearAllVisiblePoints();
				updateDialog();
			}
		});
		builder.show();
	}

	private void showOnMap(LocationPoint locationPoint) {
		// AnimateDraggingMapThread thread = mapActivity.getMapView().getAnimatedDraggingThread();
		int fZoom = mapActivity.getMapView().getZoom() < 15 ? 15 : mapActivity.getMapView().getZoom();
		// thread.startMoving(pointToNavigate.getLatitude(), pointToNavigate.getLongitude(), fZoom, true);
		mapActivity.getMapView().setIntZoom(fZoom);
		mapActivity.getMapView().setLatLon(locationPoint.getLatitude(), locationPoint.getLongitude());
	}
}
!@#$%
20190530_013431,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_b13224
package net.osmand.plus.views.controllers;

import android.content.Context;
import android.opengl.EGL14;
import android.opengl.GLSurfaceView;
import android.os.Environment;
import android.util.DisplayMetrics;
import android.util.Log;
import android.view.GestureDetector;
import android.view.MotionEvent;
import android.view.ViewParent;
import android.view.WindowManager;
import android.widget.FrameLayout;
import net.osmand.access.MapAccessibilityActions;
import net.osmand.core.android.CoreResourcesFromAndroidAssetsCustom;
import net.osmand.core.jni.*;
import net.osmand.data.LatLon;
import net.osmand.data.QuadPoint;
import net.osmand.data.RotatedTileBox;
import net.osmand.map.MapTileDownloader;
import net.osmand.plus.OsmandSettings;
import net.osmand.plus.activities.MapActivity;
import net.osmand.plus.activities.MapActivityLayers;
import net.osmand.plus.base.MapViewTrackingUtilities;
import net.osmand.plus.helpers.SimpleTwoFingerTapDetector;
import net.osmand.plus.render.NativeOsmandLibrary;
import net.osmand.plus.views.OsmandMapLayer;
import net.osmand.plus.views.OsmandMapTileView;

import javax.microedition.khronos.egl.*;
import java.io.File;
import java.util.List;

/**
 * Created by Denis on 01.10.2014.
 */
public class NativeViewController extends MapViewBaseController {

	static {
		NativeOsmandLibrary.loadLibrary("gnustl_shared");
		NativeOsmandLibrary.loadLibrary("Qt5Core");
		NativeOsmandLibrary.loadLibrary("Qt5Network");
		NativeOsmandLibrary.loadLibrary("Qt5Sql");
		NativeOsmandLibrary.loadLibrary("OsmAndCoreWithJNI");
	}

	private GLSurfaceView glSurfaceView;
	private OsmandSettings settings;
	private MapActivity mapActivity;
	private float displayDensityFactor;
	private int referenceTileSize;
	private int rasterTileSize;
	private IMapStylesCollection mapStylesCollection;
	private ResolvedMapStyle mapStyle;
	private ObfsCollection obfsCollection;
	private MapPresentationEnvironment mapPresentationEnvironment;
	private Primitiviser primitiviser;
	private BinaryMapDataProvider binaryMapDataProvider;
	private BinaryMapPrimitivesProvider binaryMapPrimitivesProvider;
	private BinaryMapStaticSymbolsProvider binaryMapStaticSymbolsProvider;
	private BinaryMapRasterBitmapTileProvider binaryMapRasterBitmapTileProvider;
	private OnlineRasterMapTileProvider onlineMapRasterBitmapTileProvider;
	private IMapRenderer mapRenderer;
	private GpuWorkerThreadPrologue gpuWorkerThreadPrologue;
	private GpuWorkerThreadEpilogue gpuWorkerThreadEpilogue;
	private RenderRequestCallback renderRequestCallback;
	private QIODeviceLogSink fileLogSink;
	private RotatedTileBox currentViewport = null;

	private boolean offlineMap = true;

	private GestureDetector gestureDetector;

	public static final String NATIVE_TAG = "NativeRender";
	private CoreResourcesFromAndroidAssetsCustom coreResources;

	SimpleTwoFingerTapDetector twoFingerTapDetector = new SimpleTwoFingerTapDetector() {
		@Override
		public void onTwoFingerTap() {
			currentViewport.setZoom(currentViewport.getZoom() - 1);
			updateView();
		}
	};


	public NativeViewController(GLSurfaceView surfaceView, MapActivity activity) {
		this.glSurfaceView = surfaceView;
		this.settings = activity.getMyApplication().getSettings();
		this.mapActivity = activity;
		setupView();
	}

	private void setupView() {
		WindowManager mgr = (WindowManager)mapActivity.getSystemService(Context.WINDOW_SERVICE);
		DisplayMetrics dm = new DisplayMetrics();
		mgr.getDefaultDisplay().getMetrics(dm);
		currentViewport = new RotatedTileBox.RotatedTileBoxBuilder().
				setLocation(settings.getLastKnownMapLocation().getLatitude(),
						settings.getLastKnownMapLocation().getLongitude()).setZoomAndScale(settings.getLastKnownMapZoom(), 0).
				setPixelDimensions(dm.widthPixels, dm.heightPixels).build();
		currentViewport.setDensity(dm.density);



		gestureDetector = new GestureDetector(mapActivity, new GestureDetector.OnGestureListener() {

			@Override
			public boolean onSingleTapUp(MotionEvent e) {
				return false;
			}

			@Override
			public void onShowPress(MotionEvent e) {
			}

			@Override
			public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {
				final QuadPoint cp = currentViewport.getCenterPixelPoint();
				final LatLon latlon = currentViewport.getLatLonFromPixel(cp.x + distanceX, cp.y + distanceY);
				currentViewport.setLatLonCenter(latlon.getLatitude(), latlon.getLongitude());
				updateView();
				return false;
			}

			@Override
			public void onLongPress(MotionEvent e) {
			}

			@Override
			public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
				return false;
			}

			@Override
			public boolean onDown(MotionEvent e) {
				return false;
			}
		});
		gestureDetector.setOnDoubleTapListener(new GestureDetector.OnDoubleTapListener() {
			@Override
			public boolean onSingleTapConfirmed(MotionEvent e) {
				return false;
			}

			@Override
			public boolean onDoubleTapEvent(MotionEvent e) {
				return false;
			}

			@Override
			public boolean onDoubleTap(MotionEvent e) {
				currentViewport.setZoom(currentViewport.getZoom() + 1);
				updateView();
				return true;
			}
		});

		// Get device display density factor
		DisplayMetrics displayMetrics = new DisplayMetrics();
		mapActivity.getWindowManager().getDefaultDisplay().getMetrics(displayMetrics);
		displayDensityFactor = displayMetrics.densityDpi / 160.0f;
		referenceTileSize = (int)(256 * displayDensityFactor);
		rasterTileSize = Integer.highestOneBit(referenceTileSize - 1) * 2;
		Log.i(NATIVE_TAG, "displayDensityFactor = " + displayDensityFactor);
		Log.i(NATIVE_TAG, "referenceTileSize = " + referenceTileSize);
		Log.i(NATIVE_TAG, "rasterTileSize = " + rasterTileSize);

		Log.i(NATIVE_TAG, "Initializing core...");
		coreResources = CoreResourcesFromAndroidAssetsCustom.loadFromCurrentApplication(mapActivity.getMyApplication());
		OsmAndCore.InitializeCore(coreResources);

		File directory =mapActivity.getMyApplication().getAppPath("");
		fileLogSink = QIODeviceLogSink.createFileLogSink(directory.getAbsolutePath() + "osmandcore.log");
		Logger.get().addLogSink(fileLogSink);

		Log.i(NATIVE_TAG, "Going to resolve default embedded style...");
		mapStylesCollection = new MapStylesCollection();
		mapStyle = mapStylesCollection.getResolvedStyleByName("default");
		if (mapStyle == null)
		{
			Log.e(NATIVE_TAG, "Failed to resolve style 'default'");
			System.exit(0);
		}

		Log.i(NATIVE_TAG, "Going to prepare OBFs collection");
		obfsCollection = new ObfsCollection();

		Log.i(NATIVE_TAG, "Will load OBFs from " + Environment.getExternalStorageDirectory() + "/osmand");

		Log.i(NATIVE_TAG, "Will load OBFs from " + directory.getAbsolutePath());
		obfsCollection.addDirectory(directory.getAbsolutePath(), false);

		Log.i(NATIVE_TAG, "Going to prepare all resources for renderer");
		mapPresentationEnvironment = new MapPresentationEnvironment(
				mapStyle,
				displayDensityFactor,
				"en"); //TODO: here should be current locale
		//mapPresentationEnvironment->setSettings(configuration.styleSettings);
		primitiviser = new Primitiviser(
				mapPresentationEnvironment);
		binaryMapDataProvider = new BinaryMapDataProvider(
				obfsCollection);
		binaryMapPrimitivesProvider = new BinaryMapPrimitivesProvider(
				binaryMapDataProvider,
				primitiviser,
				rasterTileSize);
		binaryMapStaticSymbolsProvider = new BinaryMapStaticSymbolsProvider(
				binaryMapPrimitivesProvider,
				rasterTileSize);
		binaryMapRasterBitmapTileProvider = new BinaryMapRasterBitmapTileProvider_Software(
				binaryMapPrimitivesProvider);

		onlineMapRasterBitmapTileProvider = OnlineTileSources.getBuiltIn().createProviderFor("Mapnik (OsmAnd)");

		Log.i(NATIVE_TAG, "Going to create renderer");
		mapRenderer = OsmAndCore.createMapRenderer(MapRendererClass.AtlasMapRenderer_OpenGLES2);
		if (mapRenderer == null)
		{
			Log.e(NATIVE_TAG, "Failed to create map renderer 'AtlasMapRenderer_OpenGLES2'");
			System.exit(0);
		}

		AtlasMapRendererConfiguration atlasRendererConfiguration = AtlasMapRendererConfiguration.Casts.upcastFrom(mapRenderer.getConfiguration());
		atlasRendererConfiguration.setReferenceTileSizeOnScreenInPixels(referenceTileSize);
		mapRenderer.setConfiguration(AtlasMapRendererConfiguration.Casts.downcastTo_MapRendererConfiguration(atlasRendererConfiguration));

		mapRenderer.addSymbolProvider(binaryMapStaticSymbolsProvider);
		updateView();
        /*
        IMapRasterBitmapTileProvider mapnik = OnlineTileSources.getBuiltIn().createProviderFor("Mapnik (OsmAnd)");
        if (mapnik == null)
            Log.e(NATIVE_TAG, "Failed to create mapnik");
        */
		if (offlineMap){
			mapRenderer.setRasterLayerProvider(RasterMapLayerId.BaseLayer, binaryMapRasterBitmapTileProvider);
		} else {
			mapRenderer.setRasterLayerProvider(RasterMapLayerId.BaseLayer, onlineMapRasterBitmapTileProvider);
		}

		//TODO:_glSurfaceView.setPreserveEGLContextOnPause(true);
		glSurfaceView.setEGLContextClientVersion(2);
		glSurfaceView.setEGLContextFactory(new EGLContextFactory());
		glSurfaceView.setRenderer(new NativeRenderer(mapRenderer));
		glSurfaceView.setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY);
	}

	protected void updateView() {
		mapRenderer.setAzimuth(0.0f);
		mapRenderer.setElevationAngle(90);
		mapRenderer.setTarget(new PointI(currentViewport.getCenter31X(), currentViewport.getCenter31Y()));
		mapRenderer.setZoom((float)currentViewport.getZoom() + (float)currentViewport.getZoomScale());
	}

	private class EGLContextFactory implements GLSurfaceView.EGLContextFactory {
		private EGLContext _gpuWorkerContext;
		private EGLSurface _gpuWorkerFakeSurface;

		public EGLContext createContext(EGL10 egl, EGLDisplay display, EGLConfig eglConfig) {
			final String eglExtensions = egl.eglQueryString(display, EGL10.EGL_EXTENSIONS);
			Log.i(NATIVE_TAG, "EGL extensions: " + eglExtensions);
			final String eglVersion = egl.eglQueryString(display, EGL10.EGL_VERSION);
			Log.i(NATIVE_TAG, "EGL version: " + eglVersion);

			Log.i(NATIVE_TAG, "Creating main context...");
			final int[] contextAttribList = {
					EGL14.EGL_CONTEXT_CLIENT_VERSION, 2,
					EGL10.EGL_NONE };

			EGLContext mainContext = null;
			try {
				mainContext = egl.eglCreateContext(display, eglConfig, EGL10.EGL_NO_CONTEXT, contextAttribList);
			} catch (Exception e) {
				Log.e(NATIVE_TAG, "Failed to create main context", e);
			}
			if (mainContext == null || mainContext == EGL10.EGL_NO_CONTEXT) {
				Log.e(NATIVE_TAG, "Failed to create main context: " + egl.eglGetError());
				mainContext = null;
				System.exit(0);
			}

			Log.i(NATIVE_TAG, "Creating GPU worker context...");
			try {
				_gpuWorkerContext = egl.eglCreateContext(
						display,
						eglConfig,
						mainContext,
						contextAttribList);
			} catch (Exception e) {
				Log.e(NATIVE_TAG, "Failed to create GPU worker context", e);
			}
			if (_gpuWorkerContext == null || _gpuWorkerContext == EGL10.EGL_NO_CONTEXT)
			{
				Log.e(NATIVE_TAG, "Failed to create GPU worker context: " + egl.eglGetError());
				_gpuWorkerContext = null;
			}

			if (_gpuWorkerContext != null)
			{
				Log.i(NATIVE_TAG, "Creating GPU worker fake surface...");
				try {
					final int[] surfaceAttribList = {
							EGL10.EGL_WIDTH, 1,
							EGL10.EGL_HEIGHT, 1,
							EGL10.EGL_NONE };
					_gpuWorkerFakeSurface = egl.eglCreatePbufferSurface(display, eglConfig, surfaceAttribList);
				} catch (Exception e) {
					Log.e(NATIVE_TAG, "Failed to create GPU worker fake surface", e);
				}
				if (_gpuWorkerFakeSurface == null || _gpuWorkerFakeSurface == EGL10.EGL_NO_SURFACE)
				{
					Log.e(NATIVE_TAG, "Failed to create GPU worker fake surface: " + egl.eglGetError());
					_gpuWorkerFakeSurface = null;
				}
			}

			MapRendererSetupOptions rendererSetupOptions = new MapRendererSetupOptions();
			if (_gpuWorkerContext != null && _gpuWorkerFakeSurface != null) {
				rendererSetupOptions.setGpuWorkerThreadEnabled(true);
				gpuWorkerThreadPrologue = new GpuWorkerThreadPrologue(egl, display, _gpuWorkerContext, _gpuWorkerFakeSurface);
				rendererSetupOptions.setGpuWorkerThreadPrologue(gpuWorkerThreadPrologue.getBinding());
				gpuWorkerThreadEpilogue = new GpuWorkerThreadEpilogue(egl);
				rendererSetupOptions.setGpuWorkerThreadEpilogue(gpuWorkerThreadEpilogue.getBinding());
			} else {
				rendererSetupOptions.setGpuWorkerThreadEnabled(false);
			}
			renderRequestCallback = new RenderRequestCallback();
			rendererSetupOptions.setFrameUpdateRequestCallback(renderRequestCallback.getBinding());
			mapRenderer.setup(rendererSetupOptions);

			return mainContext;
		}

		public void destroyContext(EGL10 egl, EGLDisplay display, EGLContext context) {
			egl.eglDestroyContext(display, context);

			if (_gpuWorkerContext != null) {
				egl.eglDestroyContext(display, _gpuWorkerContext);
				_gpuWorkerContext = null;
			}

			if (_gpuWorkerFakeSurface != null) {
				egl.eglDestroySurface(display, _gpuWorkerFakeSurface);
				_gpuWorkerFakeSurface = null;
			}
		}
	}

	private class GpuWorkerThreadEpilogue extends MapRendererSetupOptions.IGpuWorkerThreadEpilogue {
		public GpuWorkerThreadEpilogue(EGL10 egl) {
			_egl = egl;
		}

		private final EGL10 _egl;

		@Override
		public void method(IMapRenderer mapRenderer) {
			try {
				if (!_egl.eglWaitGL())
					Log.e(NATIVE_TAG, "Failed to wait for GPU worker context: " + _egl.eglGetError());
			} catch (Exception e) {
				Log.e(NATIVE_TAG, "Failed to wait for GPU worker context", e);
			}
		}
	}

	private class GpuWorkerThreadPrologue extends MapRendererSetupOptions.IGpuWorkerThreadPrologue {
		public GpuWorkerThreadPrologue(EGL10 egl, EGLDisplay eglDisplay, EGLContext context, EGLSurface surface) {
			_egl = egl;
			_eglDisplay = eglDisplay;
			_context = context;
			_eglSurface = surface;
		}

		private final EGL10 _egl;
		private final EGLDisplay _eglDisplay;
		private final EGLContext _context;
		private final EGLSurface _eglSurface;

		@Override
		public void method(IMapRenderer mapRenderer) {
			try {
				if (!_egl.eglMakeCurrent(_eglDisplay, _eglSurface, _eglSurface, _context))
					Log.e(NATIVE_TAG, "Failed to set GPU worker context active: " + _egl.eglGetError());
			} catch (Exception e) {
				Log.e(NATIVE_TAG, "Failed to set GPU worker context active", e);
			}
		}
	}

	private class RenderRequestCallback extends MapRendererSetupOptions.IFrameUpdateRequestCallback {
		@Override
		public void method(IMapRenderer mapRenderer) {
			glSurfaceView.requestRender();
		}
	}

	@Override
	public void setTrackBallDelegate(OnTrackBallListener trackBallDelegate) {
		super.setTrackBallDelegate(trackBallDelegate);
	}

	@Override
	public void setAccessibilityActions(MapAccessibilityActions accessibilityActions) {
		super.setAccessibilityActions(accessibilityActions);
	}

	@Override
	public void refreshMap(boolean b) {
		updateView();
	}

	@Override
	public void createLayers(MapActivityLayers mapLayers) {
		mapLayers.createLayers(glSurfaceView);
	}

	@Override
	public void setLatLon(double latitude, double longitude) {
		super.setLatLon(latitude, longitude);
	}

	@Override
	public void setIntZoom(int i) {
		super.setIntZoom(i);
	}

	@Override
	public void addView(FrameLayout view) {
		super.addView(view);
	}

	@Override
	public void setTrackingUtilities(MapViewTrackingUtilities mapViewTrackingUtilities) {
		super.setTrackingUtilities(mapViewTrackingUtilities);
	}

	@Override
	public void tileDownloaded(MapTileDownloader.DownloadRequest request) {
		super.tileDownloaded(request);
	}

	@Override
	public ViewParent getParentView() {
		return glSurfaceView.getParent();
	}

	@Override
	public List<OsmandMapLayer> getLayers() {
		return super.getLayers();
	}

	@Override
	public double getLatitude() {
		return super.getLatitude();
	}

	@Override
	public double getLongitude() {
		return super.getLongitude();
	}

	@Override
	public void startMoving(double latitude, double longitude, int mapZoomToShow, boolean b) {
		super.startMoving(latitude, longitude, mapZoomToShow, b);
	}

	@Override
	public int getZoom() {
		return super.getZoom();
	}

	@Override
	public void startZooming(int newZoom, boolean changeLocation) {
		super.startZooming(newZoom, changeLocation);
	}

	@Override
	public boolean isZooming() {
		return super.isZooming();
	}

	@Override
	public RotatedTileBox getCurrentRotatedTileBox() {
		return super.getCurrentRotatedTileBox();
	}

	@Override
	public void onPause() {
		super.onPause();
	}

	@Override
	public void updateLayers(MapActivityLayers mapLayers) {
		super.updateLayers(mapLayers);
	}

	@Override
	public void setComplexZoom() {
		super.setComplexZoom();
	}

	@Override
	public void showAndHideMapPosition() {
		super.showAndHideMapPosition();
	}

	@Override
	public OsmandMapTileView getMapTileView() {
		return super.getMapTileView();
	}

	@Override
	public boolean onTouchEvent(MotionEvent event) {
		if (twoFingerTapDetector.onTouchEvent(event)) {
			return true;
		}
		return gestureDetector.onTouchEvent(event);
	}

	@Override
	public void resume() {
		glSurfaceView.onResume();
	}

	@Override
	public void destroy() {
		if (mapStylesCollection != null) {
			mapStylesCollection.delete();
			mapStylesCollection = null;
		}

		if (mapStyle != null) {
			mapStyle.delete();
			mapStyle = null;
		}

		if (obfsCollection != null) {
			obfsCollection.delete();
			obfsCollection = null;
		}

		if (mapPresentationEnvironment != null) {
			mapPresentationEnvironment.delete();
			mapPresentationEnvironment = null;
		}

		if (primitiviser != null) {
			primitiviser.delete();
			primitiviser = null;
		}

		if (binaryMapDataProvider != null) {
			binaryMapDataProvider.delete();
			binaryMapDataProvider = null;
		}

		if (binaryMapPrimitivesProvider != null) {
			binaryMapPrimitivesProvider.delete();
			binaryMapPrimitivesProvider = null;
		}

		if (binaryMapStaticSymbolsProvider != null) {
			binaryMapStaticSymbolsProvider.delete();
			binaryMapStaticSymbolsProvider = null;
		}

		if (binaryMapRasterBitmapTileProvider != null) {
			binaryMapRasterBitmapTileProvider.delete();
			binaryMapRasterBitmapTileProvider = null;
		}

		if (mapRenderer != null) {
			mapRenderer.delete();
			mapRenderer = null;
		}

		OsmAndCore.ReleaseCore();
	}
}
!@#$%
20190530_013431,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_a13224
package net.osmand.plus.views.controllers;

import android.content.Context;
import android.opengl.EGL14;
import android.opengl.GLSurfaceView;
import android.os.Environment;
import android.util.DisplayMetrics;
import android.util.Log;
import android.view.GestureDetector;
import android.view.MotionEvent;
import android.view.ViewParent;
import android.view.WindowManager;
import android.widget.FrameLayout;
import net.osmand.access.MapAccessibilityActions;
import net.osmand.core.android.CoreResourcesFromAndroidAssets;
import net.osmand.core.jni.*;
import net.osmand.data.LatLon;
import net.osmand.data.QuadPoint;
import net.osmand.data.RotatedTileBox;
import net.osmand.map.MapTileDownloader;
import net.osmand.plus.OsmandSettings;
import net.osmand.plus.activities.MapActivity;
import net.osmand.plus.activities.MapActivityLayers;
import net.osmand.plus.base.MapViewTrackingUtilities;
import net.osmand.plus.helpers.SimpleTwoFingerTapDetector;
import net.osmand.plus.render.NativeOsmandLibrary;
import net.osmand.plus.views.OsmandMapLayer;
import net.osmand.plus.views.OsmandMapTileView;

import javax.microedition.khronos.egl.*;
import java.io.File;
import java.util.List;

/**
 * Created by Denis on 01.10.2014.
 */
public class NativeViewController extends MapViewBaseController {

	static {
		NativeOsmandLibrary.loadLibrary("gnustl_shared");
		NativeOsmandLibrary.loadLibrary("Qt5Core");
		NativeOsmandLibrary.loadLibrary("Qt5Network");
		NativeOsmandLibrary.loadLibrary("Qt5Sql");
		NativeOsmandLibrary.loadLibrary("OsmAndCoreWithJNI");
	}

	private GLSurfaceView glSurfaceView;
	private OsmandSettings settings;
	private MapActivity mapActivity;
	private float displayDensityFactor;
	private int referenceTileSize;
	private int rasterTileSize;
	private IMapStylesCollection mapStylesCollection;
	private ResolvedMapStyle mapStyle;
	private ObfsCollection obfsCollection;
	private MapPresentationEnvironment mapPresentationEnvironment;
	private Primitiviser primitiviser;
	private BinaryMapDataProvider binaryMapDataProvider;
	private BinaryMapPrimitivesProvider binaryMapPrimitivesProvider;
	private BinaryMapStaticSymbolsProvider binaryMapStaticSymbolsProvider;
	private BinaryMapRasterBitmapTileProvider binaryMapRasterBitmapTileProvider;
	private OnlineRasterMapTileProvider onlineMapRasterBitmapTileProvider;
	private IMapRenderer mapRenderer;
	private GpuWorkerThreadPrologue gpuWorkerThreadPrologue;
	private GpuWorkerThreadEpilogue gpuWorkerThreadEpilogue;
	private RenderRequestCallback renderRequestCallback;
	private QIODeviceLogSink fileLogSink;
	private RotatedTileBox currentViewport = null;

	private boolean offlineMap = true;

	private GestureDetector gestureDetector;

	public static final String NATIVE_TAG = "NativeRender";
	private CoreResourcesFromAndroidAssets coreResources;

	SimpleTwoFingerTapDetector twoFingerTapDetector = new SimpleTwoFingerTapDetector() {
		@Override
		public void onTwoFingerTap() {
			currentViewport.setZoom(currentViewport.getZoom() - 1);
			updateView();
		}
	};


	public NativeViewController(GLSurfaceView surfaceView, MapActivity activity) {
		this.glSurfaceView = surfaceView;
		this.settings = activity.getMyApplication().getSettings();
		this.mapActivity = activity;
		setupView();
	}

	private void setupView() {
		WindowManager mgr = (WindowManager)mapActivity.getSystemService(Context.WINDOW_SERVICE);
		DisplayMetrics dm = new DisplayMetrics();
		mgr.getDefaultDisplay().getMetrics(dm);
		currentViewport = new RotatedTileBox.RotatedTileBoxBuilder().
				setLocation(settings.getLastKnownMapLocation().getLatitude(),
						settings.getLastKnownMapLocation().getLongitude()).setZoomAndScale(settings.getLastKnownMapZoom(), 0).
				setPixelDimensions(dm.widthPixels, dm.heightPixels).build();
		currentViewport.setDensity(dm.density);



		gestureDetector = new GestureDetector(mapActivity, new GestureDetector.OnGestureListener() {

			@Override
			public boolean onSingleTapUp(MotionEvent e) {
				return false;
			}

			@Override
			public void onShowPress(MotionEvent e) {
			}

			@Override
			public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {
				final QuadPoint cp = currentViewport.getCenterPixelPoint();
				final LatLon latlon = currentViewport.getLatLonFromPixel(cp.x + distanceX, cp.y + distanceY);
				currentViewport.setLatLonCenter(latlon.getLatitude(), latlon.getLongitude());
				updateView();
				return false;
			}

			@Override
			public void onLongPress(MotionEvent e) {
			}

			@Override
			public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
				return false;
			}

			@Override
			public boolean onDown(MotionEvent e) {
				return false;
			}
		});
		gestureDetector.setOnDoubleTapListener(new GestureDetector.OnDoubleTapListener() {
			@Override
			public boolean onSingleTapConfirmed(MotionEvent e) {
				return false;
			}

			@Override
			public boolean onDoubleTapEvent(MotionEvent e) {
				return false;
			}

			@Override
			public boolean onDoubleTap(MotionEvent e) {
				currentViewport.setZoom(currentViewport.getZoom() + 1);
				updateView();
				return true;
			}
		});

		// Get device display density factor
		DisplayMetrics displayMetrics = new DisplayMetrics();
		mapActivity.getWindowManager().getDefaultDisplay().getMetrics(displayMetrics);
		displayDensityFactor = displayMetrics.densityDpi / 160.0f;
		referenceTileSize = (int)(256 * displayDensityFactor);
		rasterTileSize = Integer.highestOneBit(referenceTileSize - 1) * 2;
		Log.i(NATIVE_TAG, "displayDensityFactor = " + displayDensityFactor);
		Log.i(NATIVE_TAG, "referenceTileSize = " + referenceTileSize);
		Log.i(NATIVE_TAG, "rasterTileSize = " + rasterTileSize);

		Log.i(NATIVE_TAG, "Initializing core...");
		coreResources = CoreResourcesFromAndroidAssets.loadFromCurrentApplication(mapActivity.getMyApplication());
		OsmAndCore.InitializeCore(coreResources);

		File directory =mapActivity.getMyApplication().getAppPath("");
		fileLogSink = QIODeviceLogSink.createFileLogSink(directory.getAbsolutePath() + "osmandcore.log");
		Logger.get().addLogSink(fileLogSink);

		Log.i(NATIVE_TAG, "Going to resolve default embedded style...");
		mapStylesCollection = new MapStylesCollection();
		mapStyle = mapStylesCollection.getResolvedStyleByName("default");
		if (mapStyle == null)
		{
			Log.e(NATIVE_TAG, "Failed to resolve style 'default'");
			System.exit(0);
		}

		Log.i(NATIVE_TAG, "Going to prepare OBFs collection");
		obfsCollection = new ObfsCollection();

		Log.i(NATIVE_TAG, "Will load OBFs from " + Environment.getExternalStorageDirectory() + "/osmand");

		Log.i(NATIVE_TAG, "Will load OBFs from " + directory.getAbsolutePath());
		obfsCollection.addDirectory(directory.getAbsolutePath(), false);

		Log.i(NATIVE_TAG, "Going to prepare all resources for renderer");
		mapPresentationEnvironment = new MapPresentationEnvironment(
				mapStyle,
				displayDensityFactor,
				"en"); //TODO: here should be current locale
		//mapPresentationEnvironment->setSettings(configuration.styleSettings);
		primitiviser = new Primitiviser(
				mapPresentationEnvironment);
		binaryMapDataProvider = new BinaryMapDataProvider(
				obfsCollection);
		binaryMapPrimitivesProvider = new BinaryMapPrimitivesProvider(
				binaryMapDataProvider,
				primitiviser,
				rasterTileSize);
		binaryMapStaticSymbolsProvider = new BinaryMapStaticSymbolsProvider(
				binaryMapPrimitivesProvider,
				rasterTileSize);
		binaryMapRasterBitmapTileProvider = new BinaryMapRasterBitmapTileProvider_Software(
				binaryMapPrimitivesProvider);

		onlineMapRasterBitmapTileProvider = OnlineTileSources.getBuiltIn().createProviderFor("Mapnik (OsmAnd)");

		Log.i(NATIVE_TAG, "Going to create renderer");
		mapRenderer = OsmAndCore.createMapRenderer(MapRendererClass.AtlasMapRenderer_OpenGLES2);
		if (mapRenderer == null)
		{
			Log.e(NATIVE_TAG, "Failed to create map renderer 'AtlasMapRenderer_OpenGLES2'");
			System.exit(0);
		}

		AtlasMapRendererConfiguration atlasRendererConfiguration = AtlasMapRendererConfiguration.Casts.upcastFrom(mapRenderer.getConfiguration());
		atlasRendererConfiguration.setReferenceTileSizeOnScreenInPixels(referenceTileSize);
		mapRenderer.setConfiguration(AtlasMapRendererConfiguration.Casts.downcastTo_MapRendererConfiguration(atlasRendererConfiguration));

		mapRenderer.addSymbolProvider(binaryMapStaticSymbolsProvider);
		updateView();
        /*
        IMapRasterBitmapTileProvider mapnik = OnlineTileSources.getBuiltIn().createProviderFor("Mapnik (OsmAnd)");
        if (mapnik == null)
            Log.e(NATIVE_TAG, "Failed to create mapnik");
        */
		if (offlineMap){
			mapRenderer.setRasterLayerProvider(RasterMapLayerId.BaseLayer, binaryMapRasterBitmapTileProvider);
		} else {
			mapRenderer.setRasterLayerProvider(RasterMapLayerId.BaseLayer, onlineMapRasterBitmapTileProvider);
		}

		//TODO:_glSurfaceView.setPreserveEGLContextOnPause(true);
		glSurfaceView.setEGLContextClientVersion(2);
		glSurfaceView.setEGLContextFactory(new EGLContextFactory());
		glSurfaceView.setRenderer(new NativeRenderer(mapRenderer));
		glSurfaceView.setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY);
	}

	protected void updateView() {
		mapRenderer.setAzimuth(0.0f);
		mapRenderer.setElevationAngle(90);
		mapRenderer.setTarget(new PointI(currentViewport.getCenter31X(), currentViewport.getCenter31Y()));
		mapRenderer.setZoom((float)currentViewport.getZoom() + (float)currentViewport.getZoomScale());
	}

	private class EGLContextFactory implements GLSurfaceView.EGLContextFactory {
		private EGLContext _gpuWorkerContext;
		private EGLSurface _gpuWorkerFakeSurface;

		public EGLContext createContext(EGL10 egl, EGLDisplay display, EGLConfig eglConfig) {
			final String eglExtensions = egl.eglQueryString(display, EGL10.EGL_EXTENSIONS);
			Log.i(NATIVE_TAG, "EGL extensions: " + eglExtensions);
			final String eglVersion = egl.eglQueryString(display, EGL10.EGL_VERSION);
			Log.i(NATIVE_TAG, "EGL version: " + eglVersion);

			Log.i(NATIVE_TAG, "Creating main context...");
			final int[] contextAttribList = {
					EGL14.EGL_CONTEXT_CLIENT_VERSION, 2,
					EGL10.EGL_NONE };

			EGLContext mainContext = null;
			try {
				mainContext = egl.eglCreateContext(display, eglConfig, EGL10.EGL_NO_CONTEXT, contextAttribList);
			} catch (Exception e) {
				Log.e(NATIVE_TAG, "Failed to create main context", e);
			}
			if (mainContext == null || mainContext == EGL10.EGL_NO_CONTEXT) {
				Log.e(NATIVE_TAG, "Failed to create main context: " + egl.eglGetError());
				mainContext = null;
				System.exit(0);
			}

			Log.i(NATIVE_TAG, "Creating GPU worker context...");
			try {
				_gpuWorkerContext = egl.eglCreateContext(
						display,
						eglConfig,
						mainContext,
						contextAttribList);
			} catch (Exception e) {
				Log.e(NATIVE_TAG, "Failed to create GPU worker context", e);
			}
			if (_gpuWorkerContext == null || _gpuWorkerContext == EGL10.EGL_NO_CONTEXT)
			{
				Log.e(NATIVE_TAG, "Failed to create GPU worker context: " + egl.eglGetError());
				_gpuWorkerContext = null;
			}

			if (_gpuWorkerContext != null)
			{
				Log.i(NATIVE_TAG, "Creating GPU worker fake surface...");
				try {
					final int[] surfaceAttribList = {
							EGL10.EGL_WIDTH, 1,
							EGL10.EGL_HEIGHT, 1,
							EGL10.EGL_NONE };
					_gpuWorkerFakeSurface = egl.eglCreatePbufferSurface(display, eglConfig, surfaceAttribList);
				} catch (Exception e) {
					Log.e(NATIVE_TAG, "Failed to create GPU worker fake surface", e);
				}
				if (_gpuWorkerFakeSurface == null || _gpuWorkerFakeSurface == EGL10.EGL_NO_SURFACE)
				{
					Log.e(NATIVE_TAG, "Failed to create GPU worker fake surface: " + egl.eglGetError());
					_gpuWorkerFakeSurface = null;
				}
			}

			MapRendererSetupOptions rendererSetupOptions = new MapRendererSetupOptions();
			if (_gpuWorkerContext != null && _gpuWorkerFakeSurface != null) {
				rendererSetupOptions.setGpuWorkerThreadEnabled(true);
				gpuWorkerThreadPrologue = new GpuWorkerThreadPrologue(egl, display, _gpuWorkerContext, _gpuWorkerFakeSurface);
				rendererSetupOptions.setGpuWorkerThreadPrologue(gpuWorkerThreadPrologue.getBinding());
				gpuWorkerThreadEpilogue = new GpuWorkerThreadEpilogue(egl);
				rendererSetupOptions.setGpuWorkerThreadEpilogue(gpuWorkerThreadEpilogue.getBinding());
			} else {
				rendererSetupOptions.setGpuWorkerThreadEnabled(false);
			}
			renderRequestCallback = new RenderRequestCallback();
			rendererSetupOptions.setFrameUpdateRequestCallback(renderRequestCallback.getBinding());
			mapRenderer.setup(rendererSetupOptions);

			return mainContext;
		}

		public void destroyContext(EGL10 egl, EGLDisplay display, EGLContext context) {
			egl.eglDestroyContext(display, context);

			if (_gpuWorkerContext != null) {
				egl.eglDestroyContext(display, _gpuWorkerContext);
				_gpuWorkerContext = null;
			}

			if (_gpuWorkerFakeSurface != null) {
				egl.eglDestroySurface(display, _gpuWorkerFakeSurface);
				_gpuWorkerFakeSurface = null;
			}
		}
	}

	private class GpuWorkerThreadEpilogue extends MapRendererSetupOptions.IGpuWorkerThreadEpilogue {
		public GpuWorkerThreadEpilogue(EGL10 egl) {
			_egl = egl;
		}

		private final EGL10 _egl;

		@Override
		public void method(IMapRenderer mapRenderer) {
			try {
				if (!_egl.eglWaitGL())
					Log.e(NATIVE_TAG, "Failed to wait for GPU worker context: " + _egl.eglGetError());
			} catch (Exception e) {
				Log.e(NATIVE_TAG, "Failed to wait for GPU worker context", e);
			}
		}
	}

	private class GpuWorkerThreadPrologue extends MapRendererSetupOptions.IGpuWorkerThreadPrologue {
		public GpuWorkerThreadPrologue(EGL10 egl, EGLDisplay eglDisplay, EGLContext context, EGLSurface surface) {
			_egl = egl;
			_eglDisplay = eglDisplay;
			_context = context;
			_eglSurface = surface;
		}

		private final EGL10 _egl;
		private final EGLDisplay _eglDisplay;
		private final EGLContext _context;
		private final EGLSurface _eglSurface;

		@Override
		public void method(IMapRenderer mapRenderer) {
			try {
				if (!_egl.eglMakeCurrent(_eglDisplay, _eglSurface, _eglSurface, _context))
					Log.e(NATIVE_TAG, "Failed to set GPU worker context active: " + _egl.eglGetError());
			} catch (Exception e) {
				Log.e(NATIVE_TAG, "Failed to set GPU worker context active", e);
			}
		}
	}

	private class RenderRequestCallback extends MapRendererSetupOptions.IFrameUpdateRequestCallback {
		@Override
		public void method(IMapRenderer mapRenderer) {
			glSurfaceView.requestRender();
		}
	}

	@Override
	public void setTrackBallDelegate(OnTrackBallListener trackBallDelegate) {
		super.setTrackBallDelegate(trackBallDelegate);
	}

	@Override
	public void setAccessibilityActions(MapAccessibilityActions accessibilityActions) {
		super.setAccessibilityActions(accessibilityActions);
	}

	@Override
	public void refreshMap(boolean b) {
		updateView();
	}

	@Override
	public void createLayers(MapActivityLayers mapLayers) {
		mapLayers.createLayers(glSurfaceView);
	}

	@Override
	public void setLatLon(double latitude, double longitude) {
		super.setLatLon(latitude, longitude);
	}

	@Override
	public void setIntZoom(int i) {
		super.setIntZoom(i);
	}

	@Override
	public void addView(FrameLayout view) {
		super.addView(view);
	}

	@Override
	public void setTrackingUtilities(MapViewTrackingUtilities mapViewTrackingUtilities) {
		super.setTrackingUtilities(mapViewTrackingUtilities);
	}

	@Override
	public void tileDownloaded(MapTileDownloader.DownloadRequest request) {
		super.tileDownloaded(request);
	}

	@Override
	public ViewParent getParentView() {
		return glSurfaceView.getParent();
	}

	@Override
	public List<OsmandMapLayer> getLayers() {
		return super.getLayers();
	}

	@Override
	public double getLatitude() {
		return super.getLatitude();
	}

	@Override
	public double getLongitude() {
		return super.getLongitude();
	}

	@Override
	public void startMoving(double latitude, double longitude, int mapZoomToShow, boolean b) {
		super.startMoving(latitude, longitude, mapZoomToShow, b);
	}

	@Override
	public int getZoom() {
		return super.getZoom();
	}

	@Override
	public void startZooming(int newZoom, boolean changeLocation) {
		super.startZooming(newZoom, changeLocation);
	}

	@Override
	public boolean isZooming() {
		return super.isZooming();
	}

	@Override
	public RotatedTileBox getCurrentRotatedTileBox() {
		return super.getCurrentRotatedTileBox();
	}

	@Override
	public void onPause() {
		super.onPause();
	}

	@Override
	public void updateLayers(MapActivityLayers mapLayers) {
		super.updateLayers(mapLayers);
	}

	@Override
	public void setComplexZoom() {
		super.setComplexZoom();
	}

	@Override
	public void showAndHideMapPosition() {
		super.showAndHideMapPosition();
	}

	@Override
	public OsmandMapTileView getMapTileView() {
		return super.getMapTileView();
	}

	@Override
	public boolean onTouchEvent(MotionEvent event) {
		if (twoFingerTapDetector.onTouchEvent(event)) {
			return true;
		}
		return gestureDetector.onTouchEvent(event);
	}

	@Override
	public void resume() {
		glSurfaceView.onResume();
	}

	@Override
	public void destroy() {
		if (mapStylesCollection != null) {
			mapStylesCollection.delete();
			mapStylesCollection = null;
		}

		if (mapStyle != null) {
			mapStyle.delete();
			mapStyle = null;
		}

		if (obfsCollection != null) {
			obfsCollection.delete();
			obfsCollection = null;
		}

		if (mapPresentationEnvironment != null) {
			mapPresentationEnvironment.delete();
			mapPresentationEnvironment = null;
		}

		if (primitiviser != null) {
			primitiviser.delete();
			primitiviser = null;
		}

		if (binaryMapDataProvider != null) {
			binaryMapDataProvider.delete();
			binaryMapDataProvider = null;
		}

		if (binaryMapPrimitivesProvider != null) {
			binaryMapPrimitivesProvider.delete();
			binaryMapPrimitivesProvider = null;
		}

		if (binaryMapStaticSymbolsProvider != null) {
			binaryMapStaticSymbolsProvider.delete();
			binaryMapStaticSymbolsProvider = null;
		}

		if (binaryMapRasterBitmapTileProvider != null) {
			binaryMapRasterBitmapTileProvider.delete();
			binaryMapRasterBitmapTileProvider = null;
		}

		if (mapRenderer != null) {
			mapRenderer.delete();
			mapRenderer = null;
		}

		OsmAndCore.ReleaseCore();
	}
}
!@#$%
20190530_013431,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_c13224
package net.osmand.plus.views.controllers;

import android.content.Context;
import android.opengl.EGL14;
import android.opengl.GLSurfaceView;
import android.os.Environment;
import android.util.DisplayMetrics;
import android.util.Log;
import android.view.GestureDetector;
import android.view.MotionEvent;
import android.view.ViewParent;
import android.view.WindowManager;
import android.widget.FrameLayout;
import net.osmand.access.MapAccessibilityActions;
import net.osmand.core.android.CoreResourcesFromAndroidAssets;
import net.osmand.core.jni.*;
import net.osmand.data.LatLon;
import net.osmand.data.QuadPoint;
import net.osmand.data.RotatedTileBox;
import net.osmand.map.MapTileDownloader;
import net.osmand.plus.OsmandSettings;
import net.osmand.plus.activities.MapActivity;
import net.osmand.plus.activities.MapActivityLayers;
import net.osmand.plus.base.MapViewTrackingUtilities;
import net.osmand.plus.helpers.TwoFingerTapDetector;
import net.osmand.plus.render.NativeCppLibrary;
import net.osmand.plus.render.NativeOsmandLibrary;
import net.osmand.plus.views.OsmandMapLayer;
import net.osmand.plus.views.OsmandMapTileView;

import javax.microedition.khronos.egl.*;
import java.io.File;
import java.util.List;

/**
 * Created by Denis on 01.10.2014.
 */
public class NativeViewController extends MapViewBaseController {

	private GLSurfaceView glSurfaceView;
	private OsmandSettings settings;
	private MapActivity mapActivity;
	private float displayDensityFactor;
	private int referenceTileSize;
	private int rasterTileSize;
	private IMapStylesCollection mapStylesCollection;
	private ResolvedMapStyle mapStyle;
	private ObfsCollection obfsCollection;
	private MapPresentationEnvironment mapPresentationEnvironment;
	private Primitiviser primitiviser;
	private BinaryMapDataProvider binaryMapDataProvider;
	private BinaryMapPrimitivesProvider binaryMapPrimitivesProvider;
	private BinaryMapStaticSymbolsProvider binaryMapStaticSymbolsProvider;
	private BinaryMapRasterBitmapTileProvider binaryMapRasterBitmapTileProvider;
	private OnlineRasterMapTileProvider onlineMapRasterBitmapTileProvider;
	private IMapRenderer mapRenderer;
	private GpuWorkerThreadPrologue gpuWorkerThreadPrologue;
	private GpuWorkerThreadEpilogue gpuWorkerThreadEpilogue;
	private RenderRequestCallback renderRequestCallback;
	private QIODeviceLogSink fileLogSink;
	private RotatedTileBox currentViewport = null;

	private boolean offlineMap = true;

	private GestureDetector gestureDetector;

	public static final String NATIVE_TAG = "NativeRender";
	private CoreResourcesFromAndroidAssets coreResources;

	TwoFingerTapDetector twoFingerTapDetector = new TwoFingerTapDetector() {
		@Override
		public void onTwoFingerTap() {
			currentViewport.setZoom(currentViewport.getZoom() - 1);
			updateView();
		}
	};


	public NativeViewController(GLSurfaceView surfaceView, MapActivity activity) {
		this.glSurfaceView = surfaceView;
		this.settings = activity.getMyApplication().getSettings();
		this.mapActivity = activity;
		loadLibraries();
		setupView();
	}

	private void loadLibraries() {
		NativeCppLibrary.loadLibrary("gnustl_shared");
		NativeCppLibrary.loadLibrary("Qt5Core");
		NativeCppLibrary.loadLibrary("Qt5Network");
		NativeCppLibrary.loadLibrary("Qt5Sql");
		NativeCppLibrary.loadLibrary("OsmAndCoreWithJNI");
	}

	private void setupView() {
		WindowManager mgr = (WindowManager)mapActivity.getSystemService(Context.WINDOW_SERVICE);
		DisplayMetrics dm = new DisplayMetrics();
		mgr.getDefaultDisplay().getMetrics(dm);
		currentViewport = new RotatedTileBox.RotatedTileBoxBuilder().
				setLocation(settings.getLastKnownMapLocation().getLatitude(),
						settings.getLastKnownMapLocation().getLongitude()).setZoomAndScale(settings.getLastKnownMapZoom(), 0).
				setPixelDimensions(dm.widthPixels, dm.heightPixels).build();
		currentViewport.setDensity(dm.density);



		gestureDetector = new GestureDetector(mapActivity, new GestureDetector.OnGestureListener() {

			@Override
			public boolean onSingleTapUp(MotionEvent e) {
				return false;
			}

			@Override
			public void onShowPress(MotionEvent e) {
			}

			@Override
			public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {
				final QuadPoint cp = currentViewport.getCenterPixelPoint();
				final LatLon latlon = currentViewport.getLatLonFromPixel(cp.x + distanceX, cp.y + distanceY);
				currentViewport.setLatLonCenter(latlon.getLatitude(), latlon.getLongitude());
				updateView();
				return false;
			}

			@Override
			public void onLongPress(MotionEvent e) {
			}

			@Override
			public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
				return false;
			}

			@Override
			public boolean onDown(MotionEvent e) {
				return false;
			}
		});
		gestureDetector.setOnDoubleTapListener(new GestureDetector.OnDoubleTapListener() {
			@Override
			public boolean onSingleTapConfirmed(MotionEvent e) {
				return false;
			}

			@Override
			public boolean onDoubleTapEvent(MotionEvent e) {
				return false;
			}

			@Override
			public boolean onDoubleTap(MotionEvent e) {
				currentViewport.setZoom(currentViewport.getZoom() + 1);
				updateView();
				return true;
			}
		});

		// Get device display density factor
		DisplayMetrics displayMetrics = new DisplayMetrics();
		mapActivity.getWindowManager().getDefaultDisplay().getMetrics(displayMetrics);
		displayDensityFactor = displayMetrics.densityDpi / 160.0f;
		referenceTileSize = (int)(256 * displayDensityFactor);
		rasterTileSize = Integer.highestOneBit(referenceTileSize - 1) * 2;
		Log.i(NATIVE_TAG, "displayDensityFactor = " + displayDensityFactor);
		Log.i(NATIVE_TAG, "referenceTileSize = " + referenceTileSize);
		Log.i(NATIVE_TAG, "rasterTileSize = " + rasterTileSize);

		Log.i(NATIVE_TAG, "Initializing core...");
		coreResources = CoreResourcesFromAndroidAssets.loadFromCurrentApplication(mapActivity.getMyApplication());
		OsmAndCore.InitializeCore(coreResources);

		File directory =mapActivity.getMyApplication().getAppPath("");
		fileLogSink = QIODeviceLogSink.createFileLogSink(directory.getAbsolutePath() + "osmandcore.log");
		Logger.get().addLogSink(fileLogSink);

		Log.i(NATIVE_TAG, "Going to resolve default embedded style...");
		mapStylesCollection = new MapStylesCollection();
		mapStyle = mapStylesCollection.getResolvedStyleByName("default");
		if (mapStyle == null)
		{
			Log.e(NATIVE_TAG, "Failed to resolve style 'default'");
			System.exit(0);
		}

		Log.i(NATIVE_TAG, "Going to prepare OBFs collection");
		obfsCollection = new ObfsCollection();

		Log.i(NATIVE_TAG, "Will load OBFs from " + Environment.getExternalStorageDirectory() + "/osmand");

		Log.i(NATIVE_TAG, "Will load OBFs from " + directory.getAbsolutePath());
		obfsCollection.addDirectory(directory.getAbsolutePath(), false);

		Log.i(NATIVE_TAG, "Going to prepare all resources for renderer");
		mapPresentationEnvironment = new MapPresentationEnvironment(
				mapStyle,
				displayDensityFactor,
				"en"); //TODO: here should be current locale
		//mapPresentationEnvironment->setSettings(configuration.styleSettings);
		primitiviser = new Primitiviser(
				mapPresentationEnvironment);
		binaryMapDataProvider = new BinaryMapDataProvider(
				obfsCollection);
		binaryMapPrimitivesProvider = new BinaryMapPrimitivesProvider(
				binaryMapDataProvider,
				primitiviser,
				rasterTileSize);
		binaryMapStaticSymbolsProvider = new BinaryMapStaticSymbolsProvider(
				binaryMapPrimitivesProvider,
				rasterTileSize);
		binaryMapRasterBitmapTileProvider = new BinaryMapRasterBitmapTileProvider_Software(
				binaryMapPrimitivesProvider);

		onlineMapRasterBitmapTileProvider = OnlineTileSources.getBuiltIn().createProviderFor("Mapnik (OsmAnd)");

		Log.i(NATIVE_TAG, "Going to create renderer");
		mapRenderer = OsmAndCore.createMapRenderer(MapRendererClass.AtlasMapRenderer_OpenGLES2);
		if (mapRenderer == null)
		{
			Log.e(NATIVE_TAG, "Failed to create map renderer 'AtlasMapRenderer_OpenGLES2'");
			System.exit(0);
		}

		AtlasMapRendererConfiguration atlasRendererConfiguration = AtlasMapRendererConfiguration.Casts.upcastFrom(mapRenderer.getConfiguration());
		atlasRendererConfiguration.setReferenceTileSizeOnScreenInPixels(referenceTileSize);
		mapRenderer.setConfiguration(AtlasMapRendererConfiguration.Casts.downcastTo_MapRendererConfiguration(atlasRendererConfiguration));

		mapRenderer.addSymbolProvider(binaryMapStaticSymbolsProvider);
		updateView();
        /*
        IMapRasterBitmapTileProvider mapnik = OnlineTileSources.getBuiltIn().createProviderFor("Mapnik (OsmAnd)");
        if (mapnik == null)
            Log.e(NATIVE_TAG, "Failed to create mapnik");
        */
		if (offlineMap){
			mapRenderer.setRasterLayerProvider(RasterMapLayerId.BaseLayer, binaryMapRasterBitmapTileProvider);
		} else {
			mapRenderer.setRasterLayerProvider(RasterMapLayerId.BaseLayer, onlineMapRasterBitmapTileProvider);
		}

		//TODO:_glSurfaceView.setPreserveEGLContextOnPause(true);
		glSurfaceView.setEGLContextClientVersion(2);
		glSurfaceView.setEGLContextFactory(new EGLContextFactory());
		glSurfaceView.setRenderer(new NativeRenderer(mapRenderer));
		glSurfaceView.setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY);
	}

	protected void updateView() {
		mapRenderer.setAzimuth(0.0f);
		mapRenderer.setElevationAngle(90);
		mapRenderer.setTarget(new PointI(currentViewport.getCenter31X(), currentViewport.getCenter31Y()));
		mapRenderer.setZoom((float)currentViewport.getZoom() + (float)currentViewport.getZoomScale());
	}

	private class EGLContextFactory implements GLSurfaceView.EGLContextFactory {
		private EGLContext gpuWorkerContext;
		private EGLSurface gpuWorkerFakeSurface;

		public EGLContext createContext(EGL10 egl, EGLDisplay display, EGLConfig eglConfig) {
			final String eglExtensions = egl.eglQueryString(display, EGL10.EGL_EXTENSIONS);
			Log.i(NATIVE_TAG, "EGL extensions: " + eglExtensions);
			final String eglVersion = egl.eglQueryString(display, EGL10.EGL_VERSION);
			Log.i(NATIVE_TAG, "EGL version: " + eglVersion);

			Log.i(NATIVE_TAG, "Creating main context...");
			final int[] contextAttribList = {
					EGL14.EGL_CONTEXT_CLIENT_VERSION, 2,
					EGL10.EGL_NONE };

			EGLContext mainContext = null;
			try {
				mainContext = egl.eglCreateContext(display, eglConfig, EGL10.EGL_NO_CONTEXT, contextAttribList);
			} catch (Exception e) {
				Log.e(NATIVE_TAG, "Failed to create main context", e);
			}
			if (mainContext == null || mainContext == EGL10.EGL_NO_CONTEXT) {
				Log.e(NATIVE_TAG, "Failed to create main context: " + egl.eglGetError());
				mainContext = null;
				System.exit(0);
			}

			Log.i(NATIVE_TAG, "Creating GPU worker context...");
			try {
				gpuWorkerContext = egl.eglCreateContext(
						display,
						eglConfig,
						mainContext,
						contextAttribList);
			} catch (Exception e) {
				Log.e(NATIVE_TAG, "Failed to create GPU worker context", e);
			}
			if (gpuWorkerContext == null || gpuWorkerContext == EGL10.EGL_NO_CONTEXT)
			{
				Log.e(NATIVE_TAG, "Failed to create GPU worker context: " + egl.eglGetError());
				gpuWorkerContext = null;
			}

			if (gpuWorkerContext != null)
			{
				Log.i(NATIVE_TAG, "Creating GPU worker fake surface...");
				try {
					final int[] surfaceAttribList = {
							EGL10.EGL_WIDTH, 1,
							EGL10.EGL_HEIGHT, 1,
							EGL10.EGL_NONE };
					gpuWorkerFakeSurface = egl.eglCreatePbufferSurface(display, eglConfig, surfaceAttribList);
				} catch (Exception e) {
					Log.e(NATIVE_TAG, "Failed to create GPU worker fake surface", e);
				}
				if (gpuWorkerFakeSurface == null || gpuWorkerFakeSurface == EGL10.EGL_NO_SURFACE)
				{
					Log.e(NATIVE_TAG, "Failed to create GPU worker fake surface: " + egl.eglGetError());
					gpuWorkerFakeSurface = null;
				}
			}

			MapRendererSetupOptions rendererSetupOptions = new MapRendererSetupOptions();
			if (gpuWorkerContext != null && gpuWorkerFakeSurface != null) {
				rendererSetupOptions.setGpuWorkerThreadEnabled(true);
				gpuWorkerThreadPrologue = new GpuWorkerThreadPrologue(egl, display, gpuWorkerContext, gpuWorkerFakeSurface);
				rendererSetupOptions.setGpuWorkerThreadPrologue(gpuWorkerThreadPrologue.getBinding());
				gpuWorkerThreadEpilogue = new GpuWorkerThreadEpilogue(egl);
				rendererSetupOptions.setGpuWorkerThreadEpilogue(gpuWorkerThreadEpilogue.getBinding());
			} else {
				rendererSetupOptions.setGpuWorkerThreadEnabled(false);
			}
			renderRequestCallback = new RenderRequestCallback();
			rendererSetupOptions.setFrameUpdateRequestCallback(renderRequestCallback.getBinding());
			mapRenderer.setup(rendererSetupOptions);

			return mainContext;
		}

		public void destroyContext(EGL10 egl, EGLDisplay display, EGLContext context) {
			egl.eglDestroyContext(display, context);

			if (gpuWorkerContext != null) {
				egl.eglDestroyContext(display, gpuWorkerContext);
				gpuWorkerContext = null;
			}

			if (gpuWorkerFakeSurface != null) {
				egl.eglDestroySurface(display, gpuWorkerFakeSurface);
				gpuWorkerFakeSurface = null;
			}
		}
	}

	private class GpuWorkerThreadEpilogue extends MapRendererSetupOptions.IGpuWorkerThreadEpilogue {
		public GpuWorkerThreadEpilogue(EGL10 egl) {
			_egl = egl;
		}

		private final EGL10 _egl;

		@Override
		public void method(IMapRenderer mapRenderer) {
			try {
				if (!_egl.eglWaitGL())
					Log.e(NATIVE_TAG, "Failed to wait for GPU worker context: " + _egl.eglGetError());
			} catch (Exception e) {
				Log.e(NATIVE_TAG, "Failed to wait for GPU worker context", e);
			}
		}
	}

	private class GpuWorkerThreadPrologue extends MapRendererSetupOptions.IGpuWorkerThreadPrologue {
		public GpuWorkerThreadPrologue(EGL10 egl, EGLDisplay eglDisplay, EGLContext context, EGLSurface surface) {
			_egl = egl;
			_eglDisplay = eglDisplay;
			_context = context;
			_eglSurface = surface;
		}

		private final EGL10 _egl;
		private final EGLDisplay _eglDisplay;
		private final EGLContext _context;
		private final EGLSurface _eglSurface;

		@Override
		public void method(IMapRenderer mapRenderer) {
			try {
				if (!_egl.eglMakeCurrent(_eglDisplay, _eglSurface, _eglSurface, _context))
					Log.e(NATIVE_TAG, "Failed to set GPU worker context active: " + _egl.eglGetError());
			} catch (Exception e) {
				Log.e(NATIVE_TAG, "Failed to set GPU worker context active", e);
			}
		}
	}

	private class RenderRequestCallback extends MapRendererSetupOptions.IFrameUpdateRequestCallback {
		@Override
		public void method(IMapRenderer mapRenderer) {
			glSurfaceView.requestRender();
		}
	}

	@Override
	public void setTrackBallDelegate(OnTrackBallListener trackBallDelegate) {
		super.setTrackBallDelegate(trackBallDelegate);
	}

	@Override
	public void setAccessibilityActions(MapAccessibilityActions accessibilityActions) {
		super.setAccessibilityActions(accessibilityActions);
	}

	@Override
	public void refreshMap(boolean b) {
		updateView();
	}

	@Override
	public void createLayers(MapActivityLayers mapLayers) {
		mapLayers.createLayers(glSurfaceView);
	}

	@Override
	public void setLatLon(double latitude, double longitude) {
		super.setLatLon(latitude, longitude);
	}

	@Override
	public void setIntZoom(int i) {
		super.setIntZoom(i);
	}

	@Override
	public void addView(FrameLayout view) {
		super.addView(view);
	}

	@Override
	public void setTrackingUtilities(MapViewTrackingUtilities mapViewTrackingUtilities) {
		super.setTrackingUtilities(mapViewTrackingUtilities);
	}

	@Override
	public void tileDownloaded(MapTileDownloader.DownloadRequest request) {
		super.tileDownloaded(request);
	}

	@Override
	public ViewParent getParentView() {
		return glSurfaceView.getParent();
	}

	@Override
	public List<OsmandMapLayer> getLayers() {
		return super.getLayers();
	}

	@Override
	public double getLatitude() {
		return super.getLatitude();
	}

	@Override
	public double getLongitude() {
		return super.getLongitude();
	}

	@Override
	public void startMoving(double latitude, double longitude, int mapZoomToShow, boolean b) {
		super.startMoving(latitude, longitude, mapZoomToShow, b);
	}

	@Override
	public int getZoom() {
		return super.getZoom();
	}

	@Override
	public void startZooming(int newZoom, boolean changeLocation) {
		super.startZooming(newZoom, changeLocation);
	}

	@Override
	public boolean isZooming() {
		return super.isZooming();
	}

	@Override
	public RotatedTileBox getCurrentRotatedTileBox() {
		return super.getCurrentRotatedTileBox();
	}

	@Override
	public void onPause() {
		super.onPause();
	}

	@Override
	public void updateLayers(MapActivityLayers mapLayers) {
		super.updateLayers(mapLayers);
	}

	@Override
	public void setComplexZoom() {
		super.setComplexZoom();
	}

	@Override
	public void showAndHideMapPosition() {
		super.showAndHideMapPosition();
	}

	@Override
	public OsmandMapTileView getMapTileView() {
		return super.getMapTileView();
	}

	@Override
	public boolean onTouchEvent(MotionEvent event) {
		if (twoFingerTapDetector.onTouchEvent(event)) {
			return true;
		}
		return gestureDetector.onTouchEvent(event);
	}

	@Override
	public void resume() {
		glSurfaceView.onResume();
	}

	@Override
	public void destroy() {
		if (mapStylesCollection != null) {
			mapStylesCollection.delete();
			mapStylesCollection = null;
		}

		if (mapStyle != null) {
			mapStyle.delete();
			mapStyle = null;
		}

		if (obfsCollection != null) {
			obfsCollection.delete();
			obfsCollection = null;
		}

		if (mapPresentationEnvironment != null) {
			mapPresentationEnvironment.delete();
			mapPresentationEnvironment = null;
		}

		if (primitiviser != null) {
			primitiviser.delete();
			primitiviser = null;
		}

		if (binaryMapDataProvider != null) {
			binaryMapDataProvider.delete();
			binaryMapDataProvider = null;
		}

		if (binaryMapPrimitivesProvider != null) {
			binaryMapPrimitivesProvider.delete();
			binaryMapPrimitivesProvider = null;
		}

		if (binaryMapStaticSymbolsProvider != null) {
			binaryMapStaticSymbolsProvider.delete();
			binaryMapStaticSymbolsProvider = null;
		}

		if (binaryMapRasterBitmapTileProvider != null) {
			binaryMapRasterBitmapTileProvider.delete();
			binaryMapRasterBitmapTileProvider = null;
		}

		if (mapRenderer != null) {
			mapRenderer.delete();
			mapRenderer = null;
		}

		OsmAndCore.ReleaseCore();
	}
}
!@#$%
20190530_013437,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_b13224
package net.osmand.core.android;

import javax.microedition.khronos.egl.EGL10;
import javax.microedition.khronos.egl.EGLConfig;
import javax.microedition.khronos.egl.EGLContext;
import javax.microedition.khronos.egl.EGLDisplay;
import javax.microedition.khronos.egl.EGLSurface;
import javax.microedition.khronos.opengles.GL10;

import net.osmand.core.jni.*;
import net.osmand.data.LatLon;
import net.osmand.data.QuadPoint;
import net.osmand.data.RotatedTileBox;
import net.osmand.plus.OsmandApplication;
import net.osmand.plus.OsmandSettings;
import net.osmand.plus.R;
import net.osmand.plus.helpers.SimpleTwoFingerTapDetector;
import net.osmand.plus.render.NativeOsmandLibrary;
import android.app.Activity;
import android.content.Context;
import android.opengl.EGL14;
import android.opengl.GLSurfaceView;
import android.os.Bundle;
import android.os.Environment;
import android.util.DisplayMetrics;
import android.util.Log;
import android.view.GestureDetector;
import android.view.GestureDetector.OnDoubleTapListener;
import android.view.Menu;
import android.view.MenuItem;
import android.view.MotionEvent;
import android.view.Window;
import android.view.WindowManager;

import java.io.File;

public class GLActivity extends Activity {

	static {
		NativeOsmandLibrary.loadLibrary("gnustl_shared");
		NativeOsmandLibrary.loadLibrary("Qt5Core");
		NativeOsmandLibrary.loadLibrary("Qt5Network");
		NativeOsmandLibrary.loadLibrary("Qt5Sql");
		NativeOsmandLibrary.loadLibrary("OsmAndCoreWithJNI");
	}
    private static final String TAG = "OsmAndCoreSample";

    private CoreResourcesFromAndroidAssetsCustom _coreResources;

    private float _displayDensityFactor;
    private int _referenceTileSize;
    private int _rasterTileSize;
    private IMapStylesCollection _mapStylesCollection;
    private ResolvedMapStyle _mapStyle;
    private ObfsCollection _obfsCollection;
    private MapPresentationEnvironment _mapPresentationEnvironment;
    private Primitiviser _primitiviser;
    private BinaryMapDataProvider _binaryMapDataProvider;
    private BinaryMapPrimitivesProvider _binaryMapPrimitivesProvider;
    private BinaryMapStaticSymbolsProvider _binaryMapStaticSymbolsProvider;
    private BinaryMapRasterBitmapTileProvider _binaryMapRasterBitmapTileProvider;
	private OnlineRasterMapTileProvider _onlineMapRasterBitmapTileProvider;
    private IMapRenderer _mapRenderer;
    private GpuWorkerThreadPrologue _gpuWorkerThreadPrologue;
    private GpuWorkerThreadEpilogue _gpuWorkerThreadEpilogue;
    private RenderRequestCallback _renderRequestCallback;
    private QIODeviceLogSink _fileLogSink;
    private RotatedTileBox currentViewport = null;
    
	private GestureDetector gestureDetector;

    
    protected OsmandApplication getApp() {
    	return (OsmandApplication) getApplication();
    }
    
    private boolean afterTwoFingerTap = false;
	SimpleTwoFingerTapDetector twoFingerTapDetector = new SimpleTwoFingerTapDetector() {
		@Override
		public void onTwoFingerTap() {
			afterTwoFingerTap = true;
			currentViewport.setZoom(currentViewport.getZoom() - 1);
			updateView();
		}
	};

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        requestWindowFeature(Window.FEATURE_NO_TITLE);
        OsmandSettings st = getApp().getSettings();
        WindowManager mgr = (WindowManager) getSystemService(Context.WINDOW_SERVICE);
		DisplayMetrics dm = new DisplayMetrics();
		mgr.getDefaultDisplay().getMetrics(dm);
		currentViewport = new RotatedTileBox.RotatedTileBoxBuilder().
				setLocation(st.getLastKnownMapLocation().getLatitude(), 
						st.getLastKnownMapLocation().getLongitude()).setZoomAndScale(st.getLastKnownMapZoom(), 0).
						setPixelDimensions(dm.widthPixels, dm.heightPixels).build();
		currentViewport.setDensity(dm.density);
		
		
		
		gestureDetector = new GestureDetector(this, new android.view.GestureDetector.OnGestureListener() {
			
			@Override
			public boolean onSingleTapUp(MotionEvent e) {
				return false;
			}
			
			@Override
			public void onShowPress(MotionEvent e) {
			}
			
			@Override
			public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {
				final QuadPoint cp = currentViewport.getCenterPixelPoint();
				final LatLon latlon = currentViewport.getLatLonFromPixel(cp.x + distanceX, cp.y + distanceY);
				currentViewport.setLatLonCenter(latlon.getLatitude(), latlon.getLongitude());
				updateView();
				return false;
			}
			
			@Override
			public void onLongPress(MotionEvent e) {
			}
			
			@Override
			public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
				return false;
			}
			
			@Override
			public boolean onDown(MotionEvent e) {
				return false;
			}
		});
		gestureDetector.setOnDoubleTapListener(new OnDoubleTapListener() {
			@Override
			public boolean onSingleTapConfirmed(MotionEvent e) {
				return false;
			}
			
			@Override
			public boolean onDoubleTapEvent(MotionEvent e) {
				return false;
			}
			
			@Override
			public boolean onDoubleTap(MotionEvent e) {
				currentViewport.setZoom(currentViewport.getZoom() + 1);
				updateView();
				return true;
			}
		});
        		
        setContentView(R.layout.activity_gl);

        // Get device display density factor
        DisplayMetrics displayMetrics = new DisplayMetrics();
        getWindowManager().getDefaultDisplay().getMetrics(displayMetrics);
        _displayDensityFactor = displayMetrics.densityDpi / 160.0f;
        _referenceTileSize = (int)(256 * _displayDensityFactor);
        _rasterTileSize = Integer.highestOneBit(_referenceTileSize - 1) * 2;
        Log.i(TAG, "displayDensityFactor = " + _displayDensityFactor);
        Log.i(TAG, "referenceTileSize = " + _referenceTileSize);
        Log.i(TAG, "rasterTileSize = " + _rasterTileSize);

        Log.i(TAG, "Initializing core...");
        _coreResources = CoreResourcesFromAndroidAssetsCustom.loadFromCurrentApplication(this);
        OsmAndCore.InitializeCore(_coreResources);

		File directory =getApp().getAppPath("");
        _fileLogSink = QIODeviceLogSink.createFileLogSink(directory.getAbsolutePath() + "osmandcore.log");
        Logger.get().addLogSink(_fileLogSink);

        Log.i(TAG, "Going to resolve default embedded style...");
        _mapStylesCollection = new MapStylesCollection();
        _mapStyle = _mapStylesCollection.getResolvedStyleByName("default");
        if (_mapStyle == null)
        {
            Log.e(TAG, "Failed to resolve style 'default'");
            System.exit(0);
        }

        Log.i(TAG, "Going to prepare OBFs collection");
        _obfsCollection = new ObfsCollection();

		Log.i(TAG, "Will load OBFs from " + Environment.getExternalStorageDirectory() + "/osmand");

		Log.i(TAG, "Will load OBFs from " + directory.getAbsolutePath());
        _obfsCollection.addDirectory(directory.getAbsolutePath(), false);

        Log.i(TAG, "Going to prepare all resources for renderer");
        _mapPresentationEnvironment = new MapPresentationEnvironment(
                _mapStyle,
                _displayDensityFactor,
                "en"); //TODO: here should be current locale
        //mapPresentationEnvironment->setSettings(configuration.styleSettings);
        _primitiviser = new Primitiviser(
                _mapPresentationEnvironment);
        _binaryMapDataProvider = new BinaryMapDataProvider(
                _obfsCollection);
        _binaryMapPrimitivesProvider = new BinaryMapPrimitivesProvider(
                _binaryMapDataProvider,
                _primitiviser,
                _rasterTileSize);
        _binaryMapStaticSymbolsProvider = new BinaryMapStaticSymbolsProvider(
                _binaryMapPrimitivesProvider,
                _rasterTileSize);
        _binaryMapRasterBitmapTileProvider = new BinaryMapRasterBitmapTileProvider_Software(
                _binaryMapPrimitivesProvider);

		_onlineMapRasterBitmapTileProvider = OnlineTileSources.getBuiltIn().createProviderFor("Mapnik (OsmAnd)");

        Log.i(TAG, "Going to create renderer");
        _mapRenderer = OsmAndCore.createMapRenderer(MapRendererClass.AtlasMapRenderer_OpenGLES2);
        if (_mapRenderer == null)
        {
            Log.e(TAG, "Failed to create map renderer 'AtlasMapRenderer_OpenGLES2'");
            System.exit(0);
        }

        AtlasMapRendererConfiguration atlasRendererConfiguration = AtlasMapRendererConfiguration.Casts.upcastFrom(_mapRenderer.getConfiguration());
        atlasRendererConfiguration.setReferenceTileSizeOnScreenInPixels(_referenceTileSize);
        _mapRenderer.setConfiguration(AtlasMapRendererConfiguration.Casts.downcastTo_MapRendererConfiguration(atlasRendererConfiguration));

        _mapRenderer.addSymbolProvider(_binaryMapStaticSymbolsProvider);
        updateView();
        /*
        IMapRasterBitmapTileProvider mapnik = OnlineTileSources.getBuiltIn().createProviderFor("Mapnik (OsmAnd)");
        if (mapnik == null)
            Log.e(TAG, "Failed to create mapnik");
        */
        _mapRenderer.setRasterLayerProvider(RasterMapLayerId.BaseLayer, _binaryMapRasterBitmapTileProvider);

        _glSurfaceView = (GLSurfaceView) findViewById(R.id.glSurfaceView);
        //TODO:_glSurfaceView.setPreserveEGLContextOnPause(true);
        _glSurfaceView.setEGLContextClientVersion(2);
        _glSurfaceView.setEGLContextFactory(new EGLContextFactory());
        _glSurfaceView.setRenderer(new Renderer());
        _glSurfaceView.setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY);
    }

	protected void updateView() {
		_mapRenderer.setAzimuth(0.0f);
		_mapRenderer.setElevationAngle(90);
		_mapRenderer.setTarget(new PointI(currentViewport.getCenter31X(), currentViewport.getCenter31Y()));
		_mapRenderer.setZoom((float)currentViewport.getZoom() + (float)currentViewport.getZoomScale());
	}

	private GLSurfaceView _glSurfaceView;

    @Override
    public boolean onTouchEvent(MotionEvent event) {
    	if (twoFingerTapDetector.onTouchEvent(event)) {
			return true;
		}
    	return gestureDetector.onTouchEvent(event);
    }
    @Override
    protected void onPause() {
        super.onPause();
        _glSurfaceView.onPause();
    }

    @Override
    protected void onResume() {
        super.onResume();
        _glSurfaceView.onResume();
    }

    @Override
    protected void onDestroy() {
        if (_mapStylesCollection != null) {
            _mapStylesCollection.delete();
            _mapStylesCollection = null;
        }

        if (_mapStyle != null) {
            _mapStyle.delete();
            _mapStyle = null;
        }

        if (_obfsCollection != null) {
            _obfsCollection.delete();
            _obfsCollection = null;
        }

        if (_mapPresentationEnvironment != null) {
            _mapPresentationEnvironment.delete();
            _mapPresentationEnvironment = null;
        }

        if (_primitiviser != null) {
            _primitiviser.delete();
            _primitiviser = null;
        }

        if (_binaryMapDataProvider != null) {
            _binaryMapDataProvider.delete();
            _binaryMapDataProvider = null;
        }

        if (_binaryMapPrimitivesProvider != null) {
            _binaryMapPrimitivesProvider.delete();
            _binaryMapPrimitivesProvider = null;
        }

        if (_binaryMapStaticSymbolsProvider != null) {
            _binaryMapStaticSymbolsProvider.delete();
            _binaryMapStaticSymbolsProvider = null;
        }

        if (_binaryMapRasterBitmapTileProvider != null) {
            _binaryMapRasterBitmapTileProvider.delete();
            _binaryMapRasterBitmapTileProvider = null;
        }

        if (_mapRenderer != null) {
            _mapRenderer.delete();
            _mapRenderer = null;
        }

        OsmAndCore.ReleaseCore();

        super.onDestroy();
    }

    private class RenderRequestCallback extends MapRendererSetupOptions.IFrameUpdateRequestCallback {
        @Override
        public void method(IMapRenderer mapRenderer) {
            _glSurfaceView.requestRender();
        }
    }

    public class GpuWorkerThreadPrologue extends MapRendererSetupOptions.IGpuWorkerThreadPrologue {
        public GpuWorkerThreadPrologue(EGL10 egl, EGLDisplay eglDisplay, EGLContext context, EGLSurface surface) {
            _egl = egl;
            _eglDisplay = eglDisplay;
            _context = context;
            _eglSurface = surface;
        }

        private final EGL10 _egl;
        private final EGLDisplay _eglDisplay;
        private final EGLContext _context;
        private final EGLSurface _eglSurface;

        @Override
        public void method(IMapRenderer mapRenderer) {
            try {
                if (!_egl.eglMakeCurrent(_eglDisplay, _eglSurface, _eglSurface, _context))
                    Log.e(TAG, "Failed to set GPU worker context active: " + _egl.eglGetError());
            } catch (Exception e) {
                Log.e(TAG, "Failed to set GPU worker context active", e);
            }
        }
    }

    private class GpuWorkerThreadEpilogue extends MapRendererSetupOptions.IGpuWorkerThreadEpilogue {
        public GpuWorkerThreadEpilogue(EGL10 egl) {
            _egl = egl;
        }

        private final EGL10 _egl;

        @Override
        public void method(IMapRenderer mapRenderer) {
            try {
                if (!_egl.eglWaitGL())
                    Log.e(TAG, "Failed to wait for GPU worker context: " + _egl.eglGetError());
            } catch (Exception e) {
                Log.e(TAG, "Failed to wait for GPU worker context", e);
            }
        }
    }

    private class EGLContextFactory implements GLSurfaceView.EGLContextFactory {
        private EGLContext _gpuWorkerContext;
        private EGLSurface _gpuWorkerFakeSurface;

        public EGLContext createContext(EGL10 egl, EGLDisplay display, EGLConfig eglConfig) {
            final String eglExtensions = egl.eglQueryString(display, EGL10.EGL_EXTENSIONS);
            Log.i(TAG, "EGL extensions: " + eglExtensions);
            final String eglVersion = egl.eglQueryString(display, EGL10.EGL_VERSION);
            Log.i(TAG, "EGL version: " + eglVersion);

            Log.i(TAG, "Creating main context...");
            final int[] contextAttribList = {
                    EGL14.EGL_CONTEXT_CLIENT_VERSION, 2,
                    EGL10.EGL_NONE };

            EGLContext mainContext = null;
            try {
                mainContext = egl.eglCreateContext(display, eglConfig, EGL10.EGL_NO_CONTEXT, contextAttribList);
            } catch (Exception e) {
                Log.e(TAG, "Failed to create main context", e);
            }
            if (mainContext == null || mainContext == EGL10.EGL_NO_CONTEXT) {
                Log.e(TAG, "Failed to create main context: " + egl.eglGetError());
                mainContext = null;
                System.exit(0);
            }

            Log.i(TAG, "Creating GPU worker context...");
            try {
                _gpuWorkerContext = egl.eglCreateContext(
                        display,
                        eglConfig,
                        mainContext,
                        contextAttribList);
            } catch (Exception e) {
                Log.e(TAG, "Failed to create GPU worker context", e);
            }
            if (_gpuWorkerContext == null || _gpuWorkerContext == EGL10.EGL_NO_CONTEXT)
            {
                Log.e(TAG, "Failed to create GPU worker context: " + egl.eglGetError());
                _gpuWorkerContext = null;
            }

            if (_gpuWorkerContext != null)
            {
                Log.i(TAG, "Creating GPU worker fake surface...");
                try {
                    final int[] surfaceAttribList = {
                            EGL10.EGL_WIDTH, 1,
                            EGL10.EGL_HEIGHT, 1,
                            EGL10.EGL_NONE };
                    _gpuWorkerFakeSurface = egl.eglCreatePbufferSurface(display, eglConfig, surfaceAttribList);
                } catch (Exception e) {
                    Log.e(TAG, "Failed to create GPU worker fake surface", e);
                }
                if (_gpuWorkerFakeSurface == null || _gpuWorkerFakeSurface == EGL10.EGL_NO_SURFACE)
                {
                    Log.e(TAG, "Failed to create GPU worker fake surface: " + egl.eglGetError());
                    _gpuWorkerFakeSurface = null;
                }
            }

            MapRendererSetupOptions rendererSetupOptions = new MapRendererSetupOptions();
            if (_gpuWorkerContext != null && _gpuWorkerFakeSurface != null) {
                rendererSetupOptions.setGpuWorkerThreadEnabled(true);
                _gpuWorkerThreadPrologue = new GpuWorkerThreadPrologue(egl, display, _gpuWorkerContext, _gpuWorkerFakeSurface);
                rendererSetupOptions.setGpuWorkerThreadPrologue(_gpuWorkerThreadPrologue.getBinding());
                _gpuWorkerThreadEpilogue = new GpuWorkerThreadEpilogue(egl);
                rendererSetupOptions.setGpuWorkerThreadEpilogue(_gpuWorkerThreadEpilogue.getBinding());
            } else {
                rendererSetupOptions.setGpuWorkerThreadEnabled(false);
            }
            _renderRequestCallback = new RenderRequestCallback();
            rendererSetupOptions.setFrameUpdateRequestCallback(_renderRequestCallback.getBinding());
            _mapRenderer.setup(rendererSetupOptions);

            return mainContext;
        }

        public void destroyContext(EGL10 egl, EGLDisplay display, EGLContext context) {
            egl.eglDestroyContext(display, context);

            if (_gpuWorkerContext != null) {
                egl.eglDestroyContext(display, _gpuWorkerContext);
                _gpuWorkerContext = null;
            }

            if (_gpuWorkerFakeSurface != null) {
                egl.eglDestroySurface(display, _gpuWorkerFakeSurface);
                _gpuWorkerFakeSurface = null;
            }
        }
    }

    private class Renderer implements GLSurfaceView.Renderer {
        public void onSurfaceCreated(GL10 gl, EGLConfig config) {
            Log.i(TAG, "onSurfaceCreated");
            if (_mapRenderer.isRenderingInitialized())
                _mapRenderer.releaseRendering();
        }

        public void onSurfaceChanged(GL10 gl, int width, int height) {
            Log.i(TAG, "onSurfaceChanged");
            _mapRenderer.setViewport(new AreaI(0, 0, height, width));
            _mapRenderer.setWindowSize(new PointI(width, height));

            if (!_mapRenderer.isRenderingInitialized())
            {
                if (!_mapRenderer.initializeRendering())
                    Log.e(TAG, "Failed to initialize rendering");
            }
        }

        public void onDrawFrame(GL10 gl) {
            _mapRenderer.update();

            if (_mapRenderer.prepareFrame())
                _mapRenderer.renderFrame();
        }
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        return super.onOptionsItemSelected(item);
    }
}
!@#$%
20190530_013437,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_a13224
package net.osmand.core.android;

import javax.microedition.khronos.egl.EGL10;
import javax.microedition.khronos.egl.EGLConfig;
import javax.microedition.khronos.egl.EGLContext;
import javax.microedition.khronos.egl.EGLDisplay;
import javax.microedition.khronos.egl.EGLSurface;
import javax.microedition.khronos.opengles.GL10;

import net.osmand.core.jni.*;
import net.osmand.data.LatLon;
import net.osmand.data.QuadPoint;
import net.osmand.data.RotatedTileBox;
import net.osmand.plus.OsmandApplication;
import net.osmand.plus.OsmandSettings;
import net.osmand.plus.R;
import net.osmand.plus.helpers.SimpleTwoFingerTapDetector;
import net.osmand.plus.render.NativeOsmandLibrary;
import android.app.Activity;
import android.content.Context;
import android.opengl.EGL14;
import android.opengl.GLSurfaceView;
import android.os.Bundle;
import android.os.Environment;
import android.util.DisplayMetrics;
import android.util.Log;
import android.view.GestureDetector;
import android.view.GestureDetector.OnDoubleTapListener;
import android.view.Menu;
import android.view.MenuItem;
import android.view.MotionEvent;
import android.view.Window;
import android.view.WindowManager;

import java.io.File;

public class GLActivity extends Activity {

	static {
		NativeOsmandLibrary.loadLibrary("gnustl_shared");
		NativeOsmandLibrary.loadLibrary("Qt5Core");
		NativeOsmandLibrary.loadLibrary("Qt5Network");
		NativeOsmandLibrary.loadLibrary("Qt5Sql");
		NativeOsmandLibrary.loadLibrary("OsmAndCoreWithJNI");
	}
    private static final String TAG = "OsmAndCoreSample";

    private CoreResourcesFromAndroidAssets _coreResources;

    private float _displayDensityFactor;
    private int _referenceTileSize;
    private int _rasterTileSize;
    private IMapStylesCollection _mapStylesCollection;
    private ResolvedMapStyle _mapStyle;
    private ObfsCollection _obfsCollection;
    private MapPresentationEnvironment _mapPresentationEnvironment;
    private Primitiviser _primitiviser;
    private BinaryMapDataProvider _binaryMapDataProvider;
    private BinaryMapPrimitivesProvider _binaryMapPrimitivesProvider;
    private BinaryMapStaticSymbolsProvider _binaryMapStaticSymbolsProvider;
    private BinaryMapRasterBitmapTileProvider _binaryMapRasterBitmapTileProvider;
	private OnlineRasterMapTileProvider _onlineMapRasterBitmapTileProvider;
    private IMapRenderer _mapRenderer;
    private GpuWorkerThreadPrologue _gpuWorkerThreadPrologue;
    private GpuWorkerThreadEpilogue _gpuWorkerThreadEpilogue;
    private RenderRequestCallback _renderRequestCallback;
    private QIODeviceLogSink _fileLogSink;
    private RotatedTileBox currentViewport = null;
    
	private GestureDetector gestureDetector;

    
    protected OsmandApplication getApp() {
    	return (OsmandApplication) getApplication();
    }
    
    private boolean afterTwoFingerTap = false;
	SimpleTwoFingerTapDetector twoFingerTapDetector = new SimpleTwoFingerTapDetector() {
		@Override
		public void onTwoFingerTap() {
			afterTwoFingerTap = true;
			currentViewport.setZoom(currentViewport.getZoom() - 1);
			updateView();
		}
	};

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        requestWindowFeature(Window.FEATURE_NO_TITLE);
        OsmandSettings st = getApp().getSettings();
        WindowManager mgr = (WindowManager) getSystemService(Context.WINDOW_SERVICE);
		DisplayMetrics dm = new DisplayMetrics();
		mgr.getDefaultDisplay().getMetrics(dm);
		currentViewport = new RotatedTileBox.RotatedTileBoxBuilder().
				setLocation(st.getLastKnownMapLocation().getLatitude(), 
						st.getLastKnownMapLocation().getLongitude()).setZoomAndScale(st.getLastKnownMapZoom(), 0).
						setPixelDimensions(dm.widthPixels, dm.heightPixels).build();
		currentViewport.setDensity(dm.density);
		
		
		
		gestureDetector = new GestureDetector(this, new android.view.GestureDetector.OnGestureListener() {
			
			@Override
			public boolean onSingleTapUp(MotionEvent e) {
				return false;
			}
			
			@Override
			public void onShowPress(MotionEvent e) {
			}
			
			@Override
			public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {
				final QuadPoint cp = currentViewport.getCenterPixelPoint();
				final LatLon latlon = currentViewport.getLatLonFromPixel(cp.x + distanceX, cp.y + distanceY);
				currentViewport.setLatLonCenter(latlon.getLatitude(), latlon.getLongitude());
				updateView();
				return false;
			}
			
			@Override
			public void onLongPress(MotionEvent e) {
			}
			
			@Override
			public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
				return false;
			}
			
			@Override
			public boolean onDown(MotionEvent e) {
				return false;
			}
		});
		gestureDetector.setOnDoubleTapListener(new OnDoubleTapListener() {
			@Override
			public boolean onSingleTapConfirmed(MotionEvent e) {
				return false;
			}
			
			@Override
			public boolean onDoubleTapEvent(MotionEvent e) {
				return false;
			}
			
			@Override
			public boolean onDoubleTap(MotionEvent e) {
				currentViewport.setZoom(currentViewport.getZoom() + 1);
				updateView();
				return true;
			}
		});
        		
        setContentView(R.layout.activity_gl);

        // Get device display density factor
        DisplayMetrics displayMetrics = new DisplayMetrics();
        getWindowManager().getDefaultDisplay().getMetrics(displayMetrics);
        _displayDensityFactor = displayMetrics.densityDpi / 160.0f;
        _referenceTileSize = (int)(256 * _displayDensityFactor);
        _rasterTileSize = Integer.highestOneBit(_referenceTileSize - 1) * 2;
        Log.i(TAG, "displayDensityFactor = " + _displayDensityFactor);
        Log.i(TAG, "referenceTileSize = " + _referenceTileSize);
        Log.i(TAG, "rasterTileSize = " + _rasterTileSize);

        Log.i(TAG, "Initializing core...");
        _coreResources = CoreResourcesFromAndroidAssets.loadFromCurrentApplication(this);
        OsmAndCore.InitializeCore(_coreResources);

		File directory =getApp().getAppPath("");
        _fileLogSink = QIODeviceLogSink.createFileLogSink(directory.getAbsolutePath() + "osmandcore.log");
        Logger.get().addLogSink(_fileLogSink);

        Log.i(TAG, "Going to resolve default embedded style...");
        _mapStylesCollection = new MapStylesCollection();
        _mapStyle = _mapStylesCollection.getResolvedStyleByName("default");
        if (_mapStyle == null)
        {
            Log.e(TAG, "Failed to resolve style 'default'");
            System.exit(0);
        }

        Log.i(TAG, "Going to prepare OBFs collection");
        _obfsCollection = new ObfsCollection();

		Log.i(TAG, "Will load OBFs from " + Environment.getExternalStorageDirectory() + "/osmand");

		Log.i(TAG, "Will load OBFs from " + directory.getAbsolutePath());
        _obfsCollection.addDirectory(directory.getAbsolutePath(), false);

        Log.i(TAG, "Going to prepare all resources for renderer");
        _mapPresentationEnvironment = new MapPresentationEnvironment(
                _mapStyle,
                _displayDensityFactor,
                "en"); //TODO: here should be current locale
        //mapPresentationEnvironment->setSettings(configuration.styleSettings);
        _primitiviser = new Primitiviser(
                _mapPresentationEnvironment);
        _binaryMapDataProvider = new BinaryMapDataProvider(
                _obfsCollection);
        _binaryMapPrimitivesProvider = new BinaryMapPrimitivesProvider(
                _binaryMapDataProvider,
                _primitiviser,
                _rasterTileSize);
        _binaryMapStaticSymbolsProvider = new BinaryMapStaticSymbolsProvider(
                _binaryMapPrimitivesProvider,
                _rasterTileSize);
        _binaryMapRasterBitmapTileProvider = new BinaryMapRasterBitmapTileProvider_Software(
                _binaryMapPrimitivesProvider);

		_onlineMapRasterBitmapTileProvider = OnlineTileSources.getBuiltIn().createProviderFor("Mapnik (OsmAnd)");

        Log.i(TAG, "Going to create renderer");
        _mapRenderer = OsmAndCore.createMapRenderer(MapRendererClass.AtlasMapRenderer_OpenGLES2);
        if (_mapRenderer == null)
        {
            Log.e(TAG, "Failed to create map renderer 'AtlasMapRenderer_OpenGLES2'");
            System.exit(0);
        }

        AtlasMapRendererConfiguration atlasRendererConfiguration = AtlasMapRendererConfiguration.Casts.upcastFrom(_mapRenderer.getConfiguration());
        atlasRendererConfiguration.setReferenceTileSizeOnScreenInPixels(_referenceTileSize);
        _mapRenderer.setConfiguration(AtlasMapRendererConfiguration.Casts.downcastTo_MapRendererConfiguration(atlasRendererConfiguration));

        _mapRenderer.addSymbolProvider(_binaryMapStaticSymbolsProvider);
        updateView();
        /*
        IMapRasterBitmapTileProvider mapnik = OnlineTileSources.getBuiltIn().createProviderFor("Mapnik (OsmAnd)");
        if (mapnik == null)
            Log.e(TAG, "Failed to create mapnik");
        */
        _mapRenderer.setRasterLayerProvider(RasterMapLayerId.BaseLayer, _binaryMapRasterBitmapTileProvider);

        _glSurfaceView = (GLSurfaceView) findViewById(R.id.glSurfaceView);
        //TODO:_glSurfaceView.setPreserveEGLContextOnPause(true);
        _glSurfaceView.setEGLContextClientVersion(2);
        _glSurfaceView.setEGLContextFactory(new EGLContextFactory());
        _glSurfaceView.setRenderer(new Renderer());
        _glSurfaceView.setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY);
    }

	protected void updateView() {
		_mapRenderer.setAzimuth(0.0f);
		_mapRenderer.setElevationAngle(90);
		_mapRenderer.setTarget(new PointI(currentViewport.getCenter31X(), currentViewport.getCenter31Y()));
		_mapRenderer.setZoom((float)currentViewport.getZoom() + (float)currentViewport.getZoomScale());
	}

	private GLSurfaceView _glSurfaceView;

    @Override
    public boolean onTouchEvent(MotionEvent event) {
    	if (twoFingerTapDetector.onTouchEvent(event)) {
			return true;
		}
    	return gestureDetector.onTouchEvent(event);
    }
    @Override
    protected void onPause() {
        super.onPause();
        _glSurfaceView.onPause();
    }

    @Override
    protected void onResume() {
        super.onResume();
        _glSurfaceView.onResume();
    }

    @Override
    protected void onDestroy() {
        if (_mapStylesCollection != null) {
            _mapStylesCollection.delete();
            _mapStylesCollection = null;
        }

        if (_mapStyle != null) {
            _mapStyle.delete();
            _mapStyle = null;
        }

        if (_obfsCollection != null) {
            _obfsCollection.delete();
            _obfsCollection = null;
        }

        if (_mapPresentationEnvironment != null) {
            _mapPresentationEnvironment.delete();
            _mapPresentationEnvironment = null;
        }

        if (_primitiviser != null) {
            _primitiviser.delete();
            _primitiviser = null;
        }

        if (_binaryMapDataProvider != null) {
            _binaryMapDataProvider.delete();
            _binaryMapDataProvider = null;
        }

        if (_binaryMapPrimitivesProvider != null) {
            _binaryMapPrimitivesProvider.delete();
            _binaryMapPrimitivesProvider = null;
        }

        if (_binaryMapStaticSymbolsProvider != null) {
            _binaryMapStaticSymbolsProvider.delete();
            _binaryMapStaticSymbolsProvider = null;
        }

        if (_binaryMapRasterBitmapTileProvider != null) {
            _binaryMapRasterBitmapTileProvider.delete();
            _binaryMapRasterBitmapTileProvider = null;
        }

        if (_mapRenderer != null) {
            _mapRenderer.delete();
            _mapRenderer = null;
        }

        OsmAndCore.ReleaseCore();

        super.onDestroy();
    }

    private class RenderRequestCallback extends MapRendererSetupOptions.IFrameUpdateRequestCallback {
        @Override
        public void method(IMapRenderer mapRenderer) {
            _glSurfaceView.requestRender();
        }
    }

    public class GpuWorkerThreadPrologue extends MapRendererSetupOptions.IGpuWorkerThreadPrologue {
        public GpuWorkerThreadPrologue(EGL10 egl, EGLDisplay eglDisplay, EGLContext context, EGLSurface surface) {
            _egl = egl;
            _eglDisplay = eglDisplay;
            _context = context;
            _eglSurface = surface;
        }

        private final EGL10 _egl;
        private final EGLDisplay _eglDisplay;
        private final EGLContext _context;
        private final EGLSurface _eglSurface;

        @Override
        public void method(IMapRenderer mapRenderer) {
            try {
                if (!_egl.eglMakeCurrent(_eglDisplay, _eglSurface, _eglSurface, _context))
                    Log.e(TAG, "Failed to set GPU worker context active: " + _egl.eglGetError());
            } catch (Exception e) {
                Log.e(TAG, "Failed to set GPU worker context active", e);
            }
        }
    }

    private class GpuWorkerThreadEpilogue extends MapRendererSetupOptions.IGpuWorkerThreadEpilogue {
        public GpuWorkerThreadEpilogue(EGL10 egl) {
            _egl = egl;
        }

        private final EGL10 _egl;

        @Override
        public void method(IMapRenderer mapRenderer) {
            try {
                if (!_egl.eglWaitGL())
                    Log.e(TAG, "Failed to wait for GPU worker context: " + _egl.eglGetError());
            } catch (Exception e) {
                Log.e(TAG, "Failed to wait for GPU worker context", e);
            }
        }
    }

    private class EGLContextFactory implements GLSurfaceView.EGLContextFactory {
        private EGLContext _gpuWorkerContext;
        private EGLSurface _gpuWorkerFakeSurface;

        public EGLContext createContext(EGL10 egl, EGLDisplay display, EGLConfig eglConfig) {
            final String eglExtensions = egl.eglQueryString(display, EGL10.EGL_EXTENSIONS);
            Log.i(TAG, "EGL extensions: " + eglExtensions);
            final String eglVersion = egl.eglQueryString(display, EGL10.EGL_VERSION);
            Log.i(TAG, "EGL version: " + eglVersion);

            Log.i(TAG, "Creating main context...");
            final int[] contextAttribList = {
                    EGL14.EGL_CONTEXT_CLIENT_VERSION, 2,
                    EGL10.EGL_NONE };

            EGLContext mainContext = null;
            try {
                mainContext = egl.eglCreateContext(display, eglConfig, EGL10.EGL_NO_CONTEXT, contextAttribList);
            } catch (Exception e) {
                Log.e(TAG, "Failed to create main context", e);
            }
            if (mainContext == null || mainContext == EGL10.EGL_NO_CONTEXT) {
                Log.e(TAG, "Failed to create main context: " + egl.eglGetError());
                mainContext = null;
                System.exit(0);
            }

            Log.i(TAG, "Creating GPU worker context...");
            try {
                _gpuWorkerContext = egl.eglCreateContext(
                        display,
                        eglConfig,
                        mainContext,
                        contextAttribList);
            } catch (Exception e) {
                Log.e(TAG, "Failed to create GPU worker context", e);
            }
            if (_gpuWorkerContext == null || _gpuWorkerContext == EGL10.EGL_NO_CONTEXT)
            {
                Log.e(TAG, "Failed to create GPU worker context: " + egl.eglGetError());
                _gpuWorkerContext = null;
            }

            if (_gpuWorkerContext != null)
            {
                Log.i(TAG, "Creating GPU worker fake surface...");
                try {
                    final int[] surfaceAttribList = {
                            EGL10.EGL_WIDTH, 1,
                            EGL10.EGL_HEIGHT, 1,
                            EGL10.EGL_NONE };
                    _gpuWorkerFakeSurface = egl.eglCreatePbufferSurface(display, eglConfig, surfaceAttribList);
                } catch (Exception e) {
                    Log.e(TAG, "Failed to create GPU worker fake surface", e);
                }
                if (_gpuWorkerFakeSurface == null || _gpuWorkerFakeSurface == EGL10.EGL_NO_SURFACE)
                {
                    Log.e(TAG, "Failed to create GPU worker fake surface: " + egl.eglGetError());
                    _gpuWorkerFakeSurface = null;
                }
            }

            MapRendererSetupOptions rendererSetupOptions = new MapRendererSetupOptions();
            if (_gpuWorkerContext != null && _gpuWorkerFakeSurface != null) {
                rendererSetupOptions.setGpuWorkerThreadEnabled(true);
                _gpuWorkerThreadPrologue = new GpuWorkerThreadPrologue(egl, display, _gpuWorkerContext, _gpuWorkerFakeSurface);
                rendererSetupOptions.setGpuWorkerThreadPrologue(_gpuWorkerThreadPrologue.getBinding());
                _gpuWorkerThreadEpilogue = new GpuWorkerThreadEpilogue(egl);
                rendererSetupOptions.setGpuWorkerThreadEpilogue(_gpuWorkerThreadEpilogue.getBinding());
            } else {
                rendererSetupOptions.setGpuWorkerThreadEnabled(false);
            }
            _renderRequestCallback = new RenderRequestCallback();
            rendererSetupOptions.setFrameUpdateRequestCallback(_renderRequestCallback.getBinding());
            _mapRenderer.setup(rendererSetupOptions);

            return mainContext;
        }

        public void destroyContext(EGL10 egl, EGLDisplay display, EGLContext context) {
            egl.eglDestroyContext(display, context);

            if (_gpuWorkerContext != null) {
                egl.eglDestroyContext(display, _gpuWorkerContext);
                _gpuWorkerContext = null;
            }

            if (_gpuWorkerFakeSurface != null) {
                egl.eglDestroySurface(display, _gpuWorkerFakeSurface);
                _gpuWorkerFakeSurface = null;
            }
        }
    }

    private class Renderer implements GLSurfaceView.Renderer {
        public void onSurfaceCreated(GL10 gl, EGLConfig config) {
            Log.i(TAG, "onSurfaceCreated");
            if (_mapRenderer.isRenderingInitialized())
                _mapRenderer.releaseRendering();
        }

        public void onSurfaceChanged(GL10 gl, int width, int height) {
            Log.i(TAG, "onSurfaceChanged");
            _mapRenderer.setViewport(new AreaI(0, 0, height, width));
            _mapRenderer.setWindowSize(new PointI(width, height));

            if (!_mapRenderer.isRenderingInitialized())
            {
                if (!_mapRenderer.initializeRendering())
                    Log.e(TAG, "Failed to initialize rendering");
            }
        }

        public void onDrawFrame(GL10 gl) {
            _mapRenderer.update();

            if (_mapRenderer.prepareFrame())
                _mapRenderer.renderFrame();
        }
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        return super.onOptionsItemSelected(item);
    }
}
!@#$%
20190530_013437,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_c13224
package net.osmand.core.android;

import javax.microedition.khronos.egl.EGL10;
import javax.microedition.khronos.egl.EGLConfig;
import javax.microedition.khronos.egl.EGLContext;
import javax.microedition.khronos.egl.EGLDisplay;
import javax.microedition.khronos.egl.EGLSurface;
import javax.microedition.khronos.opengles.GL10;

import net.osmand.core.jni.*;
import net.osmand.data.LatLon;
import net.osmand.data.QuadPoint;
import net.osmand.data.RotatedTileBox;
import net.osmand.plus.OsmandApplication;
import net.osmand.plus.OsmandSettings;
import net.osmand.plus.R;
import net.osmand.plus.helpers.TwoFingerTapDetector;
import net.osmand.plus.render.NativeOsmandLibrary;
import android.app.Activity;
import android.content.Context;
import android.opengl.EGL14;
import android.opengl.GLSurfaceView;
import android.os.Bundle;
import android.os.Environment;
import android.util.DisplayMetrics;
import android.util.Log;
import android.view.GestureDetector;
import android.view.GestureDetector.OnDoubleTapListener;
import android.view.Menu;
import android.view.MenuItem;
import android.view.MotionEvent;
import android.view.Window;
import android.view.WindowManager;

import java.io.File;

public class GLActivity extends Activity {

	static {
		NativeOsmandLibrary.loadLibrary("gnustl_shared");
		NativeOsmandLibrary.loadLibrary("Qt5Core");
		NativeOsmandLibrary.loadLibrary("Qt5Network");
		NativeOsmandLibrary.loadLibrary("Qt5Sql");
		NativeOsmandLibrary.loadLibrary("OsmAndCoreWithJNI");
	}
    private static final String TAG = "OsmAndCoreSample";

    private CoreResourcesFromAndroidAssets _coreResources;

    private float _displayDensityFactor;
    private int _referenceTileSize;
    private int _rasterTileSize;
    private IMapStylesCollection _mapStylesCollection;
    private ResolvedMapStyle _mapStyle;
    private ObfsCollection _obfsCollection;
    private MapPresentationEnvironment _mapPresentationEnvironment;
    private Primitiviser _primitiviser;
    private BinaryMapDataProvider _binaryMapDataProvider;
    private BinaryMapPrimitivesProvider _binaryMapPrimitivesProvider;
    private BinaryMapStaticSymbolsProvider _binaryMapStaticSymbolsProvider;
    private BinaryMapRasterBitmapTileProvider _binaryMapRasterBitmapTileProvider;
	private OnlineRasterMapTileProvider _onlineMapRasterBitmapTileProvider;
    private IMapRenderer _mapRenderer;
    private GpuWorkerThreadPrologue _gpuWorkerThreadPrologue;
    private GpuWorkerThreadEpilogue _gpuWorkerThreadEpilogue;
    private RenderRequestCallback _renderRequestCallback;
    private QIODeviceLogSink _fileLogSink;
    private RotatedTileBox currentViewport = null;
    
	private GestureDetector gestureDetector;

    
    protected OsmandApplication getApp() {
    	return (OsmandApplication) getApplication();
    }
    
    private boolean afterTwoFingerTap = false;
	TwoFingerTapDetector twoFingerTapDetector = new TwoFingerTapDetector() {
		@Override
		public void onTwoFingerTap() {
			afterTwoFingerTap = true;
			currentViewport.setZoom(currentViewport.getZoom() - 1);
			updateView();
		}
	};

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        requestWindowFeature(Window.FEATURE_NO_TITLE);
        OsmandSettings st = getApp().getSettings();
        WindowManager mgr = (WindowManager) getSystemService(Context.WINDOW_SERVICE);
		DisplayMetrics dm = new DisplayMetrics();
		mgr.getDefaultDisplay().getMetrics(dm);
		currentViewport = new RotatedTileBox.RotatedTileBoxBuilder().
				setLocation(st.getLastKnownMapLocation().getLatitude(), 
						st.getLastKnownMapLocation().getLongitude()).setZoomAndScale(st.getLastKnownMapZoom(), 0).
						setPixelDimensions(dm.widthPixels, dm.heightPixels).build();
		currentViewport.setDensity(dm.density);
		
		
		
		gestureDetector = new GestureDetector(this, new android.view.GestureDetector.OnGestureListener() {
			
			@Override
			public boolean onSingleTapUp(MotionEvent e) {
				return false;
			}
			
			@Override
			public void onShowPress(MotionEvent e) {
			}
			
			@Override
			public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {
				final QuadPoint cp = currentViewport.getCenterPixelPoint();
				final LatLon latlon = currentViewport.getLatLonFromPixel(cp.x + distanceX, cp.y + distanceY);
				currentViewport.setLatLonCenter(latlon.getLatitude(), latlon.getLongitude());
				updateView();
				return false;
			}
			
			@Override
			public void onLongPress(MotionEvent e) {
			}
			
			@Override
			public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
				return false;
			}
			
			@Override
			public boolean onDown(MotionEvent e) {
				return false;
			}
		});
		gestureDetector.setOnDoubleTapListener(new OnDoubleTapListener() {
			@Override
			public boolean onSingleTapConfirmed(MotionEvent e) {
				return false;
			}
			
			@Override
			public boolean onDoubleTapEvent(MotionEvent e) {
				return false;
			}
			
			@Override
			public boolean onDoubleTap(MotionEvent e) {
				currentViewport.setZoom(currentViewport.getZoom() + 1);
				updateView();
				return true;
			}
		});
        		
        setContentView(R.layout.activity_gl);

        // Get device display density factor
        DisplayMetrics displayMetrics = new DisplayMetrics();
        getWindowManager().getDefaultDisplay().getMetrics(displayMetrics);
        _displayDensityFactor = displayMetrics.densityDpi / 160.0f;
        _referenceTileSize = (int)(256 * _displayDensityFactor);
        _rasterTileSize = Integer.highestOneBit(_referenceTileSize - 1) * 2;
        Log.i(TAG, "displayDensityFactor = " + _displayDensityFactor);
        Log.i(TAG, "referenceTileSize = " + _referenceTileSize);
        Log.i(TAG, "rasterTileSize = " + _rasterTileSize);

        Log.i(TAG, "Initializing core...");
        _coreResources = CoreResourcesFromAndroidAssets.loadFromCurrentApplication(this);
        OsmAndCore.InitializeCore(_coreResources);

		File directory =getApp().getAppPath("");
        _fileLogSink = QIODeviceLogSink.createFileLogSink(directory.getAbsolutePath() + "osmandcore.log");
        Logger.get().addLogSink(_fileLogSink);

        Log.i(TAG, "Going to resolve default embedded style...");
        _mapStylesCollection = new MapStylesCollection();
        _mapStyle = _mapStylesCollection.getResolvedStyleByName("default");
        if (_mapStyle == null)
        {
            Log.e(TAG, "Failed to resolve style 'default'");
            System.exit(0);
        }

        Log.i(TAG, "Going to prepare OBFs collection");
        _obfsCollection = new ObfsCollection();

		Log.i(TAG, "Will load OBFs from " + Environment.getExternalStorageDirectory() + "/osmand");

		Log.i(TAG, "Will load OBFs from " + directory.getAbsolutePath());
        _obfsCollection.addDirectory(directory.getAbsolutePath(), false);

        Log.i(TAG, "Going to prepare all resources for renderer");
        _mapPresentationEnvironment = new MapPresentationEnvironment(
                _mapStyle,
                _displayDensityFactor,
                "en"); //TODO: here should be current locale
        //mapPresentationEnvironment->setSettings(configuration.styleSettings);
        _primitiviser = new Primitiviser(
                _mapPresentationEnvironment);
        _binaryMapDataProvider = new BinaryMapDataProvider(
                _obfsCollection);
        _binaryMapPrimitivesProvider = new BinaryMapPrimitivesProvider(
                _binaryMapDataProvider,
                _primitiviser,
                _rasterTileSize);
        _binaryMapStaticSymbolsProvider = new BinaryMapStaticSymbolsProvider(
                _binaryMapPrimitivesProvider,
                _rasterTileSize);
        _binaryMapRasterBitmapTileProvider = new BinaryMapRasterBitmapTileProvider_Software(
                _binaryMapPrimitivesProvider);

		_onlineMapRasterBitmapTileProvider = OnlineTileSources.getBuiltIn().createProviderFor("Mapnik (OsmAnd)");

        Log.i(TAG, "Going to create renderer");
        _mapRenderer = OsmAndCore.createMapRenderer(MapRendererClass.AtlasMapRenderer_OpenGLES2);
        if (_mapRenderer == null)
        {
            Log.e(TAG, "Failed to create map renderer 'AtlasMapRenderer_OpenGLES2'");
            System.exit(0);
        }

        AtlasMapRendererConfiguration atlasRendererConfiguration = AtlasMapRendererConfiguration.Casts.upcastFrom(_mapRenderer.getConfiguration());
        atlasRendererConfiguration.setReferenceTileSizeOnScreenInPixels(_referenceTileSize);
        _mapRenderer.setConfiguration(AtlasMapRendererConfiguration.Casts.downcastTo_MapRendererConfiguration(atlasRendererConfiguration));

        _mapRenderer.addSymbolProvider(_binaryMapStaticSymbolsProvider);
        updateView();
        /*
        IMapRasterBitmapTileProvider mapnik = OnlineTileSources.getBuiltIn().createProviderFor("Mapnik (OsmAnd)");
        if (mapnik == null)
            Log.e(TAG, "Failed to create mapnik");
        */
        _mapRenderer.setRasterLayerProvider(RasterMapLayerId.BaseLayer, _binaryMapRasterBitmapTileProvider);

        _glSurfaceView = (GLSurfaceView) findViewById(R.id.glSurfaceView);
        //TODO:_glSurfaceView.setPreserveEGLContextOnPause(true);
        _glSurfaceView.setEGLContextClientVersion(2);
        _glSurfaceView.setEGLContextFactory(new EGLContextFactory());
        _glSurfaceView.setRenderer(new Renderer());
        _glSurfaceView.setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY);
    }

	protected void updateView() {
		_mapRenderer.setAzimuth(0.0f);
		_mapRenderer.setElevationAngle(90);
		_mapRenderer.setTarget(new PointI(currentViewport.getCenter31X(), currentViewport.getCenter31Y()));
		_mapRenderer.setZoom((float)currentViewport.getZoom() + (float)currentViewport.getZoomScale());
	}

	private GLSurfaceView _glSurfaceView;

    @Override
    public boolean onTouchEvent(MotionEvent event) {
    	if (twoFingerTapDetector.onTouchEvent(event)) {
			return true;
		}
    	return gestureDetector.onTouchEvent(event);
    }
    @Override
    protected void onPause() {
        super.onPause();
        _glSurfaceView.onPause();
    }

    @Override
    protected void onResume() {
        super.onResume();
        _glSurfaceView.onResume();
    }

    @Override
    protected void onDestroy() {
        if (_mapStylesCollection != null) {
            _mapStylesCollection.delete();
            _mapStylesCollection = null;
        }

        if (_mapStyle != null) {
            _mapStyle.delete();
            _mapStyle = null;
        }

        if (_obfsCollection != null) {
            _obfsCollection.delete();
            _obfsCollection = null;
        }

        if (_mapPresentationEnvironment != null) {
            _mapPresentationEnvironment.delete();
            _mapPresentationEnvironment = null;
        }

        if (_primitiviser != null) {
            _primitiviser.delete();
            _primitiviser = null;
        }

        if (_binaryMapDataProvider != null) {
            _binaryMapDataProvider.delete();
            _binaryMapDataProvider = null;
        }

        if (_binaryMapPrimitivesProvider != null) {
            _binaryMapPrimitivesProvider.delete();
            _binaryMapPrimitivesProvider = null;
        }

        if (_binaryMapStaticSymbolsProvider != null) {
            _binaryMapStaticSymbolsProvider.delete();
            _binaryMapStaticSymbolsProvider = null;
        }

        if (_binaryMapRasterBitmapTileProvider != null) {
            _binaryMapRasterBitmapTileProvider.delete();
            _binaryMapRasterBitmapTileProvider = null;
        }

        if (_mapRenderer != null) {
            _mapRenderer.delete();
            _mapRenderer = null;
        }

        OsmAndCore.ReleaseCore();

        super.onDestroy();
    }

    private class RenderRequestCallback extends MapRendererSetupOptions.IFrameUpdateRequestCallback {
        @Override
        public void method(IMapRenderer mapRenderer) {
            _glSurfaceView.requestRender();
        }
    }

    public class GpuWorkerThreadPrologue extends MapRendererSetupOptions.IGpuWorkerThreadPrologue {
        public GpuWorkerThreadPrologue(EGL10 egl, EGLDisplay eglDisplay, EGLContext context, EGLSurface surface) {
            _egl = egl;
            _eglDisplay = eglDisplay;
            _context = context;
            _eglSurface = surface;
        }

        private final EGL10 _egl;
        private final EGLDisplay _eglDisplay;
        private final EGLContext _context;
        private final EGLSurface _eglSurface;

        @Override
        public void method(IMapRenderer mapRenderer) {
            try {
                if (!_egl.eglMakeCurrent(_eglDisplay, _eglSurface, _eglSurface, _context))
                    Log.e(TAG, "Failed to set GPU worker context active: " + _egl.eglGetError());
            } catch (Exception e) {
                Log.e(TAG, "Failed to set GPU worker context active", e);
            }
        }
    }

    private class GpuWorkerThreadEpilogue extends MapRendererSetupOptions.IGpuWorkerThreadEpilogue {
        public GpuWorkerThreadEpilogue(EGL10 egl) {
            _egl = egl;
        }

        private final EGL10 _egl;

        @Override
        public void method(IMapRenderer mapRenderer) {
            try {
                if (!_egl.eglWaitGL())
                    Log.e(TAG, "Failed to wait for GPU worker context: " + _egl.eglGetError());
            } catch (Exception e) {
                Log.e(TAG, "Failed to wait for GPU worker context", e);
            }
        }
    }

    private class EGLContextFactory implements GLSurfaceView.EGLContextFactory {
        private EGLContext _gpuWorkerContext;
        private EGLSurface _gpuWorkerFakeSurface;

        public EGLContext createContext(EGL10 egl, EGLDisplay display, EGLConfig eglConfig) {
            final String eglExtensions = egl.eglQueryString(display, EGL10.EGL_EXTENSIONS);
            Log.i(TAG, "EGL extensions: " + eglExtensions);
            final String eglVersion = egl.eglQueryString(display, EGL10.EGL_VERSION);
            Log.i(TAG, "EGL version: " + eglVersion);

            Log.i(TAG, "Creating main context...");
            final int[] contextAttribList = {
                    EGL14.EGL_CONTEXT_CLIENT_VERSION, 2,
                    EGL10.EGL_NONE };

            EGLContext mainContext = null;
            try {
                mainContext = egl.eglCreateContext(display, eglConfig, EGL10.EGL_NO_CONTEXT, contextAttribList);
            } catch (Exception e) {
                Log.e(TAG, "Failed to create main context", e);
            }
            if (mainContext == null || mainContext == EGL10.EGL_NO_CONTEXT) {
                Log.e(TAG, "Failed to create main context: " + egl.eglGetError());
                mainContext = null;
                System.exit(0);
            }

            Log.i(TAG, "Creating GPU worker context...");
            try {
                _gpuWorkerContext = egl.eglCreateContext(
                        display,
                        eglConfig,
                        mainContext,
                        contextAttribList);
            } catch (Exception e) {
                Log.e(TAG, "Failed to create GPU worker context", e);
            }
            if (_gpuWorkerContext == null || _gpuWorkerContext == EGL10.EGL_NO_CONTEXT)
            {
                Log.e(TAG, "Failed to create GPU worker context: " + egl.eglGetError());
                _gpuWorkerContext = null;
            }

            if (_gpuWorkerContext != null)
            {
                Log.i(TAG, "Creating GPU worker fake surface...");
                try {
                    final int[] surfaceAttribList = {
                            EGL10.EGL_WIDTH, 1,
                            EGL10.EGL_HEIGHT, 1,
                            EGL10.EGL_NONE };
                    _gpuWorkerFakeSurface = egl.eglCreatePbufferSurface(display, eglConfig, surfaceAttribList);
                } catch (Exception e) {
                    Log.e(TAG, "Failed to create GPU worker fake surface", e);
                }
                if (_gpuWorkerFakeSurface == null || _gpuWorkerFakeSurface == EGL10.EGL_NO_SURFACE)
                {
                    Log.e(TAG, "Failed to create GPU worker fake surface: " + egl.eglGetError());
                    _gpuWorkerFakeSurface = null;
                }
            }

            MapRendererSetupOptions rendererSetupOptions = new MapRendererSetupOptions();
            if (_gpuWorkerContext != null && _gpuWorkerFakeSurface != null) {
                rendererSetupOptions.setGpuWorkerThreadEnabled(true);
                _gpuWorkerThreadPrologue = new GpuWorkerThreadPrologue(egl, display, _gpuWorkerContext, _gpuWorkerFakeSurface);
                rendererSetupOptions.setGpuWorkerThreadPrologue(_gpuWorkerThreadPrologue.getBinding());
                _gpuWorkerThreadEpilogue = new GpuWorkerThreadEpilogue(egl);
                rendererSetupOptions.setGpuWorkerThreadEpilogue(_gpuWorkerThreadEpilogue.getBinding());
            } else {
                rendererSetupOptions.setGpuWorkerThreadEnabled(false);
            }
            _renderRequestCallback = new RenderRequestCallback();
            rendererSetupOptions.setFrameUpdateRequestCallback(_renderRequestCallback.getBinding());
            _mapRenderer.setup(rendererSetupOptions);

            return mainContext;
        }

        public void destroyContext(EGL10 egl, EGLDisplay display, EGLContext context) {
            egl.eglDestroyContext(display, context);

            if (_gpuWorkerContext != null) {
                egl.eglDestroyContext(display, _gpuWorkerContext);
                _gpuWorkerContext = null;
            }

            if (_gpuWorkerFakeSurface != null) {
                egl.eglDestroySurface(display, _gpuWorkerFakeSurface);
                _gpuWorkerFakeSurface = null;
            }
        }
    }

    private class Renderer implements GLSurfaceView.Renderer {
        public void onSurfaceCreated(GL10 gl, EGLConfig config) {
            Log.i(TAG, "onSurfaceCreated");
            if (_mapRenderer.isRenderingInitialized())
                _mapRenderer.releaseRendering();
        }

        public void onSurfaceChanged(GL10 gl, int width, int height) {
            Log.i(TAG, "onSurfaceChanged");
            _mapRenderer.setViewport(new AreaI(0, 0, height, width));
            _mapRenderer.setWindowSize(new PointI(width, height));

            if (!_mapRenderer.isRenderingInitialized())
            {
                if (!_mapRenderer.initializeRendering())
                    Log.e(TAG, "Failed to initialize rendering");
            }
        }

        public void onDrawFrame(GL10 gl) {
            _mapRenderer.update();

            if (_mapRenderer.prepareFrame())
                _mapRenderer.renderFrame();
        }
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        return super.onOptionsItemSelected(item);
    }
}
!@#$%
20190530_013856,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_b12888
package net.osmand.plus.render;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.Collection;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.Map;

import net.osmand.PlatformUtil;
import net.osmand.render.RenderingRulesStorage;
import net.osmand.render.RenderingRulesStorage.RenderingRulesStorageResolver;

import org.apache.commons.logging.Log;
import org.xmlpull.v1.XmlPullParser;
import org.xmlpull.v1.XmlPullParserException;


public class RendererRegistry {

	private final static Log log = PlatformUtil.getLog(RendererRegistry.class);
	
	public final static String DEFAULT_RENDER = "OsmAnd";  //$NON-NLS-1$
	
	private RenderingRulesStorage defaultRender = null;
	private RenderingRulesStorage currentSelectedRender = null;
	
	private Map<String, File> externalRenderers = new LinkedHashMap<String, File>();
	private Map<String, String> internalRenderers = new LinkedHashMap<String, String>();
	
	private Map<String, RenderingRulesStorage> renderers = new LinkedHashMap<String, RenderingRulesStorage>();
	
	public RendererRegistry(){
		internalRenderers.put(DEFAULT_RENDER, "default.render.xml");
		internalRenderers.put("Touring-view_(more-contrast-and-details)", "Touring-view_(more-contrast-and-details)" +".render.xml");
		internalRenderers.put("UniRS", "UniRS" + ".render.xml");
		internalRenderers.put("LightRS", "LightRS" + ".render.xml");
		internalRenderers.put("High-contrast-roads", "High-contrast-roads" + ".render.xml");
		internalRenderers.put("Winter-and-ski", "Winter-and-ski" + ".render.xml");
	}
	
	public RenderingRulesStorage defaultRender() {
		if(defaultRender == null){
			defaultRender = getRenderer(DEFAULT_RENDER);
		}
		return defaultRender;
	}

	public RenderingRulesStorage getRenderer(String name) {
		if(renderers.containsKey(name)){
			return renderers.get(name);
		}
		if(!hasRender(name)){
			return null;
		}
		try {
			RenderingRulesStorage r = loadRenderer(name, new LinkedHashMap<String, RenderingRulesStorage>(), new LinkedHashMap<String, String>());
			renderers.put(name, r);
			return r;
		} catch (IOException e) {
			log.error("Error loading renderer", e); //$NON-NLS-1$
		} catch (XmlPullParserException e) {
			log.error("Error loading renderer", e); //$NON-NLS-1$
		}
		return null;
	}

	private boolean hasRender(String name) {
		return externalRenderers.containsKey(name) || internalRenderers.containsKey(name);
	}
	
	private RenderingRulesStorage loadRenderer(String name, final Map<String, RenderingRulesStorage> loadedRenderers, 
			final Map<String, String> renderingConstants) throws IOException,  XmlPullParserException {
		InputStream is = getInputStream(name);
		if(is == null) {
			return null;
		}
		try {
			XmlPullParser parser = PlatformUtil.newXMLPullParser();
			parser.setInput(is, "UTF-8");
			int tok;
			while ((tok = parser.next()) != XmlPullParser.END_DOCUMENT) {
				if (tok == XmlPullParser.START_TAG) {
					String tagName = parser.getName();
					if (tagName.equals("renderingConstant")) {
						if (!renderingConstants.containsKey(parser.getAttributeValue("", "name"))) {
							renderingConstants.put(parser.getAttributeValue("", "name"), 
									parser.getAttributeValue("", "value"));
						}
					}
				}
			}
		} finally {
			is.close();
		}

		// parse content
		is = getInputStream(name);
		final RenderingRulesStorage main = new RenderingRulesStorage(name, renderingConstants);
		
		loadedRenderers.put(name, main);
		try {
			main.parseRulesFromXmlInputStream(is, new RenderingRulesStorageResolver() {

				@Override
				public RenderingRulesStorage resolve(String name, RenderingRulesStorageResolver ref) throws XmlPullParserException {
					// reload every time to propogate rendering constants
					if (loadedRenderers.containsKey(name)) {
						log.warn("Circular dependencies found " + name); //$NON-NLS-1$
					}
					RenderingRulesStorage dep = null;
					try {
						dep = loadRenderer(name, loadedRenderers, renderingConstants);
					} catch (IOException e) {
						log.warn("Dependent renderer not found : " + e.getMessage(), e); //$NON-NLS-1$
					}
					if (dep == null) {
						log.warn("Dependent renderer not found : " + name); //$NON-NLS-1$
					}
					return dep;
				}
			});
		} finally {
			is.close();
		}
		return main;
	}

	@SuppressWarnings("resource")
	private InputStream getInputStream(String name) throws FileNotFoundException {
		InputStream is = null;
		if("default".equalsIgnoreCase(name)) {
			name = DEFAULT_RENDER;
		}
		if(externalRenderers.containsKey(name)){
			is = new FileInputStream(externalRenderers.get(name));
		} else if(internalRenderers.containsKey(name)){
			is = RenderingRulesStorage.class.getResourceAsStream(internalRenderers.get(name));
		} else {
			throw new IllegalArgumentException("Not found " + name); //$NON-NLS-1$
		}
		return is;
	}
	
	
	public void setExternalRenderers(Map<String, File> externalRenderers) {
		this.externalRenderers = externalRenderers;
	}
	
	public Collection<String> getRendererNames(){
		LinkedHashSet<String> names = new LinkedHashSet<String>();
		names.add(DEFAULT_RENDER);
		names.addAll(internalRenderers.keySet());
		names.addAll(externalRenderers.keySet());
		return names;
	}

	public RenderingRulesStorage getCurrentSelectedRenderer() {
		if(currentSelectedRender == null){
			return defaultRender();
		}
		return currentSelectedRender;
	}
	
	public void setCurrentSelectedRender(RenderingRulesStorage currentSelectedRender) {
		this.currentSelectedRender = currentSelectedRender;
	}

	
}
!@#$%
20190530_013856,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_a12888
package net.osmand.plus.render;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.Collection;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.Map;

import net.osmand.PlatformUtil;
import net.osmand.render.RenderingRulesStorage;
import net.osmand.render.RenderingRulesStorage.RenderingRulesStorageResolver;

import org.apache.commons.logging.Log;
import org.xmlpull.v1.XmlPullParser;
import org.xmlpull.v1.XmlPullParserException;


public class RendererRegistry {

	private final static Log log = PlatformUtil.getLog(RendererRegistry.class);
	
	public final static String DEFAULT_RENDER = "default";  //$NON-NLS-1$
	
	private RenderingRulesStorage defaultRender = null;
	private RenderingRulesStorage currentSelectedRender = null;
	
	private Map<String, File> externalRenderers = new LinkedHashMap<String, File>();
	private Map<String, String> internalRenderers = new LinkedHashMap<String, String>();
	
	private Map<String, RenderingRulesStorage> renderers = new LinkedHashMap<String, RenderingRulesStorage>();
	
	public RendererRegistry(){
		internalRenderers.put(DEFAULT_RENDER, "default.render.xml");
		internalRenderers.put("Touring-view_(more-contrast-and-details)", "Touring-view_(more-contrast-and-details)" +".render.xml");
		internalRenderers.put("UniRS", "UniRS" + ".render.xml");
		internalRenderers.put("LightRS", "LightRS" + ".render.xml");
		internalRenderers.put("High-contrast-roads", "High-contrast-roads" + ".render.xml");
		internalRenderers.put("Winter-and-ski", "Winter-and-ski" + ".render.xml");
	}
	
	public RenderingRulesStorage defaultRender() {
		if(defaultRender == null){
			defaultRender = getRenderer(DEFAULT_RENDER);
		}
		return defaultRender;
	}

	public RenderingRulesStorage getRenderer(String name) {
		if(renderers.containsKey(name)){
			return renderers.get(name);
		}
		if(!hasRender(name)){
			return null;
		}
		try {
			RenderingRulesStorage r = loadRenderer(name, new LinkedHashMap<String, RenderingRulesStorage>(), new LinkedHashMap<String, String>());
			renderers.put(name, r);
			return r;
		} catch (IOException e) {
			log.error("Error loading renderer", e); //$NON-NLS-1$
		} catch (XmlPullParserException e) {
			log.error("Error loading renderer", e); //$NON-NLS-1$
		}
		return null;
	}

	private boolean hasRender(String name) {
		return externalRenderers.containsKey(name) || internalRenderers.containsKey(name);
	}
	
	private RenderingRulesStorage loadRenderer(String name, final Map<String, RenderingRulesStorage> loadedRenderers, 
			final Map<String, String> renderingConstants) throws IOException,  XmlPullParserException {
		InputStream is = getInputStream(name);
		if(is == null) {
			return null;
		}
		try {
			XmlPullParser parser = PlatformUtil.newXMLPullParser();
			parser.setInput(is, "UTF-8");
			int tok;
			while ((tok = parser.next()) != XmlPullParser.END_DOCUMENT) {
				if (tok == XmlPullParser.START_TAG) {
					String tagName = parser.getName();
					if (tagName.equals("renderingConstant")) {
						if (!renderingConstants.containsKey(parser.getAttributeValue("", "name"))) {
							renderingConstants.put(parser.getAttributeValue("", "name"), 
									parser.getAttributeValue("", "value"));
						}
					}
				}
			}
		} finally {
			is.close();
		}

		// parse content
		is = getInputStream(name);
		final RenderingRulesStorage main = new RenderingRulesStorage(name, renderingConstants);
		
		loadedRenderers.put(name, main);
		try {
			main.parseRulesFromXmlInputStream(is, new RenderingRulesStorageResolver() {

				@Override
				public RenderingRulesStorage resolve(String name, RenderingRulesStorageResolver ref) throws XmlPullParserException {
					// reload every time to propogate rendering constants
					if (loadedRenderers.containsKey(name)) {
						log.warn("Circular dependencies found " + name); //$NON-NLS-1$
					}
					RenderingRulesStorage dep = null;
					try {
						dep = loadRenderer(name, loadedRenderers, renderingConstants);
					} catch (IOException e) {
						log.warn("Dependent renderer not found : " + e.getMessage(), e); //$NON-NLS-1$
					}
					if (dep == null) {
						log.warn("Dependent renderer not found : " + name); //$NON-NLS-1$
					}
					return dep;
				}
			});
		} finally {
			is.close();
		}
		return main;
	}

	@SuppressWarnings("resource")
	private InputStream getInputStream(String name) throws FileNotFoundException {
		InputStream is = null;
		if(externalRenderers.containsKey(name)){
			is = new FileInputStream(externalRenderers.get(name));
		} else if(internalRenderers.containsKey(name)){
			is = RenderingRulesStorage.class.getResourceAsStream(internalRenderers.get(name));
		} else {
			throw new IllegalArgumentException("Not found " + name); //$NON-NLS-1$
		}
		return is;
	}
	
	
	public void setExternalRenderers(Map<String, File> externalRenderers) {
		this.externalRenderers = externalRenderers;
	}
	
	public Collection<String> getRendererNames(){
		LinkedHashSet<String> names = new LinkedHashSet<String>();
		names.add(DEFAULT_RENDER);
		names.addAll(internalRenderers.keySet());
		names.addAll(externalRenderers.keySet());
		return names;
	}

	public RenderingRulesStorage getCurrentSelectedRenderer() {
		if(currentSelectedRender == null){
			return defaultRender();
		}
		return currentSelectedRender;
	}
	
	public void setCurrentSelectedRender(RenderingRulesStorage currentSelectedRender) {
		this.currentSelectedRender = currentSelectedRender;
	}

	
}
!@#$%
20190530_013856,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_c12888
package net.osmand.plus.render;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.Collection;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.Map;

import net.osmand.PlatformUtil;
import net.osmand.render.RenderingRulesStorage;
import net.osmand.render.RenderingRulesStorage.RenderingRulesStorageResolver;

import org.apache.commons.logging.Log;
import org.xmlpull.v1.XmlPullParser;
import org.xmlpull.v1.XmlPullParserException;


public class RendererRegistry {

	private final static Log log = PlatformUtil.getLog(RendererRegistry.class);
	
	public final static String DEFAULT_RENDER = "OsmAnd";  //$NON-NLS-1$
	
	private RenderingRulesStorage defaultRender = null;
	private RenderingRulesStorage currentSelectedRender = null;
	
	private Map<String, File> externalRenderers = new LinkedHashMap<String, File>();
	private Map<String, String> internalRenderers = new LinkedHashMap<String, String>();
	
	private Map<String, RenderingRulesStorage> renderers = new LinkedHashMap<String, RenderingRulesStorage>();
	
	public RendererRegistry(){
		internalRenderers.put(DEFAULT_RENDER, "default.render.xml");
		internalRenderers.put("Touring-view_(more-contrast-and-details)", "Touring-view_(more-contrast-and-details)" +".render.xml");
		internalRenderers.put("UniRS", "UniRS" + ".render.xml");
		internalRenderers.put("LightRS", "LightRS" + ".render.xml");
		internalRenderers.put("High-contrast-roads", "High-contrast-roads" + ".render.xml");
		internalRenderers.put("Winter-and-ski", "Winter-and-ski" + ".render.xml");
	}
	
	public RenderingRulesStorage defaultRender() {
		if(defaultRender == null){
			defaultRender = getRenderer(DEFAULT_RENDER);
		}
		return defaultRender;
	}

	public RenderingRulesStorage getRenderer(String name) {
		if(renderers.containsKey(name)){
			return renderers.get(name);
		}
		if(!hasRender(name)){
			return null;
		}
		try {
			RenderingRulesStorage r = loadRenderer(name, new LinkedHashMap<String, RenderingRulesStorage>(), new LinkedHashMap<String, String>());
			renderers.put(name, r);
			return r;
		} catch (IOException e) {
			log.error("Error loading renderer", e); //$NON-NLS-1$
		} catch (XmlPullParserException e) {
			log.error("Error loading renderer", e); //$NON-NLS-1$
		}
		return null;
	}

	private boolean hasRender(String name) {
		return externalRenderers.containsKey(name) || internalRenderers.containsKey(name);
	}
	
	private RenderingRulesStorage loadRenderer(String name, final Map<String, RenderingRulesStorage> loadedRenderers, 
			final Map<String, String> renderingConstants) throws IOException,  XmlPullParserException {
		InputStream is = getInputStream(name);
		if(is == null) {
			return null;
		}
		try {
			XmlPullParser parser = PlatformUtil.newXMLPullParser();
			parser.setInput(is, "UTF-8");
			int tok;
			while ((tok = parser.next()) != XmlPullParser.END_DOCUMENT) {
				if (tok == XmlPullParser.START_TAG) {
					String tagName = parser.getName();
					if (tagName.equals("renderingConstant")) {
						if (!renderingConstants.containsKey(parser.getAttributeValue("", "name"))) {
							renderingConstants.put(parser.getAttributeValue("", "name"), 
									parser.getAttributeValue("", "value"));
						}
					}
				}
			}
		} finally {
			is.close();
		}

		// parse content
		is = getInputStream(name);
		final RenderingRulesStorage main = new RenderingRulesStorage(name, renderingConstants);
		
		loadedRenderers.put(name, main);
		try {
			main.parseRulesFromXmlInputStream(is, new RenderingRulesStorageResolver() {

				@Override
				public RenderingRulesStorage resolve(String name, RenderingRulesStorageResolver ref) throws XmlPullParserException {
					// reload every time to propogate rendering constants
					if (loadedRenderers.containsKey(name)) {
						log.warn("Circular dependencies found " + name); //$NON-NLS-1$
					}
					RenderingRulesStorage dep = null;
					try {
						dep = loadRenderer(name, loadedRenderers, renderingConstants);
					} catch (IOException e) {
						log.warn("Dependent renderer not found : " + e.getMessage(), e); //$NON-NLS-1$
					}
					if (dep == null) {
						log.warn("Dependent renderer not found : " + name); //$NON-NLS-1$
					}
					return dep;
				}
			});
		} finally {
			is.close();
		}
		return main;
	}

	@SuppressWarnings("resource")
	private InputStream getInputStream(String name) throws FileNotFoundException {
		InputStream is = null;
		if("default".equalsIgnoreCase(name)) {
			name = DEFAULT_RENDER;
		} 
		if(externalRenderers.containsKey(name)){
			is = new FileInputStream(externalRenderers.get(name));
		} else if(internalRenderers.containsKey(name)){
			is = RenderingRulesStorage.class.getResourceAsStream(internalRenderers.get(name));
		} else {
			throw new IllegalArgumentException("Not found " + name); //$NON-NLS-1$
		}
		return is;
	}
	
	
	public void setExternalRenderers(Map<String, File> externalRenderers) {
		this.externalRenderers = externalRenderers;
	}
	
	public Collection<String> getRendererNames(){
		LinkedHashSet<String> names = new LinkedHashSet<String>();
		names.add(DEFAULT_RENDER);
		names.addAll(internalRenderers.keySet());
		names.addAll(externalRenderers.keySet());
		return names;
	}

	public RenderingRulesStorage getCurrentSelectedRenderer() {
		if(currentSelectedRender == null){
			return defaultRender();
		}
		return currentSelectedRender;
	}
	
	public void setCurrentSelectedRender(RenderingRulesStorage currentSelectedRender) {
		this.currentSelectedRender = currentSelectedRender;
	}

	
}
!@#$%
20190530_020741,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_b11928
package net.osmand.plus.dashboard;

import android.content.Context;
import android.graphics.Bitmap;
import android.view.*;
import android.widget.ImageView;
import net.osmand.data.LatLon;
import net.osmand.data.RotatedTileBox;
import net.osmand.map.MapTileDownloader.DownloadRequest;
import net.osmand.map.MapTileDownloader.IMapDownloaderCallback;
import net.osmand.plus.R;
import net.osmand.plus.activities.MainMenuActivity;
import net.osmand.plus.activities.MapActivity;
import net.osmand.plus.helpers.FontCache;
import net.osmand.plus.render.MapRenderRepositories;
import net.osmand.plus.render.MapVectorLayer;
import net.osmand.plus.resources.ResourceManager;
import net.osmand.plus.views.MapTextLayer;
import net.osmand.plus.views.OsmAndMapSurfaceView;
import net.osmand.plus.views.OsmandMapTileView;
import android.graphics.Typeface;
import android.os.Bundle;
import android.support.annotation.Nullable;
import android.widget.Button;
import android.widget.ProgressBar;
import android.widget.TextView;

/**
 * Created by Denis on 24.11.2014.
 */
public class DashMapFragment extends DashBaseFragment implements IMapDownloaderCallback {

    public static final String TAG = "DASH_MAP_FRAGMENT";

    @Override
    public void onDestroy() {
        super.onDestroy();
        getMyApplication().getResourceManager().getMapTileDownloader().removeDownloaderCallback(this);
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        getMyApplication().getResourceManager().getMapTileDownloader().addDownloaderCallback(this);
    }

    protected void startMapActivity() {
        MapActivity.launchMapActivityMoveToTop(getActivity());
    }

    @Override
    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
        View view = getActivity().getLayoutInflater().inflate(R.layout.dash_map_fragment, container, false);
        Typeface typeface = FontCache.getRobotoMedium(getActivity());
        ((TextView) view.findViewById(R.id.map_text)).setTypeface(typeface);
        ((Button) view.findViewById(R.id.show_map)).setTypeface(typeface);

        (view.findViewById(R.id.show_map)).setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                startMapActivity();
            }


        });
        view.findViewById(R.id.map_image).setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                startMapActivity();
            }
        });

        return view;
    }

    private void setMapImage(View view) {
        if (view == null) {
            return;
        }
        Bitmap image = getMyApplication().getResourceManager().getRenderer().getBitmap();
        ImageView map = (ImageView) view.findViewById(R.id.map_image);
        if (image != null) {
            map.setImageBitmap(image);
        }
    }


    @Override
    public void onResume() {
        super.onResume();
        if (!getMyApplication().isApplicationInitializing()) {
            updateMapImage();
        }

    }

    @Override
    public void onViewCreated(final View view, @Nullable Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);
        view.findViewById(R.id.map_image).setVisibility(View.GONE);
        if (getMyApplication().isApplicationInitializing()) {
            getMyApplication().checkApplicationIsBeingInitialized(getActivity(), (TextView) view.findViewById(R.id.ProgressMessage),
                    (ProgressBar) view.findViewById(R.id.ProgressBar), new Runnable() {
                        @Override
                        public void run() {
                            applicationInitialized(view);
                        }
                    });
        } else {
            applicationInitialized(view);
        }
    }

    private void applicationInitialized(View view) {
        updateMapImage();
        view.findViewById(R.id.loading).setVisibility(View.GONE);
        MainMenuActivity dashboardActivity = ((MainMenuActivity) getSherlockActivity());
        if (dashboardActivity != null) {
            dashboardActivity.updateDownloads();
            view.findViewById(R.id.map_image).setVisibility(View.VISIBLE);
        }
    }

    @Override
    public void tileDownloaded(DownloadRequest request) {
        if (request != null && !request.error && request.fileToSave != null) {
            ResourceManager mgr = getMyApplication().getResourceManager();
            mgr.tileDownloaded(request);
        }
        setMapImage(getView());
    }

    private void updateMapImage() {
        MapRenderRepositories repositories = getMyApplication().getResourceManager().getRenderer();
        LatLon lm = getMyApplication().getSettings().getLastKnownMapLocation();
        int zm = getMyApplication().getSettings().getLastKnownMapZoom();

        WindowManager wm = (WindowManager) getActivity().getSystemService(Context.WINDOW_SERVICE);
        Display display = wm.getDefaultDisplay();
        int height = (int) getActivity().getResources().getDimension(R.dimen.dashMapHeight);
        int width = display.getWidth();

        RotatedTileBox rotatedTileBox = new RotatedTileBox.RotatedTileBoxBuilder().
                setZoom(zm).setLocation(lm.getLatitude(), lm.getLongitude()).
                setPixelDimensions(width, height).build();
        repositories.loadMap(rotatedTileBox,
                getMyApplication().getResourceManager().getMapTileDownloader().getDownloaderCallbacks());
    }
}
!@#$%
20190530_020741,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_a11928
package net.osmand.plus.dashboard;

import android.content.Context;
import android.graphics.Bitmap;
import android.view.*;
import android.widget.ImageView;
import net.osmand.data.LatLon;
import net.osmand.data.RotatedTileBox;
import net.osmand.map.MapTileDownloader.DownloadRequest;
import net.osmand.map.MapTileDownloader.IMapDownloaderCallback;
import net.osmand.plus.R;
import net.osmand.plus.activities.MainMenuActivity;
import net.osmand.plus.activities.MapActivity;
import net.osmand.plus.helpers.FontCache;
import net.osmand.plus.render.MapRenderRepositories;
import net.osmand.plus.render.MapVectorLayer;
import net.osmand.plus.resources.ResourceManager;
import net.osmand.plus.views.MapTextLayer;
import net.osmand.plus.views.OsmAndMapSurfaceView;
import net.osmand.plus.views.OsmandMapTileView;
import android.graphics.Typeface;
import android.os.Bundle;
import android.support.annotation.Nullable;
import android.widget.Button;
import android.widget.ProgressBar;
import android.widget.TextView;

/**
 * Created by Denis on 24.11.2014.
 */
public class DashMapFragment extends DashBaseFragment implements IMapDownloaderCallback {

    public static final String TAG = "DASH_MAP_FRAGMENT";

    @Override
    public void onDestroy() {
        super.onDestroy();
        getMyApplication().getResourceManager().getMapTileDownloader().removeDownloaderCallback(this);
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        getMyApplication().getResourceManager().getMapTileDownloader().addDownloaderCallback(this);
    }

    protected void startMapActivity() {
        MapActivity.launchMapActivityMoveToTop(getActivity());
    }

    @Override
    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
        View view = getActivity().getLayoutInflater().inflate(R.layout.dash_map_fragment, container, false);
        Typeface typeface = FontCache.getRobotoMedium(getActivity());
        ((TextView) view.findViewById(R.id.map_text)).setTypeface(typeface);
        ((Button) view.findViewById(R.id.show_map)).setTypeface(typeface);

        (view.findViewById(R.id.show_map)).setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                startMapActivity();
            }


        });
        view.findViewById(R.id.map_image).setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                startMapActivity();
            }
        });

        return view;
    }

    private void setMapImage(View view) {
        if (view == null) {
            return;
        }
        Bitmap image = getMyApplication().getResourceManager().getRenderer().getBitmap();
        ImageView map = (ImageView) view.findViewById(R.id.map_image);
        if (image != null) {
            map.setImageBitmap(image);
        }
    }


    @Override
    public void onResume() {
        super.onResume();
        if (!getMyApplication().isApplicationInitializing()){
            updateMapImage();
        }

    }

    @Override
    public void onViewCreated(final View view, @Nullable Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);
        view.findViewById(R.id.map_image).setVisibility(View.GONE);
        if (getMyApplication().isApplicationInitializing()) {
            getMyApplication().checkApplicationIsBeingInitialized(getActivity(), (TextView) view.findViewById(R.id.ProgressMessage),
                    (ProgressBar) view.findViewById(R.id.ProgressBar), new Runnable() {
                        @Override
                        public void run() {
                            applicationInitialized(view);
                        }
                    });
        } else {
            applicationInitialized(view);
        }
    }

    private void applicationInitialized(View view) {
        updateMapImage();
        view.findViewById(R.id.loading).setVisibility(View.GONE);
        MainMenuActivity dashboardActivity = ((MainMenuActivity) getSherlockActivity());
        if (dashboardActivity != null) {
            dashboardActivity.updateDownloads();
            view.findViewById(R.id.map_image).setVisibility(View.VISIBLE);
        }
    }

    @Override
    public void tileDownloaded(DownloadRequest request) {
        if (request != null && !request.error && request.fileToSave != null) {
            ResourceManager mgr = getMyApplication().getResourceManager();
            mgr.tileDownloaded(request);
        }
        setMapImage(getView());
    }

    private void updateMapImage() {
        MapRenderRepositories repositories = getMyApplication().getResourceManager().getRenderer();
        LatLon lm = getMyApplication().getSettings().getLastKnownMapLocation();
        int zm = getMyApplication().getSettings().getLastKnownMapZoom();

        WindowManager wm = (WindowManager) getActivity().getSystemService(Context.WINDOW_SERVICE);
        Display display = wm.getDefaultDisplay();
        int height = (int) getActivity().getResources().getDimension(R.dimen.dashMapHeight);
        int width = display.getWidth();

        RotatedTileBox rotatedTileBox = new RotatedTileBox.RotatedTileBoxBuilder().
                setZoom(zm).setLocation(lm.getLatitude(), lm.getLongitude()).
                setPixelDimensions(width, height).build();
        repositories.loadMap(rotatedTileBox,
                getMyApplication().getResourceManager().getMapTileDownloader().getDownloaderCallbacks());
    }
}
!@#$%
20190530_020741,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_c11928
package net.osmand.plus.dashboard;

import android.content.Context;
import android.graphics.Bitmap;
import android.os.AsyncTask;
import android.view.*;
import android.widget.ImageView;
import net.osmand.data.LatLon;
import net.osmand.data.RotatedTileBox;
import net.osmand.map.MapTileDownloader.DownloadRequest;
import net.osmand.map.MapTileDownloader.IMapDownloaderCallback;
import net.osmand.plus.R;
import net.osmand.plus.activities.MainMenuActivity;
import net.osmand.plus.activities.MapActivity;
import net.osmand.plus.helpers.FontCache;
import net.osmand.plus.render.MapRenderRepositories;
import net.osmand.plus.render.MapVectorLayer;
import net.osmand.plus.resources.ResourceManager;
import net.osmand.plus.views.MapTextLayer;
import net.osmand.plus.views.OsmAndMapSurfaceView;
import net.osmand.plus.views.OsmandMapTileView;
import android.graphics.Typeface;
import android.os.Bundle;
import android.support.annotation.Nullable;
import android.widget.Button;
import android.widget.ProgressBar;
import android.widget.TextView;

/**
 * Created by Denis on 24.11.2014.
 */
public class DashMapFragment extends DashBaseFragment implements IMapDownloaderCallback {

	public static final String TAG = "DASH_MAP_FRAGMENT";

	@Override
	public void onDestroy() {
		super.onDestroy();
		getMyApplication().getResourceManager().getMapTileDownloader().removeDownloaderCallback(this);
	}

	@Override
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		getMyApplication().getResourceManager().getMapTileDownloader().addDownloaderCallback(this);
	}

	protected void startMapActivity() {
		MapActivity.launchMapActivityMoveToTop(getActivity());
	}

	@Override
	public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
		View view = getActivity().getLayoutInflater().inflate(R.layout.dash_map_fragment, container, false);
		Typeface typeface = FontCache.getRobotoMedium(getActivity());
		((TextView) view.findViewById(R.id.map_text)).setTypeface(typeface);
		((Button) view.findViewById(R.id.show_map)).setTypeface(typeface);

		(view.findViewById(R.id.show_map)).setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View view) {
				startMapActivity();
			}


		});
		view.findViewById(R.id.map_image).setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				startMapActivity();
			}
		});

		return view;
	}

	private void setMapImage(View view) {
		if (view == null) {
			return;
		}
		final Bitmap image = getMyApplication().getResourceManager().getRenderer().getBitmap();
		final ImageView map = (ImageView) view.findViewById(R.id.map_image);
		if (image != null) {
			getActivity().runOnUiThread(new Runnable() {
				@Override
				public void run() {
					map.setImageBitmap(image);
				}
			});

		}
	}


	@Override
	public void onResume() {
		super.onResume();
		if (!getMyApplication().isApplicationInitializing()) {
			updateMapImage();
		}
	}

	@Override
	public void onViewCreated(final View view, @Nullable Bundle savedInstanceState) {
		super.onViewCreated(view, savedInstanceState);
		view.findViewById(R.id.map_image).setVisibility(View.GONE);
		if (getMyApplication().isApplicationInitializing()) {
			getMyApplication().checkApplicationIsBeingInitialized(getActivity(), (TextView) view.findViewById(R.id.ProgressMessage),
					(ProgressBar) view.findViewById(R.id.ProgressBar), new Runnable() {
						@Override
						public void run() {
							applicationInitialized(view);
						}
					});
		} else {
			applicationInitialized(view);
		}
	}

	private void applicationInitialized(View view) {
		updateMapImage();
		view.findViewById(R.id.loading).setVisibility(View.GONE);
		MainMenuActivity dashboardActivity = ((MainMenuActivity) getSherlockActivity());
		if (dashboardActivity != null) {
			dashboardActivity.updateDownloads();
			view.findViewById(R.id.map_image).setVisibility(View.VISIBLE);
		}
	}

	@Override
	public void tileDownloaded(DownloadRequest request) {
		if (request != null && !request.error && request.fileToSave != null) {
			ResourceManager mgr = getMyApplication().getResourceManager();
			mgr.tileDownloaded(request);
		}
		setMapImage(getView());
	}

	private void updateMapImage() {
		MapRenderRepositories repositories = getMyApplication().getResourceManager().getRenderer();
		LatLon lm = getMyApplication().getSettings().getLastKnownMapLocation();
		int zm = getMyApplication().getSettings().getLastKnownMapZoom();

		WindowManager wm = (WindowManager) getActivity().getSystemService(Context.WINDOW_SERVICE);
		Display display = wm.getDefaultDisplay();
		int height = (int) getActivity().getResources().getDimension(R.dimen.dashMapHeight);
		int width = display.getWidth();

		RotatedTileBox rotatedTileBox = new RotatedTileBox.RotatedTileBoxBuilder().
				setZoom(zm).setLocation(lm.getLatitude(), lm.getLongitude()).
				setPixelDimensions(width, height).build();
		repositories.loadMap(rotatedTileBox,
				getMyApplication().getResourceManager().getMapTileDownloader().getDownloaderCallbacks());
	}
}
!@#$%
20190530_020751,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_b04004
package net.osmand.plus.dashboard;

import android.content.Context;
import android.graphics.Bitmap;
import android.view.*;
import android.widget.ImageView;
import net.osmand.data.LatLon;
import net.osmand.data.RotatedTileBox;
import net.osmand.map.MapTileDownloader.DownloadRequest;
import net.osmand.map.MapTileDownloader.IMapDownloaderCallback;
import net.osmand.plus.R;
import net.osmand.plus.activities.MainMenuActivity;
import net.osmand.plus.activities.MapActivity;
import net.osmand.plus.render.MapRenderRepositories;
import net.osmand.plus.resources.ResourceManager;
import android.os.Bundle;
import android.support.annotation.Nullable;
import android.widget.ProgressBar;
import android.widget.TextView;

/**
 * Created by Denis on
 * 24.11.2014.
 */
public class DashMapFragment extends DashBaseFragment implements IMapDownloaderCallback {

	public static final String TAG = "DASH_MAP_FRAGMENT";

	@Override
	public void onDestroy() {
		super.onDestroy();
		getMyApplication().getResourceManager().getMapTileDownloader().removeDownloaderCallback(this);
	}

	@Override
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		getMyApplication().getResourceManager().getMapTileDownloader().addDownloaderCallback(this);
	}

	protected void startMapActivity() {
		MapActivity.launchMapActivityMoveToTop(getActivity());
	}

	@Override
	public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
		View view = getActivity().getLayoutInflater().inflate(R.layout.dash_map_fragment, container, false);

		view.findViewById(R.id.map_image).setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				startMapActivity();
			}
		});

		return view;
	}

	private void setMapImage(View view) {
		if (view == null) {
			return;
		}
		final Bitmap image = getMyApplication().getResourceManager().getRenderer().getBitmap();
		final ImageView map = (ImageView) view.findViewById(R.id.map_image);
		if (image != null) {
			getActivity().runOnUiThread(new Runnable() {
				@Override
				public void run() {
					map.setImageBitmap(image);
				}
			});

		}
	}


	@Override
	public void onResume() {
		super.onResume();
		if (!getMyApplication().isApplicationInitializing()) {
			updateMapImage();
		}
	}

	@Override
	public void onViewCreated(final View view, @Nullable Bundle savedInstanceState) {
		super.onViewCreated(view, savedInstanceState);
		view.findViewById(R.id.map_image).setVisibility(View.GONE);
		if (getMyApplication().isApplicationInitializing()) {
			getMyApplication().checkApplicationIsBeingInitialized(getActivity(), (TextView) view.findViewById(R.id.ProgressMessage),
					(ProgressBar) view.findViewById(R.id.ProgressBar), new Runnable() {
						@Override
						public void run() {
							applicationInitialized(view);
						}
					});
		} else {
			applicationInitialized(view);
		}
	}

	private void applicationInitialized(View view) {
		updateMapImage();
		view.findViewById(R.id.loading).setVisibility(View.GONE);
		MainMenuActivity dashboardActivity = ((MainMenuActivity) getActivity());
		if (dashboardActivity != null) {
			dashboardActivity.updateDownloads();
			view.findViewById(R.id.map_image).setVisibility(View.VISIBLE);
		}
	}

	@Override
	public void tileDownloaded(DownloadRequest request) {
		if (request != null && !request.error && request.fileToSave != null) {
			ResourceManager mgr = getMyApplication().getResourceManager();
			mgr.tileDownloaded(request);
		}
		setMapImage(getView());
	}

	@SuppressWarnings("deprecation")
	private void updateMapImage() {
		MapRenderRepositories repositories = getMyApplication().getResourceManager().getRenderer();
		LatLon lm = getMyApplication().getSettings().getLastKnownMapLocation();
		int zm = getMyApplication().getSettings().getLastKnownMapZoom();

		WindowManager wm = (WindowManager) getActivity().getSystemService(Context.WINDOW_SERVICE);
		Display display = wm.getDefaultDisplay();
		int height = (int) getActivity().getResources().getDimension(R.dimen.dashMapHeight);
		int width = display.getWidth();

		RotatedTileBox rotatedTileBox = new RotatedTileBox.RotatedTileBoxBuilder().
				setZoom(zm).setLocation(lm.getLatitude(), lm.getLongitude()).
				setPixelDimensions(width, height).build();
		repositories.loadMap(rotatedTileBox,
				getMyApplication().getResourceManager().getMapTileDownloader().getDownloaderCallbacks());
	}
}
!@#$%
20190530_020751,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_a04004
package net.osmand.plus.dashboard;

import android.content.Context;
import android.graphics.Bitmap;
import android.os.AsyncTask;
import android.view.*;
import android.widget.ImageView;
import net.osmand.data.LatLon;
import net.osmand.data.RotatedTileBox;
import net.osmand.map.MapTileDownloader.DownloadRequest;
import net.osmand.map.MapTileDownloader.IMapDownloaderCallback;
import net.osmand.plus.R;
import net.osmand.plus.activities.MainMenuActivity;
import net.osmand.plus.activities.MapActivity;
import net.osmand.plus.helpers.FontCache;
import net.osmand.plus.render.MapRenderRepositories;
import net.osmand.plus.render.MapVectorLayer;
import net.osmand.plus.resources.ResourceManager;
import net.osmand.plus.views.MapTextLayer;
import net.osmand.plus.views.OsmAndMapSurfaceView;
import net.osmand.plus.views.OsmandMapTileView;
import android.graphics.Typeface;
import android.os.Bundle;
import android.support.annotation.Nullable;
import android.widget.Button;
import android.widget.ProgressBar;
import android.widget.TextView;

/**
 * Created by Denis on 24.11.2014.
 */
public class DashMapFragment extends DashBaseFragment implements IMapDownloaderCallback {

	public static final String TAG = "DASH_MAP_FRAGMENT";

	@Override
	public void onDestroy() {
		super.onDestroy();
		getMyApplication().getResourceManager().getMapTileDownloader().removeDownloaderCallback(this);
	}

	@Override
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		getMyApplication().getResourceManager().getMapTileDownloader().addDownloaderCallback(this);
	}

	protected void startMapActivity() {
		MapActivity.launchMapActivityMoveToTop(getActivity());
	}

	@Override
	public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
		View view = getActivity().getLayoutInflater().inflate(R.layout.dash_map_fragment, container, false);
		Typeface typeface = FontCache.getRobotoMedium(getActivity());
		((TextView) view.findViewById(R.id.map_text)).setTypeface(typeface);
		((Button) view.findViewById(R.id.show_map)).setTypeface(typeface);

		(view.findViewById(R.id.show_map)).setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View view) {
				startMapActivity();
			}


		});
		view.findViewById(R.id.map_image).setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				startMapActivity();
			}
		});

		return view;
	}

	private void setMapImage(View view) {
		if (view == null) {
			return;
		}
		final Bitmap image = getMyApplication().getResourceManager().getRenderer().getBitmap();
		final ImageView map = (ImageView) view.findViewById(R.id.map_image);
		if (image != null) {
			getActivity().runOnUiThread(new Runnable() {
				@Override
				public void run() {
					map.setImageBitmap(image);
				}
			});

		}
	}


	@Override
	public void onResume() {
		super.onResume();
		if (!getMyApplication().isApplicationInitializing()) {
			updateMapImage();
		}
	}

	@Override
	public void onViewCreated(final View view, @Nullable Bundle savedInstanceState) {
		super.onViewCreated(view, savedInstanceState);
		view.findViewById(R.id.map_image).setVisibility(View.GONE);
		if (getMyApplication().isApplicationInitializing()) {
			getMyApplication().checkApplicationIsBeingInitialized(getActivity(), (TextView) view.findViewById(R.id.ProgressMessage),
					(ProgressBar) view.findViewById(R.id.ProgressBar), new Runnable() {
						@Override
						public void run() {
							applicationInitialized(view);
						}
					});
		} else {
			applicationInitialized(view);
		}
	}

	private void applicationInitialized(View view) {
		updateMapImage();
		view.findViewById(R.id.loading).setVisibility(View.GONE);
		MainMenuActivity dashboardActivity = ((MainMenuActivity) getSherlockActivity());
		if (dashboardActivity != null) {
			dashboardActivity.updateDownloads();
			view.findViewById(R.id.map_image).setVisibility(View.VISIBLE);
		}
	}

	@Override
	public void tileDownloaded(DownloadRequest request) {
		if (request != null && !request.error && request.fileToSave != null) {
			ResourceManager mgr = getMyApplication().getResourceManager();
			mgr.tileDownloaded(request);
		}
		setMapImage(getView());
	}

	private void updateMapImage() {
		MapRenderRepositories repositories = getMyApplication().getResourceManager().getRenderer();
		LatLon lm = getMyApplication().getSettings().getLastKnownMapLocation();
		int zm = getMyApplication().getSettings().getLastKnownMapZoom();

		WindowManager wm = (WindowManager) getActivity().getSystemService(Context.WINDOW_SERVICE);
		Display display = wm.getDefaultDisplay();
		int height = (int) getActivity().getResources().getDimension(R.dimen.dashMapHeight);
		int width = display.getWidth();

		RotatedTileBox rotatedTileBox = new RotatedTileBox.RotatedTileBoxBuilder().
				setZoom(zm).setLocation(lm.getLatitude(), lm.getLongitude()).
				setPixelDimensions(width, height).build();
		repositories.loadMap(rotatedTileBox,
				getMyApplication().getResourceManager().getMapTileDownloader().getDownloaderCallbacks());
	}
}
!@#$%
20190530_020751,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_c04004
package net.osmand.plus.dashboard;

import android.content.Context;
import android.graphics.Bitmap;
import android.os.AsyncTask;
import android.view.*;
import android.widget.ImageView;
import net.osmand.data.LatLon;
import net.osmand.data.RotatedTileBox;
import net.osmand.map.MapTileDownloader.DownloadRequest;
import net.osmand.map.MapTileDownloader.IMapDownloaderCallback;
import net.osmand.plus.R;
import net.osmand.plus.activities.MainMenuActivity;
import net.osmand.plus.activities.MapActivity;
import net.osmand.plus.helpers.FontCache;
import net.osmand.plus.render.MapRenderRepositories;
import net.osmand.plus.render.MapVectorLayer;
import net.osmand.plus.resources.ResourceManager;
import net.osmand.plus.views.MapTextLayer;
import net.osmand.plus.views.OsmAndMapSurfaceView;
import net.osmand.plus.views.OsmandMapTileView;
import android.graphics.Typeface;
import android.os.Bundle;
import android.support.annotation.Nullable;
import android.widget.Button;
import android.widget.ProgressBar;
import android.widget.TextView;

/**
 * Created by Denis on 24.11.2014.
 */
public class DashMapFragment extends DashBaseFragment implements IMapDownloaderCallback {

	public static final String TAG = "DASH_MAP_FRAGMENT";

	@Override
	public void onDestroy() {
		super.onDestroy();
		getMyApplication().getResourceManager().getMapTileDownloader().removeDownloaderCallback(this);
	}

	@Override
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		getMyApplication().getResourceManager().getMapTileDownloader().addDownloaderCallback(this);
	}

	protected void startMapActivity() {
		MapActivity.launchMapActivityMoveToTop(getActivity());
	}

	@Override
	public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
		View view = getActivity().getLayoutInflater().inflate(R.layout.dash_map_fragment, container, false);
		Typeface typeface = FontCache.getRobotoMedium(getActivity());
		((TextView) view.findViewById(R.id.map_text)).setTypeface(typeface);
		((Button) view.findViewById(R.id.show_map)).setTypeface(typeface);

		(view.findViewById(R.id.show_map)).setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View view) {
				startMapActivity();
			}


		});
		view.findViewById(R.id.map_image).setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				startMapActivity();
			}
		});

		return view;
	}

	private void setMapImage(View view) {
		if (view == null) {
			return;
		}
		final Bitmap image = getMyApplication().getResourceManager().getRenderer().getBitmap();
		final ImageView map = (ImageView) view.findViewById(R.id.map_image);
		if (image != null) {
			getActivity().runOnUiThread(new Runnable() {
				@Override
				public void run() {
					map.setImageBitmap(image);
				}
			});

		}
	}


	@Override
	public void onResume() {
		super.onResume();
        if (!getMyApplication().isApplicationInitializing()) {
			updateMapImage();
		}

    }

	@Override
	public void onViewCreated(final View view, @Nullable Bundle savedInstanceState) {
		super.onViewCreated(view, savedInstanceState);
		view.findViewById(R.id.map_image).setVisibility(View.GONE);
		if (getMyApplication().isApplicationInitializing()) {
			getMyApplication().checkApplicationIsBeingInitialized(getActivity(), (TextView) view.findViewById(R.id.ProgressMessage),
					(ProgressBar) view.findViewById(R.id.ProgressBar), new Runnable() {
						@Override
						public void run() {
							applicationInitialized(view);
						}
					});
		} else {
			applicationInitialized(view);
		}
	}

	private void applicationInitialized(View view) {
		updateMapImage();
		view.findViewById(R.id.loading).setVisibility(View.GONE);
		MainMenuActivity dashboardActivity = ((MainMenuActivity) getSherlockActivity());
		if (dashboardActivity != null) {
			dashboardActivity.updateDownloads();
			view.findViewById(R.id.map_image).setVisibility(View.VISIBLE);
		}
	}

	@Override
	public void tileDownloaded(DownloadRequest request) {
		if (request != null && !request.error && request.fileToSave != null) {
			ResourceManager mgr = getMyApplication().getResourceManager();
			mgr.tileDownloaded(request);
		}
		setMapImage(getView());
	}

	private void updateMapImage() {
		MapRenderRepositories repositories = getMyApplication().getResourceManager().getRenderer();
		LatLon lm = getMyApplication().getSettings().getLastKnownMapLocation();
		int zm = getMyApplication().getSettings().getLastKnownMapZoom();

		WindowManager wm = (WindowManager) getActivity().getSystemService(Context.WINDOW_SERVICE);
		Display display = wm.getDefaultDisplay();
		int height = (int) getActivity().getResources().getDimension(R.dimen.dashMapHeight);
		int width = display.getWidth();

		RotatedTileBox rotatedTileBox = new RotatedTileBox.RotatedTileBoxBuilder().
				setZoom(zm).setLocation(lm.getLatitude(), lm.getLongitude()).
				setPixelDimensions(width, height).build();
		repositories.loadMap(rotatedTileBox,
				getMyApplication().getResourceManager().getMapTileDownloader().getDownloaderCallbacks());
	}
}
!@#$%
20190530_022520,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_b11976
package net.osmand.plus.activities;


import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map.Entry;

import net.osmand.CallbackWithObject;
import net.osmand.ResultMatcher;
import net.osmand.StateChangedListener;
import net.osmand.access.AccessibleToast;
import net.osmand.map.ITileSource;
import net.osmand.map.TileSourceManager.TileSourceTemplate;
import net.osmand.osm.PoiCategory;
import net.osmand.plus.ContextMenuAdapter;
import net.osmand.plus.ContextMenuAdapter.Item;
import net.osmand.plus.GPXUtilities.GPXFile;
import net.osmand.plus.GPXUtilities.WptPt;
import net.osmand.plus.OsmandApplication;
import net.osmand.plus.OsmandPlugin;
import net.osmand.plus.OsmandSettings;
import net.osmand.plus.OsmandSettings.CommonPreference;
import net.osmand.plus.R;
import net.osmand.plus.SQLiteTileSource;
import net.osmand.plus.helpers.GpxUiHelper;
import net.osmand.plus.poi.PoiFiltersHelper;
import net.osmand.plus.poi.PoiLegacyFilter;
import net.osmand.plus.rastermaps.OsmandRasterMapsPlugin;
import net.osmand.plus.render.MapVectorLayer;
import net.osmand.plus.render.RenderingIcons;
import net.osmand.plus.routing.RoutingHelper;
import net.osmand.plus.views.ContextMenuLayer;
import net.osmand.plus.views.DownloadedRegionsLayer;
import net.osmand.plus.views.FavoritesLayer;
import net.osmand.plus.views.GPXLayer;
import net.osmand.plus.views.MapControlsLayer;
import net.osmand.plus.views.MapInfoLayer;
import net.osmand.plus.views.MapTextLayer;
import net.osmand.plus.views.MapTileLayer;
import net.osmand.plus.views.OsmandMapTileView;
import net.osmand.plus.views.POIMapLayer;
import net.osmand.plus.views.PointLocationLayer;
import net.osmand.plus.views.PointNavigationLayer;
import net.osmand.plus.views.RouteLayer;
import net.osmand.plus.views.TransportInfoLayer;
import net.osmand.plus.views.TransportStopsLayer;
import android.app.AlertDialog;
import android.app.AlertDialog.Builder;
import android.content.DialogInterface;
import android.content.Intent;
import android.widget.ListAdapter;
import android.widget.Toast;

/**
 * Object is responsible to maintain layers using by map activity 
 */
public class MapActivityLayers {

	private final MapActivity activity;
	
	// the order of layer should be preserved ! when you are inserting new layer
	private MapTileLayer mapTileLayer; 
	private MapVectorLayer mapVectorLayer;
	private GPXLayer gpxLayer;
	private RouteLayer routeLayer;
	private POIMapLayer poiMapLayer;
	private FavoritesLayer favoritesLayer;
	private TransportStopsLayer transportStopsLayer;
	private TransportInfoLayer transportInfoLayer;
	private PointLocationLayer locationLayer;
	private PointNavigationLayer navigationLayer;
	private MapInfoLayer mapInfoLayer;
	private MapTextLayer mapTextLayer;
	private ContextMenuLayer contextMenuLayer;
	private MapControlsLayer mapControlsLayer;
	private DownloadedRegionsLayer downloadedRegionsLayer;

	public MapActivityLayers(MapActivity activity) {
		this.activity = activity;
	}

	public OsmandApplication getApplication(){
		return (OsmandApplication) activity.getApplication();
	}
	
	
	public void createLayers(final OsmandMapTileView mapView){
		
		OsmandApplication app = (OsmandApplication) getApplication();
		RoutingHelper routingHelper = app.getRoutingHelper();
		// first create to make accessible
		mapTextLayer = new MapTextLayer();
		// 5.95 all labels
		mapView.addLayer(mapTextLayer, 5.95f);
		// mapView.addLayer(underlayLayer, -0.5f);
		mapTileLayer = new MapTileLayer(true);
		mapView.addLayer(mapTileLayer, 0.0f);
		mapView.setMainLayer(mapTileLayer);
		
		// 0.5 layer
		mapVectorLayer = new MapVectorLayer(mapTileLayer, false);
		mapView.addLayer(mapVectorLayer, 0.5f);

		downloadedRegionsLayer = new DownloadedRegionsLayer();
		mapView.addLayer(downloadedRegionsLayer, 0.5f);

		// 0.9 gpx layer
		gpxLayer = new GPXLayer();
		mapView.addLayer(gpxLayer, 0.9f);
		
		// 1. route layer
		routeLayer = new RouteLayer(routingHelper);
		mapView.addLayer(routeLayer, 1);
		
		// 2. osm bugs layer
		// 3. poi layer
		poiMapLayer = new POIMapLayer(activity);
		// 4. favorites layer
		favoritesLayer = new FavoritesLayer();
		// 5. transport layer
		transportStopsLayer = new TransportStopsLayer();
		// 5.5 transport info layer 
		transportInfoLayer = new TransportInfoLayer(TransportRouteHelper.getInstance());
		mapView.addLayer(transportInfoLayer, 5.5f);
		// 5.95 all text labels
		// 6. point location layer 
		locationLayer = new PointLocationLayer(activity.getMapViewTrackingUtilities());
		mapView.addLayer(locationLayer, 6);
		// 7. point navigation layer
		navigationLayer = new PointNavigationLayer(activity);
		mapView.addLayer(navigationLayer, 7);
		// 8. context menu layer 
		contextMenuLayer = new ContextMenuLayer(activity);
		mapView.addLayer(contextMenuLayer, 8);
		// 9. map info layer
		mapInfoLayer = new MapInfoLayer(activity, routeLayer);
		mapView.addLayer(mapInfoLayer, 9);
		// 11. route info layer
		mapControlsLayer = new MapControlsLayer(activity);
		mapView.addLayer(mapControlsLayer, 11);
		
		app.getSettings().MAP_TRANSPARENCY.addListener(new StateChangedListener<Integer>() {
			@Override
			public void stateChanged(Integer change) {
				mapTileLayer.setAlpha(change);
				mapVectorLayer.setAlpha(change);
				mapView.refreshMap();
			}
		});
		
		OsmandPlugin.createLayers(mapView, activity);
		app.getAppCustomization().createLayers(mapView, activity);
	}

	
	public void updateLayers(OsmandMapTileView mapView){
		OsmandSettings settings = getApplication().getSettings();
		updateMapSource(mapView, settings.MAP_TILE_SOURCES);
		boolean showStops = settings.getCustomRenderBooleanProperty(OsmandSettings.TRANSPORT_STOPS_OVER_MAP).get();
		if(mapView.getLayers().contains(transportStopsLayer) != showStops){
			if(showStops){
				mapView.addLayer(transportStopsLayer, 5);
			} else {
				mapView.removeLayer(transportStopsLayer);
			}
		}

		if(mapView.getLayers().contains(poiMapLayer) != settings.SHOW_POI_OVER_MAP.get()){
			if(settings.SHOW_POI_OVER_MAP.get()){
				mapView.addLayer(poiMapLayer, 3);
			} else {
				mapView.removeLayer(poiMapLayer);
			}
		}
		
		if(mapView.getLayers().contains(favoritesLayer) != settings.SHOW_FAVORITES.get()){
			if(settings.SHOW_FAVORITES.get()){
				mapView.addLayer(favoritesLayer, 4);
			} else {
				mapView.removeLayer(favoritesLayer);
			}
		}
		OsmandPlugin.refreshLayers(mapView, activity);
	}
	
	public void updateMapSource(OsmandMapTileView mapView, CommonPreference<String> settingsToWarnAboutMap){
		OsmandSettings settings = getApplication().getSettings();
		
		// update transparency
		int mapTransparency = settings.MAP_UNDERLAY.get() == null ? 255 : settings.MAP_TRANSPARENCY.get();
		mapTileLayer.setAlpha(mapTransparency);
		mapVectorLayer.setAlpha(mapTransparency);
		
		ITileSource newSource = settings.getMapTileSource(settings.MAP_TILE_SOURCES == settingsToWarnAboutMap);
		ITileSource oldMap = mapTileLayer.getMap();
		if (newSource != oldMap) {
			if (oldMap instanceof SQLiteTileSource) {
				((SQLiteTileSource) oldMap).closeDB();
			}
			mapTileLayer.setMap(newSource);
		}
		
		boolean vectorData = !settings.MAP_ONLINE_DATA.get();
		mapTileLayer.setVisible(!vectorData);
		mapVectorLayer.setVisible(vectorData);
		if(vectorData){
			mapView.setMainLayer(mapVectorLayer);
		} else {
			mapView.setMainLayer(mapTileLayer);
		}
	}

	
	
	

	public AlertDialog showGPXFileLayer(List<String> files, final OsmandMapTileView mapView) {
		final OsmandSettings settings = getApplication().getSettings();
		CallbackWithObject<GPXFile[]> callbackWithObject = new CallbackWithObject<GPXFile[]>() {
			@Override
			public boolean processResult(GPXFile[] result) {
				WptPt locToShow = null;
				for (GPXFile g : result) {
					if (g.showCurrentTrack) {
						if (!settings.SAVE_TRACK_TO_GPX.get() && !
								settings.SAVE_GLOBAL_TRACK_TO_GPX.get()) {
							AccessibleToast.makeText(activity, R.string.gpx_monitoring_disabled_warn, Toast.LENGTH_LONG).show();
						} else {
							g.path = getString(R.string.show_current_gpx_title);
						}
						break;
					}
					if (!g.showCurrentTrack || locToShow == null) {
						locToShow = g.findPointToShow();
					}
				}
				getApplication().getSelectedGpxHelper().setGpxFileToDisplay(result);
				if (locToShow != null) {
					mapView.getAnimatedDraggingThread().startMoving(locToShow.lat, locToShow.lon,
							mapView.getZoom(), true);
				}
				mapView.refreshMap();
				activity.getMapActions().refreshDrawer();
				return true;
			}
		};

		if (files == null) {
			return GpxUiHelper.selectGPXFile(activity, true, true, callbackWithObject);
		} else {
			return GpxUiHelper.selectGPXFile(files, activity, true, true, callbackWithObject);
		}
	}
	
	
	
	
	
	public AlertDialog selectPOIFilterLayer(final OsmandMapTileView mapView, final PoiLegacyFilter[] selected){
		final List<PoiLegacyFilter> userDefined = new ArrayList<PoiLegacyFilter>();
		OsmandApplication app = (OsmandApplication)getApplication();
		final PoiFiltersHelper poiFilters = app.getPoiFilters();
		final ContextMenuAdapter adapter = new ContextMenuAdapter(activity);
		
		Item is = adapter.item(getString(R.string.any_poi));
		if(RenderingIcons.containsBigIcon("null")) {
			is.icon(RenderingIcons.getBigIconResourceId("null"));
		}
		is.reg();
		// 2nd custom
		adapter.item(getString(R.string.poi_filter_custom_filter)).icon(RenderingIcons.getBigIconResourceId("user_defined")).reg();
		
		for (PoiLegacyFilter f : poiFilters.getUserDefinedPoiFilters()) {
			Item it = adapter.item(f.getName());
			if (RenderingIcons.containsBigIcon(f.getSimplifiedId())) {
				it.icon(RenderingIcons.getBigIconResourceId(f.getSimplifiedId()));
			} else {
				it.icon(RenderingIcons.getBigIconResourceId("user_defined"));
			}
			it.reg();
			userDefined.add(f);
		}
		final List<PoiCategory> categories = getApplication().getPoiTypes().getCategories();
		for(PoiCategory t : categories){
			Item it = adapter.item(t.getTranslation());
			if(RenderingIcons.containsBigIcon(t.getKeyName())) {
				it.icon(RenderingIcons.getBigIconResourceId(t.getKeyName()));
			}
			it.reg();
		}
		Builder builder = new AlertDialog.Builder(activity);
		ListAdapter listAdapter =adapter.createListAdapter(activity, app.getSettings().isLightContent());
		builder.setAdapter(listAdapter, new DialogInterface.OnClickListener(){

			@Override
			public void onClick(DialogInterface dialog, int which) {
				if(which == 1){
					String filterId = PoiLegacyFilter.CUSTOM_FILTER_ID; 
					getApplication().getSettings().setPoiFilterForMap(filterId);
					Intent newIntent = new Intent(activity, EditPOIFilterActivity.class);
					newIntent.putExtra(EditPOIFilterActivity.AMENITY_FILTER, filterId);
					newIntent.putExtra(EditPOIFilterActivity.SEARCH_LAT, mapView.getLatitude());
					newIntent.putExtra(EditPOIFilterActivity.SEARCH_LON, mapView.getLongitude());
					activity.startActivity(newIntent);
				} else {
					String filterId;
					if (which == 0) {
						filterId = PoiFiltersHelper.getOsmDefinedFilterId(null);
					} else if (which <= userDefined.size() + 1) {
						filterId = userDefined.get(which - 2).getFilterId();
					} else {
						filterId = PoiFiltersHelper.getOsmDefinedFilterId(categories.get(which - userDefined.size() - 2));
					}
					getApplication().getSettings().setPoiFilterForMap(filterId);
					PoiLegacyFilter f = poiFilters.getFilterById(filterId);
					if (f != null) {
						f.clearNameFilter();
					}
					poiMapLayer.setFilter(f);
					mapView.refreshMap();
					if(selected != null && selected.length > 0) {
						selected[0] = f;
					}
				}
			}
			
		});
		builder.setNegativeButton(R.string.default_buttons_cancel, null);
		return builder.show();
	}

	public void selectMapLayer(final OsmandMapTileView mapView){
		if(OsmandPlugin.getEnabledPlugin(OsmandRasterMapsPlugin.class) == null) {
			AccessibleToast.makeText(activity, R.string.map_online_plugin_is_not_installed, Toast.LENGTH_LONG).show();
			return;
		}
		final OsmandSettings settings = getApplication().getSettings();
		
		final LinkedHashMap<String, String> entriesMap = new LinkedHashMap<String, String>();
		
		
		final String layerOsmVector = "LAYER_OSM_VECTOR";
		final String layerInstallMore = "LAYER_INSTALL_MORE";
		final String layerEditInstall = "LAYER_EDIT";
		
		entriesMap.put(layerOsmVector, getString(R.string.vector_data));
		entriesMap.putAll(settings.getTileSourceEntries());
		entriesMap.put(layerInstallMore, getString(R.string.install_more));
		entriesMap.put(layerEditInstall, getString(R.string.maps_define_edit));
		
		final List<Entry<String, String>> entriesMapList = new ArrayList<Entry<String, String>>(entriesMap.entrySet());
		
		Builder builder = new AlertDialog.Builder(activity);
		
		String selectedTileSourceKey = settings.MAP_TILE_SOURCES.get();		

		int selectedItem = -1;
		if (!settings.MAP_ONLINE_DATA.get()) {
			selectedItem = 0;
		} else {
		
			Entry<String, String> selectedEntry = null;
			for (Entry<String, String> entry : entriesMap.entrySet()) {
				if (entry.getKey().equals(selectedTileSourceKey)) {
					selectedEntry = entry;
					break;
				}
			}
			if (selectedEntry != null) {
				selectedItem = 0;
				entriesMapList.remove(selectedEntry);
				entriesMapList.add(0, selectedEntry);
			}
		}
		
		final String[] items = new String[entriesMapList.size()];
		int i = 0;
		for (Entry<String, String> entry : entriesMapList) {
			items[i++] = entry.getValue();
		}
		
		builder.setSingleChoiceItems(items, selectedItem, new DialogInterface.OnClickListener(){
			@Override
			public void onClick(DialogInterface dialog, int which) {
				String layerKey = entriesMapList.get(which).getKey();
				if (layerKey.equals(layerOsmVector)) {
					settings.MAP_ONLINE_DATA.set(false);
					updateMapSource(mapView, null);
				} else if (layerKey.equals(layerEditInstall)) {
					OsmandRasterMapsPlugin.defineNewEditLayer(activity, new ResultMatcher<TileSourceTemplate>() {

						@Override
						public boolean publish(TileSourceTemplate object) {
							settings.MAP_TILE_SOURCES.set(object.getName());
							settings.MAP_ONLINE_DATA.set(true);
							updateMapSource(mapView, settings.MAP_TILE_SOURCES);
							return true;
						}

						@Override
						public boolean isCancelled() {
							return false;
						}
						
					});
				} else if (layerKey.equals(layerInstallMore)) {
					OsmandRasterMapsPlugin.installMapLayers(activity, new ResultMatcher<TileSourceTemplate>() {
						TileSourceTemplate template = null;
						int count = 0;
						@Override
						public boolean publish(TileSourceTemplate object) {
							if(object == null){
								if(count == 1){
									settings.MAP_TILE_SOURCES.set(template.getName());
									settings.MAP_ONLINE_DATA.set(true);
									updateMapSource(mapView, settings.MAP_TILE_SOURCES);
								} else {
									selectMapLayer(mapView);
								}
							} else {
								count ++;
								template = object;
							}
							return false;
						}
						
						@Override
						public boolean isCancelled() {
							return false;
						}
					});
				} else {
					settings.MAP_TILE_SOURCES.set(layerKey);
					settings.MAP_ONLINE_DATA.set(true);
					updateMapSource(mapView, settings.MAP_TILE_SOURCES);
				}

				dialog.dismiss();
			}
			
		});
		builder.show();
	}

	
	private String getString(int resId) {
		return activity.getString(resId);
	}

	public PointNavigationLayer getNavigationLayer() {
		return navigationLayer;
	}
	
	public GPXLayer getGpxLayer() {
		return gpxLayer;
	}
	
	public ContextMenuLayer getContextMenuLayer() {
		return contextMenuLayer;
	}
	
	public FavoritesLayer getFavoritesLayer() {
		return favoritesLayer;
	}
	
	public MapTextLayer getMapTextLayer() {
		return mapTextLayer;
	}
	
	public PointLocationLayer getLocationLayer() {
		return locationLayer;
	}
	
	public MapInfoLayer getMapInfoLayer() {
		return mapInfoLayer;
	}
	
	public MapControlsLayer getMapControlsLayer() {
		return mapControlsLayer;
	}
	
	
	public MapTileLayer getMapTileLayer() {
		return mapTileLayer;
	}
	
	public MapVectorLayer getMapVectorLayer() {
		return mapVectorLayer;
	}
	
	public POIMapLayer getPoiMapLayer() {
		return poiMapLayer;
	}
	
	public TransportInfoLayer getTransportInfoLayer() {
		return transportInfoLayer;
	}
	
}
!@#$%
20190530_022520,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_a11976
package net.osmand.plus.activities;


import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map.Entry;

import net.osmand.CallbackWithObject;
import net.osmand.ResultMatcher;
import net.osmand.StateChangedListener;
import net.osmand.access.AccessibleToast;
import net.osmand.map.ITileSource;
import net.osmand.map.TileSourceManager.TileSourceTemplate;
import net.osmand.osm.PoiCategory;
import net.osmand.plus.ContextMenuAdapter;
import net.osmand.plus.ContextMenuAdapter.Item;
import net.osmand.plus.GPXUtilities.GPXFile;
import net.osmand.plus.GPXUtilities.WptPt;
import net.osmand.plus.OsmandApplication;
import net.osmand.plus.OsmandPlugin;
import net.osmand.plus.OsmandSettings;
import net.osmand.plus.OsmandSettings.CommonPreference;
import net.osmand.plus.R;
import net.osmand.plus.SQLiteTileSource;
import net.osmand.plus.helpers.GpxUiHelper;
import net.osmand.plus.poi.PoiFiltersHelper;
import net.osmand.plus.poi.PoiLegacyFilter;
import net.osmand.plus.rastermaps.OsmandRasterMapsPlugin;
import net.osmand.plus.render.MapVectorLayer;
import net.osmand.plus.render.RenderingIcons;
import net.osmand.plus.routing.RoutingHelper;
import net.osmand.plus.views.ContextMenuLayer;
import net.osmand.plus.views.DownloadedRegionsLayer;
import net.osmand.plus.views.FavoritesLayer;
import net.osmand.plus.views.GPXLayer;
import net.osmand.plus.views.MapControlsLayer;
import net.osmand.plus.views.MapInfoLayer;
import net.osmand.plus.views.MapTextLayer;
import net.osmand.plus.views.MapTileLayer;
import net.osmand.plus.views.OsmandMapTileView;
import net.osmand.plus.views.POIMapLayer;
import net.osmand.plus.views.PointLocationLayer;
import net.osmand.plus.views.PointNavigationLayer;
import net.osmand.plus.views.RouteLayer;
import net.osmand.plus.views.TransportInfoLayer;
import net.osmand.plus.views.TransportStopsLayer;
import android.app.AlertDialog;
import android.app.AlertDialog.Builder;
import android.content.DialogInterface;
import android.content.Intent;
import android.widget.ListAdapter;
import android.widget.Toast;

/**
 * Object is responsible to maintain layers using by map activity 
 */
public class MapActivityLayers {

	private final MapActivity activity;
	
	// the order of layer should be preserved ! when you are inserting new layer
	private MapTileLayer mapTileLayer; 
	private MapVectorLayer mapVectorLayer;
	private GPXLayer gpxLayer;
	private RouteLayer routeLayer;
	private POIMapLayer poiMapLayer;
	private FavoritesLayer favoritesLayer;
	private TransportStopsLayer transportStopsLayer;
	private TransportInfoLayer transportInfoLayer;
	private PointLocationLayer locationLayer;
	private PointNavigationLayer navigationLayer;
	private MapInfoLayer mapInfoLayer;
	private MapTextLayer mapTextLayer;
	private ContextMenuLayer contextMenuLayer;
	private MapControlsLayer mapControlsLayer;
	private DownloadedRegionsLayer downloadedRegionsLayer;

	public MapActivityLayers(MapActivity activity) {
		this.activity = activity;
	}

	public OsmandApplication getApplication(){
		return (OsmandApplication) activity.getApplication();
	}
	
	
	public void createLayers(final OsmandMapTileView mapView){
		
		OsmandApplication app = (OsmandApplication) getApplication();
		RoutingHelper routingHelper = app.getRoutingHelper();
		// first create to make accessible
		mapTextLayer = new MapTextLayer();
		// 5.95 all labels
		mapView.addLayer(mapTextLayer, 5.95f);
		// mapView.addLayer(underlayLayer, -0.5f);
		mapTileLayer = new MapTileLayer(true);
		mapView.addLayer(mapTileLayer, 0.0f);
		mapView.setMainLayer(mapTileLayer);
		
		// 0.5 layer
		mapVectorLayer = new MapVectorLayer(mapTileLayer, false);
		mapView.addLayer(mapVectorLayer, 0.5f);

		downloadedRegionsLayer = new DownloadedRegionsLayer();
		mapView.addLayer(downloadedRegionsLayer, 0.5f);

		// 0.9 gpx layer
		gpxLayer = new GPXLayer();
		mapView.addLayer(gpxLayer, 0.9f);
		
		// 1. route layer
		routeLayer = new RouteLayer(routingHelper);
		mapView.addLayer(routeLayer, 1);
		
		// 2. osm bugs layer
		// 3. poi layer
		poiMapLayer = new POIMapLayer(activity);
		// 4. favorites layer
		favoritesLayer = new FavoritesLayer();
		// 5. transport layer
		transportStopsLayer = new TransportStopsLayer();
		// 5.5 transport info layer 
		transportInfoLayer = new TransportInfoLayer(TransportRouteHelper.getInstance());
		mapView.addLayer(transportInfoLayer, 5.5f);
		// 5.95 all text labels
		// 6. point location layer 
		locationLayer = new PointLocationLayer(activity.getMapViewTrackingUtilities());
		mapView.addLayer(locationLayer, 6);
		// 7. point navigation layer
		navigationLayer = new PointNavigationLayer(activity);
		mapView.addLayer(navigationLayer, 7);
		// 8. context menu layer 
		contextMenuLayer = new ContextMenuLayer(activity);
		mapView.addLayer(contextMenuLayer, 8);
		// 9. map info layer
		mapInfoLayer = new MapInfoLayer(activity, routeLayer);
		mapView.addLayer(mapInfoLayer, 9);
		// 11. route info layer
		mapControlsLayer = new MapControlsLayer(activity);
		mapView.addLayer(mapControlsLayer, 11);
		
		app.getSettings().MAP_TRANSPARENCY.addListener(new StateChangedListener<Integer>() {
			@Override
			public void stateChanged(Integer change) {
				mapTileLayer.setAlpha(change);
				mapVectorLayer.setAlpha(change);
				mapView.refreshMap();
			}
		});
		
		OsmandPlugin.createLayers(mapView, activity);
		app.getAppCustomization().createLayers(mapView, activity);
	}

	
	public void updateLayers(OsmandMapTileView mapView){
		OsmandSettings settings = getApplication().getSettings();
		updateMapSource(mapView, settings.MAP_TILE_SOURCES);
		boolean showStops = settings.getCustomRenderBooleanProperty(OsmandSettings.TRANSPORT_STOPS_OVER_MAP).get();
		if(mapView.getLayers().contains(transportStopsLayer) != showStops){
			if(showStops){
				mapView.addLayer(transportStopsLayer, 5);
			} else {
				mapView.removeLayer(transportStopsLayer);
			}
		}
		

		if(mapView.getLayers().contains(poiMapLayer) != settings.SHOW_POI_OVER_MAP.get()){
			if(settings.SHOW_POI_OVER_MAP.get()){
				mapView.addLayer(poiMapLayer, 3);
			} else {
				mapView.removeLayer(poiMapLayer);
			}
		}
		
		if(mapView.getLayers().contains(favoritesLayer) != settings.SHOW_FAVORITES.get()){
			if(settings.SHOW_FAVORITES.get()){
				mapView.addLayer(favoritesLayer, 4);
			} else {
				mapView.removeLayer(favoritesLayer);
			}
		}
		OsmandPlugin.refreshLayers(mapView, activity);
	}
	
	public void updateMapSource(OsmandMapTileView mapView, CommonPreference<String> settingsToWarnAboutMap){
		OsmandSettings settings = getApplication().getSettings();
		
		// update transparency
		int mapTransparency = settings.MAP_UNDERLAY.get() == null ? 255 : settings.MAP_TRANSPARENCY.get();
		mapTileLayer.setAlpha(mapTransparency);
		mapVectorLayer.setAlpha(mapTransparency);
		
		ITileSource newSource = settings.getMapTileSource(settings.MAP_TILE_SOURCES == settingsToWarnAboutMap);
		ITileSource oldMap = mapTileLayer.getMap();
		if (newSource != oldMap) {
			if (oldMap instanceof SQLiteTileSource) {
				((SQLiteTileSource) oldMap).closeDB();
			}
			mapTileLayer.setMap(newSource);
		}
		
		boolean vectorData = !settings.MAP_ONLINE_DATA.get();
		mapTileLayer.setVisible(!vectorData);
		mapVectorLayer.setVisible(vectorData);
		if(vectorData){
			mapView.setMainLayer(mapVectorLayer);
		} else {
			mapView.setMainLayer(mapTileLayer);
		}
	}

	
	
	

	public AlertDialog showGPXFileLayer(List<String> files, final OsmandMapTileView mapView) {
		final OsmandSettings settings = getApplication().getSettings();
		CallbackWithObject<GPXFile[]> callbackWithObject = new CallbackWithObject<GPXFile[]>() {
			@Override
			public boolean processResult(GPXFile[] result) {
				WptPt locToShow = null;
				for (GPXFile g : result) {
					if (g.showCurrentTrack) {
						if (!settings.SAVE_TRACK_TO_GPX.get() && !
								settings.SAVE_GLOBAL_TRACK_TO_GPX.get()) {
							AccessibleToast.makeText(activity, R.string.gpx_monitoring_disabled_warn, Toast.LENGTH_LONG).show();
						} else {
							g.path = getString(R.string.show_current_gpx_title);
						}
						break;
					}
					if (!g.showCurrentTrack || locToShow == null) {
						locToShow = g.findPointToShow();
					}
				}
				getApplication().getSelectedGpxHelper().setGpxFileToDisplay(result);
				if (locToShow != null) {
					mapView.getAnimatedDraggingThread().startMoving(locToShow.lat, locToShow.lon,
							mapView.getZoom(), true);
				}
				mapView.refreshMap();
				activity.getMapActions().refreshDrawer();
				return true;
			}
		};

		if (files == null) {
			return GpxUiHelper.selectGPXFile(activity, true, true, callbackWithObject);
		} else {
			return GpxUiHelper.selectGPXFile(files, activity, true, true, callbackWithObject);
		}
	}
	
	
	
	
	
	public AlertDialog selectPOIFilterLayer(final OsmandMapTileView mapView, final PoiLegacyFilter[] selected){
		final List<PoiLegacyFilter> userDefined = new ArrayList<PoiLegacyFilter>();
		OsmandApplication app = (OsmandApplication)getApplication();
		final PoiFiltersHelper poiFilters = app.getPoiFilters();
		final ContextMenuAdapter adapter = new ContextMenuAdapter(activity);
		
		Item is = adapter.item(getString(R.string.any_poi));
		if(RenderingIcons.containsBigIcon("null")) {
			is.icon(RenderingIcons.getBigIconResourceId("null"));
		}
		is.reg();
		// 2nd custom
		adapter.item(getString(R.string.poi_filter_custom_filter)).icon(RenderingIcons.getBigIconResourceId("user_defined")).reg();
		
		for (PoiLegacyFilter f : poiFilters.getUserDefinedPoiFilters()) {
			Item it = adapter.item(f.getName());
			if (RenderingIcons.containsBigIcon(f.getSimplifiedId())) {
				it.icon(RenderingIcons.getBigIconResourceId(f.getSimplifiedId()));
			} else {
				it.icon(RenderingIcons.getBigIconResourceId("user_defined"));
			}
			it.reg();
			userDefined.add(f);
		}
		final List<PoiCategory> categories = getApplication().getPoiTypes().getCategories();
		for(PoiCategory t : categories){
			Item it = adapter.item(t.getTranslation());
			if(RenderingIcons.containsBigIcon(t.getKeyName())) {
				it.icon(RenderingIcons.getBigIconResourceId(t.getKeyName()));
			}
			it.reg();
		}
		Builder builder = new AlertDialog.Builder(activity);
		ListAdapter listAdapter =adapter.createListAdapter(activity, app.getSettings().isLightContent());
		builder.setAdapter(listAdapter, new DialogInterface.OnClickListener(){

			@Override
			public void onClick(DialogInterface dialog, int which) {
				if(which == 1){
					String filterId = PoiLegacyFilter.CUSTOM_FILTER_ID; 
					getApplication().getSettings().setPoiFilterForMap(filterId);
					Intent newIntent = new Intent(activity, EditPOIFilterActivity.class);
					newIntent.putExtra(EditPOIFilterActivity.AMENITY_FILTER, filterId);
					newIntent.putExtra(EditPOIFilterActivity.SEARCH_LAT, mapView.getLatitude());
					newIntent.putExtra(EditPOIFilterActivity.SEARCH_LON, mapView.getLongitude());
					activity.startActivity(newIntent);
				} else {
					String filterId;
					if (which == 0) {
						filterId = PoiFiltersHelper.getOsmDefinedFilterId(null);
					} else if (which <= userDefined.size() + 1) {
						filterId = userDefined.get(which - 2).getFilterId();
					} else {
						filterId = PoiFiltersHelper.getOsmDefinedFilterId(categories.get(which - userDefined.size() - 2));
					}
					getApplication().getSettings().setPoiFilterForMap(filterId);
					PoiLegacyFilter f = poiFilters.getFilterById(filterId);
					if (f != null) {
						f.clearNameFilter();
					}
					poiMapLayer.setFilter(f);
					mapView.refreshMap();
					if(selected != null && selected.length > 0) {
						selected[0] = f;
					}
				}
			}
			
		});
		builder.setNegativeButton(R.string.default_buttons_cancel, null);
		return builder.show();
	}

	public void selectMapLayer(final OsmandMapTileView mapView){
		if(OsmandPlugin.getEnabledPlugin(OsmandRasterMapsPlugin.class) == null) {
			AccessibleToast.makeText(activity, R.string.map_online_plugin_is_not_installed, Toast.LENGTH_LONG).show();
			return;
		}
		final OsmandSettings settings = getApplication().getSettings();
		
		final LinkedHashMap<String, String> entriesMap = new LinkedHashMap<String, String>();
		
		
		final String layerOsmVector = "LAYER_OSM_VECTOR";
		final String layerInstallMore = "LAYER_INSTALL_MORE";
		final String layerEditInstall = "LAYER_EDIT";
		
		entriesMap.put(layerOsmVector, getString(R.string.vector_data));
		entriesMap.putAll(settings.getTileSourceEntries());
		entriesMap.put(layerInstallMore, getString(R.string.install_more));
		entriesMap.put(layerEditInstall, getString(R.string.maps_define_edit));
		
		final List<Entry<String, String>> entriesMapList = new ArrayList<Entry<String, String>>(entriesMap.entrySet());
		
		Builder builder = new AlertDialog.Builder(activity);
		
		String selectedTileSourceKey = settings.MAP_TILE_SOURCES.get();		

		int selectedItem = -1;
		if (!settings.MAP_ONLINE_DATA.get()) {
			selectedItem = 0;
		} else {
		
			Entry<String, String> selectedEntry = null;
			for (Entry<String, String> entry : entriesMap.entrySet()) {
				if (entry.getKey().equals(selectedTileSourceKey)) {
					selectedEntry = entry;
					break;
				}
			}
			if (selectedEntry != null) {
				selectedItem = 0;
				entriesMapList.remove(selectedEntry);
				entriesMapList.add(0, selectedEntry);
			}
		}
		
		final String[] items = new String[entriesMapList.size()];
		int i = 0;
		for (Entry<String, String> entry : entriesMapList) {
			items[i++] = entry.getValue();
		}
		
		builder.setSingleChoiceItems(items, selectedItem, new DialogInterface.OnClickListener(){
			@Override
			public void onClick(DialogInterface dialog, int which) {
				String layerKey = entriesMapList.get(which).getKey();
				if (layerKey.equals(layerOsmVector)) {
					settings.MAP_ONLINE_DATA.set(false);
					updateMapSource(mapView, null);
				} else if (layerKey.equals(layerEditInstall)) {
					OsmandRasterMapsPlugin.defineNewEditLayer(activity, new ResultMatcher<TileSourceTemplate>() {

						@Override
						public boolean publish(TileSourceTemplate object) {
							settings.MAP_TILE_SOURCES.set(object.getName());
							settings.MAP_ONLINE_DATA.set(true);
							updateMapSource(mapView, settings.MAP_TILE_SOURCES);
							return true;
						}

						@Override
						public boolean isCancelled() {
							return false;
						}
						
					});
				} else if (layerKey.equals(layerInstallMore)) {
					OsmandRasterMapsPlugin.installMapLayers(activity, new ResultMatcher<TileSourceTemplate>() {
						TileSourceTemplate template = null;
						int count = 0;
						@Override
						public boolean publish(TileSourceTemplate object) {
							if(object == null){
								if(count == 1){
									settings.MAP_TILE_SOURCES.set(template.getName());
									settings.MAP_ONLINE_DATA.set(true);
									updateMapSource(mapView, settings.MAP_TILE_SOURCES);
								} else {
									selectMapLayer(mapView);
								}
							} else {
								count ++;
								template = object;
							}
							return false;
						}
						
						@Override
						public boolean isCancelled() {
							return false;
						}
					});
				} else {
					settings.MAP_TILE_SOURCES.set(layerKey);
					settings.MAP_ONLINE_DATA.set(true);
					updateMapSource(mapView, settings.MAP_TILE_SOURCES);
				}

				dialog.dismiss();
			}
			
		});
		builder.show();
	}

	
	private String getString(int resId) {
		return activity.getString(resId);
	}

	public PointNavigationLayer getNavigationLayer() {
		return navigationLayer;
	}
	
	public GPXLayer getGpxLayer() {
		return gpxLayer;
	}
	
	public ContextMenuLayer getContextMenuLayer() {
		return contextMenuLayer;
	}
	
	public FavoritesLayer getFavoritesLayer() {
		return favoritesLayer;
	}
	
	public MapTextLayer getMapTextLayer() {
		return mapTextLayer;
	}
	
	public PointLocationLayer getLocationLayer() {
		return locationLayer;
	}
	
	public MapInfoLayer getMapInfoLayer() {
		return mapInfoLayer;
	}
	
	public MapControlsLayer getMapControlsLayer() {
		return mapControlsLayer;
	}
	
	
	public MapTileLayer getMapTileLayer() {
		return mapTileLayer;
	}
	
	public MapVectorLayer getMapVectorLayer() {
		return mapVectorLayer;
	}
	
	public POIMapLayer getPoiMapLayer() {
		return poiMapLayer;
	}
	
	public TransportInfoLayer getTransportInfoLayer() {
		return transportInfoLayer;
	}
	
}
!@#$%
20190530_022520,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_c11976
package net.osmand.plus.activities;


import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map.Entry;

import net.osmand.CallbackWithObject;
import net.osmand.ResultMatcher;
import net.osmand.StateChangedListener;
import net.osmand.access.AccessibleToast;
import net.osmand.map.ITileSource;
import net.osmand.map.TileSourceManager.TileSourceTemplate;
import net.osmand.osm.PoiCategory;
import net.osmand.plus.ContextMenuAdapter;
import net.osmand.plus.ContextMenuAdapter.Item;
import net.osmand.plus.GPXUtilities.GPXFile;
import net.osmand.plus.GPXUtilities.WptPt;
import net.osmand.plus.OsmandApplication;
import net.osmand.plus.OsmandPlugin;
import net.osmand.plus.OsmandSettings;
import net.osmand.plus.OsmandSettings.CommonPreference;
import net.osmand.plus.R;
import net.osmand.plus.SQLiteTileSource;
import net.osmand.plus.helpers.GpxUiHelper;
import net.osmand.plus.poi.PoiFiltersHelper;
import net.osmand.plus.poi.PoiLegacyFilter;
import net.osmand.plus.rastermaps.OsmandRasterMapsPlugin;
import net.osmand.plus.render.MapVectorLayer;
import net.osmand.plus.render.RenderingIcons;
import net.osmand.plus.routing.RoutingHelper;
import net.osmand.plus.views.ContextMenuLayer;
import net.osmand.plus.views.DownloadedRegionsLayer;
import net.osmand.plus.views.FavoritesLayer;
import net.osmand.plus.views.GPXLayer;
import net.osmand.plus.views.MapControlsLayer;
import net.osmand.plus.views.MapInfoLayer;
import net.osmand.plus.views.MapTextLayer;
import net.osmand.plus.views.MapTileLayer;
import net.osmand.plus.views.OsmandMapTileView;
import net.osmand.plus.views.POIMapLayer;
import net.osmand.plus.views.PointLocationLayer;
import net.osmand.plus.views.PointNavigationLayer;
import net.osmand.plus.views.RouteLayer;
import net.osmand.plus.views.TransportInfoLayer;
import net.osmand.plus.views.TransportStopsLayer;
import android.app.AlertDialog;
import android.app.AlertDialog.Builder;
import android.content.DialogInterface;
import android.content.Intent;
import android.widget.ListAdapter;
import android.widget.Toast;

/**
 * Object is responsible to maintain layers using by map activity 
 */
public class MapActivityLayers {

	private final MapActivity activity;
	
	// the order of layer should be preserved ! when you are inserting new layer
	private MapTileLayer mapTileLayer; 
	private MapVectorLayer mapVectorLayer;
	private GPXLayer gpxLayer;
	private RouteLayer routeLayer;
	private POIMapLayer poiMapLayer;
	private FavoritesLayer favoritesLayer;
	private TransportStopsLayer transportStopsLayer;
	private TransportInfoLayer transportInfoLayer;
	private PointLocationLayer locationLayer;
	private PointNavigationLayer navigationLayer;
	private MapInfoLayer mapInfoLayer;
	private MapTextLayer mapTextLayer;
	private ContextMenuLayer contextMenuLayer;
	private MapControlsLayer mapControlsLayer;
	private DownloadedRegionsLayer downloadedRegionsLayer;

	public MapActivityLayers(MapActivity activity) {
		this.activity = activity;
	}

	public OsmandApplication getApplication(){
		return (OsmandApplication) activity.getApplication();
	}
	
	
	public void createLayers(final OsmandMapTileView mapView){
		
		OsmandApplication app = (OsmandApplication) getApplication();
		RoutingHelper routingHelper = app.getRoutingHelper();
		// first create to make accessible
		mapTextLayer = new MapTextLayer();
		// 5.95 all labels
		mapView.addLayer(mapTextLayer, 5.95f);
		// mapView.addLayer(underlayLayer, -0.5f);
		mapTileLayer = new MapTileLayer(true);
		mapView.addLayer(mapTileLayer, 0.0f);
		mapView.setMainLayer(mapTileLayer);
		
		// 0.5 layer
		mapVectorLayer = new MapVectorLayer(mapTileLayer, false);
		mapView.addLayer(mapVectorLayer, 0.5f);

		downloadedRegionsLayer = new DownloadedRegionsLayer();
		mapView.addLayer(downloadedRegionsLayer, 0.5f);

		// 0.9 gpx layer
		gpxLayer = new GPXLayer();
		mapView.addLayer(gpxLayer, 0.9f);
		
		// 1. route layer
		routeLayer = new RouteLayer(routingHelper);
		mapView.addLayer(routeLayer, 1);
		
		// 2. osm bugs layer
		// 3. poi layer
		poiMapLayer = new POIMapLayer(activity);
		// 4. favorites layer
		favoritesLayer = new FavoritesLayer();
		// 5. transport layer
		transportStopsLayer = new TransportStopsLayer();
		// 5.5 transport info layer 
		transportInfoLayer = new TransportInfoLayer(TransportRouteHelper.getInstance());
		mapView.addLayer(transportInfoLayer, 5.5f);
		// 5.95 all text labels
		// 6. point location layer 
		locationLayer = new PointLocationLayer(activity.getMapViewTrackingUtilities());
		mapView.addLayer(locationLayer, 6);
		// 7. point navigation layer
		navigationLayer = new PointNavigationLayer(activity);
		mapView.addLayer(navigationLayer, 7);
		// 8. context menu layer 
		contextMenuLayer = new ContextMenuLayer(activity);
		mapView.addLayer(contextMenuLayer, 8);
		// 9. map info layer
		mapInfoLayer = new MapInfoLayer(activity, routeLayer);
		mapView.addLayer(mapInfoLayer, 9);
		// 11. route info layer
		mapControlsLayer = new MapControlsLayer(activity);
		mapView.addLayer(mapControlsLayer, 11);
		
		app.getSettings().MAP_TRANSPARENCY.addListener(new StateChangedListener<Integer>() {
			@Override
			public void stateChanged(Integer change) {
				mapTileLayer.setAlpha(change);
				mapVectorLayer.setAlpha(change);
				mapView.refreshMap();
			}
		});
		
		OsmandPlugin.createLayers(mapView, activity);
		app.getAppCustomization().createLayers(mapView, activity);
	}

	
	public void updateLayers(OsmandMapTileView mapView){
		OsmandSettings settings = getApplication().getSettings();
		updateMapSource(mapView, settings.MAP_TILE_SOURCES);
		boolean showStops = settings.getCustomRenderBooleanProperty(OsmandSettings.TRANSPORT_STOPS_OVER_MAP).get();
		if(mapView.getLayers().contains(transportStopsLayer) != showStops){
			if(showStops){
				mapView.addLayer(transportStopsLayer, 5);
			} else {
				mapView.removeLayer(transportStopsLayer);
			}
		}
		

		if(mapView.getLayers().contains(poiMapLayer) != settings.SHOW_POI_OVER_MAP.get()){
			if(settings.SHOW_POI_OVER_MAP.get()){
				mapView.addLayer(poiMapLayer, 3);
			} else {
				mapView.removeLayer(poiMapLayer);
			}
		}
		
		if(mapView.getLayers().contains(favoritesLayer) != settings.SHOW_FAVORITES.get()){
			if(settings.SHOW_FAVORITES.get()){
				mapView.addLayer(favoritesLayer, 4);
			} else {
				mapView.removeLayer(favoritesLayer);
			}
		}
		OsmandPlugin.refreshLayers(mapView, activity);
	}
	
	public void updateMapSource(OsmandMapTileView mapView, CommonPreference<String> settingsToWarnAboutMap){
		OsmandSettings settings = getApplication().getSettings();
		
		// update transparency
		int mapTransparency = settings.MAP_UNDERLAY.get() == null ? 255 : settings.MAP_TRANSPARENCY.get();
		mapTileLayer.setAlpha(mapTransparency);
		mapVectorLayer.setAlpha(mapTransparency);
		
		ITileSource newSource = settings.getMapTileSource(settings.MAP_TILE_SOURCES == settingsToWarnAboutMap);
		ITileSource oldMap = mapTileLayer.getMap();
		if (newSource != oldMap) {
			if (oldMap instanceof SQLiteTileSource) {
				((SQLiteTileSource) oldMap).closeDB();
			}
			mapTileLayer.setMap(newSource);
		}
		
		boolean vectorData = !settings.MAP_ONLINE_DATA.get();
		mapTileLayer.setVisible(!vectorData);
		mapVectorLayer.setVisible(vectorData);
		if(vectorData){
			mapView.setMainLayer(mapVectorLayer);
		} else {
			mapView.setMainLayer(mapTileLayer);
		}
	}

	
	
	

	public AlertDialog showGPXFileLayer(List<String> files, final OsmandMapTileView mapView) {
		final OsmandSettings settings = getApplication().getSettings();
		CallbackWithObject<GPXFile[]> callbackWithObject = new CallbackWithObject<GPXFile[]>() {
			@Override
			public boolean processResult(GPXFile[] result) {
				WptPt locToShow = null;
				for (GPXFile g : result) {
					if (g.showCurrentTrack) {
						if (!settings.SAVE_TRACK_TO_GPX.get() && !
								settings.SAVE_GLOBAL_TRACK_TO_GPX.get()) {
							AccessibleToast.makeText(activity, R.string.gpx_monitoring_disabled_warn, Toast.LENGTH_LONG).show();
						} else {
							g.path = getString(R.string.show_current_gpx_title);
						}
						break;
					}
					if (!g.showCurrentTrack || locToShow == null) {
						locToShow = g.findPointToShow();
					}
				}
				getApplication().getSelectedGpxHelper().setGpxFileToDisplay(result);
				if (locToShow != null) {
					mapView.getAnimatedDraggingThread().startMoving(locToShow.lat, locToShow.lon,
							mapView.getZoom(), true);
				}
				mapView.refreshMap();
				activity.getMapActions().refreshDrawer();
				return true;
			}
		};

		if (files == null) {
			return GpxUiHelper.selectGPXFile(activity, true, true, callbackWithObject);
		} else {
			return GpxUiHelper.selectGPXFile(files, activity, true, true, callbackWithObject);
		}
	}
	
	
	
	
	
	public AlertDialog selectPOIFilterLayer(final OsmandMapTileView mapView, final PoiLegacyFilter[] selected){
		final List<PoiLegacyFilter> userDefined = new ArrayList<PoiLegacyFilter>();
		OsmandApplication app = (OsmandApplication)getApplication();
		final PoiFiltersHelper poiFilters = app.getPoiFilters();
		final ContextMenuAdapter adapter = new ContextMenuAdapter(activity);
		
		Item is = adapter.item(getString(R.string.any_poi));
		if(RenderingIcons.containsBigIcon("null")) {
			is.icon(RenderingIcons.getBigIconResourceId("null"));
		}
		is.reg();
		// 2nd custom
		adapter.item(getString(R.string.poi_filter_custom_filter)).icon(RenderingIcons.getBigIconResourceId("user_defined")).reg();
		
		for (PoiLegacyFilter f : poiFilters.getUserDefinedPoiFilters()) {
			Item it = adapter.item(f.getName());
			if (RenderingIcons.containsBigIcon(f.getSimplifiedId())) {
				it.icon(RenderingIcons.getBigIconResourceId(f.getSimplifiedId()));
			} else {
				it.icon(RenderingIcons.getBigIconResourceId("user_defined"));
			}
			it.reg();
			userDefined.add(f);
		}
		final List<PoiCategory> categories = getApplication().getPoiTypes().getCategories();
		for(PoiCategory t : categories){
			Item it = adapter.item(t.getTranslation());
			if(RenderingIcons.containsBigIcon(t.getKeyName())) {
				it.icon(RenderingIcons.getBigIconResourceId(t.getKeyName()));
			}
			it.reg();
		}
		Builder builder = new AlertDialog.Builder(activity);
		ListAdapter listAdapter =adapter.createListAdapter(activity, app.getSettings().isLightContent());
		builder.setAdapter(listAdapter, new DialogInterface.OnClickListener(){

			@Override
			public void onClick(DialogInterface dialog, int which) {
				if(which == 1){
					String filterId = PoiLegacyFilter.CUSTOM_FILTER_ID; 
					getApplication().getSettings().setPoiFilterForMap(filterId);
					Intent newIntent = new Intent(activity, EditPOIFilterActivity.class);
					newIntent.putExtra(EditPOIFilterActivity.AMENITY_FILTER, filterId);
					newIntent.putExtra(EditPOIFilterActivity.SEARCH_LAT, mapView.getLatitude());
					newIntent.putExtra(EditPOIFilterActivity.SEARCH_LON, mapView.getLongitude());
					activity.startActivity(newIntent);
				} else {
					String filterId;
					if (which == 0) {
						filterId = PoiFiltersHelper.getOsmDefinedFilterId(null);
					} else if (which <= userDefined.size() + 1) {
						filterId = userDefined.get(which - 2).getFilterId();
					} else {
						filterId = PoiFiltersHelper.getOsmDefinedFilterId(categories.get(which - userDefined.size() - 2));
					}
					getApplication().getSettings().setPoiFilterForMap(filterId);
					PoiLegacyFilter f = poiFilters.getFilterById(filterId);
					if (f != null) {
						f.clearNameFilter();
					}
					poiMapLayer.setFilter(f);
					mapView.refreshMap();
					if(selected != null && selected.length > 0) {
						selected[0] = f;
					}
				}
			}
			
		});
		builder.setNegativeButton(R.string.shared_string_cancel, null);
		return builder.show();
	}

	public void selectMapLayer(final OsmandMapTileView mapView){
		if(OsmandPlugin.getEnabledPlugin(OsmandRasterMapsPlugin.class) == null) {
			AccessibleToast.makeText(activity, R.string.map_online_plugin_is_not_installed, Toast.LENGTH_LONG).show();
			return;
		}
		final OsmandSettings settings = getApplication().getSettings();
		
		final LinkedHashMap<String, String> entriesMap = new LinkedHashMap<String, String>();
		
		
		final String layerOsmVector = "LAYER_OSM_VECTOR";
		final String layerInstallMore = "LAYER_INSTALL_MORE";
		final String layerEditInstall = "LAYER_EDIT";
		
		entriesMap.put(layerOsmVector, getString(R.string.vector_data));
		entriesMap.putAll(settings.getTileSourceEntries());
		entriesMap.put(layerInstallMore, getString(R.string.install_more));
		entriesMap.put(layerEditInstall, getString(R.string.maps_define_edit));
		
		final List<Entry<String, String>> entriesMapList = new ArrayList<Entry<String, String>>(entriesMap.entrySet());
		
		Builder builder = new AlertDialog.Builder(activity);
		
		String selectedTileSourceKey = settings.MAP_TILE_SOURCES.get();		

		int selectedItem = -1;
		if (!settings.MAP_ONLINE_DATA.get()) {
			selectedItem = 0;
		} else {
		
			Entry<String, String> selectedEntry = null;
			for (Entry<String, String> entry : entriesMap.entrySet()) {
				if (entry.getKey().equals(selectedTileSourceKey)) {
					selectedEntry = entry;
					break;
				}
			}
			if (selectedEntry != null) {
				selectedItem = 0;
				entriesMapList.remove(selectedEntry);
				entriesMapList.add(0, selectedEntry);
			}
		}
		
		final String[] items = new String[entriesMapList.size()];
		int i = 0;
		for (Entry<String, String> entry : entriesMapList) {
			items[i++] = entry.getValue();
		}
		
		builder.setSingleChoiceItems(items, selectedItem, new DialogInterface.OnClickListener(){
			@Override
			public void onClick(DialogInterface dialog, int which) {
				String layerKey = entriesMapList.get(which).getKey();
				if (layerKey.equals(layerOsmVector)) {
					settings.MAP_ONLINE_DATA.set(false);
					updateMapSource(mapView, null);
				} else if (layerKey.equals(layerEditInstall)) {
					OsmandRasterMapsPlugin.defineNewEditLayer(activity, new ResultMatcher<TileSourceTemplate>() {

						@Override
						public boolean publish(TileSourceTemplate object) {
							settings.MAP_TILE_SOURCES.set(object.getName());
							settings.MAP_ONLINE_DATA.set(true);
							updateMapSource(mapView, settings.MAP_TILE_SOURCES);
							return true;
						}

						@Override
						public boolean isCancelled() {
							return false;
						}
						
					});
				} else if (layerKey.equals(layerInstallMore)) {
					OsmandRasterMapsPlugin.installMapLayers(activity, new ResultMatcher<TileSourceTemplate>() {
						TileSourceTemplate template = null;
						int count = 0;
						@Override
						public boolean publish(TileSourceTemplate object) {
							if(object == null){
								if(count == 1){
									settings.MAP_TILE_SOURCES.set(template.getName());
									settings.MAP_ONLINE_DATA.set(true);
									updateMapSource(mapView, settings.MAP_TILE_SOURCES);
								} else {
									selectMapLayer(mapView);
								}
							} else {
								count ++;
								template = object;
							}
							return false;
						}
						
						@Override
						public boolean isCancelled() {
							return false;
						}
					});
				} else {
					settings.MAP_TILE_SOURCES.set(layerKey);
					settings.MAP_ONLINE_DATA.set(true);
					updateMapSource(mapView, settings.MAP_TILE_SOURCES);
				}

				dialog.dismiss();
			}
			
		});
		builder.show();
	}

	
	private String getString(int resId) {
		return activity.getString(resId);
	}

	public PointNavigationLayer getNavigationLayer() {
		return navigationLayer;
	}
	
	public GPXLayer getGpxLayer() {
		return gpxLayer;
	}
	
	public ContextMenuLayer getContextMenuLayer() {
		return contextMenuLayer;
	}
	
	public FavoritesLayer getFavoritesLayer() {
		return favoritesLayer;
	}
	
	public MapTextLayer getMapTextLayer() {
		return mapTextLayer;
	}
	
	public PointLocationLayer getLocationLayer() {
		return locationLayer;
	}
	
	public MapInfoLayer getMapInfoLayer() {
		return mapInfoLayer;
	}
	
	public MapControlsLayer getMapControlsLayer() {
		return mapControlsLayer;
	}
	
	
	public MapTileLayer getMapTileLayer() {
		return mapTileLayer;
	}
	
	public MapVectorLayer getMapVectorLayer() {
		return mapVectorLayer;
	}
	
	public POIMapLayer getPoiMapLayer() {
		return poiMapLayer;
	}
	
	public TransportInfoLayer getTransportInfoLayer() {
		return transportInfoLayer;
	}
	
}
!@#$%
20190530_023027,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_b12040
package net.osmand.plus.osmedit;

import android.app.AlertDialog;
import android.app.ProgressDialog;
import android.content.DialogInterface;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Button;
import android.widget.ImageButton;
import android.widget.LinearLayout;
import android.widget.TextView;

import net.osmand.data.PointDescription;
import net.osmand.plus.OsmandPlugin;
import net.osmand.plus.ProgressImplementation;
import net.osmand.plus.R;
import net.osmand.plus.activities.MapActivity;
import net.osmand.plus.dashboard.DashBaseFragment;
import net.osmand.plus.myplaces.FavoritesActivity;

import java.util.ArrayList;
import java.util.List;

/**
 * Created by Denis
 * on 20.01.2015.
 */
public class DashOsmEditsFragment extends DashBaseFragment implements OsmEditsUploadListener {
	public static final String TAG = "DASH_OSM_EDITS_FRAGMENT";

	OsmEditingPlugin plugin;

	@Override
	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
		plugin = OsmandPlugin.getEnabledPlugin(OsmEditingPlugin.class);

		View view = getActivity().getLayoutInflater().inflate(R.layout.dash_common_fragment, container, false);
		TextView header = ((TextView) view.findViewById(R.id.fav_text));
		header.setText(R.string.osm_settings);
		Button manage = ((Button) view.findViewById(R.id.show_all));
		manage.setText(R.string.osm_editing_manage);
		(view.findViewById(R.id.show_all)).setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View view) {
				startFavoritesActivity(FavoritesActivity.OSM_EDITS_TAB);
			}
		});

		return view;
	}


	@Override
	public void onOpenDash() {
		if (plugin == null) {
			plugin = OsmandPlugin.getEnabledPlugin(OsmEditingPlugin.class);
		}
		setupEditings();		
	}
	
	private void setupEditings() {
		View mainView = getView();
		if (plugin == null){
			mainView.setVisibility(View.GONE);
			return;
		}

		ArrayList<OsmPoint> dataPoints = new ArrayList<>();
		getOsmPoints(dataPoints);
		if (dataPoints.size() == 0){
			mainView.setVisibility(View.GONE);
			return;
		} else {
			mainView.setVisibility(View.VISIBLE);
		}

		LinearLayout osmLayout = (LinearLayout) mainView.findViewById(R.id.items);
		osmLayout.removeAllViews();

		for (final OsmPoint point : dataPoints){
			LayoutInflater inflater = getActivity().getLayoutInflater();
			View view = inflater.inflate(R.layout.note, null, false);

			OsmEditsFragment.getOsmEditView(view, point, getMyApplication());
			ImageButton send =(ImageButton) view.findViewById(R.id.play);
			send.setImageDrawable(getMyApplication().getIconsCache().getContentIcon(R.drawable.ic_action_export));
			send.setOnClickListener(new View.OnClickListener() {
				@Override
				public void onClick(View v) {
					uploadItem(point);
				}
			});
			view.findViewById(R.id.options).setVisibility(View.GONE);
			view.findViewById(R.id.divider).setVisibility(View.VISIBLE);
			view.setOnClickListener(new View.OnClickListener() {
				@Override
				public void onClick(View v) {
					boolean poi = point.getGroup() == OsmPoint.Group.POI;
					String name = poi ?
							((OpenstreetmapPoint) point).getName() : ((OsmNotesPoint) point).getText();
					getMyApplication().getSettings().setMapLocationToShow(point.getLatitude(), point.getLongitude(),
							15, new PointDescription(poi ? PointDescription.POINT_TYPE_POI : PointDescription.POINT_TYPE_OSM_BUG, name), true,
							point); //$NON-NLS-1$
					MapActivity.launchMapActivityMoveToTop(getActivity());
				}
			});
			osmLayout.addView(view);
		}
	}

	private void uploadItem(final OsmPoint point){
		AlertDialog.Builder b = new AlertDialog.Builder(getActivity());
		b.setMessage(getString(R.string.local_osm_changes_upload_all_confirm, 1));
		b.setPositiveButton(R.string.shared_string_yes, new DialogInterface.OnClickListener() {
			@Override
			public void onClick(DialogInterface dialog, int which) {
				showProgressDialog(point);
			}
		});
		b.setNegativeButton(R.string.shared_string_cancel, null);
		b.show();
	}

	private void showProgressDialog(OsmPoint point) {
		OpenstreetmapRemoteUtil remotepoi = new OpenstreetmapRemoteUtil(getActivity());
		OsmPoint[] toUpload = new OsmPoint[]{point};
		OsmBugsRemoteUtil remotebug = new OsmBugsRemoteUtil(getMyApplication());
		ProgressDialog dialog = ProgressImplementation.createProgressDialog(
				getActivity(),
				getString(R.string.uploading),
				getString(R.string.local_openstreetmap_uploading),
				ProgressDialog.STYLE_HORIZONTAL).getDialog();
		UploadOpenstreetmapPointAsyncTask uploadTask = new UploadOpenstreetmapPointAsyncTask(dialog,DashOsmEditsFragment.this, remotepoi,
				remotebug, toUpload.length);
		uploadTask.execute(toUpload);
		dialog.show();
	}

	private void getOsmPoints(ArrayList<OsmPoint> dataPoints) {
		OpenstreetmapsDbHelper dbpoi = new OpenstreetmapsDbHelper(getActivity());
		OsmBugsDbHelper dbbug = new OsmBugsDbHelper(getActivity());

		List<OpenstreetmapPoint> l1 = dbpoi.getOpenstreetmapPoints();
		List<OsmNotesPoint> l2 = dbbug.getOsmbugsPoints();
		if (l1.isEmpty()){
			int i = 0;
			for(OsmPoint point : l2){
				if (i > 2) {
					break;
				}
				dataPoints.add(point);
				i++;
			}
		} else if (l2.isEmpty()) {
			int i = 0;
			for(OsmPoint point : l1){
				if (i > 2) {
					break;
				}
				dataPoints.add(point);
				i++;
			}
		} else {
			dataPoints.add(l1.get(0));
			dataPoints.add(l2.get(0));
			if (l1.size() > 1){
				dataPoints.add(l1.get(1));
			} else if (l2.size() > 1){
				dataPoints.add(l2.get(1));
			}
		}
	}

	@Override
	public void uploadUpdated(OsmPoint point) {
		if (!this.isDetached()){
			onOpenDash();
		}
	}

	@Override
	public void uploadEnded(Integer result) {
		if (!this.isDetached()){
			onOpenDash();
		}
	}
}
!@#$%
20190530_023027,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_a12040
package net.osmand.plus.osmedit;

import android.app.AlertDialog;
import android.app.ProgressDialog;
import android.content.DialogInterface;
import android.graphics.Typeface;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Button;
import android.widget.ImageButton;
import android.widget.LinearLayout;
import android.widget.TextView;

import net.osmand.data.PointDescription;
import net.osmand.plus.OsmandPlugin;
import net.osmand.plus.ProgressImplementation;
import net.osmand.plus.R;
import net.osmand.plus.activities.MapActivity;
import net.osmand.plus.dashboard.DashBaseFragment;
import net.osmand.plus.helpers.FontCache;
import net.osmand.plus.myplaces.FavoritesActivity;

import java.util.ArrayList;
import java.util.List;

/**
 * Created by Denis
 * on 20.01.2015.
 */
public class DashOsmEditsFragment extends DashBaseFragment implements OsmEditsUploadListener {
	public static final String TAG = "DASH_OSM_EDITS_FRAGMENT";

	OsmEditingPlugin plugin;

	@Override
	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
		plugin = OsmandPlugin.getEnabledPlugin(OsmEditingPlugin.class);

		View view = getActivity().getLayoutInflater().inflate(R.layout.dash_common_fragment, container, false);
		TextView header = ((TextView) view.findViewById(R.id.fav_text));
		header.setText(R.string.osm_settings);
		Button manage = ((Button) view.findViewById(R.id.show_all));
		manage.setText(R.string.osm_editing_manage);
		(view.findViewById(R.id.show_all)).setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View view) {
				startFavoritesActivity(FavoritesActivity.OSM_EDITS_TAB);
			}
		});

		return view;
	}


	@Override
	public void onOpenDash() {
		if (plugin == null) {
			plugin = OsmandPlugin.getEnabledPlugin(OsmEditingPlugin.class);
		}
		setupEditings();		
	}
	
	private void setupEditings() {
		View mainView = getView();
		if (plugin == null){
			mainView.setVisibility(View.GONE);
			return;
		}

		ArrayList<OsmPoint> dataPoints = new ArrayList<>();
		getOsmPoints(dataPoints);
		if (dataPoints.size() == 0){
			mainView.setVisibility(View.GONE);
			return;
		} else {
			mainView.setVisibility(View.VISIBLE);
		}

		LinearLayout osmLayout = (LinearLayout) mainView.findViewById(R.id.items);
		osmLayout.removeAllViews();

		for (final OsmPoint point : dataPoints){
			LayoutInflater inflater = getActivity().getLayoutInflater();
			View view = inflater.inflate(R.layout.note, null, false);

			OsmEditsFragment.getOsmEditView(view, point, getMyApplication());
			ImageButton send =(ImageButton) view.findViewById(R.id.play);
			send.setImageDrawable(getMyApplication().getIconsCache().getContentIcon(R.drawable.ic_action_export));
			send.setOnClickListener(new View.OnClickListener() {
				@Override
				public void onClick(View v) {
					uploadItem(point);
				}
			});
			view.findViewById(R.id.options).setVisibility(View.GONE);
			view.findViewById(R.id.divider).setVisibility(View.VISIBLE);
			view.setOnClickListener(new View.OnClickListener() {
				@Override
				public void onClick(View v) {
					boolean poi = point.getGroup() == OsmPoint.Group.POI;
					String name = poi ?
							((OpenstreetmapPoint) point).getName() : ((OsmNotesPoint) point).getText();
					getMyApplication().getSettings().setMapLocationToShow(point.getLatitude(), point.getLongitude(),
							15, new PointDescription(poi ? PointDescription.POINT_TYPE_POI : PointDescription.POINT_TYPE_OSM_BUG, name), true,
							point); //$NON-NLS-1$
					MapActivity.launchMapActivityMoveToTop(getActivity());
				}
			});
			osmLayout.addView(view);
		}
	}

	private void uploadItem(final OsmPoint point){
		AlertDialog.Builder b = new AlertDialog.Builder(getActivity());
		b.setMessage(getString(R.string.local_osm_changes_upload_all_confirm, 1));
		b.setPositiveButton(R.string.shared_string_yes, new DialogInterface.OnClickListener() {
			@Override
			public void onClick(DialogInterface dialog, int which) {
				showProgressDialog(point);
			}
		});
		b.setNegativeButton(R.string.shared_string_cancel, null);
		b.show();
	}

	private void showProgressDialog(OsmPoint point) {
		OpenstreetmapRemoteUtil remotepoi = new OpenstreetmapRemoteUtil(getActivity());
		OsmPoint[] toUpload = new OsmPoint[]{point};
		OsmBugsRemoteUtil remotebug = new OsmBugsRemoteUtil(getMyApplication());
		ProgressDialog dialog = ProgressImplementation.createProgressDialog(
				getActivity(),
				getString(R.string.uploading),
				getString(R.string.local_openstreetmap_uploading),
				ProgressDialog.STYLE_HORIZONTAL).getDialog();
		UploadOpenstreetmapPointAsyncTask uploadTask = new UploadOpenstreetmapPointAsyncTask(dialog,DashOsmEditsFragment.this, remotepoi,
				remotebug, toUpload.length);
		uploadTask.execute(toUpload);
		dialog.show();
	}

	private void getOsmPoints(ArrayList<OsmPoint> dataPoints) {
		OpenstreetmapsDbHelper dbpoi = new OpenstreetmapsDbHelper(getActivity());
		OsmBugsDbHelper dbbug = new OsmBugsDbHelper(getActivity());

		List<OpenstreetmapPoint> l1 = dbpoi.getOpenstreetmapPoints();
		List<OsmNotesPoint> l2 = dbbug.getOsmbugsPoints();
		if (l1.isEmpty()){
			int i = 0;
			for(OsmPoint point : l2){
				if (i > 2) {
					break;
				}
				dataPoints.add(point);
				i++;
			}
		} else if (l2.isEmpty()) {
			int i = 0;
			for(OsmPoint point : l1){
				if (i > 2) {
					break;
				}
				dataPoints.add(point);
				i++;
			}
		} else {
			dataPoints.add(l1.get(0));
			dataPoints.add(l2.get(0));
			if (l1.size() > 1){
				dataPoints.add(l1.get(1));
			} else if (l2.size() > 1){
				dataPoints.add(l2.get(1));
			}
		}
	}

	@Override
	public void uploadUpdated(OsmPoint point) {
		if (!this.isDetached()){
			onOpenDash();
		}
	}

	@Override
	public void uploadEnded(Integer result) {
		if (!this.isDetached()){
			onOpenDash();
		}
	}
}
!@#$%
20190530_023027,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_c12040
package net.osmand.plus.osmedit;

import android.app.AlertDialog;
import android.app.ProgressDialog;
import android.content.DialogInterface;
import android.graphics.Typeface;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Button;
import android.widget.ImageButton;
import android.widget.LinearLayout;
import android.widget.TextView;

import net.osmand.data.PointDescription;
import net.osmand.plus.OsmandPlugin;
import net.osmand.plus.ProgressImplementation;
import net.osmand.plus.R;
import net.osmand.plus.activities.MapActivity;
import net.osmand.plus.dashboard.DashBaseFragment;
import net.osmand.plus.helpers.FontCache;
import net.osmand.plus.myplaces.FavoritesActivity;

import java.util.ArrayList;
import java.util.List;

/**
 * Created by Denis
 * on 20.01.2015.
 */
public class DashOsmEditsFragment extends DashBaseFragment implements OsmEditsUploadListener {
	public static final String TAG = "DASH_OSM_EDITS_FRAGMENT";

	OsmEditingPlugin plugin;

	@Override
	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
		plugin = OsmandPlugin.getEnabledPlugin(OsmEditingPlugin.class);

		View view = getActivity().getLayoutInflater().inflate(R.layout.dash_common_fragment, container, false);
		TextView header = ((TextView) view.findViewById(R.id.fav_text));
		header.setText(R.string.osm_settings);
		Button manage = ((Button) view.findViewById(R.id.show_all));
		manage.setText(R.string.osm_editing_manage);
		(view.findViewById(R.id.show_all)).setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View view) {
				startFavoritesActivity(FavoritesActivity.OSM_EDITS_TAB);
			}
		});

		return view;
	}


	@Override
	public void onOpenDash() {
		if (plugin == null) {
			plugin = OsmandPlugin.getEnabledPlugin(OsmEditingPlugin.class);
		}
		setupEditings();		
	}
	
	private void setupEditings() {
		View mainView = getView();
		if (plugin == null){
			mainView.setVisibility(View.GONE);
			return;
		}

		ArrayList<OsmPoint> dataPoints = new ArrayList<>();
		getOsmPoints(dataPoints);
		if (dataPoints.size() == 0){
			mainView.setVisibility(View.GONE);
			return;
		} else {
			mainView.setVisibility(View.VISIBLE);
		}

		LinearLayout osmLayout = (LinearLayout) mainView.findViewById(R.id.items);
		osmLayout.removeAllViews();

		for (final OsmPoint point : dataPoints) {
			LayoutInflater inflater = getActivity().getLayoutInflater();
			View view = inflater.inflate(R.layout.note, null, false);

			OsmEditsFragment.getOsmEditView(view, point, getMyApplication());
			ImageButton send = (ImageButton) view.findViewById(R.id.play);
			send.setImageDrawable(getMyApplication().getIconsCache().getContentIcon(R.drawable.ic_action_export));
			send.setOnClickListener(new View.OnClickListener() {
				@Override
				public void onClick(View v) {
					uploadItem(point);
				}
			});
			view.findViewById(R.id.options).setVisibility(View.GONE);
			view.findViewById(R.id.divider).setVisibility(View.VISIBLE);
			view.setOnClickListener(new View.OnClickListener() {
				@Override
				public void onClick(View v) {
					boolean poi = point.getGroup() == OsmPoint.Group.POI;
					String name = poi ? ((OpenstreetmapPoint) point).getName() : ((OsmNotesPoint) point).getText();
					getMyApplication().getSettings().setMapLocationToShow(
							point.getLatitude(),
							point.getLongitude(),
							15,
							new PointDescription(poi ? PointDescription.POINT_TYPE_POI
									: PointDescription.POINT_TYPE_OSM_BUG, name), true, point); //$NON-NLS-1$
					MapActivity.launchMapActivityMoveToTop(getActivity());
				}
			});
			osmLayout.addView(view);
		}
	}

	private void uploadItem(final OsmPoint point){
		AlertDialog.Builder b = new AlertDialog.Builder(getActivity());
		b.setMessage(getString(R.string.local_osm_changes_upload_all_confirm, 1));
		b.setPositiveButton(R.string.shared_string_yes, new DialogInterface.OnClickListener() {
			@Override
			public void onClick(DialogInterface dialog, int which) {
				showProgressDialog(point);
			}
		});
		b.setNegativeButton(R.string.shared_string_cancel, null);
		b.show();
	}

	private void showProgressDialog(OsmPoint point) {
		OpenstreetmapRemoteUtil remotepoi = new OpenstreetmapRemoteUtil(getActivity());
		OsmPoint[] toUpload = new OsmPoint[]{point};
		OsmBugsRemoteUtil remotebug = new OsmBugsRemoteUtil(getMyApplication());
		ProgressDialog dialog = ProgressImplementation.createProgressDialog(
				getActivity(),
				getString(R.string.uploading),
				getString(R.string.local_openstreetmap_uploading),
				ProgressDialog.STYLE_HORIZONTAL).getDialog();
		UploadOpenstreetmapPointAsyncTask uploadTask = new UploadOpenstreetmapPointAsyncTask(dialog,DashOsmEditsFragment.this, remotepoi,
				remotebug, toUpload.length);
		uploadTask.execute(toUpload);
		dialog.show();
	}

	private void getOsmPoints(ArrayList<OsmPoint> dataPoints) {
		OpenstreetmapsDbHelper dbpoi = new OpenstreetmapsDbHelper(getActivity());
		OsmBugsDbHelper dbbug = new OsmBugsDbHelper(getActivity());

		List<OpenstreetmapPoint> l1 = dbpoi.getOpenstreetmapPoints();
		List<OsmNotesPoint> l2 = dbbug.getOsmbugsPoints();
		if (l1.isEmpty()){
			int i = 0;
			for(OsmPoint point : l2){
				if (i > 2) {
					break;
				}
				dataPoints.add(point);
				i++;
			}
		} else if (l2.isEmpty()) {
			int i = 0;
			for(OsmPoint point : l1){
				if (i > 2) {
					break;
				}
				dataPoints.add(point);
				i++;
			}
		} else {
			dataPoints.add(l1.get(0));
			dataPoints.add(l2.get(0));
			if (l1.size() > 1){
				dataPoints.add(l1.get(1));
			} else if (l2.size() > 1){
				dataPoints.add(l2.get(1));
			}
		}
	}

	@Override
	public void uploadUpdated(OsmPoint point) {
		if (!this.isDetached()){
			onOpenDash();
		}
	}

	@Override
	public void uploadEnded(Integer result) {
		if (!this.isDetached()){
			onOpenDash();
		}
	}
}
!@#$%
20190530_023202,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_b03120
package net.osmand.plus.osmedit;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.AlertDialog.Builder;
import android.content.Context;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.content.Intent;
import android.support.v4.app.Fragment;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.ArrayAdapter;
import android.widget.EditText;
import android.widget.Spinner;
import android.widget.Toast;

import net.osmand.access.AccessibleToast;
import net.osmand.data.Amenity;
import net.osmand.data.DataTileManager;
import net.osmand.plus.ContextMenuAdapter;
import net.osmand.plus.ContextMenuAdapter.OnContextMenuClick;
import net.osmand.plus.OsmandApplication;
import net.osmand.plus.OsmandPlugin;
import net.osmand.plus.OsmandSettings;
import net.osmand.plus.R;
import net.osmand.plus.activities.EnumAdapter;
import net.osmand.plus.activities.EnumAdapter.IEnumWithResource;
import net.osmand.plus.activities.MapActivity;
import net.osmand.plus.activities.TabActivity;
import net.osmand.plus.myplaces.AvailableGPXFragment;
import net.osmand.plus.myplaces.AvailableGPXFragment.GpxInfo;
import net.osmand.plus.myplaces.FavoritesActivity;
import net.osmand.plus.views.OsmandMapTileView;
import net.osmand.util.Algorithms;

import java.util.List;


public class OsmEditingPlugin extends OsmandPlugin {
	private static final String ID = "osm.editing";
	private OsmandSettings settings;
	private OsmandApplication app;
	DataTileManager<OsmPoint> localOsmEdits = new DataTileManager<>();

	@Override
	public String getId() {
		return ID;
	}
	
	public OsmEditingPlugin(OsmandApplication app) {
		this.app = app;
		collectLocalOsmEdits();
	}
	
	@Override
	public boolean init(OsmandApplication app, Activity activity) {
		settings = app.getSettings();
		return true;
	}
	
	private OsmBugsLayer osmBugsLayer;
	private OsmEditsLayer osmEditsLayer;
	private EditingPOIDialogProvider poiActions;
	
	@Override
	public void updateLayers(OsmandMapTileView mapView, MapActivity activity){
		if (osmBugsLayer == null) {
			registerLayers(activity);
		}
		if(mapView.getLayers().contains(osmBugsLayer) != settings.SHOW_OSM_BUGS.get()){
			if(settings.SHOW_OSM_BUGS.get()){
				mapView.addLayer(osmBugsLayer, 2);
			} else {
				mapView.removeLayer(osmBugsLayer);
			}
		}
	}
	
	@Override
	public void registerLayers(MapActivity activity){
		osmBugsLayer = new OsmBugsLayer(activity, this);
		osmEditsLayer = new OsmEditsLayer(activity, this);
		activity.getMapView().addLayer(osmEditsLayer, 3.5f);
	}

	public OsmEditsLayer getOsmEditsLayer(MapActivity activity){
		if(osmEditsLayer == null) {
			registerLayers(activity);
		}
		return osmEditsLayer;
	}
	
	public OsmBugsLayer getBugsLayer(MapActivity activity) {
		if(osmBugsLayer == null) {
			registerLayers(activity);
		}
		return osmBugsLayer;
	}

	@Override
	public void mapActivityCreate(MapActivity activity) {
		// Always create new actions !
		poiActions = new EditingPOIDialogProvider(activity, this);
		activity.addDialogProvider(getPoiActions(activity));
		activity.addDialogProvider(getBugsLayer(activity));
	}
	
	
	@Override
	public Class<? extends Activity> getSettingsActivity() {
		return SettingsOsmEditingActivity.class;
	}
	
	public EditingPOIDialogProvider getPoiActions(MapActivity activity) {
		if (poiActions == null) {
			poiActions = new EditingPOIDialogProvider(activity, this);
		}
		return poiActions;
	}
	
	@Override
	public void registerMapContextMenuActions(final MapActivity mapActivity, final double latitude, final double longitude, ContextMenuAdapter adapter,
			final Object selectedObj) {
		OnContextMenuClick listener = new OnContextMenuClick() {
			@Override
			public boolean onContextMenuClick(ArrayAdapter<?> adapter, int resId, int pos, boolean isChecked) {
				if (resId == R.string.context_menu_item_create_poi) {
					getPoiActions(mapActivity).showCreateDialog(latitude, longitude);
				} else if (resId == R.string.context_menu_item_open_bug) {
					if(osmBugsLayer == null) {
						registerLayers(mapActivity);
					}
					osmBugsLayer.openBug(latitude, longitude);
				} else if (resId == R.string.poi_context_menu_delete) {
					getPoiActions(mapActivity).showDeleteDialog((Amenity) selectedObj);
				} else if (resId == R.string.poi_context_menu_modify) {
					getPoiActions(mapActivity).showEditDialog((Amenity) selectedObj);
				}
				return true;
			}
		};
		if(selectedObj instanceof Amenity) {
			adapter.item(R.string.poi_context_menu_modify).iconColor(R.drawable.ic_action_edit_dark).listen(listener).position(1).reg();
			adapter.item(R.string.poi_context_menu_delete).iconColor(R.drawable.ic_action_delete_dark).listen(listener).position(2).reg();
		} else {
			adapter.item(R.string.context_menu_item_create_poi).iconColor(R.drawable.ic_action_plus_dark).listen(listener).position(-1).reg();
		}
		adapter.item(R.string.context_menu_item_open_bug).iconColor(R.drawable.ic_action_bug_dark).listen(listener).reg();
	}

	@Override
	public void addMyPlacesTab(FavoritesActivity favoritesActivity, List<TabActivity.TabItem> mTabs, Intent intent) {
		OpenstreetmapsDbHelper dbpoi = new OpenstreetmapsDbHelper(favoritesActivity);
		OsmBugsDbHelper dbbug = new OsmBugsDbHelper(favoritesActivity);
		if (dbpoi.getOpenstreetmapPoints().size() > 0 || dbbug.getOsmbugsPoints().size() > 0){
			mTabs.add(favoritesActivity.getTabIndicator(R.string.osm_edits, OsmEditsFragment.class));
			if (intent != null && "OSM".equals(intent.getStringExtra("TAB"))) {
				app.getSettings().FAVORITES_TAB.set(FavoritesActivity.OSM_EDITS_TAB);
			}
		}
	}

	@Override
	public void registerLayerContextMenuActions(OsmandMapTileView mapView, ContextMenuAdapter adapter, MapActivity mapActivity) {
		adapter.item(R.string.layer_osm_bugs).selected(settings.SHOW_OSM_BUGS.get() ? 1 : 0)
				.iconColor(R.drawable.ic_action_bug_dark).listen(new OnContextMenuClick() {

					@Override
					public boolean onContextMenuClick(ArrayAdapter<?> adapter, int itemId, int pos, boolean isChecked) {
						if (itemId == R.string.layer_osm_bugs) {
							settings.SHOW_OSM_BUGS.set(isChecked);
						}
						return true;
					}
				}).position(16).reg();

	}

	@Override
	public String getDescription() {
		return app.getString(R.string.osm_editing_plugin_description);
	}
	
	@Override
	public void contextMenuFragment(final Activity la, final Fragment fragment, final Object info, ContextMenuAdapter adapter) {
		if (fragment instanceof AvailableGPXFragment) {
			adapter.item(R.string.local_index_mi_upload_gpx)
					.iconColor(R.drawable.ic_action_gup_dark)
					.listen(new OnContextMenuClick() {

						@Override
						public boolean onContextMenuClick(ArrayAdapter<?> adapter, int itemId, int pos, boolean isChecked) {
							sendGPXFiles(la, (AvailableGPXFragment) fragment, (GpxInfo) info);
							return true;
						}
					}).reg();
		}
	}
	
	@Override
	public void optionsMenuFragment(final Activity activity, final Fragment fragment, ContextMenuAdapter optionsMenuAdapter) {
		if (fragment instanceof AvailableGPXFragment) {
			final AvailableGPXFragment f = ((AvailableGPXFragment) fragment);
			optionsMenuAdapter.item(R.string.local_index_mi_upload_gpx)
					.iconColor(R.drawable.ic_action_export)
					.listen(new OnContextMenuClick() {

						@Override
						public boolean onContextMenuClick(ArrayAdapter<?> adapter, int itemId, int pos, boolean isChecked) {
							f.openSelectionMode(R.string.local_index_mi_upload_gpx, R.drawable.ic_action_export,
									R.drawable.ic_action_export, new OnClickListener() {
										@Override
										public void onClick(DialogInterface dialog, int which) {
											List<GpxInfo> selectedItems = f.getSelectedItems();
											sendGPXFiles(activity, f,
													selectedItems.toArray(new GpxInfo[selectedItems.size()]));
										}
									});
							return true;
						}
					}).position(5).reg();
		}
	}

	public void onLocalItemDeleted(OsmPoint point) {
		localOsmEdits.unregisterObject(point.getLatitude(), point.getLongitude(), point);
	}

	public enum UploadVisibility implements IEnumWithResource {
		Public(R.string.gpxup_public),
		Identifiable(R.string.gpxup_identifiable),
		Trackable(R.string.gpxup_trackable),
		Private(R.string.gpxup_private);
		private final int resourceId;

		private UploadVisibility(int resourceId) {
			this.resourceId = resourceId;
		}
		public String asURLparam() {
			return name().toLowerCase();
		}
		@Override
		public int stringResource() {
			return resourceId;
		}
	}
	
	public boolean sendGPXFiles(final Activity la, AvailableGPXFragment f, final GpxInfo... info){
		String name = settings.USER_NAME.get();
		String pwd = settings.USER_PASSWORD.get();
		if(Algorithms.isEmpty(name) || Algorithms.isEmpty(pwd)){
			AccessibleToast.makeText(la, R.string.validate_gpx_upload_name_pwd, Toast.LENGTH_LONG).show();
			return false;
		}
		Builder bldr = new AlertDialog.Builder(la);
		LayoutInflater inflater = (LayoutInflater)la.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
		final View view = inflater.inflate(R.layout.send_gpx_osm, null);
		final EditText descr = (EditText) view.findViewById(R.id.memory_size);
		if(info.length > 0 && info[0].getFileName() != null) {
			int dt = info[0].getFileName().indexOf('.');
			descr.setText(info[0].getFileName().substring(0, dt));
		}
		final EditText tags = (EditText) view.findViewById(R.id.TagsText);		
		final Spinner visibility = ((Spinner)view.findViewById(R.id.Visibility));
		EnumAdapter<UploadVisibility> adapter = new EnumAdapter<UploadVisibility>(la, android.R.layout.simple_spinner_item, UploadVisibility.values());
		adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
		visibility.setAdapter(adapter);
		visibility.setSelection(0);
		
		bldr.setView(view);
		bldr.setNegativeButton(R.string.shared_string_no, null);
		bldr.setPositiveButton(R.string.shared_string_yes, new DialogInterface.OnClickListener() {
			
			@Override
			public void onClick(DialogInterface dialog, int which) {
				new UploadGPXFilesTask(la, descr.getText().toString(), tags.getText().toString(), 
				 (UploadVisibility) visibility.getItemAtPosition(visibility.getSelectedItemPosition())
					).execute(info);
			}
		});
		bldr.show();
		return true;
	}

	public void onLocalOsmEditAdded(OsmPoint point){
		localOsmEdits.registerObject(point.getLatitude(), point.getLongitude(), point);
	}

	public void collectLocalOsmEdits() {
		localOsmEdits.clear();
		OpenstreetmapsDbHelper dbpoi = new OpenstreetmapsDbHelper(app);
		OsmBugsDbHelper dbbug = new OsmBugsDbHelper(app);

		List<OpenstreetmapPoint> l1 = dbpoi.getOpenstreetmapPoints();
		List<OsmNotesPoint> l2 = dbbug.getOsmbugsPoints();
		for (OsmPoint point : l1) {
			localOsmEdits.registerObject(point.getLatitude(), point.getLongitude(), point);
		}
		for (OsmPoint point : l2) {
			localOsmEdits.registerObject(point.getLatitude(), point.getLongitude(), point);
		}
	}

	public DataTileManager<OsmPoint> getLocalOsmEdits(){
		return localOsmEdits;
	}

	public List<OsmPoint> getAllEdits(){
		return localOsmEdits.getAllObjects();
	}

	@Override
	public String getName() {
		return app.getString(R.string.osm_settings);
	}

	@Override
	public int getLogoResourceId() {
		return R.drawable.ic_action_bug_dark;
	}
	
	@Override
	public int getAssetResourceName() {
		return R.drawable.osm_editing;
	}

	public static String getEditName(OsmPoint point){
		String prefix = getPrefix(point);
		if (point.getGroup() == OsmPoint.Group.POI) {
			return prefix + " (" + ((OpenstreetmapPoint) point).getSubtype() + ") " + ((OpenstreetmapPoint) point).getName();
		} else if (point.getGroup() == OsmPoint.Group.BUG) {
			return prefix + " (" + ((OsmNotesPoint) point).getAuthor() + ") " + ((OsmNotesPoint) point).getText();
		} else {
			return prefix;
		}
	}

	private static String getPrefix(OsmPoint osmPoint) {
		return (osmPoint.getGroup() == OsmPoint.Group.POI ? "POI " : "Bug ") + " id: " + osmPoint.getId();
	}
}
!@#$%
20190530_023202,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_a03120
package net.osmand.plus.osmedit;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.AlertDialog.Builder;
import android.content.Context;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.content.Intent;
import android.support.v4.app.Fragment;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.ArrayAdapter;
import android.widget.EditText;
import android.widget.Spinner;
import android.widget.Toast;

import net.osmand.access.AccessibleToast;
import net.osmand.data.Amenity;
import net.osmand.data.DataTileManager;
import net.osmand.plus.ContextMenuAdapter;
import net.osmand.plus.ContextMenuAdapter.OnContextMenuClick;
import net.osmand.plus.OsmandApplication;
import net.osmand.plus.OsmandPlugin;
import net.osmand.plus.OsmandSettings;
import net.osmand.plus.R;
import net.osmand.plus.activities.EnumAdapter;
import net.osmand.plus.activities.EnumAdapter.IEnumWithResource;
import net.osmand.plus.activities.MapActivity;
import net.osmand.plus.activities.TabActivity;
import net.osmand.plus.myplaces.AvailableGPXFragment;
import net.osmand.plus.myplaces.AvailableGPXFragment.GpxInfo;
import net.osmand.plus.myplaces.FavoritesActivity;
import net.osmand.plus.views.OsmandMapTileView;
import net.osmand.util.Algorithms;

import java.util.List;


public class OsmEditingPlugin extends OsmandPlugin {
	private static final String ID = "osm.editing";
	private OsmandSettings settings;
	private OsmandApplication app;
	DataTileManager<OsmPoint> localOsmEdits = new DataTileManager<>();

	@Override
	public String getId() {
		return ID;
	}
	
	public OsmEditingPlugin(OsmandApplication app) {
		this.app = app;
		collectLocalOsmEdits();
	}
	
	@Override
	public boolean init(OsmandApplication app, Activity activity) {
		settings = app.getSettings();
		return true;
	}
	
	private OsmBugsLayer osmBugsLayer;
	private OsmEditsLayer osmEditsLayer;
	private EditingPOIDialogProvider poiActions;
	
	@Override
	public void updateLayers(OsmandMapTileView mapView, MapActivity activity){
		if (osmBugsLayer == null) {
			registerLayers(activity);
		}
		if(mapView.getLayers().contains(osmBugsLayer) != settings.SHOW_OSM_BUGS.get()){
			if(settings.SHOW_OSM_BUGS.get()){
				mapView.addLayer(osmBugsLayer, 2);
			} else {
				mapView.removeLayer(osmBugsLayer);
			}
		}
	}
	
	@Override
	public void registerLayers(MapActivity activity){
		osmBugsLayer = new OsmBugsLayer(activity, this);
		osmEditsLayer = new OsmEditsLayer(activity, this);
		activity.getMapView().addLayer(osmEditsLayer, 3.5f);
	}

	public OsmEditsLayer getOsmEditsLayer(MapActivity activity){
		if(osmEditsLayer == null) {
			registerLayers(activity);
		}
		return osmEditsLayer;
	}
	
	public OsmBugsLayer getBugsLayer(MapActivity activity) {
		if(osmBugsLayer == null) {
			registerLayers(activity);
		}
		return osmBugsLayer;
	}

	@Override
	public void mapActivityCreate(MapActivity activity) {
		// Always create new actions !
		poiActions = new EditingPOIDialogProvider(activity, this);
		activity.addDialogProvider(getPoiActions(activity));
		activity.addDialogProvider(getBugsLayer(activity));
	}
	
	
	@Override
	public Class<? extends Activity> getSettingsActivity() {
		return SettingsOsmEditingActivity.class;
	}
	
	public EditingPOIDialogProvider getPoiActions(MapActivity activity) {
		if(poiActions == null) {
			poiActions = new EditingPOIDialogProvider(activity, this);
		}
		return poiActions;
	}
	
	@Override
	public void registerMapContextMenuActions(final MapActivity mapActivity, final double latitude, final double longitude, ContextMenuAdapter adapter,
			final Object selectedObj) {
		OnContextMenuClick listener = new OnContextMenuClick() {
			@Override
			public boolean onContextMenuClick(ArrayAdapter<?> adapter, int resId, int pos, boolean isChecked) {
				if (resId == R.string.context_menu_item_create_poi) {
					getPoiActions(mapActivity).showCreateDialog(latitude, longitude);
				} else if (resId == R.string.context_menu_item_open_bug) {
					if(osmBugsLayer == null) {
						registerLayers(mapActivity);
					}
					osmBugsLayer.openBug(latitude, longitude);
				} else if (resId == R.string.poi_context_menu_delete) {
					getPoiActions(mapActivity).showDeleteDialog((Amenity) selectedObj);
				} else if (resId == R.string.poi_context_menu_modify) {
					getPoiActions(mapActivity).showEditDialog((Amenity) selectedObj);
				}
				return true;
			}
		};
		if(selectedObj instanceof Amenity) {
			adapter.item(R.string.poi_context_menu_modify).iconColor(R.drawable.ic_action_edit_dark).listen(listener).position(1).reg();
			adapter.item(R.string.poi_context_menu_delete).iconColor(R.drawable.ic_action_delete_dark).listen(listener).position(2).reg();
		} else {
			adapter.item(R.string.context_menu_item_create_poi).iconColor(R.drawable.ic_action_plus_dark).listen(listener).position(-1).reg();
		}
		adapter.item(R.string.context_menu_item_open_bug).iconColor(R.drawable.ic_action_bug_dark).listen(listener).reg();
	}

	@Override
	public void addMyPlacesTab(FavoritesActivity favoritesActivity, List<TabActivity.TabItem> mTabs, Intent intent) {
		OpenstreetmapsDbHelper dbpoi = new OpenstreetmapsDbHelper(favoritesActivity);
		OsmBugsDbHelper dbbug = new OsmBugsDbHelper(favoritesActivity);
		if (dbpoi.getOpenstreetmapPoints().size() > 0 || dbbug.getOsmbugsPoints().size() > 0){
			mTabs.add(favoritesActivity.getTabIndicator(R.string.osm_edits, OsmEditsFragment.class));
			if (intent != null && "OSM".equals(intent.getStringExtra("TAB"))) {
				app.getSettings().FAVORITES_TAB.set(FavoritesActivity.OSM_EDITS_TAB);
			}
		}
	}

	@Override
	public void registerLayerContextMenuActions(OsmandMapTileView mapView, ContextMenuAdapter adapter, MapActivity mapActivity) {
		adapter.item(R.string.layer_osm_bugs).selected(settings.SHOW_OSM_BUGS.get() ? 1 : 0)
				.iconColor(R.drawable.ic_action_bug_dark).listen(new OnContextMenuClick() {

					@Override
					public boolean onContextMenuClick(ArrayAdapter<?> adapter, int itemId, int pos, boolean isChecked) {
						if (itemId == R.string.layer_osm_bugs) {
							settings.SHOW_OSM_BUGS.set(isChecked);
						}
						return true;
					}
				}).position(16).reg();

	}

	@Override
	public String getDescription() {
		return app.getString(R.string.osm_editing_plugin_description);
	}
	
	@Override
	public void contextMenuFragment(final Activity la, final Fragment fragment, final Object info, ContextMenuAdapter adapter) {
		if (fragment instanceof AvailableGPXFragment) {
			adapter.item(R.string.local_index_mi_upload_gpx)
					.iconColor(R.drawable.ic_action_gup_dark)
					.listen(new OnContextMenuClick() {

						@Override
						public boolean onContextMenuClick(ArrayAdapter<?> adapter, int itemId, int pos, boolean isChecked) {
							sendGPXFiles(la, (AvailableGPXFragment) fragment, (GpxInfo) info);
							return true;
						}
					}).reg();
		}
	}
	
	@Override
	public void optionsMenuFragment(final Activity activity, final Fragment fragment, ContextMenuAdapter optionsMenuAdapter) {
		if (fragment instanceof AvailableGPXFragment) {
			final AvailableGPXFragment f = ((AvailableGPXFragment) fragment);
			optionsMenuAdapter.item(R.string.local_index_mi_upload_gpx)
					.iconColor(R.drawable.ic_action_export)
					.listen(new OnContextMenuClick() {

						@Override
						public boolean onContextMenuClick(ArrayAdapter<?> adapter, int itemId, int pos, boolean isChecked) {
							f.openSelectionMode(R.string.local_index_mi_upload_gpx, R.drawable.ic_action_export,
									R.drawable.ic_action_export, new OnClickListener() {
										@Override
										public void onClick(DialogInterface dialog, int which) {
											List<GpxInfo> selectedItems = f.getSelectedItems();
											sendGPXFiles(activity, f,
													selectedItems.toArray(new GpxInfo[selectedItems.size()]));
										}
									});
							return true;
						}
					}).position(5).reg();
		}
	}

	public void onLocalItemDeleted(OsmPoint point) {
		localOsmEdits.unregisterObject(point.getLatitude(), point.getLongitude(), point);
	}

	public enum UploadVisibility implements IEnumWithResource {
		Public(R.string.gpxup_public),
		Identifiable(R.string.gpxup_identifiable),
		Trackable(R.string.gpxup_trackable),
		Private(R.string.gpxup_private);
		private final int resourceId;

		private UploadVisibility(int resourceId) {
			this.resourceId = resourceId;
		}
		public String asURLparam() {
			return name().toLowerCase();
		}
		@Override
		public int stringResource() {
			return resourceId;
		}
	}
	
	public boolean sendGPXFiles(final Activity la, AvailableGPXFragment f, final GpxInfo... info){
		String name = settings.USER_NAME.get();
		String pwd = settings.USER_PASSWORD.get();
		if(Algorithms.isEmpty(name) || Algorithms.isEmpty(pwd)){
			AccessibleToast.makeText(la, R.string.validate_gpx_upload_name_pwd, Toast.LENGTH_LONG).show();
			return false;
		}
		Builder bldr = new AlertDialog.Builder(la);
		LayoutInflater inflater = (LayoutInflater)la.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
		final View view = inflater.inflate(R.layout.send_gpx_osm, null);
		final EditText descr = (EditText) view.findViewById(R.id.memory_size);
		if(info.length > 0 && info[0].getFileName() != null) {
			int dt = info[0].getFileName().indexOf('.');
			descr.setText(info[0].getFileName().substring(0, dt));
		}
		final EditText tags = (EditText) view.findViewById(R.id.TagsText);		
		final Spinner visibility = ((Spinner)view.findViewById(R.id.Visibility));
		EnumAdapter<UploadVisibility> adapter = new EnumAdapter<UploadVisibility>(la, android.R.layout.simple_spinner_item, UploadVisibility.values());
		adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
		visibility.setAdapter(adapter);
		visibility.setSelection(0);
		
		bldr.setView(view);
		bldr.setNegativeButton(R.string.shared_string_no, null);
		bldr.setPositiveButton(R.string.shared_string_yes, new DialogInterface.OnClickListener() {
			
			@Override
			public void onClick(DialogInterface dialog, int which) {
				new UploadGPXFilesTask(la, descr.getText().toString(), tags.getText().toString(), 
				 (UploadVisibility) visibility.getItemAtPosition(visibility.getSelectedItemPosition())
					).execute(info);
			}
		});
		bldr.show();
		return true;
	}

	public void onLocalOsmEditAdded(OsmPoint point){
		localOsmEdits.registerObject(point.getLatitude(), point.getLongitude(), point);
	}

	public void collectLocalOsmEdits(){
		localOsmEdits.clear();
		OpenstreetmapsDbHelper dbpoi = new OpenstreetmapsDbHelper(app);
		OsmBugsDbHelper dbbug = new OsmBugsDbHelper(app);

		List<OpenstreetmapPoint> l1 = dbpoi.getOpenstreetmapPoints();
		List<OsmNotesPoint> l2 = dbbug.getOsmbugsPoints();
		for (OsmPoint point : l1){
			localOsmEdits.registerObject(point.getLatitude(), point.getLongitude(), point);
		}
		for (OsmPoint point : l2){
			localOsmEdits.registerObject(point.getLatitude(), point.getLongitude(), point);
		}
	}

	public DataTileManager<OsmPoint> getLocalOsmEdits(){
		return localOsmEdits;
	}

	public List<OsmPoint> getAllEdits(){
		return localOsmEdits.getAllObjects();
	}

	@Override
	public String getName() {
		return app.getString(R.string.osm_settings);
	}

	@Override
	public int getLogoResourceId() {
		return R.drawable.ic_action_bug_dark;
	}
	
	@Override
	public int getAssetResourceName() {
		return R.drawable.osm_editing;
	}

	public static String getEditName(OsmPoint point){
		String prefix = getPrefix(point);
		if (point.getGroup() == OsmPoint.Group.POI) {
			return prefix + " (" + ((OpenstreetmapPoint) point).getSubtype() + ") " + ((OpenstreetmapPoint) point).getName();
		} else if (point.getGroup() == OsmPoint.Group.BUG) {
			return prefix + " (" + ((OsmNotesPoint) point).getAuthor() + ") " + ((OsmNotesPoint) point).getText();
		} else {
			return prefix;
		}
	}

	private static String getPrefix(OsmPoint osmPoint) {
		return (osmPoint.getGroup() == OsmPoint.Group.POI ? "POI " : "Bug ") + " id: " + osmPoint.getId();
	}
}
!@#$%
20190530_023202,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_c03120
package net.osmand.plus.osmedit;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.AlertDialog.Builder;
import android.content.Context;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.content.Intent;
import android.support.v4.app.Fragment;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.ArrayAdapter;
import android.widget.EditText;
import android.widget.Spinner;
import android.widget.Toast;

import net.osmand.access.AccessibleToast;
import net.osmand.data.Amenity;
import net.osmand.data.DataTileManager;
import net.osmand.plus.ContextMenuAdapter;
import net.osmand.plus.ContextMenuAdapter.OnContextMenuClick;
import net.osmand.plus.OsmandApplication;
import net.osmand.plus.OsmandPlugin;
import net.osmand.plus.OsmandSettings;
import net.osmand.plus.R;
import net.osmand.plus.activities.EnumAdapter;
import net.osmand.plus.activities.EnumAdapter.IEnumWithResource;
import net.osmand.plus.activities.MapActivity;
import net.osmand.plus.activities.TabActivity;
import net.osmand.plus.myplaces.AvailableGPXFragment;
import net.osmand.plus.myplaces.AvailableGPXFragment.GpxInfo;
import net.osmand.plus.myplaces.FavoritesActivity;
import net.osmand.plus.views.OsmandMapTileView;
import net.osmand.util.Algorithms;

import java.util.List;


public class OsmEditingPlugin extends OsmandPlugin {
	private static final String ID = "osm.editing";
	private OsmandSettings settings;
	private OsmandApplication app;
	DataTileManager<OsmPoint> localOsmEdits = new DataTileManager<>();

	@Override
	public String getId() {
		return ID;
	}
	
	public OsmEditingPlugin(OsmandApplication app) {
		this.app = app;
		collectLocalOsmEdits();
	}
	
	@Override
	public boolean init(OsmandApplication app, Activity activity) {
		settings = app.getSettings();
		return true;
	}
	
	private OsmBugsLayer osmBugsLayer;
	private OsmEditsLayer osmEditsLayer;
	private EditingPOIDialogProvider poiActions;
	
	@Override
	public void updateLayers(OsmandMapTileView mapView, MapActivity activity){
		if (osmBugsLayer == null) {
			registerLayers(activity);
		}
		if(mapView.getLayers().contains(osmBugsLayer) != settings.SHOW_OSM_BUGS.get()){
			if(settings.SHOW_OSM_BUGS.get()){
				mapView.addLayer(osmBugsLayer, 2);
			} else {
				mapView.removeLayer(osmBugsLayer);
			}
		}
	}
	
	@Override
	public void registerLayers(MapActivity activity){
		osmBugsLayer = new OsmBugsLayer(activity, this);
		osmEditsLayer = new OsmEditsLayer(activity, this);
		activity.getMapView().addLayer(osmEditsLayer, 3.5f);
	}

	public OsmEditsLayer getOsmEditsLayer(MapActivity activity){
		if(osmEditsLayer == null) {
			registerLayers(activity);
		}
		return osmEditsLayer;
	}
	
	public OsmBugsLayer getBugsLayer(MapActivity activity) {
		if(osmBugsLayer == null) {
			registerLayers(activity);
		}
		return osmBugsLayer;
	}

	@Override
	public void mapActivityCreate(MapActivity activity) {
		// Always create new actions !
		poiActions = new EditingPOIDialogProvider(activity, this);
		activity.addDialogProvider(getPoiActions(activity));
		activity.addDialogProvider(getBugsLayer(activity));
	}
	
	
	@Override
	public Class<? extends Activity> getSettingsActivity() {
		return SettingsOsmEditingActivity.class;
	}
	
	public EditingPOIDialogProvider getPoiActions(MapActivity activity) {
		if(poiActions == null) {
			poiActions = new EditingPOIDialogProvider(activity, this);
		}
		return poiActions;
	}
	
	@Override
	public void registerMapContextMenuActions(final MapActivity mapActivity, final double latitude, final double longitude, ContextMenuAdapter adapter,
			final Object selectedObj) {
		OnContextMenuClick listener = new OnContextMenuClick() {
			@Override
			public boolean onContextMenuClick(ArrayAdapter<?> adapter, int resId, int pos, boolean isChecked) {
				if (resId == R.string.context_menu_item_create_poi) {
					getPoiActions(mapActivity).showCreateDialog(latitude, longitude);
				} else if (resId == R.string.context_menu_item_open_bug) {
					if(osmBugsLayer == null) {
						registerLayers(mapActivity);
					}
					osmBugsLayer.openBug(latitude, longitude);
				} else if (resId == R.string.poi_context_menu_delete) {
					getPoiActions(mapActivity).showDeleteDialog((Amenity) selectedObj);
				} else if (resId == R.string.poi_context_menu_modify) {
					getPoiActions(mapActivity).showEditDialog((Amenity) selectedObj);
				}
				return true;
			}
		};
		if(selectedObj instanceof Amenity) {
			adapter.item(R.string.poi_context_menu_modify).iconColor(R.drawable.ic_action_edit_dark).listen(listener).position(1).reg();
			adapter.item(R.string.poi_context_menu_delete).iconColor(R.drawable.ic_action_delete_dark).listen(listener).position(2).reg();
		} else {
			adapter.item(R.string.context_menu_item_create_poi).iconColor(R.drawable.ic_action_plus_dark).listen(listener).position(-1).reg();
		}
		adapter.item(R.string.context_menu_item_open_bug).iconColor(R.drawable.ic_action_bug_dark).listen(listener).reg();
	}

	@Override
	public void addMyPlacesTab(FavoritesActivity favoritesActivity, List<TabActivity.TabItem> mTabs, Intent intent) {
		OpenstreetmapsDbHelper dbpoi = new OpenstreetmapsDbHelper(favoritesActivity);
		OsmBugsDbHelper dbbug = new OsmBugsDbHelper(favoritesActivity);
		if (dbpoi.getOpenstreetmapPoints().size() > 0 || dbbug.getOsmbugsPoints().size() > 0){
			mTabs.add(favoritesActivity.getTabIndicator(R.string.osm_edits, OsmEditsFragment.class));
			if (intent != null && "OSM".equals(intent.getStringExtra("TAB"))) {
				app.getSettings().FAVORITES_TAB.set(FavoritesActivity.OSM_EDITS_TAB);
			}
		}
	}

	@Override
	public void registerLayerContextMenuActions(OsmandMapTileView mapView, ContextMenuAdapter adapter, MapActivity mapActivity) {
		adapter.item(R.string.layer_osm_bugs).selected(settings.SHOW_OSM_BUGS.get() ? 1 : 0)
				.iconColor(R.drawable.ic_action_bug_dark).listen(new OnContextMenuClick() {

					@Override
					public boolean onContextMenuClick(ArrayAdapter<?> adapter, int itemId, int pos, boolean isChecked) {
						if (itemId == R.string.layer_osm_bugs) {
							settings.SHOW_OSM_BUGS.set(isChecked);
						}
						return true;
					}
				}).position(16).reg();

	}

	@Override
	public String getDescription() {
		return app.getString(R.string.osm_editing_plugin_description);
	}
	
	@Override
	public void contextMenuFragment(final Activity la, final Fragment fragment, final Object info, ContextMenuAdapter adapter) {
		if (fragment instanceof AvailableGPXFragment) {
			adapter.item(R.string.local_index_mi_upload_gpx)
					.iconColor(R.drawable.ic_action_gup_dark)
					.listen(new OnContextMenuClick() {

						@Override
						public boolean onContextMenuClick(ArrayAdapter<?> adapter, int itemId, int pos, boolean isChecked) {
							sendGPXFiles(la, (AvailableGPXFragment) fragment, (GpxInfo) info);
							return true;
						}
					}).reg();
		}
	}
	
	@Override
	public void optionsMenuFragment(final Activity activity, final Fragment fragment, ContextMenuAdapter optionsMenuAdapter) {
		if (fragment instanceof AvailableGPXFragment) {
			final AvailableGPXFragment f = ((AvailableGPXFragment) fragment);
			optionsMenuAdapter.item(R.string.local_index_mi_upload_gpx)
					.icon(R.drawable.ic_action_export)
					.listen(new OnContextMenuClick() {

						@Override
						public boolean onContextMenuClick(ArrayAdapter<?> adapter, int itemId, int pos, boolean isChecked) {
							f.openSelectionMode(R.string.local_index_mi_upload_gpx, R.drawable.ic_action_export,
									R.drawable.ic_action_export, new OnClickListener() {
										@Override
										public void onClick(DialogInterface dialog, int which) {
											List<GpxInfo> selectedItems = f.getSelectedItems();
											sendGPXFiles(activity, f,
													selectedItems.toArray(new GpxInfo[selectedItems.size()]));
										}
									});
							return true;
						}
					}).position(5).reg();
		}
	}

	public void onLocalItemDeleted(OsmPoint point) {
		localOsmEdits.unregisterObject(point.getLatitude(), point.getLongitude(), point);
	}

	public enum UploadVisibility implements IEnumWithResource {
		Public(R.string.gpxup_public),
		Identifiable(R.string.gpxup_identifiable),
		Trackable(R.string.gpxup_trackable),
		Private(R.string.gpxup_private);
		private final int resourceId;

		private UploadVisibility(int resourceId) {
			this.resourceId = resourceId;
		}
		public String asURLparam() {
			return name().toLowerCase();
		}
		@Override
		public int stringResource() {
			return resourceId;
		}
	}
	
	public boolean sendGPXFiles(final Activity la, AvailableGPXFragment f, final GpxInfo... info){
		String name = settings.USER_NAME.get();
		String pwd = settings.USER_PASSWORD.get();
		if(Algorithms.isEmpty(name) || Algorithms.isEmpty(pwd)){
			AccessibleToast.makeText(la, R.string.validate_gpx_upload_name_pwd, Toast.LENGTH_LONG).show();
			return false;
		}
		Builder bldr = new AlertDialog.Builder(la);
		LayoutInflater inflater = (LayoutInflater)la.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
		final View view = inflater.inflate(R.layout.send_gpx_osm, null);
		final EditText descr = (EditText) view.findViewById(R.id.memory_size);
		if(info.length > 0 && info[0].getFileName() != null) {
			int dt = info[0].getFileName().indexOf('.');
			descr.setText(info[0].getFileName().substring(0, dt));
		}
		final EditText tags = (EditText) view.findViewById(R.id.TagsText);		
		final Spinner visibility = ((Spinner)view.findViewById(R.id.Visibility));
		EnumAdapter<UploadVisibility> adapter = new EnumAdapter<UploadVisibility>(la, android.R.layout.simple_spinner_item, UploadVisibility.values());
		adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
		visibility.setAdapter(adapter);
		visibility.setSelection(0);
		
		bldr.setView(view);
		bldr.setNegativeButton(R.string.shared_string_no, null);
		bldr.setPositiveButton(R.string.shared_string_yes, new DialogInterface.OnClickListener() {
			
			@Override
			public void onClick(DialogInterface dialog, int which) {
				new UploadGPXFilesTask(la, descr.getText().toString(), tags.getText().toString(), 
				 (UploadVisibility) visibility.getItemAtPosition(visibility.getSelectedItemPosition())
					).execute(info);
			}
		});
		bldr.show();
		return true;
	}

	public void onLocalOsmEditAdded(OsmPoint point){
		localOsmEdits.registerObject(point.getLatitude(), point.getLongitude(), point);
	}

	public void collectLocalOsmEdits(){
		localOsmEdits.clear();
		OpenstreetmapsDbHelper dbpoi = new OpenstreetmapsDbHelper(app);
		OsmBugsDbHelper dbbug = new OsmBugsDbHelper(app);

		List<OpenstreetmapPoint> l1 = dbpoi.getOpenstreetmapPoints();
		List<OsmNotesPoint> l2 = dbbug.getOsmbugsPoints();
		for (OsmPoint point : l1){
			localOsmEdits.registerObject(point.getLatitude(), point.getLongitude(), point);
		}
		for (OsmPoint point : l2){
			localOsmEdits.registerObject(point.getLatitude(), point.getLongitude(), point);
		}
	}

	public DataTileManager<OsmPoint> getLocalOsmEdits(){
		return localOsmEdits;
	}

	public List<OsmPoint> getAllEdits(){
		return localOsmEdits.getAllObjects();
	}

	@Override
	public String getName() {
		return app.getString(R.string.osm_settings);
	}

	@Override
	public int getLogoResourceId() {
		return R.drawable.ic_action_bug_dark;
	}
	
	@Override
	public int getAssetResourceName() {
		return R.drawable.osm_editing;
	}

	public static String getEditName(OsmPoint point){
		String prefix = getPrefix(point);
		if (point.getGroup() == OsmPoint.Group.POI) {
			return prefix + " (" + ((OpenstreetmapPoint) point).getSubtype() + ") " + ((OpenstreetmapPoint) point).getName();
		} else if (point.getGroup() == OsmPoint.Group.BUG) {
			return prefix + " (" + ((OsmNotesPoint) point).getAuthor() + ") " + ((OsmNotesPoint) point).getText();
		} else {
			return prefix;
		}
	}

	private static String getPrefix(OsmPoint osmPoint) {
		return (osmPoint.getGroup() == OsmPoint.Group.POI ? "POI " : "Bug ") + " id: " + osmPoint.getId();
	}
}
!@#$%
20190530_030819,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_b11092
package net.osmand.plus.osmedit;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.AlertDialog.Builder;
import android.content.Context;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.content.Intent;
import android.support.v4.app.Fragment;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.ArrayAdapter;
import android.widget.EditText;
import android.widget.Spinner;
import android.widget.Toast;

import net.osmand.access.AccessibleToast;
import net.osmand.data.Amenity;
import net.osmand.plus.ContextMenuAdapter;
import net.osmand.plus.ContextMenuAdapter.OnContextMenuClick;
import net.osmand.plus.OsmandApplication;
import net.osmand.plus.OsmandPlugin;
import net.osmand.plus.OsmandSettings;
import net.osmand.plus.R;
import net.osmand.plus.activities.EnumAdapter;
import net.osmand.plus.activities.EnumAdapter.IEnumWithResource;
import net.osmand.plus.activities.MapActivity;
import net.osmand.plus.activities.TabActivity;
import net.osmand.plus.myplaces.AvailableGPXFragment;
import net.osmand.plus.myplaces.AvailableGPXFragment.GpxInfo;
import net.osmand.plus.myplaces.FavoritesActivity;
import net.osmand.plus.views.OsmandMapTileView;
import net.osmand.util.Algorithms;

import java.util.List;


public class OsmEditingPlugin extends OsmandPlugin {
	private static final String ID = "osm.editing";
	private OsmandSettings settings;
	private OsmandApplication app;
	OpenstreetmapsDbHelper dbpoi;
	OsmBugsDbHelper dbbug;

	@Override
	public String getId() {
		return ID;
	}

	public OpenstreetmapsDbHelper getDBPOI() {
		if (dbpoi == null) {
			dbpoi = new OpenstreetmapsDbHelper(app);
		}
		return dbpoi;
	}

	public OsmBugsDbHelper getDBBug() {
		if (dbbug == null) {
			dbbug = new OsmBugsDbHelper(app);
		}
		return dbbug;
	}

	public OsmEditingPlugin(OsmandApplication app) {
		this.app = app;
		settings = app.getSettings();
	}

	private OsmBugsLayer osmBugsLayer;
	private OsmEditsLayer osmEditsLayer;
//	private EditingPOIDialogProvider poiActions;

	@Override
	public void updateLayers(OsmandMapTileView mapView, MapActivity activity) {
		if (isActive()) {
			if (osmBugsLayer == null) {
				registerLayers(activity);
			}
			if (!mapView.getLayers().contains(osmEditsLayer)) {
				activity.getMapView().addLayer(osmEditsLayer, 3.5f);
			}
			if (mapView.getLayers().contains(osmBugsLayer) != settings.SHOW_OSM_BUGS.get()) {
				if (settings.SHOW_OSM_BUGS.get()) {
					mapView.addLayer(osmBugsLayer, 2);
				} else {
					mapView.removeLayer(osmBugsLayer);
				}
			}
		} else {
			if (osmBugsLayer != null) {
				mapView.removeLayer(osmBugsLayer);
			}
			if (osmEditsLayer != null) {
				mapView.removeLayer(osmEditsLayer);
			}
		}
	}

	@Override
	public void registerLayers(MapActivity activity) {
		osmBugsLayer = new OsmBugsLayer(activity, this);
		osmEditsLayer = new OsmEditsLayer(activity, this);
	}

	public OsmEditsLayer getOsmEditsLayer(MapActivity activity) {
		if (osmEditsLayer == null) {
			registerLayers(activity);
		}
		return osmEditsLayer;
	}

	public OsmBugsLayer getBugsLayer(MapActivity activity) {
		if (osmBugsLayer == null) {
			registerLayers(activity);
		}
		return osmBugsLayer;
	}

	@Override
	public void mapActivityCreate(MapActivity activity) {
		// Always create new actions !
//		poiActions = new EditingPOIDialogProvider(activity, this);
//		activity.addDialogProvider(getPoiActions(activity));
		activity.addDialogProvider(getBugsLayer(activity));
	}


	@Override
	public Class<? extends Activity> getSettingsActivity() {
		return SettingsOsmEditingActivity.class;
	}

//	public EditingPOIDialogProvider getPoiActions(MapActivity activity) {
//		if (poiActions == null) {
//			poiActions = new EditingPOIDialogProvider(activity, this);
//		}
//		return poiActions;
//	}

	@Override
	public void registerMapContextMenuActions(final MapActivity mapActivity,
											  final double latitude,
											  final double longitude,
											  ContextMenuAdapter adapter,
											  final Object selectedObj) {
		OnContextMenuClick listener = new OnContextMenuClick() {
			@Override
			public boolean onContextMenuClick(ArrayAdapter<?> adapter, int resId, int pos, boolean isChecked) {
				if (resId == R.string.context_menu_item_create_poi) {
					//getPoiActions(mapActivity).showCreateDialog(latitude, longitude);
					EditPoiFragment editPoiFragment =
							EditPoiFragment.createAddPoiInstance(latitude, longitude,
									mapActivity.getMyApplication());
					mapActivity.getSupportFragmentManager().beginTransaction()
							.add(R.id.fragmentContainer, editPoiFragment, EditPoiFragment.TAG)
							.addToBackStack(null)
							.commit();
				} else if (resId == R.string.context_menu_item_open_bug) {
					if (osmBugsLayer == null) {
						registerLayers(mapActivity);
					}
					osmBugsLayer.openBug(latitude, longitude);
				} else if (resId == R.string.poi_context_menu_delete) {
					// TODO implement delete
//					getPoiActions(mapActivity).showDeleteDialog((Amenity) selectedObj);
				} else if (resId == R.string.poi_context_menu_modify) {
					// TODO implement edit
//					getPoiActions(mapActivity).showEditDialog((Amenity) selectedObj);
				}
				return true;
			}
		};
		if (selectedObj instanceof Amenity) {
			adapter.item(R.string.poi_context_menu_modify).iconColor(R.drawable.ic_action_edit_dark).listen(listener).position(1).reg();
			adapter.item(R.string.poi_context_menu_delete).iconColor(R.drawable.ic_action_delete_dark).listen(listener).position(2).reg();
		} else {
			adapter.item(R.string.context_menu_item_create_poi).iconColor(R.drawable.ic_action_plus_dark).listen(listener).position(-1).reg();
		}
		adapter.item(R.string.context_menu_item_open_bug).iconColor(R.drawable.ic_action_bug_dark).listen(listener).reg();
	}

	@Override
	public void addMyPlacesTab(FavoritesActivity favoritesActivity, List<TabActivity.TabItem> mTabs, Intent intent) {
		if (getDBPOI().getOpenstreetmapPoints().size() > 0 || getDBBug().getOsmbugsPoints().size() > 0) {
			mTabs.add(favoritesActivity.getTabIndicator(R.string.osm_edits, OsmEditsFragment.class));
			if (intent != null && "OSM".equals(intent.getStringExtra("TAB"))) {
				app.getSettings().FAVORITES_TAB.set(R.string.osm_edits);
			}
		}
	}

	@Override
	public void registerLayerContextMenuActions(OsmandMapTileView mapView, ContextMenuAdapter adapter, final MapActivity mapActivity) {
		adapter.item(R.string.layer_osm_bugs).selected(settings.SHOW_OSM_BUGS.get() ? 1 : 0)
				.iconColor(R.drawable.ic_action_bug_dark).listen(new OnContextMenuClick() {

			@Override
			public boolean onContextMenuClick(ArrayAdapter<?> adapter, int itemId, int pos, boolean isChecked) {
				if (itemId == R.string.layer_osm_bugs) {
					settings.SHOW_OSM_BUGS.set(isChecked);
					updateLayers(mapActivity.getMapView(), mapActivity);
				}
				return true;
			}
		}).position(16).reg();

	}

	@Override
	public String getDescription() {
		return app.getString(R.string.osm_editing_plugin_description);
	}

	@Override
	public void contextMenuFragment(final Activity la, final Fragment fragment, final Object info, ContextMenuAdapter adapter) {
		if (fragment instanceof AvailableGPXFragment) {
			adapter.item(R.string.local_index_mi_upload_gpx)
					.iconColor(R.drawable.ic_action_export)
					.listen(new OnContextMenuClick() {

						@Override
						public boolean onContextMenuClick(ArrayAdapter<?> adapter, int itemId, int pos, boolean isChecked) {
							sendGPXFiles(la, (AvailableGPXFragment) fragment, (GpxInfo) info);
							return true;
						}
					}).reg();
		}
	}

	@Override
	public void optionsMenuFragment(final Activity activity, final Fragment fragment, ContextMenuAdapter optionsMenuAdapter) {
		if (fragment instanceof AvailableGPXFragment) {
			final AvailableGPXFragment f = ((AvailableGPXFragment) fragment);
			optionsMenuAdapter.item(R.string.local_index_mi_upload_gpx)
					.icon(R.drawable.ic_action_export)
					.listen(new OnContextMenuClick() {

						@Override
						public boolean onContextMenuClick(ArrayAdapter<?> adapter, int itemId, int pos, boolean isChecked) {
							f.openSelectionMode(R.string.local_index_mi_upload_gpx, R.drawable.ic_action_export,
									R.drawable.ic_action_export, new OnClickListener() {
										@Override
										public void onClick(DialogInterface dialog, int which) {
											List<GpxInfo> selectedItems = f.getSelectedItems();
											sendGPXFiles(activity, f,
													selectedItems.toArray(new GpxInfo[selectedItems.size()]));
										}
									});
							return true;
						}
					}).position(5).reg();
		}
	}


	public enum UploadVisibility implements IEnumWithResource {
		Public(R.string.gpxup_public),
		Identifiable(R.string.gpxup_identifiable),
		Trackable(R.string.gpxup_trackable),
		Private(R.string.gpxup_private);
		private final int resourceId;

		private UploadVisibility(int resourceId) {
			this.resourceId = resourceId;
		}

		public String asURLparam() {
			return name().toLowerCase();
		}

		@Override
		public int stringResource() {
			return resourceId;
		}
	}

	public boolean sendGPXFiles(final Activity la, AvailableGPXFragment f, final GpxInfo... info) {
		String name = settings.USER_NAME.get();
		String pwd = settings.USER_PASSWORD.get();
		if (Algorithms.isEmpty(name) || Algorithms.isEmpty(pwd)) {
			AccessibleToast.makeText(la, R.string.validate_gpx_upload_name_pwd, Toast.LENGTH_LONG).show();
			return false;
		}
		Builder bldr = new AlertDialog.Builder(la);
		LayoutInflater inflater = (LayoutInflater) la.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
		final View view = inflater.inflate(R.layout.send_gpx_osm, null);
		final EditText descr = (EditText) view.findViewById(R.id.memory_size);
		if (info.length > 0 && info[0].getFileName() != null) {
			int dt = info[0].getFileName().indexOf('.');
			descr.setText(info[0].getFileName().substring(0, dt));
		}
		final EditText tags = (EditText) view.findViewById(R.id.TagsText);
		final Spinner visibility = ((Spinner) view.findViewById(R.id.Visibility));
		EnumAdapter<UploadVisibility> adapter = new EnumAdapter<UploadVisibility>(la, android.R.layout.simple_spinner_item, UploadVisibility.values());
		adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
		visibility.setAdapter(adapter);
		visibility.setSelection(0);

		bldr.setView(view);
		bldr.setNegativeButton(R.string.shared_string_no, null);
		bldr.setPositiveButton(R.string.shared_string_yes, new DialogInterface.OnClickListener() {

			@Override
			public void onClick(DialogInterface dialog, int which) {
				new UploadGPXFilesTask(la, descr.getText().toString(), tags.getText().toString(),
						(UploadVisibility) visibility.getItemAtPosition(visibility.getSelectedItemPosition())
				).execute(info);
			}
		});
		bldr.show();
		return true;
	}


	@Override
	public String getName() {
		return app.getString(R.string.osm_settings);
	}

	@Override
	public int getLogoResourceId() {
		return R.drawable.ic_action_bug_dark;
	}

	@Override
	public int getAssetResourceName() {
		return R.drawable.osm_editing;
	}

	public static String getEditName(OsmPoint point) {
		String prefix = getPrefix(point);
		if (point.getGroup() == OsmPoint.Group.POI) {
			return prefix + " (" + ((OpenstreetmapPoint) point).getSubtype() + ") " + ((OpenstreetmapPoint) point).getName();
		} else if (point.getGroup() == OsmPoint.Group.BUG) {
			return prefix + " (" + ((OsmNotesPoint) point).getAuthor() + ") " + ((OsmNotesPoint) point).getText();
		} else {
			return prefix;
		}
	}

	private static String getPrefix(OsmPoint osmPoint) {
		return (osmPoint.getGroup() == OsmPoint.Group.POI ? "POI " : "Bug ") + " id: " + osmPoint.getId();
	}


}
!@#$%
20190530_030819,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_a11092
package net.osmand.plus.osmedit;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.AlertDialog.Builder;
import android.content.Context;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.content.Intent;
import android.support.v4.app.Fragment;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.ArrayAdapter;
import android.widget.EditText;
import android.widget.Spinner;
import android.widget.Toast;

import net.osmand.access.AccessibleToast;
import net.osmand.data.Amenity;
import net.osmand.plus.ContextMenuAdapter;
import net.osmand.plus.ContextMenuAdapter.OnContextMenuClick;
import net.osmand.plus.OsmandApplication;
import net.osmand.plus.OsmandPlugin;
import net.osmand.plus.OsmandSettings;
import net.osmand.plus.R;
import net.osmand.plus.activities.EnumAdapter;
import net.osmand.plus.activities.EnumAdapter.IEnumWithResource;
import net.osmand.plus.activities.MapActivity;
import net.osmand.plus.activities.TabActivity;
import net.osmand.plus.myplaces.AvailableGPXFragment;
import net.osmand.plus.myplaces.AvailableGPXFragment.GpxInfo;
import net.osmand.plus.myplaces.FavoritesActivity;
import net.osmand.plus.views.OsmandMapTileView;
import net.osmand.util.Algorithms;

import java.util.List;


public class OsmEditingPlugin extends OsmandPlugin {
	private static final String ID = "osm.editing";
	private OsmandSettings settings;
	private OsmandApplication app;
	OpenstreetmapsDbHelper dbpoi;
	OsmBugsDbHelper dbbug;

	@Override
	public String getId() {
		return ID;
	}

	public OpenstreetmapsDbHelper getDBPOI() {
		if (dbpoi == null) {
			dbpoi = new OpenstreetmapsDbHelper(app);
		}
		return dbpoi;
	}

	public OsmBugsDbHelper getDBBug() {
		if (dbbug == null) {
			dbbug = new OsmBugsDbHelper(app);
		}
		return dbbug;
	}

	public OsmEditingPlugin(OsmandApplication app) {
		this.app = app;
		settings = app.getSettings();
	}

	private OsmBugsLayer osmBugsLayer;
	private OsmEditsLayer osmEditsLayer;
//	private EditingPOIDialogProvider poiActions;

	@Override
	public void updateLayers(OsmandMapTileView mapView, MapActivity activity) {
		if (isActive()) {
			if (osmBugsLayer == null) {
				registerLayers(activity);
			}
			if (!mapView.getLayers().contains(osmEditsLayer)) {
				activity.getMapView().addLayer(osmEditsLayer, 3.5f);
			}
			if (mapView.getLayers().contains(osmBugsLayer) != settings.SHOW_OSM_BUGS.get()) {
				if (settings.SHOW_OSM_BUGS.get()) {
					mapView.addLayer(osmBugsLayer, 2);
				} else {
					mapView.removeLayer(osmBugsLayer);
				}
			}
		} else {
			if (osmBugsLayer != null) {
				mapView.removeLayer(osmBugsLayer);
			}
			if (osmEditsLayer != null) {
				mapView.removeLayer(osmEditsLayer);
			}
		}
	}

	@Override
	public void registerLayers(MapActivity activity) {
		osmBugsLayer = new OsmBugsLayer(activity, this);
		osmEditsLayer = new OsmEditsLayer(activity, this);
	}

	public OsmEditsLayer getOsmEditsLayer(MapActivity activity) {
		if (osmEditsLayer == null) {
			registerLayers(activity);
		}
		return osmEditsLayer;
	}

	public OsmBugsLayer getBugsLayer(MapActivity activity) {
		if (osmBugsLayer == null) {
			registerLayers(activity);
		}
		return osmBugsLayer;
	}

	@Override
	public void mapActivityCreate(MapActivity activity) {
		// Always create new actions !
//		poiActions = new EditingPOIDialogProvider(activity, this);
//		activity.addDialogProvider(getPoiActions(activity));
		activity.addDialogProvider(getBugsLayer(activity));
	}


	@Override
	public Class<? extends Activity> getSettingsActivity() {
		return SettingsOsmEditingActivity.class;
	}

//	public EditingPOIDialogProvider getPoiActions(MapActivity activity) {
//		if (poiActions == null) {
//			poiActions = new EditingPOIDialogProvider(activity, this);
//		}
//		return poiActions;
//	}

	@Override
	public void registerMapContextMenuActions(final MapActivity mapActivity, final double latitude, final double longitude, ContextMenuAdapter adapter,
											  final Object selectedObj) {
		OnContextMenuClick listener = new OnContextMenuClick() {
			@Override
			public boolean onContextMenuClick(ArrayAdapter<?> adapter, int resId, int pos, boolean isChecked) {
				if (resId == R.string.context_menu_item_create_poi) {
					//getPoiActions(mapActivity).showCreateDialog(latitude, longitude);
					EditPoiFragment editPoiFragment =
							EditPoiFragment.createAddPoiInstance(latitude, longitude,
									mapActivity.getMyApplication());
					mapActivity.getSupportFragmentManager().beginTransaction()
							.add(R.id.fragmentContainer, editPoiFragment, EditPoiFragment.TAG)
							.addToBackStack(null)
							.commit();
				} else if (resId == R.string.context_menu_item_open_bug) {
					if (osmBugsLayer == null) {
						registerLayers(mapActivity);
					}
					osmBugsLayer.openBug(latitude, longitude);
				} else if (resId == R.string.poi_context_menu_delete) {
					// TODO implement delete
//					getPoiActions(mapActivity).showDeleteDialog((Amenity) selectedObj);
				} else if (resId == R.string.poi_context_menu_modify) {
					// TODO implement edit
//					getPoiActions(mapActivity).showEditDialog((Amenity) selectedObj);
				}
				return true;
			}
		};
		if (selectedObj instanceof Amenity) {
			adapter.item(R.string.poi_context_menu_modify).iconColor(R.drawable.ic_action_edit_dark).listen(listener).position(1).reg();
			adapter.item(R.string.poi_context_menu_delete).iconColor(R.drawable.ic_action_delete_dark).listen(listener).position(2).reg();
		} else {
			adapter.item(R.string.context_menu_item_create_poi).iconColor(R.drawable.ic_action_plus_dark).listen(listener).position(-1).reg();
		}
		adapter.item(R.string.context_menu_item_open_bug).iconColor(R.drawable.ic_action_bug_dark).listen(listener).reg();
	}

	@Override
	public void addMyPlacesTab(FavoritesActivity favoritesActivity, List<TabActivity.TabItem> mTabs, Intent intent) {
		if (getDBPOI().getOpenstreetmapPoints().size() > 0 || getDBBug().getOsmbugsPoints().size() > 0) {
			mTabs.add(favoritesActivity.getTabIndicator(R.string.osm_edits, OsmEditsFragment.class));
			if (intent != null && "OSM".equals(intent.getStringExtra("TAB"))) {
				app.getSettings().FAVORITES_TAB.set(R.string.osm_edits);
			}
		}
	}

	@Override
	public void registerLayerContextMenuActions(OsmandMapTileView mapView, ContextMenuAdapter adapter, final MapActivity mapActivity) {
		adapter.item(R.string.layer_osm_bugs).selected(settings.SHOW_OSM_BUGS.get() ? 1 : 0)
				.iconColor(R.drawable.ic_action_bug_dark).listen(new OnContextMenuClick() {

			@Override
			public boolean onContextMenuClick(ArrayAdapter<?> adapter, int itemId, int pos, boolean isChecked) {
				if (itemId == R.string.layer_osm_bugs) {
					settings.SHOW_OSM_BUGS.set(isChecked);
					updateLayers(mapActivity.getMapView(), mapActivity);
				}
				return true;
			}
		}).position(16).reg();

	}

	@Override
	public String getDescription() {
		return app.getString(R.string.osm_editing_plugin_description);
	}

	@Override
	public void contextMenuFragment(final Activity la, final Fragment fragment, final Object info, ContextMenuAdapter adapter) {
		if (fragment instanceof AvailableGPXFragment) {
			adapter.item(R.string.local_index_mi_upload_gpx)
					.iconColor(R.drawable.ic_action_export)
					.listen(new OnContextMenuClick() {

						@Override
						public boolean onContextMenuClick(ArrayAdapter<?> adapter, int itemId, int pos, boolean isChecked) {
							sendGPXFiles(la, (AvailableGPXFragment) fragment, (GpxInfo) info);
							return true;
						}
					}).reg();
		}
	}

	@Override
	public void optionsMenuFragment(final Activity activity, final Fragment fragment, ContextMenuAdapter optionsMenuAdapter) {
		if (fragment instanceof AvailableGPXFragment) {
			final AvailableGPXFragment f = ((AvailableGPXFragment) fragment);
			optionsMenuAdapter.item(R.string.local_index_mi_upload_gpx)
					.icon(R.drawable.ic_action_export)
					.listen(new OnContextMenuClick() {

						@Override
						public boolean onContextMenuClick(ArrayAdapter<?> adapter, int itemId, int pos, boolean isChecked) {
							f.openSelectionMode(R.string.local_index_mi_upload_gpx, R.drawable.ic_action_export,
									R.drawable.ic_action_export, new OnClickListener() {
										@Override
										public void onClick(DialogInterface dialog, int which) {
											List<GpxInfo> selectedItems = f.getSelectedItems();
											sendGPXFiles(activity, f,
													selectedItems.toArray(new GpxInfo[selectedItems.size()]));
										}
									});
							return true;
						}
					}).position(5).reg();
		}
	}


	public enum UploadVisibility implements IEnumWithResource {
		Public(R.string.gpxup_public),
		Identifiable(R.string.gpxup_identifiable),
		Trackable(R.string.gpxup_trackable),
		Private(R.string.gpxup_private);
		private final int resourceId;

		private UploadVisibility(int resourceId) {
			this.resourceId = resourceId;
		}

		public String asURLparam() {
			return name().toLowerCase();
		}

		@Override
		public int stringResource() {
			return resourceId;
		}
	}

	public boolean sendGPXFiles(final Activity la, AvailableGPXFragment f, final GpxInfo... info) {
		String name = settings.USER_NAME.get();
		String pwd = settings.USER_PASSWORD.get();
		if (Algorithms.isEmpty(name) || Algorithms.isEmpty(pwd)) {
			AccessibleToast.makeText(la, R.string.validate_gpx_upload_name_pwd, Toast.LENGTH_LONG).show();
			return false;
		}
		Builder bldr = new AlertDialog.Builder(la);
		LayoutInflater inflater = (LayoutInflater) la.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
		final View view = inflater.inflate(R.layout.send_gpx_osm, null);
		final EditText descr = (EditText) view.findViewById(R.id.memory_size);
		if (info.length > 0 && info[0].getFileName() != null) {
			int dt = info[0].getFileName().indexOf('.');
			descr.setText(info[0].getFileName().substring(0, dt));
		}
		final EditText tags = (EditText) view.findViewById(R.id.TagsText);
		final Spinner visibility = ((Spinner) view.findViewById(R.id.Visibility));
		EnumAdapter<UploadVisibility> adapter = new EnumAdapter<UploadVisibility>(la, android.R.layout.simple_spinner_item, UploadVisibility.values());
		adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
		visibility.setAdapter(adapter);
		visibility.setSelection(0);

		bldr.setView(view);
		bldr.setNegativeButton(R.string.shared_string_no, null);
		bldr.setPositiveButton(R.string.shared_string_yes, new DialogInterface.OnClickListener() {

			@Override
			public void onClick(DialogInterface dialog, int which) {
				new UploadGPXFilesTask(la, descr.getText().toString(), tags.getText().toString(),
						(UploadVisibility) visibility.getItemAtPosition(visibility.getSelectedItemPosition())
				).execute(info);
			}
		});
		bldr.show();
		return true;
	}


	@Override
	public String getName() {
		return app.getString(R.string.osm_settings);
	}

	@Override
	public int getLogoResourceId() {
		return R.drawable.ic_action_bug_dark;
	}

	@Override
	public int getAssetResourceName() {
		return R.drawable.osm_editing;
	}

	public static String getEditName(OsmPoint point) {
		String prefix = getPrefix(point);
		if (point.getGroup() == OsmPoint.Group.POI) {
			return prefix + " (" + ((OpenstreetmapPoint) point).getSubtype() + ") " + ((OpenstreetmapPoint) point).getName();
		} else if (point.getGroup() == OsmPoint.Group.BUG) {
			return prefix + " (" + ((OsmNotesPoint) point).getAuthor() + ") " + ((OsmNotesPoint) point).getText();
		} else {
			return prefix;
		}
	}

	private static String getPrefix(OsmPoint osmPoint) {
		return (osmPoint.getGroup() == OsmPoint.Group.POI ? "POI " : "Bug ") + " id: " + osmPoint.getId();
	}


}
!@#$%
20190530_030819,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_c11092
package net.osmand.plus.osmedit;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.AlertDialog.Builder;
import android.content.Context;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.content.Intent;
import android.support.v4.app.Fragment;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.ArrayAdapter;
import android.widget.EditText;
import android.widget.Spinner;
import android.widget.Toast;

import net.osmand.access.AccessibleToast;
import net.osmand.data.Amenity;
import net.osmand.plus.ContextMenuAdapter;
import net.osmand.plus.ContextMenuAdapter.OnContextMenuClick;
import net.osmand.plus.OsmandApplication;
import net.osmand.plus.OsmandPlugin;
import net.osmand.plus.OsmandSettings;
import net.osmand.plus.R;
import net.osmand.plus.activities.EnumAdapter;
import net.osmand.plus.activities.EnumAdapter.IEnumWithResource;
import net.osmand.plus.activities.MapActivity;
import net.osmand.plus.activities.TabActivity;
import net.osmand.plus.myplaces.AvailableGPXFragment;
import net.osmand.plus.myplaces.AvailableGPXFragment.GpxInfo;
import net.osmand.plus.myplaces.FavoritesActivity;
import net.osmand.plus.views.OsmandMapTileView;
import net.osmand.util.Algorithms;

import java.util.List;


public class OsmEditingPlugin extends OsmandPlugin {
	private static final String ID = "osm.editing";
	private OsmandSettings settings;
	private OsmandApplication app;
	OpenstreetmapsDbHelper dbpoi;
	OsmBugsDbHelper dbbug;

	@Override
	public String getId() {
		return ID;
	}

	public OpenstreetmapsDbHelper getDBPOI() {
		if (dbpoi == null) {
			dbpoi = new OpenstreetmapsDbHelper(app);
		}
		return dbpoi;
	}

	public OsmBugsDbHelper getDBBug() {
		if (dbbug == null) {
			dbbug = new OsmBugsDbHelper(app);
		}
		return dbbug;
	}

	public OsmEditingPlugin(OsmandApplication app) {
		this.app = app;
		settings = app.getSettings();
	}

	private OsmBugsLayer osmBugsLayer;
	private OsmEditsLayer osmEditsLayer;
	private EditingPOIDialogProvider poiActions;

	@Override
	public void updateLayers(OsmandMapTileView mapView, MapActivity activity) {
		if (isActive()) {
			if (osmBugsLayer == null) {
				registerLayers(activity);
			}
			if (!mapView.getLayers().contains(osmEditsLayer)) {
				activity.getMapView().addLayer(osmEditsLayer, 3.5f);
			}
			if (mapView.getLayers().contains(osmBugsLayer) != settings.SHOW_OSM_BUGS.get()) {
				if (settings.SHOW_OSM_BUGS.get()) {
					mapView.addLayer(osmBugsLayer, 2);
				} else {
					mapView.removeLayer(osmBugsLayer);
				}
			}
		} else {
			if (osmBugsLayer != null) {
				mapView.removeLayer(osmBugsLayer);
			}
			if (osmEditsLayer != null) {
				mapView.removeLayer(osmEditsLayer);
			}
		}
	}

	@Override
	public void registerLayers(MapActivity activity) {
		osmBugsLayer = new OsmBugsLayer(activity, this);
		osmEditsLayer = new OsmEditsLayer(activity, this);
	}

	public OsmEditsLayer getOsmEditsLayer(MapActivity activity) {
		if (osmEditsLayer == null) {
			registerLayers(activity);
		}
		return osmEditsLayer;
	}

	public OsmBugsLayer getBugsLayer(MapActivity activity) {
		if (osmBugsLayer == null) {
			registerLayers(activity);
		}
		return osmBugsLayer;
	}

	@Override
	public void mapActivityCreate(MapActivity activity) {
		// Always create new actions !
		poiActions = new EditingPOIDialogProvider(activity, this);
		activity.addDialogProvider(getPoiActions(activity));
		activity.addDialogProvider(getBugsLayer(activity));
	}


	@Override
	public Class<? extends Activity> getSettingsActivity() {
		return SettingsOsmEditingActivity.class;
	}

	public EditingPOIDialogProvider getPoiActions(MapActivity activity) {
		if (poiActions == null) {
			poiActions = new EditingPOIDialogProvider(activity, this);
		}
		return poiActions;
	}

	@Override
	public void registerMapContextMenuActions(final MapActivity mapActivity, final double latitude, final double longitude, ContextMenuAdapter adapter,
											  final Object selectedObj) {
		OnContextMenuClick listener = new OnContextMenuClick() {
			@Override
			public boolean onContextMenuClick(ArrayAdapter<?> adapter, int resId, int pos, boolean isChecked) {
				if (resId == R.string.context_menu_item_create_poi) {
					//getPoiActions(mapActivity).showCreateDialog(latitude, longitude);
					mapActivity.getSupportFragmentManager().beginTransaction()
							.add(R.id.fragmentContainer, new EditPoiFragment(), EditPoiFragment.TAG)
							.addToBackStack(null)
							.commit();
				} else if (resId == R.string.context_menu_item_open_bug) {
					if (osmBugsLayer == null) {
						registerLayers(mapActivity);
					}
					osmBugsLayer.openBug(latitude, longitude);
				} else if (resId == R.string.poi_context_menu_delete) {
					getPoiActions(mapActivity).showDeleteDialog((Amenity) selectedObj);
				} else if (resId == R.string.poi_context_menu_modify) {
					getPoiActions(mapActivity).showEditDialog((Amenity) selectedObj);
				}
				return true;
			}
		};
		if (selectedObj instanceof Amenity) {
			adapter.item(R.string.poi_context_menu_modify).iconColor(R.drawable.ic_action_edit_dark).listen(listener).position(1).reg();
			adapter.item(R.string.poi_context_menu_delete).iconColor(R.drawable.ic_action_delete_dark).listen(listener).position(2).reg();
		} else {
			adapter.item(R.string.context_menu_item_create_poi).iconColor(R.drawable.ic_action_plus_dark).listen(listener).position(-1).reg();
		}
		adapter.item(R.string.context_menu_item_open_bug).iconColor(R.drawable.ic_action_bug_dark).listen(listener).reg();
	}

	@Override
	public void addMyPlacesTab(FavoritesActivity favoritesActivity, List<TabActivity.TabItem> mTabs, Intent intent) {
		if (getDBPOI().getOpenstreetmapPoints().size() > 0 || getDBBug().getOsmbugsPoints().size() > 0) {
			mTabs.add(favoritesActivity.getTabIndicator(R.string.osm_edits, OsmEditsFragment.class));
			if (intent != null && "OSM".equals(intent.getStringExtra("TAB"))) {
				app.getSettings().FAVORITES_TAB.set(R.string.osm_edits);
			}
		}
	}

	@Override
	public void registerLayerContextMenuActions(OsmandMapTileView mapView, ContextMenuAdapter adapter, final MapActivity mapActivity) {
		adapter.item(R.string.layer_osm_bugs).selected(settings.SHOW_OSM_BUGS.get() ? 1 : 0)
				.iconColor(R.drawable.ic_action_bug_dark).listen(new OnContextMenuClick() {

			@Override
			public boolean onContextMenuClick(ArrayAdapter<?> adapter, int itemId, int pos, boolean isChecked) {
				if (itemId == R.string.layer_osm_bugs) {
					settings.SHOW_OSM_BUGS.set(isChecked);
					updateLayers(mapActivity.getMapView(), mapActivity);
				}
				return true;
			}
		}).position(16).reg();

	}

	@Override
	public String getDescription() {
		return app.getString(R.string.osm_editing_plugin_description);
	}

	@Override
	public void contextMenuFragment(final Activity la, final Fragment fragment, final Object info, ContextMenuAdapter adapter) {
		if (fragment instanceof AvailableGPXFragment) {
			adapter.item(R.string.local_index_mi_upload_gpx)
					.iconColor(R.drawable.ic_action_export)
					.listen(new OnContextMenuClick() {

						@Override
						public boolean onContextMenuClick(ArrayAdapter<?> adapter, int itemId, int pos, boolean isChecked) {
							sendGPXFiles(la, (AvailableGPXFragment) fragment, (GpxInfo) info);
							return true;
						}
					}).reg();
		}
	}

	@Override
	public void optionsMenuFragment(final Activity activity, final Fragment fragment, ContextMenuAdapter optionsMenuAdapter) {
		if (fragment instanceof AvailableGPXFragment) {
			final AvailableGPXFragment f = ((AvailableGPXFragment) fragment);
			optionsMenuAdapter.item(R.string.local_index_mi_upload_gpx)
					.icon(R.drawable.ic_action_export)
					.listen(new OnContextMenuClick() {

						@Override
						public boolean onContextMenuClick(ArrayAdapter<?> adapter, int itemId, int pos, boolean isChecked) {
							f.openSelectionMode(R.string.local_index_mi_upload_gpx, R.drawable.ic_action_export,
									R.drawable.ic_action_export, new OnClickListener() {
										@Override
										public void onClick(DialogInterface dialog, int which) {
											List<GpxInfo> selectedItems = f.getSelectedItems();
											sendGPXFiles(activity, f,
													selectedItems.toArray(new GpxInfo[selectedItems.size()]));
										}
									});
							return true;
						}
					}).position(5).reg();
		}
	}


	public enum UploadVisibility implements IEnumWithResource {
		Public(R.string.gpxup_public),
		Identifiable(R.string.gpxup_identifiable),
		Trackable(R.string.gpxup_trackable),
		Private(R.string.gpxup_private);
		private final int resourceId;

		private UploadVisibility(int resourceId) {
			this.resourceId = resourceId;
		}

		public String asURLparam() {
			return name().toLowerCase();
		}

		@Override
		public int stringResource() {
			return resourceId;
		}
	}

	public boolean sendGPXFiles(final Activity la, AvailableGPXFragment f, final GpxInfo... info) {
		String name = settings.USER_NAME.get();
		String pwd = settings.USER_PASSWORD.get();
		if (Algorithms.isEmpty(name) || Algorithms.isEmpty(pwd)) {
			AccessibleToast.makeText(la, R.string.validate_gpx_upload_name_pwd, Toast.LENGTH_LONG).show();
			return false;
		}
		Builder bldr = new AlertDialog.Builder(la);
		LayoutInflater inflater = (LayoutInflater) la.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
		final View view = inflater.inflate(R.layout.send_gpx_osm, null);
		final EditText descr = (EditText) view.findViewById(R.id.memory_size);
		if (info.length > 0 && info[0].getFileName() != null) {
			int dt = info[0].getFileName().indexOf('.');
			descr.setText(info[0].getFileName().substring(0, dt));
		}
		final EditText tags = (EditText) view.findViewById(R.id.TagsText);
		final Spinner visibility = ((Spinner) view.findViewById(R.id.Visibility));
		EnumAdapter<UploadVisibility> adapter = new EnumAdapter<UploadVisibility>(la, android.R.layout.simple_spinner_item, UploadVisibility.values());
		adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
		visibility.setAdapter(adapter);
		visibility.setSelection(0);

		bldr.setView(view);
		bldr.setNegativeButton(R.string.shared_string_no, null);
		bldr.setPositiveButton(R.string.shared_string_yes, new DialogInterface.OnClickListener() {

			@Override
			public void onClick(DialogInterface dialog, int which) {
				new UploadGPXFilesTask(la, descr.getText().toString(), tags.getText().toString(),
						(UploadVisibility) visibility.getItemAtPosition(visibility.getSelectedItemPosition())
				).execute(info);
			}
		});
		bldr.show();
		return true;
	}


	@Override
	public String getName() {
		return app.getString(R.string.osm_settings);
	}

	@Override
	public int getLogoResourceId() {
		return R.drawable.ic_action_bug_dark;
	}

	@Override
	public int getAssetResourceName() {
		return R.drawable.osm_editing;
	}

	public static String getEditName(OsmPoint point) {
		String prefix = getPrefix(point);
		if (point.getGroup() == OsmPoint.Group.POI) {
			return prefix + " (" + ((OpenstreetmapPoint) point).getSubtype() + ") " + ((OpenstreetmapPoint) point).getName();
		} else if (point.getGroup() == OsmPoint.Group.BUG) {
			return prefix + " (" + ((OsmNotesPoint) point).getAuthor() + ") " + ((OsmNotesPoint) point).getText();
		} else {
			return prefix;
		}
	}

	private static String getPrefix(OsmPoint osmPoint) {
		return (osmPoint.getGroup() == OsmPoint.Group.POI ? "POI " : "Bug ") + " id: " + osmPoint.getId();
	}


}
!@#$%
20190530_031937,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_b08944
package net.osmand.plus.download;

import java.io.File;
import java.text.Collator;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;

import net.osmand.IProgress;
import net.osmand.IndexConstants;
import net.osmand.access.AccessibleToast;
import net.osmand.plus.ContextMenuAdapter;
import net.osmand.plus.ContextMenuAdapter.OnContextMenuClick;
import net.osmand.plus.IconsCache;
import net.osmand.plus.OsmandApplication;
import net.osmand.plus.OsmandPlugin;
import net.osmand.plus.R;
import net.osmand.plus.activities.LocalIndexHelper;
import net.osmand.plus.activities.LocalIndexHelper.LocalIndexType;
import net.osmand.plus.activities.LocalIndexInfo;
import net.osmand.plus.activities.OsmandBaseExpandableListAdapter;
import net.osmand.plus.activities.OsmandExpandableListFragment;
import net.osmand.plus.dialogs.DirectionsDialogs;
import net.osmand.plus.helpers.FileNameTranslationHelper;
import net.osmand.plus.resources.IncrementalChangesManager;
import net.osmand.plus.resources.IncrementalChangesManager.IncrementalUpdate;
import net.osmand.plus.resources.IncrementalChangesManager.IncrementalUpdateList;
import net.osmand.util.Algorithms;
import android.app.Activity;
import android.app.AlertDialog;
import android.app.AlertDialog.Builder;
import android.content.Context;
import android.content.DialogInterface;
import android.content.res.TypedArray;
import android.graphics.PorterDuff;
import android.graphics.Typeface;
import android.graphics.drawable.Drawable;
import android.os.AsyncTask;
import android.os.Bundle;
import android.os.StatFs;
import android.support.v4.view.MenuItemCompat;
import android.support.v7.app.ActionBar;
import android.support.v7.view.ActionMode;
import android.support.v7.widget.PopupMenu;
import android.text.method.LinkMovementMethod;
import android.view.ContextMenu;
import android.view.ContextMenu.ContextMenuInfo;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.SubMenu;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ArrayAdapter;
import android.widget.CheckBox;
import android.widget.EditText;
import android.widget.ExpandableListView;
import android.widget.ExpandableListView.ExpandableListContextMenuInfo;
import android.widget.ImageButton;
import android.widget.ImageView;
import android.widget.ProgressBar;
import android.widget.TextView;
import android.widget.Toast;


public class LocalIndexesFragment extends OsmandExpandableListFragment {

	private LoadLocalIndexTask asyncLoader;
	private LocalIndexesAdapter listAdapter;
	private AsyncTask<LocalIndexInfo, ?, ?> operationTask;

	private boolean selectionMode = false;
	private Set<LocalIndexInfo> selectedItems = new LinkedHashSet<LocalIndexInfo>();
	
	protected static int DELETE_OPERATION = 1;
	protected static int BACKUP_OPERATION = 2;
	protected static int RESTORE_OPERATION = 3;
	
	MessageFormat formatMb = new MessageFormat("{0, number,##.#} MB", Locale.US);
	MessageFormat formatGb = new MessageFormat("{0, number,#.##} GB", Locale.US);
	private ContextMenuAdapter optionsMenuAdapter;
	private ActionMode actionMode;

	private TextView descriptionText;
	private ProgressBar sizeProgress;

	Drawable backup;
	Drawable sdcard;
	Drawable planet;

	@Override
	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
		View view = inflater.inflate(R.layout.local_index, container, false);

		getDownloadActivity().setSupportProgressBarIndeterminateVisibility(false);

		ExpandableListView listView = (ExpandableListView)view.findViewById(android.R.id.list);
		listAdapter = new LocalIndexesAdapter(getActivity());
		listView.setAdapter(listAdapter);
		expandAllGroups();
		setListView(listView);
		descriptionText = (TextView) view.findViewById(R.id.memory_size);
		sizeProgress = (ProgressBar) view.findViewById(R.id.memory_progress);
		updateDescriptionTextWithSize();
		colorDrawables();
		return view;
	}

	@SuppressWarnings({"unchecked","deprecation"})
	@Override
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		if (asyncLoader == null || asyncLoader.getResult() == null) {
			// getLastNonConfigurationInstance method should be in onCreate() method
			// (onResume() doesn't work)
			Object indexes = getActivity().getLastNonConfigurationInstance();
			asyncLoader = new LoadLocalIndexTask();
			if (indexes instanceof List<?>) {
				asyncLoader.setResult((List<LocalIndexInfo>) indexes);
			}
		}
		setHasOptionsMenu(true);
	}

	private void colorDrawables(){
		boolean light = getMyApplication().getSettings().isLightContent();
		backup = getActivity().getResources().getDrawable(R.drawable.ic_type_archive);
		backup.mutate();
		if (light) {
			backup.setColorFilter(getResources().getColor(R.color.icon_color_light), PorterDuff.Mode.MULTIPLY);
		}
		sdcard = getActivity().getResources().getDrawable(R.drawable.ic_sdcard);
		sdcard.mutate();
		sdcard.setColorFilter(getActivity().getResources().getColor(R.color.color_distance), PorterDuff.Mode.MULTIPLY);
	}

	@Override
	public void onResume() {
		super.onResume();
		if (asyncLoader == null || asyncLoader.getResult() == null) {
			reloadData();
		}

		getExpandableListView().setOnCreateContextMenuListener(new View.OnCreateContextMenuListener() {
			@Override
			public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo) {
				long packedPos = ((ExpandableListContextMenuInfo) menuInfo).packedPosition;
				int group = ExpandableListView.getPackedPositionGroup(packedPos);
				int child = ExpandableListView.getPackedPositionChild(packedPos);
				if (child >= 0 && group >= 0) {
					final LocalIndexInfo point = listAdapter.getChild(group, child);
					showContextMenu(point);
				}
			}
		});
	}

	public void reloadData() {
		asyncLoader = new LoadLocalIndexTask();
		asyncLoader.execute(getActivity());
	}


	private void showContextMenu(final LocalIndexInfo info) {
		Builder builder = new AlertDialog.Builder(getActivity());
		final ContextMenuAdapter adapter = new ContextMenuAdapter(getActivity());
		basicFileOperation(info, adapter);
		OsmandPlugin.onContextMenuActivity(getActivity(), null, info, adapter);

		String[] values = adapter.getItemNames();
		builder.setItems(values, new DialogInterface.OnClickListener() {
			@Override
			public void onClick(DialogInterface dialog, int which) {
				OnContextMenuClick clk = adapter.getClickAdapter(which);
				if (clk != null) {
					clk.onContextMenuClick(null, adapter.getElementId(which), which, false);
				}
			}

		});
		builder.show();
	}

	
	private void basicFileOperation(final LocalIndexInfo info, ContextMenuAdapter adapter) {
		OnContextMenuClick listener = new OnContextMenuClick() {
			@Override
			public boolean onContextMenuClick(ArrayAdapter<?> adapter, int resId, int pos, boolean isChecked) {
				return performBasicOperation(resId, info);
			}
		};
		if(info.getType() == LocalIndexType.MAP_DATA || info.getType() == LocalIndexType.SRTM_DATA || 
				info.getType() == LocalIndexType.WIKI_DATA){
			if(!info.isBackupedData()){
				adapter.item(R.string.local_index_mi_backup).listen(listener).position( 1).reg();
			}
		}
		if(info.isBackupedData()){
			adapter.item(R.string.local_index_mi_restore).listen(listener).position(2).reg();
		}
		if(info.getType() != LocalIndexType.TTS_VOICE_DATA && info.getType() != LocalIndexType.VOICE_DATA){
			adapter.item(R.string.shared_string_rename).listen(listener).position(3).reg();
		}
		adapter.item(R.string.shared_string_delete).listen(listener).position(4).reg();
	}

	private boolean performBasicOperation(int resId, final LocalIndexInfo info) {
		if (resId == R.string.shared_string_rename) {
			renameFile(getActivity(), new File(info.getPathToData()), new Runnable() {
				
				@Override
				public void run() {
					reloadIndexes();
				}
			});
		} else if (resId == R.string.local_index_mi_restore) {
			new LocalIndexOperationTask(RESTORE_OPERATION).execute(info);
		} else if (resId == R.string.shared_string_delete) {
			Builder confirm = new Builder(getActivity());
			confirm.setPositiveButton(R.string.shared_string_yes, new DialogInterface.OnClickListener() {
				@Override
				public void onClick(DialogInterface dialog, int which) {
					new LocalIndexOperationTask(DELETE_OPERATION).execute(info);
				}
			});
			confirm.setNegativeButton(R.string.shared_string_no, null);
			String fn = FileNameTranslationHelper.getFileName(getActivity(),
					getMyApplication().getResourceManager().getOsmandRegions(),
					info.getFileName());
			confirm.setMessage(getString(R.string.delete_confirmation_msg, fn));
			confirm.show();
		} else if (resId == R.string.local_index_mi_backup) {
			new LocalIndexOperationTask(BACKUP_OPERATION).execute(info);
		}
		return true;
	}

	public static void renameFile(final Activity a, final File f, final Runnable callback) {
		Builder b = new AlertDialog.Builder(a);
		if(f.exists()){
			int xt = f.getName().lastIndexOf('.');
			final String ext = xt == -1 ? "" : f.getName().substring(xt);
			final String originalName = xt == -1 ? f.getName() : f.getName().substring(0, xt);
			final EditText editText = new EditText(a);
			editText.setText(originalName);
			b.setView(editText);
			b.setPositiveButton(R.string.shared_string_save, new DialogInterface.OnClickListener() {
				
				@Override
				public void onClick(DialogInterface dialog, int which) {
					String newName = editText.getText().toString() + ext;
					File dest = new File(f.getParentFile(), newName);
					if (dest.exists()) {
						AccessibleToast.makeText(a, R.string.file_with_name_already_exists, Toast.LENGTH_LONG).show();
					} else {
						if(!dest.getParentFile().exists()) {
							dest.getParentFile().mkdirs();
						}
						if(f.renameTo(dest)){
							if(callback != null) { 
								callback.run();
							}
						} else {
							AccessibleToast.makeText(a, R.string.file_can_not_be_renamed, Toast.LENGTH_LONG).show();
						}
					}
					
				}
			});
			b.setNegativeButton(R.string.shared_string_cancel, null);
			b.show();
		}
	}

	public class LoadLocalIndexTask extends AsyncTask<Activity, LocalIndexInfo, List<LocalIndexInfo>> {

		private List<LocalIndexInfo> result;

		@Override
		protected List<LocalIndexInfo> doInBackground(Activity... params) {
			LocalIndexHelper helper = new LocalIndexHelper(getMyApplication());
			return helper.getLocalIndexData(this);
		}

		public void loadFile(LocalIndexInfo... loaded) {
			publishProgress(loaded);
		}

		@Override
		protected void onPreExecute() {
			getDownloadActivity().setSupportProgressBarIndeterminateVisibility(true);
			listAdapter.clear();
		}

		@Override
		protected void onProgressUpdate(LocalIndexInfo... values) {
			for (LocalIndexInfo v : values) {
				listAdapter.addLocalIndexInfo(v);
			}
			listAdapter.notifyDataSetChanged();
			expandAllGroups();
		}

		public void setResult(List<LocalIndexInfo> result) {
			this.result = result;
			if(result == null){
				listAdapter.clear();
			} else {
				for (LocalIndexInfo v : result) {
					listAdapter.addLocalIndexInfo(v);
				}
				listAdapter.notifyDataSetChanged();
				expandAllGroups();
				onPostExecute(result);
			}
		}

		@Override
		protected void onPostExecute(List<LocalIndexInfo> result) {
			this.result = result;
			listAdapter.sortData();
			if (getDownloadActivity() != null){
				getDownloadActivity().setSupportProgressBarIndeterminateVisibility(false);
				getDownloadActivity().setLocalIndexInfos(result);
			}
		}

		public List<LocalIndexInfo> getResult() {
			return result;
		}

	}

	private File getFileToRestore(LocalIndexInfo i){
		if(i.isBackupedData()){
			File parent = new File(i.getPathToData()).getParentFile();
			if(i.getType() == LocalIndexType.SRTM_DATA){
				parent = getMyApplication().getAppPath(IndexConstants.SRTM_INDEX_DIR);
			} else if(i.getFileName().endsWith(IndexConstants.BINARY_ROAD_MAP_INDEX_EXT)){
				parent = getMyApplication().getAppPath(IndexConstants.ROADS_INDEX_DIR);
			} else if(i.getType() == LocalIndexType.WIKI_DATA){
				parent = getMyApplication().getAppPath(IndexConstants.WIKI_INDEX_DIR);
			} else if(i.getType() == LocalIndexType.MAP_DATA){
				parent = getMyApplication().getAppPath(IndexConstants.MAPS_PATH);
			} else if(i.getType() == LocalIndexType.TILES_DATA){
				parent = getMyApplication().getAppPath(IndexConstants.TILES_INDEX_DIR);
			} else if(i.getType() == LocalIndexType.VOICE_DATA){
				parent = getMyApplication().getAppPath(IndexConstants.VOICE_INDEX_DIR);
			} else if(i.getType() == LocalIndexType.TTS_VOICE_DATA){
				parent = getMyApplication().getAppPath(IndexConstants.VOICE_INDEX_DIR);
			}
			return new File(parent, i.getFileName());
		}
		return new File(i.getPathToData());
	}
	
	private File getFileToBackup(LocalIndexInfo i) {
		if(!i.isBackupedData()){
			return new File(getMyApplication().getAppPath(IndexConstants.BACKUP_INDEX_DIR), i.getFileName());
		}
		return new File(i.getPathToData());
	}
	
	private boolean move(File from, File to){
		if(!to.getParentFile().exists()){
			to.getParentFile().mkdirs();
		}
		return from.renameTo(to);
	}
	
	public class LocalIndexOperationTask extends AsyncTask<LocalIndexInfo, LocalIndexInfo, String> {
		
		private final int operation;

		public LocalIndexOperationTask(int operation){
			this.operation = operation;
		}
		
		
		@Override
		protected String doInBackground(LocalIndexInfo... params) {
			int count = 0;
			int total = 0;
			for(LocalIndexInfo info : params) {
				if(!isCancelled()){
					boolean successfull = false;
					if(operation == DELETE_OPERATION){
						File f = new File(info.getPathToData());
						successfull = Algorithms.removeAllFiles(f);
					} else if(operation == RESTORE_OPERATION){
						successfull = move(new File(info.getPathToData()), getFileToRestore(info));
						if(successfull){
							info.setBackupedData(false);
						}
					} else if(operation == BACKUP_OPERATION){
						successfull = move(new File(info.getPathToData()), getFileToBackup(info));
						if(successfull){
							info.setBackupedData(true);
							getMyApplication().getResourceManager().closeFile(info.getFileName());
						}
					}
					total ++;
					if(successfull){
						count++;
						publishProgress(info);
					}
				}
			}
			if(operation == DELETE_OPERATION){
				return getString(R.string.local_index_items_deleted, count, total);
			} else if(operation == BACKUP_OPERATION){
				return getString(R.string.local_index_items_backuped, count, total);
			} else if(operation == RESTORE_OPERATION){
				return getString(R.string.local_index_items_restored, count, total);
			}  
			
			return "";
		}


		@Override
		protected void onProgressUpdate(LocalIndexInfo... values) {
			if(operation == DELETE_OPERATION){
				listAdapter.delete(values);
			} else if(operation == BACKUP_OPERATION){
				listAdapter.move(values, false);
			} else if(operation == RESTORE_OPERATION){
				listAdapter.move(values, true);
			}
			
		}
		
		@Override
		protected void onPreExecute() {
			getDownloadActivity().setProgressBarIndeterminateVisibility(true);
		}

		@Override
		protected void onPostExecute(String result) {
			getDownloadActivity().setProgressBarIndeterminateVisibility(false);
			AccessibleToast.makeText(getDownloadActivity(), result, Toast.LENGTH_LONG).show();
			if (operation == RESTORE_OPERATION || operation == BACKUP_OPERATION){
				listAdapter.clear();
				reloadIndexes();
			}
		}
	}
	
	


	@Override
	public boolean onChildClick(ExpandableListView parent, View v, int groupPosition, int childPosition, long id) {
		LocalIndexInfo child = listAdapter.getChild(groupPosition, childPosition);
		if (!selectionMode){
			openPopUpMenu(v, child);
			return true;
		}
		selectedItems.add(child);
		listAdapter.notifyDataSetChanged();
		return true;
	}
	
	public Set<LocalIndexInfo> getSelectedItems() {
		return selectedItems;
	}
	
	


	@Override
	public void onPause() {
		super.onPause();
		if(operationTask != null){
			operationTask.cancel(true);
		}
	}

	@Override
	public void onDestroy() {
		super.onDestroy();
		asyncLoader.cancel(true);
	}
	

	@SuppressWarnings("deprecation")
	@Override
	public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
		if (!this.isAdded()) {
			return;
		}

		//fixes issue when local files not shown after switching tabs
		//Next line throws NPE in some circumstances when called from dashboard and listAdpater=null is not checked for. (Checking !this.isAdded above is not sufficient!)
		if (listAdapter != null && listAdapter.getGroupCount() == 0 && getDownloadActivity().getLocalIndexInfos().size() > 0) {
			for(LocalIndexInfo info : getDownloadActivity().getLocalIndexInfos()) {
				listAdapter.addLocalIndexInfo(info);
			}
			listAdapter.sortData();
			getExpandableListView().setAdapter(listAdapter);
			expandAllGroups();
		}
		ActionBar actionBar = getDownloadActivity().getSupportActionBar();
		//hide action bar from downloadindexfragment
		actionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_STANDARD);
		optionsMenuAdapter = new ContextMenuAdapter(getDownloadActivity());
		OnContextMenuClick listener = new OnContextMenuClick() {
			@Override
			public boolean onContextMenuClick(ArrayAdapter<?> adapter, int itemId, int pos, boolean isChecked) {
				localOptionsMenu(itemId);
				return true;
			}
		};
		optionsMenuAdapter.item(R.string.local_index_mi_reload)
				.icon(R.drawable.ic_action_refresh_dark)
				.listen(listener).position(1).reg();
		optionsMenuAdapter.item(R.string.shared_string_delete)
				.icon(R.drawable.ic_action_delete_dark)
				.listen(listener).position(2).reg();
		optionsMenuAdapter.item(R.string.local_index_mi_backup)
				.listen(listener).position(3).reg();
		optionsMenuAdapter.item(R.string.local_index_mi_restore)
				.listen(listener).position(4).reg();
		// doesn't work correctly
		//int max =  getResources().getInteger(R.integer.abs__max_action_buttons);
		int max = 3;
		SubMenu split = null;
		for (int j = 0; j < optionsMenuAdapter.length(); j++) {
			MenuItem item;
			if (j + 1 >= max && optionsMenuAdapter.length() > max) {
				if (split == null) {
					split = menu.addSubMenu(0, 1, j + 1, R.string.shared_string_more_actions);
					split.setIcon(R.drawable.ic_overflow_menu_white);
					split.getItem();
					MenuItemCompat.setShowAsAction(split.getItem(),MenuItemCompat.SHOW_AS_ACTION_ALWAYS);
				}
				item = split.add(0, optionsMenuAdapter.getElementId(j), j + 1, optionsMenuAdapter.getItemName(j));
				MenuItemCompat.setShowAsAction(item, MenuItemCompat.SHOW_AS_ACTION_ALWAYS );
			} else {
				item = menu.add(0, optionsMenuAdapter.getElementId(j), j + 1, optionsMenuAdapter.getItemName(j));
				MenuItemCompat.setShowAsAction(item, MenuItemCompat.SHOW_AS_ACTION_ALWAYS );
			}
			OsmandApplication app = getMyApplication();
			if (optionsMenuAdapter.getImage(app, j, isLightActionBar()) != null) {
				item.setIcon(optionsMenuAdapter.getImage(app, j, isLightActionBar()));
			}
			
		}

		if(operationTask == null || operationTask.getStatus() == AsyncTask.Status.FINISHED){
			menu.setGroupVisible(0, true);
		} else {
			menu.setGroupVisible(0, false);
		}
	}
	
	@Override
	public boolean onOptionsItemSelected(MenuItem item) {
		int itemId = item.getItemId();
		for (int i = 0; i < optionsMenuAdapter.length(); i++) {
			if (itemId == optionsMenuAdapter.getElementId(i)) {
				optionsMenuAdapter.getClickAdapter(i).onContextMenuClick(null, itemId, i, false);
				return true;
			}
		}
		return super.onOptionsItemSelected(item);
	}
	
	public void doAction(int actionResId){
		if(actionResId == R.string.local_index_mi_backup){
			operationTask = new LocalIndexOperationTask(BACKUP_OPERATION);
		} else if(actionResId == R.string.shared_string_delete){
			operationTask = new LocalIndexOperationTask(DELETE_OPERATION);
		} else if(actionResId == R.string.local_index_mi_restore){
			operationTask = new LocalIndexOperationTask(RESTORE_OPERATION);
		} else {
			operationTask = null;
		}
		if(operationTask != null){
			operationTask.execute(selectedItems.toArray(new LocalIndexInfo[selectedItems.size()]));
		}
		if(actionMode != null) {
			actionMode.finish();
		}
	}
	
	
	private void expandAllGroups() {
		for (int i = 0; i < listAdapter.getGroupCount(); i++) {
			getExpandableListView().expandGroup(i);
		}
	}
	
	private void openSelectionMode(final int actionResId, final int actionIconId, 
			final DialogInterface.OnClickListener listener){
		String value = getString(actionResId);
		if (value.endsWith("...")) {
			value = value.substring(0, value.length() - 3);
		}
		final String actionButton = value;
		if(listAdapter.getGroupCount() == 0){
			listAdapter.cancelFilter();
			expandAllGroups();
			listAdapter.notifyDataSetChanged();
			AccessibleToast.makeText(getDownloadActivity(), getString(R.string.local_index_no_items_to_do, actionButton.toLowerCase()), Toast.LENGTH_SHORT).show();
			return;
		}
		expandAllGroups();
		
		selectionMode = true;
		selectedItems.clear();
		actionMode = getDownloadActivity().startSupportActionMode(new ActionMode.Callback() {

			@Override
			public boolean onCreateActionMode(ActionMode mode, Menu menu) {
				selectionMode = true;
				MenuItem it = menu.add(actionResId);
				if (actionIconId != 0) {
					it.setIcon(actionIconId);
				}
				MenuItemCompat.setShowAsAction(it, MenuItemCompat.SHOW_AS_ACTION_IF_ROOM |
						MenuItemCompat.SHOW_AS_ACTION_WITH_TEXT);
				return true;
			}

			@Override
			public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
				return false;
			}

			@Override
			public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
				if (selectedItems.isEmpty()) {
					AccessibleToast.makeText(getDownloadActivity(),
							getString(R.string.local_index_no_items_to_do, actionButton.toLowerCase()), Toast.LENGTH_SHORT).show();
					return true;
				}

				Builder builder = new AlertDialog.Builder(getDownloadActivity());
				builder.setMessage(getString(R.string.local_index_action_do, actionButton.toLowerCase(), selectedItems.size()));
				builder.setPositiveButton(actionButton, listener);
				builder.setNegativeButton(R.string.shared_string_cancel, null);
				builder.show();
				return true;
			}

			@Override
			public void onDestroyActionMode(ActionMode mode) {
				selectionMode = false;
				descriptionText.setVisibility(View.VISIBLE);
				updateDescriptionTextWithSize();
				listAdapter.cancelFilter();
				expandAllGroups();
				listAdapter.notifyDataSetChanged();
			}

		});
		//findViewById(R.id.DescriptionText).setVisibility(View.GONE);
		listAdapter.notifyDataSetChanged();
	}

	@SuppressWarnings("deprecation")
	private void updateDescriptionTextWithSize(){
		File dir = getMyApplication().getAppPath("").getParentFile();
		String size = formatGb.format(new Object[]{0});
		int percent = 0;
		if(dir.canRead()){
			StatFs fs = new StatFs(dir.getAbsolutePath());
			size = formatGb.format(new Object[]{(float) (fs.getAvailableBlocks()) * fs.getBlockSize() / (1 << 30) });
			percent = (int) (fs.getAvailableBlocks() * 100 / fs.getBlockCount());
		}
		sizeProgress.setProgress(percent);
		String text = getString(R.string.free, size);
		int l = text.indexOf('.');
		if(l == -1) {
			l = text.length();
		}
		descriptionText.setText(text);
		descriptionText.setMovementMethod(LinkMovementMethod.getInstance());
	}

	public void localOptionsMenu(final int itemId) {
		if (itemId == R.string.local_index_mi_reload) {
			reloadIndexes();
		} else if (itemId == R.string.shared_string_delete) {
			openSelectionMode(itemId, R.drawable.ic_action_delete_dark,
					new DialogInterface.OnClickListener() {

						@Override
						public void onClick(DialogInterface dialog, int which) {
							doAction(itemId);
						}
					}, null, null);
		} else if (itemId == R.string.local_index_mi_backup) {
			openSelectionMode(itemId, R.drawable.ic_type_archive,
					new DialogInterface.OnClickListener() {

						@Override
						public void onClick(DialogInterface dialog, int which) {
							doAction(itemId);
						}
					}, Boolean.FALSE, LocalIndexType.MAP_DATA);
		} else if (itemId == R.string.local_index_mi_restore) {
			openSelectionMode(itemId, R.drawable.ic_type_archive,
					new DialogInterface.OnClickListener() {

						@Override
						public void onClick(DialogInterface dialog, int which) {
							doAction(itemId);
						}
					}, Boolean.TRUE, LocalIndexType.MAP_DATA);
			listAdapter.filterCategories(true);
		}
	}
	
	public void openSelectionMode(int stringRes, int darkIcon, DialogInterface.OnClickListener listener, Boolean backup,
			LocalIndexType filter) {
		if (backup != null) {
			listAdapter.filterCategories(backup);
		}
		if (filter != null) {
			listAdapter.filterCategories(filter);
		}
		openSelectionMode(stringRes, darkIcon, listener);
	}
	

	public void reloadIndexes() {
		listAdapter.clear();
		asyncLoader = new LoadLocalIndexTask();
		AsyncTask<Void, String, List<String>> task = new AsyncTask<Void, String, List<String>>(){

			@Override
			protected void onPostExecute(List<String> warnings) {
				if ( getDownloadActivity() == null) {
					return;
				}
				getDownloadActivity().setSupportProgressBarIndeterminateVisibility(false);
				if (!warnings.isEmpty()) {
					final StringBuilder b = new StringBuilder();
					boolean f = true;
					for (String w : warnings) {
						if (f) {
							f = false;
						} else {
							b.append('\n');
						}
						b.append(w);
					}
					AccessibleToast.makeText(getDownloadActivity(), b.toString(), Toast.LENGTH_LONG).show();
				}
				if(asyncLoader.getStatus() == Status.PENDING) {
					asyncLoader.execute(getDownloadActivity());
				}
			}
			
			@Override
			protected void onPreExecute() {
				super.onPreExecute();
				getDownloadActivity().setSupportProgressBarIndeterminateVisibility(true);
			}
			@Override
			protected List<String> doInBackground(Void... params) {
				return getMyApplication().getResourceManager().reloadIndexes(IProgress.EMPTY_PROGRESS,
						new ArrayList<String>()
						);
			}
			
		};
		task.execute();
		
	}

	protected class LocalIndexesAdapter extends OsmandBaseExpandableListAdapter {
		
		Map<LocalIndexInfo, List<LocalIndexInfo>> data = new LinkedHashMap<LocalIndexInfo, List<LocalIndexInfo>>();
		List<LocalIndexInfo> category = new ArrayList<LocalIndexInfo>();
		List<LocalIndexInfo> filterCategory = null;
		int warningColor;
		int okColor;
		int corruptedColor;
		Context ctx;

		public LocalIndexesAdapter(Context ctx) {
			this.ctx = ctx;
			warningColor = ctx.getResources().getColor(R.color.color_warning);
			okColor = ctx.getResources().getColor(R.color.color_ok);
			TypedArray ta = ctx.getTheme().obtainStyledAttributes(new int[]{android.R.attr.textColorPrimary});
			ta.recycle();
			corruptedColor = ctx.getResources().getColor(R.color.color_invalid);
		}
		
		public void clear() {
			data.clear();
			category.clear();
			filterCategory = null;
			notifyDataSetChanged();
		}
		
		public void sortData() {
			final Collator cl = Collator.getInstance();
			for(List<LocalIndexInfo> i : data.values()) {
				Collections.sort(i, new Comparator<LocalIndexInfo>() {
					@Override
					public int compare(LocalIndexInfo lhs, LocalIndexInfo rhs) {
						return cl.compare(getNameToDisplay(lhs), getNameToDisplay(rhs));
					}
				});
			}
		}

		public LocalIndexInfo findCategory(LocalIndexInfo val, boolean backuped){
			for(LocalIndexInfo i : category){
				if(i.isBackupedData() == backuped && val.getType() == i.getType() && 
						Algorithms.objectEquals(i.getSubfolder(), val.getSubfolder())){
					return i;
				}
			}
			LocalIndexInfo newCat = new LocalIndexInfo(val.getType(), backuped, val.getSubfolder());
			category.add(newCat);
			data.put(newCat, new ArrayList<LocalIndexInfo>());
			return newCat;
		}
		
		public void delete(LocalIndexInfo[] values) {
			for(LocalIndexInfo i : values){
				LocalIndexInfo c = findCategory(i, i.isBackupedData());
				if(c != null){
					data.get(c).remove(i);
					if (data.get(c).size() == 0){
						data.remove(c);
						category.remove(c);
					}
				}
			}
			listAdapter.notifyDataSetChanged();
		}
		
		public void move(LocalIndexInfo[] values, boolean oldBackupState) {
			for(LocalIndexInfo i : values){
				LocalIndexInfo c = findCategory(i, oldBackupState);
				if(c != null){
					data.get(c).remove(i);
				}
				c = findCategory(i, !oldBackupState);
				if(c != null){
					data.get(c).add(i);
				}
			}
			listAdapter.notifyDataSetChanged();
			expandAllGroups();
		}

		public void cancelFilter(){
			filterCategory = null;
			notifyDataSetChanged();
		}
		
		public void filterCategories(LocalIndexType... types) {
			List<LocalIndexInfo> filter = new ArrayList<LocalIndexInfo>();
			List<LocalIndexInfo> source = filterCategory == null ? category : filterCategory;
			for (LocalIndexInfo info : source) {
				for (LocalIndexType ts : types) {
					if (info.getType() == ts) {
						filter.add(info);
					}
				}
			}
			filterCategory = filter;
			notifyDataSetChanged();
		}
		
		public void filterCategories(boolean backup) {
			List<LocalIndexInfo> filter = new ArrayList<LocalIndexInfo>();
			List<LocalIndexInfo> source = filterCategory == null ? category : filterCategory;
			for (LocalIndexInfo info : source) {
				if (info.isBackupedData() == backup) {
					filter.add(info);
				}
			}
			filterCategory = filter;
			notifyDataSetChanged();
		}

		public void addLocalIndexInfo(LocalIndexInfo info) {
			int found = -1;
			// search from end
			for (int i = category.size() - 1; i >= 0; i--) {
				LocalIndexInfo cat = category.get(i);
				if (cat.getType() == info.getType() && info.isBackupedData() == cat.isBackupedData() &&
						Algorithms.objectEquals(info.getSubfolder(), cat.getSubfolder())) {
					found = i;
					break;
				}
			}
			if (found == -1) {
				found = category.size();
				category.add(new LocalIndexInfo(info.getType(), info.isBackupedData(), info.getSubfolder()));
			}
			if (!data.containsKey(category.get(found))) {
				data.put(category.get(found), new ArrayList<LocalIndexInfo>());
			}
			data.get(category.get(found)).add(info);
		}

		@Override
		public LocalIndexInfo getChild(int groupPosition, int childPosition) {
			LocalIndexInfo cat = filterCategory != null ? filterCategory.get(groupPosition) : category.get(groupPosition);
			return data.get(cat).get(childPosition);
		}

		@Override
		public long getChildId(int groupPosition, int childPosition) {
			// it would be unusable to have 10000 local indexes
			return groupPosition * 10000 + childPosition;
		}

		@Override
		public View getChildView(final int groupPosition, final int childPosition, boolean isLastChild, View convertView, ViewGroup parent) {
			View v = convertView;
			final LocalIndexInfo child = getChild(groupPosition, childPosition);
			if (v == null ) {
				LayoutInflater inflater = (LayoutInflater) getDownloadActivity().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
				v = inflater.inflate(net.osmand.plus.R.layout.local_index_list_item, parent, false);
			}
			TextView viewName = ((TextView) v.findViewById(R.id.local_index_name));
			ImageButton options = (ImageButton) v.findViewById(R.id.options);
			options.setImageDrawable(getMyApplication().getIconsCache().getContentIcon(R.drawable.ic_overflow_menu_white));
			options.setOnClickListener(new View.OnClickListener() {
				@Override
				public void onClick(View v) {
					openPopUpMenu(v, child);
				}
			});
			ImageView icon = (ImageView) v.findViewById(R.id.icon);
			if (child.isBackupedData()) {
				icon.setImageDrawable(backup);
			} else {
				icon.setImageDrawable(sdcard);
			}

			viewName.setText(getNameToDisplay(child));
			if (child.isNotSupported()) {
				viewName.setTextColor(warningColor);
			} else if (child.isCorrupted()) {
				viewName.setTextColor(corruptedColor);
			} else if (child.isLoaded()) {
				// users confused okColor here with "uptodate", so let's leave white (black in dark app theme) as "isLoaded"
				//viewName.setTextColor(okColor);
			}
			if (child.isBackupedData()) {
				viewName.setTypeface(Typeface.DEFAULT, Typeface.ITALIC);
			} else {
				viewName.setTypeface(Typeface.DEFAULT, Typeface.NORMAL);
			}
			TextView sizeText = (TextView) v.findViewById(R.id.local_index_size);
			if (child.getSize() >= 0) {
				String size;
				if (child.getSize() > 100) {
					size = formatMb.format(new Object[] { (float) child.getSize() / (1 << 10) });
				} else {
					size = child.getSize() + " kB";
				}
				sizeText.setText(size);
				sizeText.setVisibility(View.VISIBLE);
			} else {
				sizeText.setVisibility(View.GONE);
			}

			TextView descr = ((TextView) v.findViewById(R.id.local_index_descr));
			if (child.getType() == LocalIndexType.TILES_DATA) {
				descr.setText(R.string.online_map);
			} else {
				descr.setVisibility(View.VISIBLE);
				descr.setText(child.getDescription());
			}



			final CheckBox checkbox = (CheckBox) v.findViewById(R.id.check_local_index);
			checkbox.setVisibility(selectionMode ? View.VISIBLE : View.GONE);
			if (selectionMode) {
				icon.setVisibility(View.GONE);
				options.setVisibility(View.GONE);
				checkbox.setChecked(selectedItems.contains(child));
				checkbox.setOnClickListener(new View.OnClickListener() {
					
					@Override
					public void onClick(View v) {
						if(checkbox.isChecked()){
							selectedItems.add(child);
						} else {
							selectedItems.remove(child);
						}
					}
				});

			} else {
				options.setVisibility(View.VISIBLE);
				icon.setVisibility(View.VISIBLE);
			}

			v.setOnClickListener(new View.OnClickListener() {
				@Override
				public void onClick(View v) {
					onChildClick(null, v, groupPosition, childPosition, 0);
				}
			});
			return v;
		}

		
		private String getNameToDisplay(LocalIndexInfo child) {
			String mapDescr = getMapDescription(child.getFileName());
			String mapName = FileNameTranslationHelper.getFileName(ctx,
					((OsmandApplication) getDownloadActivity().getApplication()).getResourceManager().getOsmandRegions(),
					child.getFileName());
			if (mapDescr.length() > 0) {
				return mapName + " - " + mapDescr;
			} else {
				return mapName;
			}
		}

		@Override
		public View getGroupView(int groupPosition, boolean isExpanded, View convertView, ViewGroup parent) {
			View v = convertView;
			LocalIndexInfo group = getGroup(groupPosition);
			if (v == null) {
				LayoutInflater inflater = (LayoutInflater) getDownloadActivity().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
				v = inflater.inflate(R.layout.local_index_list_category, parent, false);
			}
			StringBuilder name = new StringBuilder(group.getType().getHumanString(getDownloadActivity()));
			if(group.getSubfolder() != null) {
				name.append(" ").append(group.getSubfolder());
			}
			if (group.isBackupedData()) {
				name.append(" - ").append(getString(R.string.local_indexes_cat_backup));
			}
			TextView nameView = ((TextView) v.findViewById(R.id.category_name));
			TextView sizeView = ((TextView) v.findViewById(R.id.category_size));
			List<LocalIndexInfo> list = data.get(group);
			int size = 0;
			for (LocalIndexInfo aList : list) {
				int sz = aList.getSize();
				if (sz < 0) {
					size = 0;
					break;
				} else {
					size += sz;
				}
			}
			String sz = "";
			if (size > 0) {
				if (size > 1 << 20) {
					sz = formatGb.format(new Object[] { (float) size / (1 << 20) });
				} else {
					sz = formatMb.format(new Object[] { (float) size / (1 << 10) });
				}

			}
			sizeView.setText(sz);
			nameView.setText(name.toString());
			if (!group.isBackupedData()) {
				nameView.setTypeface(Typeface.DEFAULT, Typeface.NORMAL);
			} else {
				nameView.setTypeface(Typeface.DEFAULT, Typeface.ITALIC);
			}

			v.setOnClickListener(null);
			return v;
		}

		@Override
		public int getChildrenCount(int groupPosition) {
			LocalIndexInfo cat = filterCategory != null ? filterCategory.get(groupPosition) : category.get(groupPosition);
			return data.get(cat).size();
		}

		@Override
		public LocalIndexInfo getGroup(int groupPosition) {
			return filterCategory == null ?  category.get(groupPosition)  : filterCategory.get(groupPosition);
		}

		@Override
		public int getGroupCount() {
			return filterCategory == null ?  category.size() : filterCategory.size();
		}

		@Override
		public long getGroupId(int groupPosition) {
			return groupPosition;
		}

		@Override
		public boolean hasStableIds() {
			return false;
		}

		@Override
		public boolean isChildSelectable(int groupPosition, int childPosition) {
			return true;
		}



		private String getMapDescription(String fileName){
			if (fileName.endsWith(IndexConstants.BINARY_ROAD_MAP_INDEX_EXT)) {
				return ctx.getString(R.string.download_roads_only_item);
			}
			return "";
		}
	}
	
	private void openPopUpMenu(View v, final LocalIndexInfo info) {
		IconsCache iconsCache = getMyApplication().getIconsCache();
		final PopupMenu optionsMenu = new PopupMenu(getActivity(), v);
		DirectionsDialogs.setupPopUpMenuIcon(optionsMenu);
		final boolean restore = info.isBackupedData();
		MenuItem item;
		if (info.getType() == LocalIndexType.MAP_DATA) {
			item = optionsMenu.getMenu().add(restore? R.string.local_index_mi_restore : R.string.local_index_mi_backup)
					.setIcon(backup);
			item.setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {
				@Override
				public boolean onMenuItemClick(MenuItem item) {
					performBasicOperation(restore ? R.string.local_index_mi_restore : R.string.local_index_mi_backup, info);
					return true;
				}
			});
		}

		item = optionsMenu.getMenu().add(R.string.shared_string_rename)
				.setIcon(iconsCache.getContentIcon(R.drawable.ic_action_edit_dark));
		item.setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {
			@Override
			public boolean onMenuItemClick(MenuItem item) {
				performBasicOperation(R.string.shared_string_rename, info);
				return true;
			}
		});

		item = optionsMenu.getMenu().add(R.string.shared_string_delete)
				.setIcon(iconsCache.getContentIcon(R.drawable.ic_action_delete_dark));
		item.setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {
			@Override
			public boolean onMenuItemClick(MenuItem item) {
				performBasicOperation(R.string.shared_string_delete, info);
				return true;
			}
		});
		if(getMyApplication().getSettings().BETA_TESTING_LIVE_UPDATES.get()) {
			item = optionsMenu.getMenu().add("Live updates")
					.setIcon(iconsCache.getContentIcon(R.drawable.ic_action_refresh_dark));
			item.setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {
				@Override
				public boolean onMenuItemClick(MenuItem item) {
					runLiveUpdate(info);
					return true;
				}
			});
		}
		
		optionsMenu.show();
	}
	
	private void runLiveUpdate(final LocalIndexInfo info) {
		final String fnExt = Algorithms.getFileNameWithoutExtension(new File(info.getFileName()));
		new AsyncTask<Object, Object, IncrementalUpdateList>() {

			protected void onPreExecute() {
				getDownloadActivity().setSupportProgressBarIndeterminateVisibility(true);

			};

			@Override
			protected IncrementalUpdateList doInBackground(Object... params) {
				IncrementalChangesManager cm = getMyApplication().getResourceManager().getChangesManager();
				return cm.getUpdatesByMonth(fnExt);
			}

			protected void onPostExecute(IncrementalUpdateList result) {
				getDownloadActivity().setSupportProgressBarIndeterminateVisibility(false);
				if (result.errorMessage != null) {
					Toast.makeText(getDownloadActivity(), result.errorMessage, Toast.LENGTH_SHORT).show();
				} else {
					List<IncrementalUpdate> ll = result.getItemsForUpdate();
					if(ll.isEmpty()) {
						Toast.makeText(getDownloadActivity(), R.string.no_updates_available, Toast.LENGTH_SHORT).show();
					} else {
						for (IncrementalUpdate iu : ll) {
							IndexItem ii = new IndexItem(iu.fileName, "Incremental update", iu.timestamp, iu.sizeText,
									iu.contentSize, iu.containerSize, DownloadActivityType.LIVE_UPDATES_FILE);
							getDownloadActivity().addToDownload(ii);
							getDownloadActivity().updateDownloadButton();
						}
					}
				}

			};

		}.execute(new Object[] { fnExt });
	}


	private DownloadActivity getDownloadActivity() {
		return (DownloadActivity) getActivity();
	}
}
!@#$%
20190530_031937,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_a08944
package net.osmand.plus.download;

import java.io.File;
import java.text.Collator;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;

import net.osmand.IProgress;
import net.osmand.IndexConstants;
import net.osmand.access.AccessibleToast;
import net.osmand.plus.ContextMenuAdapter;
import net.osmand.plus.ContextMenuAdapter.OnContextMenuClick;
import net.osmand.plus.IconsCache;
import net.osmand.plus.OsmandApplication;
import net.osmand.plus.OsmandPlugin;
import net.osmand.plus.R;
import net.osmand.plus.activities.LocalIndexHelper;
import net.osmand.plus.activities.LocalIndexHelper.LocalIndexType;
import net.osmand.plus.activities.LocalIndexInfo;
import net.osmand.plus.activities.OsmandBaseExpandableListAdapter;
import net.osmand.plus.activities.OsmandExpandableListFragment;
import net.osmand.plus.dialogs.DirectionsDialogs;
import net.osmand.plus.helpers.FileNameTranslationHelper;
import net.osmand.plus.resources.IncrementalChangesManager;
import net.osmand.plus.resources.IncrementalChangesManager.IncrementalUpdate;
import net.osmand.plus.resources.IncrementalChangesManager.IncrementalUpdateList;
import net.osmand.util.Algorithms;
import android.app.Activity;
import android.app.AlertDialog;
import android.app.AlertDialog.Builder;
import android.content.Context;
import android.content.DialogInterface;
import android.content.res.TypedArray;
import android.graphics.PorterDuff;
import android.graphics.Typeface;
import android.graphics.drawable.Drawable;
import android.os.AsyncTask;
import android.os.Bundle;
import android.os.StatFs;
import android.support.v4.view.MenuItemCompat;
import android.support.v7.app.ActionBar;
import android.support.v7.view.ActionMode;
import android.support.v7.widget.PopupMenu;
import android.text.method.LinkMovementMethod;
import android.view.ContextMenu;
import android.view.ContextMenu.ContextMenuInfo;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.SubMenu;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ArrayAdapter;
import android.widget.CheckBox;
import android.widget.EditText;
import android.widget.ExpandableListView;
import android.widget.ExpandableListView.ExpandableListContextMenuInfo;
import android.widget.ImageButton;
import android.widget.ImageView;
import android.widget.ProgressBar;
import android.widget.TextView;
import android.widget.Toast;


public class LocalIndexesFragment extends OsmandExpandableListFragment {

	private LoadLocalIndexTask asyncLoader;
	private LocalIndexesAdapter listAdapter;
	private AsyncTask<LocalIndexInfo, ?, ?> operationTask;

	private boolean selectionMode = false;
	private Set<LocalIndexInfo> selectedItems = new LinkedHashSet<LocalIndexInfo>();
	
	protected static int DELETE_OPERATION = 1;
	protected static int BACKUP_OPERATION = 2;
	protected static int RESTORE_OPERATION = 3;
	
	MessageFormat formatMb = new MessageFormat("{0, number,##.#} MB", Locale.US);
	MessageFormat formatGb = new MessageFormat("{0, number,#.##} GB", Locale.US);
	private ContextMenuAdapter optionsMenuAdapter;
	private ActionMode actionMode;

	private TextView descriptionText;
	private ProgressBar sizeProgress;

	Drawable backup;
	Drawable sdcard;
	Drawable planet;

	@Override
	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
		View view = inflater.inflate(R.layout.local_index, container, false);

		getDownloadActivity().setSupportProgressBarIndeterminateVisibility(false);

		ExpandableListView listView = (ExpandableListView)view.findViewById(android.R.id.list);
		listAdapter = new LocalIndexesAdapter(getActivity());
		listView.setAdapter(listAdapter);
		expandAllGroups();
		setListView(listView);
		descriptionText = (TextView) view.findViewById(R.id.memory_size);
		sizeProgress = (ProgressBar) view.findViewById(R.id.memory_progress);
		updateDescriptionTextWithSize();
		colorDrawables();
		return view;
	}

	@SuppressWarnings({"unchecked","deprecation"})
	@Override
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		if (asyncLoader == null || asyncLoader.getResult() == null) {
			// getLastNonConfigurationInstance method should be in onCreate() method
			// (onResume() doesn't work)
			Object indexes = getActivity().getLastNonConfigurationInstance();
			asyncLoader = new LoadLocalIndexTask();
			if (indexes instanceof List<?>) {
				asyncLoader.setResult((List<LocalIndexInfo>) indexes);
			}
		}
		setHasOptionsMenu(true);
	}

	private void colorDrawables(){
		boolean light = getMyApplication().getSettings().isLightContent();
		backup = getActivity().getResources().getDrawable(R.drawable.ic_type_archive);
		backup.mutate();
		if (light) {
			backup.setColorFilter(getResources().getColor(R.color.icon_color_light), PorterDuff.Mode.MULTIPLY);
		}
		sdcard = getActivity().getResources().getDrawable(R.drawable.ic_sdcard);
		sdcard.mutate();
		sdcard.setColorFilter(getActivity().getResources().getColor(R.color.color_distance), PorterDuff.Mode.MULTIPLY);
	}

	@Override
	public void onResume() {
		super.onResume();
		if (asyncLoader == null || asyncLoader.getResult() == null) {
			reloadData();
		}

		getExpandableListView().setOnCreateContextMenuListener(new View.OnCreateContextMenuListener() {
			@Override
			public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo) {
				long packedPos = ((ExpandableListContextMenuInfo) menuInfo).packedPosition;
				int group = ExpandableListView.getPackedPositionGroup(packedPos);
				int child = ExpandableListView.getPackedPositionChild(packedPos);
				if (child >= 0 && group >= 0) {
					final LocalIndexInfo point = listAdapter.getChild(group, child);
					showContextMenu(point);
				}
			}
		});
	}

	public void reloadData() {
		asyncLoader = new LoadLocalIndexTask();
		asyncLoader.execute(getActivity());
	}


	private void showContextMenu(final LocalIndexInfo info) {
		Builder builder = new AlertDialog.Builder(getActivity());
		final ContextMenuAdapter adapter = new ContextMenuAdapter(getActivity());
		basicFileOperation(info, adapter);
		OsmandPlugin.onContextMenuActivity(getActivity(), null, info, adapter);

		String[] values = adapter.getItemNames();
		builder.setItems(values, new DialogInterface.OnClickListener() {
			@Override
			public void onClick(DialogInterface dialog, int which) {
				OnContextMenuClick clk = adapter.getClickAdapter(which);
				if (clk != null) {
					clk.onContextMenuClick(null, adapter.getElementId(which), which, false);
				}
			}

		});
		builder.show();
	}

	
	private void basicFileOperation(final LocalIndexInfo info, ContextMenuAdapter adapter) {
		OnContextMenuClick listener = new OnContextMenuClick() {
			@Override
			public boolean onContextMenuClick(ArrayAdapter<?> adapter, int resId, int pos, boolean isChecked) {
				return performBasicOperation(resId, info);
			}
		};
		if(info.getType() == LocalIndexType.MAP_DATA || info.getType() == LocalIndexType.SRTM_DATA || 
				info.getType() == LocalIndexType.WIKI_DATA){
			if(!info.isBackupedData()){
				adapter.item(R.string.local_index_mi_backup).listen(listener).position( 1).reg();
			}
		}
		if(info.isBackupedData()){
			adapter.item(R.string.local_index_mi_restore).listen(listener).position(2).reg();
		}
		if(info.getType() != LocalIndexType.TTS_VOICE_DATA && info.getType() != LocalIndexType.VOICE_DATA){
			adapter.item(R.string.shared_string_rename).listen(listener).position(3).reg();
		}
		adapter.item(R.string.shared_string_delete).listen(listener).position(4).reg();
	}

	private boolean performBasicOperation(int resId, final LocalIndexInfo info) {
		if (resId == R.string.shared_string_rename) {
			renameFile(getActivity(), new File(info.getPathToData()), new Runnable() {
				
				@Override
				public void run() {
					reloadIndexes();
				}
			});
		} else if (resId == R.string.local_index_mi_restore) {
			new LocalIndexOperationTask(RESTORE_OPERATION).execute(info);
		} else if (resId == R.string.shared_string_delete) {
			Builder confirm = new Builder(getActivity());
			confirm.setPositiveButton(R.string.shared_string_yes, new DialogInterface.OnClickListener() {
				@Override
				public void onClick(DialogInterface dialog, int which) {
					new LocalIndexOperationTask(DELETE_OPERATION).execute(info);
				}
			});
			confirm.setNegativeButton(R.string.shared_string_no, null);
			String fn = FileNameTranslationHelper.getFileName(getActivity(),
					getMyApplication().getResourceManager().getOsmandRegions(),
					info.getFileName());
			confirm.setMessage(getString(R.string.delete_confirmation_msg, fn));
			confirm.show();
		} else if (resId == R.string.local_index_mi_backup) {
			new LocalIndexOperationTask(BACKUP_OPERATION).execute(info);
		}
		return true;
	}

	public static void renameFile(final Activity a, final File f, final Runnable callback) {
		Builder b = new AlertDialog.Builder(a);
		if(f.exists()){
			int xt = f.getName().lastIndexOf('.');
			final String ext = xt == -1 ? "" : f.getName().substring(xt);
			final String originalName = xt == -1 ? f.getName() : f.getName().substring(0, xt);
			final EditText editText = new EditText(a);
			editText.setText(originalName);
			b.setView(editText);
			b.setPositiveButton(R.string.shared_string_save, new DialogInterface.OnClickListener() {
				
				@Override
				public void onClick(DialogInterface dialog, int which) {
					String newName = editText.getText().toString() + ext;
					File dest = new File(f.getParentFile(), newName);
					if (dest.exists()) {
						AccessibleToast.makeText(a, R.string.file_with_name_already_exists, Toast.LENGTH_LONG).show();
					} else {
						if(!dest.getParentFile().exists()) {
							dest.getParentFile().mkdirs();
						}
						if(f.renameTo(dest)){
							if(callback != null) { 
								callback.run();
							}
						} else {
							AccessibleToast.makeText(a, R.string.file_can_not_be_renamed, Toast.LENGTH_LONG).show();
						}
					}
					
				}
			});
			b.setNegativeButton(R.string.shared_string_cancel, null);
			b.show();
		}
	}

	public class LoadLocalIndexTask extends AsyncTask<Activity, LocalIndexInfo, List<LocalIndexInfo>> {

		private List<LocalIndexInfo> result;

		@Override
		protected List<LocalIndexInfo> doInBackground(Activity... params) {
			LocalIndexHelper helper = new LocalIndexHelper(getMyApplication());
			return helper.getLocalIndexData(this);
		}

		public void loadFile(LocalIndexInfo... loaded) {
			publishProgress(loaded);
		}

		@Override
		protected void onPreExecute() {
			getDownloadActivity().setSupportProgressBarIndeterminateVisibility(true);
			listAdapter.clear();
		}

		@Override
		protected void onProgressUpdate(LocalIndexInfo... values) {
			for (LocalIndexInfo v : values) {
				listAdapter.addLocalIndexInfo(v);
			}
			listAdapter.notifyDataSetChanged();
			expandAllGroups();
		}

		public void setResult(List<LocalIndexInfo> result) {
			this.result = result;
			if(result == null){
				listAdapter.clear();
			} else {
				for (LocalIndexInfo v : result) {
					listAdapter.addLocalIndexInfo(v);
				}
				listAdapter.notifyDataSetChanged();
				expandAllGroups();
				onPostExecute(result);
			}
		}

		@Override
		protected void onPostExecute(List<LocalIndexInfo> result) {
			this.result = result;
			listAdapter.sortData();
			if (getDownloadActivity() != null){
				getDownloadActivity().setSupportProgressBarIndeterminateVisibility(false);
				getDownloadActivity().setLocalIndexInfos(result);
			}
		}

		public List<LocalIndexInfo> getResult() {
			return result;
		}

	}

	private File getFileToRestore(LocalIndexInfo i){
		if(i.isBackupedData()){
			File parent = new File(i.getPathToData()).getParentFile();
			if(i.getType() == LocalIndexType.SRTM_DATA){
				parent = getMyApplication().getAppPath(IndexConstants.SRTM_INDEX_DIR);
			} else if(i.getFileName().endsWith(IndexConstants.BINARY_ROAD_MAP_INDEX_EXT)){
				parent = getMyApplication().getAppPath(IndexConstants.ROADS_INDEX_DIR);
			} else if(i.getType() == LocalIndexType.WIKI_DATA){
				parent = getMyApplication().getAppPath(IndexConstants.WIKI_INDEX_DIR);
			} else if(i.getType() == LocalIndexType.MAP_DATA){
				parent = getMyApplication().getAppPath(IndexConstants.MAPS_PATH);
			} else if(i.getType() == LocalIndexType.TILES_DATA){
				parent = getMyApplication().getAppPath(IndexConstants.TILES_INDEX_DIR);
			} else if(i.getType() == LocalIndexType.VOICE_DATA){
				parent = getMyApplication().getAppPath(IndexConstants.VOICE_INDEX_DIR);
			} else if(i.getType() == LocalIndexType.TTS_VOICE_DATA){
				parent = getMyApplication().getAppPath(IndexConstants.VOICE_INDEX_DIR);
			}
			return new File(parent, i.getFileName());
		}
		return new File(i.getPathToData());
	}
	
	private File getFileToBackup(LocalIndexInfo i) {
		if(!i.isBackupedData()){
			return new File(getMyApplication().getAppPath(IndexConstants.BACKUP_INDEX_DIR), i.getFileName());
		}
		return new File(i.getPathToData());
	}
	
	private boolean move(File from, File to){
		if(!to.getParentFile().exists()){
			to.getParentFile().mkdirs();
		}
		return from.renameTo(to);
	}
	
	public class LocalIndexOperationTask extends AsyncTask<LocalIndexInfo, LocalIndexInfo, String> {
		
		private final int operation;

		public LocalIndexOperationTask(int operation){
			this.operation = operation;
		}
		
		
		@Override
		protected String doInBackground(LocalIndexInfo... params) {
			int count = 0;
			int total = 0;
			for(LocalIndexInfo info : params) {
				if(!isCancelled()){
					boolean successfull = false;
					if(operation == DELETE_OPERATION){
						File f = new File(info.getPathToData());
						successfull = Algorithms.removeAllFiles(f);
					} else if(operation == RESTORE_OPERATION){
						successfull = move(new File(info.getPathToData()), getFileToRestore(info));
						if(successfull){
							info.setBackupedData(false);
						}
					} else if(operation == BACKUP_OPERATION){
						successfull = move(new File(info.getPathToData()), getFileToBackup(info));
						if(successfull){
							info.setBackupedData(true);
							getMyApplication().getResourceManager().closeFile(info.getFileName());
						}
					}
					total ++;
					if(successfull){
						count++;
						publishProgress(info);
					}
				}
			}
			if(operation == DELETE_OPERATION){
				return getString(R.string.local_index_items_deleted, count, total);
			} else if(operation == BACKUP_OPERATION){
				return getString(R.string.local_index_items_backuped, count, total);
			} else if(operation == RESTORE_OPERATION){
				return getString(R.string.local_index_items_restored, count, total);
			}  
			
			return "";
		}


		@Override
		protected void onProgressUpdate(LocalIndexInfo... values) {
			if(operation == DELETE_OPERATION){
				listAdapter.delete(values);
			} else if(operation == BACKUP_OPERATION){
				listAdapter.move(values, false);
			} else if(operation == RESTORE_OPERATION){
				listAdapter.move(values, true);
			}
			
		}
		
		@Override
		protected void onPreExecute() {
			getDownloadActivity().setProgressBarIndeterminateVisibility(true);
		}

		@Override
		protected void onPostExecute(String result) {
			getDownloadActivity().setProgressBarIndeterminateVisibility(false);
			AccessibleToast.makeText(getDownloadActivity(), result, Toast.LENGTH_LONG).show();
			if (operation == RESTORE_OPERATION || operation == BACKUP_OPERATION){
				listAdapter.clear();
				reloadIndexes();
			}
		}
	}
	
	


	@Override
	public boolean onChildClick(ExpandableListView parent, View v, int groupPosition, int childPosition, long id) {
		LocalIndexInfo child = listAdapter.getChild(groupPosition, childPosition);
		if (!selectionMode){
			openPopUpMenu(v, child);
			return true;
		}
		selectedItems.add(child);
		listAdapter.notifyDataSetChanged();
		return true;
	}
	
	public Set<LocalIndexInfo> getSelectedItems() {
		return selectedItems;
	}
	
	


	@Override
	public void onPause() {
		super.onPause();
		if(operationTask != null){
			operationTask.cancel(true);
		}
	}

	@Override
	public void onDestroy() {
		super.onDestroy();
		asyncLoader.cancel(true);
	}
	

	@SuppressWarnings("deprecation")
	@Override
	public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
		if (!this.isAdded()) {
			return;
		}

		//fixes issue when local files not shown after switching tabs
		//Next line throws NPE in some circumstances when called from dashboard and listAdpater=null is not checked for. (Checking !this.isAdded above is not sufficient!)
		if (listAdapter != null && listAdapter.getGroupCount() == 0 && getDownloadActivity().getLocalIndexInfos().size() > 0) {
			for(LocalIndexInfo info : getDownloadActivity().getLocalIndexInfos()) {
				listAdapter.addLocalIndexInfo(info);
			}
			listAdapter.sortData();
			getExpandableListView().setAdapter(listAdapter);
			expandAllGroups();
		}
		ActionBar actionBar = getDownloadActivity().getSupportActionBar();
		//hide action bar from downloadindexfragment
		actionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_STANDARD);
		optionsMenuAdapter = new ContextMenuAdapter(getDownloadActivity());
		OnContextMenuClick listener = new OnContextMenuClick() {
			@Override
			public boolean onContextMenuClick(ArrayAdapter<?> adapter, int itemId, int pos, boolean isChecked) {
				localOptionsMenu(itemId);
				return true;
			}
		};
		optionsMenuAdapter.item(R.string.local_index_mi_reload)
				.icon(R.drawable.ic_action_refresh_dark)
				.listen(listener).position(1).reg();
		optionsMenuAdapter.item(R.string.shared_string_delete)
				.icon(R.drawable.ic_action_delete_dark)
				.listen(listener).position(2).reg();
		optionsMenuAdapter.item(R.string.local_index_mi_backup)
				.listen(listener).position(3).reg();
		optionsMenuAdapter.item(R.string.local_index_mi_restore)
				.listen(listener).position(4).reg();
		// doesn't work correctly
		//int max =  getResources().getInteger(R.integer.abs__max_action_buttons);
		int max = 3;
		SubMenu split = null;
		for (int j = 0; j < optionsMenuAdapter.length(); j++) {
			MenuItem item;
			if (j + 1 >= max && optionsMenuAdapter.length() > max) {
				if (split == null) {
					split = menu.addSubMenu(0, 1, j + 1, R.string.shared_string_more_actions);
					split.setIcon(R.drawable.ic_overflow_menu_white);
					split.getItem();
					MenuItemCompat.setShowAsAction(split.getItem(),MenuItemCompat.SHOW_AS_ACTION_ALWAYS);
				}
				item = split.add(0, optionsMenuAdapter.getElementId(j), j + 1, optionsMenuAdapter.getItemName(j));
				MenuItemCompat.setShowAsAction(item, MenuItemCompat.SHOW_AS_ACTION_ALWAYS );
			} else {
				item = menu.add(0, optionsMenuAdapter.getElementId(j), j + 1, optionsMenuAdapter.getItemName(j));
				MenuItemCompat.setShowAsAction(item, MenuItemCompat.SHOW_AS_ACTION_ALWAYS );
			}
			OsmandApplication app = getMyApplication();
			if (optionsMenuAdapter.getImage(app, j, isLightActionBar()) != null) {
				item.setIcon(optionsMenuAdapter.getImage(app, j, isLightActionBar()));
			}
			
		}

		if(operationTask == null || operationTask.getStatus() == AsyncTask.Status.FINISHED){
			menu.setGroupVisible(0, true);
		} else {
			menu.setGroupVisible(0, false);
		}
	}
	
	@Override
	public boolean onOptionsItemSelected(MenuItem item) {
		int itemId = item.getItemId();
		for (int i = 0; i < optionsMenuAdapter.length(); i++) {
			if (itemId == optionsMenuAdapter.getElementId(i)) {
				optionsMenuAdapter.getClickAdapter(i).onContextMenuClick(null, itemId, i, false);
				return true;
			}
		}
		return super.onOptionsItemSelected(item);
	}
	
	public void doAction(int actionResId){
		if(actionResId == R.string.local_index_mi_backup){
			operationTask = new LocalIndexOperationTask(BACKUP_OPERATION);
		} else if(actionResId == R.string.shared_string_delete){
			operationTask = new LocalIndexOperationTask(DELETE_OPERATION);
		} else if(actionResId == R.string.local_index_mi_restore){
			operationTask = new LocalIndexOperationTask(RESTORE_OPERATION);
		} else {
			operationTask = null;
		}
		if(operationTask != null){
			operationTask.execute(selectedItems.toArray(new LocalIndexInfo[selectedItems.size()]));
		}
		if(actionMode != null) {
			actionMode.finish();
		}
	}
	
	
	private void expandAllGroups() {
		for (int i = 0; i < listAdapter.getGroupCount(); i++) {
			getExpandableListView().expandGroup(i);
		}
	}
	
	private void openSelectionMode(final int actionResId, final int actionIconId, 
			final DialogInterface.OnClickListener listener){
		String value = getString(actionResId);
		if (value.endsWith("...")) {
			value = value.substring(0, value.length() - 3);
		}
		final String actionButton = value;
		if(listAdapter.getGroupCount() == 0){
			listAdapter.cancelFilter();
			expandAllGroups();
			listAdapter.notifyDataSetChanged();
			AccessibleToast.makeText(getDownloadActivity(), getString(R.string.local_index_no_items_to_do, actionButton.toLowerCase()), Toast.LENGTH_SHORT).show();
			return;
		}
		expandAllGroups();
		
		selectionMode = true;
		selectedItems.clear();
		actionMode = getDownloadActivity().startSupportActionMode(new ActionMode.Callback() {

			@Override
			public boolean onCreateActionMode(ActionMode mode, Menu menu) {
				selectionMode = true;
				MenuItem it = menu.add(actionResId);
				if (actionIconId != 0) {
					it.setIcon(actionIconId);
				}
				MenuItemCompat.setShowAsAction(it, MenuItemCompat.SHOW_AS_ACTION_IF_ROOM |
						MenuItemCompat.SHOW_AS_ACTION_WITH_TEXT);
				return true;
			}

			@Override
			public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
				return false;
			}

			@Override
			public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
				if (selectedItems.isEmpty()) {
					AccessibleToast.makeText(getDownloadActivity(),
							getString(R.string.local_index_no_items_to_do, actionButton.toLowerCase()), Toast.LENGTH_SHORT).show();
					return true;
				}

				Builder builder = new AlertDialog.Builder(getDownloadActivity());
				builder.setMessage(getString(R.string.local_index_action_do, actionButton.toLowerCase(), selectedItems.size()));
				builder.setPositiveButton(actionButton, listener);
				builder.setNegativeButton(R.string.shared_string_cancel, null);
				builder.show();
				return true;
			}

			@Override
			public void onDestroyActionMode(ActionMode mode) {
				selectionMode = false;
				descriptionText.setVisibility(View.VISIBLE);
				updateDescriptionTextWithSize();
				listAdapter.cancelFilter();
				expandAllGroups();
				listAdapter.notifyDataSetChanged();
			}

		});
		//findViewById(R.id.DescriptionText).setVisibility(View.GONE);
		listAdapter.notifyDataSetChanged();
	}

	@SuppressWarnings("deprecation")
	private void updateDescriptionTextWithSize(){
		File dir = getMyApplication().getAppPath("").getParentFile();
		String size = formatGb.format(new Object[]{0});
		int percent = 0;
		if(dir.canRead()){
			StatFs fs = new StatFs(dir.getAbsolutePath());
			size = formatGb.format(new Object[]{(float) (fs.getAvailableBlocks()) * fs.getBlockSize() / (1 << 30) });
			percent = (int) (fs.getAvailableBlocks() * 100 / fs.getBlockCount());
		}
		sizeProgress.setProgress(percent);
		String text = getString(R.string.free, size);
		int l = text.indexOf('.');
		if(l == -1) {
			l = text.length();
		}
		descriptionText.setText(text);
		descriptionText.setMovementMethod(LinkMovementMethod.getInstance());
	}

	public void localOptionsMenu(final int itemId) {
		if (itemId == R.string.local_index_mi_reload) {
			reloadIndexes();
		} else if (itemId == R.string.shared_string_delete) {
			openSelectionMode(itemId, R.drawable.ic_action_delete_dark,
					new DialogInterface.OnClickListener() {

						@Override
						public void onClick(DialogInterface dialog, int which) {
							doAction(itemId);
						}
					}, null, null);
		} else if (itemId == R.string.local_index_mi_backup) {
			openSelectionMode(itemId, R.drawable.ic_type_archive,
					new DialogInterface.OnClickListener() {

						@Override
						public void onClick(DialogInterface dialog, int which) {
							doAction(itemId);
						}
					}, Boolean.FALSE, LocalIndexType.MAP_DATA);
		} else if (itemId == R.string.local_index_mi_restore) {
			openSelectionMode(itemId, R.drawable.ic_type_archive,
					new DialogInterface.OnClickListener() {

						@Override
						public void onClick(DialogInterface dialog, int which) {
							doAction(itemId);
						}
					}, Boolean.TRUE, LocalIndexType.MAP_DATA);
			listAdapter.filterCategories(true);
		}
	}
	
	public void openSelectionMode(int stringRes, int darkIcon, DialogInterface.OnClickListener listener, Boolean backup,
			LocalIndexType filter) {
		if (backup != null) {
			listAdapter.filterCategories(backup);
		}
		if (filter != null) {
			listAdapter.filterCategories(filter);
		}
		openSelectionMode(stringRes, darkIcon, listener);
	}
	

	public void reloadIndexes() {
		listAdapter.clear();
		asyncLoader = new LoadLocalIndexTask();
		AsyncTask<Void, String, List<String>> task = new AsyncTask<Void, String, List<String>>(){

			@Override
			protected void onPostExecute(List<String> warnings) {
				if ( getDownloadActivity() == null) {
					return;
				}
				getDownloadActivity().setSupportProgressBarIndeterminateVisibility(false);
				if (!warnings.isEmpty()) {
					final StringBuilder b = new StringBuilder();
					boolean f = true;
					for (String w : warnings) {
						if (f) {
							f = false;
						} else {
							b.append('\n');
						}
						b.append(w);
					}
					AccessibleToast.makeText(getDownloadActivity(), b.toString(), Toast.LENGTH_LONG).show();
				}
				if(asyncLoader.getStatus() == Status.PENDING) {
					asyncLoader.execute(getDownloadActivity());
				}
			}
			
			@Override
			protected void onPreExecute() {
				super.onPreExecute();
				getDownloadActivity().setSupportProgressBarIndeterminateVisibility(true);
			}
			@Override
			protected List<String> doInBackground(Void... params) {
				return getMyApplication().getResourceManager().reloadIndexes(IProgress.EMPTY_PROGRESS,
						new ArrayList<String>()
						);
			}
			
		};
		task.execute();
		
	}

	

	protected class LocalIndexesAdapter extends OsmandBaseExpandableListAdapter {
		
		Map<LocalIndexInfo, List<LocalIndexInfo>> data = new LinkedHashMap<LocalIndexInfo, List<LocalIndexInfo>>();
		List<LocalIndexInfo> category = new ArrayList<LocalIndexInfo>();
		List<LocalIndexInfo> filterCategory = null;
		int warningColor;
		int okColor;
		int corruptedColor;
		Context ctx;

		public LocalIndexesAdapter(Context ctx) {
			this.ctx = ctx;
			warningColor = ctx.getResources().getColor(R.color.color_warning);
			okColor = ctx.getResources().getColor(R.color.color_ok);
			TypedArray ta = ctx.getTheme().obtainStyledAttributes(new int[]{android.R.attr.textColorPrimary});
			ta.recycle();
			corruptedColor = ctx.getResources().getColor(R.color.color_invalid);
		}
		
		public void clear() {
			data.clear();
			category.clear();
			filterCategory = null;
			notifyDataSetChanged();
		}
		
		public void sortData() {
			final Collator cl = Collator.getInstance();
			for(List<LocalIndexInfo> i : data.values()) {
				Collections.sort(i, new Comparator<LocalIndexInfo>() {
					@Override
					public int compare(LocalIndexInfo lhs, LocalIndexInfo rhs) {
						return cl.compare(getNameToDisplay(lhs), getNameToDisplay(rhs));
					}
				});
			}
		}

		public LocalIndexInfo findCategory(LocalIndexInfo val, boolean backuped){
			for(LocalIndexInfo i : category){
				if(i.isBackupedData() == backuped && val.getType() == i.getType() && 
						Algorithms.objectEquals(i.getSubfolder(), val.getSubfolder())){
					return i;
				}
			}
			LocalIndexInfo newCat = new LocalIndexInfo(val.getType(), backuped, val.getSubfolder());
			category.add(newCat);
			data.put(newCat, new ArrayList<LocalIndexInfo>());
			return newCat;
		}
		
		public void delete(LocalIndexInfo[] values) {
			for(LocalIndexInfo i : values){
				LocalIndexInfo c = findCategory(i, i.isBackupedData());
				if(c != null){
					data.get(c).remove(i);
					if (data.get(c).size() == 0){
						data.remove(c);
						category.remove(c);
					}
				}
			}
			listAdapter.notifyDataSetChanged();
		}
		
		public void move(LocalIndexInfo[] values, boolean oldBackupState) {
			for(LocalIndexInfo i : values){
				LocalIndexInfo c = findCategory(i, oldBackupState);
				if(c != null){
					data.get(c).remove(i);
				}
				c = findCategory(i, !oldBackupState);
				if(c != null){
					data.get(c).add(i);
				}
			}
			listAdapter.notifyDataSetChanged();
			expandAllGroups();
		}

		public void cancelFilter(){
			filterCategory = null;
			notifyDataSetChanged();
		}
		
		public void filterCategories(LocalIndexType... types) {
			List<LocalIndexInfo> filter = new ArrayList<LocalIndexInfo>();
			List<LocalIndexInfo> source = filterCategory == null ? category : filterCategory;
			for (LocalIndexInfo info : source) {
				for (LocalIndexType ts : types) {
					if (info.getType() == ts) {
						filter.add(info);
					}
				}
			}
			filterCategory = filter;
			notifyDataSetChanged();
		}
		
		public void filterCategories(boolean backup) {
			List<LocalIndexInfo> filter = new ArrayList<LocalIndexInfo>();
			List<LocalIndexInfo> source = filterCategory == null ? category : filterCategory;
			for (LocalIndexInfo info : source) {
				if (info.isBackupedData() == backup) {
					filter.add(info);
				}
			}
			filterCategory = filter;
			notifyDataSetChanged();
		}

		public void addLocalIndexInfo(LocalIndexInfo info) {
			int found = -1;
			// search from end
			for (int i = category.size() - 1; i >= 0; i--) {
				LocalIndexInfo cat = category.get(i);
				if (cat.getType() == info.getType() && info.isBackupedData() == cat.isBackupedData() &&
						Algorithms.objectEquals(info.getSubfolder(), cat.getSubfolder())) {
					found = i;
					break;
				}
			}
			if (found == -1) {
				found = category.size();
				category.add(new LocalIndexInfo(info.getType(), info.isBackupedData(), info.getSubfolder()));
			}
			if (!data.containsKey(category.get(found))) {
				data.put(category.get(found), new ArrayList<LocalIndexInfo>());
			}
			data.get(category.get(found)).add(info);
		}

		@Override
		public LocalIndexInfo getChild(int groupPosition, int childPosition) {
			LocalIndexInfo cat = filterCategory != null ? filterCategory.get(groupPosition) : category.get(groupPosition);
			return data.get(cat).get(childPosition);
		}

		@Override
		public long getChildId(int groupPosition, int childPosition) {
			// it would be unusable to have 10000 local indexes
			return groupPosition * 10000 + childPosition;
		}

		@Override
		public View getChildView(final int groupPosition, final int childPosition, boolean isLastChild, View convertView, ViewGroup parent) {
			View v = convertView;
			final LocalIndexInfo child = getChild(groupPosition, childPosition);
			if (v == null ) {
				LayoutInflater inflater = (LayoutInflater) getDownloadActivity().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
				v = inflater.inflate(net.osmand.plus.R.layout.local_index_list_item, parent, false);
			}
			TextView viewName = ((TextView) v.findViewById(R.id.local_index_name));
			ImageButton options = (ImageButton) v.findViewById(R.id.options);
			options.setImageDrawable(getMyApplication().getIconsCache().getContentIcon(R.drawable.ic_overflow_menu_white));
			options.setOnClickListener(new View.OnClickListener() {
				@Override
				public void onClick(View v) {
					openPopUpMenu(v, child);
				}
			});
			ImageView icon = (ImageView) v.findViewById(R.id.icon);
			if (child.isBackupedData()) {
				icon.setImageDrawable(backup);
			} else {
				icon.setImageDrawable(sdcard);
			}

			viewName.setText(getNameToDisplay(child));
			if (child.isNotSupported()) {
				viewName.setTextColor(warningColor);
			} else if (child.isCorrupted()) {
				viewName.setTextColor(corruptedColor);
			} else if (child.isLoaded()) {
				// users confused okColor here with "uptodate", so let's leave white (black in dark app theme) as "isLoaded"
				//viewName.setTextColor(okColor);
			}
			if (child.isBackupedData()) {
				viewName.setTypeface(Typeface.DEFAULT, Typeface.ITALIC);
			} else {
				viewName.setTypeface(Typeface.DEFAULT, Typeface.NORMAL);
			}
			TextView sizeText = (TextView) v.findViewById(R.id.local_index_size);
			if (child.getSize() >= 0) {
				String size;
				if (child.getSize() > 100) {
					size = formatMb.format(new Object[] { (float) child.getSize() / (1 << 10) });
				} else {
					size = child.getSize() + " kB";
				}
				sizeText.setText(size);
				sizeText.setVisibility(View.VISIBLE);
			} else {
				sizeText.setVisibility(View.GONE);
			}

			TextView descr = ((TextView) v.findViewById(R.id.local_index_descr));
			if (child.getType() == LocalIndexType.TILES_DATA) {
				descr.setText(R.string.online_map);
			} else {
				descr.setVisibility(View.VISIBLE);
				descr.setText(child.getDescription());
			}



			final CheckBox checkbox = (CheckBox) v.findViewById(R.id.check_local_index);
			checkbox.setVisibility(selectionMode ? View.VISIBLE : View.GONE);
			if (selectionMode) {
				icon.setVisibility(View.GONE);
				options.setVisibility(View.GONE);
				checkbox.setChecked(selectedItems.contains(child));
				checkbox.setOnClickListener(new View.OnClickListener() {
					
					@Override
					public void onClick(View v) {
						if(checkbox.isChecked()){
							selectedItems.add(child);
						} else {
							selectedItems.remove(child);
						}
					}
				});

			} else {
				options.setVisibility(View.VISIBLE);
				icon.setVisibility(View.VISIBLE);
			}

			v.setOnClickListener(new View.OnClickListener() {
				@Override
				public void onClick(View v) {
					onChildClick(null, v, groupPosition, childPosition, 0);
				}
			});
			return v;
		}

		
		private String getNameToDisplay(LocalIndexInfo child) {
			String mapDescr = getMapDescription(child.getFileName());
			String mapName = FileNameTranslationHelper.getFileName(ctx,
					((OsmandApplication) getDownloadActivity().getApplication()).getResourceManager().getOsmandRegions(),
					child.getFileName());
			if (mapDescr.length() > 0) {
				return mapName + " - " + mapDescr;
			} else {
				return mapName;
			}
		}

		@Override
		public View getGroupView(int groupPosition, boolean isExpanded, View convertView, ViewGroup parent) {
			View v = convertView;
			LocalIndexInfo group = getGroup(groupPosition);
			if (v == null) {
				LayoutInflater inflater = (LayoutInflater) getDownloadActivity().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
				v = inflater.inflate(R.layout.local_index_list_category, parent, false);
			}
			StringBuilder name = new StringBuilder(group.getType().getHumanString(getDownloadActivity()));
			if(group.getSubfolder() != null) {
				name.append(" ").append(group.getSubfolder());
			}
			if (group.isBackupedData()) {
				name.append(" - ").append(getString(R.string.local_indexes_cat_backup));
			}
			TextView nameView = ((TextView) v.findViewById(R.id.category_name));
			TextView sizeView = ((TextView) v.findViewById(R.id.category_size));
			List<LocalIndexInfo> list = data.get(group);
			int size = 0;
			for (LocalIndexInfo aList : list) {
				int sz = aList.getSize();
				if (sz < 0) {
					size = 0;
					break;
				} else {
					size += sz;
				}
			}
			String sz = "";
			if (size > 0) {
				if (size > 1 << 20) {
					sz = formatGb.format(new Object[] { (float) size / (1 << 20) });
				} else {
					sz = formatMb.format(new Object[] { (float) size / (1 << 10) });
				}

			}
			sizeView.setText(sz);
			nameView.setText(name.toString());
			if (!group.isBackupedData()) {
				nameView.setTypeface(Typeface.DEFAULT, Typeface.NORMAL);
			} else {
				nameView.setTypeface(Typeface.DEFAULT, Typeface.ITALIC);
			}

			v.setOnClickListener(null);
			return v;
		}

		@Override
		public int getChildrenCount(int groupPosition) {
			LocalIndexInfo cat = filterCategory != null ? filterCategory.get(groupPosition) : category.get(groupPosition);
			return data.get(cat).size();
		}

		@Override
		public LocalIndexInfo getGroup(int groupPosition) {
			return filterCategory == null ?  category.get(groupPosition)  : filterCategory.get(groupPosition);
		}

		@Override
		public int getGroupCount() {
			return filterCategory == null ?  category.size() : filterCategory.size();
		}

		@Override
		public long getGroupId(int groupPosition) {
			return groupPosition;
		}

		@Override
		public boolean hasStableIds() {
			return false;
		}

		@Override
		public boolean isChildSelectable(int groupPosition, int childPosition) {
			return true;
		}



		private String getMapDescription(String fileName){
			if (fileName.endsWith(IndexConstants.BINARY_ROAD_MAP_INDEX_EXT)) {
				return ctx.getString(R.string.download_roads_only_item);
			}
			return "";
		}
	}
	
	private void openPopUpMenu(View v, final LocalIndexInfo info) {
		IconsCache iconsCache = getMyApplication().getIconsCache();
		final PopupMenu optionsMenu = new PopupMenu(getActivity(), v);
		DirectionsDialogs.setupPopUpMenuIcon(optionsMenu);
		final boolean restore = info.isBackupedData();
		MenuItem item;
		if (info.getType() == LocalIndexType.MAP_DATA) {
			item = optionsMenu.getMenu().add(restore? R.string.local_index_mi_restore : R.string.local_index_mi_backup)
					.setIcon(backup);
			item.setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {
				@Override
				public boolean onMenuItemClick(MenuItem item) {
					performBasicOperation(restore ? R.string.local_index_mi_restore : R.string.local_index_mi_backup, info);
					return true;
				}
			});
		}

		item = optionsMenu.getMenu().add(R.string.shared_string_rename)
				.setIcon(iconsCache.getContentIcon(R.drawable.ic_action_edit_dark));
		item.setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {
			@Override
			public boolean onMenuItemClick(MenuItem item) {
				performBasicOperation(R.string.shared_string_rename, info);
				return true;
			}
		});

		item = optionsMenu.getMenu().add(R.string.shared_string_delete)
				.setIcon(iconsCache.getContentIcon(R.drawable.ic_action_delete_dark));
		item.setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {
			@Override
			public boolean onMenuItemClick(MenuItem item) {
				performBasicOperation(R.string.shared_string_delete, info);
				return true;
			}
		});
		if(getMyApplication().getSettings().BETA_TESTING_LIVE_UPDATES.get()) {
			item = optionsMenu.getMenu().add("Live updates")
					.setIcon(iconsCache.getContentIcon(R.drawable.ic_action_refresh_dark));
			item.setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {
				@Override
				public boolean onMenuItemClick(MenuItem item) {
					runLiveUpdate(info);
					return true;
				}
			});
		}
		
		optionsMenu.show();
	}
	
	private void runLiveUpdate(final LocalIndexInfo info) {
		final String fnExt = Algorithms.getFileNameWithoutExtension(new File(info.getFileName()));
		new AsyncTask<Object, Object, IncrementalUpdateList>() {

			protected void onPreExecute() {
				getDownloadActivity().setSupportProgressBarIndeterminateVisibility(true);

			};

			@Override
			protected IncrementalUpdateList doInBackground(Object... params) {
				IncrementalChangesManager cm = getMyApplication().getResourceManager().getChangesManager();
				return cm.getUpdatesByMonth(fnExt);
			}

			protected void onPostExecute(IncrementalUpdateList result) {
				getDownloadActivity().setSupportProgressBarIndeterminateVisibility(false);
				if (result.errorMessage != null) {
					Toast.makeText(getDownloadActivity(), result.errorMessage, Toast.LENGTH_SHORT).show();
				} else {
					List<IncrementalUpdate> ll = result.getItemsForUpdate();
					if(ll.isEmpty()) {
						Toast.makeText(getDownloadActivity(), R.string.no_updates_available, Toast.LENGTH_SHORT).show();
					} else {
						for (IncrementalUpdate iu : ll) {
							IndexItem ii = new IndexItem(iu.fileName, "Incremental update", iu.timestamp, iu.sizeText,
									iu.contentSize, iu.containerSize, DownloadActivityType.LIVE_UPDATES_FILE);
							getDownloadActivity().addToDownload(ii);
							getDownloadActivity().updateDownloadButton();
						}
					}
				}

			};

		}.execute(new Object[] { fnExt });
	}


	private DownloadActivity getDownloadActivity() {
		return (DownloadActivity) getActivity();
	}
}
!@#$%
20190530_031937,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_c08944
package net.osmand.plus.download;

import java.io.File;
import java.text.Collator;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;

import net.osmand.IProgress;
import net.osmand.IndexConstants;
import net.osmand.access.AccessibleToast;
import net.osmand.plus.ContextMenuAdapter;
import net.osmand.plus.ContextMenuAdapter.OnContextMenuClick;
import net.osmand.plus.IconsCache;
import net.osmand.plus.OsmandApplication;
import net.osmand.plus.OsmandPlugin;
import net.osmand.plus.R;
import net.osmand.plus.activities.LocalIndexHelper;
import net.osmand.plus.activities.LocalIndexHelper.LocalIndexType;
import net.osmand.plus.activities.LocalIndexInfo;
import net.osmand.plus.activities.OsmandBaseExpandableListAdapter;
import net.osmand.plus.activities.OsmandExpandableListFragment;
import net.osmand.plus.dialogs.DirectionsDialogs;
import net.osmand.plus.helpers.FileNameTranslationHelper;
import net.osmand.plus.resources.IncrementalChangesManager;
import net.osmand.plus.resources.IncrementalChangesManager.IncrementalUpdate;
import net.osmand.plus.resources.IncrementalChangesManager.IncrementalUpdateList;
import net.osmand.util.Algorithms;
import android.app.Activity;
import android.app.AlertDialog;
import android.app.AlertDialog.Builder;
import android.content.Context;
import android.content.DialogInterface;
import android.content.res.TypedArray;
import android.graphics.PorterDuff;
import android.graphics.Typeface;
import android.graphics.drawable.Drawable;
import android.os.AsyncTask;
import android.os.Bundle;
import android.os.StatFs;
import android.support.v4.view.MenuItemCompat;
import android.support.v7.app.ActionBar;
import android.support.v7.view.ActionMode;
import android.support.v7.widget.PopupMenu;
import android.text.method.LinkMovementMethod;
import android.view.ContextMenu;
import android.view.ContextMenu.ContextMenuInfo;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.SubMenu;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ArrayAdapter;
import android.widget.CheckBox;
import android.widget.EditText;
import android.widget.ExpandableListView;
import android.widget.ExpandableListView.ExpandableListContextMenuInfo;
import android.widget.ImageButton;
import android.widget.ImageView;
import android.widget.ProgressBar;
import android.widget.TextView;
import android.widget.Toast;


public class LocalIndexesFragment extends OsmandExpandableListFragment {

	private LoadLocalIndexTask asyncLoader;
	private LocalIndexesAdapter listAdapter;
	private AsyncTask<LocalIndexInfo, ?, ?> operationTask;

	private boolean selectionMode = false;
	private Set<LocalIndexInfo> selectedItems = new LinkedHashSet<LocalIndexInfo>();
	
	protected static int DELETE_OPERATION = 1;
	protected static int BACKUP_OPERATION = 2;
	protected static int RESTORE_OPERATION = 3;
	
	MessageFormat formatMb = new MessageFormat("{0, number,##.#} MB", Locale.US);
	MessageFormat formatGb = new MessageFormat("{0, number,#.##} GB", Locale.US);
	private ContextMenuAdapter optionsMenuAdapter;
	private ActionMode actionMode;

	private TextView descriptionText;
	private ProgressBar sizeProgress;

	Drawable backup;
	Drawable sdcard;
	Drawable planet;

	@Override
	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
		View view = inflater.inflate(R.layout.local_index, container, false);

		getDownloadActivity().setSupportProgressBarIndeterminateVisibility(false);

		ExpandableListView listView = (ExpandableListView)view.findViewById(android.R.id.list);
		listAdapter = new LocalIndexesAdapter(getActivity());
		listView.setAdapter(listAdapter);
		expandAllGroups();
			setListView(listView);
		descriptionText = (TextView) view.findViewById(R.id.memory_size);
		sizeProgress = (ProgressBar) view.findViewById(R.id.memory_progress);
		updateDescriptionTextWithSize();
		colorDrawables();
		return view;
	}

	@SuppressWarnings({"unchecked","deprecation"})
	@Override
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		if (asyncLoader == null || asyncLoader.getResult() == null) {
			// getLastNonConfigurationInstance method should be in onCreate() method
			// (onResume() doesn't work)
			Object indexes = getActivity().getLastNonConfigurationInstance();
			asyncLoader = new LoadLocalIndexTask();
			if (indexes instanceof List<?>) {
				asyncLoader.setResult((List<LocalIndexInfo>) indexes);
			}
		}
		setHasOptionsMenu(true);
	}

	private void colorDrawables(){
		boolean light = getMyApplication().getSettings().isLightContent();
		backup = getActivity().getResources().getDrawable(R.drawable.ic_type_archive);
		backup.mutate();
		if (light) {
			backup.setColorFilter(getResources().getColor(R.color.icon_color), PorterDuff.Mode.MULTIPLY);
		}
		sdcard = getActivity().getResources().getDrawable(R.drawable.ic_sdcard);
		sdcard.mutate();
		sdcard.setColorFilter(getActivity().getResources().getColor(R.color.color_distance), PorterDuff.Mode.MULTIPLY);
	}

	@Override
	public void onResume() {
		super.onResume();
		if (asyncLoader == null || asyncLoader.getResult() == null) {
			reloadData();
		}

		getExpandableListView().setOnCreateContextMenuListener(new View.OnCreateContextMenuListener() {
			@Override
			public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo) {
				long packedPos = ((ExpandableListContextMenuInfo) menuInfo).packedPosition;
				int group = ExpandableListView.getPackedPositionGroup(packedPos);
				int child = ExpandableListView.getPackedPositionChild(packedPos);
				if (child >= 0 && group >= 0) {
					final LocalIndexInfo point = listAdapter.getChild(group, child);
					showContextMenu(point);
				}
			}
		});
	}

	public void reloadData() {
		asyncLoader = new LoadLocalIndexTask();
		asyncLoader.execute(getActivity());
	}


	private void showContextMenu(final LocalIndexInfo info) {
		Builder builder = new AlertDialog.Builder(getActivity());
		final ContextMenuAdapter adapter = new ContextMenuAdapter(getActivity());
		basicFileOperation(info, adapter);
		OsmandPlugin.onContextMenuActivity(getActivity(), null, info, adapter);

		String[] values = adapter.getItemNames();
		builder.setItems(values, new DialogInterface.OnClickListener() {
			@Override
			public void onClick(DialogInterface dialog, int which) {
				OnContextMenuClick clk = adapter.getClickAdapter(which);
				if (clk != null) {
					clk.onContextMenuClick(null, adapter.getElementId(which), which, false);
				}
			}

		});
		builder.show();
	}

	
	private void basicFileOperation(final LocalIndexInfo info, ContextMenuAdapter adapter) {
		OnContextMenuClick listener = new OnContextMenuClick() {
			@Override
			public boolean onContextMenuClick(ArrayAdapter<?> adapter, int resId, int pos, boolean isChecked) {
				return performBasicOperation(resId, info);
			}
		};
		if(info.getType() == LocalIndexType.MAP_DATA || info.getType() == LocalIndexType.SRTM_DATA || 
				info.getType() == LocalIndexType.WIKI_DATA){
			if(!info.isBackupedData()){
				adapter.item(R.string.local_index_mi_backup).listen(listener).position( 1).reg();
			}
		}
		if(info.isBackupedData()){
			adapter.item(R.string.local_index_mi_restore).listen(listener).position(2).reg();
		}
		if(info.getType() != LocalIndexType.TTS_VOICE_DATA && info.getType() != LocalIndexType.VOICE_DATA){
			adapter.item(R.string.shared_string_rename).listen(listener).position(3).reg();
		}
		adapter.item(R.string.shared_string_delete).listen(listener).position(4).reg();
	}

	private boolean performBasicOperation(int resId, final LocalIndexInfo info) {
		if (resId == R.string.shared_string_rename) {
			renameFile(getActivity(), new File(info.getPathToData()), new Runnable() {
				
				@Override
				public void run() {
					reloadIndexes();
				}
			});
		} else if (resId == R.string.local_index_mi_restore) {
			new LocalIndexOperationTask(RESTORE_OPERATION).execute(info);
		} else if (resId == R.string.shared_string_delete) {
			Builder confirm = new Builder(getActivity());
			confirm.setPositiveButton(R.string.shared_string_yes, new DialogInterface.OnClickListener() {
				@Override
				public void onClick(DialogInterface dialog, int which) {
					new LocalIndexOperationTask(DELETE_OPERATION).execute(info);
				}
			});
			confirm.setNegativeButton(R.string.shared_string_no, null);
			String fn = FileNameTranslationHelper.getFileName(getActivity(),
					getMyApplication().getResourceManager().getOsmandRegions(),
					info.getFileName());
			confirm.setMessage(getString(R.string.delete_confirmation_msg, fn));
			confirm.show();
		} else if (resId == R.string.local_index_mi_backup) {
			new LocalIndexOperationTask(BACKUP_OPERATION).execute(info);
		}
		return true;
	}

	public static void renameFile(final Activity a, final File f, final Runnable callback) {
		Builder b = new AlertDialog.Builder(a);
		if(f.exists()){
			int xt = f.getName().lastIndexOf('.');
			final String ext = xt == -1 ? "" : f.getName().substring(xt);
			final String originalName = xt == -1 ? f.getName() : f.getName().substring(0, xt);
			final EditText editText = new EditText(a);
			editText.setText(originalName);
			b.setView(editText);
			b.setPositiveButton(R.string.shared_string_save, new DialogInterface.OnClickListener() {
				
				@Override
				public void onClick(DialogInterface dialog, int which) {
					String newName = editText.getText().toString() + ext;
					File dest = new File(f.getParentFile(), newName);
					if (dest.exists()) {
						AccessibleToast.makeText(a, R.string.file_with_name_already_exists, Toast.LENGTH_LONG).show();
					} else {
						if(!dest.getParentFile().exists()) {
							dest.getParentFile().mkdirs();
						}
						if(f.renameTo(dest)){
							if(callback != null) { 
								callback.run();
							}
						} else {
							AccessibleToast.makeText(a, R.string.file_can_not_be_renamed, Toast.LENGTH_LONG).show();
						}
					}
					
				}
			});
			b.setNegativeButton(R.string.shared_string_cancel, null);
			b.show();
		}
	}

	public class LoadLocalIndexTask extends AsyncTask<Activity, LocalIndexInfo, List<LocalIndexInfo>> {

		private List<LocalIndexInfo> result;

		@Override
		protected List<LocalIndexInfo> doInBackground(Activity... params) {
			LocalIndexHelper helper = new LocalIndexHelper(getMyApplication());
			return helper.getLocalIndexData(this);
		}

		public void loadFile(LocalIndexInfo... loaded) {
			publishProgress(loaded);
		}

		@Override
		protected void onPreExecute() {
			getDownloadActivity().setSupportProgressBarIndeterminateVisibility(true);
			listAdapter.clear();
		}

		@Override
		protected void onProgressUpdate(LocalIndexInfo... values) {
			for (LocalIndexInfo v : values) {
				listAdapter.addLocalIndexInfo(v);
			}
			listAdapter.notifyDataSetChanged();
			expandAllGroups();
		}

		public void setResult(List<LocalIndexInfo> result) {
			this.result = result;
			if(result == null){
				listAdapter.clear();
			} else {
				for (LocalIndexInfo v : result) {
					listAdapter.addLocalIndexInfo(v);
				}
				listAdapter.notifyDataSetChanged();
				expandAllGroups();
				onPostExecute(result);
			}
		}

		@Override
		protected void onPostExecute(List<LocalIndexInfo> result) {
			this.result = result;
			listAdapter.sortData();
			if (getDownloadActivity() != null){
				getDownloadActivity().setSupportProgressBarIndeterminateVisibility(false);
				getDownloadActivity().setLocalIndexInfos(result);
			}
		}

		public List<LocalIndexInfo> getResult() {
			return result;
		}

	}

	private File getFileToRestore(LocalIndexInfo i){
		if(i.isBackupedData()){
			File parent = new File(i.getPathToData()).getParentFile();
			if(i.getType() == LocalIndexType.SRTM_DATA){
				parent = getMyApplication().getAppPath(IndexConstants.SRTM_INDEX_DIR);
			} else if(i.getFileName().endsWith(IndexConstants.BINARY_ROAD_MAP_INDEX_EXT)){
				parent = getMyApplication().getAppPath(IndexConstants.ROADS_INDEX_DIR);
			} else if(i.getType() == LocalIndexType.WIKI_DATA){
				parent = getMyApplication().getAppPath(IndexConstants.WIKI_INDEX_DIR);
			} else if(i.getType() == LocalIndexType.MAP_DATA){
				parent = getMyApplication().getAppPath(IndexConstants.MAPS_PATH);
			} else if(i.getType() == LocalIndexType.TILES_DATA){
				parent = getMyApplication().getAppPath(IndexConstants.TILES_INDEX_DIR);
			} else if(i.getType() == LocalIndexType.VOICE_DATA){
				parent = getMyApplication().getAppPath(IndexConstants.VOICE_INDEX_DIR);
			} else if(i.getType() == LocalIndexType.TTS_VOICE_DATA){
				parent = getMyApplication().getAppPath(IndexConstants.VOICE_INDEX_DIR);
			}
			return new File(parent, i.getFileName());
		}
		return new File(i.getPathToData());
	}
	
	private File getFileToBackup(LocalIndexInfo i) {
		if(!i.isBackupedData()){
			return new File(getMyApplication().getAppPath(IndexConstants.BACKUP_INDEX_DIR), i.getFileName());
		}
		return new File(i.getPathToData());
	}
	
	private boolean move(File from, File to){
		if(!to.getParentFile().exists()){
			to.getParentFile().mkdirs();
		}
		return from.renameTo(to);
	}
	
	public class LocalIndexOperationTask extends AsyncTask<LocalIndexInfo, LocalIndexInfo, String> {
		
		private final int operation;

		public LocalIndexOperationTask(int operation){
			this.operation = operation;
		}
		
		
		@Override
		protected String doInBackground(LocalIndexInfo... params) {
			int count = 0;
			int total = 0;
			for(LocalIndexInfo info : params) {
				if(!isCancelled()){
					boolean successfull = false;
					if(operation == DELETE_OPERATION){
						File f = new File(info.getPathToData());
						successfull = Algorithms.removeAllFiles(f);
					} else if(operation == RESTORE_OPERATION){
						successfull = move(new File(info.getPathToData()), getFileToRestore(info));
						if(successfull){
							info.setBackupedData(false);
						}
					} else if(operation == BACKUP_OPERATION){
						successfull = move(new File(info.getPathToData()), getFileToBackup(info));
						if(successfull){
							info.setBackupedData(true);
							getMyApplication().getResourceManager().closeFile(info.getFileName());
						}
					}
					total ++;
					if(successfull){
						count++;
						publishProgress(info);
					}
				}
			}
			if(operation == DELETE_OPERATION){
				return getString(R.string.local_index_items_deleted, count, total);
			} else if(operation == BACKUP_OPERATION){
				return getString(R.string.local_index_items_backuped, count, total);
			} else if(operation == RESTORE_OPERATION){
				return getString(R.string.local_index_items_restored, count, total);
			}  
			
			return "";
		}


		@Override
		protected void onProgressUpdate(LocalIndexInfo... values) {
			if(operation == DELETE_OPERATION){
				listAdapter.delete(values);
			} else if(operation == BACKUP_OPERATION){
				listAdapter.move(values, false);
			} else if(operation == RESTORE_OPERATION){
				listAdapter.move(values, true);
			}
			
		}
		
		@Override
		protected void onPreExecute() {
			getDownloadActivity().setProgressBarIndeterminateVisibility(true);
		}

		@Override
		protected void onPostExecute(String result) {
			getDownloadActivity().setProgressBarIndeterminateVisibility(false);
			AccessibleToast.makeText(getDownloadActivity(), result, Toast.LENGTH_LONG).show();
			if (operation == RESTORE_OPERATION || operation == BACKUP_OPERATION){
				listAdapter.clear();
				reloadIndexes();
			}
		}
	}
	
	


	@Override
	public boolean onChildClick(ExpandableListView parent, View v, int groupPosition, int childPosition, long id) {
		LocalIndexInfo child = listAdapter.getChild(groupPosition, childPosition);
		if (!selectionMode){
			openPopUpMenu(v, child);
			return true;
		}
		selectedItems.add(child);
		listAdapter.notifyDataSetChanged();
		return true;
	}
	
	public Set<LocalIndexInfo> getSelectedItems() {
		return selectedItems;
	}
	
	


	@Override
	public void onPause() {
		super.onPause();
		if(operationTask != null){
			operationTask.cancel(true);
		}
	}

	@Override
	public void onDestroy() {
		super.onDestroy();
		asyncLoader.cancel(true);
	}
	

	@SuppressWarnings("deprecation")
	@Override
	public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
		if (!this.isAdded()) {
			return;
		}

		//fixes issue when local files not shown after switching tabs
		//Next line throws NPE in some circumstances when called from dashboard and listAdpater=null is not checked for. (Checking !this.isAdded above is not sufficient!)
		if (listAdapter != null && listAdapter.getGroupCount() == 0 && getDownloadActivity().getLocalIndexInfos().size() > 0) {
			for(LocalIndexInfo info : getDownloadActivity().getLocalIndexInfos()) {
				listAdapter.addLocalIndexInfo(info);
			}
			listAdapter.sortData();
			getExpandableListView().setAdapter(listAdapter);
			expandAllGroups();
		}
		ActionBar actionBar = getDownloadActivity().getSupportActionBar();
		//hide action bar from downloadindexfragment
		actionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_STANDARD);
		optionsMenuAdapter = new ContextMenuAdapter(getDownloadActivity());
		OnContextMenuClick listener = new OnContextMenuClick() {
			@Override
			public boolean onContextMenuClick(ArrayAdapter<?> adapter, int itemId, int pos, boolean isChecked) {
				localOptionsMenu(itemId);
				return true;
			}
		};
		optionsMenuAdapter.item(R.string.local_index_mi_reload)
				.icon(R.drawable.ic_action_refresh_dark)
				.listen(listener).position(1).reg();
		optionsMenuAdapter.item(R.string.shared_string_delete)
				.icon(R.drawable.ic_action_delete_dark)
				.listen(listener).position(2).reg();
		optionsMenuAdapter.item(R.string.local_index_mi_backup)
				.listen(listener).position(3).reg();
		optionsMenuAdapter.item(R.string.local_index_mi_restore)
				.listen(listener).position(4).reg();
		// doesn't work correctly
		//int max =  getResources().getInteger(R.integer.abs__max_action_buttons);
		int max = 3;
		SubMenu split = null;
		for (int j = 0; j < optionsMenuAdapter.length(); j++) {
			MenuItem item;
			if (j + 1 >= max && optionsMenuAdapter.length() > max) {
				if (split == null) {
					split = menu.addSubMenu(0, 1, j + 1, R.string.shared_string_more_actions);
					split.setIcon(R.drawable.ic_overflow_menu_white);
					split.getItem();
					MenuItemCompat.setShowAsAction(split.getItem(),MenuItemCompat.SHOW_AS_ACTION_ALWAYS);
				}
				item = split.add(0, optionsMenuAdapter.getElementId(j), j + 1, optionsMenuAdapter.getItemName(j));
				MenuItemCompat.setShowAsAction(item, MenuItemCompat.SHOW_AS_ACTION_ALWAYS );
			} else {
				item = menu.add(0, optionsMenuAdapter.getElementId(j), j + 1, optionsMenuAdapter.getItemName(j));
				MenuItemCompat.setShowAsAction(item, MenuItemCompat.SHOW_AS_ACTION_ALWAYS );
			}
			OsmandApplication app = getMyApplication();
			if (optionsMenuAdapter.getImage(app, j, isLightActionBar()) != null) {
				item.setIcon(optionsMenuAdapter.getImage(app, j, isLightActionBar()));
			}
			
		}

		if(operationTask == null || operationTask.getStatus() == AsyncTask.Status.FINISHED){
			menu.setGroupVisible(0, true);
		} else {
			menu.setGroupVisible(0, false);
		}
	}
	
	@Override
	public boolean onOptionsItemSelected(MenuItem item) {
		int itemId = item.getItemId();
		for (int i = 0; i < optionsMenuAdapter.length(); i++) {
			if (itemId == optionsMenuAdapter.getElementId(i)) {
				optionsMenuAdapter.getClickAdapter(i).onContextMenuClick(null, itemId, i, false);
				return true;
			}
		}
		return super.onOptionsItemSelected(item);
	}
	
	public void doAction(int actionResId){
		if(actionResId == R.string.local_index_mi_backup){
			operationTask = new LocalIndexOperationTask(BACKUP_OPERATION);
		} else if(actionResId == R.string.shared_string_delete){
			operationTask = new LocalIndexOperationTask(DELETE_OPERATION);
		} else if(actionResId == R.string.local_index_mi_restore){
			operationTask = new LocalIndexOperationTask(RESTORE_OPERATION);
		} else {
			operationTask = null;
		}
		if(operationTask != null){
			operationTask.execute(selectedItems.toArray(new LocalIndexInfo[selectedItems.size()]));
		}
		if(actionMode != null) {
			actionMode.finish();
		}
	}
	
	
	private void expandAllGroups() {
		for (int i = 0; i < listAdapter.getGroupCount(); i++) {
			getExpandableListView().expandGroup(i);
		}
	}
	
	private void openSelectionMode(final int actionResId, final int actionIconId, 
			final DialogInterface.OnClickListener listener){
		String value = getString(actionResId);
		if (value.endsWith("...")) {
			value = value.substring(0, value.length() - 3);
		}
		final String actionButton = value;
		if(listAdapter.getGroupCount() == 0){
			listAdapter.cancelFilter();
			expandAllGroups();
			listAdapter.notifyDataSetChanged();
			AccessibleToast.makeText(getDownloadActivity(), getString(R.string.local_index_no_items_to_do, actionButton.toLowerCase()), Toast.LENGTH_SHORT).show();
			return;
		}
		expandAllGroups();
		
		selectionMode = true;
		selectedItems.clear();
		actionMode = getDownloadActivity().startSupportActionMode(new ActionMode.Callback() {

			@Override
			public boolean onCreateActionMode(ActionMode mode, Menu menu) {
				selectionMode = true;
				MenuItem it = menu.add(actionResId);
				if (actionIconId != 0) {
					it.setIcon(actionIconId);
				}
				MenuItemCompat.setShowAsAction(it, MenuItemCompat.SHOW_AS_ACTION_IF_ROOM |
						MenuItemCompat.SHOW_AS_ACTION_WITH_TEXT);
				return true;
			}

			@Override
			public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
				return false;
			}

			@Override
			public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
				if (selectedItems.isEmpty()) {
					AccessibleToast.makeText(getDownloadActivity(),
							getString(R.string.local_index_no_items_to_do, actionButton.toLowerCase()), Toast.LENGTH_SHORT).show();
					return true;
				}

				Builder builder = new AlertDialog.Builder(getDownloadActivity());
				builder.setMessage(getString(R.string.local_index_action_do, actionButton.toLowerCase(), selectedItems.size()));
				builder.setPositiveButton(actionButton, listener);
				builder.setNegativeButton(R.string.shared_string_cancel, null);
				builder.show();
				return true;
			}

			@Override
			public void onDestroyActionMode(ActionMode mode) {
				selectionMode = false;
				descriptionText.setVisibility(View.VISIBLE);
				updateDescriptionTextWithSize();
				listAdapter.cancelFilter();
				expandAllGroups();
				listAdapter.notifyDataSetChanged();
			}

		});
		//findViewById(R.id.DescriptionText).setVisibility(View.GONE);
		listAdapter.notifyDataSetChanged();
	}

	@SuppressWarnings("deprecation")
	private void updateDescriptionTextWithSize(){
		File dir = getMyApplication().getAppPath("").getParentFile();
		String size = formatGb.format(new Object[]{0});
		int percent = 0;
		if(dir.canRead()){
			StatFs fs = new StatFs(dir.getAbsolutePath());
			size = formatGb.format(new Object[]{(float) (fs.getAvailableBlocks()) * fs.getBlockSize() / (1 << 30) });
			percent = (int) (fs.getAvailableBlocks() * 100 / fs.getBlockCount());
		}
		sizeProgress.setProgress(percent);
		String text = getString(R.string.free, size);
		int l = text.indexOf('.');
		if(l == -1) {
			l = text.length();
		}
		descriptionText.setText(text);
		descriptionText.setMovementMethod(LinkMovementMethod.getInstance());
	}

	public void localOptionsMenu(final int itemId) {
		if (itemId == R.string.local_index_mi_reload) {
			reloadIndexes();
		} else if (itemId == R.string.shared_string_delete) {
			openSelectionMode(itemId, R.drawable.ic_action_delete_dark,
					new DialogInterface.OnClickListener() {

						@Override
						public void onClick(DialogInterface dialog, int which) {
							doAction(itemId);
						}
					}, null, null);
		} else if (itemId == R.string.local_index_mi_backup) {
			openSelectionMode(itemId, R.drawable.ic_type_archive,
					new DialogInterface.OnClickListener() {

						@Override
						public void onClick(DialogInterface dialog, int which) {
							doAction(itemId);
						}
					}, Boolean.FALSE, LocalIndexType.MAP_DATA);
		} else if (itemId == R.string.local_index_mi_restore) {
			openSelectionMode(itemId, R.drawable.ic_type_archive,
					new DialogInterface.OnClickListener() {

						@Override
						public void onClick(DialogInterface dialog, int which) {
							doAction(itemId);
						}
					}, Boolean.TRUE, LocalIndexType.MAP_DATA);
			listAdapter.filterCategories(true);
		}
	}
	
	public void openSelectionMode(int stringRes, int darkIcon, DialogInterface.OnClickListener listener, Boolean backup,
			LocalIndexType filter) {
		if (backup != null) {
			listAdapter.filterCategories(backup);
		}
		if (filter != null) {
			listAdapter.filterCategories(filter);
		}
		openSelectionMode(stringRes, darkIcon, listener);
	}
	

	public void reloadIndexes() {
		listAdapter.clear();
		asyncLoader = new LoadLocalIndexTask();
		AsyncTask<Void, String, List<String>> task = new AsyncTask<Void, String, List<String>>(){

			@Override
			protected void onPostExecute(List<String> warnings) {
				if ( getDownloadActivity() == null) {
					return;
				}
				getDownloadActivity().setSupportProgressBarIndeterminateVisibility(false);
				if (!warnings.isEmpty()) {
					final StringBuilder b = new StringBuilder();
					boolean f = true;
					for (String w : warnings) {
						if (f) {
							f = false;
						} else {
							b.append('\n');
						}
						b.append(w);
					}
					AccessibleToast.makeText(getDownloadActivity(), b.toString(), Toast.LENGTH_LONG).show();
				}
				if(asyncLoader.getStatus() == Status.PENDING) {
					asyncLoader.execute(getDownloadActivity());
				}
			}
			
			@Override
			protected void onPreExecute() {
				super.onPreExecute();
				getDownloadActivity().setSupportProgressBarIndeterminateVisibility(true);
			}
			@Override
			protected List<String> doInBackground(Void... params) {
				return getMyApplication().getResourceManager().reloadIndexes(IProgress.EMPTY_PROGRESS,
						new ArrayList<String>()
						);
			}
			
		};
		task.execute();
		
	}

	

	protected class LocalIndexesAdapter extends OsmandBaseExpandableListAdapter {
		
		Map<LocalIndexInfo, List<LocalIndexInfo>> data = new LinkedHashMap<LocalIndexInfo, List<LocalIndexInfo>>();
		List<LocalIndexInfo> category = new ArrayList<LocalIndexInfo>();
		List<LocalIndexInfo> filterCategory = null;
		int warningColor;
		int okColor;
		int corruptedColor;
		Context ctx;

		public LocalIndexesAdapter(Context ctx) {
			this.ctx = ctx;
			warningColor = ctx.getResources().getColor(R.color.color_warning);
			okColor = ctx.getResources().getColor(R.color.color_ok);
			TypedArray ta = ctx.getTheme().obtainStyledAttributes(new int[]{android.R.attr.textColorPrimary});
			ta.recycle();
			corruptedColor = ctx.getResources().getColor(R.color.color_invalid);
		}
		
		public void clear() {
			data.clear();
			category.clear();
			filterCategory = null;
			notifyDataSetChanged();
		}
		
		public void sortData() {
			final Collator cl = Collator.getInstance();
			for(List<LocalIndexInfo> i : data.values()) {
				Collections.sort(i, new Comparator<LocalIndexInfo>() {
					@Override
					public int compare(LocalIndexInfo lhs, LocalIndexInfo rhs) {
						return cl.compare(getNameToDisplay(lhs), getNameToDisplay(rhs));
					}
				});
			}
		}

		public LocalIndexInfo findCategory(LocalIndexInfo val, boolean backuped){
			for(LocalIndexInfo i : category){
				if(i.isBackupedData() == backuped && val.getType() == i.getType() && 
						Algorithms.objectEquals(i.getSubfolder(), val.getSubfolder())){
					return i;
				}
			}
			LocalIndexInfo newCat = new LocalIndexInfo(val.getType(), backuped, val.getSubfolder());
			category.add(newCat);
			data.put(newCat, new ArrayList<LocalIndexInfo>());
			return newCat;
		}
		
		public void delete(LocalIndexInfo[] values) {
			for(LocalIndexInfo i : values){
				LocalIndexInfo c = findCategory(i, i.isBackupedData());
				if(c != null){
					data.get(c).remove(i);
					if (data.get(c).size() == 0){
						data.remove(c);
						category.remove(c);
					}
				}
			}
			listAdapter.notifyDataSetChanged();
		}
		
		public void move(LocalIndexInfo[] values, boolean oldBackupState) {
			for(LocalIndexInfo i : values){
				LocalIndexInfo c = findCategory(i, oldBackupState);
				if(c != null){
					data.get(c).remove(i);
				}
				c = findCategory(i, !oldBackupState);
				if(c != null){
					data.get(c).add(i);
				}
			}
			listAdapter.notifyDataSetChanged();
			expandAllGroups();
		}

		public void cancelFilter(){
			filterCategory = null;
			notifyDataSetChanged();
		}
		
		public void filterCategories(LocalIndexType... types) {
			List<LocalIndexInfo> filter = new ArrayList<LocalIndexInfo>();
			List<LocalIndexInfo> source = filterCategory == null ? category : filterCategory;
			for (LocalIndexInfo info : source) {
				for (LocalIndexType ts : types) {
					if (info.getType() == ts) {
						filter.add(info);
					}
				}
			}
			filterCategory = filter;
			notifyDataSetChanged();
		}
		
		public void filterCategories(boolean backup) {
			List<LocalIndexInfo> filter = new ArrayList<LocalIndexInfo>();
			List<LocalIndexInfo> source = filterCategory == null ? category : filterCategory;
			for (LocalIndexInfo info : source) {
				if (info.isBackupedData() == backup) {
					filter.add(info);
				}
			}
			filterCategory = filter;
			notifyDataSetChanged();
		}

		public void addLocalIndexInfo(LocalIndexInfo info) {
			int found = -1;
			// search from end
			for (int i = category.size() - 1; i >= 0; i--) {
				LocalIndexInfo cat = category.get(i);
				if (cat.getType() == info.getType() && info.isBackupedData() == cat.isBackupedData() &&
						Algorithms.objectEquals(info.getSubfolder(), cat.getSubfolder())) {
					found = i;
					break;
				}
			}
			if (found == -1) {
				found = category.size();
				category.add(new LocalIndexInfo(info.getType(), info.isBackupedData(), info.getSubfolder()));
			}
			if (!data.containsKey(category.get(found))) {
				data.put(category.get(found), new ArrayList<LocalIndexInfo>());
			}
			data.get(category.get(found)).add(info);
		}

		@Override
		public LocalIndexInfo getChild(int groupPosition, int childPosition) {
			LocalIndexInfo cat = filterCategory != null ? filterCategory.get(groupPosition) : category.get(groupPosition);
			return data.get(cat).get(childPosition);
		}

		@Override
		public long getChildId(int groupPosition, int childPosition) {
			// it would be unusable to have 10000 local indexes
			return groupPosition * 10000 + childPosition;
		}

		@Override
		public View getChildView(final int groupPosition, final int childPosition, boolean isLastChild, View convertView, ViewGroup parent) {
			View v = convertView;
			final LocalIndexInfo child = getChild(groupPosition, childPosition);
			if (v == null ) {
				LayoutInflater inflater = (LayoutInflater) getDownloadActivity().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
				v = inflater.inflate(net.osmand.plus.R.layout.local_index_list_item, parent, false);
			}
			TextView viewName = ((TextView) v.findViewById(R.id.local_index_name));
			ImageButton options = (ImageButton) v.findViewById(R.id.options);
			options.setImageDrawable(getMyApplication().getIconsCache().getContentIcon(R.drawable.ic_overflow_menu_white));
			options.setOnClickListener(new View.OnClickListener() {
				@Override
				public void onClick(View v) {
					openPopUpMenu(v, child);
				}
			});
			ImageView icon = (ImageView) v.findViewById(R.id.icon);
			if (child.isBackupedData()) {
				icon.setImageDrawable(backup);
			} else {
				icon.setImageDrawable(sdcard);
			}

			viewName.setText(getNameToDisplay(child));
			if (child.isNotSupported()) {
				viewName.setTextColor(warningColor);
			} else if (child.isCorrupted()) {
				viewName.setTextColor(corruptedColor);
			} else if (child.isLoaded()) {
				// users confused okColor here with "uptodate", so let's leave white (black in dark app theme) as "isLoaded"
				//viewName.setTextColor(okColor);
			}
			if (child.isBackupedData()) {
				viewName.setTypeface(Typeface.DEFAULT, Typeface.ITALIC);
			} else {
				viewName.setTypeface(Typeface.DEFAULT, Typeface.NORMAL);
			}
			TextView sizeText = (TextView) v.findViewById(R.id.local_index_size);
			if (child.getSize() >= 0) {
				String size;
				if (child.getSize() > 100) {
					size = formatMb.format(new Object[] { (float) child.getSize() / (1 << 10) });
				} else {
					size = child.getSize() + " kB";
				}
				sizeText.setText(size);
				sizeText.setVisibility(View.VISIBLE);
			} else {
				sizeText.setVisibility(View.GONE);
			}

			TextView descr = ((TextView) v.findViewById(R.id.local_index_descr));
			if (child.getType() == LocalIndexType.TILES_DATA) {
				descr.setText(R.string.online_map);
			} else {
				descr.setVisibility(View.VISIBLE);
				descr.setText(child.getDescription());
			}



			final CheckBox checkbox = (CheckBox) v.findViewById(R.id.check_local_index);
			checkbox.setVisibility(selectionMode ? View.VISIBLE : View.GONE);
			if (selectionMode) {
				icon.setVisibility(View.GONE);
				options.setVisibility(View.GONE);
				checkbox.setChecked(selectedItems.contains(child));
				checkbox.setOnClickListener(new View.OnClickListener() {
					
					@Override
					public void onClick(View v) {
						if(checkbox.isChecked()){
							selectedItems.add(child);
						} else {
							selectedItems.remove(child);
						}
					}
				});

			} else {
				options.setVisibility(View.VISIBLE);
				icon.setVisibility(View.VISIBLE);
			}

			v.setOnClickListener(new View.OnClickListener() {
				@Override
				public void onClick(View v) {
					onChildClick(null, v, groupPosition, childPosition, 0);
				}
			});
			return v;
		}

		
		private String getNameToDisplay(LocalIndexInfo child) {
			String mapDescr = getMapDescription(child.getFileName());
			String mapName = FileNameTranslationHelper.getFileName(ctx,
					((OsmandApplication) getDownloadActivity().getApplication()).getResourceManager().getOsmandRegions(),
					child.getFileName());
			if (mapDescr.length() > 0) {
				return mapName + " - " + mapDescr;
			} else {
				return mapName;
			}
		}

		@Override
		public View getGroupView(int groupPosition, boolean isExpanded, View convertView, ViewGroup parent) {
			View v = convertView;
			LocalIndexInfo group = getGroup(groupPosition);
			if (v == null) {
				LayoutInflater inflater = (LayoutInflater) getDownloadActivity().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
				v = inflater.inflate(R.layout.local_index_list_category, parent, false);
			}
			StringBuilder name = new StringBuilder(group.getType().getHumanString(getDownloadActivity()));
			if(group.getSubfolder() != null) {
				name.append(" ").append(group.getSubfolder());
			}
			if (group.isBackupedData()) {
				name.append(" - ").append(getString(R.string.local_indexes_cat_backup));
			}
			TextView nameView = ((TextView) v.findViewById(R.id.category_name));
			TextView sizeView = ((TextView) v.findViewById(R.id.category_size));
			List<LocalIndexInfo> list = data.get(group);
			int size = 0;
			for (LocalIndexInfo aList : list) {
				int sz = aList.getSize();
				if (sz < 0) {
					size = 0;
					break;
				} else {
					size += sz;
				}
			}
			String sz = "";
			if (size > 0) {
				if (size > 1 << 20) {
					sz = formatGb.format(new Object[] { (float) size / (1 << 20) });
				} else {
					sz = formatMb.format(new Object[] { (float) size / (1 << 10) });
				}

			}
			sizeView.setText(sz);
			nameView.setText(name.toString());
			if (!group.isBackupedData()) {
				nameView.setTypeface(Typeface.DEFAULT, Typeface.NORMAL);
			} else {
				nameView.setTypeface(Typeface.DEFAULT, Typeface.ITALIC);
			}

			v.setOnClickListener(null);
			return v;
		}

		@Override
		public int getChildrenCount(int groupPosition) {
			LocalIndexInfo cat = filterCategory != null ? filterCategory.get(groupPosition) : category.get(groupPosition);
			return data.get(cat).size();
		}

		@Override
		public LocalIndexInfo getGroup(int groupPosition) {
			return filterCategory == null ?  category.get(groupPosition)  : filterCategory.get(groupPosition);
		}

		@Override
		public int getGroupCount() {
			return filterCategory == null ?  category.size() : filterCategory.size();
		}

		@Override
		public long getGroupId(int groupPosition) {
			return groupPosition;
		}

		@Override
		public boolean hasStableIds() {
			return false;
		}

		@Override
		public boolean isChildSelectable(int groupPosition, int childPosition) {
			return true;
		}



		private String getMapDescription(String fileName){
			if (fileName.endsWith(IndexConstants.BINARY_ROAD_MAP_INDEX_EXT)) {
				return ctx.getString(R.string.download_roads_only_item);
			}
			return "";
		}
	}
	
	private void openPopUpMenu(View v, final LocalIndexInfo info) {
		IconsCache iconsCache = getMyApplication().getIconsCache();
		final PopupMenu optionsMenu = new PopupMenu(getActivity(), v);
		DirectionsDialogs.setupPopUpMenuIcon(optionsMenu);
		final boolean restore = info.isBackupedData();
		MenuItem item;
		if (info.getType() == LocalIndexType.MAP_DATA) {
			item = optionsMenu.getMenu().add(restore? R.string.local_index_mi_restore : R.string.local_index_mi_backup)
					.setIcon(backup);
			item.setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {
				@Override
				public boolean onMenuItemClick(MenuItem item) {
					performBasicOperation(restore ? R.string.local_index_mi_restore : R.string.local_index_mi_backup, info);
					return true;
				}
			});
		}

		item = optionsMenu.getMenu().add(R.string.shared_string_rename)
				.setIcon(iconsCache.getContentIcon(R.drawable.ic_action_edit_dark));
		item.setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {
			@Override
			public boolean onMenuItemClick(MenuItem item) {
				performBasicOperation(R.string.shared_string_rename, info);
				return true;
			}
		});

		item = optionsMenu.getMenu().add(R.string.shared_string_delete)
				.setIcon(iconsCache.getContentIcon(R.drawable.ic_action_delete_dark));
		item.setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {
			@Override
			public boolean onMenuItemClick(MenuItem item) {
				performBasicOperation(R.string.shared_string_delete, info);
				return true;
			}
		});
		if(getMyApplication().getSettings().BETA_TESTING_LIVE_UPDATES.get()) {
			item = optionsMenu.getMenu().add("Live updates")
					.setIcon(iconsCache.getContentIcon(R.drawable.ic_action_refresh_dark));
			item.setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {
				@Override
				public boolean onMenuItemClick(MenuItem item) {
					runLiveUpdate(info);
					return true;
				}
			});
		}
		
		optionsMenu.show();
	}
	
	private void runLiveUpdate(final LocalIndexInfo info) {
		final String fnExt = Algorithms.getFileNameWithoutExtension(new File(info.getFileName()));
		new AsyncTask<Object, Object, IncrementalUpdateList>() {

			protected void onPreExecute() {
				getDownloadActivity().setSupportProgressBarIndeterminateVisibility(true);

			};

			@Override
			protected IncrementalUpdateList doInBackground(Object... params) {
				IncrementalChangesManager cm = getMyApplication().getResourceManager().getChangesManager();
				return cm.getUpdatesByMonth(fnExt);
			}

			protected void onPostExecute(IncrementalUpdateList result) {
				getDownloadActivity().setSupportProgressBarIndeterminateVisibility(false);
				if (result.errorMessage != null) {
					Toast.makeText(getDownloadActivity(), result.errorMessage, Toast.LENGTH_SHORT).show();
				} else {
					List<IncrementalUpdate> ll = result.getItemsForUpdate();
					if(ll.isEmpty()) {
						Toast.makeText(getDownloadActivity(), R.string.no_updates_available, Toast.LENGTH_SHORT).show();
					} else {
						for (IncrementalUpdate iu : ll) {
							IndexItem ii = new IndexItem(iu.fileName, "Incremental update", iu.timestamp, iu.sizeText,
									iu.contentSize, iu.containerSize, DownloadActivityType.LIVE_UPDATES_FILE);
							getDownloadActivity().addToDownload(ii);
							getDownloadActivity().updateDownloadButton();
						}
					}
				}

			};

		}.execute(new Object[] { fnExt });
	}


	private DownloadActivity getDownloadActivity() {
		return (DownloadActivity) getActivity();
	}
}
!@#$%
20190530_033249,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_b06800
package net.osmand.plus.download.ui;

import java.text.DateFormat;

import net.osmand.access.AccessibleToast;
import net.osmand.plus.OsmandPlugin;
import net.osmand.plus.R;
import net.osmand.plus.Version;
import net.osmand.plus.download.DownloadActivity;
import net.osmand.plus.download.DownloadActivityType;
import net.osmand.plus.download.DownloadResourceGroup;
import net.osmand.plus.download.DownloadResources;
import net.osmand.plus.download.IndexItem;
import net.osmand.plus.openseamapsplugin.NauticalMapsPlugin;
import net.osmand.plus.srtmplugin.SRTMPlugin;
import android.annotation.SuppressLint;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.res.Resources;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.support.v7.app.AlertDialog;
import android.util.TypedValue;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.ImageView;
import android.widget.ProgressBar;
import android.widget.TextView;
import android.widget.Toast;

public class ItemViewHolder {

	protected final TextView nameTextView;
	protected final TextView descrTextView;
	protected final ImageView leftImageView;
	protected final ImageView rightImageButton;
	protected final Button rightButton;
	protected final ProgressBar progressBar;

	private boolean srtmDisabled;
	private boolean srtmNeedsInstallation;
	private boolean nauticalPluginDisabled;
	private boolean freeVersion;
	
	protected final DownloadActivity context;
	
	private int textColorPrimary;
	private int textColorSecondary;
	
	boolean showTypeInDesc;
	boolean showTypeInName;
	boolean showRemoteDate;
	boolean silentCancelDownload;
	boolean showProgressInDesc;
	
	private DateFormat dateFormat;

	

	private enum RightButtonAction {
		DOWNLOAD,
		ASK_FOR_SEAMARKS_PLUGIN,
		ASK_FOR_SRTM_PLUGIN_PURCHASE,
		ASK_FOR_SRTM_PLUGIN_ENABLE,
		ASK_FOR_FULL_VERSION_PURCHASE
	}
	

	public ItemViewHolder(View view, DownloadActivity context) {
		this.context = context;
		dateFormat = android.text.format.DateFormat.getMediumDateFormat(context);
		progressBar = (ProgressBar) view.findViewById(R.id.progressBar);
		rightButton = (Button) view.findViewById(R.id.rightButton);
		leftImageView = (ImageView) view.findViewById(R.id.leftImageView);
		descrTextView = (TextView) view.findViewById(R.id.description);
		rightImageButton = (ImageView) view.findViewById(R.id.rightImageButton);
		nameTextView = (TextView) view.findViewById(R.id.name);
		

		TypedValue typedValue = new TypedValue();
		Resources.Theme theme = context.getTheme();
		theme.resolveAttribute(android.R.attr.textColorPrimary, typedValue, true);
		textColorPrimary = typedValue.data;
		theme.resolveAttribute(android.R.attr.textColorSecondary, typedValue, true);
		textColorSecondary = typedValue.data;
	}
	
	public void setShowRemoteDate(boolean showRemoteDate) {
		this.showRemoteDate = showRemoteDate;
	}
	
	public void setShowProgressInDescr(boolean b) {
		showProgressInDesc = b;
	}
	
	public void setSilentCancelDownload(boolean silentCancelDownload) {
		this.silentCancelDownload = silentCancelDownload;
	}
	
	public void setShowTypeInDesc(boolean showTypeInDesc) {
		this.showTypeInDesc = showTypeInDesc;
	}
	
	public void setShowTypeInName(boolean showTypeInName) {
		this.showTypeInName = showTypeInName;
	}


	// FIXME don't initialize on every row 
	private void initAppStatusVariables() {
		srtmDisabled = OsmandPlugin.getEnabledPlugin(SRTMPlugin.class) == null;
		nauticalPluginDisabled = OsmandPlugin.getEnabledPlugin(NauticalMapsPlugin.class) == null;
		freeVersion = Version.isFreeVersion(context.getMyApplication());
		OsmandPlugin srtmPlugin = OsmandPlugin.getPlugin(SRTMPlugin.class);
		srtmNeedsInstallation = srtmPlugin == null || srtmPlugin.needsInstallation();
	}

	public void bindIndexItem(final IndexItem indexItem, final DownloadResourceGroup parentOptional) {
		initAppStatusVariables();
		boolean isDownloading = context.getDownloadThread().isDownloading(indexItem);
		int progress = -1;
		if (context.getDownloadThread().getCurrentDownloadingItem() == indexItem) {
			progress = context.getDownloadThread().getCurrentDownloadingItemProgress();
		}
		boolean disabled = checkDisabledAndClickAction(indexItem);
		/// name and left item
		if(showTypeInName) {
			nameTextView.setText(indexItem.getType().getString(context));
		} else {
			nameTextView.setText(indexItem.getVisibleName(context, context.getMyApplication().getRegions(), false));
		}
		if(!disabled) {
			nameTextView.setTextColor(textColorPrimary);
		} else {
			nameTextView.setTextColor(textColorSecondary);
		}
		int color = textColorSecondary;
		if(indexItem.isDownloaded() && !isDownloading) {
			int colorId = indexItem.getType() != DownloadActivityType.HILLSHADE_FILE &&
					indexItem.isOutdated() ? R.color.color_distance : R.color.color_ok;
			color = context.getResources().getColor(colorId);
		}
		if (indexItem.isDownloaded()) {
			leftImageView.setImageDrawable(getContentIcon(context,
					indexItem.getType().getIconResource(), color));
		} else if (disabled) {
			leftImageView.setImageDrawable(getContentIcon(context,
					indexItem.getType().getIconResource(), textColorSecondary));
		} else {
			leftImageView.setImageDrawable(getContentIcon(context,
					indexItem.getType().getIconResource()));
		}
		descrTextView.setTextColor(textColorSecondary);
		if (!isDownloading) {
			progressBar.setVisibility(View.GONE);
			descrTextView.setVisibility(View.VISIBLE);
			if ((indexItem.getType() == DownloadActivityType.SRTM_COUNTRY_FILE ||
					indexItem.getType() == DownloadActivityType.HILLSHADE_FILE) && srtmDisabled) {
				if(showTypeInName) {
					descrTextView.setText("");
				} else {
					descrTextView.setText(indexItem.getType().getString(context));
				}
			} else if (showTypeInDesc) {
				descrTextView.setText(indexItem.getType().getString(context) + 
						"  " + indexItem.getSizeDescription(context) +
						"  " + (showRemoteDate ? indexItem.getRemoteDate(dateFormat) : indexItem.getLocalDate(dateFormat)));
			} else {
				descrTextView.setText(indexItem.getSizeDescription(context) + "  " + 
						(showRemoteDate ? indexItem.getRemoteDate(dateFormat) : indexItem.getLocalDate(dateFormat)));
			}
			
			rightImageButton.setImageDrawable(getContentIcon(context, R.drawable.ic_action_import));
			rightImageButton.setOnClickListener(new View.OnClickListener() {
				@Override
				public void onClick(View v) {
					download(indexItem, parentOptional);
				}
			});
		} else {
			progressBar.setVisibility(View.VISIBLE);
			progressBar.setIndeterminate(progress == -1);
			progressBar.setProgress(progress);
			
			if (showProgressInDesc) {
				double mb = indexItem.getArchiveSizeMB();
				String v ;
				if (progress != -1) {
					v = context.getString(R.string.value_downloaded_from_max, mb * progress / 100, mb);
				} else {
					v = context.getString(R.string.file_size_in_mb, mb);
				}
				if(showTypeInDesc && indexItem.getType() == DownloadActivityType.ROADS_FILE) {
					descrTextView.setText(indexItem.getType().getString(context) + "  " + v);
				} else {
					descrTextView.setText(v);
				}
				descrTextView.setVisibility(View.VISIBLE);
			} else {
				descrTextView.setVisibility(View.GONE);
			}
			
			rightImageButton.setImageDrawable(getContentIcon(context, R.drawable.ic_action_remove_dark));
			rightImageButton.setOnClickListener(new View.OnClickListener() {
				@Override
				public void onClick(View v) {
					if (silentCancelDownload) {
						context.getDownloadThread().cancelDownload(indexItem);
					} else {
						context.makeSureUserCancelDownload(indexItem);
					}
				}
			});
		}
	}


	protected void download(IndexItem indexItem, DownloadResourceGroup parentOptional) {
		boolean handled = false;
		if (indexItem.getType() == DownloadActivityType.ROADS_FILE && parentOptional != null) {
			for (IndexItem ii : parentOptional.getIndividualResources()) {
				if (ii.getType() == DownloadActivityType.NORMAL_FILE) {
					if (ii.isDownloaded()) {
						handled = true;
						confirmDownload(indexItem);
					}
					break;
				}
			}
		}		
		if(!handled) {
			context.startDownload(indexItem);
		}
	}
	private void confirmDownload(final IndexItem indexItem) {
		AlertDialog.Builder builder = new AlertDialog.Builder(context);
		builder.setTitle(R.string.are_you_sure);
		builder.setMessage(R.string.confirm_download_roadmaps);
		builder.setNegativeButton(R.string.shared_string_cancel, null).setPositiveButton(
				R.string.shared_string_download, new DialogInterface.OnClickListener() {
					@Override
					public void onClick(DialogInterface dialog, int which) {
						if (indexItem != null) {
							context.startDownload(indexItem);
						}
					}
				});
		builder.show();
	}

	private boolean checkDisabledAndClickAction(final IndexItem indexItem) {
		RightButtonAction clickAction = getClickAction(indexItem);
		boolean disabled = clickAction != RightButtonAction.DOWNLOAD;
		if (clickAction != RightButtonAction.DOWNLOAD) {
			rightButton.setText(R.string.get_plugin);
			rightButton.setVisibility(View.VISIBLE);
			rightImageButton.setVisibility(View.GONE);
			rightButton.setOnClickListener(getRightButtonAction(indexItem, clickAction, null));
		} else {
			rightButton.setVisibility(View.GONE);
			rightImageButton.setVisibility(View.VISIBLE);
		}
		
		return disabled;
	}

	@SuppressLint("DefaultLocale")
	public RightButtonAction getClickAction(final IndexItem indexItem) {
		RightButtonAction clickAction = RightButtonAction.DOWNLOAD;
		if (indexItem.getBasename().toLowerCase().equals(DownloadResources.WORLD_SEAMARKS_KEY)
				&& nauticalPluginDisabled) {
			clickAction = RightButtonAction.ASK_FOR_SEAMARKS_PLUGIN;
		} else if ((indexItem.getType() == DownloadActivityType.SRTM_COUNTRY_FILE ||
				indexItem.getType() == DownloadActivityType.HILLSHADE_FILE) && srtmDisabled) {
			if (srtmNeedsInstallation) {
				clickAction = RightButtonAction.ASK_FOR_SRTM_PLUGIN_PURCHASE;
			} else {
				clickAction = RightButtonAction.ASK_FOR_SRTM_PLUGIN_ENABLE;
			}

		} else if (indexItem.getType() == DownloadActivityType.WIKIPEDIA_FILE && freeVersion) {
			clickAction = RightButtonAction.ASK_FOR_FULL_VERSION_PURCHASE;
		}
		return clickAction;
	}

	public OnClickListener getRightButtonAction(final IndexItem item, final RightButtonAction clickAction, final DownloadResourceGroup parentOptional) {
		if (clickAction != RightButtonAction.DOWNLOAD) {
			return new View.OnClickListener() {
				@Override
				public void onClick(View v) {
					switch (clickAction) {
					case ASK_FOR_FULL_VERSION_PURCHASE:
						Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(Version.marketPrefix(context
								.getMyApplication()) + "net.osmand.plus"));
						context.startActivity(intent);
						break;
					case ASK_FOR_SEAMARKS_PLUGIN:
						context.startActivity(new Intent(context, context.getMyApplication().getAppCustomization()
								.getPluginsActivity()));
						AccessibleToast.makeText(context.getApplicationContext(),
								context.getString(R.string.activate_seamarks_plugin), Toast.LENGTH_SHORT).show();
						break;
					case ASK_FOR_SRTM_PLUGIN_PURCHASE:
						OsmandPlugin plugin = OsmandPlugin.getPlugin(SRTMPlugin.class);
						context.startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse(plugin.getInstallURL())));
						break;
					case ASK_FOR_SRTM_PLUGIN_ENABLE:
						context.startActivity(new Intent(context, context.getMyApplication().getAppCustomization()
								.getPluginsActivity()));
						AccessibleToast.makeText(context, context.getString(R.string.activate_srtm_plugin),
								Toast.LENGTH_SHORT).show();
						break;
					case DOWNLOAD:
						break;
					}
				}
			};
		} else {
			final boolean isDownloading = context.getDownloadThread().isDownloading(item);
			return new View.OnClickListener() {
				@Override
				public void onClick(View v) {
					if(isDownloading) {
						if(silentCancelDownload) {
							context.getDownloadThread().cancelDownload(item);
						} else {
							context.makeSureUserCancelDownload(item);
						}
					} else {
						download(item, parentOptional);
					}
				}
			};
		}
	}

	private Drawable getContentIcon(DownloadActivity context, int resourceId) {
		return context.getMyApplication().getIconsCache().getContentIcon(resourceId);
	}

	private Drawable getContentIcon(DownloadActivity context, int resourceId, int color) {
		return context.getMyApplication().getIconsCache().getPaintedContentIcon(resourceId, color);
	}
}
!@#$%
20190530_033249,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_a06800
package net.osmand.plus.download.ui;

import java.text.DateFormat;

import net.osmand.access.AccessibleToast;
import net.osmand.plus.OsmandPlugin;
import net.osmand.plus.R;
import net.osmand.plus.Version;
import net.osmand.plus.download.DownloadActivity;
import net.osmand.plus.download.DownloadActivityType;
import net.osmand.plus.download.DownloadResourceGroup;
import net.osmand.plus.download.DownloadResources;
import net.osmand.plus.download.IndexItem;
import net.osmand.plus.openseamapsplugin.NauticalMapsPlugin;
import net.osmand.plus.srtmplugin.SRTMPlugin;
import android.annotation.SuppressLint;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.res.Resources;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.support.v7.app.AlertDialog;
import android.util.TypedValue;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.ImageView;
import android.widget.ProgressBar;
import android.widget.TextView;
import android.widget.Toast;

public class ItemViewHolder {

	protected final TextView nameTextView;
	protected final TextView descrTextView;
	protected final ImageView leftImageView;
	protected final ImageView rightImageButton;
	protected final Button rightButton;
	protected final ProgressBar progressBar;

	private boolean srtmDisabled;
	private boolean srtmNeedsInstallation;
	private boolean nauticalPluginDisabled;
	private boolean freeVersion;
	
	protected final DownloadActivity context;
	
	private int textColorPrimary;
	private int textColorSecondary;
	
	boolean showTypeInDesc;
	boolean showTypeInName;
	boolean showRemoteDate;
	boolean silentCancelDownload;
	boolean showProgressInDesc;
	
	private DateFormat dateFormat;

	

	private enum RightButtonAction {
		DOWNLOAD,
		ASK_FOR_SEAMARKS_PLUGIN,
		ASK_FOR_SRTM_PLUGIN_PURCHASE,
		ASK_FOR_SRTM_PLUGIN_ENABLE,
		ASK_FOR_FULL_VERSION_PURCHASE
	}
	

	public ItemViewHolder(View view, DownloadActivity context) {
		this.context = context;
		dateFormat = android.text.format.DateFormat.getMediumDateFormat(context);
		progressBar = (ProgressBar) view.findViewById(R.id.progressBar);
		rightButton = (Button) view.findViewById(R.id.rightButton);
		leftImageView = (ImageView) view.findViewById(R.id.leftImageView);
		descrTextView = (TextView) view.findViewById(R.id.description);
		rightImageButton = (ImageView) view.findViewById(R.id.rightImageButton);
		nameTextView = (TextView) view.findViewById(R.id.name);
		

		TypedValue typedValue = new TypedValue();
		Resources.Theme theme = context.getTheme();
		theme.resolveAttribute(android.R.attr.textColorPrimary, typedValue, true);
		textColorPrimary = typedValue.data;
		theme.resolveAttribute(android.R.attr.textColorSecondary, typedValue, true);
		textColorSecondary = typedValue.data;
	}
	
	public void setShowRemoteDate(boolean showRemoteDate) {
		this.showRemoteDate = showRemoteDate;
	}
	
	public void setShowProgressInDescr(boolean b) {
		showProgressInDesc = b;
	}
	
	public void setSilentCancelDownload(boolean silentCancelDownload) {
		this.silentCancelDownload = silentCancelDownload;
	}
	
	public void setShowTypeInDesc(boolean showTypeInDesc) {
		this.showTypeInDesc = showTypeInDesc;
	}
	
	public void setShowTypeInName(boolean showTypeInName) {
		this.showTypeInName = showTypeInName;
	}


	// FIXME don't initialize on every row 
	private void initAppStatusVariables() {
		srtmDisabled = OsmandPlugin.getEnabledPlugin(SRTMPlugin.class) == null;
		nauticalPluginDisabled = OsmandPlugin.getEnabledPlugin(NauticalMapsPlugin.class) == null;
		freeVersion = Version.isFreeVersion(context.getMyApplication());
		OsmandPlugin srtmPlugin = OsmandPlugin.getPlugin(SRTMPlugin.class);
		srtmNeedsInstallation = srtmPlugin == null || srtmPlugin.needsInstallation();
	}

	public void bindIndexItem(final IndexItem indexItem, final DownloadResourceGroup parentOptional) {
		initAppStatusVariables();
		boolean isDownloading = context.getDownloadThread().isDownloading(indexItem);
		int progress = -1;
		if (context.getDownloadThread().getCurrentDownloadingItem() == indexItem) {
			progress = context.getDownloadThread().getCurrentDownloadingItemProgress();
		}
		boolean disabled = checkDisabledAndClickAction(indexItem);
		/// name and left item
		if(showTypeInName) {
			nameTextView.setText(indexItem.getType().getString(context));
		} else {
			nameTextView.setText(indexItem.getVisibleName(context, context.getMyApplication().getRegions(), false));
		}
		if(!disabled) {
			nameTextView.setTextColor(textColorPrimary);
		} else {
			nameTextView.setTextColor(textColorSecondary);
		}
		int color = textColorSecondary;
		if(indexItem.isDownloaded() && !isDownloading) {
			int colorId = indexItem.getType() != DownloadActivityType.HILLSHADE_FILE &&
					indexItem.isOutdated() ? R.color.color_distance : R.color.color_ok;
			color = context.getResources().getColor(colorId);
		}
		if (indexItem.isDownloaded()) {
			leftImageView.setImageDrawable(getContentIcon(context,
					indexItem.getType().getIconResource(), color));
		} else if (disabled) {
			leftImageView.setImageDrawable(getContentIcon(context,
					indexItem.getType().getIconResource(), textColorSecondary));
		} else {
			leftImageView.setImageDrawable(getContentIcon(context,
					indexItem.getType().getIconResource()));
		}
		descrTextView.setTextColor(textColorSecondary);
		if (!isDownloading) {
			progressBar.setVisibility(View.GONE);
			descrTextView.setVisibility(View.VISIBLE);
			if ((indexItem.getType() == DownloadActivityType.SRTM_COUNTRY_FILE ||
					indexItem.getType() == DownloadActivityType.HILLSHADE_FILE) && srtmDisabled) {
				if(showTypeInName) {
					descrTextView.setText("");
				} else {
					descrTextView.setText(indexItem.getType().getString(context));
				}
			} else if (showTypeInDesc) {
				descrTextView.setText(indexItem.getType().getString(context) + 
						"  " + indexItem.getSizeDescription(context) +
						"  " + (showRemoteDate ? indexItem.getRemoteDate(dateFormat) : indexItem.getLocalDate(dateFormat)));
			} else {
				descrTextView.setText(indexItem.getSizeDescription(context) + "  " + 
						(showRemoteDate ? indexItem.getRemoteDate(dateFormat) : indexItem.getLocalDate(dateFormat)));
			}
			
			rightImageButton.setImageDrawable(getContentIcon(context, R.drawable.ic_action_import));
			rightImageButton.setOnClickListener(new View.OnClickListener() {
				@Override
				public void onClick(View v) {
					download(indexItem, parentOptional);
				}
			});
		} else {
			progressBar.setVisibility(View.VISIBLE);
			progressBar.setIndeterminate(progress == -1);
			progressBar.setProgress(progress);
			
			if (showProgressInDesc) {
				double mb = indexItem.getArchiveSizeMB();
				String v ;
				if (progress != -1) {
					v = context.getString(R.string.value_downloaded_from_max, mb * progress / 100, mb);
				} else {
					v = context.getString(R.string.file_size_in_mb, mb);
				}
				if(showTypeInDesc && indexItem.getType() == DownloadActivityType.ROADS_FILE) {
					descrTextView.setText(indexItem.getType().getString(context) + "  " + v);
				} else {
					descrTextView.setText(v);
				}
				descrTextView.setVisibility(View.VISIBLE);
			} else {
				descrTextView.setVisibility(View.GONE);
			}
			
			rightImageButton.setImageDrawable(getContentIcon(context, R.drawable.ic_action_remove_dark));
			rightImageButton.setOnClickListener(new View.OnClickListener() {
				@Override
				public void onClick(View v) {
					if (silentCancelDownload) {
						context.getDownloadThread().cancelDownload(indexItem);
					} else {
						context.makeSureUserCancelDownload(indexItem);
					}
				}
			});
		}
	}


	protected void download(IndexItem indexItem, DownloadResourceGroup parentOptional) {
		boolean handled = false;
		if (indexItem.getType() == DownloadActivityType.ROADS_FILE && parentOptional != null) {
			for (IndexItem ii : parentOptional.getIndividualResources()) {
				if (ii.getType() == DownloadActivityType.NORMAL_FILE) {
					if (ii.isDownloaded()) {
						handled = true;
						confirmDownload(indexItem);
					}
					break;
				}
			}
		}		
		if(!handled) {
			context.startDownload(indexItem);
		}
	}
	private void confirmDownload(final IndexItem indexItem) {
		AlertDialog.Builder builder = new AlertDialog.Builder(context);
		builder.setTitle(R.string.are_you_sure);
		builder.setMessage(R.string.confirm_download_roadmaps);
		builder.setNegativeButton(R.string.shared_string_cancel, null).setPositiveButton(
				R.string.shared_string_download, new DialogInterface.OnClickListener() {
					@Override
					public void onClick(DialogInterface dialog, int which) {
						if (indexItem != null) {
							context.startDownload(indexItem);
						}
					}
				});
		builder.show();
	}

	private boolean checkDisabledAndClickAction(final IndexItem indexItem) {
		RightButtonAction clickAction = getClickAction(indexItem);
		boolean disabled = clickAction != RightButtonAction.DOWNLOAD;
		if (clickAction != RightButtonAction.DOWNLOAD) {
			rightButton.setText(R.string.get_plugin);
			rightButton.setVisibility(View.VISIBLE);
			rightImageButton.setVisibility(View.GONE);
			rightButton.setOnClickListener(getRightButtonAction(indexItem, clickAction, null));
		} else {
			rightButton.setVisibility(View.GONE);
			rightImageButton.setVisibility(View.VISIBLE);
		}
		
		return disabled;
	}

	@SuppressLint("DefaultLocale")
	public RightButtonAction getClickAction(final IndexItem indexItem) {
		RightButtonAction clickAction = RightButtonAction.DOWNLOAD;
		if (indexItem.getBasename().toLowerCase().equals(DownloadResources.WORLD_SEAMARKS_KEY)
				&& nauticalPluginDisabled) {
			clickAction = RightButtonAction.ASK_FOR_SEAMARKS_PLUGIN;
		} else if ((indexItem.getType() == DownloadActivityType.SRTM_COUNTRY_FILE ||
				indexItem.getType() == DownloadActivityType.HILLSHADE_FILE) && srtmDisabled) {
			if (srtmNeedsInstallation) {
				clickAction = RightButtonAction.ASK_FOR_SRTM_PLUGIN_PURCHASE;
			} else {
				clickAction = RightButtonAction.ASK_FOR_SRTM_PLUGIN_ENABLE;
			}

		} else if (indexItem.getType() == DownloadActivityType.WIKIPEDIA_FILE && freeVersion) {
			clickAction = RightButtonAction.ASK_FOR_FULL_VERSION_PURCHASE;
		}
		return clickAction;
	}

	public OnClickListener getRightButtonAction(final IndexItem item, final RightButtonAction clickAction, final DownloadResourceGroup parentOptional) {
		if (clickAction != RightButtonAction.DOWNLOAD) {
			return new View.OnClickListener() {
				@Override
				public void onClick(View v) {
					switch (clickAction) {
					case ASK_FOR_FULL_VERSION_PURCHASE:
						Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(Version.marketPrefix(context
								.getMyApplication()) + "net.osmand.plus"));
						context.startActivity(intent);
						break;
					case ASK_FOR_SEAMARKS_PLUGIN:
						context.startActivity(new Intent(context, context.getMyApplication().getAppCustomization()
								.getPluginsActivity()));
						AccessibleToast.makeText(context.getApplicationContext(),
								context.getString(R.string.activate_seamarks_plugin), Toast.LENGTH_SHORT).show();
						break;
					case ASK_FOR_SRTM_PLUGIN_PURCHASE:
						OsmandPlugin plugin = OsmandPlugin.getPlugin(SRTMPlugin.class);
						context.startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse(plugin.getInstallURL())));
						break;
					case ASK_FOR_SRTM_PLUGIN_ENABLE:
						context.startActivity(new Intent(context, context.getMyApplication().getAppCustomization()
								.getPluginsActivity()));
						AccessibleToast.makeText(context, context.getString(R.string.activate_srtm_plugin),
								Toast.LENGTH_SHORT).show();
						break;
					case DOWNLOAD:
						break;
					}
				}
			};
		} else {
			final boolean isDownloading = context.getDownloadThread().isDownloading(item);
			return new View.OnClickListener() {
				@Override
				public void onClick(View v) {
					if(isDownloading) {
						if(silentCancelDownload) {
							context.getDownloadThread().cancelDownload(item);
						} else {
							context.makeSureUserCancelDownload(item);
						}
					} else {
						download(item, parentOptional);
					}
				}
			};
		}
	}

	private Drawable getContentIcon(DownloadActivity context, int resourceId) {
		return context.getMyApplication().getIconsCache().getContentIcon(resourceId);
	}

	private Drawable getContentIcon(DownloadActivity context, int resourceId, int color) {
		return context.getMyApplication().getIconsCache().getPaintedContentIcon(resourceId, color);
	}

	
}
!@#$%
20190530_033249,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_c06800
package net.osmand.plus.download.ui;

import java.io.File;
import java.text.DateFormat;

import net.osmand.access.AccessibleToast;
import net.osmand.plus.OsmandPlugin;
import net.osmand.plus.R;
import net.osmand.plus.Version;
import net.osmand.plus.activities.LocalIndexHelper.LocalIndexType;
import net.osmand.plus.activities.LocalIndexInfo;
import net.osmand.plus.download.DownloadActivity;
import net.osmand.plus.download.DownloadActivityType;
import net.osmand.plus.download.DownloadResourceGroup;
import net.osmand.plus.download.DownloadResources;
import net.osmand.plus.download.IndexItem;
import net.osmand.plus.download.ui.LocalIndexesFragment.LocalIndexOperationTask;
import net.osmand.plus.helpers.FileNameTranslationHelper;
import net.osmand.plus.openseamapsplugin.NauticalMapsPlugin;
import net.osmand.plus.srtmplugin.SRTMPlugin;
import android.annotation.SuppressLint;
import android.app.AlertDialog.Builder;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.res.Resources;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.support.v7.app.AlertDialog;
import android.support.v7.widget.PopupMenu;
import android.util.TypedValue;
import android.view.MenuItem;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.ImageView;
import android.widget.ProgressBar;
import android.widget.TextView;
import android.widget.Toast;

public class ItemViewHolder {

	protected final TextView nameTextView;
	protected final TextView descrTextView;
	protected final ImageView leftImageView;
	protected final ImageView rightImageButton;
	protected final Button rightButton;
	protected final ProgressBar progressBar;

	private boolean srtmDisabled;
	private boolean srtmNeedsInstallation;
	private boolean nauticalPluginDisabled;
	private boolean freeVersion;
	
	protected final DownloadActivity context;
	
	private int textColorPrimary;
	private int textColorSecondary;
	
	boolean showTypeInDesc;
	boolean showTypeInName;
	boolean showRemoteDate;
	boolean silentCancelDownload;
	boolean showProgressInDesc;
	
	private DateFormat dateFormat;

	

	private enum RightButtonAction {
		DOWNLOAD,
		ASK_FOR_SEAMARKS_PLUGIN,
		ASK_FOR_SRTM_PLUGIN_PURCHASE,
		ASK_FOR_SRTM_PLUGIN_ENABLE,
		ASK_FOR_FULL_VERSION_PURCHASE
	}
	

	public ItemViewHolder(View view, DownloadActivity context) {
		this.context = context;
		dateFormat = android.text.format.DateFormat.getMediumDateFormat(context);
		progressBar = (ProgressBar) view.findViewById(R.id.progressBar);
		rightButton = (Button) view.findViewById(R.id.rightButton);
		leftImageView = (ImageView) view.findViewById(R.id.leftImageView);
		descrTextView = (TextView) view.findViewById(R.id.description);
		rightImageButton = (ImageView) view.findViewById(R.id.rightImageButton);
		nameTextView = (TextView) view.findViewById(R.id.name);
		

		TypedValue typedValue = new TypedValue();
		Resources.Theme theme = context.getTheme();
		theme.resolveAttribute(android.R.attr.textColorPrimary, typedValue, true);
		textColorPrimary = typedValue.data;
		theme.resolveAttribute(android.R.attr.textColorSecondary, typedValue, true);
		textColorSecondary = typedValue.data;
	}
	
	public void setShowRemoteDate(boolean showRemoteDate) {
		this.showRemoteDate = showRemoteDate;
	}
	
	public void setShowProgressInDescr(boolean b) {
		showProgressInDesc = b;
	}
	
	public void setSilentCancelDownload(boolean silentCancelDownload) {
		this.silentCancelDownload = silentCancelDownload;
	}
	
	public void setShowTypeInDesc(boolean showTypeInDesc) {
		this.showTypeInDesc = showTypeInDesc;
	}
	
	public void setShowTypeInName(boolean showTypeInName) {
		this.showTypeInName = showTypeInName;
	}


	// FIXME don't initialize on every row 
	private void initAppStatusVariables() {
		srtmDisabled = OsmandPlugin.getEnabledPlugin(SRTMPlugin.class) == null;
		nauticalPluginDisabled = OsmandPlugin.getEnabledPlugin(NauticalMapsPlugin.class) == null;
		freeVersion = Version.isFreeVersion(context.getMyApplication());
		OsmandPlugin srtmPlugin = OsmandPlugin.getPlugin(SRTMPlugin.class);
		srtmNeedsInstallation = srtmPlugin == null || srtmPlugin.needsInstallation();
	}

	public void bindIndexItem(final IndexItem indexItem, final DownloadResourceGroup parentOptional) {
		initAppStatusVariables();
		boolean isDownloading = context.getDownloadThread().isDownloading(indexItem);
		int progress = -1;
		if (context.getDownloadThread().getCurrentDownloadingItem() == indexItem) {
			progress = context.getDownloadThread().getCurrentDownloadingItemProgress();
		}
		boolean disabled = checkDisabledAndClickAction(indexItem);
		/// name and left item
		if(showTypeInName) {
			nameTextView.setText(indexItem.getType().getString(context));
		} else {
			nameTextView.setText(indexItem.getVisibleName(context, context.getMyApplication().getRegions(), false));
		}
		if(!disabled) {
			nameTextView.setTextColor(textColorPrimary);
		} else {
			nameTextView.setTextColor(textColorSecondary);
		}
		int color = textColorSecondary;
		if(indexItem.isDownloaded() && !isDownloading) {
			int colorId = indexItem.isOutdated() ? R.color.color_distance : R.color.color_ok;
			color = context.getResources().getColor(colorId);
		}
		if (indexItem.isDownloaded()) {
			leftImageView.setImageDrawable(getContentIcon(context,
					indexItem.getType().getIconResource(), color));
		} else if (disabled) {
			leftImageView.setImageDrawable(getContentIcon(context,
					indexItem.getType().getIconResource(), textColorSecondary));
		} else {
			leftImageView.setImageDrawable(getContentIcon(context,
					indexItem.getType().getIconResource()));
		}
		descrTextView.setTextColor(textColorSecondary);
		if (!isDownloading) {
			progressBar.setVisibility(View.GONE);
			descrTextView.setVisibility(View.VISIBLE);
			if ((indexItem.getType() == DownloadActivityType.SRTM_COUNTRY_FILE ||
					indexItem.getType() == DownloadActivityType.HILLSHADE_FILE) && srtmDisabled) {
				if(showTypeInName) {
					descrTextView.setText("");
				} else {
					descrTextView.setText(indexItem.getType().getString(context));
				}
			} else if (showTypeInDesc) {
				descrTextView.setText(indexItem.getType().getString(context) + 
						"  " + indexItem.getSizeDescription(context) +
						"  " + (showRemoteDate ? indexItem.getRemoteDate(dateFormat) : indexItem.getLocalDate(dateFormat)));
			} else {
				descrTextView.setText(indexItem.getSizeDescription(context) + "  " + 
						(showRemoteDate ? indexItem.getRemoteDate(dateFormat) : indexItem.getLocalDate(dateFormat)));
			}

		} else {
			progressBar.setVisibility(View.VISIBLE);
			progressBar.setIndeterminate(progress == -1);
			progressBar.setProgress(progress);
			
			if (showProgressInDesc) {
				double mb = indexItem.getArchiveSizeMB();
				String v ;
				if (progress != -1) {
					v = context.getString(R.string.value_downloaded_from_max, mb * progress / 100, mb);
				} else {
					v = context.getString(R.string.file_size_in_mb, mb);
				}
				if(showTypeInDesc && indexItem.getType() == DownloadActivityType.ROADS_FILE) {
					descrTextView.setText(indexItem.getType().getString(context) + "  " + v);
				} else {
					descrTextView.setText(v);
				}
				descrTextView.setVisibility(View.VISIBLE);
			} else {
				descrTextView.setVisibility(View.GONE);
			}
			
		}
	}


	protected void download(IndexItem indexItem, DownloadResourceGroup parentOptional) {
		boolean handled = false;
		if (indexItem.getType() == DownloadActivityType.ROADS_FILE && parentOptional != null) {
			for (IndexItem ii : parentOptional.getIndividualResources()) {
				if (ii.getType() == DownloadActivityType.NORMAL_FILE) {
					if (ii.isDownloaded()) {
						handled = true;
						confirmDownload(indexItem);
					}
					break;
				}
			}
		}		
		if(!handled) {
			context.startDownload(indexItem);
		}
	}
	private void confirmDownload(final IndexItem indexItem) {
		AlertDialog.Builder builder = new AlertDialog.Builder(context);
		builder.setTitle(R.string.are_you_sure);
		builder.setMessage(R.string.confirm_download_roadmaps);
		builder.setNegativeButton(R.string.shared_string_cancel, null).setPositiveButton(
				R.string.shared_string_download, new DialogInterface.OnClickListener() {
					@Override
					public void onClick(DialogInterface dialog, int which) {
						if (indexItem != null) {
							context.startDownload(indexItem);
						}
					}
				});
		builder.show();
	}

	private boolean checkDisabledAndClickAction(final IndexItem item) {
		RightButtonAction clickAction = getClickAction(item);
		boolean disabled = clickAction != RightButtonAction.DOWNLOAD;
		OnClickListener action = getRightButtonAction(item, clickAction, null);
		if (clickAction != RightButtonAction.DOWNLOAD) {
			rightButton.setText(R.string.get_plugin);
			rightButton.setVisibility(View.VISIBLE);
			rightImageButton.setVisibility(View.GONE);
			rightButton.setOnClickListener(action);
		} else {
			rightButton.setVisibility(View.GONE);
			rightImageButton.setVisibility(View.VISIBLE);
			final boolean isDownloading = context.getDownloadThread().isDownloading(item);
			if (isDownloading) {
				rightImageButton.setImageDrawable(getContentIcon(context, R.drawable.ic_action_remove_dark));
			} else if(item.isDownloaded() && !item.isOutdated()) {
				rightImageButton.setImageDrawable(getContentIcon(context, R.drawable.ic_overflow_menu_white));
			} else {
				rightImageButton.setImageDrawable(getContentIcon(context, R.drawable.ic_action_import));
			}
			rightImageButton.setOnClickListener(action);
		}
		
		return disabled;
	}

	@SuppressLint("DefaultLocale")
	public RightButtonAction getClickAction(final IndexItem indexItem) {
		RightButtonAction clickAction = RightButtonAction.DOWNLOAD;
		if (indexItem.getBasename().toLowerCase().equals(DownloadResources.WORLD_SEAMARKS_KEY)
				&& nauticalPluginDisabled) {
			clickAction = RightButtonAction.ASK_FOR_SEAMARKS_PLUGIN;
		} else if ((indexItem.getType() == DownloadActivityType.SRTM_COUNTRY_FILE ||
				indexItem.getType() == DownloadActivityType.HILLSHADE_FILE) && srtmDisabled) {
			if (srtmNeedsInstallation) {
				clickAction = RightButtonAction.ASK_FOR_SRTM_PLUGIN_PURCHASE;
			} else {
				clickAction = RightButtonAction.ASK_FOR_SRTM_PLUGIN_ENABLE;
			}

		} else if (indexItem.getType() == DownloadActivityType.WIKIPEDIA_FILE && freeVersion) {
			clickAction = RightButtonAction.ASK_FOR_FULL_VERSION_PURCHASE;
		}
		return clickAction;
	}

	public OnClickListener getRightButtonAction(final IndexItem item, final RightButtonAction clickAction, final DownloadResourceGroup parentOptional) {
		if (clickAction != RightButtonAction.DOWNLOAD) {
			return new View.OnClickListener() {
				@Override
				public void onClick(View v) {
					switch (clickAction) {
					case ASK_FOR_FULL_VERSION_PURCHASE:
						Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(Version.marketPrefix(context
								.getMyApplication()) + "net.osmand.plus"));
						context.startActivity(intent);
						break;
					case ASK_FOR_SEAMARKS_PLUGIN:
						context.startActivity(new Intent(context, context.getMyApplication().getAppCustomization()
								.getPluginsActivity()));
						AccessibleToast.makeText(context.getApplicationContext(),
								context.getString(R.string.activate_seamarks_plugin), Toast.LENGTH_SHORT).show();
						break;
					case ASK_FOR_SRTM_PLUGIN_PURCHASE:
						OsmandPlugin plugin = OsmandPlugin.getPlugin(SRTMPlugin.class);
						context.startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse(plugin.getInstallURL())));
						break;
					case ASK_FOR_SRTM_PLUGIN_ENABLE:
						context.startActivity(new Intent(context, context.getMyApplication().getAppCustomization()
								.getPluginsActivity()));
						AccessibleToast.makeText(context, context.getString(R.string.activate_srtm_plugin),
								Toast.LENGTH_SHORT).show();
						break;
					case DOWNLOAD:
						break;
					}
				}
			};
		} else {
			final boolean isDownloading = context.getDownloadThread().isDownloading(item);
			return new View.OnClickListener() {
				@Override
				public void onClick(View v) {
					if(isDownloading) {
						if(silentCancelDownload) {
							context.getDownloadThread().cancelDownload(item);
						} else {
							context.makeSureUserCancelDownload(item);
						}
					} else if(item.isDownloaded() && !item.isOutdated()){
						contextMenu(v, item, parentOptional);
					} else {
						download(item, parentOptional);
					}
				}
			};
		}
	}

	protected void contextMenu(View v, final IndexItem indexItem, final DownloadResourceGroup parentOptional) {
		final PopupMenu optionsMenu = new PopupMenu(context, v);
		MenuItem item;
		
		final File fl = indexItem.getTargetFile(context.getMyApplication());
		if (fl.exists()) {
			item = optionsMenu.getMenu().add(R.string.shared_string_delete).setIcon(
							context.getMyApplication().getIconsCache().getContentIcon(R.drawable.ic_action_remove_dark));
			item.setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {
				@Override
				public boolean onMenuItemClick(MenuItem item) {
					LocalIndexType tp = LocalIndexType.MAP_DATA;
					if (indexItem.getType() == DownloadActivityType.HILLSHADE_FILE) {
						tp = LocalIndexType.TILES_DATA;
					} else if (indexItem.getType() == DownloadActivityType.ROADS_FILE) {
						tp = LocalIndexType.MAP_DATA;
					} else if (indexItem.getType() == DownloadActivityType.SRTM_COUNTRY_FILE) {
						tp = LocalIndexType.SRTM_DATA;
					} else if (indexItem.getType() == DownloadActivityType.WIKIPEDIA_FILE) {
						tp = LocalIndexType.MAP_DATA;
					} else if (indexItem.getType() == DownloadActivityType.VOICE_FILE) {
						tp = indexItem.getBasename().contains("tts") ? LocalIndexType.TTS_VOICE_DATA
								: LocalIndexType.VOICE_DATA;
					}
					final LocalIndexInfo info = new LocalIndexInfo(tp, fl, false);
					Builder confirm = new Builder(context);
					confirm.setPositiveButton(R.string.shared_string_yes, new DialogInterface.OnClickListener() {
						@Override
						public void onClick(DialogInterface dialog, int which) {
							new LocalIndexOperationTask(context, null, LocalIndexOperationTask.DELETE_OPERATION)
									.execute(info);
						}
					});
					confirm.setNegativeButton(R.string.shared_string_no, null);
					String fn = FileNameTranslationHelper.getFileName(context, context.getMyApplication().getRegions(),
							indexItem.getVisibleName(context, context.getMyApplication().getRegions()));
					confirm.setMessage(context.getString(R.string.delete_confirmation_msg, fn));
					confirm.show();
					return true;
				}
			});
		}
		item = optionsMenu.getMenu().add(R.string.shared_string_download)
				.setIcon(context.getMyApplication().getIconsCache().getContentIcon(R.drawable.ic_action_import));
		item.setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {
			@Override
			public boolean onMenuItemClick(MenuItem item) {
				download(indexItem, parentOptional);
				return true;
			}
		});
		
		optionsMenu.show();
	}

	private Drawable getContentIcon(DownloadActivity context, int resourceId) {
		return context.getMyApplication().getIconsCache().getContentIcon(resourceId);
	}

	private Drawable getContentIcon(DownloadActivity context, int resourceId, int color) {
		return context.getMyApplication().getIconsCache().getPaintedContentIcon(resourceId, color);
	}

	
}
!@#$%
20190530_033251,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_b06800
package net.osmand.plus.download.ui;

import java.util.ArrayList;
import java.util.List;

import net.osmand.plus.IconsCache;
import net.osmand.plus.OsmandApplication;
import net.osmand.plus.OsmandSettings;
import net.osmand.plus.R;
import net.osmand.plus.activities.OsmandBaseExpandableListAdapter;
import net.osmand.plus.download.DownloadActivity;
import net.osmand.plus.download.DownloadActivity.BannerAndDownloadFreeVersion;
import net.osmand.plus.download.DownloadActivityType;
import net.osmand.plus.download.DownloadIndexesThread.DownloadEvents;
import net.osmand.plus.download.DownloadResourceGroup;
import net.osmand.plus.download.DownloadResourceGroup.DownloadResourceGroupType;
import net.osmand.plus.download.DownloadResources;
import net.osmand.plus.download.IndexItem;
import net.osmand.util.Algorithms;
import android.content.Context;
import android.content.DialogInterface;
import android.content.res.Resources;
import android.content.res.TypedArray;
import android.graphics.drawable.Drawable;
import android.os.Bundle;
import android.support.v4.app.DialogFragment;
import android.support.v4.view.MenuItemCompat;
import android.support.v7.app.AlertDialog;
import android.support.v7.widget.Toolbar;
import android.util.TypedValue;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.widget.ExpandableListView;
import android.widget.ExpandableListView.OnChildClickListener;
import android.widget.TextView;

public class DownloadResourceGroupFragment extends DialogFragment implements DownloadEvents, OnChildClickListener {
	public static final int RELOAD_ID = 0;
	public static final int SEARCH_ID = 1;
	public static final String TAG = "RegionDialogFragment";
	private static final String REGION_ID_DLG_KEY = "world_region_dialog_key";
	private String groupId;
	private View view;
	private BannerAndDownloadFreeVersion banner;
	protected ExpandableListView listView;
	protected DownloadResourceGroupAdapter listAdapter;
	private DownloadResourceGroup group;
	private DownloadActivity activity;
	private Toolbar toolbar;

	@Override
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		boolean isLightTheme = getMyApplication().getSettings().OSMAND_THEME.get() == OsmandSettings.OSMAND_LIGHT_THEME;
		int themeId = isLightTheme ? R.style.OsmandLightTheme : R.style.OsmandDarkTheme;
		setStyle(STYLE_NO_FRAME, themeId);
		setHasOptionsMenu(true);
	}

	public boolean openAsDialog() {
		return !Algorithms.isEmpty(groupId);
	}

	@Override
	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
		view = inflater.inflate(R.layout.maps_in_category_fragment, container, false);
		if (savedInstanceState != null) {
			groupId = savedInstanceState.getString(REGION_ID_DLG_KEY);
		}
		if (groupId == null && getArguments() != null) {
			groupId = getArguments().getString(REGION_ID_DLG_KEY);
		}
		if (groupId == null) {
			groupId = "";
		}
		activity = (DownloadActivity) getActivity();

		toolbar = (Toolbar) view.findViewById(R.id.toolbar);
		toolbar.setNavigationIcon(getMyApplication().getIconsCache().getIcon(R.drawable.abc_ic_ab_back_mtrl_am_alpha));
		toolbar.setNavigationOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				dismiss();
			}
		});
		if (!openAsDialog()) {
			toolbar.setVisibility(View.GONE);
		}

		setHasOptionsMenu(true);

		if(openAsDialog()) {
			banner = new BannerAndDownloadFreeVersion(view, (DownloadActivity) getActivity());
		} else {
			banner = null;
			view.findViewById(R.id.freeVersionBanner).setVisibility(View.GONE);
		}

		listView = (ExpandableListView) view.findViewById(android.R.id.list);
		listView.setOnChildClickListener(this);
		listAdapter = new DownloadResourceGroupAdapter(activity);
		listView.setAdapter(listAdapter);

		reloadData();
		return view;
	}

	private void reloadData() {
		DownloadResources indexes = activity.getDownloadThread().getIndexes();
		group = indexes.getGroupById(groupId);
		if (group != null) {
			listAdapter.update(group);
			toolbar.setTitle(group.getName(activity));
		}
		expandAllGroups();
	}

	private void expandAllGroups() {
		for (int i = 0; i < listAdapter.getGroupCount(); i++) {
			listView.expandGroup(i);
		}
	}

	@Override
	public void onActivityCreated(Bundle savedInstanceState) {
		super.onActivityCreated(savedInstanceState);
		setShowsDialog(openAsDialog());
		listView.setBackgroundColor(getResources().getColor(
				getMyApplication().getSettings().isLightContent() ? R.color.bg_color_light : R.color.bg_color_dark));
	}

	@Override
	public void newDownloadIndexes() {
		if(banner != null) {
			banner.updateBannerInProgress();
		}
		reloadData();
	}

	@Override
	public void downloadHasFinished() {
		if(banner != null) {
			banner.updateBannerInProgress();
		}
		listAdapter.notifyDataSetChanged();
	}

	@Override
	public void downloadInProgress() {
		if(banner != null) {
			banner.updateBannerInProgress();
		}
		listAdapter.notifyDataSetChanged();
	}

	@Override
	public boolean onChildClick(ExpandableListView parent, View v, int groupPosition, int childPosition, long id) {
		Object child = listAdapter.getChild(groupPosition, childPosition);
		if (child instanceof DownloadResourceGroup) {
			String uniqueId = ((DownloadResourceGroup) child).getUniqueId();
			final DownloadResourceGroupFragment regionDialogFragment = DownloadResourceGroupFragment
					.createInstance(uniqueId);
			((DownloadActivity) getActivity()).showDialog(getActivity(), regionDialogFragment);
			return true;
		} else if (child instanceof IndexItem) {
			IndexItem indexItem = (IndexItem) child;
			DownloadResourceGroup groupObj = listAdapter.getGroupObj(groupPosition);
			ItemViewHolder vh = (ItemViewHolder) v.getTag();
			OnClickListener ls = vh.getRightButtonAction(indexItem, vh.getClickAction(indexItem), groupObj);
			ls.onClick(v);
			return true;
		}
		return false;
	}

	

	@Override
	public void onSaveInstanceState(Bundle outState) {
		outState.putString(REGION_ID_DLG_KEY, groupId);
		super.onSaveInstanceState(outState);
	}

	private OsmandApplication getMyApplication() {
		return (OsmandApplication) getActivity().getApplication();
	}

	private DownloadActivity getDownloadActivity() {
		return (DownloadActivity) getActivity();
	}

	@Override
	public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
		if (!openAsDialog()) {
			MenuItem itemReload = menu.add(0, RELOAD_ID, 0, R.string.shared_string_refresh);
			itemReload.setIcon(R.drawable.ic_action_refresh_dark);
			MenuItemCompat.setShowAsAction(itemReload, MenuItemCompat.SHOW_AS_ACTION_ALWAYS);

			MenuItem itemSearch = menu.add(0, SEARCH_ID, 1, R.string.shared_string_search);
			itemSearch.setIcon(R.drawable.ic_action_search_dark);
			MenuItemCompat.setShowAsAction(itemSearch, MenuItemCompat.SHOW_AS_ACTION_ALWAYS);
		}
	}

	@Override
	public boolean onOptionsItemSelected(MenuItem item) {
		switch (item.getItemId()) {
		case RELOAD_ID:
			// re-create the thread
			getDownloadActivity().getDownloadThread().runReloadIndexFiles();
			return true;
		case SEARCH_ID:
			getDownloadActivity().showDialog(getActivity(), SearchDialogFragment.createInstance(""));
			return true;
		default:
			return super.onOptionsItemSelected(item);
		}
	}

	public static DownloadResourceGroupFragment createInstance(String regionId) {
		Bundle bundle = new Bundle();
		bundle.putString(REGION_ID_DLG_KEY, regionId);
		DownloadResourceGroupFragment fragment = new DownloadResourceGroupFragment();
		fragment.setArguments(bundle);
		return fragment;
	}

	
	
	private static class DownloadGroupViewHolder {
		TextView textView;
		private DownloadActivity ctx;

		public DownloadGroupViewHolder(DownloadActivity ctx, View v) {
			this.ctx = ctx;
			textView = (TextView) v.findViewById(R.id.title);
		}
		
		private boolean isParentWorld(DownloadResourceGroup group) {
			return group.getParentGroup() == null
					|| group.getParentGroup().getType() == DownloadResourceGroupType.WORLD;
		}

		private Drawable getIconForGroup(DownloadResourceGroup group) {
			Drawable iconLeft;
			if (group.getType() == DownloadResourceGroupType.VOICE_REC
					|| group.getType() == DownloadResourceGroupType.VOICE_TTS) {
				iconLeft = ctx.getMyApplication().getIconsCache().getContentIcon(R.drawable.ic_action_volume_up);
			} else {
				IconsCache cache = ctx.getMyApplication().getIconsCache();
				if (isParentWorld(group) || isParentWorld(group.getParentGroup())) {
					iconLeft = cache.getContentIcon(R.drawable.ic_world_globe_dark);
				} else {
					DownloadResourceGroup ggr = group
							.getSubGroupById(DownloadResourceGroupType.REGION_MAPS.getDefaultId());
					iconLeft = cache.getContentIcon(R.drawable.ic_map);
					if (ggr != null && ggr.getIndividualResources() != null) {
						IndexItem item = null;
						for (IndexItem ii : ggr.getIndividualResources()) {
							if (ii.getType() == DownloadActivityType.NORMAL_FILE
									|| ii.getType() == DownloadActivityType.ROADS_FILE) {
								if (ii.isDownloaded() || ii.isOutdated()) {
									item = ii;
									break;
								}
							}
						}
						if (item != null) {
							if (item.isOutdated()) {
								iconLeft = cache.getIcon(R.drawable.ic_map, R.color.color_distance);
							} else {
								iconLeft = cache.getIcon(R.drawable.ic_map, R.color.color_ok);
							}
						}
					}
				}
			}
			return iconLeft;
		}

		public void bindItem(DownloadResourceGroup group) {
			Drawable iconLeft = getIconForGroup(group);
			textView.setCompoundDrawablesWithIntrinsicBounds(iconLeft, null, null, null);
			String name = group.getName(ctx);
			textView.setText(name);
		}
	}

	public static class DownloadResourceGroupAdapter extends OsmandBaseExpandableListAdapter {

		private List<DownloadResourceGroup> data = new ArrayList<DownloadResourceGroup>();
		private DownloadActivity ctx;
		private DownloadResourceGroup mainGroup;

		

		public DownloadResourceGroupAdapter(DownloadActivity ctx) {
			this.ctx = ctx;
			TypedArray ta = ctx.getTheme().obtainStyledAttributes(new int[] { android.R.attr.textColorPrimary });
			ta.recycle();
		}

		public void update(DownloadResourceGroup mainGroup) {
			this.mainGroup = mainGroup;
			data = mainGroup.getGroups();
			notifyDataSetChanged();
		}

		@Override
		public Object getChild(int groupPosition, int childPosition) {
			DownloadResourceGroup drg = data.get(groupPosition);
			if (drg.getType().containsIndexItem()) {
				return drg.getItemByIndex(childPosition);
			}
			return drg.getGroupByIndex(childPosition);
		}

		@Override
		public long getChildId(int groupPosition, int childPosition) {
			return groupPosition * 10000 + childPosition;
		}

		@Override
		public View getChildView(final int groupPosition, final int childPosition, boolean isLastChild,
				View convertView, ViewGroup parent) {
			final Object child = getChild(groupPosition, childPosition);
			if (child instanceof IndexItem) {
				
				IndexItem item = (IndexItem) child;
				DownloadResourceGroup group = getGroupObj(groupPosition);
				ItemViewHolder viewHolder;
				if (convertView != null && convertView.getTag() instanceof ItemViewHolder) {
					viewHolder = (ItemViewHolder) convertView.getTag();
				}  else {
					convertView = LayoutInflater.from(parent.getContext()).inflate(
							R.layout.two_line_with_images_list_item, parent, false);
					viewHolder = new ItemViewHolder(convertView, ctx);
					viewHolder.setShowRemoteDate(true);
					convertView.setTag(viewHolder);
				}
				if(mainGroup.getType() == DownloadResourceGroupType.REGION && 
						group != null && group.getType() == DownloadResourceGroupType.REGION_MAPS) {
					viewHolder.setShowTypeInName(true);
					viewHolder.setShowTypeInDesc(false);
				} else if(group != null && (group.getType() == DownloadResourceGroupType.SRTM_HEADER
						|| group.getType() == DownloadResourceGroupType.HILLSHADE_HEADER)) {
					viewHolder.setShowTypeInName(false);
					viewHolder.setShowTypeInDesc(false);
				} else {
					viewHolder.setShowTypeInDesc(true);
				}
				viewHolder.bindIndexItem(item, group);
			} else {
				DownloadResourceGroup group = (DownloadResourceGroup) child;
				DownloadGroupViewHolder viewHolder;
				if (convertView != null && convertView.getTag() instanceof DownloadGroupViewHolder) {
					viewHolder = (DownloadGroupViewHolder) convertView.getTag();
				}  else {
					convertView = LayoutInflater.from(parent.getContext()).inflate(R.layout.simple_list_menu_item,
								parent, false);
					viewHolder = new DownloadGroupViewHolder(ctx, convertView);
					convertView.setTag(viewHolder);
				}
				viewHolder.bindItem(group);
			}

			return convertView;
		}

		

		@Override
		public View getGroupView(int groupPosition, boolean isExpanded, final View convertView, final ViewGroup parent) {
			View v = convertView;
			String section = getGroup(groupPosition);
			if (v == null) {
				LayoutInflater inflater = LayoutInflater.from(ctx);
				v = inflater.inflate(R.layout.download_item_list_section, parent, false);
			}
			TextView nameView = ((TextView) v.findViewById(R.id.section_name));
			nameView.setText(section);
			v.setOnClickListener(null);
			TypedValue typedValue = new TypedValue();
			Resources.Theme theme = ctx.getTheme();
			theme.resolveAttribute(R.attr.ctx_menu_info_view_bg, typedValue, true);
			v.setBackgroundColor(typedValue.data);

			return v;
		}

		@Override
		public int getChildrenCount(int groupPosition) {
			return data.get(groupPosition).size();
		}
		
		public DownloadResourceGroup getGroupObj(int groupPosition) {
			return data.get(groupPosition);
		}

		@Override
		public String getGroup(int groupPosition) {
			DownloadResourceGroup drg = data.get(groupPosition);
			int rid = drg.getType().getResourceId();
			if (rid != -1) {
				return ctx.getString(rid);
			}
			return "";
		}

		@Override
		public int getGroupCount() {
			return data.size();
		}

		@Override
		public long getGroupId(int groupPosition) {
			return groupPosition;
		}

		@Override
		public boolean hasStableIds() {
			return false;
		}

		@Override
		public boolean isChildSelectable(int groupPosition, int childPosition) {
			return true;
		}
	}
}
!@#$%
20190530_033251,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_a06800
package net.osmand.plus.download.ui;

import java.util.ArrayList;
import java.util.List;

import net.osmand.plus.IconsCache;
import net.osmand.plus.OsmandApplication;
import net.osmand.plus.OsmandSettings;
import net.osmand.plus.R;
import net.osmand.plus.activities.OsmandBaseExpandableListAdapter;
import net.osmand.plus.download.DownloadActivity;
import net.osmand.plus.download.DownloadActivity.BannerAndDownloadFreeVersion;
import net.osmand.plus.download.DownloadActivityType;
import net.osmand.plus.download.DownloadIndexesThread.DownloadEvents;
import net.osmand.plus.download.DownloadResourceGroup;
import net.osmand.plus.download.DownloadResourceGroup.DownloadResourceGroupType;
import net.osmand.plus.download.DownloadResources;
import net.osmand.plus.download.IndexItem;
import net.osmand.util.Algorithms;
import android.content.Context;
import android.content.DialogInterface;
import android.content.res.Resources;
import android.content.res.TypedArray;
import android.graphics.drawable.Drawable;
import android.os.Bundle;
import android.support.v4.app.DialogFragment;
import android.support.v4.view.MenuItemCompat;
import android.support.v7.app.AlertDialog;
import android.support.v7.widget.Toolbar;
import android.util.TypedValue;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.widget.ExpandableListView;
import android.widget.ExpandableListView.OnChildClickListener;
import android.widget.TextView;

public class DownloadResourceGroupFragment extends DialogFragment implements DownloadEvents, OnChildClickListener {
	public static final int RELOAD_ID = 0;
	public static final int SEARCH_ID = 1;
	public static final String TAG = "RegionDialogFragment";
	private static final String REGION_ID_DLG_KEY = "world_region_dialog_key";
	private String groupId;
	private View view;
	private BannerAndDownloadFreeVersion banner;
	protected ExpandableListView listView;
	protected DownloadResourceGroupAdapter listAdapter;
	private DownloadResourceGroup group;
	private DownloadActivity activity;
	private Toolbar toolbar;

	@Override
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		boolean isLightTheme = getMyApplication().getSettings().OSMAND_THEME.get() == OsmandSettings.OSMAND_LIGHT_THEME;
		int themeId = isLightTheme ? R.style.OsmandLightTheme : R.style.OsmandDarkTheme;
		setStyle(STYLE_NO_FRAME, themeId);
		setHasOptionsMenu(true);
	}

	public boolean openAsDialog() {
		return !Algorithms.isEmpty(groupId);
	}

	@Override
	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
		view = inflater.inflate(R.layout.maps_in_category_fragment, container, false);
		if (savedInstanceState != null) {
			groupId = savedInstanceState.getString(REGION_ID_DLG_KEY);
		}
		if (groupId == null && getArguments() != null) {
			groupId = getArguments().getString(REGION_ID_DLG_KEY);
		}
		if (groupId == null) {
			groupId = "";
		}
		activity = (DownloadActivity) getActivity();

		toolbar = (Toolbar) view.findViewById(R.id.toolbar);
		toolbar.setNavigationIcon(getMyApplication().getIconsCache().getIcon(R.drawable.abc_ic_ab_back_mtrl_am_alpha));
		toolbar.setNavigationOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				dismiss();
			}
		});
		if (!openAsDialog()) {
			toolbar.setVisibility(View.GONE);
		}

		setHasOptionsMenu(true);

		if(openAsDialog()) {
			banner = new BannerAndDownloadFreeVersion(view, (DownloadActivity) getActivity());
		} else {
			banner = null;
			view.findViewById(R.id.freeVersionBanner).setVisibility(View.GONE);
		}

		listView = (ExpandableListView) view.findViewById(android.R.id.list);
		listView.setOnChildClickListener(this);
		listAdapter = new DownloadResourceGroupAdapter(activity);
		listView.setAdapter(listAdapter);

		reloadData();
		return view;
	}

	private void reloadData() {
		DownloadResources indexes = activity.getDownloadThread().getIndexes();
		group = indexes.getGroupById(groupId);
		if (group != null) {
			listAdapter.update(group);
			toolbar.setTitle(group.getName(activity));
		}
		expandAllGroups();
	}

	private void expandAllGroups() {
		for (int i = 0; i < listAdapter.getGroupCount(); i++) {
			listView.expandGroup(i);
		}
	}

	@Override
	public void onActivityCreated(Bundle savedInstanceState) {
		super.onActivityCreated(savedInstanceState);
		setShowsDialog(openAsDialog());
		listView.setBackgroundColor(getResources().getColor(
				getMyApplication().getSettings().isLightContent() ? R.color.bg_color_light : R.color.bg_color_dark));
	}

	@Override
	public void newDownloadIndexes() {
		if(banner != null) {
			banner.updateBannerInProgress();
		}
		reloadData();
	}

	@Override
	public void downloadHasFinished() {
		if(banner != null) {
			banner.updateBannerInProgress();
		}
		listAdapter.notifyDataSetChanged();
	}

	@Override
	public void downloadInProgress() {
		if(banner != null) {
			banner.updateBannerInProgress();
		}
		listAdapter.notifyDataSetChanged();
	}

	@Override
	public boolean onChildClick(ExpandableListView parent, View v, int groupPosition, int childPosition, long id) {
		Object child = listAdapter.getChild(groupPosition, childPosition);
		if (child instanceof DownloadResourceGroup) {
			String uniqueId = ((DownloadResourceGroup) child).getUniqueId();
			final DownloadResourceGroupFragment regionDialogFragment = DownloadResourceGroupFragment
					.createInstance(uniqueId);
			((DownloadActivity) getActivity()).showDialog(getActivity(), regionDialogFragment);
			return true;
		} else if (child instanceof IndexItem) {
			IndexItem indexItem = (IndexItem) child;
			DownloadResourceGroup groupObj = listAdapter.getGroupObj(groupPosition);
			ItemViewHolder vh = (ItemViewHolder) v.getTag();
			OnClickListener ls = vh.getRightButtonAction(indexItem, vh.getClickAction(indexItem), groupObj);
			ls.onClick(v);
			return true;
		}
		return false;
	}

	

	@Override
	public void onSaveInstanceState(Bundle outState) {
		outState.putString(REGION_ID_DLG_KEY, groupId);
		super.onSaveInstanceState(outState);
	}

	private OsmandApplication getMyApplication() {
		return (OsmandApplication) getActivity().getApplication();
	}

	private DownloadActivity getDownloadActivity() {
		return (DownloadActivity) getActivity();
	}

	@Override
	public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
		if (!openAsDialog()) {
			MenuItem itemReload = menu.add(0, RELOAD_ID, 0, R.string.shared_string_refresh);
			itemReload.setIcon(R.drawable.ic_action_refresh_dark);
			MenuItemCompat.setShowAsAction(itemReload, MenuItemCompat.SHOW_AS_ACTION_ALWAYS);

			MenuItem itemSearch = menu.add(0, SEARCH_ID, 1, R.string.shared_string_search);
			itemSearch.setIcon(R.drawable.ic_action_search_dark);
			MenuItemCompat.setShowAsAction(itemSearch, MenuItemCompat.SHOW_AS_ACTION_ALWAYS);
		}
	}

	@Override
	public boolean onOptionsItemSelected(MenuItem item) {
		switch (item.getItemId()) {
		case RELOAD_ID:
			// re-create the thread
			getDownloadActivity().getDownloadThread().runReloadIndexFiles();
			return true;
		case SEARCH_ID:
			getDownloadActivity().showDialog(getActivity(), SearchDialogFragment.createInstance(""));
			return true;
		default:
			return super.onOptionsItemSelected(item);
		}
	}

	public static DownloadResourceGroupFragment createInstance(String regionId) {
		Bundle bundle = new Bundle();
		bundle.putString(REGION_ID_DLG_KEY, regionId);
		DownloadResourceGroupFragment fragment = new DownloadResourceGroupFragment();
		fragment.setArguments(bundle);
		return fragment;
	}

	
	
	private static class DownloadGroupViewHolder {
		TextView textView;
		private DownloadActivity ctx;

		public DownloadGroupViewHolder(DownloadActivity ctx, View v) {
			this.ctx = ctx;
			textView = (TextView) v.findViewById(R.id.title);
		}
		
		private boolean isParentWorld(DownloadResourceGroup group) {
			return group.getParentGroup() == null
					|| group.getParentGroup().getType() == DownloadResourceGroupType.WORLD;
		}

		private Drawable getIconForGroup(DownloadResourceGroup group) {
			Drawable iconLeft;
			if (group.getType() == DownloadResourceGroupType.VOICE_REC
					|| group.getType() == DownloadResourceGroupType.VOICE_TTS) {
				iconLeft = ctx.getMyApplication().getIconsCache().getContentIcon(R.drawable.ic_action_volume_up);
			} else {
				IconsCache cache = ctx.getMyApplication().getIconsCache();
				if (isParentWorld(group) || isParentWorld(group.getParentGroup())) {
					iconLeft = cache.getContentIcon(R.drawable.ic_world_globe_dark);
				} else {
					DownloadResourceGroup ggr = group
							.getSubGroupById(DownloadResourceGroupType.REGION_MAPS.getDefaultId());
					iconLeft = cache.getContentIcon(R.drawable.ic_map);
					if (ggr != null && ggr.getIndividualResources() != null) {
						IndexItem item = null;
						for (IndexItem ii : ggr.getIndividualResources()) {
							if (ii.getType() == DownloadActivityType.NORMAL_FILE
									|| ii.getType() == DownloadActivityType.ROADS_FILE) {
								if (ii.isDownloaded() || ii.isOutdated()) {
									item = ii;
									break;
								}
							}
						}
						if (item != null) {
							if (item.isOutdated()) {
								iconLeft = cache.getIcon(R.drawable.ic_map, R.color.color_distance);
							} else {
								iconLeft = cache.getIcon(R.drawable.ic_map, R.color.color_ok);
							}
						}
					}
				}
			}
			return iconLeft;
		}

		public void bindItem(DownloadResourceGroup group) {
			Drawable iconLeft = getIconForGroup(group);
			textView.setCompoundDrawablesWithIntrinsicBounds(iconLeft, null, null, null);
			String name = group.getName(ctx);
			textView.setText(name);
		}
	}

	public static class DownloadResourceGroupAdapter extends OsmandBaseExpandableListAdapter {

		private List<DownloadResourceGroup> data = new ArrayList<DownloadResourceGroup>();
		private DownloadActivity ctx;
		private DownloadResourceGroup mainGroup;

		

		public DownloadResourceGroupAdapter(DownloadActivity ctx) {
			this.ctx = ctx;
			TypedArray ta = ctx.getTheme().obtainStyledAttributes(new int[] { android.R.attr.textColorPrimary });
			ta.recycle();
		}

		public void update(DownloadResourceGroup mainGroup) {
			this.mainGroup = mainGroup;
			data = mainGroup.getGroups();
			notifyDataSetChanged();
		}

		@Override
		public Object getChild(int groupPosition, int childPosition) {
			DownloadResourceGroup drg = data.get(groupPosition);
			if (drg.getType().containsIndexItem()) {
				return drg.getItemByIndex(childPosition);
			}
			return drg.getGroupByIndex(childPosition);
		}

		@Override
		public long getChildId(int groupPosition, int childPosition) {
			return groupPosition * 10000 + childPosition;
		}

		@Override
		public View getChildView(final int groupPosition, final int childPosition, boolean isLastChild,
				View convertView, ViewGroup parent) {
			final Object child = getChild(groupPosition, childPosition);
			if (child instanceof IndexItem) {
				
				IndexItem item = (IndexItem) child;
				DownloadResourceGroup group = getGroupObj(groupPosition);
				ItemViewHolder viewHolder;
				if (convertView != null && convertView.getTag() instanceof ItemViewHolder) {
					viewHolder = (ItemViewHolder) convertView.getTag();
				}  else {
					convertView = LayoutInflater.from(parent.getContext()).inflate(
							R.layout.two_line_with_images_list_item, parent, false);
					viewHolder = new ItemViewHolder(convertView, ctx);
					viewHolder.setShowRemoteDate(true);
					convertView.setTag(viewHolder);
				}
				if(mainGroup.getType() == DownloadResourceGroupType.REGION && 
						group != null && group.getType() == DownloadResourceGroupType.REGION_MAPS) {
					viewHolder.setShowTypeInName(true);
					viewHolder.setShowTypeInDesc(false);
				} else if(group != null && (group.getType() == DownloadResourceGroupType.SRTM_HEADER || 
						group.getType() == DownloadResourceGroupType.HILLSHADE_HEADER)) {
					viewHolder.setShowTypeInName(false);
					viewHolder.setShowTypeInDesc(false);
				} else {
					viewHolder.setShowTypeInDesc(true);
				}
				viewHolder.bindIndexItem(item, group);
			} else {
				DownloadResourceGroup group = (DownloadResourceGroup) child;
				DownloadGroupViewHolder viewHolder;
				if (convertView != null && convertView.getTag() instanceof DownloadGroupViewHolder) {
					viewHolder = (DownloadGroupViewHolder) convertView.getTag();
				}  else {
					convertView = LayoutInflater.from(parent.getContext()).inflate(R.layout.simple_list_menu_item,
								parent, false);
					viewHolder = new DownloadGroupViewHolder(ctx, convertView);
					convertView.setTag(viewHolder);
				}
				viewHolder.bindItem(group);
			}

			return convertView;
		}

		

		@Override
		public View getGroupView(int groupPosition, boolean isExpanded, final View convertView, final ViewGroup parent) {
			View v = convertView;
			String section = getGroup(groupPosition);
			if (v == null) {
				LayoutInflater inflater = LayoutInflater.from(ctx);
				v = inflater.inflate(R.layout.download_item_list_section, parent, false);
			}
			TextView nameView = ((TextView) v.findViewById(R.id.section_name));
			nameView.setText(section);
			v.setOnClickListener(null);
			TypedValue typedValue = new TypedValue();
			Resources.Theme theme = ctx.getTheme();
			theme.resolveAttribute(R.attr.ctx_menu_info_view_bg, typedValue, true);
			v.setBackgroundColor(typedValue.data);

			return v;
		}

		@Override
		public int getChildrenCount(int groupPosition) {
			return data.get(groupPosition).size();
		}
		
		public DownloadResourceGroup getGroupObj(int groupPosition) {
			return data.get(groupPosition);
		}

		@Override
		public String getGroup(int groupPosition) {
			DownloadResourceGroup drg = data.get(groupPosition);
			int rid = drg.getType().getResourceId();
			if (rid != -1) {
				return ctx.getString(rid);
			}
			return "";
		}

		@Override
		public int getGroupCount() {
			return data.size();
		}

		@Override
		public long getGroupId(int groupPosition) {
			return groupPosition;
		}

		@Override
		public boolean hasStableIds() {
			return false;
		}

		@Override
		public boolean isChildSelectable(int groupPosition, int childPosition) {
			return true;
		}
	}
}
!@#$%
20190530_033251,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_c06800
package net.osmand.plus.download.ui;

import android.content.res.Resources;
import android.content.res.TypedArray;
import android.os.Bundle;
import android.support.v4.app.DialogFragment;
import android.support.v4.view.MenuItemCompat;
import android.support.v7.widget.Toolbar;
import android.util.TypedValue;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.widget.ExpandableListView;
import android.widget.ExpandableListView.OnChildClickListener;
import android.widget.TextView;

import net.osmand.plus.OsmandApplication;
import net.osmand.plus.OsmandSettings;
import net.osmand.plus.R;
import net.osmand.plus.activities.OsmandBaseExpandableListAdapter;
import net.osmand.plus.download.DownloadActivity;
import net.osmand.plus.download.DownloadActivity.BannerAndDownloadFreeVersion;
import net.osmand.plus.download.DownloadIndexesThread.DownloadEvents;
import net.osmand.plus.download.DownloadResourceGroup;
import net.osmand.plus.download.DownloadResourceGroup.DownloadResourceGroupType;
import net.osmand.plus.download.DownloadResources;
import net.osmand.plus.download.IndexItem;
import net.osmand.util.Algorithms;

import java.util.ArrayList;
import java.util.List;

public class DownloadResourceGroupFragment extends DialogFragment implements DownloadEvents, OnChildClickListener {
	public static final int RELOAD_ID = 0;
	public static final int SEARCH_ID = 1;
	public static final String TAG = "RegionDialogFragment";
	private static final String REGION_ID_DLG_KEY = "world_region_dialog_key";
	private String groupId;
	private View view;
	private BannerAndDownloadFreeVersion banner;
	protected ExpandableListView listView;
	protected DownloadResourceGroupAdapter listAdapter;
	private DownloadResourceGroup group;
	private DownloadActivity activity;
	private Toolbar toolbar;

	@Override
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		boolean isLightTheme = getMyApplication().getSettings().OSMAND_THEME.get() == OsmandSettings.OSMAND_LIGHT_THEME;
		int themeId = isLightTheme ? R.style.OsmandLightTheme : R.style.OsmandDarkTheme;
		setStyle(STYLE_NO_FRAME, themeId);
		setHasOptionsMenu(true);
	}

	public boolean openAsDialog() {
		return !Algorithms.isEmpty(groupId);
	}

	@Override
	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
		view = inflater.inflate(R.layout.maps_in_category_fragment, container, false);
		if (savedInstanceState != null) {
			groupId = savedInstanceState.getString(REGION_ID_DLG_KEY);
		}
		if (groupId == null && getArguments() != null) {
			groupId = getArguments().getString(REGION_ID_DLG_KEY);
		}
		if (groupId == null) {
			groupId = "";
		}
		activity = (DownloadActivity) getActivity();

		toolbar = (Toolbar) view.findViewById(R.id.toolbar);
		toolbar.setNavigationIcon(getMyApplication().getIconsCache().getIcon(R.drawable.abc_ic_ab_back_mtrl_am_alpha));
		toolbar.setNavigationOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				dismiss();
			}
		});
		if (!openAsDialog()) {
			toolbar.setVisibility(View.GONE);
		}

		setHasOptionsMenu(true);

		if(openAsDialog()) {
			banner = new BannerAndDownloadFreeVersion(view, (DownloadActivity) getActivity());
		} else {
			banner = null;
			view.findViewById(R.id.freeVersionBanner).setVisibility(View.GONE);
		}

		listView = (ExpandableListView) view.findViewById(android.R.id.list);
		listView.setOnChildClickListener(this);
		listAdapter = new DownloadResourceGroupAdapter(activity);
		listView.setAdapter(listAdapter);

		return view;
	}

	@Override
	public void onResume() {
		super.onResume();
		reloadData();
	}

	private void reloadData() {
		DownloadResources indexes = activity.getDownloadThread().getIndexes();
		group = indexes.getGroupById(groupId);
		if (group != null) {
			listAdapter.update(group);
			toolbar.setTitle(group.getName(activity));
		}
		expandAllGroups();
	}

	private void expandAllGroups() {
		for (int i = 0; i < listAdapter.getGroupCount(); i++) {
			listView.expandGroup(i);
		}
	}

	@Override
	public void onActivityCreated(Bundle savedInstanceState) {
		super.onActivityCreated(savedInstanceState);
		setShowsDialog(openAsDialog());
		listView.setBackgroundColor(getResources().getColor(
				getMyApplication().getSettings().isLightContent() ? R.color.bg_color_light : R.color.bg_color_dark));
	}

	@Override
	public void newDownloadIndexes() {
		if(banner != null) {
			banner.updateBannerInProgress();
		}
		reloadData();
	}

	@Override
	public void downloadHasFinished() {
		if(banner != null) {
			banner.updateBannerInProgress();
		}
		listAdapter.notifyDataSetChanged();
	}

	@Override
	public void downloadInProgress() {
		if(banner != null) {
			banner.updateBannerInProgress();
		}
		listAdapter.notifyDataSetChanged();
	}

	@Override
	public boolean onChildClick(ExpandableListView parent, View v, int groupPosition, int childPosition, long id) {
		Object child = listAdapter.getChild(groupPosition, childPosition);
		if (child instanceof DownloadResourceGroup) {
			String uniqueId = ((DownloadResourceGroup) child).getUniqueId();
			final DownloadResourceGroupFragment regionDialogFragment = DownloadResourceGroupFragment
					.createInstance(uniqueId);
			((DownloadActivity) getActivity()).showDialog(getActivity(), regionDialogFragment);
			return true;
		} else if (child instanceof IndexItem) {
			IndexItem indexItem = (IndexItem) child;
			DownloadResourceGroup groupObj = listAdapter.getGroupObj(groupPosition);
			ItemViewHolder vh = (ItemViewHolder) v.getTag();
			OnClickListener ls = vh.getRightButtonAction(indexItem, vh.getClickAction(indexItem), groupObj);
			ls.onClick(v);
			return true;
		}
		return false;
	}

	

	@Override
	public void onSaveInstanceState(Bundle outState) {
		outState.putString(REGION_ID_DLG_KEY, groupId);
		super.onSaveInstanceState(outState);
	}

	private OsmandApplication getMyApplication() {
		return (OsmandApplication) getActivity().getApplication();
	}

	private DownloadActivity getDownloadActivity() {
		return (DownloadActivity) getActivity();
	}

	@Override
	public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
		if (!openAsDialog()) {
			MenuItem itemReload = menu.add(0, RELOAD_ID, 0, R.string.shared_string_refresh);
			itemReload.setIcon(R.drawable.ic_action_refresh_dark);
			MenuItemCompat.setShowAsAction(itemReload, MenuItemCompat.SHOW_AS_ACTION_ALWAYS);

			MenuItem itemSearch = menu.add(0, SEARCH_ID, 1, R.string.shared_string_search);
			itemSearch.setIcon(R.drawable.ic_action_search_dark);
			MenuItemCompat.setShowAsAction(itemSearch, MenuItemCompat.SHOW_AS_ACTION_ALWAYS);
		}
	}

	@Override
	public boolean onOptionsItemSelected(MenuItem item) {
		switch (item.getItemId()) {
		case RELOAD_ID:
			// re-create the thread
			getDownloadActivity().getDownloadThread().runReloadIndexFiles();
			return true;
		case SEARCH_ID:
			getDownloadActivity().showDialog(getActivity(), SearchDialogFragment.createInstance(""));
			return true;
		default:
			return super.onOptionsItemSelected(item);
		}
	}

	public static DownloadResourceGroupFragment createInstance(String regionId) {
		Bundle bundle = new Bundle();
		bundle.putString(REGION_ID_DLG_KEY, regionId);
		DownloadResourceGroupFragment fragment = new DownloadResourceGroupFragment();
		fragment.setArguments(bundle);
		return fragment;
	}


	public static class DownloadResourceGroupAdapter extends OsmandBaseExpandableListAdapter {

		private List<DownloadResourceGroup> data = new ArrayList<DownloadResourceGroup>();
		private DownloadActivity ctx;
		private DownloadResourceGroup mainGroup;

		

		public DownloadResourceGroupAdapter(DownloadActivity ctx) {
			this.ctx = ctx;
			TypedArray ta = ctx.getTheme().obtainStyledAttributes(new int[] { android.R.attr.textColorPrimary });
			ta.recycle();
		}

		public void update(DownloadResourceGroup mainGroup) {
			this.mainGroup = mainGroup;
			data = mainGroup.getGroups();
			notifyDataSetChanged();
		}

		@Override
		public Object getChild(int groupPosition, int childPosition) {
			DownloadResourceGroup drg = data.get(groupPosition);
			if (drg.getType().containsIndexItem()) {
				return drg.getItemByIndex(childPosition);
			}
			return drg.getGroupByIndex(childPosition);
		}

		@Override
		public long getChildId(int groupPosition, int childPosition) {
			return groupPosition * 10000 + childPosition;
		}

		@Override
		public View getChildView(final int groupPosition, final int childPosition, boolean isLastChild,
				View convertView, ViewGroup parent) {
			final Object child = getChild(groupPosition, childPosition);
			if (child instanceof IndexItem) {
				
				IndexItem item = (IndexItem) child;
				DownloadResourceGroup group = getGroupObj(groupPosition);
				ItemViewHolder viewHolder;
				if (convertView != null && convertView.getTag() instanceof ItemViewHolder) {
					viewHolder = (ItemViewHolder) convertView.getTag();
				}  else {
					convertView = LayoutInflater.from(parent.getContext()).inflate(
							R.layout.two_line_with_images_list_item, parent, false);
					viewHolder = new ItemViewHolder(convertView, ctx);
					viewHolder.setShowRemoteDate(true);
					convertView.setTag(viewHolder);
				}
				if(mainGroup.getType() == DownloadResourceGroupType.REGION && 
						group != null && group.getType() == DownloadResourceGroupType.REGION_MAPS) {
					viewHolder.setShowTypeInName(true);
					viewHolder.setShowTypeInDesc(false);
				} else if(group != null && (group.getType() == DownloadResourceGroupType.SRTM_HEADER || 
						group.getType() == DownloadResourceGroupType.HILLSHADE_HEADER)) {
					viewHolder.setShowTypeInName(false);
					viewHolder.setShowTypeInDesc(false);
				} else {
					viewHolder.setShowTypeInDesc(true);
				}
				viewHolder.bindIndexItem(item, group);
			} else {
				DownloadResourceGroup group = (DownloadResourceGroup) child;
				DownloadGroupViewHolder viewHolder;
				if (convertView != null && convertView.getTag() instanceof DownloadGroupViewHolder) {
					viewHolder = (DownloadGroupViewHolder) convertView.getTag();
				}  else {
					convertView = LayoutInflater.from(parent.getContext()).inflate(R.layout.simple_list_menu_item,
								parent, false);
					viewHolder = new DownloadGroupViewHolder(ctx, convertView);
					convertView.setTag(viewHolder);
				}
				viewHolder.bindItem(group);
			}

			return convertView;
		}

		

		@Override
		public View getGroupView(int groupPosition, boolean isExpanded, final View convertView, final ViewGroup parent) {
			View v = convertView;
			String section = getGroup(groupPosition);
			if (v == null) {
				LayoutInflater inflater = LayoutInflater.from(ctx);
				v = inflater.inflate(R.layout.download_item_list_section, parent, false);
			}
			TextView nameView = ((TextView) v.findViewById(R.id.section_name));
			nameView.setText(section);
			v.setOnClickListener(null);
			TypedValue typedValue = new TypedValue();
			Resources.Theme theme = ctx.getTheme();
			theme.resolveAttribute(R.attr.ctx_menu_info_view_bg, typedValue, true);
			v.setBackgroundColor(typedValue.data);

			return v;
		}

		@Override
		public int getChildrenCount(int groupPosition) {
			return data.get(groupPosition).size();
		}
		
		public DownloadResourceGroup getGroupObj(int groupPosition) {
			return data.get(groupPosition);
		}

		@Override
		public String getGroup(int groupPosition) {
			DownloadResourceGroup drg = data.get(groupPosition);
			int rid = drg.getType().getResourceId();
			if (rid != -1) {
				return ctx.getString(rid);
			}
			return "";
		}

		@Override
		public int getGroupCount() {
			return data.size();
		}

		@Override
		public long getGroupId(int groupPosition) {
			return groupPosition;
		}

		@Override
		public boolean hasStableIds() {
			return false;
		}

		@Override
		public boolean isChildSelectable(int groupPosition, int childPosition) {
			return true;
		}
	}
}
!@#$%
20190530_035435,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_b04792
package net.osmand.plus;

import android.app.Activity;
import android.app.AlarmManager;
import android.app.Application;
import android.app.PendingIntent;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager.NameNotFoundException;
import android.content.res.Configuration;
import android.os.AsyncTask;
import android.os.Build;
import android.os.Handler;
import android.os.Message;
import android.support.v7.app.AlertDialog;
import android.text.format.DateFormat;
import android.util.TypedValue;
import android.view.View;
import android.view.accessibility.AccessibilityManager;
import android.widget.CheckBox;
import android.widget.LinearLayout;
import android.widget.LinearLayout.LayoutParams;
import android.widget.TextView;
import android.widget.Toast;

import net.osmand.PlatformUtil;
import net.osmand.access.AccessibilityPlugin;
import net.osmand.access.AccessibleAlertBuilder;
import net.osmand.access.AccessibleToast;
import net.osmand.map.OsmandRegions;
import net.osmand.osm.MapPoiTypes;
import net.osmand.plus.AppInitializer.AppInitializeListener;
import net.osmand.plus.access.AccessibilityMode;
import net.osmand.plus.activities.DayNightHelper;
import net.osmand.plus.activities.ExitActivity;
import net.osmand.plus.activities.SavingTrackHelper;
import net.osmand.plus.activities.SettingsActivity;
import net.osmand.plus.api.SQLiteAPI;
import net.osmand.plus.api.SQLiteAPIImpl;
import net.osmand.plus.dialogs.RateUsBottomSheetDialog;
import net.osmand.plus.download.DownloadIndexesThread;
import net.osmand.plus.helpers.AvoidSpecificRoads;
import net.osmand.plus.helpers.WaypointHelper;
import net.osmand.plus.monitoring.LiveMonitoringHelper;
import net.osmand.plus.poi.PoiFiltersHelper;
import net.osmand.plus.render.RendererRegistry;
import net.osmand.plus.resources.ResourceManager;
import net.osmand.plus.routing.RoutingHelper;
import net.osmand.plus.voice.CommandPlayer;
import net.osmand.router.RoutingConfiguration;
import net.osmand.util.Algorithms;

import java.io.BufferedWriter;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileWriter;
import java.io.PrintStream;
import java.lang.Thread.UncaughtExceptionHandler;
import java.util.Locale;

import btools.routingapp.BRouterServiceConnection;
import btools.routingapp.IBRouterService;



public class OsmandApplication extends Application {
	public static final String EXCEPTION_PATH = "exception.log"; //$NON-NLS-1$
	private static final org.apache.commons.logging.Log LOG = PlatformUtil.getLog(OsmandApplication.class);

	final AppInitializer appInitializer = new AppInitializer(this);
	OsmandSettings osmandSettings = null;
	OsmAndAppCustomization appCustomization;
	private final SQLiteAPI sqliteAPI = new SQLiteAPIImpl(this);
	private final OsmAndTaskManager taskManager = new OsmAndTaskManager(this);
	private final IconsCache iconsCache = new IconsCache(this);
	Handler uiHandler;

	NavigationService navigationService;
	
	// start variables
	ResourceManager resourceManager;
	OsmAndLocationProvider locationProvider;
	RendererRegistry rendererRegistry;
	DayNightHelper daynightHelper;
	PoiFiltersHelper poiFilters;
	MapPoiTypes poiTypes;
	RoutingHelper routingHelper;
	FavouritesDbHelper favorites;
	CommandPlayer player;
	GpxSelectionHelper selectedGpxHelper;
	SavingTrackHelper savingTrackHelper;
	NotificationHelper notificationHelper;
	LiveMonitoringHelper liveMonitoringHelper;
	TargetPointsHelper targetPointsHelper;
	WaypointHelper waypointHelper;
	DownloadIndexesThread downloadIndexesThread;
	AvoidSpecificRoads avoidSpecificRoads;
	BRouterServiceConnection bRouterServiceConnection;
	OsmandRegions regions;


	RoutingConfiguration.Builder defaultRoutingConfig;
	private Locale preferredLocale = null;
	private Locale defaultLocale;
	private File externalStorageDirectory;
	
	
	// Typeface
	
	@Override
	public void onCreate() {
		long timeToStart = System.currentTimeMillis();
		if (Version.getAppName(this).equals("OsmAnd~")) {
			if (android.os.Build.VERSION.SDK_INT >= 9) {
				try {
					Class.forName("net.osmand.plus.base.EnableStrictMode").newInstance();
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		}
		super.onCreate();
		createInUiThread();
		uiHandler = new Handler();
		appCustomization = new OsmAndAppCustomization();
		appCustomization.setup(this);
		osmandSettings = appCustomization.getOsmandSettings();
		externalStorageDirectory = osmandSettings.getExternalStorageDirectory();
		
		checkPreferredLocale();
		appInitializer.onCreateApplication();
//		if(!osmandSettings.FOLLOW_THE_ROUTE.get()) {
//			targetPointsHelper.clearPointToNavigate(false);
//		}
		startApplication();
		System.out.println("Time to start application " + (System.currentTimeMillis() - timeToStart) + " ms. Should be less < 800 ms");
		timeToStart = System.currentTimeMillis();
		OsmandPlugin.initPlugins(this);
		System.out.println("Time to init plugins " + (System.currentTimeMillis() - timeToStart) + " ms. Should be less < 800 ms");
	}
	
	public AppInitializer getAppInitializer() {
		return appInitializer;
	}
	
	public MapPoiTypes getPoiTypes() {
		return poiTypes;
	}

	private void createInUiThread() {
		new Toast(this); // activate in UI thread to avoid further exceptions
		new AsyncTask<View, Void, Void>() {
			@Override
			protected Void doInBackground(View... params) {
				return null;
			}

			protected void onPostExecute(Void result) {
			}
		}.execute();
	}
	
	public IconsCache getIconsCache() {
		return iconsCache;
	}
	
	@Override
	public void onTerminate() {
		super.onTerminate();
		if (routingHelper != null) {
			routingHelper.getVoiceRouter().onApplicationTerminate();
		}
        if(RateUsBottomSheetDialog.shouldShow(osmandSettings)) {
            osmandSettings.RATE_US_STATE.set(RateUsBottomSheetDialog.RateUsState.IGNORED);
        }
        getNotificationHelper().removeServiceNotification();
	}

	public RendererRegistry getRendererRegistry() {
		return rendererRegistry;
	}
	
	public OsmAndTaskManager getTaskManager() {
		return taskManager;
	}
	
	public AvoidSpecificRoads getAvoidSpecificRoads() {
		return avoidSpecificRoads;
	}

	public OsmAndLocationProvider getLocationProvider() {
		return locationProvider;
	}
	
	public OsmAndAppCustomization getAppCustomization() {
		return appCustomization;
	}
	
	
	public void setAppCustomization(OsmAndAppCustomization appCustomization) {
		this.appCustomization = appCustomization;
		this.appCustomization.setup(this);
	}

	/**
	 * Application settings
	 * 
	 * @return Reference to instance of OsmandSettings
	 */
	public OsmandSettings getSettings() {
		if (osmandSettings == null) {
			LOG.error("Trying to access settings before they were created");
		}
		return osmandSettings;
	}

	public SavingTrackHelper getSavingTrackHelper() {
		return savingTrackHelper;
	}
	
	public NotificationHelper getNotificationHelper() {
		return notificationHelper;
	}

	public LiveMonitoringHelper getLiveMonitoringHelper() {
		return liveMonitoringHelper;
	}

	public WaypointHelper getWaypointHelper() {
		return waypointHelper;
	}

	public PoiFiltersHelper getPoiFilters() {
		return poiFilters;
	}


	public GpxSelectionHelper getSelectedGpxHelper() {
		return selectedGpxHelper;
	}

	public FavouritesDbHelper getFavorites() {
		return favorites;
	}

	public ResourceManager getResourceManager() {
		return resourceManager;
	}

	public DayNightHelper getDaynightHelper() {
		return daynightHelper;
	}
	
	public synchronized DownloadIndexesThread getDownloadThread() {
		if(downloadIndexesThread == null) {
			downloadIndexesThread = new DownloadIndexesThread(this);
		}
		return downloadIndexesThread;
	}

	@Override
	public void onLowMemory() {
		super.onLowMemory();
		resourceManager.onLowMemory();
	}

	@Override
	public void onConfigurationChanged(Configuration newConfig) {
		if (preferredLocale != null && !newConfig.locale.getLanguage().equals(preferredLocale.getLanguage())) {
			super.onConfigurationChanged(newConfig);
			// ugly fix ! On devices after 4.0 screen is blinking when you rotate device!
			if (Build.VERSION.SDK_INT < 14) {
				newConfig.locale = preferredLocale;
			}
			getBaseContext().getResources().updateConfiguration(newConfig, getBaseContext().getResources().getDisplayMetrics());
			Locale.setDefault(preferredLocale);
		} else {
			super.onConfigurationChanged(newConfig);
		}
	}

	public void checkPreferredLocale() {
		Configuration config = getBaseContext().getResources().getConfiguration();
		String lang = osmandSettings.PREFERRED_LOCALE.get();
		if(defaultLocale == null) {
			defaultLocale = Locale.getDefault();
		}
		if (!"".equals(lang) && !config.locale.getLanguage().equals(lang)) {
			preferredLocale = new Locale(lang);
			Locale.setDefault(preferredLocale);
			config.locale = preferredLocale;
			getBaseContext().getResources().updateConfiguration(config, getBaseContext().getResources().getDisplayMetrics());
		} else if("".equals(lang) && defaultLocale != null && Locale.getDefault() != defaultLocale) {
			Locale.setDefault(defaultLocale);
			config.locale = defaultLocale;
			preferredLocale = null;
			getBaseContext().getResources().updateConfiguration(config, getBaseContext().getResources().getDisplayMetrics());
		}
		
	}

	public static final int PROGRESS_DIALOG = 5;

	public void checkApplicationIsBeingInitialized(Activity activity, AppInitializeListener listener) {
		// start application if it was previously closed
		startApplication();
		if(listener != null) {
			appInitializer.addListener(listener);
		}
	}
	
	public void unsubscribeInitListener(AppInitializeListener listener) {
		if(listener != null) {
			appInitializer.removeListener(listener);
		}		
	}
	
	public boolean isApplicationInitializing() {
		return appInitializer.isAppInitializing();
	}

	public RoutingHelper getRoutingHelper() {
		return routingHelper;
	}

	public CommandPlayer getPlayer() {
		return player;
	}

	public void initVoiceCommandPlayer(final Activity uiContext) {
		showDialogInitializingCommandPlayer(uiContext, true, null, false);
	}

	public void showDialogInitializingCommandPlayer(final Activity uiContext, boolean warningNoneProvider) {
		showDialogInitializingCommandPlayer(uiContext, warningNoneProvider, null, true);
	}

	public void showDialogInitializingCommandPlayer(final Activity uiContext, boolean warningNoneProvider, Runnable run, boolean showDialog) {
		String voiceProvider = osmandSettings.VOICE_PROVIDER.get();
		if (voiceProvider == null || OsmandSettings.VOICE_PROVIDER_NOT_USE.equals(voiceProvider)) {
			if (warningNoneProvider && voiceProvider == null) {
				AlertDialog.Builder builder = new AccessibleAlertBuilder(uiContext);
				LinearLayout ll = new LinearLayout(uiContext);
				ll.setOrientation(LinearLayout.VERTICAL);
				final TextView tv = new TextView(uiContext);
				tv.setPadding(7, 3, 7, 0);
				tv.setText(R.string.voice_is_not_available_msg);
				tv.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 19);
				ll.addView(tv);
				
				final CheckBox cb = new CheckBox(uiContext);
				cb.setText(R.string.shared_string_remember_my_choice);
				LinearLayout.LayoutParams lp = new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);
				lp.setMargins(7, 10, 7, 0);
				cb.setLayoutParams(lp);
				ll.addView(cb);
				
				builder.setCancelable(true);
				builder.setNegativeButton(R.string.shared_string_cancel, new DialogInterface.OnClickListener() {
					@Override
					public void onClick(DialogInterface dialog, int which) {
						if(cb.isChecked()) {
							osmandSettings.VOICE_PROVIDER.set(OsmandSettings.VOICE_PROVIDER_NOT_USE);
						}
					}
				});
				builder.setPositiveButton(R.string.shared_string_ok, new DialogInterface.OnClickListener() {
					@Override
					public void onClick(DialogInterface dialog, int which) {
						Intent intent = new Intent(uiContext, SettingsActivity.class);
						intent.putExtra(SettingsActivity.INTENT_KEY_SETTINGS_SCREEN, SettingsActivity.SCREEN_GENERAL_SETTINGS);
						uiContext.startActivity(intent);
					}
				});
				
				
				builder.setTitle(R.string.voice_is_not_available_title);
				builder.setView(ll);
				//builder.setMessage(R.string.voice_is_not_available_msg);
				builder.show();
			}

		} else {
			if (player == null || !Algorithms.objectEquals(voiceProvider, player.getCurrentVoice())) {
				appInitializer.	initVoiceDataInDifferentThread(uiContext, voiceProvider, run, showDialog);
			}
		}

	}

	public NavigationService getNavigationService() {
		return navigationService;
	}

	public void setNavigationService(NavigationService navigationService) {
		this.navigationService = navigationService;
	}


	private void fullExit() {
		// http://stackoverflow.com/questions/2092951/how-to-close-android-application
		System.runFinalizersOnExit(true);
		System.exit(0);
	}

	public synchronized void closeApplication(final Activity activity) {
		if (getNavigationService() != null) {
			AlertDialog.Builder bld = new AlertDialog.Builder(activity);
			bld.setMessage(R.string.background_service_is_enabled_question);
			bld.setPositiveButton(R.string.shared_string_yes, new DialogInterface.OnClickListener() {
				@Override
				public void onClick(DialogInterface dialog, int which) {
					closeApplicationAnywayImpl(activity, true);
				}
			});
			bld.setNegativeButton(R.string.shared_string_no, new DialogInterface.OnClickListener() {
				@Override
				public void onClick(DialogInterface dialog, int which) {
					closeApplicationAnywayImpl(activity, false);
				}
			});
			bld.show();
		} else {
			closeApplicationAnywayImpl(activity, true);
		}
	}
	
	private void closeApplicationAnyway(final Activity activity, boolean disableService) {
		activity.finish();
		Intent newIntent = new Intent(activity, ExitActivity.class);
		newIntent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_NEW_TASK);
		newIntent.putExtra(ExitActivity.DISABLE_SERVICE, disableService);
		startActivity(newIntent);
	}

	public void closeApplicationAnywayImpl(final Activity activity, boolean disableService) {
		if (appInitializer.isAppInitializing()) {
			resourceManager.close();
		}
		activity.finish();
		if (getNavigationService() == null) {
			fullExit();
		} else if (disableService) {
			final Intent serviceIntent = new Intent(this, NavigationService.class);
			stopService(serviceIntent);

			new Thread(new Runnable() {
				public void run() {
					//wait until the service has fully stopped
					while (getNavigationService() != null) {
						try {
							Thread.sleep(100);
						}
							catch (InterruptedException e) {
						}
					}

					fullExit();
				}
			}).start();
		}
	}

	public void startApplication() {
		Thread.setDefaultUncaughtExceptionHandler(new DefaultExceptionHandler());
		appInitializer.startApplication();
	}

	private class DefaultExceptionHandler implements UncaughtExceptionHandler {

		private UncaughtExceptionHandler defaultHandler;
		private PendingIntent intent;

		public DefaultExceptionHandler() {
			defaultHandler = Thread.getDefaultUncaughtExceptionHandler();
			intent = PendingIntent.getActivity(OsmandApplication.this.getBaseContext(), 0,
					new Intent(OsmandApplication.this.getBaseContext(),
							getAppCustomization().getMapActivity()), 0);
		}

		@Override
		public void uncaughtException(final Thread thread, final Throwable ex) {
			File file = getAppPath(EXCEPTION_PATH);
			try {
				ByteArrayOutputStream out = new ByteArrayOutputStream();
				PrintStream printStream = new PrintStream(out);
				ex.printStackTrace(printStream);
				StringBuilder msg = new StringBuilder();
				msg.append("Version  " + Version.getFullVersion(OsmandApplication.this) + "\n"). //$NON-NLS-1$ 
						append(DateFormat.format("dd.MM.yyyy h:mm:ss", System.currentTimeMillis()));
				try {
					PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), 0);
					if (info != null) {
						msg.append("\nApk Version : ").append(info.versionName).append(" ").append(info.versionCode); //$NON-NLS-1$ //$NON-NLS-2$
					}
				} catch (Throwable e) {
				}
				msg.append("\n"). //$NON-NLS-1$//$NON-NLS-2$
						append("Exception occured in thread " + thread.toString() + " : \n"). //$NON-NLS-1$ //$NON-NLS-2$
						append(new String(out.toByteArray()));

				if (file.getParentFile().canWrite()) {
					BufferedWriter writer = new BufferedWriter(new FileWriter(file, true));
					writer.write(msg.toString());
					writer.close();
				}
				if (routingHelper.isFollowingMode()) {
					AlarmManager mgr = (AlarmManager) getSystemService(Context.ALARM_SERVICE);
					mgr.set(AlarmManager.RTC, System.currentTimeMillis() + 2000, intent);
					System.exit(2);
				}
				defaultHandler.uncaughtException(thread, ex);
			} catch (Exception e) {
				// swallow all exceptions
				android.util.Log.e(PlatformUtil.TAG, "Exception while handle other exception", e); //$NON-NLS-1$
			}

		}
	}

	
	public TargetPointsHelper getTargetPointsHelper() {
		return targetPointsHelper;
	}

	public void showShortToastMessage(final int msgId, final Object... args) {
		uiHandler.post(new Runnable() {
			@Override
			public void run() {
				AccessibleToast.makeText(OsmandApplication.this, getString(msgId, args), Toast.LENGTH_SHORT).show();
			}
		});
	}

	public void showShortToastMessage(final String msg) {
		uiHandler.post(new Runnable() {
			@Override
			public void run() {
				AccessibleToast.makeText(OsmandApplication.this, msg, Toast.LENGTH_SHORT).show();
			}
		});
	}

	public void showToastMessage(final int msgId, final Object... args) {
		uiHandler.post(new Runnable() {
			@Override
			public void run() {
				AccessibleToast.makeText(OsmandApplication.this, getString(msgId, args), Toast.LENGTH_LONG).show();
			}
		});
	}

	public void showToastMessage(final String msg) {
		uiHandler.post(new Runnable() {
			@Override
			public void run() {
				AccessibleToast.makeText(OsmandApplication.this, msg, Toast.LENGTH_LONG).show();				
			}
		});
	}

	public SQLiteAPI getSQLiteAPI() {
		return sqliteAPI;
	}

	public void runInUIThread(Runnable run) {
		uiHandler.post(run);
	}

	public void runInUIThread(Runnable run, long delay) {
		uiHandler.postDelayed(run, delay);
	}
	
	public void runMessageInUIThreadAndCancelPrevious(final int messageId, final Runnable run, long delay) {
		Message msg = Message.obtain(uiHandler, new Runnable() {
			
			@Override
			public void run() {
				if(!uiHandler.hasMessages(messageId)) {
					run.run();
				}
			}
		});
		msg.what = messageId;
		uiHandler.removeMessages(messageId);
		uiHandler.sendMessageDelayed(msg, delay);
	}
	
	public File getAppPath(String path) {
		if(path == null) {
			path = "";
		}
		return new File(externalStorageDirectory, path);
	}
	
	public void setExternalStorageDirectory(int type, String directory){
		osmandSettings.setExternalStorageDirectory(type, directory);
		externalStorageDirectory = osmandSettings.getExternalStorageDirectory();
		getResourceManager().resetStoreDirectory();
	}

	public void applyTheme(Context c) {
		int t = R.style.OsmandDarkTheme;
		if (osmandSettings.OSMAND_THEME.get() == OsmandSettings.OSMAND_DARK_THEME) {
			t = R.style.OsmandDarkTheme;
		} else if (osmandSettings.OSMAND_THEME.get() == OsmandSettings.OSMAND_LIGHT_THEME) {
			t = R.style.OsmandLightTheme;
		}
		setLanguage(c);
		c.setTheme(t);
	}
	
	public IBRouterService getBRouterService() {
		if(bRouterServiceConnection == null) {
			return null;
		}
		return bRouterServiceConnection.getBrouterService();
	}
	
	public void setLanguage(Context context) {
		if (preferredLocale != null) {
			Configuration config = context.getResources().getConfiguration();
			String lang = preferredLocale.getLanguage();
			if (!"".equals(lang) && !config.locale.getLanguage().equals(lang)) {
				preferredLocale = new Locale(lang);
				Locale.setDefault(preferredLocale);
				config.locale = preferredLocale;
				context.getResources().updateConfiguration(config, context.getResources().getDisplayMetrics());
			} else if("".equals(lang) && defaultLocale != null && Locale.getDefault() != defaultLocale) {
				Locale.setDefault(defaultLocale);
				config.locale = defaultLocale;
				getBaseContext().getResources().updateConfiguration(config, getBaseContext().getResources().getDisplayMetrics());
			}
		}
	}
	
	public String getLanguage() {
		String lang = "";
		if (preferredLocale != null) {
			lang = preferredLocale.getLanguage();
		} else {
			lang = Locale.getDefault().getLanguage();
		}
		if (lang != null && lang.length() > 2) {
			lang = lang.substring(0, 2).toLowerCase();
		}
		return lang;
	}
	
	public RoutingConfiguration.Builder getDefaultRoutingConfig() {
		if(defaultRoutingConfig == null) {
			defaultRoutingConfig = appInitializer.getLazyDefaultRoutingConfig();
		}
		return defaultRoutingConfig;
	}
	
	public OsmandRegions getRegions() {
		return regions;
	}

	public boolean accessibilityExtensions() {
		return (Build.VERSION.SDK_INT < 14) ? getSettings().ACCESSIBILITY_EXTENSIONS.get() : false;
	}
	
	public boolean accessibilityEnabled() {
		final AccessibilityMode mode = getSettings().ACCESSIBILITY_MODE.get();
		if(OsmandPlugin.getEnabledPlugin(AccessibilityPlugin.class) == null) {
			return false;
		}
		if (mode == AccessibilityMode.ON) {
			return true;
		} else if (mode == AccessibilityMode.OFF) {
			return false;
		}
		return ((AccessibilityManager) getSystemService(Context.ACCESSIBILITY_SERVICE)).isEnabled();
	}

	public String getVersionName() {
		try {
			PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), 0);
			return info.versionName;
		} catch (NameNotFoundException e) {
			return "";
		}
	}

	public int getVersionCode() {
		try {
			PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), 0);
			return info.versionCode;
		} catch (NameNotFoundException e) {
			return 0;
		}
	}
	

	public void startNavigationService(int intent) {
		final Intent serviceIntent = new Intent(this, NavigationService.class);
		serviceIntent.putExtra(NavigationService.USAGE_INTENT, intent);
		if (getNavigationService() == null) {
			if (intent != NavigationService.USED_BY_GPX) {
				//for only-USED_BY_GPX case use pre-configured SERVICE_OFF_INTERVAL
				//other cases always use "continuous":
				getSettings().SERVICE_OFF_INTERVAL.set(0);
			}
			startService(serviceIntent);
		} else {
			//additional cases always use "continuous"
			//TODO: fallback to custom USED_BY_GPX interval in case all other sleep mode purposes have been stopped
			getSettings().SERVICE_OFF_INTERVAL.set(0);
			getNavigationService().addUsageIntent(intent);
			getNotificationHelper().showNotification();
		}	
	}


	public String getLangTranslation(String l) {
		try {
			java.lang.reflect.Field f = R.string.class.getField("lang_"+l);
			if (f != null) {
				Integer in = (Integer) f.get(null);
				return getString(in);
			}
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return l;
	}
}
!@#$%
20190530_035435,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_a04792
package net.osmand.plus;

import android.app.Activity;
import android.app.AlarmManager;
import android.app.PendingIntent;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager.NameNotFoundException;
import android.content.res.Configuration;
import android.os.AsyncTask;
import android.os.Build;
import android.os.Handler;
import android.os.Message;
import android.support.multidex.MultiDexApplication;
import android.support.v7.app.AlertDialog;
import android.text.format.DateFormat;
import android.util.TypedValue;
import android.view.View;
import android.view.accessibility.AccessibilityManager;
import android.widget.CheckBox;
import android.widget.LinearLayout;
import android.widget.LinearLayout.LayoutParams;
import android.widget.TextView;
import android.widget.Toast;

import net.osmand.PlatformUtil;
import net.osmand.access.AccessibilityPlugin;
import net.osmand.access.AccessibleAlertBuilder;
import net.osmand.access.AccessibleToast;
import net.osmand.map.OsmandRegions;
import net.osmand.osm.MapPoiTypes;
import net.osmand.plus.AppInitializer.AppInitializeListener;
import net.osmand.plus.access.AccessibilityMode;
import net.osmand.plus.activities.DayNightHelper;
import net.osmand.plus.activities.ExitActivity;
import net.osmand.plus.activities.SavingTrackHelper;
import net.osmand.plus.activities.SettingsActivity;
import net.osmand.plus.api.SQLiteAPI;
import net.osmand.plus.api.SQLiteAPIImpl;
import net.osmand.plus.dialogs.RateUsBottomSheetDialog;
import net.osmand.plus.download.DownloadIndexesThread;
import net.osmand.plus.helpers.AvoidSpecificRoads;
import net.osmand.plus.helpers.WaypointHelper;
import net.osmand.plus.monitoring.LiveMonitoringHelper;
import net.osmand.plus.poi.PoiFiltersHelper;
import net.osmand.plus.render.RendererRegistry;
import net.osmand.plus.resources.ResourceManager;
import net.osmand.plus.routing.RoutingHelper;
import net.osmand.plus.voice.CommandPlayer;
import net.osmand.router.RoutingConfiguration;
import net.osmand.util.Algorithms;

import java.io.BufferedWriter;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileWriter;
import java.io.PrintStream;
import java.lang.Thread.UncaughtExceptionHandler;
import java.util.Locale;

import btools.routingapp.BRouterServiceConnection;
import btools.routingapp.IBRouterService;



public class OsmandApplication extends MultiDexApplication {
	public static final String EXCEPTION_PATH = "exception.log"; //$NON-NLS-1$
	private static final org.apache.commons.logging.Log LOG = PlatformUtil.getLog(OsmandApplication.class);

	final AppInitializer appInitializer = new AppInitializer(this);
	OsmandSettings osmandSettings = null;
	OsmAndAppCustomization appCustomization;
	private final SQLiteAPI sqliteAPI = new SQLiteAPIImpl(this);
	private final OsmAndTaskManager taskManager = new OsmAndTaskManager(this);
	private final IconsCache iconsCache = new IconsCache(this);
	Handler uiHandler;

	NavigationService navigationService;
	
	// start variables
	ResourceManager resourceManager;
	OsmAndLocationProvider locationProvider;
	RendererRegistry rendererRegistry;
	DayNightHelper daynightHelper;
	PoiFiltersHelper poiFilters;
	MapPoiTypes poiTypes;
	RoutingHelper routingHelper;
	FavouritesDbHelper favorites;
	CommandPlayer player;
	GpxSelectionHelper selectedGpxHelper;
	SavingTrackHelper savingTrackHelper;
	NotificationHelper notificationHelper;
	LiveMonitoringHelper liveMonitoringHelper;
	TargetPointsHelper targetPointsHelper;
	WaypointHelper waypointHelper;
	DownloadIndexesThread downloadIndexesThread;
	AvoidSpecificRoads avoidSpecificRoads;
	BRouterServiceConnection bRouterServiceConnection;
	OsmandRegions regions;


	RoutingConfiguration.Builder defaultRoutingConfig;
	private Locale preferredLocale = null;
	private Locale defaultLocale;
	private File externalStorageDirectory;
	
	
	// Typeface
	
	@Override
	public void onCreate() {
		long timeToStart = System.currentTimeMillis();
		if (Version.getAppName(this).equals("OsmAnd~")) {
			if (android.os.Build.VERSION.SDK_INT >= 9) {
				try {
					Class.forName("net.osmand.plus.base.EnableStrictMode").newInstance();
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		}
		super.onCreate();
		createInUiThread();
		uiHandler = new Handler();
		appCustomization = new OsmAndAppCustomization();
		appCustomization.setup(this);
		osmandSettings = appCustomization.getOsmandSettings();
		externalStorageDirectory = osmandSettings.getExternalStorageDirectory();
		
		checkPreferredLocale();
		appInitializer.onCreateApplication();
//		if(!osmandSettings.FOLLOW_THE_ROUTE.get()) {
//			targetPointsHelper.clearPointToNavigate(false);
//		}
		startApplication();
		System.out.println("Time to start application " + (System.currentTimeMillis() - timeToStart) + " ms. Should be less < 800 ms");
		timeToStart = System.currentTimeMillis();
		OsmandPlugin.initPlugins(this);
		System.out.println("Time to init plugins " + (System.currentTimeMillis() - timeToStart) + " ms. Should be less < 800 ms");
	}
	
	public AppInitializer getAppInitializer() {
		return appInitializer;
	}
	
	public MapPoiTypes getPoiTypes() {
		return poiTypes;
	}

	private void createInUiThread() {
		new Toast(this); // activate in UI thread to avoid further exceptions
		new AsyncTask<View, Void, Void>() {
			@Override
			protected Void doInBackground(View... params) {
				return null;
			}

			protected void onPostExecute(Void result) {
			}
		}.execute();
	}
	
	public IconsCache getIconsCache() {
		return iconsCache;
	}
	
	@Override
	public void onTerminate() {
		super.onTerminate();
		if (routingHelper != null) {
			routingHelper.getVoiceRouter().onApplicationTerminate();
		}
        if(RateUsBottomSheetDialog.shouldShow(osmandSettings)) {
            osmandSettings.RATE_US_STATE.set(RateUsBottomSheetDialog.RateUsState.IGNORED);
        }
        getNotificationHelper().removeServiceNotification();
	}

	public RendererRegistry getRendererRegistry() {
		return rendererRegistry;
	}
	
	public OsmAndTaskManager getTaskManager() {
		return taskManager;
	}
	
	public AvoidSpecificRoads getAvoidSpecificRoads() {
		return avoidSpecificRoads;
	}

	public OsmAndLocationProvider getLocationProvider() {
		return locationProvider;
	}
	
	public OsmAndAppCustomization getAppCustomization() {
		return appCustomization;
	}
	
	
	public void setAppCustomization(OsmAndAppCustomization appCustomization) {
		this.appCustomization = appCustomization;
		this.appCustomization.setup(this);
	}

	/**
	 * Application settings
	 * 
	 * @return Reference to instance of OsmandSettings
	 */
	public OsmandSettings getSettings() {
		if (osmandSettings == null) {
			LOG.error("Trying to access settings before they were created");
		}
		return osmandSettings;
	}

	public SavingTrackHelper getSavingTrackHelper() {
		return savingTrackHelper;
	}
	
	public NotificationHelper getNotificationHelper() {
		return notificationHelper;
	}

	public LiveMonitoringHelper getLiveMonitoringHelper() {
		return liveMonitoringHelper;
	}

	public WaypointHelper getWaypointHelper() {
		return waypointHelper;
	}

	public PoiFiltersHelper getPoiFilters() {
		return poiFilters;
	}


	public GpxSelectionHelper getSelectedGpxHelper() {
		return selectedGpxHelper;
	}

	public FavouritesDbHelper getFavorites() {
		return favorites;
	}

	public ResourceManager getResourceManager() {
		return resourceManager;
	}

	public DayNightHelper getDaynightHelper() {
		return daynightHelper;
	}
	
	public synchronized DownloadIndexesThread getDownloadThread() {
		if(downloadIndexesThread == null) {
			downloadIndexesThread = new DownloadIndexesThread(this);
		}
		return downloadIndexesThread;
	}

	@Override
	public void onLowMemory() {
		super.onLowMemory();
		resourceManager.onLowMemory();
	}

	@Override
	public void onConfigurationChanged(Configuration newConfig) {
		if (preferredLocale != null && !newConfig.locale.getLanguage().equals(preferredLocale.getLanguage())) {
			super.onConfigurationChanged(newConfig);
			// ugly fix ! On devices after 4.0 screen is blinking when you rotate device!
			if (Build.VERSION.SDK_INT < 14) {
				newConfig.locale = preferredLocale;
			}
			getBaseContext().getResources().updateConfiguration(newConfig, getBaseContext().getResources().getDisplayMetrics());
			Locale.setDefault(preferredLocale);
		} else {
			super.onConfigurationChanged(newConfig);
		}
	}

	public void checkPreferredLocale() {
		Configuration config = getBaseContext().getResources().getConfiguration();
		String lang = osmandSettings.PREFERRED_LOCALE.get();
		if(defaultLocale == null) {
			defaultLocale = Locale.getDefault();
		}
		if (!"".equals(lang) && !config.locale.getLanguage().equals(lang)) {
			preferredLocale = new Locale(lang);
			Locale.setDefault(preferredLocale);
			config.locale = preferredLocale;
			getBaseContext().getResources().updateConfiguration(config, getBaseContext().getResources().getDisplayMetrics());
		} else if("".equals(lang) && defaultLocale != null && Locale.getDefault() != defaultLocale) {
			Locale.setDefault(defaultLocale);
			config.locale = defaultLocale;
			preferredLocale = null;
			getBaseContext().getResources().updateConfiguration(config, getBaseContext().getResources().getDisplayMetrics());
		}
		
	}

	public static final int PROGRESS_DIALOG = 5;

	public void checkApplicationIsBeingInitialized(Activity activity, AppInitializeListener listener) {
		// start application if it was previously closed
		startApplication();
		if(listener != null) {
			appInitializer.addListener(listener);
		}
	}
	
	public void unsubscribeInitListener(AppInitializeListener listener) {
		if(listener != null) {
			appInitializer.removeListener(listener);
		}		
	}
	
	public boolean isApplicationInitializing() {
		return appInitializer.isAppInitializing();
	}

	public RoutingHelper getRoutingHelper() {
		return routingHelper;
	}

	public CommandPlayer getPlayer() {
		return player;
	}

	public void initVoiceCommandPlayer(final Activity uiContext) {
		showDialogInitializingCommandPlayer(uiContext, true, null, false);
	}

	public void showDialogInitializingCommandPlayer(final Activity uiContext, boolean warningNoneProvider) {
		showDialogInitializingCommandPlayer(uiContext, warningNoneProvider, null, true);
	}

	public void showDialogInitializingCommandPlayer(final Activity uiContext, boolean warningNoneProvider, Runnable run, boolean showDialog) {
		String voiceProvider = osmandSettings.VOICE_PROVIDER.get();
		if (voiceProvider == null || OsmandSettings.VOICE_PROVIDER_NOT_USE.equals(voiceProvider)) {
			if (warningNoneProvider && voiceProvider == null) {
				AlertDialog.Builder builder = new AccessibleAlertBuilder(uiContext);
				LinearLayout ll = new LinearLayout(uiContext);
				ll.setOrientation(LinearLayout.VERTICAL);
				final TextView tv = new TextView(uiContext);
				tv.setPadding(7, 3, 7, 0);
				tv.setText(R.string.voice_is_not_available_msg);
				tv.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 19);
				ll.addView(tv);
				
				final CheckBox cb = new CheckBox(uiContext);
				cb.setText(R.string.shared_string_remember_my_choice);
				LinearLayout.LayoutParams lp = new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);
				lp.setMargins(7, 10, 7, 0);
				cb.setLayoutParams(lp);
				ll.addView(cb);
				
				builder.setCancelable(true);
				builder.setNegativeButton(R.string.shared_string_cancel, new DialogInterface.OnClickListener() {
					@Override
					public void onClick(DialogInterface dialog, int which) {
						if(cb.isChecked()) {
							osmandSettings.VOICE_PROVIDER.set(OsmandSettings.VOICE_PROVIDER_NOT_USE);
						}
					}
				});
				builder.setPositiveButton(R.string.shared_string_ok, new DialogInterface.OnClickListener() {
					@Override
					public void onClick(DialogInterface dialog, int which) {
						Intent intent = new Intent(uiContext, SettingsActivity.class);
						intent.putExtra(SettingsActivity.INTENT_KEY_SETTINGS_SCREEN, SettingsActivity.SCREEN_GENERAL_SETTINGS);
						uiContext.startActivity(intent);
					}
				});
				
				
				builder.setTitle(R.string.voice_is_not_available_title);
				builder.setView(ll);
				//builder.setMessage(R.string.voice_is_not_available_msg);
				builder.show();
			}

		} else {
			if (player == null || !Algorithms.objectEquals(voiceProvider, player.getCurrentVoice())) {
				appInitializer.	initVoiceDataInDifferentThread(uiContext, voiceProvider, run, showDialog);
			}
		}

	}

	public NavigationService getNavigationService() {
		return navigationService;
	}

	public void setNavigationService(NavigationService navigationService) {
		this.navigationService = navigationService;
	}


	private void fullExit() {
		// http://stackoverflow.com/questions/2092951/how-to-close-android-application
		System.runFinalizersOnExit(true);
		System.exit(0);
	}

	public synchronized void closeApplication(final Activity activity) {
		if (getNavigationService() != null) {
			AlertDialog.Builder bld = new AlertDialog.Builder(activity);
			bld.setMessage(R.string.background_service_is_enabled_question);
			bld.setPositiveButton(R.string.shared_string_yes, new DialogInterface.OnClickListener() {
				@Override
				public void onClick(DialogInterface dialog, int which) {
					closeApplicationAnywayImpl(activity, true);
				}
			});
			bld.setNegativeButton(R.string.shared_string_no, new DialogInterface.OnClickListener() {
				@Override
				public void onClick(DialogInterface dialog, int which) {
					closeApplicationAnywayImpl(activity, false);
				}
			});
			bld.show();
		} else {
			closeApplicationAnywayImpl(activity, true);
		}
	}
	
	private void closeApplicationAnyway(final Activity activity, boolean disableService) {
		activity.finish();
		Intent newIntent = new Intent(activity, ExitActivity.class);
		newIntent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_NEW_TASK);
		newIntent.putExtra(ExitActivity.DISABLE_SERVICE, disableService);
		startActivity(newIntent);
	}

	public void closeApplicationAnywayImpl(final Activity activity, boolean disableService) {
		if (appInitializer.isAppInitializing()) {
			resourceManager.close();
		}
		activity.finish();
		if (getNavigationService() == null) {
			fullExit();
		} else if (disableService) {
			final Intent serviceIntent = new Intent(this, NavigationService.class);
			stopService(serviceIntent);

			new Thread(new Runnable() {
				public void run() {
					//wait until the service has fully stopped
					while (getNavigationService() != null) {
						try {
							Thread.sleep(100);
						}
							catch (InterruptedException e) {
						}
					}

					fullExit();
				}
			}).start();
		}
	}

	public void startApplication() {
		Thread.setDefaultUncaughtExceptionHandler(new DefaultExceptionHandler());
		appInitializer.startApplication();
	}

	private class DefaultExceptionHandler implements UncaughtExceptionHandler {

		private UncaughtExceptionHandler defaultHandler;
		private PendingIntent intent;

		public DefaultExceptionHandler() {
			defaultHandler = Thread.getDefaultUncaughtExceptionHandler();
			intent = PendingIntent.getActivity(OsmandApplication.this.getBaseContext(), 0,
					new Intent(OsmandApplication.this.getBaseContext(),
							getAppCustomization().getMapActivity()), 0);
		}

		@Override
		public void uncaughtException(final Thread thread, final Throwable ex) {
			File file = getAppPath(EXCEPTION_PATH);
			try {
				ByteArrayOutputStream out = new ByteArrayOutputStream();
				PrintStream printStream = new PrintStream(out);
				ex.printStackTrace(printStream);
				StringBuilder msg = new StringBuilder();
				msg.append("Version  " + Version.getFullVersion(OsmandApplication.this) + "\n"). //$NON-NLS-1$ 
						append(DateFormat.format("dd.MM.yyyy h:mm:ss", System.currentTimeMillis()));
				try {
					PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), 0);
					if (info != null) {
						msg.append("\nApk Version : ").append(info.versionName).append(" ").append(info.versionCode); //$NON-NLS-1$ //$NON-NLS-2$
					}
				} catch (Throwable e) {
				}
				msg.append("\n"). //$NON-NLS-1$//$NON-NLS-2$
						append("Exception occured in thread " + thread.toString() + " : \n"). //$NON-NLS-1$ //$NON-NLS-2$
						append(new String(out.toByteArray()));

				if (file.getParentFile().canWrite()) {
					BufferedWriter writer = new BufferedWriter(new FileWriter(file, true));
					writer.write(msg.toString());
					writer.close();
				}
				if (routingHelper.isFollowingMode()) {
					AlarmManager mgr = (AlarmManager) getSystemService(Context.ALARM_SERVICE);
					mgr.set(AlarmManager.RTC, System.currentTimeMillis() + 2000, intent);
					System.exit(2);
				}
				defaultHandler.uncaughtException(thread, ex);
			} catch (Exception e) {
				// swallow all exceptions
				android.util.Log.e(PlatformUtil.TAG, "Exception while handle other exception", e); //$NON-NLS-1$
			}

		}
	}

	
	public TargetPointsHelper getTargetPointsHelper() {
		return targetPointsHelper;
	}

	public void showShortToastMessage(final int msgId, final Object... args) {
		uiHandler.post(new Runnable() {
			@Override
			public void run() {
				AccessibleToast.makeText(OsmandApplication.this, getString(msgId, args), Toast.LENGTH_SHORT).show();
			}
		});
	}

	public void showShortToastMessage(final String msg) {
		uiHandler.post(new Runnable() {
			@Override
			public void run() {
				AccessibleToast.makeText(OsmandApplication.this, msg, Toast.LENGTH_SHORT).show();
			}
		});
	}

	public void showToastMessage(final int msgId, final Object... args) {
		uiHandler.post(new Runnable() {
			@Override
			public void run() {
				AccessibleToast.makeText(OsmandApplication.this, getString(msgId, args), Toast.LENGTH_LONG).show();
			}
		});
	}

	public void showToastMessage(final String msg) {
		uiHandler.post(new Runnable() {
			@Override
			public void run() {
				AccessibleToast.makeText(OsmandApplication.this, msg, Toast.LENGTH_LONG).show();				
			}
		});
	}

	public SQLiteAPI getSQLiteAPI() {
		return sqliteAPI;
	}

	public void runInUIThread(Runnable run) {
		uiHandler.post(run);
	}

	public void runInUIThread(Runnable run, long delay) {
		uiHandler.postDelayed(run, delay);
	}
	
	public void runMessageInUIThreadAndCancelPrevious(final int messageId, final Runnable run, long delay) {
		Message msg = Message.obtain(uiHandler, new Runnable() {
			
			@Override
			public void run() {
				if(!uiHandler.hasMessages(messageId)) {
					run.run();
				}
			}
		});
		msg.what = messageId;
		uiHandler.removeMessages(messageId);
		uiHandler.sendMessageDelayed(msg, delay);
	}
	
	public File getAppPath(String path) {
		if(path == null) {
			path = "";
		}
		return new File(externalStorageDirectory, path);
	}
	
	public void setExternalStorageDirectory(int type, String directory){
		osmandSettings.setExternalStorageDirectory(type, directory);
		externalStorageDirectory = osmandSettings.getExternalStorageDirectory();
		getResourceManager().resetStoreDirectory();
	}

	public void applyTheme(Context c) {
		int t = R.style.OsmandDarkTheme;
		if (osmandSettings.OSMAND_THEME.get() == OsmandSettings.OSMAND_DARK_THEME) {
			t = R.style.OsmandDarkTheme;
		} else if (osmandSettings.OSMAND_THEME.get() == OsmandSettings.OSMAND_LIGHT_THEME) {
			t = R.style.OsmandLightTheme;
		}
		setLanguage(c);
		c.setTheme(t);
	}
	
	public IBRouterService getBRouterService() {
		if(bRouterServiceConnection == null) {
			return null;
		}
		return bRouterServiceConnection.getBrouterService();
	}
	
	public void setLanguage(Context context) {
		if (preferredLocale != null) {
			Configuration config = context.getResources().getConfiguration();
			String lang = preferredLocale.getLanguage();
			if (!"".equals(lang) && !config.locale.getLanguage().equals(lang)) {
				preferredLocale = new Locale(lang);
				Locale.setDefault(preferredLocale);
				config.locale = preferredLocale;
				context.getResources().updateConfiguration(config, context.getResources().getDisplayMetrics());
			} else if("".equals(lang) && defaultLocale != null && Locale.getDefault() != defaultLocale) {
				Locale.setDefault(defaultLocale);
				config.locale = defaultLocale;
				getBaseContext().getResources().updateConfiguration(config, getBaseContext().getResources().getDisplayMetrics());
			}
		}
	}
	
	public String getLanguage() {
		String lang = "";
		if (preferredLocale != null) {
			lang = preferredLocale.getLanguage();
		} else {
			lang = Locale.getDefault().getLanguage();
		}
		if (lang != null && lang.length() > 2) {
			lang = lang.substring(0, 2).toLowerCase();
		}
		return lang;
	}
	
	public RoutingConfiguration.Builder getDefaultRoutingConfig() {
		if(defaultRoutingConfig == null) {
			defaultRoutingConfig = appInitializer.getLazyDefaultRoutingConfig();
		}
		return defaultRoutingConfig;
	}
	
	public OsmandRegions getRegions() {
		return regions;
	}

	public boolean accessibilityExtensions() {
		return (Build.VERSION.SDK_INT < 14) ? getSettings().ACCESSIBILITY_EXTENSIONS.get() : false;
	}
	
	public boolean accessibilityEnabled() {
		final AccessibilityMode mode = getSettings().ACCESSIBILITY_MODE.get();
		if(OsmandPlugin.getEnabledPlugin(AccessibilityPlugin.class) == null) {
			return false;
		}
		if (mode == AccessibilityMode.ON) {
			return true;
		} else if (mode == AccessibilityMode.OFF) {
			return false;
		}
		return ((AccessibilityManager) getSystemService(Context.ACCESSIBILITY_SERVICE)).isEnabled();
	}

	public String getVersionName() {
		try {
			PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), 0);
			return info.versionName;
		} catch (NameNotFoundException e) {
			return "";
		}
	}

	public int getVersionCode() {
		try {
			PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), 0);
			return info.versionCode;
		} catch (NameNotFoundException e) {
			return 0;
		}
	}
	

	public void startNavigationService(int intent) {
		final Intent serviceIntent = new Intent(this, NavigationService.class);
		serviceIntent.putExtra(NavigationService.USAGE_INTENT, intent);
		if (getNavigationService() == null) {
			if (intent != NavigationService.USED_BY_GPX) {
				//for only-USED_BY_GPX case use pre-configured SERVICE_OFF_INTERVAL
				//other cases always use "continuous":
				getSettings().SERVICE_OFF_INTERVAL.set(0);
			}
			startService(serviceIntent);
		} else {
			//additional cases always use "continuous"
			//TODO: fallback to custom USED_BY_GPX interval in case all other sleep mode purposes have been stopped
			getSettings().SERVICE_OFF_INTERVAL.set(0);
			getNavigationService().addUsageIntent(intent);
			getNotificationHelper().showNotification();
		}	
	}


	public String getLangTranslation(String l) {
		try {
			java.lang.reflect.Field f = R.string.class.getField("lang_"+l);
			if (f != null) {
				Integer in = (Integer) f.get(null);
				return getString(in);
			}
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return l;
	}
}
!@#$%
20190530_035435,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_c04792
package net.osmand.plus;

import android.app.Activity;
import android.app.AlarmManager;
import android.app.PendingIntent;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager.NameNotFoundException;
import android.content.res.Configuration;
import android.os.AsyncTask;
import android.os.Build;
import android.os.Handler;
import android.os.Message;
import android.support.multidex.MultiDexApplication;
import android.support.v7.app.AlertDialog;
import android.text.format.DateFormat;
import android.util.TypedValue;
import android.view.View;
import android.view.accessibility.AccessibilityManager;
import android.widget.CheckBox;
import android.widget.LinearLayout;
import android.widget.LinearLayout.LayoutParams;
import android.widget.TextView;
import android.widget.Toast;

import net.osmand.PlatformUtil;
import net.osmand.access.AccessibilityPlugin;
import net.osmand.access.AccessibleAlertBuilder;
import net.osmand.access.AccessibleToast;
import net.osmand.map.OsmandRegions;
import net.osmand.osm.MapPoiTypes;
import net.osmand.plus.AppInitializer.AppInitializeListener;
import net.osmand.plus.access.AccessibilityMode;
import net.osmand.plus.activities.DayNightHelper;
import net.osmand.plus.activities.ExitActivity;
import net.osmand.plus.activities.SavingTrackHelper;
import net.osmand.plus.activities.SettingsActivity;
import net.osmand.plus.api.SQLiteAPI;
import net.osmand.plus.api.SQLiteAPIImpl;
import net.osmand.plus.dialogs.RateUsBottomSheetDialog;
import net.osmand.plus.download.DownloadIndexesThread;
import net.osmand.plus.helpers.AvoidSpecificRoads;
import net.osmand.plus.helpers.WaypointHelper;
import net.osmand.plus.monitoring.LiveMonitoringHelper;
import net.osmand.plus.poi.PoiFiltersHelper;
import net.osmand.plus.render.RendererRegistry;
import net.osmand.plus.resources.ResourceManager;
import net.osmand.plus.routing.RoutingHelper;
import net.osmand.plus.voice.CommandPlayer;
import net.osmand.router.RoutingConfiguration;
import net.osmand.util.Algorithms;

import java.io.BufferedWriter;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileWriter;
import java.io.PrintStream;
import java.lang.Thread.UncaughtExceptionHandler;
import java.util.Locale;

import btools.routingapp.BRouterServiceConnection;
import btools.routingapp.IBRouterService;

public class OsmandApplication extends MultiDexApplication {
	public static final String EXCEPTION_PATH = "exception.log"; //$NON-NLS-1$
	private static final org.apache.commons.logging.Log LOG = PlatformUtil.getLog(OsmandApplication.class);

	final AppInitializer appInitializer = new AppInitializer(this);
	OsmandSettings osmandSettings = null;
	OsmAndAppCustomization appCustomization;
	private final SQLiteAPI sqliteAPI = new SQLiteAPIImpl(this);
	private final OsmAndTaskManager taskManager = new OsmAndTaskManager(this);
	private final IconsCache iconsCache = new IconsCache(this);
	Handler uiHandler;

	NavigationService navigationService;
	
	// start variables
	ResourceManager resourceManager;
	OsmAndLocationProvider locationProvider;
	RendererRegistry rendererRegistry;
	DayNightHelper daynightHelper;
	PoiFiltersHelper poiFilters;
	MapPoiTypes poiTypes;
	RoutingHelper routingHelper;
	FavouritesDbHelper favorites;
	CommandPlayer player;
	GpxSelectionHelper selectedGpxHelper;
	SavingTrackHelper savingTrackHelper;
	NotificationHelper notificationHelper;
	LiveMonitoringHelper liveMonitoringHelper;
	TargetPointsHelper targetPointsHelper;
	WaypointHelper waypointHelper;
	DownloadIndexesThread downloadIndexesThread;
	AvoidSpecificRoads avoidSpecificRoads;
	BRouterServiceConnection bRouterServiceConnection;
	OsmandRegions regions;


	RoutingConfiguration.Builder defaultRoutingConfig;
	private Locale preferredLocale = null;
	private Locale defaultLocale;
	private File externalStorageDirectory;
	
	
	// Typeface
	
	@Override
	public void onCreate() {
		long timeToStart = System.currentTimeMillis();
		if (Version.getAppName(this).equals("OsmAnd~")) {
			if (android.os.Build.VERSION.SDK_INT >= 9) {
				try {
					Class.forName("net.osmand.plus.base.EnableStrictMode").newInstance();
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		}
		super.onCreate();
		createInUiThread();
		uiHandler = new Handler();
		appCustomization = new OsmAndAppCustomization();
		appCustomization.setup(this);
		osmandSettings = appCustomization.getOsmandSettings();
		externalStorageDirectory = osmandSettings.getExternalStorageDirectory();
		
		checkPreferredLocale();
		appInitializer.onCreateApplication();
//		if(!osmandSettings.FOLLOW_THE_ROUTE.get()) {
//			targetPointsHelper.clearPointToNavigate(false);
//		}
		startApplication();
		System.out.println("Time to start application " + (System.currentTimeMillis() - timeToStart) + " ms. Should be less < 800 ms");
		timeToStart = System.currentTimeMillis();
		OsmandPlugin.initPlugins(this);
		System.out.println("Time to init plugins " + (System.currentTimeMillis() - timeToStart) + " ms. Should be less < 800 ms");
	}
	
	public AppInitializer getAppInitializer() {
		return appInitializer;
	}
	
	public MapPoiTypes getPoiTypes() {
		return poiTypes;
	}

	private void createInUiThread() {
		new Toast(this); // activate in UI thread to avoid further exceptions
		new AsyncTask<View, Void, Void>() {
			@Override
			protected Void doInBackground(View... params) {
				return null;
			}

			protected void onPostExecute(Void result) {
			}
		}.execute();
	}
	
	public IconsCache getIconsCache() {
		return iconsCache;
	}
	
	@Override
	public void onTerminate() {
		super.onTerminate();
		if (routingHelper != null) {
			routingHelper.getVoiceRouter().onApplicationTerminate();
		}
        if(RateUsBottomSheetDialog.shouldShow(osmandSettings)) {
            osmandSettings.RATE_US_STATE.set(RateUsBottomSheetDialog.RateUsState.IGNORED);
        }
        getNotificationHelper().removeServiceNotification();
	}

	public RendererRegistry getRendererRegistry() {
		return rendererRegistry;
	}
	
	public OsmAndTaskManager getTaskManager() {
		return taskManager;
	}
	
	public AvoidSpecificRoads getAvoidSpecificRoads() {
		return avoidSpecificRoads;
	}

	public OsmAndLocationProvider getLocationProvider() {
		return locationProvider;
	}
	
	public OsmAndAppCustomization getAppCustomization() {
		return appCustomization;
	}
	
	
	public void setAppCustomization(OsmAndAppCustomization appCustomization) {
		this.appCustomization = appCustomization;
		this.appCustomization.setup(this);
	}

	/**
	 * Application settings
	 * 
	 * @return Reference to instance of OsmandSettings
	 */
	public OsmandSettings getSettings() {
		if (osmandSettings == null) {
			LOG.error("Trying to access settings before they were created");
		}
		return osmandSettings;
	}

	public SavingTrackHelper getSavingTrackHelper() {
		return savingTrackHelper;
	}
	
	public NotificationHelper getNotificationHelper() {
		return notificationHelper;
	}

	public LiveMonitoringHelper getLiveMonitoringHelper() {
		return liveMonitoringHelper;
	}

	public WaypointHelper getWaypointHelper() {
		return waypointHelper;
	}

	public PoiFiltersHelper getPoiFilters() {
		return poiFilters;
	}


	public GpxSelectionHelper getSelectedGpxHelper() {
		return selectedGpxHelper;
	}

	public FavouritesDbHelper getFavorites() {
		return favorites;
	}

	public ResourceManager getResourceManager() {
		return resourceManager;
	}

	public DayNightHelper getDaynightHelper() {
		return daynightHelper;
	}
	
	public synchronized DownloadIndexesThread getDownloadThread() {
		if(downloadIndexesThread == null) {
			downloadIndexesThread = new DownloadIndexesThread(this);
		}
		return downloadIndexesThread;
	}

	@Override
	public void onLowMemory() {
		super.onLowMemory();
		resourceManager.onLowMemory();
	}

	@Override
	public void onConfigurationChanged(Configuration newConfig) {
		if (preferredLocale != null && !newConfig.locale.getLanguage().equals(preferredLocale.getLanguage())) {
			super.onConfigurationChanged(newConfig);
			// ugly fix ! On devices after 4.0 screen is blinking when you rotate device!
			if (Build.VERSION.SDK_INT < 14) {
				newConfig.locale = preferredLocale;
			}
			getBaseContext().getResources().updateConfiguration(newConfig, getBaseContext().getResources().getDisplayMetrics());
			Locale.setDefault(preferredLocale);
		} else {
			super.onConfigurationChanged(newConfig);
		}
	}

	public void checkPreferredLocale() {
		Configuration config = getBaseContext().getResources().getConfiguration();
		String lang = osmandSettings.PREFERRED_LOCALE.get();
		if(defaultLocale == null) {
			defaultLocale = Locale.getDefault();
		}
		if (!"".equals(lang) && !config.locale.getLanguage().equals(lang)) {
			preferredLocale = new Locale(lang);
			Locale.setDefault(preferredLocale);
			config.locale = preferredLocale;
			getBaseContext().getResources().updateConfiguration(config, getBaseContext().getResources().getDisplayMetrics());
		} else if("".equals(lang) && defaultLocale != null && Locale.getDefault() != defaultLocale) {
			Locale.setDefault(defaultLocale);
			config.locale = defaultLocale;
			preferredLocale = null;
			getBaseContext().getResources().updateConfiguration(config, getBaseContext().getResources().getDisplayMetrics());
		}
		
	}

	public static final int PROGRESS_DIALOG = 5;

	public void checkApplicationIsBeingInitialized(Activity activity, AppInitializeListener listener) {
		// start application if it was previously closed
		startApplication();
		if(listener != null) {
			appInitializer.addListener(listener);
		}
	}
	
	public void unsubscribeInitListener(AppInitializeListener listener) {
		if(listener != null) {
			appInitializer.removeListener(listener);
		}		
	}
	
	public boolean isApplicationInitializing() {
		return appInitializer.isAppInitializing();
	}

	public RoutingHelper getRoutingHelper() {
		return routingHelper;
	}

	public CommandPlayer getPlayer() {
		return player;
	}

	public void initVoiceCommandPlayer(final Activity uiContext) {
		showDialogInitializingCommandPlayer(uiContext, true, null, false);
	}

	public void showDialogInitializingCommandPlayer(final Activity uiContext, boolean warningNoneProvider) {
		showDialogInitializingCommandPlayer(uiContext, warningNoneProvider, null, true);
	}

	public void showDialogInitializingCommandPlayer(final Activity uiContext, boolean warningNoneProvider, Runnable run, boolean showDialog) {
		String voiceProvider = osmandSettings.VOICE_PROVIDER.get();
		if (voiceProvider == null || OsmandSettings.VOICE_PROVIDER_NOT_USE.equals(voiceProvider)) {
			if (warningNoneProvider && voiceProvider == null) {
				AlertDialog.Builder builder = new AccessibleAlertBuilder(uiContext);
				LinearLayout ll = new LinearLayout(uiContext);
				ll.setOrientation(LinearLayout.VERTICAL);
				final TextView tv = new TextView(uiContext);
				tv.setPadding(7, 3, 7, 0);
				tv.setText(R.string.voice_is_not_available_msg);
				tv.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 19);
				ll.addView(tv);
				
				final CheckBox cb = new CheckBox(uiContext);
				cb.setText(R.string.shared_string_remember_my_choice);
				LinearLayout.LayoutParams lp = new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);
				lp.setMargins(7, 10, 7, 0);
				cb.setLayoutParams(lp);
				ll.addView(cb);
				
				builder.setCancelable(true);
				builder.setNegativeButton(R.string.shared_string_cancel, new DialogInterface.OnClickListener() {
					@Override
					public void onClick(DialogInterface dialog, int which) {
						if(cb.isChecked()) {
							osmandSettings.VOICE_PROVIDER.set(OsmandSettings.VOICE_PROVIDER_NOT_USE);
						}
					}
				});
				builder.setPositiveButton(R.string.shared_string_ok, new DialogInterface.OnClickListener() {
					@Override
					public void onClick(DialogInterface dialog, int which) {
						Intent intent = new Intent(uiContext, SettingsActivity.class);
						intent.putExtra(SettingsActivity.INTENT_KEY_SETTINGS_SCREEN, SettingsActivity.SCREEN_GENERAL_SETTINGS);
						uiContext.startActivity(intent);
					}
				});
				
				
				builder.setTitle(R.string.voice_is_not_available_title);
				builder.setView(ll);
				//builder.setMessage(R.string.voice_is_not_available_msg);
				builder.show();
			}

		} else {
			if (player == null || !Algorithms.objectEquals(voiceProvider, player.getCurrentVoice())) {
				appInitializer.	initVoiceDataInDifferentThread(uiContext, voiceProvider, run, showDialog);
			}
		}

	}

	public NavigationService getNavigationService() {
		return navigationService;
	}

	public void setNavigationService(NavigationService navigationService) {
		this.navigationService = navigationService;
	}


	private void fullExit() {
		// http://stackoverflow.com/questions/2092951/how-to-close-android-application
		System.runFinalizersOnExit(true);
		System.exit(0);
	}

	public synchronized void closeApplication(final Activity activity) {
		if (getNavigationService() != null) {
			AlertDialog.Builder bld = new AlertDialog.Builder(activity);
			bld.setMessage(R.string.background_service_is_enabled_question);
			bld.setPositiveButton(R.string.shared_string_yes, new DialogInterface.OnClickListener() {
				@Override
				public void onClick(DialogInterface dialog, int which) {
					closeApplicationAnywayImpl(activity, true);
				}
			});
			bld.setNegativeButton(R.string.shared_string_no, new DialogInterface.OnClickListener() {
				@Override
				public void onClick(DialogInterface dialog, int which) {
					closeApplicationAnywayImpl(activity, false);
				}
			});
			bld.show();
		} else {
			closeApplicationAnywayImpl(activity, true);
		}
	}
	
	private void closeApplicationAnyway(final Activity activity, boolean disableService) {
		activity.finish();
		Intent newIntent = new Intent(activity, ExitActivity.class);
		newIntent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_NEW_TASK);
		newIntent.putExtra(ExitActivity.DISABLE_SERVICE, disableService);
		startActivity(newIntent);
	}

	public void closeApplicationAnywayImpl(final Activity activity, boolean disableService) {
		if (appInitializer.isAppInitializing()) {
			resourceManager.close();
		}
		activity.finish();
		if (getNavigationService() == null) {
			fullExit();
		} else if (disableService) {
			final Intent serviceIntent = new Intent(this, NavigationService.class);
			stopService(serviceIntent);

			new Thread(new Runnable() {
				public void run() {
					//wait until the service has fully stopped
					while (getNavigationService() != null) {
						try {
							Thread.sleep(100);
						}
							catch (InterruptedException e) {
						}
					}

					fullExit();
				}
			}).start();
		}
	}

	public void startApplication() {
		Thread.setDefaultUncaughtExceptionHandler(new DefaultExceptionHandler());
		appInitializer.startApplication();
	}

	private class DefaultExceptionHandler implements UncaughtExceptionHandler {

		private UncaughtExceptionHandler defaultHandler;
		private PendingIntent intent;

		public DefaultExceptionHandler() {
			defaultHandler = Thread.getDefaultUncaughtExceptionHandler();
			intent = PendingIntent.getActivity(OsmandApplication.this.getBaseContext(), 0,
					new Intent(OsmandApplication.this.getBaseContext(),
							getAppCustomization().getMapActivity()), 0);
		}

		@Override
		public void uncaughtException(final Thread thread, final Throwable ex) {
			File file = getAppPath(EXCEPTION_PATH);
			try {
				ByteArrayOutputStream out = new ByteArrayOutputStream();
				PrintStream printStream = new PrintStream(out);
				ex.printStackTrace(printStream);
				StringBuilder msg = new StringBuilder();
				msg.append("Version  " + Version.getFullVersion(OsmandApplication.this) + "\n"). //$NON-NLS-1$ 
						append(DateFormat.format("dd.MM.yyyy h:mm:ss", System.currentTimeMillis()));
				try {
					PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), 0);
					if (info != null) {
						msg.append("\nApk Version : ").append(info.versionName).append(" ").append(info.versionCode); //$NON-NLS-1$ //$NON-NLS-2$
					}
				} catch (Throwable e) {
				}
				msg.append("\n"). //$NON-NLS-1$//$NON-NLS-2$
						append("Exception occured in thread " + thread.toString() + " : \n"). //$NON-NLS-1$ //$NON-NLS-2$
						append(new String(out.toByteArray()));

				if (file.getParentFile().canWrite()) {
					BufferedWriter writer = new BufferedWriter(new FileWriter(file, true));
					writer.write(msg.toString());
					writer.close();
				}
				if (routingHelper.isFollowingMode()) {
					AlarmManager mgr = (AlarmManager) getSystemService(Context.ALARM_SERVICE);
					mgr.set(AlarmManager.RTC, System.currentTimeMillis() + 2000, intent);
					System.exit(2);
				}
				defaultHandler.uncaughtException(thread, ex);
			} catch (Exception e) {
				// swallow all exceptions
				android.util.Log.e(PlatformUtil.TAG, "Exception while handle other exception", e); //$NON-NLS-1$
			}

		}
	}

	
	public TargetPointsHelper getTargetPointsHelper() {
		return targetPointsHelper;
	}

	public void showShortToastMessage(final int msgId, final Object... args) {
		uiHandler.post(new Runnable() {
			@Override
			public void run() {
				AccessibleToast.makeText(OsmandApplication.this, getString(msgId, args), Toast.LENGTH_SHORT).show();
			}
		});
	}

	public void showShortToastMessage(final String msg) {
		uiHandler.post(new Runnable() {
			@Override
			public void run() {
				AccessibleToast.makeText(OsmandApplication.this, msg, Toast.LENGTH_SHORT).show();
			}
		});
	}

	public void showToastMessage(final int msgId, final Object... args) {
		uiHandler.post(new Runnable() {
			@Override
			public void run() {
				AccessibleToast.makeText(OsmandApplication.this, getString(msgId, args), Toast.LENGTH_LONG).show();
			}
		});
	}

	public void showToastMessage(final String msg) {
		uiHandler.post(new Runnable() {
			@Override
			public void run() {
				AccessibleToast.makeText(OsmandApplication.this, msg, Toast.LENGTH_LONG).show();				
			}
		});
	}

	public SQLiteAPI getSQLiteAPI() {
		return sqliteAPI;
	}

	public void runInUIThread(Runnable run) {
		uiHandler.post(run);
	}

	public void runInUIThread(Runnable run, long delay) {
		uiHandler.postDelayed(run, delay);
	}
	
	public void runMessageInUIThreadAndCancelPrevious(final int messageId, final Runnable run, long delay) {
		Message msg = Message.obtain(uiHandler, new Runnable() {
			
			@Override
			public void run() {
				if(!uiHandler.hasMessages(messageId)) {
					run.run();
				}
			}
		});
		msg.what = messageId;
		uiHandler.removeMessages(messageId);
		uiHandler.sendMessageDelayed(msg, delay);
	}
	
	public File getAppPath(String path) {
		if(path == null) {
			path = "";
		}
		return new File(externalStorageDirectory, path);
	}
	
	public void setExternalStorageDirectory(int type, String directory){
		osmandSettings.setExternalStorageDirectory(type, directory);
		externalStorageDirectory = osmandSettings.getExternalStorageDirectory();
		getResourceManager().resetStoreDirectory();
	}

	public void applyTheme(Context c) {
		int t = R.style.OsmandDarkTheme;
		if (osmandSettings.OSMAND_THEME.get() == OsmandSettings.OSMAND_DARK_THEME) {
			t = R.style.OsmandDarkTheme;
		} else if (osmandSettings.OSMAND_THEME.get() == OsmandSettings.OSMAND_LIGHT_THEME) {
			t = R.style.OsmandLightTheme;
		}
		setLanguage(c);
		c.setTheme(t);
	}
	
	public IBRouterService getBRouterService() {
		if(bRouterServiceConnection == null) {
			return null;
		}
		return bRouterServiceConnection.getBrouterService();
	}
	
	public void setLanguage(Context context) {
		if (preferredLocale != null) {
			Configuration config = context.getResources().getConfiguration();
			String lang = preferredLocale.getLanguage();
			if (!"".equals(lang) && !config.locale.getLanguage().equals(lang)) {
				preferredLocale = new Locale(lang);
				Locale.setDefault(preferredLocale);
				config.locale = preferredLocale;
				context.getResources().updateConfiguration(config, context.getResources().getDisplayMetrics());
			} else if("".equals(lang) && defaultLocale != null && Locale.getDefault() != defaultLocale) {
				Locale.setDefault(defaultLocale);
				config.locale = defaultLocale;
				getBaseContext().getResources().updateConfiguration(config, getBaseContext().getResources().getDisplayMetrics());
			}
		}
	}
	
	public String getLanguage() {
		String lang = "";
		if (preferredLocale != null) {
			lang = preferredLocale.getLanguage();
		} else {
			lang = Locale.getDefault().getLanguage();
		}
		if (lang != null && lang.length() > 2) {
			lang = lang.substring(0, 2).toLowerCase();
		}
		return lang;
	}
	
	public RoutingConfiguration.Builder getDefaultRoutingConfig() {
		if(defaultRoutingConfig == null) {
			defaultRoutingConfig = appInitializer.getLazyDefaultRoutingConfig();
		}
		return defaultRoutingConfig;
	}
	
	public OsmandRegions getRegions() {
		return regions;
	}

	public boolean accessibilityExtensions() {
		return (Build.VERSION.SDK_INT < 14) ? getSettings().ACCESSIBILITY_EXTENSIONS.get() : false;
	}
	
	public boolean accessibilityEnabled() {
		final AccessibilityMode mode = getSettings().ACCESSIBILITY_MODE.get();
		if(OsmandPlugin.getEnabledPlugin(AccessibilityPlugin.class) == null) {
			return false;
		}
		if (mode == AccessibilityMode.ON) {
			return true;
		} else if (mode == AccessibilityMode.OFF) {
			return false;
		}
		return ((AccessibilityManager) getSystemService(Context.ACCESSIBILITY_SERVICE)).isEnabled();
	}

	public String getVersionName() {
		try {
			PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), 0);
			return info.versionName;
		} catch (NameNotFoundException e) {
			return "";
		}
	}

	public int getVersionCode() {
		try {
			PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), 0);
			return info.versionCode;
		} catch (NameNotFoundException e) {
			return 0;
		}
	}
	

	public void startNavigationService(int intent) {
		final Intent serviceIntent = new Intent(this, NavigationService.class);
		serviceIntent.putExtra(NavigationService.USAGE_INTENT, intent);
		if (getNavigationService() == null) {
			if (intent != NavigationService.USED_BY_GPX) {
				//for only-USED_BY_GPX case use pre-configured SERVICE_OFF_INTERVAL
				//other cases always use "continuous":
				getSettings().SERVICE_OFF_INTERVAL.set(0);
			}
			startService(serviceIntent);
		} else {
			//additional cases always use "continuous"
			//TODO: fallback to custom USED_BY_GPX interval in case all other sleep mode purposes have been stopped
			getSettings().SERVICE_OFF_INTERVAL.set(0);
			getNavigationService().addUsageIntent(intent);
			getNotificationHelper().showNotification();
		}	
	}


	public String getLangTranslation(String l) {
		try {
			java.lang.reflect.Field f = R.string.class.getField("lang_"+l);
			if (f != null) {
				Integer in = (Integer) f.get(null);
				return getString(in);
			}
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return l;
	}
}
!@#$%
20190530_035734,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_b08896
package net.osmand.plus.osmedit;
import android.app.Activity;
import android.app.Dialog;
import android.app.ProgressDialog;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.res.Resources;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Build;
import android.os.Bundle;
import android.support.annotation.NonNull;
import android.support.design.widget.TabLayout;
import android.support.design.widget.TextInputLayout;
import android.support.v4.app.DialogFragment;
import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentManager;
import android.support.v4.app.FragmentPagerAdapter;
import android.support.v4.view.ViewCompat;
import android.support.v4.view.ViewPager;
import android.support.v7.app.AlertDialog;
import android.support.v7.app.AppCompatActivity;
import android.support.v7.widget.Toolbar;
import android.text.Editable;
import android.text.TextUtils;
import android.text.TextWatcher;
import android.util.TypedValue;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.view.WindowManager;
import android.view.inputmethod.EditorInfo;
import android.widget.AdapterView;
import android.widget.ArrayAdapter;
import android.widget.AutoCompleteTextView;
import android.widget.Button;
import android.widget.CheckBox;
import android.widget.EditText;
import android.widget.ImageButton;
import android.widget.LinearLayout;
import android.widget.TextView;
import android.widget.Toast;
import net.osmand.CallbackWithObject;
import net.osmand.PlatformUtil;
import net.osmand.access.AccessibleToast;
import net.osmand.data.Amenity;
import net.osmand.data.LatLon;
import net.osmand.osm.PoiCategory;
import net.osmand.osm.PoiType;
import net.osmand.osm.edit.EntityInfo;
import net.osmand.osm.edit.Node;
import net.osmand.osm.edit.OSMSettings;
import net.osmand.plus.OsmandApplication;
import net.osmand.plus.OsmandPlugin;
import net.osmand.plus.OsmandSettings;
import net.osmand.plus.R;
import net.osmand.plus.activities.MapActivity;
import net.osmand.plus.osmedit.dialogs.PoiSubTypeDialogFragment;
import net.osmand.plus.osmedit.dialogs.PoiTypeDialogFragment;
import net.osmand.util.Algorithms;

import org.apache.commons.logging.Log;

import java.io.Serializable;
import java.util.Comparator;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

public class EditPoiDialogFragment extends DialogFragment {
	public static final String TAG = "EditPoiDialogFragment";
	private static final Log LOG = PlatformUtil.getLog(EditPoiDialogFragment.class);

	private static final String KEY_AMENITY_NODE = "key_amenity_node";
	private static final String TAGS_LIST = "tags_list";
	private static final String IS_ADDING_POI = "is_adding_poi";

	private static final HashSet<String> BASIC_TAGS = new HashSet<String>() {
		{
			add(OSMSettings.OSMTagKey.NAME.getValue());
			add(OSMSettings.OSMTagKey.ADDR_STREET.getValue());
			add(OSMSettings.OSMTagKey.ADDR_HOUSE_NUMBER.getValue());
			add(OSMSettings.OSMTagKey.PHONE.getValue());
			add(OSMSettings.OSMTagKey.WEBSITE.getValue());
			add(OSMSettings.OSMTagKey.OPENING_HOURS.getValue());
		}
	};

	private EditPoiData editPoiData;
	private ViewPager viewPager;
	private AutoCompleteTextView poiTypeEditText;

	private OpenstreetmapUtil mOpenstreetmapUtil;
	private TextInputLayout poiTypeTextInputLayout;
	private View view;

	@Override
	public void onAttach(Activity activity) {
		super.onAttach(activity);
		OsmandSettings settings = getMyApplication().getSettings();
		OsmEditingPlugin plugin = OsmandPlugin.getPlugin(OsmEditingPlugin.class);
		if (settings.OFFLINE_EDITION.get() || !settings.isInternetConnectionAvailable(true)) {
			mOpenstreetmapUtil = plugin.getPoiModificationLocalUtil();
		} else {
			mOpenstreetmapUtil = plugin.getPoiModificationRemoteUtil();
		}

		Node node = (Node) getArguments().getSerializable(KEY_AMENITY_NODE);
		editPoiData = new EditPoiData(node, getMyApplication());
	}

	@Override
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		boolean isLightTheme = ((OsmandApplication) getActivity().getApplication())
				.getSettings().OSMAND_THEME.get() == OsmandSettings.OSMAND_LIGHT_THEME;
		int themeId = isLightTheme ? R.style.OsmandLightTheme : R.style.OsmandDarkTheme;
		setStyle(STYLE_NO_FRAME, themeId);
		getActivity().getWindow()
				.setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE);
	}

	@Override
	public View onCreateView(LayoutInflater inflater, ViewGroup container,
							 Bundle savedInstanceState) {
		view = inflater.inflate(R.layout.fragment_edit_poi, container, false);
		final OsmandSettings settings = getMyApplication().getSettings();
		boolean isLightTheme = settings.OSMAND_THEME.get() == OsmandSettings.OSMAND_LIGHT_THEME;

		if (savedInstanceState != null) {
			@SuppressWarnings("unchecked")
			Map<String, String> mp = (Map<String, String>) savedInstanceState.getSerializable(TAGS_LIST);
			editPoiData.updateTags(mp);
		}

		boolean isAddingPoi = getArguments().getBoolean(IS_ADDING_POI);

		Toolbar toolbar = (Toolbar) view.findViewById(R.id.toolbar);
		toolbar.setTitle(isAddingPoi ? R.string.poi_create_title : R.string.poi_edit_title);
		toolbar.setNavigationIcon(R.drawable.abc_ic_ab_back_mtrl_am_alpha);
		toolbar.setNavigationOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				dismissCheckForChanges();
			}
		});

		viewPager = (ViewPager) view.findViewById(R.id.viewpager);
		String basicTitle = getResources().getString(R.string.tab_title_basic);
		String extendedTitle = getResources().getString(R.string.tab_title_advanced);
		final MyAdapter pagerAdapter = new MyAdapter(getChildFragmentManager(), basicTitle, extendedTitle);
		viewPager.setAdapter(pagerAdapter);
		viewPager.addOnPageChangeListener(new ViewPager.OnPageChangeListener() {
			@Override
			public void onPageScrolled(int i, float v, int i1) {

			}

			@Override
			public void onPageSelected(int i) {
				((OnFragmentActivatedListener) pagerAdapter.getItem(i)).onFragmentActivated();
			}

			@Override
			public void onPageScrollStateChanged(int i) {

			}
		});

		final TabLayout tabLayout = (TabLayout) view.findViewById(R.id.tab_layout);
		tabLayout.setTabMode(TabLayout.MODE_SCROLLABLE);

		// Hack due to bug in design support library v22.2.1
		// https://code.google.com/p/android/issues/detail?id=180462
		// TODO remove in new version
		if (ViewCompat.isLaidOut(tabLayout)) {
			tabLayout.setupWithViewPager(viewPager);
		} else {
			tabLayout.addOnLayoutChangeListener(new View.OnLayoutChangeListener() {
				@Override
				public void onLayoutChange(View v, int left, int top, int right, int bottom,
										   int oldLeft, int oldTop, int oldRight, int oldBottom) {
					tabLayout.setupWithViewPager(viewPager);
					tabLayout.removeOnLayoutChangeListener(this);
				}
			});
		}

		ImageButton onlineDocumentationButton =
				(ImageButton) view.findViewById(R.id.onlineDocumentationButton);
		onlineDocumentationButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				getActivity().startActivity(new Intent(Intent.ACTION_VIEW,
						Uri.parse("https://wiki.openstreetmap.org/wiki/Map_Features")));
			}
		});

		final int colorId = isLightTheme ? R.color.inactive_item_orange : R.color.dash_search_icon_dark;
		final int color = getResources().getColor(colorId);
		onlineDocumentationButton.setImageDrawable(getMyApplication().getIconsCache()
				.getPaintedContentIcon(R.drawable.ic_action_help, color));
		final ImageButton poiTypeButton = (ImageButton) view.findViewById(R.id.poiTypeButton);
		poiTypeButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				DialogFragment fragment = PoiTypeDialogFragment.createInstance();
				fragment.show(getChildFragmentManager(), "PoiTypeDialogFragment");
			}
		});

		EditText poiNameEditText = (EditText) view.findViewById(R.id.poiNameEditText);
		poiNameEditText.addTextChangedListener(new TextWatcher() {
			@Override
			public void beforeTextChanged(CharSequence s, int start, int count, int after) {
			}

			@Override
			public void onTextChanged(CharSequence s, int start, int before, int count) {
			}

			@Override
			public void afterTextChanged(Editable s) {
				if (!getEditPoiData().isInEdit()) {
					if (!TextUtils.isEmpty(s)) {
						getEditPoiData().putTag(OSMSettings.OSMTagKey.NAME.getValue(),
								s.toString());
					} else {
						getEditPoiData().removeTag(OSMSettings.OSMTagKey.NAME.getValue());
					}
				}
			}
		});
		poiNameEditText.setText(editPoiData.getTag(OSMSettings.OSMTagKey.NAME.getValue()));
		poiTypeTextInputLayout = (TextInputLayout) view.findViewById(R.id.poiTypeTextInputLayout);
		poiTypeEditText = (AutoCompleteTextView) view.findViewById(R.id.poiTypeEditText);
		poiTypeEditText.addTextChangedListener(new TextWatcher() {
			@Override
			public void beforeTextChanged(CharSequence s, int start, int count, int after) {
			}

			@Override
			public void onTextChanged(CharSequence s, int start, int before, int count) {
			}

			@Override
			public void afterTextChanged(Editable s) {
				if (!getEditPoiData().isInEdit()) {
					getEditPoiData().updateTypeTag(s.toString());
					poiTypeTextInputLayout.setHint(editPoiData.getPoiCategory().getTranslation());
				}
			}
		});
		poiNameEditText.setOnEditorActionListener(mOnEditorActionListener);
		poiTypeEditText.setOnEditorActionListener(mOnEditorActionListener);
		poiTypeEditText.setText(editPoiData.getPoiTypeString());
		poiTypeEditText.setOnTouchListener(new View.OnTouchListener() {
			@Override
			public boolean onTouch(final View v, MotionEvent event) {
				final EditText editText = (EditText) v;
				final int DRAWABLE_RIGHT = 2;
				if (event.getAction() == MotionEvent.ACTION_UP) {
					if (event.getX() >= (editText.getRight()
							- editText.getCompoundDrawables()[DRAWABLE_RIGHT].getBounds().width()
							- editText.getPaddingRight())) {
						if (editPoiData.getPoiCategory() != null) {
							DialogFragment dialogFragment =
									PoiSubTypeDialogFragment.createInstance(editPoiData.getPoiCategory());
							dialogFragment.show(getChildFragmentManager(), "PoiSubTypeDialogFragment");
						}

						return true;
					}
				}
				return false;
			}
		});

		Button saveButton = (Button) view.findViewById(R.id.saveButton);
		saveButton.setText(mOpenstreetmapUtil instanceof OpenstreetmapRemoteUtil
				? R.string.shared_string_upload : R.string.shared_string_save);
		saveButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				trySave();
			}
		});
		Button cancelButton = (Button) view.findViewById(R.id.cancelButton);
		cancelButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				dismissCheckForChanges();
			}
		});
		setAdapterForPoiTypeEditText();
		setCancelable(false);
		return view;
	}

	@NonNull
	@Override
	public Dialog onCreateDialog(Bundle savedInstanceState) {
		final Dialog dialog = super.onCreateDialog(savedInstanceState);
		dialog.getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE);
		return dialog;
	}

	private void trySave() {
		if (TextUtils.isEmpty(poiTypeEditText.getText())) {
			HashSet<String> tagsCopy = new HashSet<>();
			tagsCopy.addAll(editPoiData.getTagValues().keySet());
			tagsCopy.removeAll(BASIC_TAGS);
			if (tagsCopy.isEmpty()) {
				poiTypeEditText.setError(getResources().getString(R.string.please_specify_poi_type));
			} else {
				new SaveWithAdvancedTagsDialogFragment().show(getChildFragmentManager(), "dialog");
			}
		} else if(editPoiData.getPoiCategory() == getMyApplication().getPoiTypes().getOtherPoiCategory()) {
			poiTypeEditText.setError(getResources().getString(R.string.please_specify_poi_type));
		} else if(editPoiData.getPoiTypeDefined() == null) {
			poiTypeEditText.setError(getResources().getString(R.string.please_specify_poi_type_only_from_list));
		} else {
			save();
		}
	}

	private void save() {
		Node original = editPoiData.getEntity();
		final boolean offlineEdit = mOpenstreetmapUtil instanceof OpenstreetmapLocalUtil;
		Node node = new Node(original.getLatitude(), original.getLongitude(), original.getId());
		OsmPoint.Action action = node.getId() < 0 ? OsmPoint.Action.CREATE : OsmPoint.Action.MODIFY;
		for (Map.Entry<String, String> tag : editPoiData.getTagValues().entrySet()) {
			if (tag.getKey().equals(EditPoiData.POI_TYPE_TAG)) {
				final PoiType poiType = editPoiData.getAllTranslatedSubTypes().get(tag.getValue().trim().toLowerCase());
				if (poiType != null) {
					node.putTag(poiType.getOsmTag(), poiType.getOsmValue());
					if (poiType.getOsmTag2() != null) {
						node.putTag(poiType.getOsmTag2(), poiType.getOsmValue2());
					}
				} else if (!Algorithms.isEmpty(tag.getValue())) {
					node.putTag(editPoiData.getPoiCategory().getDefaultTag(), tag.getValue());

				}
				if(offlineEdit && !Algorithms.isEmpty(tag.getValue())) {
					node.putTag(tag.getKey(), tag.getValue());
				}
			} else if (!Algorithms.isEmpty(tag.getKey()) && !Algorithms.isEmpty(tag.getValue())) {
				node.putTag(tag.getKey(), tag.getValue());
			}
		}
		commitNode(action, node, mOpenstreetmapUtil.getEntityInfo(node.getId()), "", false,
				new CallbackWithObject<Node>() {

					@Override
					public boolean processResult(Node result) {
						if (result != null) {
							OsmEditingPlugin plugin = OsmandPlugin.getPlugin(OsmEditingPlugin.class);
							if (plugin != null && offlineEdit) {
								List<OpenstreetmapPoint> points = plugin.getDBPOI().getOpenstreetmapPoints();
								if (getActivity() instanceof MapActivity && points.size() > 0) {
									OsmPoint point = points.get(points.size() - 1);
									MapActivity mapActivity = (MapActivity) getActivity();
									mapActivity.getContextMenu().showOrUpdate(
											new LatLon(point.getLatitude(), point.getLongitude()),
											plugin.getOsmEditsLayer(mapActivity).getObjectName(point), point);
								}
							}

							if (getActivity() instanceof MapActivity) {
								((MapActivity) getActivity()).getMapView().refreshMap(true);
							}
							dismiss();
						} else {
							OsmEditingPlugin plugin = OsmandPlugin.getPlugin(OsmEditingPlugin.class);
							mOpenstreetmapUtil = plugin.getPoiModificationLocalUtil();
							Button saveButton = (Button) view.findViewById(R.id.saveButton);
							saveButton.setText(mOpenstreetmapUtil instanceof OpenstreetmapRemoteUtil
									? R.string.shared_string_upload : R.string.shared_string_save);
						}

						return false;
					}
				}, getActivity(), mOpenstreetmapUtil);
	}

	@Override
	public void onResume() {
		super.onResume();
		getDialog().setOnKeyListener(new DialogInterface.OnKeyListener() {
			@Override
			public boolean onKey(DialogInterface dialog, int keyCode, KeyEvent event) {
				if (keyCode == android.view.KeyEvent.KEYCODE_BACK) {
					if (event.getAction() == KeyEvent.ACTION_DOWN) {
						return true;
					} else {
						dismissCheckForChanges();
						return true;
					}
				}
				return false;
			}
		});
	}

	private void dismissCheckForChanges() {
		if (editPoiData.hasChangesBeenMade()) {
			new AreYouSureDialogFragment().show(getChildFragmentManager(),
					"AreYouSureDialogFragment");
		} else {
			dismiss();
		}
	}

	@Override
	public void onSaveInstanceState(Bundle outState) {
		outState.putSerializable(TAGS_LIST, (Serializable) editPoiData.getTagValues());
		super.onSaveInstanceState(outState);
	}

	public EditPoiData getEditPoiData() {
		return editPoiData;
	}

	public void setSubCategory(String subCategory) {
		poiTypeEditText.setText(subCategory);
	}

	public static void commitNode(final OsmPoint.Action action,
								  final Node n,
								  final EntityInfo info,
								  final String comment,
								  final boolean closeChangeSet,
								  final CallbackWithObject<Node> postExecute,
								  final Activity activity,
								  final OpenstreetmapUtil openstreetmapUtil) {
		if (info == null && OsmPoint.Action.CREATE != action && openstreetmapUtil instanceof OpenstreetmapRemoteUtil) {
			AccessibleToast.makeText(activity, activity.getResources().getString(R.string.poi_error_info_not_loaded), Toast.LENGTH_LONG).show();
			return;
		}
		new AsyncTask<Void, Void, Node>() {
			ProgressDialog progress;

			@Override
			protected void onPreExecute() {
				progress = ProgressDialog.show(activity, activity.getString(R.string.uploading), activity.getString(R.string.uploading_data));
				super.onPreExecute();
			}

			@Override
			protected Node doInBackground(Void... params) {
				return openstreetmapUtil.commitNodeImpl(action, n, info, comment, closeChangeSet);
			}

			@Override
			protected void onPostExecute(Node result) {
				progress.dismiss();
				if(postExecute != null) {
					postExecute.processResult(result);
				}
			}
		}.execute();
	}

	public void setPoiCategory(PoiCategory type) {
		editPoiData.updateType(type);
		poiTypeEditText.setText(editPoiData.getPoiTypeString());
		setAdapterForPoiTypeEditText();
	}

	private void setAdapterForPoiTypeEditText() {
		final Map<String, PoiType> subCategories = new LinkedHashMap<>();
		PoiCategory ct = editPoiData.getPoiCategory();
		if(ct != null) {
			for (PoiType s : ct.getPoiTypes()) {
				if(!s.isReference() && !s.isNotEditableOsm() && s.getBaseLangType() == null) {
					addMapEntryAdapter(subCategories, s.getTranslation(), s);
					addMapEntryAdapter(subCategories, s.getKeyName().replace('_', ' '), s);
				}
			}
		}
		for (Map.Entry<String, PoiType> s : editPoiData.getAllTranslatedSubTypes().entrySet()) {
			addMapEntryAdapter(subCategories, s.getKey(), s.getValue());
		}
		final ArrayAdapter<Object> adapter;
		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
			adapter = new ArrayAdapter<>(getActivity(),
					R.layout.list_textview, subCategories.keySet().toArray());
		} else {
			TypedValue typedValue = new TypedValue();
			Resources.Theme theme = getActivity().getTheme();
			theme.resolveAttribute(android.R.attr.textColorSecondary, typedValue, true);
			final int textColor = typedValue.data;

			adapter = new ArrayAdapter<Object>(getActivity(),
					R.layout.list_textview, subCategories.keySet().toArray()) {
				@Override
				public View getView(int position, View convertView, ViewGroup parent) {
					final View view = super.getView(position, convertView, parent);
					((TextView) view.findViewById(R.id.textView)).setTextColor(textColor);
					return view;
				}
			};
		}
		adapter.sort(new Comparator<Object>() {
			@Override
			public int compare(Object lhs, Object rhs) {
				return lhs.toString().compareTo(rhs.toString());
			}
		});
		poiTypeEditText.setAdapter(adapter);
		poiTypeEditText.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {

			@Override
			public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
				Object item = parent.getAdapter().getItem(position);
				poiTypeEditText.setText(item.toString());
				setAdapterForPoiTypeEditText();
			}

			@Override
			public void onNothingSelected(AdapterView<?> parent) {
			}
		});

	}

	private void addMapEntryAdapter(final Map<String, PoiType> subCategories, String key, PoiType v) {
		if (!subCategories.containsKey(key.toLowerCase())) {
			subCategories.put(Algorithms.capitalizeFirstLetterAndLowercase(key), v);
		}
	}

	private OsmandApplication getMyApplication() {
		return (OsmandApplication) getActivity().getApplication();
	}

	public static EditPoiDialogFragment createAddPoiInstance(double latitude, double longitude,
															 OsmandApplication application) {
		Node node = new Node(latitude, longitude, -1);
		return createInstance(node, true);
	}

	public static EditPoiDialogFragment createInstance(Node node, boolean isAddingPoi) {
		EditPoiDialogFragment editPoiDialogFragment = new EditPoiDialogFragment();
		Bundle args = new Bundle();
		args.putSerializable(KEY_AMENITY_NODE, node);
		args.putBoolean(IS_ADDING_POI, isAddingPoi);
		editPoiDialogFragment.setArguments(args);
		return editPoiDialogFragment;
	}

	public static void showEditInstance(final Amenity amenity,
										final AppCompatActivity activity) {
		final OsmandSettings settings = ((OsmandApplication) activity.getApplication())
				.getSettings();
		final OpenstreetmapUtil openstreetmapUtilToLoad;
		OsmEditingPlugin plugin = OsmandPlugin.getPlugin(OsmEditingPlugin.class);
		if (//settings.OFFLINE_EDITION.get() ||
				!settings.isInternetConnectionAvailable(true)) {
			openstreetmapUtilToLoad = plugin.getPoiModificationLocalUtil();
		} else {
			openstreetmapUtilToLoad = plugin.getPoiModificationRemoteUtil();
		}
		new AsyncTask<Void, Void, Node>() {
			@Override
			protected Node doInBackground(Void... params) {
				return openstreetmapUtilToLoad.loadNode(amenity);
			}

			protected void onPostExecute(Node n) {
				if (n != null) {
					EditPoiDialogFragment fragment =
							EditPoiDialogFragment.createInstance(n, false);
					fragment.show(activity.getSupportFragmentManager(), TAG);
				} else {
					AccessibleToast.makeText(activity,
							activity.getString(R.string.poi_error_poi_not_found),
							Toast.LENGTH_SHORT).show();
				}
			}
		}.execute();
	}

	public static class MyAdapter extends FragmentPagerAdapter {
		private final Fragment[] fragments = new Fragment[]{new BasicEditPoiFragment(),
				new AdvancedEditPoiFragment()};
		private final String[] titles;

		public MyAdapter(FragmentManager fm, String basicTitle, String extendedTitle) {
			super(fm);
			titles = new String[]{basicTitle, extendedTitle};
		}

		@Override
		public int getCount() {
			return 2;
		}

		@Override
		public Fragment getItem(int position) {
			return fragments[position];
		}

		@Override
		public CharSequence getPageTitle(int position) {
			return titles[position];
		}
	}

	public static class ShowDeleteDialogAsyncTask extends AsyncTask<Amenity, Void, Node> {
		private final OpenstreetmapUtil openstreetmapUtil;
		private final AppCompatActivity activity;

		public ShowDeleteDialogAsyncTask(AppCompatActivity activity) {
			this.activity = activity;
			OsmandSettings settings = ((OsmandApplication) activity.getApplication()).getSettings();
			OsmEditingPlugin plugin = OsmandPlugin.getPlugin(OsmEditingPlugin.class);
			if (settings.OFFLINE_EDITION.get() || !settings.isInternetConnectionAvailable(true)) {
				openstreetmapUtil = plugin.getPoiModificationLocalUtil();
			} else {
				openstreetmapUtil = plugin.getPoiModificationRemoteUtil();
			}
		}

		protected Node doInBackground(Amenity[] params) {
			return openstreetmapUtil.loadNode(params[0]);
		}

		protected void onPostExecute(final Node n) {
			if (n == null) {
				AccessibleToast.makeText(activity, activity.getResources().getString(R.string.poi_error_poi_not_found), Toast.LENGTH_LONG).show();
				return;
			}
			AlertDialog.Builder builder = new AlertDialog.Builder(activity);
			builder.setTitle(R.string.poi_remove_title);
			final EditText comment;
			final CheckBox closeChangesetCheckBox;
			final boolean isLocalEdit = openstreetmapUtil instanceof OpenstreetmapLocalUtil;
			if (isLocalEdit) {
				closeChangesetCheckBox = null;
				comment = null;
			} else {
				LinearLayout ll = new LinearLayout(activity);
				ll.setPadding(16, 2, 16, 0);
				ll.setOrientation(LinearLayout.VERTICAL);
				closeChangesetCheckBox = new CheckBox(activity);
				closeChangesetCheckBox.setText(R.string.close_changeset);
				ll.addView(closeChangesetCheckBox);
				comment = new EditText(activity);
				comment.setText(R.string.poi_remove_title);
				ll.addView(comment);
				builder.setView(ll);
			}
			builder.setNegativeButton(R.string.shared_string_cancel, null);
			builder.setPositiveButton(isLocalEdit ? R.string.shared_string_save : R.string.shared_string_delete, new DialogInterface.OnClickListener() {
				@Override
				public void onClick(DialogInterface dialog, int which) {
					String c = comment == null ? null : comment.getText().toString();
					boolean closeChangeSet = closeChangesetCheckBox != null
							&& closeChangesetCheckBox.isChecked();
					deleteNode(n, c, closeChangeSet);
				}

				
			});
			builder.create().show();
		}
		
		private void deleteNode(final Node n, final String c, final boolean closeChangeSet) {
			final boolean isLocalEdit = openstreetmapUtil instanceof OpenstreetmapLocalUtil;
			commitNode(OsmPoint.Action.DELETE, n, openstreetmapUtil.getEntityInfo(n.getId()), c, closeChangeSet,
					new CallbackWithObject<Node>() {

						@Override
						public boolean processResult(Node result) {
							if (result != null) {
								if (isLocalEdit) {
									AccessibleToast.makeText(activity, R.string.osm_changes_added_to_local_edits,
											Toast.LENGTH_LONG).show();
								} else {
									AccessibleToast.makeText(activity, R.string.poi_remove_success, Toast.LENGTH_LONG)
											.show();
								}
								if (activity instanceof MapActivity) {
									((MapActivity) activity).getMapView().refreshMap(true);
								}
							}
							return false;
						}
					}, activity, openstreetmapUtil);
		}
	}

	public static class SaveWithAdvancedTagsDialogFragment extends DialogFragment {
		@NonNull
		@Override
		public Dialog onCreateDialog(Bundle savedInstanceState) {
			AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
			builder.setTitle(getResources().getString(R.string.are_you_sure))
					.setMessage(getString(R.string.save_poi_without_poi_type_message))
					.setPositiveButton(R.string.shared_string_ok, new DialogInterface.OnClickListener() {
						@Override
						public void onClick(DialogInterface dialog, int which) {
							((EditPoiDialogFragment) getParentFragment()).save();
						}
					})
					.setNegativeButton(R.string.shared_string_cancel, null);
			return builder.create();
		}
	}

	public static class AreYouSureDialogFragment extends DialogFragment {
		@NonNull
		@Override
		public Dialog onCreateDialog(Bundle savedInstanceState) {
			AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
			builder.setTitle(getResources().getString(R.string.are_you_sure))
					.setMessage(getString(R.string.unsaved_changes_will_be_lost))
					.setPositiveButton(R.string.shared_string_ok, new DialogInterface.OnClickListener() {
						@Override
						public void onClick(DialogInterface dialog, int which) {
							((DialogFragment) getParentFragment()).dismiss();
						}
					})
					.setNegativeButton(R.string.shared_string_cancel, null);
			return builder.create();
		}
	} 

	private TextView.OnEditorActionListener mOnEditorActionListener =
			new TextView.OnEditorActionListener() {
				@Override
				public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
					boolean handled = false;
					if (actionId == EditorInfo.IME_ACTION_SEND) {
						trySave();
						handled = true;
					}
					return handled;
				}
			};

	public interface OnFragmentActivatedListener {
		void onFragmentActivated();
	}
}
!@#$%
20190530_035734,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_a08896
package net.osmand.plus.osmedit;
import android.app.Activity;
import android.app.Dialog;
import android.app.ProgressDialog;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.res.Resources;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Build;
import android.os.Bundle;
import android.support.annotation.NonNull;
import android.support.design.widget.TabLayout;
import android.support.design.widget.TextInputLayout;
import android.support.v4.app.DialogFragment;
import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentManager;
import android.support.v4.app.FragmentPagerAdapter;
import android.support.v4.view.ViewCompat;
import android.support.v4.view.ViewPager;
import android.support.v7.app.AlertDialog;
import android.support.v7.app.AppCompatActivity;
import android.support.v7.widget.Toolbar;
import android.text.Editable;
import android.text.TextUtils;
import android.text.TextWatcher;
import android.util.TypedValue;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.view.WindowManager;
import android.view.inputmethod.EditorInfo;
import android.widget.AdapterView;
import android.widget.ArrayAdapter;
import android.widget.AutoCompleteTextView;
import android.widget.Button;
import android.widget.CheckBox;
import android.widget.EditText;
import android.widget.ImageButton;
import android.widget.LinearLayout;
import android.widget.TextView;
import android.widget.Toast;
import net.osmand.CallbackWithObject;
import net.osmand.PlatformUtil;
import net.osmand.access.AccessibleToast;
import net.osmand.data.Amenity;
import net.osmand.data.LatLon;
import net.osmand.osm.PoiCategory;
import net.osmand.osm.PoiType;
import net.osmand.osm.edit.EntityInfo;
import net.osmand.osm.edit.Node;
import net.osmand.osm.edit.OSMSettings;
import net.osmand.plus.OsmandApplication;
import net.osmand.plus.OsmandPlugin;
import net.osmand.plus.OsmandSettings;
import net.osmand.plus.R;
import net.osmand.plus.activities.MapActivity;
import net.osmand.plus.osmedit.dialogs.PoiSubTypeDialogFragment;
import net.osmand.plus.osmedit.dialogs.PoiTypeDialogFragment;
import net.osmand.util.Algorithms;

import org.apache.commons.logging.Log;

import java.io.Serializable;
import java.util.Comparator;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

public class EditPoiDialogFragment extends DialogFragment {
	public static final String TAG = "EditPoiDialogFragment";
	private static final Log LOG = PlatformUtil.getLog(EditPoiDialogFragment.class);

	private static final String KEY_AMENITY_NODE = "key_amenity_node";
	private static final String TAGS_LIST = "tags_list";
	private static final String IS_ADDING_POI = "is_adding_poi";

	private static final HashSet<String> BASIC_TAGS = new HashSet<String>() {
		{
			add(OSMSettings.OSMTagKey.NAME.getValue());
			add(OSMSettings.OSMTagKey.ADDR_STREET.getValue());
			add(OSMSettings.OSMTagKey.ADDR_HOUSE_NUMBER.getValue());
			add(OSMSettings.OSMTagKey.PHONE.getValue());
			add(OSMSettings.OSMTagKey.WEBSITE.getValue());
			add(OSMSettings.OSMTagKey.OPENING_HOURS.getValue());
		}
	};

	private EditPoiData editPoiData;
	private ViewPager viewPager;
	private AutoCompleteTextView poiTypeEditText;

	private OpenstreetmapUtil mOpenstreetmapUtil;
	private TextInputLayout poiTypeTextInputLayout;
	private View view;

	@Override
	public void onAttach(Activity activity) {
		super.onAttach(activity);
		OsmandSettings settings = getMyApplication().getSettings();
		OsmEditingPlugin plugin = OsmandPlugin.getPlugin(OsmEditingPlugin.class);
		if (settings.OFFLINE_EDITION.get() || !settings.isInternetConnectionAvailable(true)) {
			mOpenstreetmapUtil = plugin.getPoiModificationLocalUtil();
		} else {
			mOpenstreetmapUtil = plugin.getPoiModificationRemoteUtil();
		}

		Node node = (Node) getArguments().getSerializable(KEY_AMENITY_NODE);
		editPoiData = new EditPoiData(node, getMyApplication());
	}

	@Override
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		boolean isLightTheme = ((OsmandApplication) getActivity().getApplication())
				.getSettings().OSMAND_THEME.get() == OsmandSettings.OSMAND_LIGHT_THEME;
		int themeId = isLightTheme ? R.style.OsmandLightTheme : R.style.OsmandDarkTheme;
		setStyle(STYLE_NO_FRAME, themeId);
		getActivity().getWindow()
				.setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE);
	}

	@Override
	public View onCreateView(LayoutInflater inflater, ViewGroup container,
							 Bundle savedInstanceState) {
		view = inflater.inflate(R.layout.fragment_edit_poi, container, false);
		final OsmandSettings settings = getMyApplication().getSettings();
		boolean isLightTheme = settings.OSMAND_THEME.get() == OsmandSettings.OSMAND_LIGHT_THEME;

		if (savedInstanceState != null) {
			@SuppressWarnings("unchecked")
			Map<String, String> mp = (Map<String, String>) savedInstanceState.getSerializable(TAGS_LIST);
			editPoiData.updateTags(mp);
		}

		boolean isAddingPoi = getArguments().getBoolean(IS_ADDING_POI);

		Toolbar toolbar = (Toolbar) view.findViewById(R.id.toolbar);
		toolbar.setTitle(isAddingPoi ? R.string.poi_create_title : R.string.poi_edit_title);
		toolbar.setNavigationIcon(R.drawable.abc_ic_ab_back_mtrl_am_alpha);
		toolbar.setNavigationOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				dismissCheckForChanges();
			}
		});

		viewPager = (ViewPager) view.findViewById(R.id.viewpager);
		String basicTitle = getResources().getString(R.string.tab_title_basic);
		String extendedTitle = getResources().getString(R.string.tab_title_advanced);
		final MyAdapter pagerAdapter = new MyAdapter(getChildFragmentManager(), basicTitle, extendedTitle);
		viewPager.setAdapter(pagerAdapter);
		viewPager.addOnPageChangeListener(new ViewPager.OnPageChangeListener() {
			@Override
			public void onPageScrolled(int i, float v, int i1) {

			}

			@Override
			public void onPageSelected(int i) {
				((OnFragmentActivatedListener) pagerAdapter.getItem(i)).onFragmentActivated();
			}

			@Override
			public void onPageScrollStateChanged(int i) {

			}
		});

		final TabLayout tabLayout = (TabLayout) view.findViewById(R.id.tab_layout);
		tabLayout.setTabMode(TabLayout.MODE_SCROLLABLE);

		// Hack due to bug in design support library v22.2.1
		// https://code.google.com/p/android/issues/detail?id=180462
		// TODO remove in new version
		if (ViewCompat.isLaidOut(tabLayout)) {
			tabLayout.setupWithViewPager(viewPager);
		} else {
			tabLayout.addOnLayoutChangeListener(new View.OnLayoutChangeListener() {
				@Override
				public void onLayoutChange(View v, int left, int top, int right, int bottom,
										   int oldLeft, int oldTop, int oldRight, int oldBottom) {
					tabLayout.setupWithViewPager(viewPager);
					tabLayout.removeOnLayoutChangeListener(this);
				}
			});
		}

		ImageButton onlineDocumentationButton =
				(ImageButton) view.findViewById(R.id.onlineDocumentationButton);
		onlineDocumentationButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				getActivity().startActivity(new Intent(Intent.ACTION_VIEW,
						Uri.parse("https://wiki.openstreetmap.org/wiki/Map_Features")));
			}
		});

		final int colorId = isLightTheme ? R.color.inactive_item_orange : R.color.dash_search_icon_dark;
		final int color = getResources().getColor(colorId);
		onlineDocumentationButton.setImageDrawable(getMyApplication().getIconsCache()
				.getPaintedContentIcon(R.drawable.ic_action_help, color));
		final ImageButton poiTypeButton = (ImageButton) view.findViewById(R.id.poiTypeButton);
		poiTypeButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				DialogFragment fragment = PoiTypeDialogFragment.createInstance();
				fragment.show(getChildFragmentManager(), "PoiTypeDialogFragment");
			}
		});

		EditText poiNameEditText = (EditText) view.findViewById(R.id.poiNameEditText);
		poiNameEditText.addTextChangedListener(new TextWatcher() {
			@Override
			public void beforeTextChanged(CharSequence s, int start, int count, int after) {
			}

			@Override
			public void onTextChanged(CharSequence s, int start, int before, int count) {
			}

			@Override
			public void afterTextChanged(Editable s) {
				if (!getEditPoiData().isInEdit()) {
					if (!TextUtils.isEmpty(s)) {
						getEditPoiData().putTag(OSMSettings.OSMTagKey.NAME.getValue(),
								s.toString());
					} else {
						getEditPoiData().removeTag(OSMSettings.OSMTagKey.NAME.getValue());
					}
				}
			}
		});
		poiNameEditText.setText(editPoiData.getTag(OSMSettings.OSMTagKey.NAME.getValue()));
		poiTypeTextInputLayout = (TextInputLayout) view.findViewById(R.id.poiTypeTextInputLayout);
		poiTypeEditText = (AutoCompleteTextView) view.findViewById(R.id.poiTypeEditText);
		poiTypeEditText.addTextChangedListener(new TextWatcher() {
			@Override
			public void beforeTextChanged(CharSequence s, int start, int count, int after) {
			}

			@Override
			public void onTextChanged(CharSequence s, int start, int before, int count) {
			}

			@Override
			public void afterTextChanged(Editable s) {
				if (!getEditPoiData().isInEdit()) {
					getEditPoiData().updateTypeTag(s.toString());
					poiTypeTextInputLayout.setHint(editPoiData.getPoiCategory().getTranslation());
				}
			}
		});
		poiNameEditText.setOnEditorActionListener(mOnEditorActionListener);
		poiTypeEditText.setOnEditorActionListener(mOnEditorActionListener);
		poiTypeEditText.setText(editPoiData.getPoiTypeString());
		poiTypeEditText.setOnTouchListener(new View.OnTouchListener() {
			@Override
			public boolean onTouch(final View v, MotionEvent event) {
				final EditText editText = (EditText) v;
				final int DRAWABLE_RIGHT = 2;
				if (event.getAction() == MotionEvent.ACTION_UP) {
					if (event.getX() >= (editText.getRight()
							- editText.getCompoundDrawables()[DRAWABLE_RIGHT].getBounds().width()
							- editText.getPaddingRight())) {
						if (editPoiData.getPoiCategory() != null) {
							DialogFragment dialogFragment =
									PoiSubTypeDialogFragment.createInstance(editPoiData.getPoiCategory());
							dialogFragment.show(getChildFragmentManager(), "PoiSubTypeDialogFragment");
						}

						return true;
					}
				}
				return false;
			}
		});

		Button saveButton = (Button) view.findViewById(R.id.saveButton);
		saveButton.setText(mOpenstreetmapUtil instanceof OpenstreetmapRemoteUtil
				? R.string.shared_string_upload : R.string.shared_string_save);
		saveButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				trySave();
			}
		});
		Button cancelButton = (Button) view.findViewById(R.id.cancelButton);
		cancelButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				dismissCheckForChanges();
			}
		});
		setAdapterForPoiTypeEditText();
		setCancelable(false);
		return view;
	}

	@NonNull
	@Override
	public Dialog onCreateDialog(Bundle savedInstanceState) {
		final Dialog dialog = super.onCreateDialog(savedInstanceState);
		dialog.getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE);
		return dialog;
	}

	private void trySave() {
		if (TextUtils.isEmpty(poiTypeEditText.getText())) {
			HashSet<String> tagsCopy = new HashSet<>();
			tagsCopy.addAll(editPoiData.getTagValues().keySet());
			tagsCopy.removeAll(BASIC_TAGS);
			if (tagsCopy.isEmpty()) {
				poiTypeEditText.setError(getResources().getString(R.string.please_specify_poi_type));
			} else {
				new SaveWithAdvancedTagsDialogFragment().show(getChildFragmentManager(), "dialog");
			}
		} else if(editPoiData.getPoiCategory() == getMyApplication().getPoiTypes().getOtherPoiCategory()) {
			poiTypeEditText.setError(getResources().getString(R.string.please_specify_poi_type));
		} else if(editPoiData.getPoiTypeDefined() == null) {
			poiTypeEditText.setError(getResources().getString(R.string.please_specify_poi_type_only_from_list));
		} else {
			save();
		}
	}

	private void save() {
		Node original = editPoiData.getEntity();
		final boolean offlineEdit = mOpenstreetmapUtil instanceof OpenstreetmapLocalUtil;
		Node node = new Node(original.getLatitude(), original.getLongitude(), original.getId());
		OsmPoint.Action action = node.getId() == -1 ? OsmPoint.Action.CREATE : OsmPoint.Action.MODIFY;
		for (Map.Entry<String, String> tag : editPoiData.getTagValues().entrySet()) {
			if (tag.getKey().equals(EditPoiData.POI_TYPE_TAG)) {
				final PoiType poiType = editPoiData.getAllTranslatedSubTypes().get(tag.getValue().trim().toLowerCase());
				if (poiType != null) {
					node.putTag(poiType.getOsmTag(), poiType.getOsmValue());
					if (poiType.getOsmTag2() != null) {
						node.putTag(poiType.getOsmTag2(), poiType.getOsmValue2());
					}
				} else if (!Algorithms.isEmpty(tag.getValue())) {
					node.putTag(editPoiData.getPoiCategory().getDefaultTag(), tag.getValue());

				}
				if(offlineEdit && !Algorithms.isEmpty(tag.getValue())) {
					node.putTag(tag.getKey(), tag.getValue());
				}
			} else if (!Algorithms.isEmpty(tag.getKey()) && !Algorithms.isEmpty(tag.getValue())) {
				node.putTag(tag.getKey(), tag.getValue());
			}
		}
		commitNode(action, node, mOpenstreetmapUtil.getEntityInfo(node.getId()), "", false,
				new CallbackWithObject<Node>() {

					@Override
					public boolean processResult(Node result) {
						if (result != null) {
							OsmEditingPlugin plugin = OsmandPlugin.getPlugin(OsmEditingPlugin.class);
							if (plugin != null && offlineEdit) {
								List<OpenstreetmapPoint> points = plugin.getDBPOI().getOpenstreetmapPoints();
								if (getActivity() instanceof MapActivity && points.size() > 0) {
									OsmPoint point = points.get(points.size() - 1);
									MapActivity mapActivity = (MapActivity) getActivity();
									mapActivity.getContextMenu().showOrUpdate(
											new LatLon(point.getLatitude(), point.getLongitude()),
											plugin.getOsmEditsLayer(mapActivity).getObjectName(point), point);
								}
							}

							if (getActivity() instanceof MapActivity) {
								((MapActivity) getActivity()).getMapView().refreshMap(true);
							}
							dismiss();
						} else {
							OsmEditingPlugin plugin = OsmandPlugin.getPlugin(OsmEditingPlugin.class);
							mOpenstreetmapUtil = plugin.getPoiModificationLocalUtil();
							Button saveButton = (Button) view.findViewById(R.id.saveButton);
							saveButton.setText(mOpenstreetmapUtil instanceof OpenstreetmapRemoteUtil
									? R.string.shared_string_upload : R.string.shared_string_save);
						}

						return false;
					}
				}, getActivity(), mOpenstreetmapUtil);
	}

	@Override
	public void onResume() {
		super.onResume();
		getDialog().setOnKeyListener(new DialogInterface.OnKeyListener() {
			@Override
			public boolean onKey(DialogInterface dialog, int keyCode, KeyEvent event) {
				if (keyCode == android.view.KeyEvent.KEYCODE_BACK) {
					if (event.getAction() == KeyEvent.ACTION_DOWN) {
						return true;
					} else {
						dismissCheckForChanges();
						return true;
					}
				}
				return false;
			}
		});
	}

	private void dismissCheckForChanges() {
		if (editPoiData.hasChangesBeenMade()) {
			new AreYouSureDialogFragment().show(getChildFragmentManager(),
					"AreYouSureDialogFragment");
		} else {
			dismiss();
		}
	}

	@Override
	public void onSaveInstanceState(Bundle outState) {
		outState.putSerializable(TAGS_LIST, (Serializable) editPoiData.getTagValues());
		super.onSaveInstanceState(outState);
	}

	public EditPoiData getEditPoiData() {
		return editPoiData;
	}

	public void setSubCategory(String subCategory) {
		poiTypeEditText.setText(subCategory);
	}

	public static void commitNode(final OsmPoint.Action action,
								  final Node n,
								  final EntityInfo info,
								  final String comment,
								  final boolean closeChangeSet,
								  final CallbackWithObject<Node> postExecute,
								  final Activity activity,
								  final OpenstreetmapUtil openstreetmapUtil) {
		if (info == null && OsmPoint.Action.CREATE != action && openstreetmapUtil instanceof OpenstreetmapRemoteUtil) {
			AccessibleToast.makeText(activity, activity.getResources().getString(R.string.poi_error_info_not_loaded), Toast.LENGTH_LONG).show();
			return;
		}
		new AsyncTask<Void, Void, Node>() {
			ProgressDialog progress;

			@Override
			protected void onPreExecute() {
				progress = ProgressDialog.show(activity, activity.getString(R.string.uploading), activity.getString(R.string.uploading_data));
				super.onPreExecute();
			}

			@Override
			protected Node doInBackground(Void... params) {
				return openstreetmapUtil.commitNodeImpl(action, n, info, comment, closeChangeSet);
			}

			@Override
			protected void onPostExecute(Node result) {
				progress.dismiss();
				if(postExecute != null) {
					postExecute.processResult(result);
				}
			}
		}.execute();
	}

	public void setPoiCategory(PoiCategory type) {
		editPoiData.updateType(type);
		poiTypeEditText.setText(editPoiData.getPoiTypeString());
		setAdapterForPoiTypeEditText();
	}

	private void setAdapterForPoiTypeEditText() {
		final Map<String, PoiType> subCategories = new LinkedHashMap<>();
		PoiCategory ct = editPoiData.getPoiCategory();
		if(ct != null) {
			for (PoiType s : ct.getPoiTypes()) {
				if(!s.isReference() && !s.isNotEditableOsm() && s.getBaseLangType() == null) {
					addMapEntryAdapter(subCategories, s.getTranslation(), s);
					addMapEntryAdapter(subCategories, s.getKeyName().replace('_', ' '), s);
				}
			}
		}
		for (Map.Entry<String, PoiType> s : editPoiData.getAllTranslatedSubTypes().entrySet()) {
			addMapEntryAdapter(subCategories, s.getKey(), s.getValue());
		}
		final ArrayAdapter<Object> adapter;
		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
			adapter = new ArrayAdapter<>(getActivity(),
					R.layout.list_textview, subCategories.keySet().toArray());
		} else {
			TypedValue typedValue = new TypedValue();
			Resources.Theme theme = getActivity().getTheme();
			theme.resolveAttribute(android.R.attr.textColorSecondary, typedValue, true);
			final int textColor = typedValue.data;

			adapter = new ArrayAdapter<Object>(getActivity(),
					R.layout.list_textview, subCategories.keySet().toArray()) {
				@Override
				public View getView(int position, View convertView, ViewGroup parent) {
					final View view = super.getView(position, convertView, parent);
					((TextView) view.findViewById(R.id.textView)).setTextColor(textColor);
					return view;
				}
			};
		}
		adapter.sort(new Comparator<Object>() {
			@Override
			public int compare(Object lhs, Object rhs) {
				return lhs.toString().compareTo(rhs.toString());
			}
		});
		poiTypeEditText.setAdapter(adapter);
		poiTypeEditText.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {

			@Override
			public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
				Object item = parent.getAdapter().getItem(position);
				poiTypeEditText.setText(item.toString());
				setAdapterForPoiTypeEditText();
			}

			@Override
			public void onNothingSelected(AdapterView<?> parent) {
			}
		});

	}

	private void addMapEntryAdapter(final Map<String, PoiType> subCategories, String key, PoiType v) {
		if (!subCategories.containsKey(key.toLowerCase())) {
			subCategories.put(Algorithms.capitalizeFirstLetterAndLowercase(key), v);
		}
	}

	private OsmandApplication getMyApplication() {
		return (OsmandApplication) getActivity().getApplication();
	}

	public static EditPoiDialogFragment createAddPoiInstance(double latitude, double longitude,
															 OsmandApplication application) {
		Node node = new Node(latitude, longitude, -1);
		return createInstance(node, true);
	}

	public static EditPoiDialogFragment createInstance(Node node, boolean isAddingPoi) {
		EditPoiDialogFragment editPoiDialogFragment = new EditPoiDialogFragment();
		Bundle args = new Bundle();
		args.putSerializable(KEY_AMENITY_NODE, node);
		args.putBoolean(IS_ADDING_POI, isAddingPoi);
		editPoiDialogFragment.setArguments(args);
		return editPoiDialogFragment;
	}

	public static void showEditInstance(final Amenity amenity,
										final AppCompatActivity activity) {
		final OsmandSettings settings = ((OsmandApplication) activity.getApplication())
				.getSettings();
		final OpenstreetmapUtil openstreetmapUtilToLoad;
		OsmEditingPlugin plugin = OsmandPlugin.getPlugin(OsmEditingPlugin.class);
		if (//settings.OFFLINE_EDITION.get() ||
				!settings.isInternetConnectionAvailable(true)) {
			openstreetmapUtilToLoad = plugin.getPoiModificationLocalUtil();
		} else {
			openstreetmapUtilToLoad = plugin.getPoiModificationRemoteUtil();
		}
		new AsyncTask<Void, Void, Node>() {
			@Override
			protected Node doInBackground(Void... params) {
				return openstreetmapUtilToLoad.loadNode(amenity);
			}

			protected void onPostExecute(Node n) {
				if (n != null) {
					EditPoiDialogFragment fragment =
							EditPoiDialogFragment.createInstance(n, false);
					fragment.show(activity.getSupportFragmentManager(), TAG);
				} else {
					AccessibleToast.makeText(activity,
							activity.getString(R.string.poi_error_poi_not_found),
							Toast.LENGTH_SHORT).show();
				}
			}
		}.execute();
	}

	public static class MyAdapter extends FragmentPagerAdapter {
		private final Fragment[] fragments = new Fragment[]{new BasicEditPoiFragment(),
				new AdvancedEditPoiFragment()};
		private final String[] titles;

		public MyAdapter(FragmentManager fm, String basicTitle, String extendedTitle) {
			super(fm);
			titles = new String[]{basicTitle, extendedTitle};
		}

		@Override
		public int getCount() {
			return 2;
		}

		@Override
		public Fragment getItem(int position) {
			return fragments[position];
		}

		@Override
		public CharSequence getPageTitle(int position) {
			return titles[position];
		}
	}

	public static class ShowDeleteDialogAsyncTask extends AsyncTask<Amenity, Void, Node> {
		private final OpenstreetmapUtil openstreetmapUtil;
		private final AppCompatActivity activity;

		public ShowDeleteDialogAsyncTask(AppCompatActivity activity) {
			this.activity = activity;
			OsmandSettings settings = ((OsmandApplication) activity.getApplication()).getSettings();
			OsmEditingPlugin plugin = OsmandPlugin.getPlugin(OsmEditingPlugin.class);
			if (settings.OFFLINE_EDITION.get() || !settings.isInternetConnectionAvailable(true)) {
				openstreetmapUtil = plugin.getPoiModificationLocalUtil();
			} else {
				openstreetmapUtil = plugin.getPoiModificationRemoteUtil();
			}
		}

		protected Node doInBackground(Amenity[] params) {
			return openstreetmapUtil.loadNode(params[0]);
		}

		protected void onPostExecute(final Node n) {
			if (n == null) {
				AccessibleToast.makeText(activity, activity.getResources().getString(R.string.poi_error_poi_not_found), Toast.LENGTH_LONG).show();
				return;
			}
			AlertDialog.Builder builder = new AlertDialog.Builder(activity);
			builder.setTitle(R.string.poi_remove_title);
			final EditText comment;
			final CheckBox closeChangesetCheckBox;
			final boolean isLocalEdit = openstreetmapUtil instanceof OpenstreetmapLocalUtil;
			if (isLocalEdit) {
				closeChangesetCheckBox = null;
				comment = null;
			} else {
				LinearLayout ll = new LinearLayout(activity);
				ll.setPadding(16, 2, 16, 0);
				ll.setOrientation(LinearLayout.VERTICAL);
				closeChangesetCheckBox = new CheckBox(activity);
				closeChangesetCheckBox.setText(R.string.close_changeset);
				ll.addView(closeChangesetCheckBox);
				comment = new EditText(activity);
				comment.setText(R.string.poi_remove_title);
				ll.addView(comment);
				builder.setView(ll);
			}
			builder.setNegativeButton(R.string.shared_string_cancel, null);
			builder.setPositiveButton(isLocalEdit ? R.string.shared_string_save : R.string.shared_string_delete, new DialogInterface.OnClickListener() {
				@Override
				public void onClick(DialogInterface dialog, int which) {
					String c = comment == null ? null : comment.getText().toString();
					boolean closeChangeSet = closeChangesetCheckBox != null
							&& closeChangesetCheckBox.isChecked();
					deleteNode(n, c, closeChangeSet);
				}

				
			});
			builder.create().show();
		}
		
		private void deleteNode(final Node n, final String c, final boolean closeChangeSet) {
			final boolean isLocalEdit = openstreetmapUtil instanceof OpenstreetmapLocalUtil;
			commitNode(OsmPoint.Action.DELETE, n, openstreetmapUtil.getEntityInfo(n.getId()), c, closeChangeSet,
					new CallbackWithObject<Node>() {

						@Override
						public boolean processResult(Node result) {
							if (result != null) {
								if (isLocalEdit) {
									AccessibleToast.makeText(activity, R.string.osm_changes_added_to_local_edits,
											Toast.LENGTH_LONG).show();
								} else {
									AccessibleToast.makeText(activity, R.string.poi_remove_success, Toast.LENGTH_LONG)
											.show();
								}
								if (activity instanceof MapActivity) {
									((MapActivity) activity).getMapView().refreshMap(true);
								}
							}
							return false;
						}
					}, activity, openstreetmapUtil);
		}
	}

	public static class SaveWithAdvancedTagsDialogFragment extends DialogFragment {
		@NonNull
		@Override
		public Dialog onCreateDialog(Bundle savedInstanceState) {
			AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
			builder.setTitle(getResources().getString(R.string.are_you_sure))
					.setMessage(getString(R.string.save_poi_without_poi_type_message))
					.setPositiveButton(R.string.shared_string_ok, new DialogInterface.OnClickListener() {
						@Override
						public void onClick(DialogInterface dialog, int which) {
							((EditPoiDialogFragment) getParentFragment()).save();
						}
					})
					.setNegativeButton(R.string.shared_string_cancel, null);
			return builder.create();
		}
	}

	public static class AreYouSureDialogFragment extends DialogFragment {
		@NonNull
		@Override
		public Dialog onCreateDialog(Bundle savedInstanceState) {
			AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
			builder.setTitle(getResources().getString(R.string.are_you_sure))
					.setMessage(getString(R.string.unsaved_changes_will_be_lost))
					.setPositiveButton(R.string.shared_string_ok, new DialogInterface.OnClickListener() {
						@Override
						public void onClick(DialogInterface dialog, int which) {
							((DialogFragment) getParentFragment()).dismiss();
						}
					})
					.setNegativeButton(R.string.shared_string_cancel, null);
			return builder.create();
		}
	} 

	private TextView.OnEditorActionListener mOnEditorActionListener =
			new TextView.OnEditorActionListener() {
				@Override
				public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
					boolean handled = false;
					if (actionId == EditorInfo.IME_ACTION_SEND) {
						trySave();
						handled = true;
					}
					return handled;
				}
			};

	public interface OnFragmentActivatedListener {
		void onFragmentActivated();
	}
}
!@#$%
20190530_035734,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_c08896
package net.osmand.plus.osmedit;

import android.app.Activity;
import android.app.Dialog;
import android.app.ProgressDialog;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.res.Resources;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Build;
import android.os.Bundle;
import android.support.annotation.NonNull;
import android.support.design.widget.TabLayout;
import android.support.design.widget.TextInputLayout;
import android.support.v4.app.DialogFragment;
import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentManager;
import android.support.v4.app.FragmentPagerAdapter;
import android.support.v4.view.ViewCompat;
import android.support.v4.view.ViewPager;
import android.support.v7.app.AlertDialog;
import android.support.v7.app.AppCompatActivity;
import android.support.v7.widget.Toolbar;
import android.text.Editable;
import android.text.TextUtils;
import android.text.TextWatcher;
import android.util.TypedValue;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.view.WindowManager;
import android.view.inputmethod.EditorInfo;
import android.widget.AdapterView;
import android.widget.ArrayAdapter;
import android.widget.AutoCompleteTextView;
import android.widget.Button;
import android.widget.CheckBox;
import android.widget.EditText;
import android.widget.ImageButton;
import android.widget.LinearLayout;
import android.widget.TextView;
import android.widget.Toast;

import net.osmand.CallbackWithObject;
import net.osmand.PlatformUtil;
import net.osmand.access.AccessibleToast;
import net.osmand.data.Amenity;
import net.osmand.data.LatLon;
import net.osmand.osm.PoiCategory;
import net.osmand.osm.PoiType;
import net.osmand.osm.edit.EntityInfo;
import net.osmand.osm.edit.Node;
import net.osmand.osm.edit.OSMSettings;
import net.osmand.plus.OsmandApplication;
import net.osmand.plus.OsmandPlugin;
import net.osmand.plus.OsmandSettings;
import net.osmand.plus.R;
import net.osmand.plus.activities.MapActivity;
import net.osmand.plus.osmedit.dialogs.PoiSubTypeDialogFragment;
import net.osmand.plus.osmedit.dialogs.PoiTypeDialogFragment;
import net.osmand.util.Algorithms;

import org.apache.commons.logging.Log;

import java.io.Serializable;
import java.util.Comparator;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

public class EditPoiDialogFragment extends DialogFragment {
	public static final String TAG = "EditPoiDialogFragment";
	private static final Log LOG = PlatformUtil.getLog(EditPoiDialogFragment.class);

	private static final String KEY_AMENITY_NODE = "key_amenity_node";
	private static final String TAGS_LIST = "tags_list";
	private static final String IS_ADDING_POI = "is_adding_poi";

	private static final HashSet<String> BASIC_TAGS = new HashSet<String>() {
		{
			add(OSMSettings.OSMTagKey.NAME.getValue());
			add(OSMSettings.OSMTagKey.ADDR_STREET.getValue());
			add(OSMSettings.OSMTagKey.ADDR_HOUSE_NUMBER.getValue());
			add(OSMSettings.OSMTagKey.PHONE.getValue());
			add(OSMSettings.OSMTagKey.WEBSITE.getValue());
			add(OSMSettings.OSMTagKey.OPENING_HOURS.getValue());
		}
	};

	private EditPoiData editPoiData;
	private ViewPager viewPager;
	private AutoCompleteTextView poiTypeEditText;

	private OpenstreetmapUtil mOpenstreetmapUtil;
	private TextInputLayout poiTypeTextInputLayout;
	private View view;

	@Override
	public void onAttach(Activity activity) {
		super.onAttach(activity);
		OsmandSettings settings = getMyApplication().getSettings();
		OsmEditingPlugin plugin = OsmandPlugin.getPlugin(OsmEditingPlugin.class);
		if (settings.OFFLINE_EDITION.get() || !settings.isInternetConnectionAvailable(true)) {
			mOpenstreetmapUtil = plugin.getPoiModificationLocalUtil();
		} else {
			mOpenstreetmapUtil = plugin.getPoiModificationRemoteUtil();
		}

		Node node = (Node) getArguments().getSerializable(KEY_AMENITY_NODE);
		editPoiData = new EditPoiData(node, getMyApplication());
	}

	@Override
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		boolean isLightTheme = ((OsmandApplication) getActivity().getApplication())
				.getSettings().OSMAND_THEME.get() == OsmandSettings.OSMAND_LIGHT_THEME;
		int themeId = isLightTheme ? R.style.OsmandLightTheme : R.style.OsmandDarkTheme;
		setStyle(STYLE_NO_FRAME, themeId);
		getActivity().getWindow()
				.setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE);
	}

	@Override
	public View onCreateView(LayoutInflater inflater, ViewGroup container,
							 Bundle savedInstanceState) {
		view = inflater.inflate(R.layout.fragment_edit_poi, container, false);
		final OsmandSettings settings = getMyApplication().getSettings();
		boolean isLightTheme = settings.OSMAND_THEME.get() == OsmandSettings.OSMAND_LIGHT_THEME;

		if (savedInstanceState != null) {
			@SuppressWarnings("unchecked")
			Map<String, String> mp = (Map<String, String>) savedInstanceState.getSerializable(TAGS_LIST);
			editPoiData.updateTags(mp);
		}

		boolean isAddingPoi = getArguments().getBoolean(IS_ADDING_POI);

		Toolbar toolbar = (Toolbar) view.findViewById(R.id.toolbar);
		toolbar.setTitle(isAddingPoi ? R.string.poi_create_title : R.string.poi_edit_title);
		toolbar.setNavigationIcon(R.drawable.abc_ic_ab_back_mtrl_am_alpha);
		toolbar.setNavigationOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				dismissCheckForChanges();
			}
		});

		viewPager = (ViewPager) view.findViewById(R.id.viewpager);
		String basicTitle = getResources().getString(R.string.tab_title_basic);
		String extendedTitle = getResources().getString(R.string.tab_title_advanced);
		final MyAdapter pagerAdapter = new MyAdapter(getChildFragmentManager(), basicTitle, extendedTitle);
		viewPager.setAdapter(pagerAdapter);
		viewPager.addOnPageChangeListener(new ViewPager.OnPageChangeListener() {
			@Override
			public void onPageScrolled(int i, float v, int i1) {

			}

			@Override
			public void onPageSelected(int i) {
				((OnFragmentActivatedListener) pagerAdapter.getItem(i)).onFragmentActivated();
			}

			@Override
			public void onPageScrollStateChanged(int i) {

			}
		});

		final TabLayout tabLayout = (TabLayout) view.findViewById(R.id.tab_layout);
		tabLayout.setTabMode(TabLayout.MODE_SCROLLABLE);

		// Hack due to bug in design support library v22.2.1
		// https://code.google.com/p/android/issues/detail?id=180462
		// TODO remove in new version
		if (ViewCompat.isLaidOut(tabLayout)) {
			tabLayout.setupWithViewPager(viewPager);
		} else {
			tabLayout.addOnLayoutChangeListener(new View.OnLayoutChangeListener() {
				@Override
				public void onLayoutChange(View v, int left, int top, int right, int bottom,
										   int oldLeft, int oldTop, int oldRight, int oldBottom) {
					tabLayout.setupWithViewPager(viewPager);
					tabLayout.removeOnLayoutChangeListener(this);
				}
			});
		}

		ImageButton onlineDocumentationButton =
				(ImageButton) view.findViewById(R.id.onlineDocumentationButton);
		onlineDocumentationButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				getActivity().startActivity(new Intent(Intent.ACTION_VIEW,
						Uri.parse("https://wiki.openstreetmap.org/wiki/Map_Features")));
			}
		});

		final int colorId = isLightTheme ? R.color.inactive_item_orange : R.color.dash_search_icon_dark;
		final int color = getResources().getColor(colorId);
		onlineDocumentationButton.setImageDrawable(getMyApplication().getIconsCache()
				.getPaintedContentIcon(R.drawable.ic_action_help, color));
		final ImageButton poiTypeButton = (ImageButton) view.findViewById(R.id.poiTypeButton);
		poiTypeButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				DialogFragment fragment = PoiTypeDialogFragment.createInstance();
				fragment.show(getChildFragmentManager(), "PoiTypeDialogFragment");
			}
		});

		EditText poiNameEditText = (EditText) view.findViewById(R.id.poiNameEditText);
		poiNameEditText.addTextChangedListener(new TextWatcher() {
			@Override
			public void beforeTextChanged(CharSequence s, int start, int count, int after) {
			}

			@Override
			public void onTextChanged(CharSequence s, int start, int before, int count) {
			}

			@Override
			public void afterTextChanged(Editable s) {
				if (!getEditPoiData().isInEdit()) {
					if (!TextUtils.isEmpty(s)) {
						getEditPoiData().putTag(OSMSettings.OSMTagKey.NAME.getValue(),
								s.toString());
					} else {
						getEditPoiData().removeTag(OSMSettings.OSMTagKey.NAME.getValue());
					}
				}
			}
		});
		poiNameEditText.setText(editPoiData.getTag(OSMSettings.OSMTagKey.NAME.getValue()));
		poiTypeTextInputLayout = (TextInputLayout) view.findViewById(R.id.poiTypeTextInputLayout);
		poiTypeEditText = (AutoCompleteTextView) view.findViewById(R.id.poiTypeEditText);
		poiTypeEditText.addTextChangedListener(new TextWatcher() {
			@Override
			public void beforeTextChanged(CharSequence s, int start, int count, int after) {
			}

			@Override
			public void onTextChanged(CharSequence s, int start, int before, int count) {
			}

			@Override
			public void afterTextChanged(Editable s) {
				if (!getEditPoiData().isInEdit()) {
					getEditPoiData().updateTypeTag(s.toString());
					poiTypeTextInputLayout.setHint(editPoiData.getPoiCategory().getTranslation());
				}
			}
		});
		poiNameEditText.setOnEditorActionListener(mOnEditorActionListener);
		poiTypeEditText.setOnEditorActionListener(mOnEditorActionListener);
		poiTypeEditText.setText(editPoiData.getPoiTypeString());
		poiTypeEditText.setOnTouchListener(new View.OnTouchListener() {
			@Override
			public boolean onTouch(final View v, MotionEvent event) {
				final EditText editText = (EditText) v;
				final int DRAWABLE_RIGHT = 2;
				if (event.getAction() == MotionEvent.ACTION_UP) {
					if (event.getX() >= (editText.getRight()
							- editText.getCompoundDrawables()[DRAWABLE_RIGHT].getBounds().width()
							- editText.getPaddingRight())) {
						if (editPoiData.getPoiCategory() != null) {
							DialogFragment dialogFragment =
									PoiSubTypeDialogFragment.createInstance(editPoiData.getPoiCategory());
							dialogFragment.show(getChildFragmentManager(), "PoiSubTypeDialogFragment");
						}

						return true;
					}
				}
				return false;
			}
		});

		Button saveButton = (Button) view.findViewById(R.id.saveButton);
		saveButton.setText(mOpenstreetmapUtil instanceof OpenstreetmapRemoteUtil
				? R.string.shared_string_upload : R.string.shared_string_save);
		saveButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				trySave();
			}
		});
		Button cancelButton = (Button) view.findViewById(R.id.cancelButton);
		cancelButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				dismissCheckForChanges();
			}
		});
		setAdapterForPoiTypeEditText();
		setCancelable(false);
		return view;
	}

	@NonNull
	@Override
	public Dialog onCreateDialog(Bundle savedInstanceState) {
		final Dialog dialog = super.onCreateDialog(savedInstanceState);
		dialog.getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE);
		return dialog;
	}

	private void trySave() {
		if (TextUtils.isEmpty(poiTypeEditText.getText())) {
			HashSet<String> tagsCopy = new HashSet<>();
			tagsCopy.addAll(editPoiData.getTagValues().keySet());
			tagsCopy.removeAll(BASIC_TAGS);
			if (tagsCopy.isEmpty()) {
				poiTypeEditText.setError(getResources().getString(R.string.please_specify_poi_type));
			} else {
				new SaveWithAdvancedTagsDialogFragment().show(getChildFragmentManager(), "dialog");
			}
		} else if(editPoiData.getPoiCategory() == getMyApplication().getPoiTypes().getOtherPoiCategory()) {
			poiTypeEditText.setError(getResources().getString(R.string.please_specify_poi_type));
		} else if(editPoiData.getPoiTypeDefined() == null) {
			poiTypeEditText.setError(getResources().getString(R.string.please_specify_poi_type_only_from_list));
		} else {
			save();
		}
	}

	private void save() {
		Node original = editPoiData.getEntity();
		final boolean offlineEdit = mOpenstreetmapUtil instanceof OpenstreetmapLocalUtil;
		Node node = new Node(original.getLatitude(), original.getLongitude(), original.getId());
		OsmPoint.Action action = node.getId() == -1 ? OsmPoint.Action.CREATE : OsmPoint.Action.MODIFY;
		for (Map.Entry<String, String> tag : editPoiData.getTagValues().entrySet()) {
			if (tag.getKey().equals(EditPoiData.POI_TYPE_TAG)) {
				final PoiType poiType = editPoiData.getAllTranslatedSubTypes().get(tag.getValue().trim().toLowerCase());
				if (poiType != null) {
					node.putTag(poiType.getOsmTag(), poiType.getOsmValue());
					if (poiType.getOsmTag2() != null) {
						node.putTag(poiType.getOsmTag2(), poiType.getOsmValue2());
					}
				} else if (!Algorithms.isEmpty(tag.getValue())) {
					node.putTag(editPoiData.getPoiCategory().getDefaultTag(), tag.getValue());

				}
				if(offlineEdit && !Algorithms.isEmpty(tag.getValue())) {
					node.putTag(tag.getKey(), tag.getValue());
				}
			} else if (!Algorithms.isEmpty(tag.getKey()) && !Algorithms.isEmpty(tag.getValue())) {
				node.putTag(tag.getKey(), tag.getValue());
			}
		}
		commitNode(action, node, mOpenstreetmapUtil.getEntityInfo(node.getId()), "", false,
				new CallbackWithObject<Node>() {

					@Override
					public boolean processResult(Node result) {
						if (result != null) {
							OsmEditingPlugin plugin = OsmandPlugin.getPlugin(OsmEditingPlugin.class);
							if (plugin != null && offlineEdit) {
								List<OpenstreetmapPoint> points = plugin.getDBPOI().getOpenstreetmapPoints();
								if (getActivity() instanceof MapActivity && points.size() > 0) {
									OsmPoint point = points.get(points.size() - 1);
									MapActivity mapActivity = (MapActivity) getActivity();
									mapActivity.getContextMenu().showOrUpdate(
											new LatLon(point.getLatitude(), point.getLongitude()),
											plugin.getOsmEditsLayer(mapActivity).getObjectName(point), point);
								}
							}

							if (getActivity() instanceof MapActivity) {
								((MapActivity) getActivity()).getMapView().refreshMap(true);
							}
							dismiss();
						} else {
							OsmEditingPlugin plugin = OsmandPlugin.getPlugin(OsmEditingPlugin.class);
							mOpenstreetmapUtil = plugin.getPoiModificationLocalUtil();
							Button saveButton = (Button) view.findViewById(R.id.saveButton);
							saveButton.setText(mOpenstreetmapUtil instanceof OpenstreetmapRemoteUtil
									? R.string.shared_string_upload : R.string.shared_string_save);
						}

						return false;
					}
				}, getActivity(), mOpenstreetmapUtil);
	}

	@Override
	public void onResume() {
		super.onResume();
		getDialog().setOnKeyListener(new DialogInterface.OnKeyListener() {
			@Override
			public boolean onKey(DialogInterface dialog, int keyCode, KeyEvent event) {
				if (keyCode == android.view.KeyEvent.KEYCODE_BACK) {
					if (event.getAction() == KeyEvent.ACTION_DOWN) {
						return true;
					} else {
						dismissCheckForChanges();
						return true;
					}
				}
				return false;
			}
		});
	}

	private void dismissCheckForChanges() {
		if (editPoiData.hasChangesBeenMade()) {
			new AreYouSureDialogFragment().show(getChildFragmentManager(),
					"AreYouSureDialogFragment");
		} else {
			dismiss();
		}
	}

	@Override
	public void onSaveInstanceState(Bundle outState) {
		outState.putSerializable(TAGS_LIST, (Serializable) editPoiData.getTagValues());
		super.onSaveInstanceState(outState);
	}

	public EditPoiData getEditPoiData() {
		return editPoiData;
	}

	public void setSubCategory(String subCategory) {
		poiTypeEditText.setText(subCategory);
	}

	public static void commitNode(final OsmPoint.Action action,
								  final Node n,
								  final EntityInfo info,
								  final String comment,
								  final boolean closeChangeSet,
								  final CallbackWithObject<Node> postExecute,
								  final Activity activity,
								  final OpenstreetmapUtil openstreetmapUtil) {
		if (info == null && OsmPoint.Action.CREATE != action && openstreetmapUtil instanceof OpenstreetmapRemoteUtil) {
			AccessibleToast.makeText(activity, activity.getResources().getString(R.string.poi_error_info_not_loaded), Toast.LENGTH_LONG).show();
			return;
		}
		new AsyncTask<Void, Void, Node>() {
			ProgressDialog progress;

			@Override
			protected void onPreExecute() {
				progress = ProgressDialog.show(activity, activity.getString(R.string.uploading), activity.getString(R.string.uploading_data));
				super.onPreExecute();
			}

			@Override
			protected Node doInBackground(Void... params) {
				return openstreetmapUtil.commitNodeImpl(action, n, info, comment, closeChangeSet);
			}

			@Override
			protected void onPostExecute(Node result) {
				progress.dismiss();
				if(postExecute != null) {
					postExecute.processResult(result);
				}
			}
		}.execute();
	}

	public void setPoiCategory(PoiCategory type) {
		editPoiData.updateType(type);
		poiTypeEditText.setText(editPoiData.getPoiTypeString());
		setAdapterForPoiTypeEditText();
	}

	private void setAdapterForPoiTypeEditText() {
		final Map<String, PoiType> subCategories = new LinkedHashMap<>();
		PoiCategory ct = editPoiData.getPoiCategory();
		if(ct != null) {
			for (PoiType s : ct.getPoiTypes()) {
				if(!s.isReference() && !s.isNotEditableOsm() && s.getBaseLangType() == null) {
					addMapEntryAdapter(subCategories, s.getTranslation(), s);
					addMapEntryAdapter(subCategories, s.getKeyName().replace('_', ' '), s);
				}
			}
		}
		for (Map.Entry<String, PoiType> s : editPoiData.getAllTranslatedSubTypes().entrySet()) {
			addMapEntryAdapter(subCategories, s.getKey(), s.getValue());
		}
		final ArrayAdapter<Object> adapter;
		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
			adapter = new ArrayAdapter<>(getActivity(),
					R.layout.list_textview, subCategories.keySet().toArray());
		} else {
			TypedValue typedValue = new TypedValue();
			Resources.Theme theme = getActivity().getTheme();
			theme.resolveAttribute(android.R.attr.textColorSecondary, typedValue, true);
			final int textColor = typedValue.data;

			adapter = new ArrayAdapter<Object>(getActivity(),
					R.layout.list_textview, subCategories.keySet().toArray()) {
				@Override
				public View getView(int position, View convertView, ViewGroup parent) {
					final View view = super.getView(position, convertView, parent);
					((TextView) view.findViewById(R.id.textView)).setTextColor(textColor);
					return view;
				}
			};
		}
		adapter.sort(new Comparator<Object>() {
			@Override
			public int compare(Object lhs, Object rhs) {
				return lhs.toString().compareTo(rhs.toString());
			}
		});
		poiTypeEditText.setAdapter(adapter);
		poiTypeEditText.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {

			@Override
			public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
				Object item = parent.getAdapter().getItem(position);
				poiTypeEditText.setText(item.toString());
				setAdapterForPoiTypeEditText();
			}

			@Override
			public void onNothingSelected(AdapterView<?> parent) {
			}
		});

	}

	private void addMapEntryAdapter(final Map<String, PoiType> subCategories, String key, PoiType v) {
		if (!subCategories.containsKey(key.toLowerCase())) {
			subCategories.put(Algorithms.capitalizeFirstLetterAndLowercase(key), v);
		}
	}

	private OsmandApplication getMyApplication() {
		return (OsmandApplication) getActivity().getApplication();
	}

	public static EditPoiDialogFragment createAddPoiInstance(double latitude, double longitude,
															 OsmandApplication application) {
		Node node = new Node(latitude, longitude, -1);
		return createInstance(node, true);
	}

	public static EditPoiDialogFragment createInstance(Node node, boolean isAddingPoi) {
		EditPoiDialogFragment editPoiDialogFragment = new EditPoiDialogFragment();
		Bundle args = new Bundle();
		args.putSerializable(KEY_AMENITY_NODE, node);
		args.putBoolean(IS_ADDING_POI, isAddingPoi);
		editPoiDialogFragment.setArguments(args);
		return editPoiDialogFragment;
	}

	public static void showEditInstance(final Amenity amenity,
										final AppCompatActivity activity) {
		final OsmandSettings settings = ((OsmandApplication) activity.getApplication())
				.getSettings();
		final OpenstreetmapUtil openstreetmapUtilToLoad;
		OsmEditingPlugin plugin = OsmandPlugin.getPlugin(OsmEditingPlugin.class);
		if (//settings.OFFLINE_EDITION.get() ||
				!settings.isInternetConnectionAvailable(true)) {
			openstreetmapUtilToLoad = plugin.getPoiModificationLocalUtil();
		} else {
			openstreetmapUtilToLoad = plugin.getPoiModificationRemoteUtil();
		}
		new AsyncTask<Void, Void, Node>() {
			@Override
			protected Node doInBackground(Void... params) {
				return openstreetmapUtilToLoad.loadNode(amenity);
			}

			protected void onPostExecute(Node n) {
				if (n != null) {
					EditPoiDialogFragment fragment =
							EditPoiDialogFragment.createInstance(n, false);
					fragment.show(activity.getSupportFragmentManager(), TAG);
				} else {
					AccessibleToast.makeText(activity,
							activity.getString(R.string.poi_error_poi_not_found),
							Toast.LENGTH_SHORT).show();
				}
			}
		}.execute();
	}

	public static class MyAdapter extends FragmentPagerAdapter {
		private final Fragment[] fragments = new Fragment[]{new BasicEditPoiFragment(),
				new AdvancedEditPoiFragment()};
		private final String[] titles;

		public MyAdapter(FragmentManager fm, String basicTitle, String extendedTitle) {
			super(fm);
			titles = new String[]{basicTitle, extendedTitle};
		}

		@Override
		public int getCount() {
			return 2;
		}

		@Override
		public Fragment getItem(int position) {
			return fragments[position];
		}

		@Override
		public CharSequence getPageTitle(int position) {
			return titles[position];
		}
	}

	public static class ShowDeleteDialogAsyncTask extends AsyncTask<Amenity, Void, Node> {
		private final OpenstreetmapUtil openstreetmapUtil;
		private final AppCompatActivity activity;

		public ShowDeleteDialogAsyncTask(AppCompatActivity activity) {
			this.activity = activity;
			OsmandSettings settings = ((OsmandApplication) activity.getApplication()).getSettings();
			OsmEditingPlugin plugin = OsmandPlugin.getPlugin(OsmEditingPlugin.class);
			if (settings.OFFLINE_EDITION.get() || !settings.isInternetConnectionAvailable(true)) {
				openstreetmapUtil = plugin.getPoiModificationLocalUtil();
			} else {
				openstreetmapUtil = plugin.getPoiModificationRemoteUtil();
			}
		}

		protected Node doInBackground(Amenity[] params) {
			return openstreetmapUtil.loadNode(params[0]);
		}

		protected void onPostExecute(final Node n) {
			if (n == null) {
				AccessibleToast.makeText(activity, activity.getResources().getString(R.string.poi_error_poi_not_found), Toast.LENGTH_LONG).show();
				return;
			}
			AlertDialog.Builder builder = new AlertDialog.Builder(activity);
			builder.setTitle(R.string.poi_remove_title);
			final EditText comment;
			final CheckBox closeChangesetCheckBox;
			final boolean isLocalEdit = openstreetmapUtil instanceof OpenstreetmapLocalUtil;
			if (isLocalEdit) {
				closeChangesetCheckBox = null;
				comment = null;
			} else {
				LinearLayout ll = new LinearLayout(activity);
				ll.setPadding(16, 2, 16, 0);
				ll.setOrientation(LinearLayout.VERTICAL);
				closeChangesetCheckBox = new CheckBox(activity);
				closeChangesetCheckBox.setText(R.string.close_changeset);
				ll.addView(closeChangesetCheckBox);
				comment = new EditText(activity);
				comment.setText(R.string.poi_remove_title);
				ll.addView(comment);
				builder.setView(ll);
			}
			builder.setNegativeButton(R.string.shared_string_cancel, null);
			builder.setPositiveButton(isLocalEdit ? R.string.shared_string_save : R.string.shared_string_delete, new DialogInterface.OnClickListener() {
				@Override
				public void onClick(DialogInterface dialog, int which) {
					String c = comment == null ? null : comment.getText().toString();
					boolean closeChangeSet = closeChangesetCheckBox != null
							&& closeChangesetCheckBox.isChecked();
					deleteNode(n, c, closeChangeSet);
				}

				
			});
			builder.create().show();
		}
		
		private void deleteNode(final Node n, final String c, final boolean closeChangeSet) {
			final boolean isLocalEdit = openstreetmapUtil instanceof OpenstreetmapLocalUtil;
			commitNode(OsmPoint.Action.DELETE, n, openstreetmapUtil.getEntityInfo(n.getId()), c, closeChangeSet,
					new CallbackWithObject<Node>() {

						@Override
						public boolean processResult(Node result) {
							if (result != null) {
								if (isLocalEdit) {
									AccessibleToast.makeText(activity, R.string.osm_changes_added_to_local_edits,
											Toast.LENGTH_LONG).show();
								} else {
									AccessibleToast.makeText(activity, R.string.poi_remove_success, Toast.LENGTH_LONG)
											.show();
								}
								if (activity instanceof MapActivity) {
									((MapActivity) activity).getMapView().refreshMap(true);
								}
							}
							return false;
						}
					}, activity, openstreetmapUtil);
		}
	}

	public static class SaveWithAdvancedTagsDialogFragment extends DialogFragment {
		@NonNull
		@Override
		public Dialog onCreateDialog(Bundle savedInstanceState) {
			AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
			builder.setTitle(getResources().getString(R.string.are_you_sure))
					.setMessage(getString(R.string.save_poi_without_poi_type_message))
					.setPositiveButton(R.string.shared_string_ok, new DialogInterface.OnClickListener() {
						@Override
						public void onClick(DialogInterface dialog, int which) {
							((EditPoiDialogFragment) getParentFragment()).save();
						}
					})
					.setNegativeButton(R.string.shared_string_cancel, null);
			return builder.create();
		}
	}

	public static class AreYouSureDialogFragment extends DialogFragment {
		@NonNull
		@Override
		public Dialog onCreateDialog(Bundle savedInstanceState) {
			AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
			builder.setTitle(getResources().getString(R.string.are_you_sure))
					.setMessage(getString(R.string.unsaved_changes_will_be_lost))
					.setPositiveButton(R.string.shared_string_ok, new DialogInterface.OnClickListener() {
						@Override
						public void onClick(DialogInterface dialog, int which) {
							((DialogFragment) getParentFragment()).dismiss();
						}
					})
					.setNegativeButton(R.string.shared_string_cancel, null);
			return builder.create();
		}
	} 

	private TextView.OnEditorActionListener mOnEditorActionListener =
			new TextView.OnEditorActionListener() {
				@Override
				public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
					boolean handled = false;
					if (actionId == EditorInfo.IME_ACTION_SEND) {
						trySave();
						handled = true;
					}
					return handled;
				}
			};

	public interface OnFragmentActivatedListener {
		void onFragmentActivated();
	}
}
!@#$%
20190530_040417,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_b06584
package net.osmand.plus.views;

import android.Manifest;
import android.annotation.SuppressLint;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.ColorFilter;
import android.graphics.PointF;
import android.graphics.drawable.Drawable;
import android.os.Build;
import android.support.annotation.NonNull;
import android.support.v4.app.ActivityCompat;
import android.support.v7.app.AlertDialog;
import android.view.MotionEvent;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.ImageButton;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.SeekBar;
import android.widget.TextView;

import net.londatiga.android.ActionItem;
import net.londatiga.android.QuickAction;
import net.osmand.AndroidUtils;
import net.osmand.core.android.MapRendererContext;
import net.osmand.data.LatLon;
import net.osmand.data.RotatedTileBox;
import net.osmand.plus.ApplicationMode;
import net.osmand.plus.OsmAndLocationProvider;
import net.osmand.plus.OsmandApplication;
import net.osmand.plus.OsmandPlugin;
import net.osmand.plus.OsmandSettings;
import net.osmand.plus.OsmandSettings.CommonPreference;
import net.osmand.plus.R;
import net.osmand.plus.TargetPointsHelper;
import net.osmand.plus.activities.MapActivity;
import net.osmand.plus.activities.search.SearchAddressFragment;
import net.osmand.plus.dashboard.DashboardOnMap.DashboardType;
import net.osmand.plus.mapcontextmenu.other.MapRouteInfoMenu;
import net.osmand.plus.routing.RoutingHelper;
import net.osmand.plus.views.corenative.NativeCoreContext;

import java.util.ArrayList;
import java.util.List;

import gnu.trove.list.array.TIntArrayList;

public class MapControlsLayer extends OsmandMapLayer {

	private static final int TIMEOUT_TO_SHOW_BUTTONS = 7000;
	public static final int REQUEST_ADDRESS_SELECT = 2;
	private static final int REQUEST_LOCATION_FOR_NAVIGATION_PERMISSION = 200;

	public MapHudButton createHudButton(View iv, int resId) {
		MapHudButton mc = new MapHudButton();
		mc.iv = iv;
		mc.resId = resId;
		return mc;
	}

	private List<MapHudButton> controls = new ArrayList<>();
	private final MapActivity mapActivity;
	private int shadowColor = -1;
	// private RulerControl rulerControl;
	// private List<MapControls> allControls = new ArrayList<MapControls>();

	private SeekBar transparencyBar;
	private LinearLayout transparencyBarLayout;
	private static CommonPreference<Integer> settingsToTransparency;
	private OsmandSettings settings;

	private MapRouteInfoMenu mapRouteInfoMenu;
	private MapHudButton backToLocationControl;
	private MapHudButton menuControl;
	private MapHudButton compassHud;
	private float cachedRotate = 0;
	private ImageView appModeIcon;
	private TextView zoomText;
	private OsmandMapTileView mapView;
	private OsmandApplication app;
	private View mapAppModeShadow;
	private MapHudButton routePlanningBtn;
	private long touchEvent;
	private MapHudButton mapZoomOut;
	private MapHudButton mapZoomIn;
	private MapHudButton layersHud;
	private long lastZoom;

	public MapControlsLayer(MapActivity activity) {
		this.mapActivity = activity;
		app = activity.getMyApplication();
		settings = activity.getMyApplication().getSettings();
		mapView = mapActivity.getMapView();
	}

	public MapRouteInfoMenu getMapRouteInfoMenu() {
		return mapRouteInfoMenu;
	}

	@Override
	public boolean drawInScreenPixels() {
		return true;
	}

	@Override
	public void initLayer(final OsmandMapTileView view) {
		initTopControls();
		initTransparencyBar();
		initZooms();
		initDasboardRelatedControls();
		updateControls(view.getCurrentRotatedTileBox(), null);
	}

	public void initDasboardRelatedControls() {
		initControls();
		initRouteControls();
	}

	private class CompassDrawable extends Drawable {

		private Drawable original;

		public CompassDrawable(Drawable original) {
			this.original = original;
		}

		@Override
		public void draw(Canvas canvas) {
			canvas.save();
			canvas.rotate(cachedRotate, getIntrinsicWidth() / 2, getIntrinsicHeight() / 2);
			original.draw(canvas);
			canvas.restore();
		}

		@Override
		public int getMinimumHeight() {
			return original.getMinimumHeight();
		}

		@Override
		public int getMinimumWidth() {
			return original.getMinimumWidth();
		}

		@Override
		public int getIntrinsicHeight() {
			return original.getIntrinsicHeight();
		}

		@Override
		public int getIntrinsicWidth() {
			return original.getIntrinsicWidth();
		}

		@Override
		public void setChangingConfigurations(int configs) {
			super.setChangingConfigurations(configs);
			original.setChangingConfigurations(configs);
		}

		@Override
		public void setBounds(int left, int top, int right, int bottom) {
			super.setBounds(left, top, right, bottom);
			original.setBounds(left, top, right, bottom);
		}

		@Override
		public void setAlpha(int alpha) {
			original.setAlpha(alpha);
		}

		@Override
		public void setColorFilter(ColorFilter cf) {
			original.setColorFilter(cf);
		}

		@Override
		public int getOpacity() {
			return original.getOpacity();
		}
	}

	private void initTopControls() {
		View configureMap = mapActivity.findViewById(R.id.map_layers_button);
		layersHud = createHudButton(configureMap, R.drawable.map_layer_dark)
				.setIconsId(R.drawable.map_layer_dark, R.drawable.map_layer_night)
				.setBg(R.drawable.btn_inset_circle_trans, R.drawable.btn_inset_circle_night);
		controls.add(layersHud);
		configureMap.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				mapActivity.getDashboard().setDashboardVisibility(true, DashboardType.CONFIGURE_MAP);
			}
		});

		View compass = mapActivity.findViewById(R.id.map_compass_button);
		compassHud = createHudButton(compass, R.drawable.map_compass).setIconColorId(0).
				setBg(R.drawable.btn_inset_circle_trans, R.drawable.btn_inset_circle_night);
		compassHud.compass = true;
		controls.add(compassHud);
		compass.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				mapActivity.getMapViewTrackingUtilities().switchRotateMapMode();
			}
		});

	}

	private void initRouteControls() {
		mapRouteInfoMenu = new MapRouteInfoMenu(mapActivity, this);
	}

	public void updateRouteButtons(View main, boolean routeInfo) {
		boolean nightMode = mapActivity.getMyApplication().getDaynightHelper().isNightModeForMapControls();
		ImageView cancelRouteButton = (ImageView) main.findViewById(R.id.map_cancel_route_button);
		cancelRouteButton.setImageDrawable(app.getIconsCache().getContentIcon(R.drawable.map_action_cancel, !nightMode));
		AndroidUtils.setBackground(mapActivity, cancelRouteButton, nightMode, R.drawable.dashboard_button_light, R.drawable.dashboard_button_dark);
		cancelRouteButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				clickRouteCancel();
			}
		});

		ImageView waypointsButton = (ImageView) main.findViewById(R.id.map_waypoints_route_button);
		waypointsButton.setImageDrawable(app.getIconsCache().getContentIcon(R.drawable.map_action_waypoints, !nightMode));
		AndroidUtils.setBackground(mapActivity, waypointsButton, nightMode, R.drawable.dashboard_button_light, R.drawable.dashboard_button_dark);
		waypointsButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				clickRouteWaypoints();
			}
		});

		ImageView options = (ImageView) main.findViewById(R.id.map_options_route_button);
		options.setImageDrawable(!routeInfo ? app.getIconsCache().getIcon(R.drawable.map_action_settings,
				R.color.osmand_orange) : app.getIconsCache().getContentIcon(R.drawable.map_action_settings, !nightMode));
		AndroidUtils.setBackground(mapActivity, options, nightMode, R.drawable.dashboard_button_light, R.drawable.dashboard_button_dark);
		options.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				clickRouteParams();
			}
		});

		TextView routeGoButton = (TextView) main.findViewById(R.id.map_go_route_button);
		routeGoButton.setCompoundDrawablesWithIntrinsicBounds(app.getIconsCache().getIcon(R.drawable.map_start_navigation, R.color.color_myloc_distance), null, null, null);
		routeGoButton.setText(mapActivity.getString(R.string.shared_string_go));
		AndroidUtils.setTextSecondaryColor(mapActivity, routeGoButton, nightMode);
		AndroidUtils.setBackground(mapActivity, routeGoButton, nightMode, R.drawable.dashboard_button_light, R.drawable.dashboard_button_dark);
		routeGoButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				clickRouteGo();
			}
		});
	}

	public void setControlsClickable(boolean clickable) {
		for (MapHudButton mb : controls) {
			mb.iv.setClickable(clickable);
		}
	}

	private TargetPointsHelper getTargets() {
		return mapActivity.getMyApplication().getTargetPointsHelper();
	}

	protected void clickRouteParams() {
		mapActivity.getMapActions().openRoutePreferencesDialog();
	}

	protected void clickRouteWaypoints() {
		if (getTargets().checkPointToNavigateShort()) {
			mapActivity.getMapActions().openIntermediatePointsDialog();
		}
	}

	protected void clickRouteCancel() {
		mapRouteInfoMenu.hide();
		if (mapActivity.getRoutingHelper().isFollowingMode()) {
			mapActivity.getMapActions().stopNavigationActionConfirm();
		} else {
			mapActivity.getMapActions().stopNavigationWithoutConfirm();
		}
	}

	protected void clickRouteGo() {
		mapRouteInfoMenu.hide();
		startNavigation();
	}

	public void showRouteInfoControlDialog() {
		mapRouteInfoMenu.showHideMenu();
	}

	public void showDialog() {
		mapRouteInfoMenu.setShowMenu();
	}

	private void initControls() {
		View backToLocation = mapActivity.findViewById(R.id.map_my_location_button);
		backToLocationControl = createHudButton(backToLocation, R.drawable.map_my_location)
				.setBg(R.drawable.btn_circle_blue);
		controls.add(backToLocationControl);

		backToLocation.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				if (OsmAndLocationProvider.isLocationPermissionAvailable(mapActivity)) {
					mapActivity.getMapViewTrackingUtilities().backToLocationImpl();
				} else {
					ActivityCompat.requestPermissions(mapActivity,
							new String[]{Manifest.permission.ACCESS_FINE_LOCATION},
							OsmAndLocationProvider.REQUEST_LOCATION_PERMISSION);
				}
			}
		});
		controls.add(createHudButton(mapActivity.findViewById(R.id.map_app_mode_shadow), 0).setBg(
				R.drawable.btn_round_trans, R.drawable.btn_round_transparent));
		View backToMenuButton = mapActivity.findViewById(R.id.map_menu_button);

		final boolean dash = settings.SHOW_DASHBOARD_ON_MAP_SCREEN.get();
		menuControl = createHudButton(backToMenuButton,
				!dash ? R.drawable.map_drawer : R.drawable.map_dashboard).setBg(
				R.drawable.btn_round, R.drawable.btn_round_night);
		controls.add(menuControl);
		backToMenuButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				if (dash) {
					mapActivity.getDashboard().setDashboardVisibility(true, DashboardType.DASHBOARD);
				} else {
					mapActivity.openDrawer();
				}
			}
		});
		mapAppModeShadow = mapActivity.findViewById(R.id.map_app_mode_shadow);
		mapAppModeShadow.setOnClickListener(new View.OnClickListener() {

			@Override
			public void onClick(View v) {
				onApplicationModePress(v);
			}
		});
		appModeIcon = (ImageView) mapActivity.findViewById(R.id.map_app_mode_icon);
		zoomText = (TextView) mapActivity.findViewById(R.id.map_app_mode_text);

		View routePlanButton = mapActivity.findViewById(R.id.map_route_info_button);
		routePlanningBtn = createHudButton(routePlanButton, R.drawable.map_directions).setBg(
				R.drawable.btn_round, R.drawable.btn_round_night);
		controls.add(routePlanningBtn);
		routePlanButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				if (OsmAndLocationProvider.isLocationPermissionAvailable(mapActivity)) {
					onNavigationClick();
				} else {
					ActivityCompat.requestPermissions(mapActivity,
							new String[]{Manifest.permission.ACCESS_FINE_LOCATION},
							REQUEST_LOCATION_FOR_NAVIGATION_PERMISSION);
				}
			}
		});
	}

	public void doNavigate() {
		mapRouteInfoMenu.hide();
		startNavigation();
	}

	private void onNavigationClick() {
		RoutingHelper routingHelper = mapActivity.getRoutingHelper();
		if (!routingHelper.isFollowingMode() && !routingHelper.isRoutePlanningMode()) {
			mapActivity.getMapActions().enterRoutePlanningMode(null, null);
		} else {
			showRouteInfoControlDialog();
		}
	}


	public void switchToRouteFollowingLayout() {
		touchEvent = 0;
		mapActivity.getMyApplication().getRoutingHelper().setRoutePlanningMode(false);
		mapActivity.getMapViewTrackingUtilities().switchToRoutePlanningMode();
		mapActivity.refreshMap();
	}

	public boolean switchToRoutePlanningLayout() {
		if (!mapActivity.getRoutingHelper().isRoutePlanningMode() && mapActivity.getRoutingHelper().isFollowingMode()) {
			mapActivity.getRoutingHelper().setRoutePlanningMode(true);
			mapActivity.getMapViewTrackingUtilities().switchToRoutePlanningMode();
			mapActivity.refreshMap();
			return true;
		}
		return false;
	}

	private void initZooms() {
		final OsmandMapTileView view = mapActivity.getMapView();
		View zoomInButton = mapActivity.findViewById(R.id.map_zoom_in_button);
		mapZoomIn = createHudButton(zoomInButton, R.drawable.map_zoom_in).
				setIconsId(R.drawable.map_zoom_in, R.drawable.map_zoom_in_night).setRoundTransparent();
		controls.add(mapZoomIn);
		zoomInButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				if (view.isZooming()) {
					mapActivity.changeZoom(2, System.currentTimeMillis());
				} else {
					mapActivity.changeZoom(1, System.currentTimeMillis());
				}

			}
		});
		final View.OnLongClickListener listener = MapControlsLayer.getOnClickMagnifierListener(view);
		zoomInButton.setOnLongClickListener(listener);
		View zoomOutButton = mapActivity.findViewById(R.id.map_zoom_out_button);
		mapZoomOut = createHudButton(zoomOutButton, R.drawable.map_zoom_out).
				setIconsId(R.drawable.map_zoom_out, R.drawable.map_zoom_out_night).setRoundTransparent();
		controls.add(mapZoomOut);
		zoomOutButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				mapActivity.changeZoom(-1, System.currentTimeMillis());
			}
		});
		zoomOutButton.setOnLongClickListener(listener);
	}

	public void startNavigation() {
		OsmandApplication app = mapActivity.getMyApplication();
		RoutingHelper routingHelper = app.getRoutingHelper();
		if (routingHelper.isFollowingMode()) {
			switchToRouteFollowingLayout();
		} else {
			if (!app.getTargetPointsHelper().checkPointToNavigateShort()) {
				mapRouteInfoMenu.show();
			} else {
				touchEvent = 0;
				mapActivity.getMapViewTrackingUtilities().backToLocationImpl();
				app.getSettings().FOLLOW_THE_ROUTE.set(true);
				routingHelper.setFollowingMode(true);
				routingHelper.setRoutePlanningMode(false);
				mapActivity.getMapViewTrackingUtilities().switchToRoutePlanningMode();
				app.getRoutingHelper().notifyIfRouteIsCalculated();
				routingHelper.setCurrentLocation(app.getLocationProvider().getLastKnownLocation(), false);
			}
		}
	}

	@Override
	public void destroyLayer() {
		controls.clear();
	}

	@Override
	public void onDraw(Canvas canvas, RotatedTileBox tileBox, DrawSettings nightMode) {
		updateControls(tileBox, nightMode);
	}

	@SuppressWarnings("deprecation")
	private void updateControls(@NonNull RotatedTileBox tileBox, DrawSettings nightMode) {
		boolean isNight = nightMode != null && nightMode.isNightMode();
		int shadw = isNight ? Color.TRANSPARENT : Color.WHITE;
		int textColor = isNight ? mapActivity.getResources().getColor(R.color.widgettext_night) : Color.BLACK;
		if (shadowColor != shadw) {
			shadowColor = shadw;
			// TODOnightMode
			// updatextColor(textColor, shadw, rulerControl, zoomControls, mapMenuControls);
		}
		// default buttons
		boolean routePlanningMode = false;
		RoutingHelper rh = mapActivity.getRoutingHelper();
		if (rh.isRoutePlanningMode()) {
			routePlanningMode = true;
		} else if ((rh.isRouteCalculated() || rh.isRouteBeingCalculated()) && !rh.isFollowingMode()) {
			routePlanningMode = true;
		}
		boolean routeFollowingMode = !routePlanningMode && rh.isFollowingMode();
		boolean dialogOpened = mapRouteInfoMenu.isVisible();
		boolean showRouteCalculationControls = routePlanningMode ||
				((System.currentTimeMillis() - touchEvent < TIMEOUT_TO_SHOW_BUTTONS) && routeFollowingMode);
		updateMyLocation(rh, dialogOpened);
		boolean showButtons = (showRouteCalculationControls || !routeFollowingMode);
		routePlanningBtn.setIconResId(routeFollowingMode ? R.drawable.ic_action_gabout_dark : R.drawable.map_directions);
		if (routePlanningMode || routeFollowingMode) {
			routePlanningBtn.setIconResId(R.drawable.map_start_navigation);
			routePlanningBtn.setIconColorId(R.color.color_myloc_distance);
		} else {
			routePlanningBtn.setIconResId(R.drawable.map_directions);
			routePlanningBtn.resetIconColors();
		}
		routePlanningBtn.updateVisibility(showButtons);
		menuControl.updateVisibility(showButtons);

		mapZoomIn.updateVisibility(!dialogOpened);
		mapZoomOut.updateVisibility(!dialogOpened);
		compassHud.updateVisibility(!dialogOpened);
		layersHud.updateVisibility(!dialogOpened);

		if (routeFollowingMode || routePlanningMode) {
			mapAppModeShadow.setVisibility(View.GONE);
		} else {
			if (mapView.isZooming()) {
				lastZoom = System.currentTimeMillis();
			}
			mapAppModeShadow.setVisibility(View.VISIBLE);
			//if (!mapView.isZooming() || !OsmandPlugin.isDevelopment()) {
			if ((System.currentTimeMillis() - lastZoom > 1000) || !OsmandPlugin.isDevelopment()) {
				zoomText.setVisibility(View.GONE);
				appModeIcon.setVisibility(View.VISIBLE);
				appModeIcon.setImageDrawable(
						app.getIconsCache().getIcon(
								settings.getApplicationMode().getSmallIconDark(), !isNight));
			} else {
				appModeIcon.setVisibility(View.GONE);
				zoomText.setVisibility(View.VISIBLE);
				zoomText.setTextColor(textColor);
				zoomText.setText(getZoomLevel(tileBox));
			}
		}

		mapRouteInfoMenu.setVisible(showRouteCalculationControls);
		updateCompass(isNight);

		for (MapHudButton mc : controls) {
			mc.update(mapActivity.getMyApplication(), nightMode != null && nightMode.isNightMode());
		}
	}

	private void updateCompass(boolean isNight) {
		float mapRotate = mapActivity.getMapView().getRotate();
		if (mapRotate != cachedRotate) {
			cachedRotate = mapRotate;
			// Aply animation to image view
			compassHud.iv.invalidate();
		}
		if (settings.ROTATE_MAP.get() == OsmandSettings.ROTATE_MAP_NONE) {
			compassHud.setIconResId(isNight ? R.drawable.map_compass_niu_white : R.drawable.map_compass_niu);
		} else if (settings.ROTATE_MAP.get() == OsmandSettings.ROTATE_MAP_BEARING) {
			compassHud.setIconResId(isNight ? R.drawable.map_compass_bearing_white : R.drawable.map_compass_bearing);
		} else {
			compassHud.setIconResId(isNight ? R.drawable.map_compass_white : R.drawable.map_compass);
		}
	}

	private void updateMyLocation(RoutingHelper rh, boolean dialogOpened) {
		boolean enabled = mapActivity.getMyApplication().getLocationProvider().getLastKnownLocation() != null;
		boolean tracked = mapActivity.getMapViewTrackingUtilities().isMapLinkedToLocation();

		if (!enabled) {
			backToLocationControl.setBg(R.drawable.btn_circle, R.drawable.btn_circle_night);
			backToLocationControl.setIconColorId(R.color.icon_color, 0);
		} else if (tracked) {
			backToLocationControl.setBg(R.drawable.btn_circle, R.drawable.btn_circle_night);
			backToLocationControl.setIconColorId(R.color.color_myloc_distance);
		} else {
			backToLocationControl.setIconColorId(0);
			backToLocationControl.setBg(R.drawable.btn_circle_blue);
		}
		boolean visible = !(tracked && rh.isFollowingMode());
		backToLocationControl.updateVisibility(visible && !dialogOpened);
	}


	public boolean onSingleTap(PointF point, RotatedTileBox tileBox) {
		return mapRouteInfoMenu.onSingleTap(point, tileBox);
	}

	@Override
	public boolean onTouchEvent(MotionEvent event, RotatedTileBox tileBox) {
		touchEvent = System.currentTimeMillis();
		RoutingHelper rh = mapActivity.getRoutingHelper();
		if (rh.isFollowingMode()) {
			mapActivity.refreshMap();
		}
		return false;
	}

	// /////////////// Transparency bar /////////////////////////
	private void initTransparencyBar() {
		transparencyBarLayout = (LinearLayout) mapActivity.findViewById(R.id.map_transparency_layout);
		transparencyBar = (SeekBar) mapActivity.findViewById(R.id.map_transparency_seekbar);
		transparencyBar.setMax(255);
		if (settingsToTransparency != null) {
			transparencyBar.setProgress(settingsToTransparency.get());
			transparencyBarLayout.setVisibility(View.VISIBLE);
		} else {
			transparencyBarLayout.setVisibility(View.GONE);
		}
		transparencyBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {

			@Override
			public void onStopTrackingTouch(SeekBar seekBar) {
			}

			@Override
			public void onStartTrackingTouch(SeekBar seekBar) {
			}

			@Override
			public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
				if (settingsToTransparency != null) {
					settingsToTransparency.set(progress);
					mapActivity.getMapView().refreshMap();
				}
			}
		});
		ImageButton imageButton = (ImageButton) mapActivity.findViewById(R.id.map_transparency_hide);
		imageButton.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
				transparencyBarLayout.setVisibility(View.GONE);
				hideTransparencyBar(settingsToTransparency);
			}
		});
	}

	public void showTransparencyBar(CommonPreference<Integer> transparenPreference) {
		MapControlsLayer.settingsToTransparency = transparenPreference;
		transparencyBarLayout.setVisibility(View.VISIBLE);
		transparencyBar.setProgress(transparenPreference.get());
	}

	public void hideTransparencyBar(CommonPreference<Integer> transparentPreference) {
		if (settingsToTransparency == transparentPreference) {
			transparencyBarLayout.setVisibility(View.GONE);
			settingsToTransparency = null;
		}
	}

	private class MapHudButton {
		View iv;
		int bgDark;
		int bgLight;
		int resId;
		int resLightId;
		int resDarkId;
		int resClrLight = R.color.icon_color;
		int resClrDark = 0;


		boolean nightMode = false;
		boolean f = true;
		boolean compass;

		public MapHudButton setRoundTransparent() {
			setBg(R.drawable.btn_circle_trans, R.drawable.btn_circle_night);
			return this;
		}


		public MapHudButton setBg(int dayBg, int nightBg) {
			if (bgDark == nightBg && dayBg == bgLight) {
				return this;
			}
			bgDark = nightBg;
			bgLight = dayBg;
			f = true;
			return this;
		}

		public boolean updateVisibility(boolean visible) {
			if (visible != (iv.getVisibility() == View.VISIBLE)) {
				if (visible) {
					iv.setVisibility(View.VISIBLE);
				} else {
					iv.setVisibility(View.GONE);
				}
				iv.invalidate();
				return true;
			}
			return false;
		}

		public MapHudButton setBg(int bg) {
			if (bgDark == bg && bg == bgLight) {
				return this;
			}
			bgDark = bg;
			bgLight = bg;
			f = true;
			return this;
		}

		public boolean setIconResId(int resId) {
			if (this.resId == resId) {
				return false;
			}
			this.resId = resId;
			f = true;
			return true;
		}

		public void resetIconColors() {
			resClrLight = R.color.icon_color;
			resClrDark = 0;
		}

		public MapHudButton setIconColorId(int clr) {
			if (resClrLight == clr && resClrDark == clr) {
				return this;
			}
			resClrLight = clr;
			resClrDark = clr;
			f = true;
			return this;
		}

		public MapHudButton setIconsId(int icnLight, int icnDark) {
			if (resLightId == icnLight && resDarkId == icnDark) {
				return this;
			}
			resLightId = icnLight;
			resDarkId = icnDark;
			f = true;
			return this;
		}

		public MapHudButton setIconColorId(int clrLight, int clrDark) {
			if (resClrLight == clrLight && resClrDark == clrDark) {
				return this;
			}
			resClrLight = clrLight;
			resClrDark = clrDark;
			f = true;
			return this;
		}

		@SuppressLint("NewApi")
		@SuppressWarnings("deprecation")
		public void update(OsmandApplication ctx, boolean night) {
			if (nightMode == night && !f) {
				return;
			}
			f = false;
			nightMode = night;
			if (bgDark != 0 && bgLight != 0) {
				if (Build.VERSION.SDK_INT > Build.VERSION_CODES.LOLLIPOP) {
					iv.setBackground(ctx.getResources().getDrawable(night ? bgDark : bgLight,
							mapActivity.getTheme()));
				} else {
					iv.setBackgroundDrawable(ctx.getResources().getDrawable(night ? bgDark : bgLight));
				}
			}
			Drawable d = null;
			if (resDarkId != 0 && nightMode) {
				d = ctx.getIconsCache().getIcon(resDarkId);
			} else if (resLightId != 0 && !nightMode) {
				d = ctx.getIconsCache().getIcon(resLightId);
			} else if (resId != 0) {
				d = ctx.getIconsCache().getIcon(resId, nightMode ? resClrDark : resClrLight);
			}

			if (iv instanceof ImageView) {
				if (compass) {
					((ImageView) iv).setImageDrawable(new CompassDrawable(d));
				} else {
					((ImageView) iv).setImageDrawable(d);
				}
			} else if (iv instanceof TextView) {
				((TextView) iv).setCompoundDrawablesWithIntrinsicBounds(
						d, null, null, null);
			}
		}

	}

	private void onApplicationModePress(View v) {
		final QuickAction mQuickAction = new QuickAction(v);
		mQuickAction.setOnAnchorOnTop(true);
		List<ApplicationMode> vls = ApplicationMode.values(mapActivity.getMyApplication().getSettings());
		final ApplicationMode[] modes = vls.toArray(new ApplicationMode[vls.size()]);
		Drawable[] icons = new Drawable[vls.size()];
		int[] values = new int[vls.size()];
		for (int k = 0; k < modes.length; k++) {
			icons[k] = app.getIconsCache().getIcon(modes[k].getSmallIconDark(), R.color.icon_color);
			values[k] = modes[k].getStringResource();
		}
		for (int i = 0; i < modes.length; i++) {
			final ActionItem action = new ActionItem();
			action.setTitle(mapActivity.getResources().getString(values[i]));
			action.setIcon(icons[i]);
			final int j = i;
			action.setOnClickListener(new OnClickListener() {
				@Override
				public void onClick(View v) {
					mapActivity.getMyApplication().getSettings().APPLICATION_MODE.set(modes[j]);
					mQuickAction.dismiss();
				}
			});
			mQuickAction.addActionItem(action);
		}
		mQuickAction.setAnimStyle(QuickAction.ANIM_AUTO);
		mQuickAction.show();
	}

	private String getZoomLevel(@NonNull RotatedTileBox tb) {
		String zoomText = tb.getZoom() + "";
		double frac = tb.getMapDensity();
		if (frac != 0) {
			int ifrac = (int) (frac * 10);
			zoomText += " ";
			zoomText += Math.abs(ifrac) / 10;
			if (ifrac % 10 != 0) {
				zoomText += "." + Math.abs(ifrac) % 10;
			}
		}
		return zoomText;
	}

	public static View.OnLongClickListener getOnClickMagnifierListener(final OsmandMapTileView view) {
		return new View.OnLongClickListener() {

			@Override
			public boolean onLongClick(View notUseCouldBeNull) {
				final OsmandSettings.OsmandPreference<Float> mapDensity = view.getSettings().MAP_DENSITY;
				final AlertDialog.Builder bld = new AlertDialog.Builder(view.getContext());
				int p = (int) (mapDensity.get() * 100);
				final TIntArrayList tlist = new TIntArrayList(new int[]{20, 25, 33, 50, 75, 100, 150, 200, 300, 400});
				final List<String> values = new ArrayList<>();
				int i = -1;
				for (int k = 0; k <= tlist.size(); k++) {
					final boolean end = k == tlist.size();
					if (i == -1) {
						if ((end || p < tlist.get(k))) {
							values.add(p + " %");
							i = k;
						} else if (p == tlist.get(k)) {
							i = k;
						}

					}
					if (k < tlist.size()) {
						values.add(tlist.get(k) + " %");
					}
				}
				if (values.size() != tlist.size()) {
					tlist.insert(i, p);
				}

				bld.setTitle(R.string.map_magnifier);
				bld.setSingleChoiceItems(values.toArray(new String[values.size()]), i,
						new DialogInterface.OnClickListener() {
							@Override
							public void onClick(DialogInterface dialog, int which) {
								int p = tlist.get(which);
								mapDensity.set(p / 100.0f);
								view.setComplexZoom(view.getZoom(), view.getSettingsMapDensity());
								MapRendererContext mapContext = NativeCoreContext.getMapRendererContext();
								if (mapContext != null) {
									mapContext.updateMapSettings();
								}
								dialog.dismiss();
							}
						});
				bld.show();
				return true;
			}
		};
	}

	public void onActivityResult(int requestCode, int resultCode, Intent data) {
		if (requestCode == REQUEST_ADDRESS_SELECT && resultCode == SearchAddressFragment.SELECT_ADDRESS_POINT_RESULT_OK) {
			String name = data.getStringExtra(SearchAddressFragment.SELECT_ADDRESS_POINT_INTENT_KEY);
			boolean target = data.getBooleanExtra(MapRouteInfoMenu.TARGET_SELECT, true);
			LatLon latLon = new LatLon(
					data.getDoubleExtra(SearchAddressFragment.SELECT_ADDRESS_POINT_LAT, 0),
					data.getDoubleExtra(SearchAddressFragment.SELECT_ADDRESS_POINT_LON, 0));
			if (name != null) {
				mapRouteInfoMenu.selectAddress(name, latLon, target);
			} else {
				mapRouteInfoMenu.selectAddress("", latLon, target);
			}
		}
	}

	public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
		if (requestCode == REQUEST_LOCATION_FOR_NAVIGATION_PERMISSION
				&& grantResults[0] == PackageManager.PERMISSION_GRANTED) {
			onNavigationClick();
		}
	}
}
!@#$%
20190530_040417,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_a06584
package net.osmand.plus.views;

import android.Manifest;
import android.annotation.SuppressLint;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.ColorFilter;
import android.graphics.PointF;
import android.graphics.drawable.Drawable;
import android.os.Build;
import android.support.annotation.NonNull;
import android.support.v4.app.ActivityCompat;
import android.support.v4.content.ContextCompat;
import android.support.v7.app.AlertDialog;
import android.view.MotionEvent;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.ImageButton;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.SeekBar;
import android.widget.TextView;

import net.londatiga.android.ActionItem;
import net.londatiga.android.QuickAction;
import net.osmand.AndroidUtils;
import net.osmand.core.android.MapRendererContext;
import net.osmand.data.LatLon;
import net.osmand.data.RotatedTileBox;
import net.osmand.plus.ApplicationMode;
import net.osmand.plus.OsmAndLocationProvider;
import net.osmand.plus.OsmandApplication;
import net.osmand.plus.OsmandPlugin;
import net.osmand.plus.OsmandSettings;
import net.osmand.plus.OsmandSettings.CommonPreference;
import net.osmand.plus.R;
import net.osmand.plus.TargetPointsHelper;
import net.osmand.plus.activities.MapActivity;
import net.osmand.plus.activities.search.SearchAddressFragment;
import net.osmand.plus.dashboard.DashboardOnMap.DashboardType;
import net.osmand.plus.mapcontextmenu.other.MapRouteInfoMenu;
import net.osmand.plus.mapcontextmenu.other.MapRoutePreferencesControl;
import net.osmand.plus.routing.RoutingHelper;
import net.osmand.plus.views.corenative.NativeCoreContext;

import java.util.ArrayList;
import java.util.List;

import gnu.trove.list.array.TIntArrayList;

public class MapControlsLayer extends OsmandMapLayer {

	private static final int TIMEOUT_TO_SHOW_BUTTONS = 7000;
	public static final int REQUEST_ADDRESS_SELECT = 2;
	private static final int REQUEST_LOCATION_FOR_NAVIGATION_PERMISSION = 200;

	public MapHudButton createHudButton(View iv, int resId) {
		MapHudButton mc = new MapHudButton();
		mc.iv = iv;
		mc.resId = resId;
		return mc;
	}

	private List<MapHudButton> controls = new ArrayList<>();
	private final MapActivity mapActivity;
	private int shadowColor = -1;
	// private RulerControl rulerControl;
	// private List<MapControls> allControls = new ArrayList<MapControls>();

	private SeekBar transparencyBar;
	private LinearLayout transparencyBarLayout;
	private static CommonPreference<Integer> settingsToTransparency;
	private OsmandSettings settings;

	private MapRoutePreferencesControl optionsRouteControlDialog;
	private MapRouteInfoMenu mapRouteInfoMenu;
	private MapHudButton backToLocationControl;
	private MapHudButton menuControl;
	private MapHudButton compassHud;
	private float cachedRotate = 0;
	private ImageView appModeIcon;
	private TextView zoomText;
	private OsmandMapTileView mapView;
	private OsmandApplication app;
	private View mapAppModeShadow;
	private MapHudButton routePlanningBtn;
	private long touchEvent;
	private MapHudButton mapZoomOut;
	private MapHudButton mapZoomIn;
	private MapHudButton layersHud;
	private long lastZoom;

	public MapControlsLayer(MapActivity activity) {
		this.mapActivity = activity;
		app = activity.getMyApplication();
		settings = activity.getMyApplication().getSettings();
		mapView = mapActivity.getMapView();
	}

	public MapRouteInfoMenu getMapRouteInfoMenu() {
		return mapRouteInfoMenu;
	}

	@Override
	public boolean drawInScreenPixels() {
		return true;
	}

	@Override
	public void initLayer(final OsmandMapTileView view) {
		initTopControls();
		initTransparencyBar();
		initZooms();
		initDasboardRelatedControls();
		updateControls(view.getCurrentRotatedTileBox(), null);
	}

	public void initDasboardRelatedControls() {
		initControls();
		initRouteControls();
	}

	private class CompassDrawable extends Drawable {

		private Drawable original;

		public CompassDrawable(Drawable original) {
			this.original = original;
		}

		@Override
		public void draw(Canvas canvas) {
			canvas.save();
			canvas.rotate(cachedRotate, getIntrinsicWidth() / 2, getIntrinsicHeight() / 2);
			original.draw(canvas);
			canvas.restore();
		}

		@Override
		public int getMinimumHeight() {
			return original.getMinimumHeight();
		}

		@Override
		public int getMinimumWidth() {
			return original.getMinimumWidth();
		}

		@Override
		public int getIntrinsicHeight() {
			return original.getIntrinsicHeight();
		}

		@Override
		public int getIntrinsicWidth() {
			return original.getIntrinsicWidth();
		}

		@Override
		public void setChangingConfigurations(int configs) {
			super.setChangingConfigurations(configs);
			original.setChangingConfigurations(configs);
		}

		@Override
		public void setBounds(int left, int top, int right, int bottom) {
			super.setBounds(left, top, right, bottom);
			original.setBounds(left, top, right, bottom);
		}

		@Override
		public void setAlpha(int alpha) {
			original.setAlpha(alpha);
		}

		@Override
		public void setColorFilter(ColorFilter cf) {
			original.setColorFilter(cf);
		}

		@Override
		public int getOpacity() {
			return original.getOpacity();
		}
	}

	private void initTopControls() {
		View configureMap = mapActivity.findViewById(R.id.map_layers_button);
		layersHud = createHudButton(configureMap, R.drawable.map_layer_dark)
				.setIconsId(R.drawable.map_layer_dark, R.drawable.map_layer_night)
				.setBg(R.drawable.btn_inset_circle_trans, R.drawable.btn_inset_circle_night);
		controls.add(layersHud);
		configureMap.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				mapActivity.getDashboard().setDashboardVisibility(true, DashboardType.CONFIGURE_MAP);
			}
		});

		View compass = mapActivity.findViewById(R.id.map_compass_button);
		compassHud = createHudButton(compass, R.drawable.map_compass).setIconColorId(0).
				setBg(R.drawable.btn_inset_circle_trans, R.drawable.btn_inset_circle_night);
		compassHud.compass = true;
		controls.add(compassHud);
		compass.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				mapActivity.getMapViewTrackingUtilities().switchRotateMapMode();
			}
		});

	}

	private void initRouteControls() {
		mapRouteInfoMenu = new MapRouteInfoMenu(mapActivity, this);
		optionsRouteControlDialog = new MapRoutePreferencesControl(mapActivity, this);
	}

	public void updateRouteButtons(View main, boolean routeInfo) {
		boolean nightMode = mapActivity.getMyApplication().getDaynightHelper().isNightMode();
		ImageView cancelRouteButton = (ImageView) main.findViewById(R.id.map_cancel_route_button);
		cancelRouteButton.setImageDrawable(app.getIconsCache().getContentIcon(R.drawable.map_action_cancel, !nightMode));
		AndroidUtils.setBackground(mapActivity, cancelRouteButton, nightMode, R.drawable.dashboard_button_light, R.drawable.dashboard_button_dark);
		cancelRouteButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				clickRouteCancel();
			}
		});

		ImageView waypointsButton = (ImageView) main.findViewById(R.id.map_waypoints_route_button);
		waypointsButton.setImageDrawable(app.getIconsCache().getContentIcon(R.drawable.map_action_waypoints, !nightMode));
		AndroidUtils.setBackground(mapActivity, waypointsButton, nightMode, R.drawable.dashboard_button_light, R.drawable.dashboard_button_dark);
		waypointsButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				clickRouteWaypoints();
			}
		});

		ImageView options = (ImageView) main.findViewById(R.id.map_options_route_button);
		options.setImageDrawable(!routeInfo ? app.getIconsCache().getIcon(R.drawable.map_action_settings,
				R.color.osmand_orange) : app.getIconsCache().getContentIcon(R.drawable.map_action_settings, !nightMode));
		AndroidUtils.setBackground(mapActivity, options, nightMode, R.drawable.dashboard_button_light, R.drawable.dashboard_button_dark);
		options.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				clickRouteParams();
			}
		});

		TextView routeGoButton = (TextView) main.findViewById(R.id.map_go_route_button);
		routeGoButton.setCompoundDrawablesWithIntrinsicBounds(app.getIconsCache().getIcon(R.drawable.map_start_navigation, R.color.color_myloc_distance), null, null, null);
		routeGoButton.setText(mapActivity.getString(R.string.shared_string_go));
		AndroidUtils.setTextSecondaryColor(mapActivity, routeGoButton, nightMode);
		AndroidUtils.setBackground(mapActivity, routeGoButton, nightMode, R.drawable.dashboard_button_light, R.drawable.dashboard_button_dark);
		routeGoButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				clickRouteGo();
			}
		});
	}

	public void setControlsClickable(boolean clickable) {
		for (MapHudButton mb : controls) {
			mb.iv.setClickable(clickable);
		}
	}

	private TargetPointsHelper getTargets() {
		return mapActivity.getMyApplication().getTargetPointsHelper();
	}

	protected void clickRouteParams() {
		if (optionsRouteControlDialog.isDialogVisible()) {
			optionsRouteControlDialog.hideDialog();
			mapRouteInfoMenu.showHideMenu();
		} else {
			mapRouteInfoMenu.hide();
			optionsRouteControlDialog.showAndHideDialog();
		}
	}

	protected void clickRouteWaypoints() {
		if (getTargets().checkPointToNavigateShort()) {
			mapActivity.getMapActions().openIntermediatePointsDialog();
		}
	}

	protected void clickRouteCancel() {
		mapRouteInfoMenu.hide();
		optionsRouteControlDialog.hideDialog();
		if (mapActivity.getRoutingHelper().isFollowingMode()) {
			mapActivity.getMapActions().stopNavigationActionConfirm();
		} else {
			mapActivity.getMapActions().stopNavigationWithoutConfirm();
		}
	}

	protected void clickRouteGo() {
		mapRouteInfoMenu.hide();
		optionsRouteControlDialog.hideDialog();
		startNavigation();
	}

	public void showRouteInfoControlDialog() {
		mapRouteInfoMenu.showHideMenu();
	}

	public void showDialog() {
		mapRouteInfoMenu.setShowMenu();
	}

	private void initControls() {
		View backToLocation = mapActivity.findViewById(R.id.map_my_location_button);
		backToLocationControl = createHudButton(backToLocation, R.drawable.map_my_location)
				.setBg(R.drawable.btn_circle_blue);
		controls.add(backToLocationControl);

		backToLocation.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				if (OsmAndLocationProvider.isLocationPermissionAvailable(mapActivity)) {
					mapActivity.getMapViewTrackingUtilities().backToLocationImpl();
				} else {
					ActivityCompat.requestPermissions(mapActivity,
							new String[]{Manifest.permission.ACCESS_FINE_LOCATION},
							OsmAndLocationProvider.REQUEST_LOCATION_PERMISSION);
				}
			}
		});
		controls.add(createHudButton(mapActivity.findViewById(R.id.map_app_mode_shadow), 0).setBg(
				R.drawable.btn_round_trans, R.drawable.btn_round_transparent));
		View backToMenuButton = mapActivity.findViewById(R.id.map_menu_button);

		final boolean dash = settings.SHOW_DASHBOARD_ON_MAP_SCREEN.get();
		menuControl = createHudButton(backToMenuButton,
				!dash ? R.drawable.map_drawer : R.drawable.map_dashboard).setBg(
				R.drawable.btn_round, R.drawable.btn_round_night);
		controls.add(menuControl);
		backToMenuButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				if (dash) {
					mapActivity.getDashboard().setDashboardVisibility(true, DashboardType.DASHBOARD);
				} else {
					mapActivity.openDrawer();
				}
			}
		});
		mapAppModeShadow = mapActivity.findViewById(R.id.map_app_mode_shadow);
		mapAppModeShadow.setOnClickListener(new View.OnClickListener() {

			@Override
			public void onClick(View v) {
				onApplicationModePress(v);
			}
		});
		appModeIcon = (ImageView) mapActivity.findViewById(R.id.map_app_mode_icon);
		zoomText = (TextView) mapActivity.findViewById(R.id.map_app_mode_text);

		View routePlanButton = mapActivity.findViewById(R.id.map_route_info_button);
		routePlanningBtn = createHudButton(routePlanButton, R.drawable.map_directions).setBg(
				R.drawable.btn_round, R.drawable.btn_round_night);
		controls.add(routePlanningBtn);
		routePlanButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				if (OsmAndLocationProvider.isLocationPermissionAvailable(mapActivity)) {
					onNavigationClick();
				} else {
					ActivityCompat.requestPermissions(mapActivity,
							new String[]{Manifest.permission.ACCESS_FINE_LOCATION},
							REQUEST_LOCATION_FOR_NAVIGATION_PERMISSION);
				}
			}
		});
	}

	private void onNavigationClick() {
		RoutingHelper routingHelper = mapActivity.getRoutingHelper();
		if (!routingHelper.isFollowingMode() && !routingHelper.isRoutePlanningMode()) {
			mapActivity.getMapActions().enterRoutePlanningMode(null, null);
		} else {
			showRouteInfoControlDialog();
		}
	}


	public void switchToRouteFollowingLayout() {
		touchEvent = 0;
		mapActivity.getMyApplication().getRoutingHelper().setRoutePlanningMode(false);
		mapActivity.getMapViewTrackingUtilities().switchToRoutePlanningMode();
		mapActivity.refreshMap();
	}

	public boolean switchToRoutePlanningLayout() {
		if (!mapActivity.getRoutingHelper().isRoutePlanningMode() && mapActivity.getRoutingHelper().isFollowingMode()) {
			mapActivity.getRoutingHelper().setRoutePlanningMode(true);
			mapActivity.getMapViewTrackingUtilities().switchToRoutePlanningMode();
			mapActivity.refreshMap();
			return true;
		}
		return false;
	}

	private void initZooms() {
		final OsmandMapTileView view = mapActivity.getMapView();
		View zoomInButton = mapActivity.findViewById(R.id.map_zoom_in_button);
		mapZoomIn = createHudButton(zoomInButton, R.drawable.map_zoom_in).
				setIconsId(R.drawable.map_zoom_in, R.drawable.map_zoom_in_night).setRoundTransparent();
		controls.add(mapZoomIn);
		zoomInButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				if (view.isZooming()) {
					mapActivity.changeZoom(2, System.currentTimeMillis());
				} else {
					mapActivity.changeZoom(1, System.currentTimeMillis());
				}

			}
		});
		final View.OnLongClickListener listener = MapControlsLayer.getOnClickMagnifierListener(view);
		zoomInButton.setOnLongClickListener(listener);
		View zoomOutButton = mapActivity.findViewById(R.id.map_zoom_out_button);
		mapZoomOut = createHudButton(zoomOutButton, R.drawable.map_zoom_out).
				setIconsId(R.drawable.map_zoom_out, R.drawable.map_zoom_out_night).setRoundTransparent();
		controls.add(mapZoomOut);
		zoomOutButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				mapActivity.changeZoom(-1, System.currentTimeMillis());
			}
		});
		zoomOutButton.setOnLongClickListener(listener);
	}

	public void startNavigation() {
		OsmandApplication app = mapActivity.getMyApplication();
		RoutingHelper routingHelper = app.getRoutingHelper();
		if (routingHelper.isFollowingMode()) {
			switchToRouteFollowingLayout();
		} else {
			if (!app.getTargetPointsHelper().checkPointToNavigateShort()) {
				mapRouteInfoMenu.show();
			} else {
				touchEvent = 0;
				mapActivity.getMapViewTrackingUtilities().backToLocationImpl();
				app.getSettings().FOLLOW_THE_ROUTE.set(true);
				routingHelper.setFollowingMode(true);
				routingHelper.setRoutePlanningMode(false);
				mapActivity.getMapViewTrackingUtilities().switchToRoutePlanningMode();
				app.getRoutingHelper().notifyIfRouteIsCalculated();
				routingHelper.setCurrentLocation(app.getLocationProvider().getLastKnownLocation(), false);
			}
		}
	}

	@Override
	public void destroyLayer() {
		controls.clear();
	}

	@Override
	public void onDraw(Canvas canvas, RotatedTileBox tileBox, DrawSettings nightMode) {
		updateControls(tileBox, nightMode);
	}

	@SuppressWarnings("deprecation")
	private void updateControls(@NonNull RotatedTileBox tileBox, DrawSettings nightMode) {
		boolean isNight = nightMode != null && nightMode.isNightMode();
		int shadw = isNight ? Color.TRANSPARENT : Color.WHITE;
		int textColor = isNight ? mapActivity.getResources().getColor(R.color.widgettext_night) : Color.BLACK;
		if (shadowColor != shadw) {
			shadowColor = shadw;
			// TODOnightMode
			// updatextColor(textColor, shadw, rulerControl, zoomControls, mapMenuControls);
		}
		// default buttons
		boolean routePlanningMode = false;
		RoutingHelper rh = mapActivity.getRoutingHelper();
		if (rh.isRoutePlanningMode()) {
			routePlanningMode = true;
		} else if ((rh.isRouteCalculated() || rh.isRouteBeingCalculated()) && !rh.isFollowingMode()) {
			routePlanningMode = true;
		}
		boolean routeFollowingMode = !routePlanningMode && rh.isFollowingMode();
		boolean dialogOpened = optionsRouteControlDialog.isDialogVisible() || mapRouteInfoMenu.isVisible();
		boolean showRouteCalculationControls = routePlanningMode ||
				((System.currentTimeMillis() - touchEvent < TIMEOUT_TO_SHOW_BUTTONS) && routeFollowingMode);
		updateMyLocation(rh, dialogOpened);
		boolean showButtons = (showRouteCalculationControls || !routeFollowingMode);
		routePlanningBtn.setIconResId(routeFollowingMode ? R.drawable.ic_action_gabout_dark : R.drawable.map_directions);
		if (routePlanningMode || routeFollowingMode) {
			routePlanningBtn.setIconResId(R.drawable.map_start_navigation);
			routePlanningBtn.setIconColorId(R.color.color_myloc_distance);
		} else {
			routePlanningBtn.setIconResId(R.drawable.map_directions);
			routePlanningBtn.resetIconColors();
		}
		routePlanningBtn.updateVisibility(showButtons);
		menuControl.updateVisibility(showButtons);

		mapZoomIn.updateVisibility(!dialogOpened);
		mapZoomOut.updateVisibility(!dialogOpened);
		compassHud.updateVisibility(!dialogOpened);
		layersHud.updateVisibility(!dialogOpened);

		if (routeFollowingMode || routePlanningMode) {
			mapAppModeShadow.setVisibility(View.GONE);
		} else {
			if (mapView.isZooming()) {
				lastZoom = System.currentTimeMillis();
			}
			mapAppModeShadow.setVisibility(View.VISIBLE);
			//if (!mapView.isZooming() || !OsmandPlugin.isDevelopment()) {
			if ((System.currentTimeMillis() - lastZoom > 1000) || !OsmandPlugin.isDevelopment()) {
				zoomText.setVisibility(View.GONE);
				appModeIcon.setVisibility(View.VISIBLE);
				appModeIcon.setImageDrawable(
						app.getIconsCache().getIcon(
								settings.getApplicationMode().getSmallIconDark(), !isNight));
			} else {
				appModeIcon.setVisibility(View.GONE);
				zoomText.setVisibility(View.VISIBLE);
				zoomText.setTextColor(textColor);
				zoomText.setText(getZoomLevel(tileBox));
			}
		}

		mapRouteInfoMenu.setVisible(showRouteCalculationControls);
		updateCompass(isNight);

		for (MapHudButton mc : controls) {
			mc.update(mapActivity.getMyApplication(), nightMode != null && nightMode.isNightMode());
		}
	}

	private void updateCompass(boolean isNight) {
		float mapRotate = mapActivity.getMapView().getRotate();
		if (mapRotate != cachedRotate) {
			cachedRotate = mapRotate;
			// Aply animation to image view
			compassHud.iv.invalidate();
		}
		if (settings.ROTATE_MAP.get() == OsmandSettings.ROTATE_MAP_NONE) {
			compassHud.setIconResId(isNight ? R.drawable.map_compass_niu_white : R.drawable.map_compass_niu);
		} else if (settings.ROTATE_MAP.get() == OsmandSettings.ROTATE_MAP_BEARING) {
			compassHud.setIconResId(isNight ? R.drawable.map_compass_bearing_white : R.drawable.map_compass_bearing);
		} else {
			compassHud.setIconResId(isNight ? R.drawable.map_compass_white : R.drawable.map_compass);
		}
	}

	private void updateMyLocation(RoutingHelper rh, boolean dialogOpened) {
		boolean enabled = mapActivity.getMyApplication().getLocationProvider().getLastKnownLocation() != null;
		boolean tracked = mapActivity.getMapViewTrackingUtilities().isMapLinkedToLocation();

		if (!enabled) {
			backToLocationControl.setBg(R.drawable.btn_circle, R.drawable.btn_circle_night);
			backToLocationControl.setIconColorId(R.color.icon_color, 0);
		} else if (tracked) {
			backToLocationControl.setBg(R.drawable.btn_circle, R.drawable.btn_circle_night);
			backToLocationControl.setIconColorId(R.color.color_myloc_distance);
		} else {
			backToLocationControl.setIconColorId(0);
			backToLocationControl.setBg(R.drawable.btn_circle_blue);
		}
		boolean visible = !(tracked && rh.isFollowingMode());
		backToLocationControl.updateVisibility(visible && !dialogOpened);
	}


	public boolean onSingleTap(PointF point, RotatedTileBox tileBox) {
		return mapRouteInfoMenu.onSingleTap(point, tileBox);
	}

	@Override
	public boolean onTouchEvent(MotionEvent event, RotatedTileBox tileBox) {
		touchEvent = System.currentTimeMillis();
		RoutingHelper rh = mapActivity.getRoutingHelper();
		if (rh.isFollowingMode()) {
			mapActivity.refreshMap();
		}
		return false;
	}

	// /////////////// Transparency bar /////////////////////////
	private void initTransparencyBar() {
		transparencyBarLayout = (LinearLayout) mapActivity.findViewById(R.id.map_transparency_layout);
		transparencyBar = (SeekBar) mapActivity.findViewById(R.id.map_transparency_seekbar);
		transparencyBar.setMax(255);
		if (settingsToTransparency != null) {
			transparencyBar.setProgress(settingsToTransparency.get());
			transparencyBarLayout.setVisibility(View.VISIBLE);
		} else {
			transparencyBarLayout.setVisibility(View.GONE);
		}
		transparencyBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {

			@Override
			public void onStopTrackingTouch(SeekBar seekBar) {
			}

			@Override
			public void onStartTrackingTouch(SeekBar seekBar) {
			}

			@Override
			public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
				if (settingsToTransparency != null) {
					settingsToTransparency.set(progress);
					mapActivity.getMapView().refreshMap();
				}
			}
		});
		ImageButton imageButton = (ImageButton) mapActivity.findViewById(R.id.map_transparency_hide);
		imageButton.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
				transparencyBarLayout.setVisibility(View.GONE);
				hideTransparencyBar(settingsToTransparency);
			}
		});
	}

	public void showTransparencyBar(CommonPreference<Integer> transparenPreference) {
		MapControlsLayer.settingsToTransparency = transparenPreference;
		transparencyBarLayout.setVisibility(View.VISIBLE);
		transparencyBar.setProgress(transparenPreference.get());
	}

	public void hideTransparencyBar(CommonPreference<Integer> transparentPreference) {
		if (settingsToTransparency == transparentPreference) {
			transparencyBarLayout.setVisibility(View.GONE);
			settingsToTransparency = null;
		}
	}

	private class MapHudButton {
		View iv;
		int bgDark;
		int bgLight;
		int resId;
		int resLightId;
		int resDarkId;
		int resClrLight = R.color.icon_color;
		int resClrDark = 0;


		boolean nightMode = false;
		boolean f = true;
		boolean compass;

		public MapHudButton setRoundTransparent() {
			setBg(R.drawable.btn_circle_trans, R.drawable.btn_circle_night);
			return this;
		}


		public MapHudButton setBg(int dayBg, int nightBg) {
			if (bgDark == nightBg && dayBg == bgLight) {
				return this;
			}
			bgDark = nightBg;
			bgLight = dayBg;
			f = true;
			return this;
		}

		public boolean updateVisibility(boolean visible) {
			if (visible != (iv.getVisibility() == View.VISIBLE)) {
				if (visible) {
					iv.setVisibility(View.VISIBLE);
				} else {
					iv.setVisibility(View.GONE);
				}
				iv.invalidate();
				return true;
			}
			return false;
		}

		public MapHudButton setBg(int bg) {
			if (bgDark == bg && bg == bgLight) {
				return this;
			}
			bgDark = bg;
			bgLight = bg;
			f = true;
			return this;
		}

		public boolean setIconResId(int resId) {
			if (this.resId == resId) {
				return false;
			}
			this.resId = resId;
			f = true;
			return true;
		}

		public void resetIconColors() {
			resClrLight = R.color.icon_color;
			resClrDark = 0;
		}

		public MapHudButton setIconColorId(int clr) {
			if (resClrLight == clr && resClrDark == clr) {
				return this;
			}
			resClrLight = clr;
			resClrDark = clr;
			f = true;
			return this;
		}

		public MapHudButton setIconsId(int icnLight, int icnDark) {
			if (resLightId == icnLight && resDarkId == icnDark) {
				return this;
			}
			resLightId = icnLight;
			resDarkId = icnDark;
			f = true;
			return this;
		}

		public MapHudButton setIconColorId(int clrLight, int clrDark) {
			if (resClrLight == clrLight && resClrDark == clrDark) {
				return this;
			}
			resClrLight = clrLight;
			resClrDark = clrDark;
			f = true;
			return this;
		}

		@SuppressLint("NewApi")
		@SuppressWarnings("deprecation")
		public void update(OsmandApplication ctx, boolean night) {
			if (nightMode == night && !f) {
				return;
			}
			f = false;
			nightMode = night;
			if (bgDark != 0 && bgLight != 0) {
				if (Build.VERSION.SDK_INT > Build.VERSION_CODES.LOLLIPOP) {
					iv.setBackground(ctx.getResources().getDrawable(night ? bgDark : bgLight,
							mapActivity.getTheme()));
				} else {
					iv.setBackgroundDrawable(ctx.getResources().getDrawable(night ? bgDark : bgLight));
				}
			}
			Drawable d = null;
			if (resDarkId != 0 && nightMode) {
				d = ctx.getIconsCache().getIcon(resDarkId);
			} else if (resLightId != 0 && !nightMode) {
				d = ctx.getIconsCache().getIcon(resLightId);
			} else if (resId != 0) {
				d = ctx.getIconsCache().getIcon(resId, nightMode ? resClrDark : resClrLight);
			}

			if (iv instanceof ImageView) {
				if (compass) {
					((ImageView) iv).setImageDrawable(new CompassDrawable(d));
				} else {
					((ImageView) iv).setImageDrawable(d);
				}
			} else if (iv instanceof TextView) {
				((TextView) iv).setCompoundDrawablesWithIntrinsicBounds(
						d, null, null, null);
			}
		}

	}

	private void onApplicationModePress(View v) {
		final QuickAction mQuickAction = new QuickAction(v);
		mQuickAction.setOnAnchorOnTop(true);
		List<ApplicationMode> vls = ApplicationMode.values(mapActivity.getMyApplication().getSettings());
		final ApplicationMode[] modes = vls.toArray(new ApplicationMode[vls.size()]);
		Drawable[] icons = new Drawable[vls.size()];
		int[] values = new int[vls.size()];
		for (int k = 0; k < modes.length; k++) {
			icons[k] = app.getIconsCache().getIcon(modes[k].getSmallIconDark(), R.color.icon_color);
			values[k] = modes[k].getStringResource();
		}
		for (int i = 0; i < modes.length; i++) {
			final ActionItem action = new ActionItem();
			action.setTitle(mapActivity.getResources().getString(values[i]));
			action.setIcon(icons[i]);
			final int j = i;
			action.setOnClickListener(new OnClickListener() {
				@Override
				public void onClick(View v) {
					mapActivity.getMyApplication().getSettings().APPLICATION_MODE.set(modes[j]);
					mQuickAction.dismiss();
				}
			});
			mQuickAction.addActionItem(action);
		}
		mQuickAction.setAnimStyle(QuickAction.ANIM_AUTO);
		mQuickAction.show();
	}

	private String getZoomLevel(@NonNull RotatedTileBox tb) {
		String zoomText = tb.getZoom() + "";
		double frac = tb.getMapDensity();
		if (frac != 0) {
			int ifrac = (int) (frac * 10);
			zoomText += " ";
			zoomText += Math.abs(ifrac) / 10;
			if (ifrac % 10 != 0) {
				zoomText += "." + Math.abs(ifrac) % 10;
			}
		}
		return zoomText;
	}

	public static View.OnLongClickListener getOnClickMagnifierListener(final OsmandMapTileView view) {
		return new View.OnLongClickListener() {

			@Override
			public boolean onLongClick(View notUseCouldBeNull) {
				final OsmandSettings.OsmandPreference<Float> mapDensity = view.getSettings().MAP_DENSITY;
				final AlertDialog.Builder bld = new AlertDialog.Builder(view.getContext());
				int p = (int) (mapDensity.get() * 100);
				final TIntArrayList tlist = new TIntArrayList(new int[]{20, 25, 33, 50, 75, 100, 150, 200, 300, 400});
				final List<String> values = new ArrayList<>();
				int i = -1;
				for (int k = 0; k <= tlist.size(); k++) {
					final boolean end = k == tlist.size();
					if (i == -1) {
						if ((end || p < tlist.get(k))) {
							values.add(p + " %");
							i = k;
						} else if (p == tlist.get(k)) {
							i = k;
						}

					}
					if (k < tlist.size()) {
						values.add(tlist.get(k) + " %");
					}
				}
				if (values.size() != tlist.size()) {
					tlist.insert(i, p);
				}

				bld.setTitle(R.string.map_magnifier);
				bld.setSingleChoiceItems(values.toArray(new String[values.size()]), i,
						new DialogInterface.OnClickListener() {
							@Override
							public void onClick(DialogInterface dialog, int which) {
								int p = tlist.get(which);
								mapDensity.set(p / 100.0f);
								view.setComplexZoom(view.getZoom(), view.getSettingsMapDensity());
								MapRendererContext mapContext = NativeCoreContext.getMapRendererContext();
								if (mapContext != null) {
									mapContext.updateMapSettings();
								}
								dialog.dismiss();
							}
						});
				bld.show();
				return true;
			}
		};
	}

	public void onActivityResult(int requestCode, int resultCode, Intent data) {
		if (requestCode == REQUEST_ADDRESS_SELECT && resultCode == SearchAddressFragment.SELECT_ADDRESS_POINT_RESULT_OK) {
			String name = data.getStringExtra(SearchAddressFragment.SELECT_ADDRESS_POINT_INTENT_KEY);
			boolean target = data.getBooleanExtra(MapRouteInfoMenu.TARGET_SELECT, true);
			LatLon latLon = new LatLon(
					data.getDoubleExtra(SearchAddressFragment.SELECT_ADDRESS_POINT_LAT, 0),
					data.getDoubleExtra(SearchAddressFragment.SELECT_ADDRESS_POINT_LON, 0));
			if (name != null) {
				mapRouteInfoMenu.selectAddress(name, latLon, target);
			} else {
				mapRouteInfoMenu.selectAddress("", latLon, target);
			}
		}
	}

	public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
		if (requestCode == REQUEST_LOCATION_FOR_NAVIGATION_PERMISSION
				&& grantResults[0] == PackageManager.PERMISSION_GRANTED) {
			onNavigationClick();
		}
	}
}
!@#$%
20190530_040417,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_c06584
package net.osmand.plus.views;

import android.Manifest;
import android.annotation.SuppressLint;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.ColorFilter;
import android.graphics.PointF;
import android.graphics.drawable.Drawable;
import android.os.Build;
import android.support.annotation.NonNull;
import android.support.v4.app.ActivityCompat;
import android.support.v4.content.ContextCompat;
import android.support.v7.app.AlertDialog;
import android.view.MotionEvent;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.ImageButton;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.SeekBar;
import android.widget.TextView;

import net.londatiga.android.ActionItem;
import net.londatiga.android.QuickAction;
import net.osmand.AndroidUtils;
import net.osmand.core.android.MapRendererContext;
import net.osmand.data.LatLon;
import net.osmand.data.RotatedTileBox;
import net.osmand.plus.ApplicationMode;
import net.osmand.plus.OsmAndLocationProvider;
import net.osmand.plus.OsmandApplication;
import net.osmand.plus.OsmandPlugin;
import net.osmand.plus.OsmandSettings;
import net.osmand.plus.OsmandSettings.CommonPreference;
import net.osmand.plus.R;
import net.osmand.plus.TargetPointsHelper;
import net.osmand.plus.activities.MapActivity;
import net.osmand.plus.activities.search.SearchAddressFragment;
import net.osmand.plus.dashboard.DashboardOnMap.DashboardType;
import net.osmand.plus.mapcontextmenu.other.MapRouteInfoMenu;
import net.osmand.plus.mapcontextmenu.other.MapRoutePreferencesControl;
import net.osmand.plus.routing.RoutingHelper;
import net.osmand.plus.views.corenative.NativeCoreContext;

import java.util.ArrayList;
import java.util.List;

import gnu.trove.list.array.TIntArrayList;

public class MapControlsLayer extends OsmandMapLayer {

	private static final int TIMEOUT_TO_SHOW_BUTTONS = 7000;
	public static final int REQUEST_ADDRESS_SELECT = 2;
	private static final int REQUEST_LOCATION_FOR_NAVIGATION_PERMISSION = 200;

	public MapHudButton createHudButton(View iv, int resId) {
		MapHudButton mc = new MapHudButton();
		mc.iv = iv;
		mc.resId = resId;
		return mc;
	}

	private List<MapHudButton> controls = new ArrayList<>();
	private final MapActivity mapActivity;
	private int shadowColor = -1;
	// private RulerControl rulerControl;
	// private List<MapControls> allControls = new ArrayList<MapControls>();

	private SeekBar transparencyBar;
	private LinearLayout transparencyBarLayout;
	private static CommonPreference<Integer> settingsToTransparency;
	private OsmandSettings settings;

	private MapRoutePreferencesControl optionsRouteControlDialog;
	private MapRouteInfoMenu mapRouteInfoMenu;
	private MapHudButton backToLocationControl;
	private MapHudButton menuControl;
	private MapHudButton compassHud;
	private float cachedRotate = 0;
	private ImageView appModeIcon;
	private TextView zoomText;
	private OsmandMapTileView mapView;
	private OsmandApplication app;
	private View mapAppModeShadow;
	private MapHudButton routePlanningBtn;
	private long touchEvent;
	private MapHudButton mapZoomOut;
	private MapHudButton mapZoomIn;
	private MapHudButton layersHud;
	private long lastZoom;

	public MapControlsLayer(MapActivity activity) {
		this.mapActivity = activity;
		app = activity.getMyApplication();
		settings = activity.getMyApplication().getSettings();
		mapView = mapActivity.getMapView();
	}

	public MapRouteInfoMenu getMapRouteInfoMenu() {
		return mapRouteInfoMenu;
	}

	@Override
	public boolean drawInScreenPixels() {
		return true;
	}

	@Override
	public void initLayer(final OsmandMapTileView view) {
		initTopControls();
		initTransparencyBar();
		initZooms();
		initDasboardRelatedControls();
		updateControls(view.getCurrentRotatedTileBox(), null);
	}

	public void initDasboardRelatedControls() {
		initControls();
		initRouteControls();
	}

	private class CompassDrawable extends Drawable {

		private Drawable original;

		public CompassDrawable(Drawable original) {
			this.original = original;
		}

		@Override
		public void draw(Canvas canvas) {
			canvas.save();
			canvas.rotate(cachedRotate, getIntrinsicWidth() / 2, getIntrinsicHeight() / 2);
			original.draw(canvas);
			canvas.restore();
		}

		@Override
		public int getMinimumHeight() {
			return original.getMinimumHeight();
		}

		@Override
		public int getMinimumWidth() {
			return original.getMinimumWidth();
		}

		@Override
		public int getIntrinsicHeight() {
			return original.getIntrinsicHeight();
		}

		@Override
		public int getIntrinsicWidth() {
			return original.getIntrinsicWidth();
		}

		@Override
		public void setChangingConfigurations(int configs) {
			super.setChangingConfigurations(configs);
			original.setChangingConfigurations(configs);
		}

		@Override
		public void setBounds(int left, int top, int right, int bottom) {
			super.setBounds(left, top, right, bottom);
			original.setBounds(left, top, right, bottom);
		}

		@Override
		public void setAlpha(int alpha) {
			original.setAlpha(alpha);
		}

		@Override
		public void setColorFilter(ColorFilter cf) {
			original.setColorFilter(cf);
		}

		@Override
		public int getOpacity() {
			return original.getOpacity();
		}
	}

	private void initTopControls() {
		View configureMap = mapActivity.findViewById(R.id.map_layers_button);
		layersHud = createHudButton(configureMap, R.drawable.map_layer_dark)
				.setIconsId(R.drawable.map_layer_dark, R.drawable.map_layer_night)
				.setBg(R.drawable.btn_inset_circle_trans, R.drawable.btn_inset_circle_night);
		controls.add(layersHud);
		configureMap.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				mapActivity.getDashboard().setDashboardVisibility(true, DashboardType.CONFIGURE_MAP);
			}
		});

		View compass = mapActivity.findViewById(R.id.map_compass_button);
		compassHud = createHudButton(compass, R.drawable.map_compass).setIconColorId(0).
				setBg(R.drawable.btn_inset_circle_trans, R.drawable.btn_inset_circle_night);
		compassHud.compass = true;
		controls.add(compassHud);
		compass.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				mapActivity.getMapViewTrackingUtilities().switchRotateMapMode();
			}
		});

	}

	private void initRouteControls() {
		mapRouteInfoMenu = new MapRouteInfoMenu(mapActivity, this);
		optionsRouteControlDialog = new MapRoutePreferencesControl(mapActivity, this);
	}

	public void updateRouteButtons(View main, boolean routeInfo) {
		boolean nightMode = mapActivity.getMyApplication().getDaynightHelper().isNightMode();
		ImageView cancelRouteButton = (ImageView) main.findViewById(R.id.map_cancel_route_button);
		cancelRouteButton.setImageDrawable(app.getIconsCache().getContentIcon(R.drawable.map_action_cancel, !nightMode));
		AndroidUtils.setBackground(mapActivity, cancelRouteButton, nightMode, R.drawable.dashboard_button_light, R.drawable.dashboard_button_dark);
		cancelRouteButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				clickRouteCancel();
			}
		});

		ImageView waypointsButton = (ImageView) main.findViewById(R.id.map_waypoints_route_button);
		waypointsButton.setImageDrawable(app.getIconsCache().getContentIcon(R.drawable.map_action_waypoints, !nightMode));
		AndroidUtils.setBackground(mapActivity, waypointsButton, nightMode, R.drawable.dashboard_button_light, R.drawable.dashboard_button_dark);
		waypointsButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				clickRouteWaypoints();
			}
		});

		ImageView options = (ImageView) main.findViewById(R.id.map_options_route_button);
		options.setImageDrawable(!routeInfo ? app.getIconsCache().getIcon(R.drawable.map_action_settings,
				R.color.osmand_orange) : app.getIconsCache().getContentIcon(R.drawable.map_action_settings, !nightMode));
		AndroidUtils.setBackground(mapActivity, options, nightMode, R.drawable.dashboard_button_light, R.drawable.dashboard_button_dark);
		options.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				clickRouteParams();
			}
		});

		TextView routeGoButton = (TextView) main.findViewById(R.id.map_go_route_button);
		routeGoButton.setCompoundDrawablesWithIntrinsicBounds(app.getIconsCache().getIcon(R.drawable.map_start_navigation, R.color.color_myloc_distance), null, null, null);
		routeGoButton.setText(mapActivity.getString(R.string.shared_string_go));
		AndroidUtils.setTextSecondaryColor(mapActivity, routeGoButton, nightMode);
		AndroidUtils.setBackground(mapActivity, routeGoButton, nightMode, R.drawable.dashboard_button_light, R.drawable.dashboard_button_dark);
		routeGoButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				clickRouteGo();
			}
		});
	}

	public void setControlsClickable(boolean clickable) {
		for (MapHudButton mb : controls) {
			mb.iv.setClickable(clickable);
		}
	}

	private TargetPointsHelper getTargets() {
		return mapActivity.getMyApplication().getTargetPointsHelper();
	}

	protected void clickRouteParams() {
		if (optionsRouteControlDialog.isDialogVisible()) {
			optionsRouteControlDialog.hideDialog();
			mapRouteInfoMenu.showHideMenu();
		} else {
			mapRouteInfoMenu.hide();
			optionsRouteControlDialog.showAndHideDialog();
		}
	}

	protected void clickRouteWaypoints() {
		if (getTargets().checkPointToNavigateShort()) {
			mapActivity.getMapActions().openIntermediatePointsDialog();
		}
	}

	protected void clickRouteCancel() {
		mapRouteInfoMenu.hide();
		optionsRouteControlDialog.hideDialog();
		if (mapActivity.getRoutingHelper().isFollowingMode()) {
			mapActivity.getMapActions().stopNavigationActionConfirm();
		} else {
			mapActivity.getMapActions().stopNavigationWithoutConfirm();
		}
	}

	protected void clickRouteGo() {
		mapRouteInfoMenu.hide();
		optionsRouteControlDialog.hideDialog();
		startNavigation();
	}

	public void showRouteInfoControlDialog() {
		mapRouteInfoMenu.showHideMenu();
	}

	public void showDialog() {
		mapRouteInfoMenu.setShowMenu();
	}

	private void initControls() {
		View backToLocation = mapActivity.findViewById(R.id.map_my_location_button);
		backToLocationControl = createHudButton(backToLocation, R.drawable.map_my_location)
				.setBg(R.drawable.btn_circle_blue);
		controls.add(backToLocationControl);

		backToLocation.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				if (OsmAndLocationProvider.isLocationPermissionAvailable(mapActivity)) {
					mapActivity.getMapViewTrackingUtilities().backToLocationImpl();
				} else {
					ActivityCompat.requestPermissions(mapActivity,
							new String[] { Manifest.permission.ACCESS_FINE_LOCATION },
							OsmAndLocationProvider.REQUEST_LOCATION_PERMISSION);
				}
			}
		});
		controls.add(createHudButton(mapActivity.findViewById(R.id.map_app_mode_shadow), 0).setBg(
				R.drawable.btn_round_trans, R.drawable.btn_round_transparent));
		View backToMenuButton = mapActivity.findViewById(R.id.map_menu_button);

		final boolean dash = settings.SHOW_DASHBOARD_ON_MAP_SCREEN.get();
		menuControl = createHudButton(backToMenuButton,
				!dash ? R.drawable.map_drawer : R.drawable.map_dashboard).setBg(
				R.drawable.btn_round, R.drawable.btn_round_night);
		controls.add(menuControl);
		backToMenuButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				if (dash) {
					mapActivity.getDashboard().setDashboardVisibility(true, DashboardType.DASHBOARD);
				} else {
					mapActivity.openDrawer();
				}
			}
		});
		mapAppModeShadow = mapActivity.findViewById(R.id.map_app_mode_shadow);
		mapAppModeShadow.setOnClickListener(new View.OnClickListener() {

			@Override
			public void onClick(View v) {
				onApplicationModePress(v);
			}
		});
		appModeIcon = (ImageView) mapActivity.findViewById(R.id.map_app_mode_icon);
		zoomText = (TextView) mapActivity.findViewById(R.id.map_app_mode_text);

		View routePlanButton = mapActivity.findViewById(R.id.map_route_info_button);
		routePlanningBtn = createHudButton(routePlanButton, R.drawable.map_directions).setBg(
				R.drawable.btn_round, R.drawable.btn_round_night);
		controls.add(routePlanningBtn);
		routePlanButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				if (OsmAndLocationProvider.isLocationPermissionAvailable(mapActivity)) {
					onNavigationClick();
				} else {
					ActivityCompat.requestPermissions(mapActivity,
							new String[]{Manifest.permission.ACCESS_FINE_LOCATION},
							REQUEST_LOCATION_FOR_NAVIGATION_PERMISSION);
				}
			}
		});
	}

	private void onNavigationClick() {
		RoutingHelper routingHelper = mapActivity.getRoutingHelper();
		if (!routingHelper.isFollowingMode() && !routingHelper.isRoutePlanningMode()) {
			mapActivity.getMapActions().enterRoutePlanningMode(null, null);
		} else {
			showRouteInfoControlDialog();
		}
	}


	public void switchToRouteFollowingLayout() {
		touchEvent = 0;
		mapActivity.getMyApplication().getRoutingHelper().setRoutePlanningMode(false);
		mapActivity.getMapViewTrackingUtilities().switchToRoutePlanningMode();
		mapActivity.refreshMap();
	}

	public boolean switchToRoutePlanningLayout() {
		if (!mapActivity.getRoutingHelper().isRoutePlanningMode() && mapActivity.getRoutingHelper().isFollowingMode()) {
			mapActivity.getRoutingHelper().setRoutePlanningMode(true);
			mapActivity.getMapViewTrackingUtilities().switchToRoutePlanningMode();
			mapActivity.refreshMap();
			return true;
		}
		return false;
	}

	private void initZooms() {
		final OsmandMapTileView view = mapActivity.getMapView();
		View zoomInButton = mapActivity.findViewById(R.id.map_zoom_in_button);
		mapZoomIn = createHudButton(zoomInButton, R.drawable.map_zoom_in).
				setIconsId(R.drawable.map_zoom_in, R.drawable.map_zoom_in_night).setRoundTransparent();
		controls.add(mapZoomIn);
		zoomInButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				if (view.isZooming()) {
					mapActivity.changeZoom(2, System.currentTimeMillis());
				} else {
					mapActivity.changeZoom(1, System.currentTimeMillis());
				}

			}
		});
		final View.OnLongClickListener listener = MapControlsLayer.getOnClickMagnifierListener(view);
		zoomInButton.setOnLongClickListener(listener);
		View zoomOutButton = mapActivity.findViewById(R.id.map_zoom_out_button);
		mapZoomOut = createHudButton(zoomOutButton, R.drawable.map_zoom_out).
				setIconsId(R.drawable.map_zoom_out, R.drawable.map_zoom_out_night).setRoundTransparent();
		controls.add(mapZoomOut);
		zoomOutButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				mapActivity.changeZoom(-1, System.currentTimeMillis());
			}
		});
		zoomOutButton.setOnLongClickListener(listener);
	}

	public void startNavigation() {
		OsmandApplication app = mapActivity.getMyApplication();
		RoutingHelper routingHelper = app.getRoutingHelper();
		if (routingHelper.isFollowingMode()) {
			switchToRouteFollowingLayout();
		} else {
			if (!app.getTargetPointsHelper().checkPointToNavigateShort()) {
				mapRouteInfoMenu.show();
			} else {
				touchEvent = 0;
				mapActivity.getMapViewTrackingUtilities().backToLocationImpl();
				app.getSettings().FOLLOW_THE_ROUTE.set(true);
				routingHelper.setFollowingMode(true);
				routingHelper.setRoutePlanningMode(false);
				mapActivity.getMapViewTrackingUtilities().switchToRoutePlanningMode();
				app.getRoutingHelper().notifyIfRouteIsCalculated();
				routingHelper.setCurrentLocation(app.getLocationProvider().getLastKnownLocation(), false);
			}
		}
	}

	@Override
	public void destroyLayer() {
		controls.clear();
	}

	@Override
	public void onDraw(Canvas canvas, RotatedTileBox tileBox, DrawSettings nightMode) {
		updateControls(tileBox, nightMode);
	}

	@SuppressWarnings("deprecation")
	private void updateControls(@NonNull RotatedTileBox tileBox, DrawSettings nightMode) {
		boolean isNight = nightMode != null && nightMode.isNightMode();
		int shadw = isNight ? Color.TRANSPARENT : Color.WHITE;
		int textColor = isNight ? mapActivity.getResources().getColor(R.color.widgettext_night) : Color.BLACK;
		if (shadowColor != shadw) {
			shadowColor = shadw;
			// TODOnightMode
			// updatextColor(textColor, shadw, rulerControl, zoomControls, mapMenuControls);
		}
		// default buttons
		boolean routePlanningMode = false;
		RoutingHelper rh = mapActivity.getRoutingHelper();
		if (rh.isRoutePlanningMode()) {
			routePlanningMode = true;
		} else if ((rh.isRouteCalculated() || rh.isRouteBeingCalculated()) && !rh.isFollowingMode()) {
			routePlanningMode = true;
		}
		boolean routeFollowingMode = !routePlanningMode && rh.isFollowingMode();
		boolean dialogOpened = optionsRouteControlDialog.isDialogVisible() || mapRouteInfoMenu.isVisible();
		boolean showRouteCalculationControls = routePlanningMode ||
				((System.currentTimeMillis() - touchEvent < TIMEOUT_TO_SHOW_BUTTONS) && routeFollowingMode);
		updateMyLocation(rh, dialogOpened);
		boolean showButtons = (showRouteCalculationControls || !routeFollowingMode);
		routePlanningBtn.setIconResId(routeFollowingMode ? R.drawable.ic_action_gabout_dark : R.drawable.map_directions);
		if (routePlanningMode || routeFollowingMode) {
			routePlanningBtn.setIconResId(R.drawable.map_start_navigation);
			routePlanningBtn.setIconColorId(R.color.color_myloc_distance);
		} else {
			routePlanningBtn.setIconResId(R.drawable.map_directions);
			routePlanningBtn.resetIconColors();
		}
		routePlanningBtn.updateVisibility(showButtons);
		menuControl.updateVisibility(showButtons);

		mapZoomIn.updateVisibility(!dialogOpened);
		mapZoomOut.updateVisibility(!dialogOpened);
		compassHud.updateVisibility(!dialogOpened);
		layersHud.updateVisibility(!dialogOpened);

		if (routeFollowingMode || routePlanningMode) {
			mapAppModeShadow.setVisibility(View.GONE);
		} else {
			if (mapView.isZooming()) {
				lastZoom = System.currentTimeMillis();
			}
			mapAppModeShadow.setVisibility(View.VISIBLE);
			//if (!mapView.isZooming() || !OsmandPlugin.isDevelopment()) {
			if ((System.currentTimeMillis() - lastZoom > 1000) || !OsmandPlugin.isDevelopment()) {
				zoomText.setVisibility(View.GONE);
				appModeIcon.setVisibility(View.VISIBLE);
				appModeIcon.setImageDrawable(
						app.getIconsCache().getIcon(
								settings.getApplicationMode().getSmallIconDark(), !isNight));
			} else {
				appModeIcon.setVisibility(View.GONE);
				zoomText.setVisibility(View.VISIBLE);
				zoomText.setTextColor(textColor);
				zoomText.setText(getZoomLevel(tileBox));
			}
		}

		mapRouteInfoMenu.setVisible(showRouteCalculationControls);
		updateCompass(isNight);

		for (MapHudButton mc : controls) {
			mc.update(mapActivity.getMyApplication(), nightMode != null && nightMode.isNightMode());
		}
	}

	private void updateCompass(boolean isNight) {
		float mapRotate = mapActivity.getMapView().getRotate();
		if (mapRotate != cachedRotate) {
			cachedRotate = mapRotate;
			// Aply animation to image view
			compassHud.iv.invalidate();
		}
		if (settings.ROTATE_MAP.get() == OsmandSettings.ROTATE_MAP_NONE) {
			compassHud.setIconResId(isNight ? R.drawable.map_compass_niu_white : R.drawable.map_compass_niu);
		} else if (settings.ROTATE_MAP.get() == OsmandSettings.ROTATE_MAP_BEARING) {
			compassHud.setIconResId(isNight ? R.drawable.map_compass_bearing_white : R.drawable.map_compass_bearing);
		} else {
			compassHud.setIconResId(isNight ? R.drawable.map_compass_white : R.drawable.map_compass);
		}
	}

	private void updateMyLocation(RoutingHelper rh, boolean dialogOpened) {
		boolean enabled = mapActivity.getMyApplication().getLocationProvider().getLastKnownLocation() != null;
		boolean tracked = mapActivity.getMapViewTrackingUtilities().isMapLinkedToLocation();

		if (!enabled) {
			backToLocationControl.setBg(R.drawable.btn_circle, R.drawable.btn_circle_night);
			backToLocationControl.setIconColorId(R.color.icon_color, 0);
		} else if (tracked) {
			backToLocationControl.setBg(R.drawable.btn_circle, R.drawable.btn_circle_night);
			backToLocationControl.setIconColorId(R.color.color_myloc_distance);
		} else {
			backToLocationControl.setIconColorId(0);
			backToLocationControl.setBg(R.drawable.btn_circle_blue);
		}
		boolean visible = !(tracked && rh.isFollowingMode());
		backToLocationControl.updateVisibility(visible && !dialogOpened);
	}


	public boolean onSingleTap(PointF point, RotatedTileBox tileBox) {
		return mapRouteInfoMenu.onSingleTap(point, tileBox);
	}

	@Override
	public boolean onTouchEvent(MotionEvent event, RotatedTileBox tileBox) {
		touchEvent = System.currentTimeMillis();
		RoutingHelper rh = mapActivity.getRoutingHelper();
		if (rh.isFollowingMode()) {
			mapActivity.refreshMap();
		}
		return false;
	}

	// /////////////// Transparency bar /////////////////////////
	private void initTransparencyBar() {
		transparencyBarLayout = (LinearLayout) mapActivity.findViewById(R.id.map_transparency_layout);
		transparencyBar = (SeekBar) mapActivity.findViewById(R.id.map_transparency_seekbar);
		transparencyBar.setMax(255);
		if (settingsToTransparency != null) {
			transparencyBar.setProgress(settingsToTransparency.get());
			transparencyBarLayout.setVisibility(View.VISIBLE);
		} else {
			transparencyBarLayout.setVisibility(View.GONE);
		}
		transparencyBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {

			@Override
			public void onStopTrackingTouch(SeekBar seekBar) {
			}

			@Override
			public void onStartTrackingTouch(SeekBar seekBar) {
			}

			@Override
			public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
				if (settingsToTransparency != null) {
					settingsToTransparency.set(progress);
					mapActivity.getMapView().refreshMap();
				}
			}
		});
		ImageButton imageButton = (ImageButton) mapActivity.findViewById(R.id.map_transparency_hide);
		imageButton.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
				transparencyBarLayout.setVisibility(View.GONE);
				hideTransparencyBar(settingsToTransparency);
			}
		});
	}

	public void showTransparencyBar(CommonPreference<Integer> transparenPreference) {
		MapControlsLayer.settingsToTransparency = transparenPreference;
		transparencyBarLayout.setVisibility(View.VISIBLE);
		transparencyBar.setProgress(transparenPreference.get());
	}

	public void hideTransparencyBar(CommonPreference<Integer> transparentPreference) {
		if (settingsToTransparency == transparentPreference) {
			transparencyBarLayout.setVisibility(View.GONE);
			settingsToTransparency = null;
		}
	}

	private class MapHudButton {
		View iv;
		int bgDark;
		int bgLight;
		int resId;
		int resLightId;
		int resDarkId;
		int resClrLight = R.color.icon_color;
		int resClrDark = 0;


		boolean nightMode = false;
		boolean f = true;
		boolean compass;

		public MapHudButton setRoundTransparent() {
			setBg(R.drawable.btn_circle_trans, R.drawable.btn_circle_night);
			return this;
		}


		public MapHudButton setBg(int dayBg, int nightBg) {
			if (bgDark == nightBg && dayBg == bgLight) {
				return this;
			}
			bgDark = nightBg;
			bgLight = dayBg;
			f = true;
			return this;
		}

		public boolean updateVisibility(boolean visible) {
			if (visible != (iv.getVisibility() == View.VISIBLE)) {
				if (visible) {
					iv.setVisibility(View.VISIBLE);
				} else {
					iv.setVisibility(View.GONE);
				}
				iv.invalidate();
				return true;
			}
			return false;
		}

		public MapHudButton setBg(int bg) {
			if (bgDark == bg && bg == bgLight) {
				return this;
			}
			bgDark = bg;
			bgLight = bg;
			f = true;
			return this;
		}

		public boolean setIconResId(int resId) {
			if (this.resId == resId) {
				return false;
			}
			this.resId = resId;
			f = true;
			return true;
		}

		public void resetIconColors() {
			resClrLight = R.color.icon_color;
			resClrDark = 0;
		}

		public MapHudButton setIconColorId(int clr) {
			if (resClrLight == clr && resClrDark == clr) {
				return this;
			}
			resClrLight = clr;
			resClrDark = clr;
			f = true;
			return this;
		}

		public MapHudButton setIconsId(int icnLight, int icnDark) {
			if (resLightId == icnLight && resDarkId == icnDark) {
				return this;
			}
			resLightId = icnLight;
			resDarkId = icnDark;
			f = true;
			return this;
		}

		public MapHudButton setIconColorId(int clrLight, int clrDark) {
			if (resClrLight == clrLight && resClrDark == clrDark) {
				return this;
			}
			resClrLight = clrLight;
			resClrDark = clrDark;
			f = true;
			return this;
		}

		@SuppressLint("NewApi")
		@SuppressWarnings("deprecation")
		public void update(OsmandApplication ctx, boolean night) {
			if (nightMode == night && !f) {
				return;
			}
			f = false;
			nightMode = night;
			if (bgDark != 0 && bgLight != 0) {
				if (Build.VERSION.SDK_INT > Build.VERSION_CODES.LOLLIPOP) {
					iv.setBackground(ctx.getResources().getDrawable(night ? bgDark : bgLight,
							mapActivity.getTheme()));
				} else {
					iv.setBackgroundDrawable(ctx.getResources().getDrawable(night ? bgDark : bgLight));
				}
			}
			Drawable d = null;
			if (resDarkId != 0 && nightMode) {
				d = ctx.getIconsCache().getIcon(resDarkId);
			} else if (resLightId != 0 && !nightMode) {
				d = ctx.getIconsCache().getIcon(resLightId);
			} else if (resId != 0) {
				d = ctx.getIconsCache().getIcon(resId, nightMode ? resClrDark : resClrLight);
			}

			if (iv instanceof ImageView) {
				if (compass) {
					((ImageView) iv).setImageDrawable(new CompassDrawable(d));
				} else {
					((ImageView) iv).setImageDrawable(d);
				}
			} else if (iv instanceof TextView) {
				((TextView) iv).setCompoundDrawablesWithIntrinsicBounds(
						d, null, null, null);
			}
		}

	}

	private void onApplicationModePress(View v) {
		final QuickAction mQuickAction = new QuickAction(v);
		mQuickAction.setOnAnchorOnTop(true);
		List<ApplicationMode> vls = ApplicationMode.values(mapActivity.getMyApplication().getSettings());
		final ApplicationMode[] modes = vls.toArray(new ApplicationMode[vls.size()]);
		Drawable[] icons = new Drawable[vls.size()];
		int[] values = new int[vls.size()];
		for (int k = 0; k < modes.length; k++) {
			icons[k] = app.getIconsCache().getIcon(modes[k].getSmallIconDark(), R.color.icon_color);
			values[k] = modes[k].getStringResource();
		}
		for (int i = 0; i < modes.length; i++) {
			final ActionItem action = new ActionItem();
			action.setTitle(mapActivity.getResources().getString(values[i]));
			action.setIcon(icons[i]);
			final int j = i;
			action.setOnClickListener(new OnClickListener() {
				@Override
				public void onClick(View v) {
					mapActivity.getMyApplication().getSettings().APPLICATION_MODE.set(modes[j]);
					mQuickAction.dismiss();
				}
			});
			mQuickAction.addActionItem(action);
		}
		mQuickAction.setAnimStyle(QuickAction.ANIM_AUTO);
		mQuickAction.show();
	}

	private String getZoomLevel(@NonNull RotatedTileBox tb) {
		String zoomText = tb.getZoom() + "";
		double frac = tb.getMapDensity();
		if (frac != 0) {
			int ifrac = (int) (frac * 10);
			zoomText += " ";
			zoomText += Math.abs(ifrac) / 10;
			if (ifrac % 10 != 0) {
				zoomText += "." + Math.abs(ifrac) % 10;
			}
		}
		return zoomText;
	}

	public static View.OnLongClickListener getOnClickMagnifierListener(final OsmandMapTileView view) {
		return new View.OnLongClickListener() {

			@Override
			public boolean onLongClick(View notUseCouldBeNull) {
				final OsmandSettings.OsmandPreference<Float> mapDensity = view.getSettings().MAP_DENSITY;
				final AlertDialog.Builder bld = new AlertDialog.Builder(view.getContext());
				int p = (int) (mapDensity.get() * 100);
				final TIntArrayList tlist = new TIntArrayList(new int[]{20, 25, 33, 50, 75, 100, 150, 200, 300, 400});
				final List<String> values = new ArrayList<>();
				int i = -1;
				for (int k = 0; k <= tlist.size(); k++) {
					final boolean end = k == tlist.size();
					if (i == -1) {
						if ((end || p < tlist.get(k))) {
							values.add(p + " %");
							i = k;
						} else if (p == tlist.get(k)) {
							i = k;
						}

					}
					if (k < tlist.size()) {
						values.add(tlist.get(k) + " %");
					}
				}
				if (values.size() != tlist.size()) {
					tlist.insert(i, p);
				}

				bld.setTitle(R.string.map_magnifier);
				bld.setSingleChoiceItems(values.toArray(new String[values.size()]), i,
						new DialogInterface.OnClickListener() {
							@Override
							public void onClick(DialogInterface dialog, int which) {
								int p = tlist.get(which);
								mapDensity.set(p / 100.0f);
								view.setComplexZoom(view.getZoom(), view.getSettingsMapDensity());
								MapRendererContext mapContext = NativeCoreContext.getMapRendererContext();
								if (mapContext != null) {
									mapContext.updateMapSettings();
								}
								dialog.dismiss();
							}
						});
				bld.show();
				return true;
			}
		};
	}

	public void onActivityResult(int requestCode, int resultCode, Intent data) {
		if (requestCode == REQUEST_ADDRESS_SELECT && resultCode == SearchAddressFragment.SELECT_ADDRESS_POINT_RESULT_OK) {
			String name = data.getStringExtra(SearchAddressFragment.SELECT_ADDRESS_POINT_INTENT_KEY);
			boolean target = data.getBooleanExtra(MapRouteInfoMenu.TARGET_SELECT, true);
			LatLon latLon = new LatLon(
					data.getDoubleExtra(SearchAddressFragment.SELECT_ADDRESS_POINT_LAT, 0),
					data.getDoubleExtra(SearchAddressFragment.SELECT_ADDRESS_POINT_LON, 0));
			if (name != null) {
				mapRouteInfoMenu.selectAddress(name, latLon, target);
			} else {
				mapRouteInfoMenu.selectAddress("", latLon, target);
			}
		}
	}

	public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
		if (requestCode == REQUEST_LOCATION_FOR_NAVIGATION_PERMISSION
				&& grantResults[0] == PackageManager.PERMISSION_GRANTED) {
			onNavigationClick();
		}
	}
}
!@#$%
20190530_041523,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_b02996
/* Copyright (c) 2012 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package net.osmand.plus.inapp.util;

import android.app.Activity;
import android.app.PendingIntent;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentSender.SendIntentException;
import android.content.ServiceConnection;
import android.os.Bundle;
import android.os.Handler;
import android.os.IBinder;
import android.os.RemoteException;
import android.text.TextUtils;
import android.util.Log;

import com.android.vending.billing.IInAppBillingService;

import org.json.JSONException;

import java.util.ArrayList;
import java.util.List;


/**
 * Provides convenience methods for in-app billing. You can create one instance of this
 * class for your application and use it to process in-app billing operations.
 * It provides synchronous (blocking) and asynchronous (non-blocking) methods for
 * many common in-app billing operations, as well as automatic signature
 * verification.
 *
 * After instantiating, you must perform setup in order to start using the object.
 * To perform setup, call the {@link #startSetup} method and provide a listener;
 * that listener will be notified when setup is complete, after which (and not before)
 * you may call other methods.
 *
 * After setup is complete, you will typically want to request an inventory of owned
 * items and subscriptions. See {@link #queryInventory}, {@link #queryInventoryAsync}
 * and related methods.
 *
 * When you are done with this object, don't forget to call {@link #dispose}
 * to ensure proper cleanup. This object holds a binding to the in-app billing
 * service, which will leak unless you dispose of it correctly. If you created
 * the object on an Activity's onCreate method, then the recommended
 * place to dispose of it is the Activity's onDestroy method.
 *
 * A note about threading: When using this object from a background thread, you may
 * call the blocking versions of methods; when using from a UI thread, call
 * only the asynchronous versions and handle the results via callbacks.
 * Also, notice that you can only call one asynchronous operation at a time;
 * attempting to start a second asynchronous operation while the first one
 * has not yet completed will result in an exception being thrown.
 *
 * @author Bruno Oliveira (Google)
 *
 */
public class IabHelper {
    // Is debug logging enabled?
    boolean mDebugLog = false;
    String mDebugTag = "IabHelper";

    // Is setup done?
    boolean mSetupDone = false;

    // Has this object been disposed of? (If so, we should ignore callbacks, etc)
    boolean mDisposed = false;

    // Are subscriptions supported?
    boolean mSubscriptionsSupported = false;

    // Is an asynchronous operation in progress?
    // (only one at a time can be in progress)
    boolean mAsyncInProgress = false;

    // (for logging/debugging)
    // if mAsyncInProgress == true, what asynchronous operation is in progress?
    String mAsyncOperation = "";

    // Context we were passed during initialization
    Context mContext;

    // Connection to the service
    IInAppBillingService mService;
    ServiceConnection mServiceConn;

    // The request code used to launch purchase flow
    int mRequestCode;

    // The item type of the current purchase flow
    String mPurchasingItemType;

    // Public key for verifying signature, in base64 encoding
    String mSignatureBase64 = null;

    // Billing response codes
    public static final int BILLING_RESPONSE_RESULT_OK = 0;
    public static final int BILLING_RESPONSE_RESULT_USER_CANCELED = 1;
    public static final int BILLING_RESPONSE_RESULT_BILLING_UNAVAILABLE = 3;
    public static final int BILLING_RESPONSE_RESULT_ITEM_UNAVAILABLE = 4;
    public static final int BILLING_RESPONSE_RESULT_DEVELOPER_ERROR = 5;
    public static final int BILLING_RESPONSE_RESULT_ERROR = 6;
    public static final int BILLING_RESPONSE_RESULT_ITEM_ALREADY_OWNED = 7;
    public static final int BILLING_RESPONSE_RESULT_ITEM_NOT_OWNED = 8;

    // IAB Helper error codes
    public static final int IABHELPER_ERROR_BASE = -1000;
    public static final int IABHELPER_REMOTE_EXCEPTION = -1001;
    public static final int IABHELPER_BAD_RESPONSE = -1002;
    public static final int IABHELPER_VERIFICATION_FAILED = -1003;
    public static final int IABHELPER_SEND_INTENT_FAILED = -1004;
    public static final int IABHELPER_USER_CANCELLED = -1005;
    public static final int IABHELPER_UNKNOWN_PURCHASE_RESPONSE = -1006;
    public static final int IABHELPER_MISSING_TOKEN = -1007;
    public static final int IABHELPER_UNKNOWN_ERROR = -1008;
    public static final int IABHELPER_SUBSCRIPTIONS_NOT_AVAILABLE = -1009;
    public static final int IABHELPER_INVALID_CONSUMPTION = -1010;

    // Keys for the responses from InAppBillingService
    public static final String RESPONSE_CODE = "RESPONSE_CODE";
    public static final String RESPONSE_GET_SKU_DETAILS_LIST = "DETAILS_LIST";
    public static final String RESPONSE_BUY_INTENT = "BUY_INTENT";
    public static final String RESPONSE_INAPP_PURCHASE_DATA = "INAPP_PURCHASE_DATA";
    public static final String RESPONSE_INAPP_SIGNATURE = "INAPP_DATA_SIGNATURE";
    public static final String RESPONSE_INAPP_ITEM_LIST = "INAPP_PURCHASE_ITEM_LIST";
    public static final String RESPONSE_INAPP_PURCHASE_DATA_LIST = "INAPP_PURCHASE_DATA_LIST";
    public static final String RESPONSE_INAPP_SIGNATURE_LIST = "INAPP_DATA_SIGNATURE_LIST";
    public static final String INAPP_CONTINUATION_TOKEN = "INAPP_CONTINUATION_TOKEN";

    // Item types
    public static final String ITEM_TYPE_INAPP = "inapp";
    public static final String ITEM_TYPE_SUBS = "subs";

    // some fields on the getSkuDetails response bundle
    public static final String GET_SKU_DETAILS_ITEM_LIST = "ITEM_ID_LIST";
    public static final String GET_SKU_DETAILS_ITEM_TYPE_LIST = "ITEM_TYPE_LIST";

    /**
     * Creates an instance. After creation, it will not yet be ready to use. You must perform
     * setup by calling {@link #startSetup} and wait for setup to complete. This constructor does not
     * block and is safe to call from a UI thread.
     *
     * @param ctx Your application or Activity context. Needed to bind to the in-app billing service.
     * @param base64PublicKey Your application's public key, encoded in base64.
     *     This is used for verification of purchase signatures. You can find your app's base64-encoded
     *     public key in your application's page on Google Play Developer Console. Note that this
     *     is NOT your "developer public key".
     */
    public IabHelper(Context ctx, String base64PublicKey) {
        mContext = ctx.getApplicationContext();
        mSignatureBase64 = base64PublicKey;
        logDebug("IAB helper created.");
    }

    /**
     * Enables or disable debug logging through LogCat.
     */
    public void enableDebugLogging(boolean enable, String tag) {
        checkNotDisposed();
        mDebugLog = enable;
        mDebugTag = tag;
    }

    public void enableDebugLogging(boolean enable) {
        checkNotDisposed();
        mDebugLog = enable;
    }

    /**
     * Callback for setup process. This listener's {@link #onIabSetupFinished} method is called
     * when the setup process is complete.
     */
    public interface OnIabSetupFinishedListener {
        /**
         * Called to notify that setup is complete.
         *
         * @param result The result of the setup process.
         */
        public void onIabSetupFinished(IabResult result);
    }

    /**
     * Starts the setup process. This will start up the setup process asynchronously.
     * You will be notified through the listener when the setup process is complete.
     * This method is safe to call from a UI thread.
     *
     * @param listener The listener to notify when the setup process is complete.
     */
    public void startSetup(final OnIabSetupFinishedListener listener) {
        // If already set up, can't do it again.
        checkNotDisposed();
        if (mSetupDone) throw new IllegalStateException("IAB helper is already set up.");

        // Connection to IAB service
        logDebug("Starting in-app billing setup.");
        mServiceConn = new ServiceConnection() {
            @Override
            public void onServiceDisconnected(ComponentName name) {
                logDebug("Billing service disconnected.");
                mService = null;
            }

            @Override
            public void onServiceConnected(ComponentName name, IBinder service) {
                if (mDisposed) return;
                logDebug("Billing service connected.");
                mService = IInAppBillingService.Stub.asInterface(service);
                String packageName = mContext.getPackageName();
                try {
                    logDebug("Checking for in-app billing 3 support.");

                    // check for in-app billing v3 support
                    int response = mService.isBillingSupported(3, packageName, ITEM_TYPE_INAPP);
                    if (response != BILLING_RESPONSE_RESULT_OK) {
                        if (listener != null) listener.onIabSetupFinished(new IabResult(response,
                                "Error checking for billing v3 support."));

                        // if in-app purchases aren't supported, neither are subscriptions.
                        mSubscriptionsSupported = false;
                        return;
                    }
                    logDebug("In-app billing version 3 supported for " + packageName);

                    // check for v3 subscriptions support
                    response = mService.isBillingSupported(3, packageName, ITEM_TYPE_SUBS);
                    if (response == BILLING_RESPONSE_RESULT_OK) {
                        logDebug("Subscriptions AVAILABLE.");
                        mSubscriptionsSupported = true;
                    }
                    else {
                        logDebug("Subscriptions NOT AVAILABLE. Response: " + response);
                    }

                    mSetupDone = true;
                }
                catch (RemoteException e) {
                    if (listener != null) {
                        listener.onIabSetupFinished(new IabResult(IABHELPER_REMOTE_EXCEPTION,
                                                    "RemoteException while setting up in-app billing."));
                    }
                    e.printStackTrace();
                    return;
                }

                if (listener != null) {
                    listener.onIabSetupFinished(new IabResult(BILLING_RESPONSE_RESULT_OK, "Setup successful."));
                }
            }
        };

        Intent serviceIntent = new Intent("com.android.vending.billing.InAppBillingService.BIND");
        serviceIntent.setPackage("com.android.vending");
        if (!mContext.getPackageManager().queryIntentServices(serviceIntent, 0).isEmpty()) {
            // service available to handle that Intent
            mContext.bindService(serviceIntent, mServiceConn, Context.BIND_AUTO_CREATE);
        }
        else {
            // no service available to handle that Intent
            mServiceConn = null;
            if (listener != null) {
                listener.onIabSetupFinished(
                        new IabResult(BILLING_RESPONSE_RESULT_BILLING_UNAVAILABLE,
                        "Billing service unavailable on device."));
            }
        }
    }

    /**
     * Dispose of object, releasing resources. It's very important to call this
     * method when you are done with this object. It will release any resources
     * used by it such as service connections. Naturally, once the object is
     * disposed of, it can't be used again.
     */
    public void dispose() {
        logDebug("Disposing.");
        mSetupDone = false;
        if (mServiceConn != null) {
            logDebug("Unbinding from service.");
            if (mContext != null) mContext.unbindService(mServiceConn);
        }
        mDisposed = true;
        mContext = null;
        mServiceConn = null;
        mService = null;
        mPurchaseListener = null;
    }

    private void checkNotDisposed() {
        if (mDisposed) throw new IllegalStateException("IabHelper was disposed of, so it cannot be used.");
    }

    /** Returns whether subscriptions are supported. */
    public boolean subscriptionsSupported() {
        checkNotDisposed();
        return mSubscriptionsSupported;
    }


    /**
     * Callback that notifies when a purchase is finished.
     */
    public interface OnIabPurchaseFinishedListener {
        /**
         * Called to notify that an in-app purchase finished. If the purchase was successful,
         * then the sku parameter specifies which item was purchased. If the purchase failed,
         * the sku and extraData parameters may or may not be null, depending on how far the purchase
         * process went.
         *
         * @param result The result of the purchase.
         * @param info The purchase information (null if purchase failed)
         */
        public void onIabPurchaseFinished(IabResult result, Purchase info);
    }

    // The listener registered on launchPurchaseFlow, which we have to call back when
    // the purchase finishes
    OnIabPurchaseFinishedListener mPurchaseListener;

    public void launchPurchaseFlow(Activity act, String sku, int requestCode, OnIabPurchaseFinishedListener listener) {
        launchPurchaseFlow(act, sku, requestCode, listener, "");
    }

    public void launchPurchaseFlow(Activity act, String sku, int requestCode,
            OnIabPurchaseFinishedListener listener, String extraData) {
        launchPurchaseFlow(act, sku, ITEM_TYPE_INAPP, requestCode, listener, extraData);
    }

    public void launchSubscriptionPurchaseFlow(Activity act, String sku, int requestCode,
            OnIabPurchaseFinishedListener listener) {
        launchSubscriptionPurchaseFlow(act, sku, requestCode, listener, "");
    }

    public void launchSubscriptionPurchaseFlow(Activity act, String sku, int requestCode,
            OnIabPurchaseFinishedListener listener, String extraData) {
        launchPurchaseFlow(act, sku, ITEM_TYPE_SUBS, requestCode, listener, extraData);
    }

    /**
     * Initiate the UI flow for an in-app purchase. Call this method to initiate an in-app purchase,
     * which will involve bringing up the Google Play screen. The calling activity will be paused while
     * the user interacts with Google Play, and the result will be delivered via the activity's
     * {@link android.app.Activity#onActivityResult} method, at which point you must call
     * this object's {@link #handleActivityResult} method to continue the purchase flow. This method
     * MUST be called from the UI thread of the Activity.
     *
     * @param act The calling activity.
     * @param sku The sku of the item to purchase.
     * @param itemType indicates if it's a product or a subscription (ITEM_TYPE_INAPP or ITEM_TYPE_SUBS)
     * @param requestCode A request code (to differentiate from other responses --
     *     as in {@link android.app.Activity#startActivityForResult}).
     * @param listener The listener to notify when the purchase process finishes
     * @param extraData Extra data (developer payload), which will be returned with the purchase data
     *     when the purchase completes. This extra data will be permanently bound to that purchase
     *     and will always be returned when the purchase is queried.
     */
    public void launchPurchaseFlow(Activity act, String sku, String itemType, int requestCode,
                        OnIabPurchaseFinishedListener listener, String extraData) {
        checkNotDisposed();
        checkSetupDone("launchPurchaseFlow");
        flagStartAsync("launchPurchaseFlow");
        IabResult result;

        if (itemType.equals(ITEM_TYPE_SUBS) && !mSubscriptionsSupported) {
            IabResult r = new IabResult(IABHELPER_SUBSCRIPTIONS_NOT_AVAILABLE,
                    "Subscriptions are not available.");
            flagEndAsync();
            if (listener != null) listener.onIabPurchaseFinished(r, null);
            return;
        }

        try {
            logDebug("Constructing buy intent for " + sku + ", item type: " + itemType);
            Bundle buyIntentBundle = mService.getBuyIntent(3, mContext.getPackageName(), sku, itemType, extraData);
            int response = getResponseCodeFromBundle(buyIntentBundle);
            if (response != BILLING_RESPONSE_RESULT_OK) {
                logError("Unable to buy item, Error response: " + getResponseDesc(response));
                flagEndAsync();
                result = new IabResult(response, "Unable to buy item");
                if (listener != null) listener.onIabPurchaseFinished(result, null);
                return;
            }

            PendingIntent pendingIntent = buyIntentBundle.getParcelable(RESPONSE_BUY_INTENT);
            logDebug("Launching buy intent for " + sku + ". Request code: " + requestCode);
            mRequestCode = requestCode;
            mPurchaseListener = listener;
            mPurchasingItemType = itemType;
            act.startIntentSenderForResult(pendingIntent.getIntentSender(),
                                           requestCode, new Intent(),
                                           Integer.valueOf(0), Integer.valueOf(0),
                                           Integer.valueOf(0));
        }
        catch (SendIntentException e) {
            logError("SendIntentException while launching purchase flow for sku " + sku);
            e.printStackTrace();
            flagEndAsync();

            result = new IabResult(IABHELPER_SEND_INTENT_FAILED, "Failed to send intent.");
            if (listener != null) listener.onIabPurchaseFinished(result, null);
        }
        catch (RemoteException e) {
            logError("RemoteException while launching purchase flow for sku " + sku);
            e.printStackTrace();
            flagEndAsync();

            result = new IabResult(IABHELPER_REMOTE_EXCEPTION, "Remote exception while starting purchase flow");
            if (listener != null) listener.onIabPurchaseFinished(result, null);
        }
    }

    /**
     * Handles an activity result that's part of the purchase flow in in-app billing. If you
     * are calling {@link #launchPurchaseFlow}, then you must call this method from your
     * Activity's {@link android.app.Activity@onActivityResult} method. This method
     * MUST be called from the UI thread of the Activity.
     *
     * @param requestCode The requestCode as you received it.
     * @param resultCode The resultCode as you received it.
     * @param data The data (Intent) as you received it.
     * @return Returns true if the result was related to a purchase flow and was handled;
     *     false if the result was not related to a purchase, in which case you should
     *     handle it normally.
     */
    public boolean handleActivityResult(int requestCode, int resultCode, Intent data) {
        IabResult result;
        if (requestCode != mRequestCode) return false;

        checkNotDisposed();
        checkSetupDone("handleActivityResult");

        // end of async purchase operation that started on launchPurchaseFlow
        flagEndAsync();

        if (data == null) {
            logError("Null data in IAB activity result.");
            result = new IabResult(IABHELPER_BAD_RESPONSE, "Null data in IAB result");
            if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, null);
            return true;
        }

        int responseCode = getResponseCodeFromIntent(data);
        String purchaseData = data.getStringExtra(RESPONSE_INAPP_PURCHASE_DATA);
        String dataSignature = data.getStringExtra(RESPONSE_INAPP_SIGNATURE);

        if (resultCode == Activity.RESULT_OK && responseCode == BILLING_RESPONSE_RESULT_OK) {
            logDebug("Successful resultcode from purchase activity.");
            logDebug("Purchase data: " + purchaseData);
            logDebug("Data signature: " + dataSignature);
            logDebug("Extras: " + data.getExtras());
            logDebug("Expected item type: " + mPurchasingItemType);

            if (purchaseData == null || dataSignature == null) {
                logError("BUG: either purchaseData or dataSignature is null.");
                logDebug("Extras: " + data.getExtras().toString());
                result = new IabResult(IABHELPER_UNKNOWN_ERROR, "IAB returned null purchaseData or dataSignature");
                if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, null);
                return true;
            }

            Purchase purchase = null;
            try {
                purchase = new Purchase(mPurchasingItemType, purchaseData, dataSignature);
                String sku = purchase.getSku();

                // Verify signature
                if (!Security.verifyPurchase(mSignatureBase64, purchaseData, dataSignature)) {
                    logError("Purchase signature verification FAILED for sku " + sku);
                    result = new IabResult(IABHELPER_VERIFICATION_FAILED, "Signature verification failed for sku " + sku);
                    if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, purchase);
                    return true;
                }
                logDebug("Purchase signature successfully verified.");
            }
            catch (JSONException e) {
                logError("Failed to parse purchase data.");
                e.printStackTrace();
                result = new IabResult(IABHELPER_BAD_RESPONSE, "Failed to parse purchase data.");
                if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, null);
                return true;
            }

            if (mPurchaseListener != null) {
                mPurchaseListener.onIabPurchaseFinished(new IabResult(BILLING_RESPONSE_RESULT_OK, "Success"), purchase);
            }
        }
        else if (resultCode == Activity.RESULT_OK) {
            // result code was OK, but in-app billing response was not OK.
            logDebug("Result code was OK but in-app billing response was not OK: " + getResponseDesc(responseCode));
            if (mPurchaseListener != null) {
                result = new IabResult(responseCode, "Problem purchashing item.");
                mPurchaseListener.onIabPurchaseFinished(result, null);
            }
        }
        else if (resultCode == Activity.RESULT_CANCELED) {
            logDebug("Purchase canceled - Response: " + getResponseDesc(responseCode));
            result = new IabResult(IABHELPER_USER_CANCELLED, "User canceled.");
            if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, null);
        }
        else {
            logError("Purchase failed. Result code: " + Integer.toString(resultCode)
                    + ". Response: " + getResponseDesc(responseCode));
            result = new IabResult(IABHELPER_UNKNOWN_PURCHASE_RESPONSE, "Unknown purchase response.");
            if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, null);
        }
        return true;
    }

    public Inventory queryInventory(boolean querySkuDetails, List<String> moreSkus) throws IabException {
        return queryInventory(querySkuDetails, moreSkus, null);
    }

    /**
     * Queries the inventory. This will query all owned items from the server, as well as
     * information on additional skus, if specified. This method may block or take long to execute.
     * Do not call from a UI thread. For that, use the non-blocking version {@link #refreshInventoryAsync}.
     *
     * @param querySkuDetails if true, SKU details (price, description, etc) will be queried as well
     *     as purchase information.
     * @param moreItemSkus additional PRODUCT skus to query information on, regardless of ownership.
     *     Ignored if null or if querySkuDetails is false.
     * @param moreSubsSkus additional SUBSCRIPTIONS skus to query information on, regardless of ownership.
     *     Ignored if null or if querySkuDetails is false.
     * @throws IabException if a problem occurs while refreshing the inventory.
     */
    public Inventory queryInventory(boolean querySkuDetails, List<String> moreItemSkus,
                                        List<String> moreSubsSkus) throws IabException {
        checkNotDisposed();
        checkSetupDone("queryInventory");
        try {
            Inventory inv = new Inventory();
            int r = queryPurchases(inv, ITEM_TYPE_INAPP);
            if (r != BILLING_RESPONSE_RESULT_OK) {
                throw new IabException(r, "Error refreshing inventory (querying owned items).");
            }

            if (querySkuDetails) {
                r = querySkuDetails(ITEM_TYPE_INAPP, inv, moreItemSkus);
                if (r != BILLING_RESPONSE_RESULT_OK) {
                    throw new IabException(r, "Error refreshing inventory (querying prices of items).");
                }
            }

            // if subscriptions are supported, then also query for subscriptions
            if (mSubscriptionsSupported) {
                r = queryPurchases(inv, ITEM_TYPE_SUBS);
                if (r != BILLING_RESPONSE_RESULT_OK) {
                    throw new IabException(r, "Error refreshing inventory (querying owned subscriptions).");
                }

                if (querySkuDetails) {
                    r = querySkuDetails(ITEM_TYPE_SUBS, inv, moreItemSkus);
                    if (r != BILLING_RESPONSE_RESULT_OK) {
                        throw new IabException(r, "Error refreshing inventory (querying prices of subscriptions).");
                    }
                }
            }

            return inv;
        }
        catch (RemoteException e) {
            throw new IabException(IABHELPER_REMOTE_EXCEPTION, "Remote exception while refreshing inventory.", e);
        }
        catch (JSONException e) {
            throw new IabException(IABHELPER_BAD_RESPONSE, "Error parsing JSON response while refreshing inventory.", e);
        }
    }

    /**
     * Listener that notifies when an inventory query operation completes.
     */
    public interface QueryInventoryFinishedListener {
        /**
         * Called to notify that an inventory query operation completed.
         *
         * @param result The result of the operation.
         * @param inv The inventory.
         */
        public void onQueryInventoryFinished(IabResult result, Inventory inv);
    }


    /**
     * Asynchronous wrapper for inventory query. This will perform an inventory
     * query as described in {@link #queryInventory}, but will do so asynchronously
     * and call back the specified listener upon completion. This method is safe to
     * call from a UI thread.
     *
     * @param querySkuDetails as in {@link #queryInventory}
     * @param moreSkus as in {@link #queryInventory}
     * @param listener The listener to notify when the refresh operation completes.
     */
    public void queryInventoryAsync(final boolean querySkuDetails,
                               final List<String> moreSkus,
                               final QueryInventoryFinishedListener listener) {
        final Handler handler = new Handler();
        checkNotDisposed();
        checkSetupDone("queryInventory");
        flagStartAsync("refresh inventory");
        (new Thread(new Runnable() {
            public void run() {
                IabResult result = new IabResult(BILLING_RESPONSE_RESULT_OK, "Inventory refresh successful.");
                Inventory inv = null;
                try {
                    inv = queryInventory(querySkuDetails, moreSkus);
                }
                catch (IabException ex) {
                    result = ex.getResult();
                }

                flagEndAsync();

                final IabResult result_f = result;
                final Inventory inv_f = inv;
                if (!mDisposed && listener != null) {
                    handler.post(new Runnable() {
                        public void run() {
                            listener.onQueryInventoryFinished(result_f, inv_f);
                        }
                    });
                }
            }
        })).start();
    }

    public void queryInventoryAsync(QueryInventoryFinishedListener listener) {
        queryInventoryAsync(true, null, listener);
    }

    public void queryInventoryAsync(boolean querySkuDetails, QueryInventoryFinishedListener listener) {
        queryInventoryAsync(querySkuDetails, null, listener);
    }


    /**
     * Consumes a given in-app product. Consuming can only be done on an item
     * that's owned, and as a result of consumption, the user will no longer own it.
     * This method may block or take long to return. Do not call from the UI thread.
     * For that, see {@link #consumeAsync}.
     *
     * @param itemInfo The PurchaseInfo that represents the item to consume.
     * @throws IabException if there is a problem during consumption.
     */
    void consume(Purchase itemInfo) throws IabException {
        checkNotDisposed();
        checkSetupDone("consume");

        if (!itemInfo.mItemType.equals(ITEM_TYPE_INAPP)) {
            throw new IabException(IABHELPER_INVALID_CONSUMPTION,
                    "Items of type '" + itemInfo.mItemType + "' can't be consumed.");
        }

        try {
            String token = itemInfo.getToken();
            String sku = itemInfo.getSku();
            if (token == null || token.equals("")) {
               logError("Can't consume "+ sku + ". No token.");
               throw new IabException(IABHELPER_MISSING_TOKEN, "PurchaseInfo is missing token for sku: "
                   + sku + " " + itemInfo);
            }

            logDebug("Consuming sku: " + sku + ", token: " + token);
            int response = mService.consumePurchase(3, mContext.getPackageName(), token);
            if (response == BILLING_RESPONSE_RESULT_OK) {
               logDebug("Successfully consumed sku: " + sku);
            }
            else {
               logDebug("Error consuming consuming sku " + sku + ". " + getResponseDesc(response));
               throw new IabException(response, "Error consuming sku " + sku);
            }
        }
        catch (RemoteException e) {
            throw new IabException(IABHELPER_REMOTE_EXCEPTION, "Remote exception while consuming. PurchaseInfo: " + itemInfo, e);
        }
    }

    /**
     * Callback that notifies when a consumption operation finishes.
     */
    public interface OnConsumeFinishedListener {
        /**
         * Called to notify that a consumption has finished.
         *
         * @param purchase The purchase that was (or was to be) consumed.
         * @param result The result of the consumption operation.
         */
        public void onConsumeFinished(Purchase purchase, IabResult result);
    }

    /**
     * Callback that notifies when a multi-item consumption operation finishes.
     */
    public interface OnConsumeMultiFinishedListener {
        /**
         * Called to notify that a consumption of multiple items has finished.
         *
         * @param purchases The purchases that were (or were to be) consumed.
         * @param results The results of each consumption operation, corresponding to each
         *     sku.
         */
        public void onConsumeMultiFinished(List<Purchase> purchases, List<IabResult> results);
    }

    /**
     * Asynchronous wrapper to item consumption. Works like {@link #consume}, but
     * performs the consumption in the background and notifies completion through
     * the provided listener. This method is safe to call from a UI thread.
     *
     * @param purchase The purchase to be consumed.
     * @param listener The listener to notify when the consumption operation finishes.
     */
    public void consumeAsync(Purchase purchase, OnConsumeFinishedListener listener) {
        checkNotDisposed();
        checkSetupDone("consume");
        List<Purchase> purchases = new ArrayList<Purchase>();
        purchases.add(purchase);
        consumeAsyncInternal(purchases, listener, null);
    }

    /**
     * Same as {@link consumeAsync}, but for multiple items at once.
     * @param purchases The list of PurchaseInfo objects representing the purchases to consume.
     * @param listener The listener to notify when the consumption operation finishes.
     */
    public void consumeAsync(List<Purchase> purchases, OnConsumeMultiFinishedListener listener) {
        checkNotDisposed();
        checkSetupDone("consume");
        consumeAsyncInternal(purchases, null, listener);
    }

    /**
     * Returns a human-readable description for the given response code.
     *
     * @param code The response code
     * @return A human-readable string explaining the result code.
     *     It also includes the result code numerically.
     */
    public static String getResponseDesc(int code) {
        String[] iab_msgs = ("0:OK/1:User Canceled/2:Unknown/" +
                "3:Billing Unavailable/4:Item unavailable/" +
                "5:Developer Error/6:Error/7:Item Already Owned/" +
                "8:Item not owned").split("/");
        String[] iabhelper_msgs = ("0:OK/-1001:Remote exception during initialization/" +
                                   "-1002:Bad response received/" +
                                   "-1003:Purchase signature verification failed/" +
                                   "-1004:Send intent failed/" +
                                   "-1005:User cancelled/" +
                                   "-1006:Unknown purchase response/" +
                                   "-1007:Missing token/" +
                                   "-1008:Unknown error/" +
                                   "-1009:Subscriptions not available/" +
                                   "-1010:Invalid consumption attempt").split("/");

        if (code <= IABHELPER_ERROR_BASE) {
            int index = IABHELPER_ERROR_BASE - code;
            if (index >= 0 && index < iabhelper_msgs.length) return iabhelper_msgs[index];
            else return String.valueOf(code) + ":Unknown IAB Helper Error";
        }
        else if (code < 0 || code >= iab_msgs.length)
            return String.valueOf(code) + ":Unknown";
        else
            return iab_msgs[code];
    }


    // Checks that setup was done; if not, throws an exception.
    void checkSetupDone(String operation) {
        if (!mSetupDone) {
            logError("Illegal state for operation (" + operation + "): IAB helper is not set up.");
            throw new IllegalStateException("IAB helper is not set up. Can't perform operation: " + operation);
        }
    }

    // Workaround to bug where sometimes response codes come as Long instead of Integer
    int getResponseCodeFromBundle(Bundle b) {
        Object o = b.get(RESPONSE_CODE);
        if (o == null) {
            logDebug("Bundle with null response code, assuming OK (known issue)");
            return BILLING_RESPONSE_RESULT_OK;
        }
        else if (o instanceof Integer) return ((Integer)o).intValue();
        else if (o instanceof Long) return (int)((Long)o).longValue();
        else {
            logError("Unexpected type for bundle response code.");
            logError(o.getClass().getName());
            throw new RuntimeException("Unexpected type for bundle response code: " + o.getClass().getName());
        }
    }

    // Workaround to bug where sometimes response codes come as Long instead of Integer
    int getResponseCodeFromIntent(Intent i) {
        Object o = i.getExtras().get(RESPONSE_CODE);
        if (o == null) {
            logError("Intent with no response code, assuming OK (known issue)");
            return BILLING_RESPONSE_RESULT_OK;
        }
        else if (o instanceof Integer) return ((Integer)o).intValue();
        else if (o instanceof Long) return (int)((Long)o).longValue();
        else {
            logError("Unexpected type for intent response code.");
            logError(o.getClass().getName());
            throw new RuntimeException("Unexpected type for intent response code: " + o.getClass().getName());
        }
    }

    void flagStartAsync(String operation) {
        if (mAsyncInProgress) throw new IllegalStateException("Can't start async operation (" +
                operation + ") because another async operation(" + mAsyncOperation + ") is in progress.");
        mAsyncOperation = operation;
        mAsyncInProgress = true;
        logDebug("Starting async operation: " + operation);
    }

    void flagEndAsync() {
        logDebug("Ending async operation: " + mAsyncOperation);
        mAsyncOperation = "";
        mAsyncInProgress = false;
    }


    int queryPurchases(Inventory inv, String itemType) throws JSONException, RemoteException {
        // Query purchases
        logDebug("Querying owned items, item type: " + itemType);
        logDebug("Package name: " + mContext.getPackageName());
        boolean verificationFailed = false;
        String continueToken = null;

        do {
            logDebug("Calling getPurchases with continuation token: " + continueToken);
            Bundle ownedItems = mService.getPurchases(3, mContext.getPackageName(),
                    itemType, continueToken);

            int response = getResponseCodeFromBundle(ownedItems);
            logDebug("Owned items response: " + String.valueOf(response));
            if (response != BILLING_RESPONSE_RESULT_OK) {
                logDebug("getPurchases() failed: " + getResponseDesc(response));
                return response;
            }
            if (!ownedItems.containsKey(RESPONSE_INAPP_ITEM_LIST)
                    || !ownedItems.containsKey(RESPONSE_INAPP_PURCHASE_DATA_LIST)
                    || !ownedItems.containsKey(RESPONSE_INAPP_SIGNATURE_LIST)) {
                logError("Bundle returned from getPurchases() doesn't contain required fields.");
                return IABHELPER_BAD_RESPONSE;
            }

            ArrayList<String> ownedSkus = ownedItems.getStringArrayList(
                        RESPONSE_INAPP_ITEM_LIST);
            ArrayList<String> purchaseDataList = ownedItems.getStringArrayList(
                        RESPONSE_INAPP_PURCHASE_DATA_LIST);
            ArrayList<String> signatureList = ownedItems.getStringArrayList(
                        RESPONSE_INAPP_SIGNATURE_LIST);

            for (int i = 0; i < purchaseDataList.size(); ++i) {
                String purchaseData = purchaseDataList.get(i);
                String signature = signatureList.get(i);
                String sku = ownedSkus.get(i);
                if (Security.verifyPurchase(mSignatureBase64, purchaseData, signature)) {
                    logDebug("Sku is owned: " + sku);
                    Purchase purchase = new Purchase(itemType, purchaseData, signature);

                    if (TextUtils.isEmpty(purchase.getToken())) {
                        logWarn("BUG: empty/null token!");
                        logDebug("Purchase data: " + purchaseData);
                    }

                    // Record ownership and token
                    inv.addPurchase(purchase);
                }
                else {
                    logWarn("Purchase signature verification **FAILED**. Not adding item.");
                    logDebug("   Purchase data: " + purchaseData);
                    logDebug("   Signature: " + signature);
                    verificationFailed = true;
                }
            }

            continueToken = ownedItems.getString(INAPP_CONTINUATION_TOKEN);
            logDebug("Continuation token: " + continueToken);
        } while (!TextUtils.isEmpty(continueToken));

        return verificationFailed ? IABHELPER_VERIFICATION_FAILED : BILLING_RESPONSE_RESULT_OK;
    }

    int querySkuDetails(String itemType, Inventory inv, List<String> moreSkus)
                                throws RemoteException, JSONException {
        logDebug("Querying SKU details.");
        ArrayList<String> skuList = new ArrayList<String>();
        skuList.addAll(inv.getAllOwnedSkus(itemType));
        if (moreSkus != null) {
            for (String sku : moreSkus) {
                if (!skuList.contains(sku)) {
                    skuList.add(sku);
                }
            }
        }

        if (skuList.size() == 0) {
            logDebug("queryPrices: nothing to do because there are no SKUs.");
            return BILLING_RESPONSE_RESULT_OK;
        }

        Bundle querySkus = new Bundle();
        querySkus.putStringArrayList(GET_SKU_DETAILS_ITEM_LIST, skuList);
        Bundle skuDetails = mService.getSkuDetails(3, mContext.getPackageName(),
                itemType, querySkus);

        if (!skuDetails.containsKey(RESPONSE_GET_SKU_DETAILS_LIST)) {
            int response = getResponseCodeFromBundle(skuDetails);
            if (response != BILLING_RESPONSE_RESULT_OK) {
                logDebug("getSkuDetails() failed: " + getResponseDesc(response));
                return response;
            }
            else {
                logError("getSkuDetails() returned a bundle with neither an error nor a detail list.");
                return IABHELPER_BAD_RESPONSE;
            }
        }

        ArrayList<String> responseList = skuDetails.getStringArrayList(
                RESPONSE_GET_SKU_DETAILS_LIST);

        for (String thisResponse : responseList) {
            SkuDetails d = new SkuDetails(itemType, thisResponse);
            logDebug("Got sku details: " + d);
            inv.addSkuDetails(d);
        }
        return BILLING_RESPONSE_RESULT_OK;
    }


    void consumeAsyncInternal(final List<Purchase> purchases,
                              final OnConsumeFinishedListener singleListener,
                              final OnConsumeMultiFinishedListener multiListener) {
        final Handler handler = new Handler();
        flagStartAsync("consume");
        (new Thread(new Runnable() {
            public void run() {
                final List<IabResult> results = new ArrayList<IabResult>();
                for (Purchase purchase : purchases) {
                    try {
                        consume(purchase);
                        results.add(new IabResult(BILLING_RESPONSE_RESULT_OK, "Successful consume of sku " + purchase.getSku()));
                    }
                    catch (IabException ex) {
                        results.add(ex.getResult());
                    }
                }

                flagEndAsync();
                if (!mDisposed && singleListener != null) {
                    handler.post(new Runnable() {
                        public void run() {
                            singleListener.onConsumeFinished(purchases.get(0), results.get(0));
                        }
                    });
                }
                if (!mDisposed && multiListener != null) {
                    handler.post(new Runnable() {
                        public void run() {
                            multiListener.onConsumeMultiFinished(purchases, results);
                        }
                    });
                }
            }
        })).start();
    }

    void logDebug(String msg) {
        if (mDebugLog) Log.d(mDebugTag, msg);
    }

    void logError(String msg) {
        Log.e(mDebugTag, "In-app billing error: " + msg);
    }

    void logWarn(String msg) {
        Log.w(mDebugTag, "In-app billing warning: " + msg);
    }
}
!@#$%
20190530_041523,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_a02996
/* Copyright (c) 2012 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package net.osmand.plus.inapp.util;

import android.app.Activity;
import android.app.PendingIntent;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentSender.SendIntentException;
import android.content.ServiceConnection;
import android.os.Bundle;
import android.os.Handler;
import android.os.IBinder;
import android.os.RemoteException;
import android.text.TextUtils;
import android.util.Log;

import com.android.vending.billing.IInAppBillingService;

import org.json.JSONException;

import java.util.ArrayList;
import java.util.List;


/**
 * Provides convenience methods for in-app billing. You can create one instance of this
 * class for your application and use it to process in-app billing operations.
 * It provides synchronous (blocking) and asynchronous (non-blocking) methods for
 * many common in-app billing operations, as well as automatic signature
 * verification.
 *
 * After instantiating, you must perform setup in order to start using the object.
 * To perform setup, call the {@link #startSetup} method and provide a listener;
 * that listener will be notified when setup is complete, after which (and not before)
 * you may call other methods.
 *
 * After setup is complete, you will typically want to request an inventory of owned
 * items and subscriptions. See {@link #queryInventory}, {@link #queryInventoryAsync}
 * and related methods.
 *
 * When you are done with this object, don't forget to call {@link #dispose}
 * to ensure proper cleanup. This object holds a binding to the in-app billing
 * service, which will leak unless you dispose of it correctly. If you created
 * the object on an Activity's onCreate method, then the recommended
 * place to dispose of it is the Activity's onDestroy method.
 *
 * A note about threading: When using this object from a background thread, you may
 * call the blocking versions of methods; when using from a UI thread, call
 * only the asynchronous versions and handle the results via callbacks.
 * Also, notice that you can only call one asynchronous operation at a time;
 * attempting to start a second asynchronous operation while the first one
 * has not yet completed will result in an exception being thrown.
 *
 * @author Bruno Oliveira (Google)
 *
 */
public class IabHelper {
    // Is debug logging enabled?
    boolean mDebugLog = false;
    String mDebugTag = "IabHelper";

    // Is setup done?
    boolean mSetupDone = false;

    // Has this object been disposed of? (If so, we should ignore callbacks, etc)
    boolean mDisposed = false;

    // Are subscriptions supported?
    boolean mSubscriptionsSupported = false;

    // Is an asynchronous operation in progress?
    // (only one at a time can be in progress)
    boolean mAsyncInProgress = false;

    // (for logging/debugging)
    // if mAsyncInProgress == true, what asynchronous operation is in progress?
    String mAsyncOperation = "";

    // Context we were passed during initialization
    Context mContext;

    // Connection to the service
    IInAppBillingService mService;
    ServiceConnection mServiceConn;

    // The request code used to launch purchase flow
    int mRequestCode;

    // The item type of the current purchase flow
    String mPurchasingItemType;

    // Public key for verifying signature, in base64 encoding
    String mSignatureBase64 = null;

    // Billing response codes
    public static final int BILLING_RESPONSE_RESULT_OK = 0;
    public static final int BILLING_RESPONSE_RESULT_USER_CANCELED = 1;
    public static final int BILLING_RESPONSE_RESULT_BILLING_UNAVAILABLE = 3;
    public static final int BILLING_RESPONSE_RESULT_ITEM_UNAVAILABLE = 4;
    public static final int BILLING_RESPONSE_RESULT_DEVELOPER_ERROR = 5;
    public static final int BILLING_RESPONSE_RESULT_ERROR = 6;
    public static final int BILLING_RESPONSE_RESULT_ITEM_ALREADY_OWNED = 7;
    public static final int BILLING_RESPONSE_RESULT_ITEM_NOT_OWNED = 8;

    // IAB Helper error codes
    public static final int IABHELPER_ERROR_BASE = -1000;
    public static final int IABHELPER_REMOTE_EXCEPTION = -1001;
    public static final int IABHELPER_BAD_RESPONSE = -1002;
    public static final int IABHELPER_VERIFICATION_FAILED = -1003;
    public static final int IABHELPER_SEND_INTENT_FAILED = -1004;
    public static final int IABHELPER_USER_CANCELLED = -1005;
    public static final int IABHELPER_UNKNOWN_PURCHASE_RESPONSE = -1006;
    public static final int IABHELPER_MISSING_TOKEN = -1007;
    public static final int IABHELPER_UNKNOWN_ERROR = -1008;
    public static final int IABHELPER_SUBSCRIPTIONS_NOT_AVAILABLE = -1009;
    public static final int IABHELPER_INVALID_CONSUMPTION = -1010;

    // Keys for the responses from InAppBillingService
    public static final String RESPONSE_CODE = "RESPONSE_CODE";
    public static final String RESPONSE_GET_SKU_DETAILS_LIST = "DETAILS_LIST";
    public static final String RESPONSE_BUY_INTENT = "BUY_INTENT";
    public static final String RESPONSE_INAPP_PURCHASE_DATA = "INAPP_PURCHASE_DATA";
    public static final String RESPONSE_INAPP_SIGNATURE = "INAPP_DATA_SIGNATURE";
    public static final String RESPONSE_INAPP_ITEM_LIST = "INAPP_PURCHASE_ITEM_LIST";
    public static final String RESPONSE_INAPP_PURCHASE_DATA_LIST = "INAPP_PURCHASE_DATA_LIST";
    public static final String RESPONSE_INAPP_SIGNATURE_LIST = "INAPP_DATA_SIGNATURE_LIST";
    public static final String INAPP_CONTINUATION_TOKEN = "INAPP_CONTINUATION_TOKEN";

    // Item types
    public static final String ITEM_TYPE_INAPP = "inapp";
    public static final String ITEM_TYPE_SUBS = "subs";

    // some fields on the getSkuDetails response bundle
    public static final String GET_SKU_DETAILS_ITEM_LIST = "ITEM_ID_LIST";
    public static final String GET_SKU_DETAILS_ITEM_TYPE_LIST = "ITEM_TYPE_LIST";

    /**
     * Creates an instance. After creation, it will not yet be ready to use. You must perform
     * setup by calling {@link #startSetup} and wait for setup to complete. This constructor does not
     * block and is safe to call from a UI thread.
     *
     * @param ctx Your application or Activity context. Needed to bind to the in-app billing service.
     * @param base64PublicKey Your application's public key, encoded in base64.
     *     This is used for verification of purchase signatures. You can find your app's base64-encoded
     *     public key in your application's page on Google Play Developer Console. Note that this
     *     is NOT your "developer public key".
     */
    public IabHelper(Context ctx, String base64PublicKey) {
        mContext = ctx.getApplicationContext();
        mSignatureBase64 = base64PublicKey;
        logDebug("IAB helper created.");
    }

    /**
     * Enables or disable debug logging through LogCat.
     */
    public void enableDebugLogging(boolean enable, String tag) {
        checkNotDisposed();
        mDebugLog = enable;
        mDebugTag = tag;
    }

    public void enableDebugLogging(boolean enable) {
        checkNotDisposed();
        mDebugLog = enable;
    }

    /**
     * Callback for setup process. This listener's {@link #onIabSetupFinished} method is called
     * when the setup process is complete.
     */
    public interface OnIabSetupFinishedListener {
        /**
         * Called to notify that setup is complete.
         *
         * @param result The result of the setup process.
         */
        public void onIabSetupFinished(IabResult result);
    }

    /**
     * Starts the setup process. This will start up the setup process asynchronously.
     * You will be notified through the listener when the setup process is complete.
     * This method is safe to call from a UI thread.
     *
     * @param listener The listener to notify when the setup process is complete.
     */
    public void startSetup(final OnIabSetupFinishedListener listener) {
        // If already set up, can't do it again.
        checkNotDisposed();
        if (mSetupDone) throw new IllegalStateException("IAB helper is already set up.");

        // Connection to IAB service
        logDebug("Starting in-app billing setup.");
        mServiceConn = new ServiceConnection() {
            @Override
            public void onServiceDisconnected(ComponentName name) {
                logDebug("Billing service disconnected.");
                mService = null;
            }

            @Override
            public void onServiceConnected(ComponentName name, IBinder service) {
                if (mDisposed) return;
                logDebug("Billing service connected.");
                mService = IInAppBillingService.Stub.asInterface(service);
                String packageName = mContext.getPackageName();
                try {
                    logDebug("Checking for in-app billing 3 support.");

                    // check for in-app billing v3 support
                    int response = mService.isBillingSupported(3, packageName, ITEM_TYPE_INAPP);
                    if (response != BILLING_RESPONSE_RESULT_OK) {
                        if (listener != null) listener.onIabSetupFinished(new IabResult(response,
                                "Error checking for billing v3 support."));

                        // if in-app purchases aren't supported, neither are subscriptions.
                        mSubscriptionsSupported = false;
                        return;
                    }
                    logDebug("In-app billing version 3 supported for " + packageName);

                    // check for v3 subscriptions support
                    response = mService.isBillingSupported(3, packageName, ITEM_TYPE_SUBS);
                    if (response == BILLING_RESPONSE_RESULT_OK) {
                        logDebug("Subscriptions AVAILABLE.");
                        mSubscriptionsSupported = true;
                    }
                    else {
                        logDebug("Subscriptions NOT AVAILABLE. Response: " + response);
                    }

                    mSetupDone = true;
                }
                catch (RemoteException e) {
                    if (listener != null) {
                        listener.onIabSetupFinished(new IabResult(IABHELPER_REMOTE_EXCEPTION,
                                                    "RemoteException while setting up in-app billing."));
                    }
                    e.printStackTrace();
                    return;
                }

                if (listener != null) {
                    listener.onIabSetupFinished(new IabResult(BILLING_RESPONSE_RESULT_OK, "Setup successful."));
                }
            }
        };

        Intent serviceIntent = new Intent("com.android.vending.billing.InAppBillingService.BIND");
        serviceIntent.setPackage("com.android.vending");
        if (!mContext.getPackageManager().queryIntentServices(serviceIntent, 0).isEmpty()) {
            // service available to handle that Intent
            mContext.bindService(serviceIntent, mServiceConn, Context.BIND_AUTO_CREATE);
        }
        else {
            // no service available to handle that Intent
            if (listener != null) {
                listener.onIabSetupFinished(
                        new IabResult(BILLING_RESPONSE_RESULT_BILLING_UNAVAILABLE,
                        "Billing service unavailable on device."));
            }
        }
    }

    /**
     * Dispose of object, releasing resources. It's very important to call this
     * method when you are done with this object. It will release any resources
     * used by it such as service connections. Naturally, once the object is
     * disposed of, it can't be used again.
     */
    public void dispose() {
        logDebug("Disposing.");
        mSetupDone = false;
        if (mServiceConn != null) {
            logDebug("Unbinding from service.");
            if (mContext != null) mContext.unbindService(mServiceConn);
        }
        mDisposed = true;
        mContext = null;
        mServiceConn = null;
        mService = null;
        mPurchaseListener = null;
    }

    private void checkNotDisposed() {
        if (mDisposed) throw new IllegalStateException("IabHelper was disposed of, so it cannot be used.");
    }

    /** Returns whether subscriptions are supported. */
    public boolean subscriptionsSupported() {
        checkNotDisposed();
        return mSubscriptionsSupported;
    }


    /**
     * Callback that notifies when a purchase is finished.
     */
    public interface OnIabPurchaseFinishedListener {
        /**
         * Called to notify that an in-app purchase finished. If the purchase was successful,
         * then the sku parameter specifies which item was purchased. If the purchase failed,
         * the sku and extraData parameters may or may not be null, depending on how far the purchase
         * process went.
         *
         * @param result The result of the purchase.
         * @param info The purchase information (null if purchase failed)
         */
        public void onIabPurchaseFinished(IabResult result, Purchase info);
    }

    // The listener registered on launchPurchaseFlow, which we have to call back when
    // the purchase finishes
    OnIabPurchaseFinishedListener mPurchaseListener;

    public void launchPurchaseFlow(Activity act, String sku, int requestCode, OnIabPurchaseFinishedListener listener) {
        launchPurchaseFlow(act, sku, requestCode, listener, "");
    }

    public void launchPurchaseFlow(Activity act, String sku, int requestCode,
            OnIabPurchaseFinishedListener listener, String extraData) {
        launchPurchaseFlow(act, sku, ITEM_TYPE_INAPP, requestCode, listener, extraData);
    }

    public void launchSubscriptionPurchaseFlow(Activity act, String sku, int requestCode,
            OnIabPurchaseFinishedListener listener) {
        launchSubscriptionPurchaseFlow(act, sku, requestCode, listener, "");
    }

    public void launchSubscriptionPurchaseFlow(Activity act, String sku, int requestCode,
            OnIabPurchaseFinishedListener listener, String extraData) {
        launchPurchaseFlow(act, sku, ITEM_TYPE_SUBS, requestCode, listener, extraData);
    }

    /**
     * Initiate the UI flow for an in-app purchase. Call this method to initiate an in-app purchase,
     * which will involve bringing up the Google Play screen. The calling activity will be paused while
     * the user interacts with Google Play, and the result will be delivered via the activity's
     * {@link android.app.Activity#onActivityResult} method, at which point you must call
     * this object's {@link #handleActivityResult} method to continue the purchase flow. This method
     * MUST be called from the UI thread of the Activity.
     *
     * @param act The calling activity.
     * @param sku The sku of the item to purchase.
     * @param itemType indicates if it's a product or a subscription (ITEM_TYPE_INAPP or ITEM_TYPE_SUBS)
     * @param requestCode A request code (to differentiate from other responses --
     *     as in {@link android.app.Activity#startActivityForResult}).
     * @param listener The listener to notify when the purchase process finishes
     * @param extraData Extra data (developer payload), which will be returned with the purchase data
     *     when the purchase completes. This extra data will be permanently bound to that purchase
     *     and will always be returned when the purchase is queried.
     */
    public void launchPurchaseFlow(Activity act, String sku, String itemType, int requestCode,
                        OnIabPurchaseFinishedListener listener, String extraData) {
        checkNotDisposed();
        checkSetupDone("launchPurchaseFlow");
        flagStartAsync("launchPurchaseFlow");
        IabResult result;

        if (itemType.equals(ITEM_TYPE_SUBS) && !mSubscriptionsSupported) {
            IabResult r = new IabResult(IABHELPER_SUBSCRIPTIONS_NOT_AVAILABLE,
                    "Subscriptions are not available.");
            flagEndAsync();
            if (listener != null) listener.onIabPurchaseFinished(r, null);
            return;
        }

        try {
            logDebug("Constructing buy intent for " + sku + ", item type: " + itemType);
            Bundle buyIntentBundle = mService.getBuyIntent(3, mContext.getPackageName(), sku, itemType, extraData);
            int response = getResponseCodeFromBundle(buyIntentBundle);
            if (response != BILLING_RESPONSE_RESULT_OK) {
                logError("Unable to buy item, Error response: " + getResponseDesc(response));
                flagEndAsync();
                result = new IabResult(response, "Unable to buy item");
                if (listener != null) listener.onIabPurchaseFinished(result, null);
                return;
            }

            PendingIntent pendingIntent = buyIntentBundle.getParcelable(RESPONSE_BUY_INTENT);
            logDebug("Launching buy intent for " + sku + ". Request code: " + requestCode);
            mRequestCode = requestCode;
            mPurchaseListener = listener;
            mPurchasingItemType = itemType;
            act.startIntentSenderForResult(pendingIntent.getIntentSender(),
                                           requestCode, new Intent(),
                                           Integer.valueOf(0), Integer.valueOf(0),
                                           Integer.valueOf(0));
        }
        catch (SendIntentException e) {
            logError("SendIntentException while launching purchase flow for sku " + sku);
            e.printStackTrace();
            flagEndAsync();

            result = new IabResult(IABHELPER_SEND_INTENT_FAILED, "Failed to send intent.");
            if (listener != null) listener.onIabPurchaseFinished(result, null);
        }
        catch (RemoteException e) {
            logError("RemoteException while launching purchase flow for sku " + sku);
            e.printStackTrace();
            flagEndAsync();

            result = new IabResult(IABHELPER_REMOTE_EXCEPTION, "Remote exception while starting purchase flow");
            if (listener != null) listener.onIabPurchaseFinished(result, null);
        }
    }

    /**
     * Handles an activity result that's part of the purchase flow in in-app billing. If you
     * are calling {@link #launchPurchaseFlow}, then you must call this method from your
     * Activity's {@link android.app.Activity@onActivityResult} method. This method
     * MUST be called from the UI thread of the Activity.
     *
     * @param requestCode The requestCode as you received it.
     * @param resultCode The resultCode as you received it.
     * @param data The data (Intent) as you received it.
     * @return Returns true if the result was related to a purchase flow and was handled;
     *     false if the result was not related to a purchase, in which case you should
     *     handle it normally.
     */
    public boolean handleActivityResult(int requestCode, int resultCode, Intent data) {
        IabResult result;
        if (requestCode != mRequestCode) return false;

        checkNotDisposed();
        checkSetupDone("handleActivityResult");

        // end of async purchase operation that started on launchPurchaseFlow
        flagEndAsync();

        if (data == null) {
            logError("Null data in IAB activity result.");
            result = new IabResult(IABHELPER_BAD_RESPONSE, "Null data in IAB result");
            if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, null);
            return true;
        }

        int responseCode = getResponseCodeFromIntent(data);
        String purchaseData = data.getStringExtra(RESPONSE_INAPP_PURCHASE_DATA);
        String dataSignature = data.getStringExtra(RESPONSE_INAPP_SIGNATURE);

        if (resultCode == Activity.RESULT_OK && responseCode == BILLING_RESPONSE_RESULT_OK) {
            logDebug("Successful resultcode from purchase activity.");
            logDebug("Purchase data: " + purchaseData);
            logDebug("Data signature: " + dataSignature);
            logDebug("Extras: " + data.getExtras());
            logDebug("Expected item type: " + mPurchasingItemType);

            if (purchaseData == null || dataSignature == null) {
                logError("BUG: either purchaseData or dataSignature is null.");
                logDebug("Extras: " + data.getExtras().toString());
                result = new IabResult(IABHELPER_UNKNOWN_ERROR, "IAB returned null purchaseData or dataSignature");
                if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, null);
                return true;
            }

            Purchase purchase = null;
            try {
                purchase = new Purchase(mPurchasingItemType, purchaseData, dataSignature);
                String sku = purchase.getSku();

                // Verify signature
                if (!Security.verifyPurchase(mSignatureBase64, purchaseData, dataSignature)) {
                    logError("Purchase signature verification FAILED for sku " + sku);
                    result = new IabResult(IABHELPER_VERIFICATION_FAILED, "Signature verification failed for sku " + sku);
                    if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, purchase);
                    return true;
                }
                logDebug("Purchase signature successfully verified.");
            }
            catch (JSONException e) {
                logError("Failed to parse purchase data.");
                e.printStackTrace();
                result = new IabResult(IABHELPER_BAD_RESPONSE, "Failed to parse purchase data.");
                if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, null);
                return true;
            }

            if (mPurchaseListener != null) {
                mPurchaseListener.onIabPurchaseFinished(new IabResult(BILLING_RESPONSE_RESULT_OK, "Success"), purchase);
            }
        }
        else if (resultCode == Activity.RESULT_OK) {
            // result code was OK, but in-app billing response was not OK.
            logDebug("Result code was OK but in-app billing response was not OK: " + getResponseDesc(responseCode));
            if (mPurchaseListener != null) {
                result = new IabResult(responseCode, "Problem purchashing item.");
                mPurchaseListener.onIabPurchaseFinished(result, null);
            }
        }
        else if (resultCode == Activity.RESULT_CANCELED) {
            logDebug("Purchase canceled - Response: " + getResponseDesc(responseCode));
            result = new IabResult(IABHELPER_USER_CANCELLED, "User canceled.");
            if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, null);
        }
        else {
            logError("Purchase failed. Result code: " + Integer.toString(resultCode)
                    + ". Response: " + getResponseDesc(responseCode));
            result = new IabResult(IABHELPER_UNKNOWN_PURCHASE_RESPONSE, "Unknown purchase response.");
            if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, null);
        }
        return true;
    }

    public Inventory queryInventory(boolean querySkuDetails, List<String> moreSkus) throws IabException {
        return queryInventory(querySkuDetails, moreSkus, null);
    }

    /**
     * Queries the inventory. This will query all owned items from the server, as well as
     * information on additional skus, if specified. This method may block or take long to execute.
     * Do not call from a UI thread. For that, use the non-blocking version {@link #refreshInventoryAsync}.
     *
     * @param querySkuDetails if true, SKU details (price, description, etc) will be queried as well
     *     as purchase information.
     * @param moreItemSkus additional PRODUCT skus to query information on, regardless of ownership.
     *     Ignored if null or if querySkuDetails is false.
     * @param moreSubsSkus additional SUBSCRIPTIONS skus to query information on, regardless of ownership.
     *     Ignored if null or if querySkuDetails is false.
     * @throws IabException if a problem occurs while refreshing the inventory.
     */
    public Inventory queryInventory(boolean querySkuDetails, List<String> moreItemSkus,
                                        List<String> moreSubsSkus) throws IabException {
        checkNotDisposed();
        checkSetupDone("queryInventory");
        try {
            Inventory inv = new Inventory();
            int r = queryPurchases(inv, ITEM_TYPE_INAPP);
            if (r != BILLING_RESPONSE_RESULT_OK) {
                throw new IabException(r, "Error refreshing inventory (querying owned items).");
            }

            if (querySkuDetails) {
                r = querySkuDetails(ITEM_TYPE_INAPP, inv, moreItemSkus);
                if (r != BILLING_RESPONSE_RESULT_OK) {
                    throw new IabException(r, "Error refreshing inventory (querying prices of items).");
                }
            }

            // if subscriptions are supported, then also query for subscriptions
            if (mSubscriptionsSupported) {
                r = queryPurchases(inv, ITEM_TYPE_SUBS);
                if (r != BILLING_RESPONSE_RESULT_OK) {
                    throw new IabException(r, "Error refreshing inventory (querying owned subscriptions).");
                }

                if (querySkuDetails) {
                    r = querySkuDetails(ITEM_TYPE_SUBS, inv, moreItemSkus);
                    if (r != BILLING_RESPONSE_RESULT_OK) {
                        throw new IabException(r, "Error refreshing inventory (querying prices of subscriptions).");
                    }
                }
            }

            return inv;
        }
        catch (RemoteException e) {
            throw new IabException(IABHELPER_REMOTE_EXCEPTION, "Remote exception while refreshing inventory.", e);
        }
        catch (JSONException e) {
            throw new IabException(IABHELPER_BAD_RESPONSE, "Error parsing JSON response while refreshing inventory.", e);
        }
    }

    /**
     * Listener that notifies when an inventory query operation completes.
     */
    public interface QueryInventoryFinishedListener {
        /**
         * Called to notify that an inventory query operation completed.
         *
         * @param result The result of the operation.
         * @param inv The inventory.
         */
        public void onQueryInventoryFinished(IabResult result, Inventory inv);
    }


    /**
     * Asynchronous wrapper for inventory query. This will perform an inventory
     * query as described in {@link #queryInventory}, but will do so asynchronously
     * and call back the specified listener upon completion. This method is safe to
     * call from a UI thread.
     *
     * @param querySkuDetails as in {@link #queryInventory}
     * @param moreSkus as in {@link #queryInventory}
     * @param listener The listener to notify when the refresh operation completes.
     */
    public void queryInventoryAsync(final boolean querySkuDetails,
                               final List<String> moreSkus,
                               final QueryInventoryFinishedListener listener) {
        final Handler handler = new Handler();
        checkNotDisposed();
        checkSetupDone("queryInventory");
        flagStartAsync("refresh inventory");
        (new Thread(new Runnable() {
            public void run() {
                IabResult result = new IabResult(BILLING_RESPONSE_RESULT_OK, "Inventory refresh successful.");
                Inventory inv = null;
                try {
                    inv = queryInventory(querySkuDetails, moreSkus);
                }
                catch (IabException ex) {
                    result = ex.getResult();
                }

                flagEndAsync();

                final IabResult result_f = result;
                final Inventory inv_f = inv;
                if (!mDisposed && listener != null) {
                    handler.post(new Runnable() {
                        public void run() {
                            listener.onQueryInventoryFinished(result_f, inv_f);
                        }
                    });
                }
            }
        })).start();
    }

    public void queryInventoryAsync(QueryInventoryFinishedListener listener) {
        queryInventoryAsync(true, null, listener);
    }

    public void queryInventoryAsync(boolean querySkuDetails, QueryInventoryFinishedListener listener) {
        queryInventoryAsync(querySkuDetails, null, listener);
    }


    /**
     * Consumes a given in-app product. Consuming can only be done on an item
     * that's owned, and as a result of consumption, the user will no longer own it.
     * This method may block or take long to return. Do not call from the UI thread.
     * For that, see {@link #consumeAsync}.
     *
     * @param itemInfo The PurchaseInfo that represents the item to consume.
     * @throws IabException if there is a problem during consumption.
     */
    void consume(Purchase itemInfo) throws IabException {
        checkNotDisposed();
        checkSetupDone("consume");

        if (!itemInfo.mItemType.equals(ITEM_TYPE_INAPP)) {
            throw new IabException(IABHELPER_INVALID_CONSUMPTION,
                    "Items of type '" + itemInfo.mItemType + "' can't be consumed.");
        }

        try {
            String token = itemInfo.getToken();
            String sku = itemInfo.getSku();
            if (token == null || token.equals("")) {
               logError("Can't consume "+ sku + ". No token.");
               throw new IabException(IABHELPER_MISSING_TOKEN, "PurchaseInfo is missing token for sku: "
                   + sku + " " + itemInfo);
            }

            logDebug("Consuming sku: " + sku + ", token: " + token);
            int response = mService.consumePurchase(3, mContext.getPackageName(), token);
            if (response == BILLING_RESPONSE_RESULT_OK) {
               logDebug("Successfully consumed sku: " + sku);
            }
            else {
               logDebug("Error consuming consuming sku " + sku + ". " + getResponseDesc(response));
               throw new IabException(response, "Error consuming sku " + sku);
            }
        }
        catch (RemoteException e) {
            throw new IabException(IABHELPER_REMOTE_EXCEPTION, "Remote exception while consuming. PurchaseInfo: " + itemInfo, e);
        }
    }

    /**
     * Callback that notifies when a consumption operation finishes.
     */
    public interface OnConsumeFinishedListener {
        /**
         * Called to notify that a consumption has finished.
         *
         * @param purchase The purchase that was (or was to be) consumed.
         * @param result The result of the consumption operation.
         */
        public void onConsumeFinished(Purchase purchase, IabResult result);
    }

    /**
     * Callback that notifies when a multi-item consumption operation finishes.
     */
    public interface OnConsumeMultiFinishedListener {
        /**
         * Called to notify that a consumption of multiple items has finished.
         *
         * @param purchases The purchases that were (or were to be) consumed.
         * @param results The results of each consumption operation, corresponding to each
         *     sku.
         */
        public void onConsumeMultiFinished(List<Purchase> purchases, List<IabResult> results);
    }

    /**
     * Asynchronous wrapper to item consumption. Works like {@link #consume}, but
     * performs the consumption in the background and notifies completion through
     * the provided listener. This method is safe to call from a UI thread.
     *
     * @param purchase The purchase to be consumed.
     * @param listener The listener to notify when the consumption operation finishes.
     */
    public void consumeAsync(Purchase purchase, OnConsumeFinishedListener listener) {
        checkNotDisposed();
        checkSetupDone("consume");
        List<Purchase> purchases = new ArrayList<Purchase>();
        purchases.add(purchase);
        consumeAsyncInternal(purchases, listener, null);
    }

    /**
     * Same as {@link consumeAsync}, but for multiple items at once.
     * @param purchases The list of PurchaseInfo objects representing the purchases to consume.
     * @param listener The listener to notify when the consumption operation finishes.
     */
    public void consumeAsync(List<Purchase> purchases, OnConsumeMultiFinishedListener listener) {
        checkNotDisposed();
        checkSetupDone("consume");
        consumeAsyncInternal(purchases, null, listener);
    }

    /**
     * Returns a human-readable description for the given response code.
     *
     * @param code The response code
     * @return A human-readable string explaining the result code.
     *     It also includes the result code numerically.
     */
    public static String getResponseDesc(int code) {
        String[] iab_msgs = ("0:OK/1:User Canceled/2:Unknown/" +
                "3:Billing Unavailable/4:Item unavailable/" +
                "5:Developer Error/6:Error/7:Item Already Owned/" +
                "8:Item not owned").split("/");
        String[] iabhelper_msgs = ("0:OK/-1001:Remote exception during initialization/" +
                                   "-1002:Bad response received/" +
                                   "-1003:Purchase signature verification failed/" +
                                   "-1004:Send intent failed/" +
                                   "-1005:User cancelled/" +
                                   "-1006:Unknown purchase response/" +
                                   "-1007:Missing token/" +
                                   "-1008:Unknown error/" +
                                   "-1009:Subscriptions not available/" +
                                   "-1010:Invalid consumption attempt").split("/");

        if (code <= IABHELPER_ERROR_BASE) {
            int index = IABHELPER_ERROR_BASE - code;
            if (index >= 0 && index < iabhelper_msgs.length) return iabhelper_msgs[index];
            else return String.valueOf(code) + ":Unknown IAB Helper Error";
        }
        else if (code < 0 || code >= iab_msgs.length)
            return String.valueOf(code) + ":Unknown";
        else
            return iab_msgs[code];
    }


    // Checks that setup was done; if not, throws an exception.
    void checkSetupDone(String operation) {
        if (!mSetupDone) {
            logError("Illegal state for operation (" + operation + "): IAB helper is not set up.");
            throw new IllegalStateException("IAB helper is not set up. Can't perform operation: " + operation);
        }
    }

    // Workaround to bug where sometimes response codes come as Long instead of Integer
    int getResponseCodeFromBundle(Bundle b) {
        Object o = b.get(RESPONSE_CODE);
        if (o == null) {
            logDebug("Bundle with null response code, assuming OK (known issue)");
            return BILLING_RESPONSE_RESULT_OK;
        }
        else if (o instanceof Integer) return ((Integer)o).intValue();
        else if (o instanceof Long) return (int)((Long)o).longValue();
        else {
            logError("Unexpected type for bundle response code.");
            logError(o.getClass().getName());
            throw new RuntimeException("Unexpected type for bundle response code: " + o.getClass().getName());
        }
    }

    // Workaround to bug where sometimes response codes come as Long instead of Integer
    int getResponseCodeFromIntent(Intent i) {
        Object o = i.getExtras().get(RESPONSE_CODE);
        if (o == null) {
            logError("Intent with no response code, assuming OK (known issue)");
            return BILLING_RESPONSE_RESULT_OK;
        }
        else if (o instanceof Integer) return ((Integer)o).intValue();
        else if (o instanceof Long) return (int)((Long)o).longValue();
        else {
            logError("Unexpected type for intent response code.");
            logError(o.getClass().getName());
            throw new RuntimeException("Unexpected type for intent response code: " + o.getClass().getName());
        }
    }

    void flagStartAsync(String operation) {
        if (mAsyncInProgress) throw new IllegalStateException("Can't start async operation (" +
                operation + ") because another async operation(" + mAsyncOperation + ") is in progress.");
        mAsyncOperation = operation;
        mAsyncInProgress = true;
        logDebug("Starting async operation: " + operation);
    }

    void flagEndAsync() {
        logDebug("Ending async operation: " + mAsyncOperation);
        mAsyncOperation = "";
        mAsyncInProgress = false;
    }


    int queryPurchases(Inventory inv, String itemType) throws JSONException, RemoteException {
        // Query purchases
        logDebug("Querying owned items, item type: " + itemType);
        logDebug("Package name: " + mContext.getPackageName());
        boolean verificationFailed = false;
        String continueToken = null;

        do {
            logDebug("Calling getPurchases with continuation token: " + continueToken);
            Bundle ownedItems = mService.getPurchases(3, mContext.getPackageName(),
                    itemType, continueToken);

            int response = getResponseCodeFromBundle(ownedItems);
            logDebug("Owned items response: " + String.valueOf(response));
            if (response != BILLING_RESPONSE_RESULT_OK) {
                logDebug("getPurchases() failed: " + getResponseDesc(response));
                return response;
            }
            if (!ownedItems.containsKey(RESPONSE_INAPP_ITEM_LIST)
                    || !ownedItems.containsKey(RESPONSE_INAPP_PURCHASE_DATA_LIST)
                    || !ownedItems.containsKey(RESPONSE_INAPP_SIGNATURE_LIST)) {
                logError("Bundle returned from getPurchases() doesn't contain required fields.");
                return IABHELPER_BAD_RESPONSE;
            }

            ArrayList<String> ownedSkus = ownedItems.getStringArrayList(
                        RESPONSE_INAPP_ITEM_LIST);
            ArrayList<String> purchaseDataList = ownedItems.getStringArrayList(
                        RESPONSE_INAPP_PURCHASE_DATA_LIST);
            ArrayList<String> signatureList = ownedItems.getStringArrayList(
                        RESPONSE_INAPP_SIGNATURE_LIST);

            for (int i = 0; i < purchaseDataList.size(); ++i) {
                String purchaseData = purchaseDataList.get(i);
                String signature = signatureList.get(i);
                String sku = ownedSkus.get(i);
                if (Security.verifyPurchase(mSignatureBase64, purchaseData, signature)) {
                    logDebug("Sku is owned: " + sku);
                    Purchase purchase = new Purchase(itemType, purchaseData, signature);

                    if (TextUtils.isEmpty(purchase.getToken())) {
                        logWarn("BUG: empty/null token!");
                        logDebug("Purchase data: " + purchaseData);
                    }

                    // Record ownership and token
                    inv.addPurchase(purchase);
                }
                else {
                    logWarn("Purchase signature verification **FAILED**. Not adding item.");
                    logDebug("   Purchase data: " + purchaseData);
                    logDebug("   Signature: " + signature);
                    verificationFailed = true;
                }
            }

            continueToken = ownedItems.getString(INAPP_CONTINUATION_TOKEN);
            logDebug("Continuation token: " + continueToken);
        } while (!TextUtils.isEmpty(continueToken));

        return verificationFailed ? IABHELPER_VERIFICATION_FAILED : BILLING_RESPONSE_RESULT_OK;
    }

    int querySkuDetails(String itemType, Inventory inv, List<String> moreSkus)
                                throws RemoteException, JSONException {
        logDebug("Querying SKU details.");
        ArrayList<String> skuList = new ArrayList<String>();
        skuList.addAll(inv.getAllOwnedSkus(itemType));
        if (moreSkus != null) {
            for (String sku : moreSkus) {
                if (!skuList.contains(sku)) {
                    skuList.add(sku);
                }
            }
        }

        if (skuList.size() == 0) {
            logDebug("queryPrices: nothing to do because there are no SKUs.");
            return BILLING_RESPONSE_RESULT_OK;
        }

        Bundle querySkus = new Bundle();
        querySkus.putStringArrayList(GET_SKU_DETAILS_ITEM_LIST, skuList);
        Bundle skuDetails = mService.getSkuDetails(3, mContext.getPackageName(),
                itemType, querySkus);

        if (!skuDetails.containsKey(RESPONSE_GET_SKU_DETAILS_LIST)) {
            int response = getResponseCodeFromBundle(skuDetails);
            if (response != BILLING_RESPONSE_RESULT_OK) {
                logDebug("getSkuDetails() failed: " + getResponseDesc(response));
                return response;
            }
            else {
                logError("getSkuDetails() returned a bundle with neither an error nor a detail list.");
                return IABHELPER_BAD_RESPONSE;
            }
        }

        ArrayList<String> responseList = skuDetails.getStringArrayList(
                RESPONSE_GET_SKU_DETAILS_LIST);

        for (String thisResponse : responseList) {
            SkuDetails d = new SkuDetails(itemType, thisResponse);
            logDebug("Got sku details: " + d);
            inv.addSkuDetails(d);
        }
        return BILLING_RESPONSE_RESULT_OK;
    }


    void consumeAsyncInternal(final List<Purchase> purchases,
                              final OnConsumeFinishedListener singleListener,
                              final OnConsumeMultiFinishedListener multiListener) {
        final Handler handler = new Handler();
        flagStartAsync("consume");
        (new Thread(new Runnable() {
            public void run() {
                final List<IabResult> results = new ArrayList<IabResult>();
                for (Purchase purchase : purchases) {
                    try {
                        consume(purchase);
                        results.add(new IabResult(BILLING_RESPONSE_RESULT_OK, "Successful consume of sku " + purchase.getSku()));
                    }
                    catch (IabException ex) {
                        results.add(ex.getResult());
                    }
                }

                flagEndAsync();
                if (!mDisposed && singleListener != null) {
                    handler.post(new Runnable() {
                        public void run() {
                            singleListener.onConsumeFinished(purchases.get(0), results.get(0));
                        }
                    });
                }
                if (!mDisposed && multiListener != null) {
                    handler.post(new Runnable() {
                        public void run() {
                            multiListener.onConsumeMultiFinished(purchases, results);
                        }
                    });
                }
            }
        })).start();
    }

    void logDebug(String msg) {
        if (mDebugLog) Log.d(mDebugTag, msg);
    }

    void logError(String msg) {
        Log.e(mDebugTag, "In-app billing error: " + msg);
    }

    void logWarn(String msg) {
        Log.w(mDebugTag, "In-app billing warning: " + msg);
    }
}
!@#$%
20190530_041523,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_c02996
/* Copyright (c) 2012 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package net.osmand.plus.inapp.util;

import android.app.Activity;
import android.app.PendingIntent;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentSender.SendIntentException;
import android.content.ServiceConnection;
import android.os.Bundle;
import android.os.Handler;
import android.os.IBinder;
import android.os.RemoteException;
import android.text.TextUtils;
import android.util.Log;

import com.android.vending.billing.IInAppBillingService;

import org.json.JSONException;

import java.util.ArrayList;
import java.util.List;


/**
 * Provides convenience methods for in-app billing. You can create one instance of this
 * class for your application and use it to process in-app billing operations.
 * It provides synchronous (blocking) and asynchronous (non-blocking) methods for
 * many common in-app billing operations, as well as automatic signature
 * verification.
 *
 * After instantiating, you must perform setup in order to start using the object.
 * To perform setup, call the {@link #startSetup} method and provide a listener;
 * that listener will be notified when setup is complete, after which (and not before)
 * you may call other methods.
 *
 * After setup is complete, you will typically want to request an inventory of owned
 * items and subscriptions. See {@link #queryInventory}, {@link #queryInventoryAsync}
 * and related methods.
 *
 * When you are done with this object, don't forget to call {@link #dispose}
 * to ensure proper cleanup. This object holds a binding to the in-app billing
 * service, which will leak unless you dispose of it correctly. If you created
 * the object on an Activity's onCreate method, then the recommended
 * place to dispose of it is the Activity's onDestroy method.
 *
 * A note about threading: When using this object from a background thread, you may
 * call the blocking versions of methods; when using from a UI thread, call
 * only the asynchronous versions and handle the results via callbacks.
 * Also, notice that you can only call one asynchronous operation at a time;
 * attempting to start a second asynchronous operation while the first one
 * has not yet completed will result in an exception being thrown.
 *
 * @author Bruno Oliveira (Google)
 *
 */
public class IabHelper {
    // Is debug logging enabled?
    boolean mDebugLog = false;
    String mDebugTag = "IabHelper";

    // Is setup done?
    boolean mSetupDone = false;

    // Has this object been disposed of? (If so, we should ignore callbacks, etc)
    boolean mDisposed = false;

    // Are subscriptions supported?
    boolean mSubscriptionsSupported = false;

    // Is an asynchronous operation in progress?
    // (only one at a time can be in progress)
    boolean mAsyncInProgress = false;

    // (for logging/debugging)
    // if mAsyncInProgress == true, what asynchronous operation is in progress?
    String mAsyncOperation = "";

    // Context we were passed during initialization
    Context mContext;

    // Connection to the service
    IInAppBillingService mService;
    ServiceConnection mServiceConn;

    // The request code used to launch purchase flow
    int mRequestCode;

    // The item type of the current purchase flow
    String mPurchasingItemType;

    // Public key for verifying signature, in base64 encoding
    String mSignatureBase64 = null;

    // Billing response codes
    public static final int BILLING_RESPONSE_RESULT_OK = 0;
    public static final int BILLING_RESPONSE_RESULT_USER_CANCELED = 1;
    public static final int BILLING_RESPONSE_RESULT_BILLING_UNAVAILABLE = 3;
    public static final int BILLING_RESPONSE_RESULT_ITEM_UNAVAILABLE = 4;
    public static final int BILLING_RESPONSE_RESULT_DEVELOPER_ERROR = 5;
    public static final int BILLING_RESPONSE_RESULT_ERROR = 6;
    public static final int BILLING_RESPONSE_RESULT_ITEM_ALREADY_OWNED = 7;
    public static final int BILLING_RESPONSE_RESULT_ITEM_NOT_OWNED = 8;

    // IAB Helper error codes
    public static final int IABHELPER_ERROR_BASE = -1000;
    public static final int IABHELPER_REMOTE_EXCEPTION = -1001;
    public static final int IABHELPER_BAD_RESPONSE = -1002;
    public static final int IABHELPER_VERIFICATION_FAILED = -1003;
    public static final int IABHELPER_SEND_INTENT_FAILED = -1004;
    public static final int IABHELPER_USER_CANCELLED = -1005;
    public static final int IABHELPER_UNKNOWN_PURCHASE_RESPONSE = -1006;
    public static final int IABHELPER_MISSING_TOKEN = -1007;
    public static final int IABHELPER_UNKNOWN_ERROR = -1008;
    public static final int IABHELPER_SUBSCRIPTIONS_NOT_AVAILABLE = -1009;
    public static final int IABHELPER_INVALID_CONSUMPTION = -1010;

    // Keys for the responses from InAppBillingService
    public static final String RESPONSE_CODE = "RESPONSE_CODE";
    public static final String RESPONSE_GET_SKU_DETAILS_LIST = "DETAILS_LIST";
    public static final String RESPONSE_BUY_INTENT = "BUY_INTENT";
    public static final String RESPONSE_INAPP_PURCHASE_DATA = "INAPP_PURCHASE_DATA";
    public static final String RESPONSE_INAPP_SIGNATURE = "INAPP_DATA_SIGNATURE";
    public static final String RESPONSE_INAPP_ITEM_LIST = "INAPP_PURCHASE_ITEM_LIST";
    public static final String RESPONSE_INAPP_PURCHASE_DATA_LIST = "INAPP_PURCHASE_DATA_LIST";
    public static final String RESPONSE_INAPP_SIGNATURE_LIST = "INAPP_DATA_SIGNATURE_LIST";
    public static final String INAPP_CONTINUATION_TOKEN = "INAPP_CONTINUATION_TOKEN";

    // Item types
    public static final String ITEM_TYPE_INAPP = "inapp";
    public static final String ITEM_TYPE_SUBS = "subs";

    // some fields on the getSkuDetails response bundle
    public static final String GET_SKU_DETAILS_ITEM_LIST = "ITEM_ID_LIST";
    public static final String GET_SKU_DETAILS_ITEM_TYPE_LIST = "ITEM_TYPE_LIST";

    /**
     * Creates an instance. After creation, it will not yet be ready to use. You must perform
     * setup by calling {@link #startSetup} and wait for setup to complete. This constructor does not
     * block and is safe to call from a UI thread.
     *
     * @param ctx Your application or Activity context. Needed to bind to the in-app billing service.
     * @param base64PublicKey Your application's public key, encoded in base64.
     *     This is used for verification of purchase signatures. You can find your app's base64-encoded
     *     public key in your application's page on Google Play Developer Console. Note that this
     *     is NOT your "developer public key".
     */
    public IabHelper(Context ctx, String base64PublicKey) {
        mContext = ctx.getApplicationContext();
        mSignatureBase64 = base64PublicKey;
        logDebug("IAB helper created.");
    }

    /**
     * Enables or disable debug logging through LogCat.
     */
    public void enableDebugLogging(boolean enable, String tag) {
        checkNotDisposed();
        mDebugLog = enable;
        mDebugTag = tag;
    }

    public void enableDebugLogging(boolean enable) {
        checkNotDisposed();
        mDebugLog = enable;
    }

    /**
     * Callback for setup process. This listener's {@link #onIabSetupFinished} method is called
     * when the setup process is complete.
     */
    public interface OnIabSetupFinishedListener {
        /**
         * Called to notify that setup is complete.
         *
         * @param result The result of the setup process.
         */
        public void onIabSetupFinished(IabResult result);
    }

    /**
     * Starts the setup process. This will start up the setup process asynchronously.
     * You will be notified through the listener when the setup process is complete.
     * This method is safe to call from a UI thread.
     *
     * @param listener The listener to notify when the setup process is complete.
     */
    public void startSetup(final OnIabSetupFinishedListener listener) {
        // If already set up, can't do it again.
        checkNotDisposed();
        if (mSetupDone) throw new IllegalStateException("IAB helper is already set up.");

        // Connection to IAB service
        logDebug("Starting in-app billing setup.");
        mServiceConn = new ServiceConnection() {
            @Override
            public void onServiceDisconnected(ComponentName name) {
                logDebug("Billing service disconnected.");
                mService = null;
            }

            @Override
            public void onServiceConnected(ComponentName name, IBinder service) {
                if (mDisposed) return;
                logDebug("Billing service connected.");
                mService = IInAppBillingService.Stub.asInterface(service);
                String packageName = mContext.getPackageName();
                try {
                    logDebug("Checking for in-app billing 3 support.");

                    // check for in-app billing v3 support
                    int response = mService.isBillingSupported(3, packageName, ITEM_TYPE_INAPP);
                    if (response != BILLING_RESPONSE_RESULT_OK) {
                        if (listener != null) listener.onIabSetupFinished(new IabResult(response,
                                "Error checking for billing v3 support."));

                        // if in-app purchases aren't supported, neither are subscriptions.
                        mSubscriptionsSupported = false;
                        return;
                    }
                    logDebug("In-app billing version 3 supported for " + packageName);

                    // check for v3 subscriptions support
                    response = mService.isBillingSupported(3, packageName, ITEM_TYPE_SUBS);
                    if (response == BILLING_RESPONSE_RESULT_OK) {
                        logDebug("Subscriptions AVAILABLE.");
                        mSubscriptionsSupported = true;
                    }
                    else {
                        logDebug("Subscriptions NOT AVAILABLE. Response: " + response);
                    }

                    mSetupDone = true;
                }
                catch (RemoteException e) {
                    if (listener != null) {
                        listener.onIabSetupFinished(new IabResult(IABHELPER_REMOTE_EXCEPTION,
                                                    "RemoteException while setting up in-app billing."));
                    }
                    e.printStackTrace();
                    return;
                }

                if (listener != null) {
                    listener.onIabSetupFinished(new IabResult(BILLING_RESPONSE_RESULT_OK, "Setup successful."));
                }
            }
        };

        Intent serviceIntent = new Intent("com.android.vending.billing.InAppBillingService.BIND");
        serviceIntent.setPackage("com.android.vending");
        if (!mContext.getPackageManager().queryIntentServices(serviceIntent, 0).isEmpty()) {
            // service available to handle that Intent
            mContext.bindService(serviceIntent, mServiceConn, Context.BIND_AUTO_CREATE);
        }
        else {
            // no service available to handle that Intent
			mServiceConn = null;
            if (listener != null) {
                listener.onIabSetupFinished(
                        new IabResult(BILLING_RESPONSE_RESULT_BILLING_UNAVAILABLE,
                        "Billing service unavailable on device."));
            }
        }
    }

    /**
     * Dispose of object, releasing resources. It's very important to call this
     * method when you are done with this object. It will release any resources
     * used by it such as service connections. Naturally, once the object is
     * disposed of, it can't be used again.
     */
    public void dispose() {
        logDebug("Disposing.");
        mSetupDone = false;
        if (mServiceConn != null) {
            logDebug("Unbinding from service.");
            if (mContext != null) mContext.unbindService(mServiceConn);
        }
        mDisposed = true;
        mContext = null;
        mServiceConn = null;
        mService = null;
        mPurchaseListener = null;
    }

    private void checkNotDisposed() {
        if (mDisposed) throw new IllegalStateException("IabHelper was disposed of, so it cannot be used.");
    }

    /** Returns whether subscriptions are supported. */
    public boolean subscriptionsSupported() {
        checkNotDisposed();
        return mSubscriptionsSupported;
    }


    /**
     * Callback that notifies when a purchase is finished.
     */
    public interface OnIabPurchaseFinishedListener {
        /**
         * Called to notify that an in-app purchase finished. If the purchase was successful,
         * then the sku parameter specifies which item was purchased. If the purchase failed,
         * the sku and extraData parameters may or may not be null, depending on how far the purchase
         * process went.
         *
         * @param result The result of the purchase.
         * @param info The purchase information (null if purchase failed)
         */
        public void onIabPurchaseFinished(IabResult result, Purchase info);
    }

    // The listener registered on launchPurchaseFlow, which we have to call back when
    // the purchase finishes
    OnIabPurchaseFinishedListener mPurchaseListener;

    public void launchPurchaseFlow(Activity act, String sku, int requestCode, OnIabPurchaseFinishedListener listener) {
        launchPurchaseFlow(act, sku, requestCode, listener, "");
    }

    public void launchPurchaseFlow(Activity act, String sku, int requestCode,
            OnIabPurchaseFinishedListener listener, String extraData) {
        launchPurchaseFlow(act, sku, ITEM_TYPE_INAPP, requestCode, listener, extraData);
    }

    public void launchSubscriptionPurchaseFlow(Activity act, String sku, int requestCode,
            OnIabPurchaseFinishedListener listener) {
        launchSubscriptionPurchaseFlow(act, sku, requestCode, listener, "");
    }

    public void launchSubscriptionPurchaseFlow(Activity act, String sku, int requestCode,
            OnIabPurchaseFinishedListener listener, String extraData) {
        launchPurchaseFlow(act, sku, ITEM_TYPE_SUBS, requestCode, listener, extraData);
    }

    /**
     * Initiate the UI flow for an in-app purchase. Call this method to initiate an in-app purchase,
     * which will involve bringing up the Google Play screen. The calling activity will be paused while
     * the user interacts with Google Play, and the result will be delivered via the activity's
     * {@link android.app.Activity#onActivityResult} method, at which point you must call
     * this object's {@link #handleActivityResult} method to continue the purchase flow. This method
     * MUST be called from the UI thread of the Activity.
     *
     * @param act The calling activity.
     * @param sku The sku of the item to purchase.
     * @param itemType indicates if it's a product or a subscription (ITEM_TYPE_INAPP or ITEM_TYPE_SUBS)
     * @param requestCode A request code (to differentiate from other responses --
     *     as in {@link android.app.Activity#startActivityForResult}).
     * @param listener The listener to notify when the purchase process finishes
     * @param extraData Extra data (developer payload), which will be returned with the purchase data
     *     when the purchase completes. This extra data will be permanently bound to that purchase
     *     and will always be returned when the purchase is queried.
     */
    public void launchPurchaseFlow(Activity act, String sku, String itemType, int requestCode,
                        OnIabPurchaseFinishedListener listener, String extraData) {
        checkNotDisposed();
        checkSetupDone("launchPurchaseFlow");
        flagStartAsync("launchPurchaseFlow");
        IabResult result;

        if (itemType.equals(ITEM_TYPE_SUBS) && !mSubscriptionsSupported) {
            IabResult r = new IabResult(IABHELPER_SUBSCRIPTIONS_NOT_AVAILABLE,
                    "Subscriptions are not available.");
            flagEndAsync();
            if (listener != null) listener.onIabPurchaseFinished(r, null);
            return;
        }

        try {
            logDebug("Constructing buy intent for " + sku + ", item type: " + itemType);
            Bundle buyIntentBundle = mService.getBuyIntent(3, mContext.getPackageName(), sku, itemType, extraData);
            int response = getResponseCodeFromBundle(buyIntentBundle);
            if (response != BILLING_RESPONSE_RESULT_OK) {
                logError("Unable to buy item, Error response: " + getResponseDesc(response));
                flagEndAsync();
                result = new IabResult(response, "Unable to buy item");
                if (listener != null) listener.onIabPurchaseFinished(result, null);
                return;
            }

            PendingIntent pendingIntent = buyIntentBundle.getParcelable(RESPONSE_BUY_INTENT);
            logDebug("Launching buy intent for " + sku + ". Request code: " + requestCode);
            mRequestCode = requestCode;
            mPurchaseListener = listener;
            mPurchasingItemType = itemType;
            act.startIntentSenderForResult(pendingIntent.getIntentSender(),
                                           requestCode, new Intent(),
                                           Integer.valueOf(0), Integer.valueOf(0),
                                           Integer.valueOf(0));
        }
        catch (SendIntentException e) {
            logError("SendIntentException while launching purchase flow for sku " + sku);
            e.printStackTrace();
            flagEndAsync();

            result = new IabResult(IABHELPER_SEND_INTENT_FAILED, "Failed to send intent.");
            if (listener != null) listener.onIabPurchaseFinished(result, null);
        }
        catch (RemoteException e) {
            logError("RemoteException while launching purchase flow for sku " + sku);
            e.printStackTrace();
            flagEndAsync();

            result = new IabResult(IABHELPER_REMOTE_EXCEPTION, "Remote exception while starting purchase flow");
            if (listener != null) listener.onIabPurchaseFinished(result, null);
        }
    }

    /**
     * Handles an activity result that's part of the purchase flow in in-app billing. If you
     * are calling {@link #launchPurchaseFlow}, then you must call this method from your
     * Activity's {@link android.app.Activity@onActivityResult} method. This method
     * MUST be called from the UI thread of the Activity.
     *
     * @param requestCode The requestCode as you received it.
     * @param resultCode The resultCode as you received it.
     * @param data The data (Intent) as you received it.
     * @return Returns true if the result was related to a purchase flow and was handled;
     *     false if the result was not related to a purchase, in which case you should
     *     handle it normally.
     */
    public boolean handleActivityResult(int requestCode, int resultCode, Intent data) {
        IabResult result;
        if (requestCode != mRequestCode) return false;

        checkNotDisposed();
        checkSetupDone("handleActivityResult");

        // end of async purchase operation that started on launchPurchaseFlow
        flagEndAsync();

        if (data == null) {
            logError("Null data in IAB activity result.");
            result = new IabResult(IABHELPER_BAD_RESPONSE, "Null data in IAB result");
            if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, null);
            return true;
        }

        int responseCode = getResponseCodeFromIntent(data);
        String purchaseData = data.getStringExtra(RESPONSE_INAPP_PURCHASE_DATA);
        String dataSignature = data.getStringExtra(RESPONSE_INAPP_SIGNATURE);

        if (resultCode == Activity.RESULT_OK && responseCode == BILLING_RESPONSE_RESULT_OK) {
            logDebug("Successful resultcode from purchase activity.");
            logDebug("Purchase data: " + purchaseData);
            logDebug("Data signature: " + dataSignature);
            logDebug("Extras: " + data.getExtras());
            logDebug("Expected item type: " + mPurchasingItemType);

            if (purchaseData == null || dataSignature == null) {
                logError("BUG: either purchaseData or dataSignature is null.");
                logDebug("Extras: " + data.getExtras().toString());
                result = new IabResult(IABHELPER_UNKNOWN_ERROR, "IAB returned null purchaseData or dataSignature");
                if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, null);
                return true;
            }

            Purchase purchase = null;
            try {
                purchase = new Purchase(mPurchasingItemType, purchaseData, dataSignature);
                String sku = purchase.getSku();

                // Verify signature
                if (!Security.verifyPurchase(mSignatureBase64, purchaseData, dataSignature)) {
                    logError("Purchase signature verification FAILED for sku " + sku);
                    result = new IabResult(IABHELPER_VERIFICATION_FAILED, "Signature verification failed for sku " + sku);
                    if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, purchase);
                    return true;
                }
                logDebug("Purchase signature successfully verified.");
            }
            catch (JSONException e) {
                logError("Failed to parse purchase data.");
                e.printStackTrace();
                result = new IabResult(IABHELPER_BAD_RESPONSE, "Failed to parse purchase data.");
                if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, null);
                return true;
            }

            if (mPurchaseListener != null) {
                mPurchaseListener.onIabPurchaseFinished(new IabResult(BILLING_RESPONSE_RESULT_OK, "Success"), purchase);
            }
        }
        else if (resultCode == Activity.RESULT_OK) {
            // result code was OK, but in-app billing response was not OK.
            logDebug("Result code was OK but in-app billing response was not OK: " + getResponseDesc(responseCode));
            if (mPurchaseListener != null) {
                result = new IabResult(responseCode, "Problem purchashing item.");
                mPurchaseListener.onIabPurchaseFinished(result, null);
            }
        }
        else if (resultCode == Activity.RESULT_CANCELED) {
            logDebug("Purchase canceled - Response: " + getResponseDesc(responseCode));
            result = new IabResult(IABHELPER_USER_CANCELLED, "User canceled.");
            if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, null);
        }
        else {
            logError("Purchase failed. Result code: " + Integer.toString(resultCode)
                    + ". Response: " + getResponseDesc(responseCode));
            result = new IabResult(IABHELPER_UNKNOWN_PURCHASE_RESPONSE, "Unknown purchase response.");
            if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, null);
        }
        return true;
    }

    public Inventory queryInventory(boolean querySkuDetails, List<String> moreSkus) throws IabException {
        return queryInventory(querySkuDetails, moreSkus, null);
    }

    /**
     * Queries the inventory. This will query all owned items from the server, as well as
     * information on additional skus, if specified. This method may block or take long to execute.
     * Do not call from a UI thread. For that, use the non-blocking version {@link #refreshInventoryAsync}.
     *
     * @param querySkuDetails if true, SKU details (price, description, etc) will be queried as well
     *     as purchase information.
     * @param moreItemSkus additional PRODUCT skus to query information on, regardless of ownership.
     *     Ignored if null or if querySkuDetails is false.
     * @param moreSubsSkus additional SUBSCRIPTIONS skus to query information on, regardless of ownership.
     *     Ignored if null or if querySkuDetails is false.
     * @throws IabException if a problem occurs while refreshing the inventory.
     */
    public Inventory queryInventory(boolean querySkuDetails, List<String> moreItemSkus,
                                        List<String> moreSubsSkus) throws IabException {
        checkNotDisposed();
        checkSetupDone("queryInventory");
        try {
            Inventory inv = new Inventory();
            int r = queryPurchases(inv, ITEM_TYPE_INAPP);
            if (r != BILLING_RESPONSE_RESULT_OK) {
                throw new IabException(r, "Error refreshing inventory (querying owned items).");
            }

            if (querySkuDetails) {
                r = querySkuDetails(ITEM_TYPE_INAPP, inv, moreItemSkus);
                if (r != BILLING_RESPONSE_RESULT_OK) {
                    throw new IabException(r, "Error refreshing inventory (querying prices of items).");
                }
            }

            // if subscriptions are supported, then also query for subscriptions
            if (mSubscriptionsSupported) {
                r = queryPurchases(inv, ITEM_TYPE_SUBS);
                if (r != BILLING_RESPONSE_RESULT_OK) {
                    throw new IabException(r, "Error refreshing inventory (querying owned subscriptions).");
                }

                if (querySkuDetails) {
                    r = querySkuDetails(ITEM_TYPE_SUBS, inv, moreItemSkus);
                    if (r != BILLING_RESPONSE_RESULT_OK) {
                        throw new IabException(r, "Error refreshing inventory (querying prices of subscriptions).");
                    }
                }
            }

            return inv;
        }
        catch (RemoteException e) {
            throw new IabException(IABHELPER_REMOTE_EXCEPTION, "Remote exception while refreshing inventory.", e);
        }
        catch (JSONException e) {
            throw new IabException(IABHELPER_BAD_RESPONSE, "Error parsing JSON response while refreshing inventory.", e);
        }
    }

    /**
     * Listener that notifies when an inventory query operation completes.
     */
    public interface QueryInventoryFinishedListener {
        /**
         * Called to notify that an inventory query operation completed.
         *
         * @param result The result of the operation.
         * @param inv The inventory.
         */
        public void onQueryInventoryFinished(IabResult result, Inventory inv);
    }


    /**
     * Asynchronous wrapper for inventory query. This will perform an inventory
     * query as described in {@link #queryInventory}, but will do so asynchronously
     * and call back the specified listener upon completion. This method is safe to
     * call from a UI thread.
     *
     * @param querySkuDetails as in {@link #queryInventory}
     * @param moreSkus as in {@link #queryInventory}
     * @param listener The listener to notify when the refresh operation completes.
     */
    public void queryInventoryAsync(final boolean querySkuDetails,
                               final List<String> moreSkus,
                               final QueryInventoryFinishedListener listener) {
        final Handler handler = new Handler();
        checkNotDisposed();
        checkSetupDone("queryInventory");
        flagStartAsync("refresh inventory");
        (new Thread(new Runnable() {
            public void run() {
                IabResult result = new IabResult(BILLING_RESPONSE_RESULT_OK, "Inventory refresh successful.");
                Inventory inv = null;
                try {
                    inv = queryInventory(querySkuDetails, moreSkus);
                }
                catch (IabException ex) {
                    result = ex.getResult();
                }

                flagEndAsync();

                final IabResult result_f = result;
                final Inventory inv_f = inv;
                if (!mDisposed && listener != null) {
                    handler.post(new Runnable() {
                        public void run() {
                            listener.onQueryInventoryFinished(result_f, inv_f);
                        }
                    });
                }
            }
        })).start();
    }

    public void queryInventoryAsync(QueryInventoryFinishedListener listener) {
        queryInventoryAsync(true, null, listener);
    }

    public void queryInventoryAsync(boolean querySkuDetails, QueryInventoryFinishedListener listener) {
        queryInventoryAsync(querySkuDetails, null, listener);
    }


    /**
     * Consumes a given in-app product. Consuming can only be done on an item
     * that's owned, and as a result of consumption, the user will no longer own it.
     * This method may block or take long to return. Do not call from the UI thread.
     * For that, see {@link #consumeAsync}.
     *
     * @param itemInfo The PurchaseInfo that represents the item to consume.
     * @throws IabException if there is a problem during consumption.
     */
    void consume(Purchase itemInfo) throws IabException {
        checkNotDisposed();
        checkSetupDone("consume");

        if (!itemInfo.mItemType.equals(ITEM_TYPE_INAPP)) {
            throw new IabException(IABHELPER_INVALID_CONSUMPTION,
                    "Items of type '" + itemInfo.mItemType + "' can't be consumed.");
        }

        try {
            String token = itemInfo.getToken();
            String sku = itemInfo.getSku();
            if (token == null || token.equals("")) {
               logError("Can't consume "+ sku + ". No token.");
               throw new IabException(IABHELPER_MISSING_TOKEN, "PurchaseInfo is missing token for sku: "
                   + sku + " " + itemInfo);
            }

            logDebug("Consuming sku: " + sku + ", token: " + token);
            int response = mService.consumePurchase(3, mContext.getPackageName(), token);
            if (response == BILLING_RESPONSE_RESULT_OK) {
               logDebug("Successfully consumed sku: " + sku);
            }
            else {
               logDebug("Error consuming consuming sku " + sku + ". " + getResponseDesc(response));
               throw new IabException(response, "Error consuming sku " + sku);
            }
        }
        catch (RemoteException e) {
            throw new IabException(IABHELPER_REMOTE_EXCEPTION, "Remote exception while consuming. PurchaseInfo: " + itemInfo, e);
        }
    }

    /**
     * Callback that notifies when a consumption operation finishes.
     */
    public interface OnConsumeFinishedListener {
        /**
         * Called to notify that a consumption has finished.
         *
         * @param purchase The purchase that was (or was to be) consumed.
         * @param result The result of the consumption operation.
         */
        public void onConsumeFinished(Purchase purchase, IabResult result);
    }

    /**
     * Callback that notifies when a multi-item consumption operation finishes.
     */
    public interface OnConsumeMultiFinishedListener {
        /**
         * Called to notify that a consumption of multiple items has finished.
         *
         * @param purchases The purchases that were (or were to be) consumed.
         * @param results The results of each consumption operation, corresponding to each
         *     sku.
         */
        public void onConsumeMultiFinished(List<Purchase> purchases, List<IabResult> results);
    }

    /**
     * Asynchronous wrapper to item consumption. Works like {@link #consume}, but
     * performs the consumption in the background and notifies completion through
     * the provided listener. This method is safe to call from a UI thread.
     *
     * @param purchase The purchase to be consumed.
     * @param listener The listener to notify when the consumption operation finishes.
     */
    public void consumeAsync(Purchase purchase, OnConsumeFinishedListener listener) {
        checkNotDisposed();
        checkSetupDone("consume");
        List<Purchase> purchases = new ArrayList<Purchase>();
        purchases.add(purchase);
        consumeAsyncInternal(purchases, listener, null);
    }

    /**
     * Same as {@link consumeAsync}, but for multiple items at once.
     * @param purchases The list of PurchaseInfo objects representing the purchases to consume.
     * @param listener The listener to notify when the consumption operation finishes.
     */
    public void consumeAsync(List<Purchase> purchases, OnConsumeMultiFinishedListener listener) {
        checkNotDisposed();
        checkSetupDone("consume");
        consumeAsyncInternal(purchases, null, listener);
    }

    /**
     * Returns a human-readable description for the given response code.
     *
     * @param code The response code
     * @return A human-readable string explaining the result code.
     *     It also includes the result code numerically.
     */
    public static String getResponseDesc(int code) {
        String[] iab_msgs = ("0:OK/1:User Canceled/2:Unknown/" +
                "3:Billing Unavailable/4:Item unavailable/" +
                "5:Developer Error/6:Error/7:Item Already Owned/" +
                "8:Item not owned").split("/");
        String[] iabhelper_msgs = ("0:OK/-1001:Remote exception during initialization/" +
                                   "-1002:Bad response received/" +
                                   "-1003:Purchase signature verification failed/" +
                                   "-1004:Send intent failed/" +
                                   "-1005:User cancelled/" +
                                   "-1006:Unknown purchase response/" +
                                   "-1007:Missing token/" +
                                   "-1008:Unknown error/" +
                                   "-1009:Subscriptions not available/" +
                                   "-1010:Invalid consumption attempt").split("/");

        if (code <= IABHELPER_ERROR_BASE) {
            int index = IABHELPER_ERROR_BASE - code;
            if (index >= 0 && index < iabhelper_msgs.length) return iabhelper_msgs[index];
            else return String.valueOf(code) + ":Unknown IAB Helper Error";
        }
        else if (code < 0 || code >= iab_msgs.length)
            return String.valueOf(code) + ":Unknown";
        else
            return iab_msgs[code];
    }


    // Checks that setup was done; if not, throws an exception.
    void checkSetupDone(String operation) {
        if (!mSetupDone) {
            logError("Illegal state for operation (" + operation + "): IAB helper is not set up.");
            throw new IllegalStateException("IAB helper is not set up. Can't perform operation: " + operation);
        }
    }

    // Workaround to bug where sometimes response codes come as Long instead of Integer
    int getResponseCodeFromBundle(Bundle b) {
        Object o = b.get(RESPONSE_CODE);
        if (o == null) {
            logDebug("Bundle with null response code, assuming OK (known issue)");
            return BILLING_RESPONSE_RESULT_OK;
        }
        else if (o instanceof Integer) return ((Integer)o).intValue();
        else if (o instanceof Long) return (int)((Long)o).longValue();
        else {
            logError("Unexpected type for bundle response code.");
            logError(o.getClass().getName());
            throw new RuntimeException("Unexpected type for bundle response code: " + o.getClass().getName());
        }
    }

    // Workaround to bug where sometimes response codes come as Long instead of Integer
    int getResponseCodeFromIntent(Intent i) {
        Object o = i.getExtras().get(RESPONSE_CODE);
        if (o == null) {
            logError("Intent with no response code, assuming OK (known issue)");
            return BILLING_RESPONSE_RESULT_OK;
        }
        else if (o instanceof Integer) return ((Integer)o).intValue();
        else if (o instanceof Long) return (int)((Long)o).longValue();
        else {
            logError("Unexpected type for intent response code.");
            logError(o.getClass().getName());
            throw new RuntimeException("Unexpected type for intent response code: " + o.getClass().getName());
        }
    }

    void flagStartAsync(String operation) {
        if (mAsyncInProgress) throw new IllegalStateException("Can't start async operation (" +
                operation + ") because another async operation(" + mAsyncOperation + ") is in progress.");
        mAsyncOperation = operation;
        mAsyncInProgress = true;
        logDebug("Starting async operation: " + operation);
    }

    void flagEndAsync() {
        logDebug("Ending async operation: " + mAsyncOperation);
        mAsyncOperation = "";
        mAsyncInProgress = false;
    }


    int queryPurchases(Inventory inv, String itemType) throws JSONException, RemoteException {
        // Query purchases
        logDebug("Querying owned items, item type: " + itemType);
        logDebug("Package name: " + mContext.getPackageName());
        boolean verificationFailed = false;
        String continueToken = null;

        do {
            logDebug("Calling getPurchases with continuation token: " + continueToken);
            Bundle ownedItems = mService.getPurchases(3, mContext.getPackageName(),
                    itemType, continueToken);

            int response = getResponseCodeFromBundle(ownedItems);
            logDebug("Owned items response: " + String.valueOf(response));
            if (response != BILLING_RESPONSE_RESULT_OK) {
                logDebug("getPurchases() failed: " + getResponseDesc(response));
                return response;
            }
            if (!ownedItems.containsKey(RESPONSE_INAPP_ITEM_LIST)
                    || !ownedItems.containsKey(RESPONSE_INAPP_PURCHASE_DATA_LIST)
                    || !ownedItems.containsKey(RESPONSE_INAPP_SIGNATURE_LIST)) {
                logError("Bundle returned from getPurchases() doesn't contain required fields.");
                return IABHELPER_BAD_RESPONSE;
            }

            ArrayList<String> ownedSkus = ownedItems.getStringArrayList(
                        RESPONSE_INAPP_ITEM_LIST);
            ArrayList<String> purchaseDataList = ownedItems.getStringArrayList(
                        RESPONSE_INAPP_PURCHASE_DATA_LIST);
            ArrayList<String> signatureList = ownedItems.getStringArrayList(
                        RESPONSE_INAPP_SIGNATURE_LIST);

            for (int i = 0; i < purchaseDataList.size(); ++i) {
                String purchaseData = purchaseDataList.get(i);
                String signature = signatureList.get(i);
                String sku = ownedSkus.get(i);
                if (Security.verifyPurchase(mSignatureBase64, purchaseData, signature)) {
                    logDebug("Sku is owned: " + sku);
                    Purchase purchase = new Purchase(itemType, purchaseData, signature);

                    if (TextUtils.isEmpty(purchase.getToken())) {
                        logWarn("BUG: empty/null token!");
                        logDebug("Purchase data: " + purchaseData);
                    }

                    // Record ownership and token
                    inv.addPurchase(purchase);
                }
                else {
                    logWarn("Purchase signature verification **FAILED**. Not adding item.");
                    logDebug("   Purchase data: " + purchaseData);
                    logDebug("   Signature: " + signature);
                    verificationFailed = true;
                }
            }

            continueToken = ownedItems.getString(INAPP_CONTINUATION_TOKEN);
            logDebug("Continuation token: " + continueToken);
        } while (!TextUtils.isEmpty(continueToken));

        return verificationFailed ? IABHELPER_VERIFICATION_FAILED : BILLING_RESPONSE_RESULT_OK;
    }

    int querySkuDetails(String itemType, Inventory inv, List<String> moreSkus)
                                throws RemoteException, JSONException {
        logDebug("Querying SKU details.");
        ArrayList<String> skuList = new ArrayList<String>();
        skuList.addAll(inv.getAllOwnedSkus(itemType));
        if (moreSkus != null) {
            for (String sku : moreSkus) {
                if (!skuList.contains(sku)) {
                    skuList.add(sku);
                }
            }
        }

        if (skuList.size() == 0) {
            logDebug("queryPrices: nothing to do because there are no SKUs.");
            return BILLING_RESPONSE_RESULT_OK;
        }

        Bundle querySkus = new Bundle();
        querySkus.putStringArrayList(GET_SKU_DETAILS_ITEM_LIST, skuList);
        Bundle skuDetails = mService.getSkuDetails(3, mContext.getPackageName(),
                itemType, querySkus);

        if (!skuDetails.containsKey(RESPONSE_GET_SKU_DETAILS_LIST)) {
            int response = getResponseCodeFromBundle(skuDetails);
            if (response != BILLING_RESPONSE_RESULT_OK) {
                logDebug("getSkuDetails() failed: " + getResponseDesc(response));
                return response;
            }
            else {
                logError("getSkuDetails() returned a bundle with neither an error nor a detail list.");
                return IABHELPER_BAD_RESPONSE;
            }
        }

        ArrayList<String> responseList = skuDetails.getStringArrayList(
                RESPONSE_GET_SKU_DETAILS_LIST);

        for (String thisResponse : responseList) {
            SkuDetails d = new SkuDetails(itemType, thisResponse);
            logDebug("Got sku details: " + d);
            inv.addSkuDetails(d);
        }
        return BILLING_RESPONSE_RESULT_OK;
    }


    void consumeAsyncInternal(final List<Purchase> purchases,
                              final OnConsumeFinishedListener singleListener,
                              final OnConsumeMultiFinishedListener multiListener) {
        final Handler handler = new Handler();
        flagStartAsync("consume");
        (new Thread(new Runnable() {
            public void run() {
                final List<IabResult> results = new ArrayList<IabResult>();
                for (Purchase purchase : purchases) {
                    try {
                        consume(purchase);
                        results.add(new IabResult(BILLING_RESPONSE_RESULT_OK, "Successful consume of sku " + purchase.getSku()));
                    }
                    catch (IabException ex) {
                        results.add(ex.getResult());
                    }
                }

                flagEndAsync();
                if (!mDisposed && singleListener != null) {
                    handler.post(new Runnable() {
                        public void run() {
                            singleListener.onConsumeFinished(purchases.get(0), results.get(0));
                        }
                    });
                }
                if (!mDisposed && multiListener != null) {
                    handler.post(new Runnable() {
                        public void run() {
                            multiListener.onConsumeMultiFinished(purchases, results);
                        }
                    });
                }
            }
        })).start();
    }

    void logDebug(String msg) {
        if (mDebugLog) Log.d(mDebugTag, msg);
    }

    void logError(String msg) {
        Log.e(mDebugTag, "In-app billing error: " + msg);
    }

    void logWarn(String msg) {
        Log.w(mDebugTag, "In-app billing warning: " + msg);
    }
}
!@#$%
20190530_041533,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_b04328
package net.osmand.plus.dashboard;

import android.annotation.SuppressLint;
import android.content.Intent;
import android.content.res.Resources;
import android.graphics.drawable.ColorDrawable;
import android.graphics.drawable.Drawable;
import android.os.Build;
import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentManager;
import android.support.v4.app.FragmentTransaction;
import android.support.v7.widget.Toolbar;
import android.util.TypedValue;
import android.view.Gravity;
import android.view.View;
import android.view.animation.Animation;
import android.view.animation.Animation.AnimationListener;
import android.view.animation.TranslateAnimation;
import android.widget.AbsListView;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.ArrayAdapter;
import android.widget.Button;
import android.widget.CompoundButton;
import android.widget.FrameLayout;
import android.widget.ImageView;
import android.widget.ImageView.ScaleType;
import android.widget.ListView;
import android.widget.ScrollView;
import android.widget.TextView;

import com.github.ksoichiro.android.observablescrollview.ObservableListView;
import com.github.ksoichiro.android.observablescrollview.ObservableScrollView;
import com.github.ksoichiro.android.observablescrollview.ObservableScrollViewCallbacks;
import com.github.ksoichiro.android.observablescrollview.ScrollState;

import net.osmand.PlatformUtil;
import net.osmand.ValueHolder;
import net.osmand.data.LatLon;
import net.osmand.plus.ContextMenuAdapter;
import net.osmand.plus.ContextMenuAdapter.OnContextMenuClick;
import net.osmand.plus.ContextMenuAdapter.OnRowItemClick;
import net.osmand.plus.IconsCache;
import net.osmand.plus.OsmandApplication;
import net.osmand.plus.OsmandPlugin;
import net.osmand.plus.OsmandSettings;
import net.osmand.plus.R;
import net.osmand.plus.TargetPointsHelper.TargetPoint;
import net.osmand.plus.activities.MapActivity;
import net.osmand.plus.dashboard.tools.DashFragmentData;
import net.osmand.plus.dashboard.tools.DashboardSettingsDialogFragment;
import net.osmand.plus.dashboard.tools.TransactionBuilder;
import net.osmand.plus.dialogs.ConfigureMapMenu;
import net.osmand.plus.dialogs.RasterMapMenu;
import net.osmand.plus.download.DownloadActivity;
import net.osmand.plus.helpers.AndroidUiHelper;
import net.osmand.plus.helpers.WaypointDialogHelper;
import net.osmand.plus.helpers.WaypointDialogHelper.WaypointDialogHelperCallbacks;
import net.osmand.plus.helpers.WaypointHelper.LocationPointWrapper;
import net.osmand.plus.mapcontextmenu.other.RoutePreferencesMenu;
import net.osmand.plus.mapcontextmenu.other.RoutePreferencesMenu.LocalRoutingParameter;
import net.osmand.plus.rastermaps.OsmandRasterMapsPlugin;
import net.osmand.plus.routing.RoutingHelper;
import net.osmand.plus.routing.RoutingHelper.IRouteInformationListener;
import net.osmand.plus.views.DownloadedRegionsLayer;
import net.osmand.plus.views.OsmandMapTileView;
import net.osmand.plus.views.controls.DynamicListView;
import net.osmand.plus.views.controls.DynamicListViewCallbacks;
import net.osmand.plus.views.controls.StableArrayAdapter;
import net.osmand.plus.views.controls.SwipeDismissListViewTouchListener;
import net.osmand.plus.views.controls.SwipeDismissListViewTouchListener.Undoable;

import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import static android.util.TypedValue.COMPLEX_UNIT_DIP;

/**
 */
public class DashboardOnMap implements ObservableScrollViewCallbacks, DynamicListViewCallbacks,
		IRouteInformationListener, WaypointDialogHelperCallbacks {
	private static final org.apache.commons.logging.Log LOG =
			PlatformUtil.getLog(DashboardOnMap.class);
	private static final String TAG = "DashboardOnMap";
	public static boolean staticVisible = false;
	public static DashboardType staticVisibleType = DashboardType.DASHBOARD;
	public static final String SHOULD_SHOW = "should_show";


	private final DashFragmentData[] fragmentsData = new DashFragmentData[]{
			new DashFragmentData(DashRateUsFragment.TAG, DashRateUsFragment.class,
					DashRateUsFragment.SHOULD_SHOW_FUNCTION, 0, null),
			new DashFragmentData(DashDashboardOrDrawerFragment.TAG, DashDashboardOrDrawerFragment.class,
					DashDashboardOrDrawerFragment.SHOULD_SHOW_FUNCTION, 5, null),
			new DashFragmentData(DashErrorFragment.TAG, DashErrorFragment.class,
					DashErrorFragment.SHOULD_SHOW_FUNCTION, 30, null),
			new DashFragmentData(DashNavigationFragment.TAG, DashNavigationFragment.class,
					DashNavigationFragment.SHOULD_SHOW_FUNCTION, 40, null),
			new DashFragmentData(DashWaypointsFragment.TAG, DashWaypointsFragment.class,
					DashWaypointsFragment.SHOULD_SHOW_FUNCTION, 60, null),
			new DashFragmentData(DashSearchFragment.TAG, DashSearchFragment.class,
					DashSearchFragment.SHOULD_SHOW_FUNCTION, 70, null),
			DashRecentsFragment.FRAGMENT_DATA,
			DashFavoritesFragment.FRAGMENT_DATA,
			new DashFragmentData(DashPluginsFragment.TAG, DashPluginsFragment.class,
					DashPluginsFragment.SHOULD_SHOW_FUNCTION, 140, null)
	};

	private MapActivity mapActivity;
	private ImageView actionButton;
	private FrameLayout dashboardView;

	private ArrayAdapter<?> listAdapter;
	private OnItemClickListener listAdapterOnClickListener;
	private SwipeDismissListViewTouchListener swipeDismissListener;

	private boolean visible = false;
	private DashboardType visibleType;
	private DashboardType previousVisibleType;
	private boolean landscape;
	private List<WeakReference<DashBaseFragment>> fragList = new LinkedList<>();
	private net.osmand.Location myLocation;
	private LatLon mapViewLocation;
	private float heading;
	private boolean mapLinkedToLocation;
	private float mapRotation;
	private boolean inLocationUpdate = false;
	private ListView listView;
	private View listBackgroundView;
	private Toolbar toolbar;
	private View paddingView;
	private int mFlexibleSpaceImageHeight;
	private int mFlexibleBlurSpaceHeight;
	private boolean portrait;

	int baseColor;

	private WaypointDialogHelper waypointDialogHelper;
	private final int[] running = new int[]{-1};
	private List<LocationPointWrapper> deletedPoints = new ArrayList<>();
	private Drawable gradientToolbar;
	boolean nightMode;

	public DashFragmentData[] getFragmentsData() {
		return fragmentsData;
	}

	public enum DashboardType {
		WAYPOINTS,
		WAYPOINTS_FLAT,
		CONFIGURE_SCREEN,
		CONFIGURE_MAP,
		LIST_MENU,
		ROUTE_PREFERENCES,
		DASHBOARD,
		OVERLAY_MAP,
		UNDERLAY_MAP
	}

	private Map<DashboardActionButtonType, DashboardActionButton> actionButtons = new HashMap<>();

	public enum DashboardActionButtonType {
		MY_LOCATION,
		NAVIGATE,
		ROUTE
	}

	private class DashboardActionButton {
		private Drawable icon;
		private View.OnClickListener onClickListener;
	}

	public DashboardOnMap(MapActivity ma) {
		this.mapActivity = ma;
	}


	public void createDashboardView() {
		baseColor = mapActivity.getResources().getColor(R.color.osmand_orange) & 0x00ffffff;
		waypointDialogHelper = new WaypointDialogHelper(mapActivity);
		waypointDialogHelper.setWaypointDialogHelperCallbacks(this);
		landscape = !AndroidUiHelper.isOrientationPortrait(mapActivity);
		dashboardView = (FrameLayout) mapActivity.findViewById(R.id.dashboard);
		final View.OnClickListener listener = new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				hideDashboard();
			}
		};
		toolbar = ((Toolbar) dashboardView.findViewById(R.id.toolbar));
		ObservableScrollView scrollView = ((ObservableScrollView) dashboardView.findViewById(R.id.main_scroll));
		listView = (ListView) dashboardView.findViewById(R.id.dash_list_view);
		//listView.setChoiceMode(ListView.CHOICE_MODE_SINGLE);
		listView.setDrawSelectorOnTop(true);
		((DynamicListView) listView).setDynamicListViewCallbacks(this);

		// Create a ListView-specific touch listener. ListViews are given special treatment because
		// by default they handle touches for their list items... i.e. they're in charge of drawing
		// the pressed state (the list selector), handling list item clicks, etc.
		swipeDismissListener = new SwipeDismissListViewTouchListener(
				listView,
				new SwipeDismissListViewTouchListener.DismissCallbacks() {
					@Override
					public boolean canDismiss(int position) {
						boolean res = false;
						if (visibleType == DashboardType.WAYPOINTS && listAdapter instanceof StableArrayAdapter) {
							List<Object> activeObjects = ((StableArrayAdapter) listAdapter).getActiveObjects();
							Object obj = listAdapter.getItem(position);
							res = activeObjects.contains(obj);
						}
						return res;
					}

					@Override
					public Undoable onDismiss(final int position) {
						final Object item;
						final StableArrayAdapter stableAdapter;
						final int activeObjPos;
						if (listAdapter instanceof StableArrayAdapter) {
							stableAdapter = (StableArrayAdapter) listAdapter;
							item = stableAdapter.getItem(position);

							stableAdapter.setNotifyOnChange(false);
							stableAdapter.remove(item);
							stableAdapter.getObjects().remove(item);
							activeObjPos = stableAdapter.getActiveObjects().indexOf(item);
							stableAdapter.getActiveObjects().remove(item);
							stableAdapter.refreshData();
							stableAdapter.notifyDataSetChanged();

						} else {
							item = null;
							stableAdapter = null;
							activeObjPos = 0;
						}
						return new Undoable() {
							@Override
							public void undo() {
								if (item != null) {
									stableAdapter.setNotifyOnChange(false);
									stableAdapter.insert(item, position);
									stableAdapter.getObjects().add(position, item);
									stableAdapter.getActiveObjects().add(activeObjPos, item);
									stableAdapter.refreshData();
									onItemsSwapped(stableAdapter.getActiveObjects());
								}
							}

							@Override
							public String getTitle() {
								if (visibleType == DashboardType.WAYPOINTS
										&& (getMyApplication().getRoutingHelper().isRoutePlanningMode() || getMyApplication().getRoutingHelper().isFollowingMode())
										&& item != null
										&& stableAdapter.getActiveObjects().size() == 0) {
									return mapActivity.getResources().getString(R.string.cancel_navigation);
								} else {
									return null;
								}
							}
						};
					}

					@Override
					public void onHidePopup() {
						if (listAdapter instanceof StableArrayAdapter) {
							StableArrayAdapter stableAdapter = (StableArrayAdapter) listAdapter;
							stableAdapter.refreshData();
							onItemsSwapped(stableAdapter.getActiveObjects());
							if (stableAdapter.getActiveObjects().size() == 0) {
								hideDashboard();
								mapActivity.getMapActions().stopNavigationWithoutConfirm();
								mapActivity.getMapLayers().getMapControlsLayer().getMapRouteInfoMenu().hide();
							}
						}
					}
				});

		gradientToolbar = mapActivity.getResources().getDrawable(R.drawable.gradient_toolbar).mutate();
		if (AndroidUiHelper.isOrientationPortrait(mapActivity)) {
			this.portrait = true;
			scrollView.setScrollViewCallbacks(this);
			((ObservableListView) listView).setScrollViewCallbacks(this);
			mFlexibleSpaceImageHeight = mapActivity.getResources().getDimensionPixelSize(
					R.dimen.dashboard_map_top_padding);
			mFlexibleBlurSpaceHeight = mapActivity.getResources().getDimensionPixelSize(
					R.dimen.dashboard_map_toolbar);
			// Set padding view for ListView. This is the flexible space.
			paddingView = new FrameLayout(mapActivity);
			AbsListView.LayoutParams lp = new AbsListView.LayoutParams(AbsListView.LayoutParams.MATCH_PARENT,
					mFlexibleSpaceImageHeight);
			paddingView.setLayoutParams(lp);
			// This is required to disable header's list selector effect
			paddingView.setClickable(true);
			paddingView.setOnClickListener(listener);

			FrameLayout shadowContainer = new FrameLayout(mapActivity);
			FrameLayout.LayoutParams fl = new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT,
					FrameLayout.LayoutParams.MATCH_PARENT);
			fl.gravity = Gravity.BOTTOM;
			shadowContainer.setLayoutParams(fl);
			ImageView shadow = new ImageView(mapActivity);
			shadow.setImageDrawable(mapActivity.getResources().getDrawable(R.drawable.bg_shadow_onmap));
			shadow.setLayoutParams(new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT,
					FrameLayout.LayoutParams.WRAP_CONTENT, Gravity.BOTTOM));
			shadow.setScaleType(ScaleType.FIT_XY);
			shadowContainer.addView(shadow);
			((FrameLayout) paddingView).addView(shadowContainer);
			listView.addHeaderView(paddingView);
			listBackgroundView = mapActivity.findViewById(R.id.dash_list_background);
		}
		dashboardView.findViewById(R.id.animateContent).setOnClickListener(listener);
		dashboardView.findViewById(R.id.map_part_dashboard).setOnClickListener(listener);

		initActionButtons();
		dashboardView.addView(actionButton);
	}


	private void updateListBackgroundHeight() {

		if (listBackgroundView == null || listBackgroundView.getHeight() > 0) {
			return;
		}
		final View contentView = mapActivity.getWindow().getDecorView().findViewById(android.R.id.content);
		if (contentView.getHeight() > 0) {
			listBackgroundView.getLayoutParams().height = contentView.getHeight();
		} else {
			contentView.post(new Runnable() {
				@Override
				public void run() {
					// mListBackgroundView's should fill its parent vertically
					// but the height of the content view is 0 on 'onCreate'.
					// So we should get it with post().
					listBackgroundView.getLayoutParams().height = contentView.getHeight();
				}
			});
		}
	}

	private void updateToolbarActions() {
		TextView tv = (TextView) dashboardView.findViewById(R.id.toolbar_text);
		tv.setText("");
		boolean waypointsVisible = visibleType == DashboardType.WAYPOINTS || visibleType == DashboardType.WAYPOINTS_FLAT;
		if (waypointsVisible) {
			tv.setText(R.string.waypoints);
		} else if (visibleType == DashboardType.CONFIGURE_MAP) {
			tv.setText(R.string.configure_map);
		} else if (visibleType == DashboardType.CONFIGURE_SCREEN) {
			tv.setText(R.string.layer_map_appearance);
		} else if (visibleType == DashboardType.ROUTE_PREFERENCES) {
			tv.setText(R.string.shared_string_settings);
		} else if (visibleType == DashboardType.UNDERLAY_MAP) {
			tv.setText(R.string.map_underlay);
		} else if (visibleType == DashboardType.OVERLAY_MAP) {
			tv.setText(R.string.map_overlay);
		}
		ImageView edit = (ImageView) dashboardView.findViewById(R.id.toolbar_edit);
		edit.setVisibility(View.GONE);
		ImageView sort = (ImageView) dashboardView.findViewById(R.id.toolbar_sort);
		sort.setVisibility(View.GONE);
		ImageView ok = (ImageView) dashboardView.findViewById(R.id.toolbar_ok);
		ok.setVisibility(View.GONE);
		ImageView flat = (ImageView) dashboardView.findViewById(R.id.toolbar_flat);
		flat.setVisibility(View.GONE);
		ImageView settingsButton = (ImageView) dashboardView.findViewById(R.id.toolbar_settings);
		settingsButton.setVisibility(View.GONE);
		IconsCache iconsCache = mapActivity.getMyApplication().getIconsCache();
		ImageView lst = (ImageView) dashboardView.findViewById(R.id.toolbar_list);
		lst.setVisibility(View.GONE);
		ImageView back = (ImageView) dashboardView.findViewById(R.id.toolbar_back);
		back.setImageDrawable(
				getMyApplication().getIconsCache().getIcon(R.drawable.abc_ic_ab_back_mtrl_am_alpha));
		back.setOnClickListener(new View.OnClickListener() {

			@Override
			public void onClick(View v) {
				backPressed();
			}
		});

		if (waypointsVisible && getMyApplication().getWaypointHelper().getAllPoints().size() > 0) {
			if (getMyApplication().getWaypointHelper().isRouteCalculated()) {
				flat.setVisibility(View.VISIBLE);
				final boolean flatNow = visibleType == DashboardType.WAYPOINTS_FLAT;
				flat.setImageDrawable(iconsCache.getIcon(flatNow ? R.drawable.ic_tree_list_dark
						: R.drawable.ic_flat_list_dark));
				flat.setOnClickListener(new View.OnClickListener() {

					@Override
					public void onClick(View v) {
						setDashboardVisibility(true, flatNow ? DashboardType.WAYPOINTS : DashboardType.WAYPOINTS_FLAT,
								previousVisibleType, false);
					}
				});
			}
		}
//		if (waypointsEdit) {
//			ok.setVisibility(View.VISIBLE);
//			ok.setOnClickListener(new View.OnClickListener() {
//
//				@Override
//				public void onClick(View v) {
//					mapActivity.getMyApplication().getWaypointHelper().removeVisibleLocationPoint(deletedPoints);
//					hideDashboard();
//				}
//			});
//		}
		if (visibleType == DashboardType.DASHBOARD || visibleType == DashboardType.LIST_MENU) {
			settingsButton.setVisibility(View.VISIBLE);
			settingsButton.setOnClickListener(new View.OnClickListener() {

				@Override
				public void onClick(View v) {
					new DashboardSettingsDialogFragment().show(
							mapActivity.getSupportFragmentManager(), "dashboard_settings");
				}
			});
			lst.setVisibility(View.VISIBLE);
			lst.setOnClickListener(new View.OnClickListener() {

				@Override
				public void onClick(View v) {
					hideDashboard(false);
					mapActivity.openDrawer();
				}
			});
		}
	}


	private void initActionButtons() {
		actionButton = new ImageView(mapActivity);
		int btnSize = (int) mapActivity.getResources().getDimension(R.dimen.map_button_size);
		int topPad = (int) mapActivity.getResources().getDimension(R.dimen.dashboard_map_top_padding);
		FrameLayout.LayoutParams params = new FrameLayout.LayoutParams(
				btnSize, btnSize
		);
		int marginRight = btnSize / 4;
		params.setMargins(0, landscape ? 0 : topPad - 2 * btnSize,
				marginRight, landscape ? marginRight : 0);
		params.gravity = landscape ? Gravity.BOTTOM | Gravity.RIGHT : Gravity.TOP | Gravity.RIGHT;
		actionButton.setLayoutParams(params);
		actionButton.setScaleType(ScaleType.CENTER);
		actionButton.setBackgroundDrawable(mapActivity.getResources().getDrawable(R.drawable.btn_circle_blue));
		hideActionButton();


		DashboardActionButton myLocationButton = new DashboardActionButton();
		myLocationButton.icon = mapActivity.getResources().getDrawable(R.drawable.map_my_location);
		myLocationButton.onClickListener = new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				if (getMyApplication().accessibilityEnabled()) {
					mapActivity.getMapActions().whereAmIDialog();
				} else {
					mapActivity.getMapViewTrackingUtilities().backToLocationImpl();
				}
				hideDashboard();
			}
		};

		DashboardActionButton navigateButton = new DashboardActionButton();
		navigateButton.icon = mapActivity.getResources().getDrawable(R.drawable.map_start_navigation);
		navigateButton.onClickListener = new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				mapActivity.getMapLayers().getMapControlsLayer().doNavigate();
				hideDashboard();
			}
		};

		DashboardActionButton routeButton = new DashboardActionButton();
		routeButton.icon = mapActivity.getResources().getDrawable(R.drawable.map_directions);
		routeButton.onClickListener = new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				mapActivity.getMapLayers().getMapControlsLayer().doRoute();
				hideDashboard();
			}
		};

		actionButtons.put(DashboardActionButtonType.MY_LOCATION, myLocationButton);
		actionButtons.put(DashboardActionButtonType.NAVIGATE, navigateButton);
		actionButtons.put(DashboardActionButtonType.ROUTE, routeButton);
	}

	private void setActionButton(DashboardType type) {
		DashboardActionButton button = null;

		if (type == DashboardType.DASHBOARD
				|| type == DashboardType.LIST_MENU
				|| type == DashboardType.CONFIGURE_SCREEN) {
			button = actionButtons.get(DashboardActionButtonType.MY_LOCATION);
		} else if (type == DashboardType.ROUTE_PREFERENCES) {
			button = actionButtons.get(DashboardActionButtonType.NAVIGATE);
		} else if (type == DashboardType.WAYPOINTS || type == DashboardType.WAYPOINTS_FLAT) {
			boolean routePlanningMode = false;
			RoutingHelper rh = mapActivity.getRoutingHelper();
			if (rh.isRoutePlanningMode()) {
				routePlanningMode = true;
			} else if ((rh.isRouteCalculated() || rh.isRouteBeingCalculated()) && !rh.isFollowingMode()) {
				routePlanningMode = true;
			}
			boolean routeFollowingMode = !routePlanningMode && rh.isFollowingMode();

			if (routePlanningMode || routeFollowingMode) {
				button = actionButtons.get(DashboardActionButtonType.NAVIGATE);
			} else {
				button = actionButtons.get(DashboardActionButtonType.ROUTE);
			}
		}

		if (button != null) {
			actionButton.setImageDrawable(button.icon);
			actionButton.setOnClickListener(button.onClickListener);
		}
	}

	private void hideActionButton() {
		actionButton.setVisibility(View.GONE);
	}

	public net.osmand.Location getMyLocation() {
		return myLocation;
	}

	public LatLon getMapViewLocation() {
		return mapViewLocation;
	}

	public float getHeading() {
		return heading;
	}

	public float getMapRotation() {
		return mapRotation;
	}

	public boolean isMapLinkedToLocation() {
		return mapLinkedToLocation;
	}

	protected OsmandApplication getMyApplication() {
		return mapActivity.getMyApplication();
	}

	public ArrayAdapter<?> getListAdapter() {
		return listAdapter;
	}

	public OnItemClickListener getListAdapterOnClickListener() {
		return listAdapterOnClickListener;
	}

	public void hideDashboard() {
		setDashboardVisibility(false, visibleType);
	}

	public void hideDashboard(boolean animation) {
		setDashboardVisibility(false, visibleType, animation);
	}

	public void setDashboardVisibility(boolean visible, DashboardType type) {
		setDashboardVisibility(visible, type, this.visible ? visibleType : null, true);
	}

	public void setDashboardVisibility(boolean visible, DashboardType type, boolean animation) {
		setDashboardVisibility(visible, type, this.visible ? visibleType : null, animation);
	}

	public void refreshDashboardFragments() {
		addOrUpdateDashboardFragments();
	}

	public void setDashboardVisibility(boolean visible, DashboardType type, DashboardType prevItem, boolean animation) {
		if (visible == this.visible && type == visibleType) {
			return;
		}
		nightMode = mapActivity.getMyApplication().getDaynightHelper().isNightModeForMapControls();
		this.previousVisibleType = prevItem;
		this.visible = visible;
		boolean refresh = this.visibleType == type;
		this.visibleType = type;
		DashboardOnMap.staticVisible = visible;
		DashboardOnMap.staticVisibleType = type;
		mapActivity.enableDrawer();
		if (visible) {
			mapViewLocation = mapActivity.getMapLocation();
			mapRotation = mapActivity.getMapRotate();
			mapLinkedToLocation = mapActivity.getMapViewTrackingUtilities().isMapLinkedToLocation();
			myLocation = mapActivity.getMyApplication().getLocationProvider().getLastKnownLocation();
			mapActivity.getMapViewTrackingUtilities().setDashboard(this);
			mapActivity.disableDrawer();
			dashboardView.setVisibility(View.VISIBLE);
			if (isActionButtonVisible()) {
				setActionButton(visibleType);
				actionButton.setVisibility(View.VISIBLE);
			} else {
				hideActionButton();
			}
			updateDownloadBtn();
			View listViewLayout = dashboardView.findViewById(R.id.dash_list_view_layout);
			ScrollView scrollView = (ScrollView) dashboardView.findViewById(R.id.main_scroll);
			if (visibleType == DashboardType.DASHBOARD) {
				addOrUpdateDashboardFragments();
				scrollView.setVisibility(View.VISIBLE);
				scrollView.scrollTo(0, 0);
				listViewLayout.setVisibility(View.GONE);
				onScrollChanged(scrollView.getScrollY(), false, false);
			} else {
				scrollView.setVisibility(View.GONE);
				listViewLayout.setVisibility(View.VISIBLE);
				if (listView instanceof ObservableListView) {
					onScrollChanged(listView.getScrollY(), false, false);
				}
				if (refresh) {
					refreshContent(false);
				} else {
					updateListAdapter();
					updateListBackgroundHeight();
				}
				applyDayNightMode();
			}
			mapActivity.findViewById(R.id.toolbar_back).setVisibility(isBackButtonVisible() ? View.VISIBLE : View.GONE);
			mapActivity.findViewById(R.id.MapHudButtonsOverlay).setVisibility(View.INVISIBLE);
			boolean portrait = AndroidUiHelper.isOrientationPortrait(mapActivity);
			if (!portrait) {
				AndroidUiHelper.updateVisibility(mapActivity.findViewById(R.id.map_route_land_left_margin_external), true);
				mapActivity.getMapView().setMapPositionX(1);
				mapActivity.refreshMap();
			}

			updateToolbarActions();
			//fabButton.showFloatingActionButton();
			open(dashboardView.findViewById(R.id.animateContent), animation);
			updateLocation(true, true, false);
//			addOrUpdateDashboardFragments();
			mapActivity.getRoutingHelper().addListener(this);
		} else {
			if (swipeDismissListener != null) {
				swipeDismissListener.discardUndo();
			}
			mapActivity.getRoutingHelper().removeListener(this);
			mapActivity.getMapViewTrackingUtilities().setDashboard(null);
			hide(dashboardView.findViewById(R.id.animateContent), animation);

			if (!mapActivity.getMapLayers().getMapControlsLayer().getMapRouteInfoMenu().isVisible()) {
				AndroidUiHelper.updateVisibility(mapActivity.findViewById(R.id.map_route_land_left_margin_external), false);
				mapActivity.getMapView().setMapPositionX(0);
				mapActivity.getMapView().refreshMap();
			}

			mapActivity.findViewById(R.id.MapHudButtonsOverlay).setVisibility(View.VISIBLE);
			hideActionButton();
			for (WeakReference<DashBaseFragment> df : fragList) {
				if (df.get() != null) {
					df.get().onCloseDash();
				}
			}
		}
	}

	private void applyDayNightMode() {
		if (nightMode) {
			if (listBackgroundView != null) {
				listBackgroundView.setBackgroundColor(mapActivity.getResources().getColor(R.color.ctx_menu_info_view_bg_dark));
			} else {
				listView.setBackgroundColor(mapActivity.getResources().getColor(R.color.ctx_menu_info_view_bg_dark));
			}
			if (visibleType != DashboardType.WAYPOINTS) {
				Drawable d = new ColorDrawable(mapActivity.getResources().getColor(R.color.dashboard_divider_dark));
				listView.setDivider(d);
				listView.setDividerHeight(dpToPx(1f));
			} else {
				listView.setDivider(null);
			}
		} else {
			if (listBackgroundView != null) {
				listBackgroundView.setBackgroundColor(mapActivity.getResources().getColor(R.color.ctx_menu_info_view_bg_light));
			} else {
				listView.setBackgroundColor(mapActivity.getResources().getColor(R.color.ctx_menu_info_view_bg_light));
			}
			if (visibleType != DashboardType.WAYPOINTS) {
				Drawable d = new ColorDrawable(mapActivity.getResources().getColor(R.color.dashboard_divider_light));
				listView.setDivider(d);
				listView.setDividerHeight(dpToPx(1f));
			} else {
				listView.setDivider(null);
			}
		}
	}

	private int dpToPx(float dp) {
		Resources r = mapActivity.getResources();
		return (int) TypedValue.applyDimension(COMPLEX_UNIT_DIP, dp, r.getDisplayMetrics());
	}

	private void updateListAdapter() {
		ContextMenuAdapter cm = null;
		if (DashboardType.WAYPOINTS == visibleType || DashboardType.WAYPOINTS_FLAT == visibleType) {
			StableArrayAdapter listAdapter = waypointDialogHelper.getWaypointsDrawerAdapter(true, deletedPoints, mapActivity, running,
					DashboardType.WAYPOINTS_FLAT == visibleType, nightMode);
			OnItemClickListener listener = waypointDialogHelper.getDrawerItemClickListener(mapActivity, running,
					listAdapter);

			DynamicListView dynamicListView = (DynamicListView) listView;
			dynamicListView.setItemsList(listAdapter.getObjects());
			dynamicListView.setActiveItemsList(listAdapter.getActiveObjects());

			updateListAdapter(listAdapter, listener);

		} else {
			if (DashboardType.CONFIGURE_SCREEN == visibleType) {
				cm = mapActivity.getMapLayers().getMapWidgetRegistry().getViewConfigureMenuAdapter(mapActivity);
			} else if (DashboardType.CONFIGURE_MAP == visibleType) {
				cm = new ConfigureMapMenu().createListAdapter(mapActivity);
			} else if (DashboardType.LIST_MENU == visibleType) {
				cm = mapActivity.getMapActions().createMainOptionsMenu();
			} else if (DashboardType.ROUTE_PREFERENCES == visibleType) {
				RoutePreferencesMenu routePreferencesMenu = new RoutePreferencesMenu(mapActivity);
				ArrayAdapter<LocalRoutingParameter> listAdapter = routePreferencesMenu.getRoutePreferencesDrawerAdapter(nightMode);
				OnItemClickListener listener = routePreferencesMenu.getItemClickListener(listAdapter);
				updateListAdapter(listAdapter, listener);
			} else if (DashboardType.UNDERLAY_MAP == visibleType) {
				cm = RasterMapMenu.createListAdapter(mapActivity, OsmandRasterMapsPlugin.RasterMapType.UNDERLAY);
			} else if (DashboardType.OVERLAY_MAP == visibleType) {
				cm = RasterMapMenu.createListAdapter(mapActivity, OsmandRasterMapsPlugin.RasterMapType.OVERLAY);
			}
			if (cm != null) {
				updateListAdapter(cm);
			}
		}
	}

	public void updateListAdapter(ContextMenuAdapter cm) {
		boolean nightMode = mapActivity.getMyApplication().getDaynightHelper().isNightModeForMapControls();
		if (this.nightMode != nightMode) {
			this.nightMode = nightMode;
			applyDayNightMode();
		}
		final ArrayAdapter<?> listAdapter = cm.createListAdapter(mapActivity, !nightMode);
		OnItemClickListener listener = getOptionsMenuOnClickListener(cm, listAdapter);
		updateListAdapter(listAdapter, listener);
	}

	public void refreshContent(boolean force) {
		if (visibleType == DashboardType.WAYPOINTS || force) {
			updateListAdapter();
		} else if (visibleType == DashboardType.CONFIGURE_MAP || visibleType == DashboardType.ROUTE_PREFERENCES) {
			int index = listView.getFirstVisiblePosition();
			View v = listView.getChildAt(0);
			int top = (v == null) ? 0 : (v.getTop() - listView.getPaddingTop());
			updateListAdapter();
			listView.setSelectionFromTop(index, top);
		} else {
			listAdapter.notifyDataSetChanged();
		}
	}


	private OnItemClickListener getOptionsMenuOnClickListener(final ContextMenuAdapter cm,
															  final ArrayAdapter<?> listAdapter) {
		return new AdapterView.OnItemClickListener() {

			@Override
			public void onItemClick(AdapterView<?> parent, View view, int which, long id) {
				OnContextMenuClick click = cm.getClickAdapter(which);
				if (click instanceof OnRowItemClick) {
					boolean cl = ((OnRowItemClick) click).onRowItemClick(listAdapter, view, cm.getElementId(which), which);
					if (cl) {
						hideDashboard();
					}
				} else if (click != null) {
					CompoundButton btn = (CompoundButton) view.findViewById(R.id.check_item);
					if (btn != null && btn.getVisibility() == View.VISIBLE) {
						btn.setChecked(!btn.isChecked());
					} else {
						if (click.onContextMenuClick(listAdapter, cm.getElementId(which), which, false)) {
							hideDashboard();
						}
					}
				} else {
					hideDashboard();
				}
			}
		};
	}

	private void updateDownloadBtn() {
		Button btn = (Button) dashboardView.findViewById(R.id.map_download_button);
		String filter = null;
		String txt = "";
		OsmandMapTileView mv = mapActivity.getMapView();
		if (mv != null && !mapActivity.getMyApplication().isApplicationInitializing()) {
			if (mv.getZoom() < 11 && !mapActivity.getMyApplication().getResourceManager().containsBasemap()) {
				filter = "basemap";
				txt = mapActivity.getString(R.string.shared_string_download) + " "
						+ mapActivity.getString(R.string.base_world_map);
			} else {
				DownloadedRegionsLayer dl = mv.getLayerByClass(DownloadedRegionsLayer.class);
				if (dl != null) {
					StringBuilder btnName = new StringBuilder();
					filter = dl.getFilter(btnName);
					txt = btnName.toString();
				}
			}
		}

		btn.setText(txt);
		btn.setVisibility(filter == null ? View.GONE : View.VISIBLE);
		final String f = filter;
		btn.setOnClickListener(new View.OnClickListener() {

			@Override
			public void onClick(View v) {
				hideDashboard(false);
				final Intent intent = new Intent(mapActivity, mapActivity.getMyApplication().getAppCustomization()
						.getDownloadIndexActivity());
				if (f != null && !f.equals("basemap")) {
					intent.putExtra(DownloadActivity.FILTER_KEY, f);
				}
				intent.putExtra(DownloadActivity.TAB_TO_OPEN, DownloadActivity.DOWNLOAD_TAB);
				mapActivity.startActivity(intent);
			}
		});
		scheduleDownloadButtonCheck();
	}

	private void scheduleDownloadButtonCheck() {
		mapActivity.getMyApplication().runInUIThread(new Runnable() {

			@Override
			public void run() {
				if (isVisible()) {
					updateDownloadBtn();
				}
			}
		}, 4000);
	}


	public void navigationAction() {
		RoutingHelper routingHelper = mapActivity.getRoutingHelper();
		if (!routingHelper.isFollowingMode() && !routingHelper.isRoutePlanningMode()) {
			mapActivity.getMapActions().enterRoutePlanningMode(null, null);
		} else {
			mapActivity.getRoutingHelper().setRoutePlanningMode(true);
			mapActivity.getMapViewTrackingUtilities().switchToRoutePlanningMode();
			mapActivity.refreshMap();
		}
		hideDashboard(true);
	}


	// To animate view slide out from right to left
	private void open(View view, boolean animation) {
		if (animation) {
			TranslateAnimation animate = new TranslateAnimation(-mapActivity.findViewById(R.id.MapHudButtonsOverlay)
					.getWidth(), 0, 0, 0);
			animate.setDuration(500);
			animate.setFillAfter(true);
			view.startAnimation(animate);
			view.setVisibility(View.VISIBLE);
		} else {
			view.setVisibility(View.VISIBLE);
		}
	}

	private void hide(View view, boolean animation) {
		if (!animation) {
			dashboardView.setVisibility(View.GONE);
		} else {
			TranslateAnimation animate = new TranslateAnimation(0, -mapActivity.findViewById(R.id.MapHudButtonsOverlay)
					.getWidth(), 0, 0);
			animate.setDuration(500);
			animate.setFillAfter(true);
			animate.setAnimationListener(new AnimationListener() {

				@Override
				public void onAnimationStart(Animation animation) {

				}

				@Override
				public void onAnimationRepeat(Animation animation) {

				}

				@Override
				public void onAnimationEnd(Animation animation) {
					dashboardView.setVisibility(View.GONE);
				}
			});
			view.startAnimation(animate);
		}
		view.setVisibility(View.GONE);
	}


	private void addOrUpdateDashboardFragments() {
		OsmandSettings settings = getMyApplication().getSettings();
		TransactionBuilder builder =
				new TransactionBuilder(mapActivity.getSupportFragmentManager(), settings, mapActivity);
		builder.addFragmentsData(fragmentsData)
				.addFragmentsData(OsmandPlugin.getPluginsCardsList())
				.getFragmentTransaction().commit();
	}

	public boolean isVisible() {
		return visible;
	}

	public void onDetach(DashBaseFragment dashBaseFragment) {
		Iterator<WeakReference<DashBaseFragment>> it = fragList.iterator();
		while (it.hasNext()) {
			WeakReference<DashBaseFragment> wr = it.next();
			if (wr.get() == dashBaseFragment) {
				it.remove();
			}
		}
	}


	public void updateLocation(final boolean centerChanged, final boolean locationChanged,
							   final boolean compassChanged) {
		if (inLocationUpdate) {
			return;
		}
		inLocationUpdate = true;
		mapActivity.runOnUiThread(new Runnable() {
			@Override
			public void run() {
				inLocationUpdate = false;
				for (WeakReference<DashBaseFragment> df : fragList) {
					if (df.get() instanceof DashLocationFragment) {
						((DashLocationFragment) df.get()).updateLocation(centerChanged, locationChanged, compassChanged);
					}
				}
			}
		});

	}

	public void updateMyLocation(net.osmand.Location location) {
		myLocation = location;
		updateLocation(false, true, false);
	}

	public void updateCompassValue(double heading) {
		this.heading = (float) heading;
		updateLocation(false, false, true);
	}

	public void onAttach(DashBaseFragment dashBaseFragment) {
		fragList.add(new WeakReference<>(dashBaseFragment));
	}

	public void requestLayout() {
		dashboardView.requestLayout();
	}


	public void onMenuPressed() {
		if (!isVisible()) {
			setDashboardVisibility(true, DashboardType.DASHBOARD);
		} else {
			hideDashboard();
		}
	}


	public boolean onBackPressed() {
		if (isVisible()) {
			backPressed();
			return true;
		}
		return false;
	}


	private void backPressed() {
		if (previousVisibleType != visibleType && previousVisibleType != null) {
			visibleType = null;
			setDashboardVisibility(true, previousVisibleType);
		} else {
			hideDashboard();
		}
	}


	@Override
	public void onScrollChanged(int scrollY, boolean firstScroll, boolean dragging) {
		// Translate list background
		if (portrait) {
			if (listBackgroundView != null) {
				setTranslationY(listBackgroundView, Math.max(0, -scrollY + mFlexibleSpaceImageHeight));
			}
		}
		if (portrait) {
			setTranslationY(toolbar, Math.min(0, -scrollY + mFlexibleSpaceImageHeight - mFlexibleBlurSpaceHeight));
		}
		updateColorOfToolbar(scrollY);
		updateTopButton(scrollY);
	}

	private boolean isActionButtonVisible() {
		return visibleType == DashboardType.DASHBOARD
				|| visibleType == DashboardType.WAYPOINTS
				|| visibleType == DashboardType.WAYPOINTS_FLAT
				|| visibleType == DashboardType.LIST_MENU
				|| visibleType == DashboardType.ROUTE_PREFERENCES
				|| visibleType == DashboardType.CONFIGURE_SCREEN;
	}

	private boolean isBackButtonVisible() {
		return !(visibleType == DashboardType.DASHBOARD || visibleType == DashboardType.LIST_MENU);
	}

	private void updateTopButton(int scrollY) {

		if (actionButton != null && portrait && isActionButtonVisible()) {
			double scale = mapActivity.getResources().getDisplayMetrics().density;
			int originalPosition = mFlexibleSpaceImageHeight - (int) (80 * scale);
			int minTop = mFlexibleBlurSpaceHeight + (int) (5 * scale);
			FrameLayout.LayoutParams lp = (FrameLayout.LayoutParams) actionButton.getLayoutParams();
			if (minTop > originalPosition - scrollY) {
				hideActionButton();
			} else {
				actionButton.setVisibility(View.VISIBLE);
				lp.topMargin = originalPosition - scrollY;
				((FrameLayout) actionButton.getParent()).updateViewLayout(actionButton, lp);
			}

		}
	}


	private void updateColorOfToolbar(int scrollY) {
		if (portrait) {
			float sh = mFlexibleSpaceImageHeight - mFlexibleBlurSpaceHeight;
			float t = sh == 0 ? 1 : (1 - Math.max(0, -scrollY + sh) / sh);
			t = Math.max(0, t);

			int alpha = (int) (t * 255);
			// in order to have proper fast scroll down
			int malpha = t == 1 ? 0 : alpha;
			setAlpha(paddingView, malpha, baseColor);
			setAlpha(dashboardView.findViewById(R.id.map_part_dashboard), malpha, baseColor);
			gradientToolbar.setAlpha((int) ((1 - t) * 255));
			setAlpha(dashboardView, (int) (t * 128), 0);
			if (t < 1) {
				dashboardView.findViewById(R.id.toolbar).setBackgroundDrawable(gradientToolbar);
			} else {
				dashboardView.findViewById(R.id.toolbar).setBackgroundColor(0xff000000 | baseColor);
			}
		}
	}

	private void updateListAdapter(ArrayAdapter<?> listAdapter, OnItemClickListener listener) {
		this.listAdapter = listAdapter;
		this.listAdapterOnClickListener = listener;
		if (this.listView != null) {
			listView.setAdapter(listAdapter);
			if (!portrait) {
				listView.setOnItemClickListener(this.listAdapterOnClickListener);
			} else if (this.listAdapterOnClickListener != null) {
				listView.setOnItemClickListener(new OnItemClickListener() {

					@Override
					public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
						listAdapterOnClickListener.onItemClick(parent, view, position - 1, id);
					}
				});
			} else {
				listView.setOnItemClickListener(null);
			}
		}
	}

	@SuppressLint("NewApi")
	private void setTranslationY(View v, int y) {
		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
			v.setTranslationY(y);
		} else {
			TranslateAnimation anim = new TranslateAnimation(0, 0, y, y);
			anim.setFillAfter(true);
			anim.setDuration(0);
			v.startAnimation(anim);
		}
	}

	@SuppressLint("NewApi")
	private void setAlpha(View v, int alpha, int clr) {
//		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
//			v.setAlpha(alpha/255.f);
//		} else {
		int colr = (alpha << 24) | clr;
		v.setBackgroundColor(colr);
//		}
	}

	@Override
	public void onDownMotionEvent() {
	}


	@Override
	public void onUpOrCancelMotionEvent(ScrollState scrollState) {
//		 ActionBar ab = getSupportActionBar();
//	        if (scrollState == ScrollState.UP) {
//	            if (ab.isShowing()) {
//	                ab.hide();
//	            }
//	        } else if (scrollState == ScrollState.DOWN) {
//	            if (!ab.isShowing()) {
//	                ab.show();
//	            }
//	        }		
	}


	public <T extends DashBaseFragment> T getFragmentByClass(Class<T> class1) {
		for (WeakReference<DashBaseFragment> f : fragList) {
			DashBaseFragment b = f.get();
			if (b != null && !b.isDetached() && class1.isInstance(b)) {
				//noinspection unchecked
				return (T) b;
			}
		}
		return null;
	}

	public void blacklistFragmentByTag(String tag) {
		hideFragmentByTag(tag);
		getMyApplication().getSettings().registerBooleanPreference(SHOULD_SHOW + tag, true)
				.makeGlobal().set(false);
	}

	public void hideFragmentByTag(String tag) {
		FragmentManager manager = mapActivity.getSupportFragmentManager();
		FragmentTransaction transaction = manager.beginTransaction();
		Fragment frag = manager.findFragmentByTag(tag);
		transaction.hide(frag).commit();
	}

	public void unblacklistFragmentClass(String tag) {
		unhideFragmentByTag(tag);
		getMyApplication().getSettings().registerBooleanPreference(SHOULD_SHOW + tag, true)
				.makeGlobal().set(true);
	}

	public void unhideFragmentByTag(String tag) {
		FragmentManager manager = mapActivity.getSupportFragmentManager();
		FragmentTransaction transaction = manager.beginTransaction();
		Fragment frag = manager.findFragmentByTag(tag);
		transaction.show(frag).commit();
	}

	public void clearDeletedPoints() {
		deletedPoints.clear();
	}

	View getParentView() {
		return dashboardView;
	}

	public static <T> List<T> handleNumberOfRows(List<T> list, OsmandSettings settings,
												 String rowNumberTag) {
		int numberOfRows = settings.registerIntPreference(rowNumberTag, 3)
				.makeGlobal().get();
		if (list.size() > numberOfRows) {
			while (list.size() != numberOfRows) {
				list.remove(numberOfRows);
			}
		}
		return list;
	}

	public static class DefaultShouldShow extends DashFragmentData.ShouldShowFunction {

		public boolean shouldShow(OsmandSettings settings, MapActivity activity, String tag) {
			return settings.registerBooleanPreference(SHOULD_SHOW + tag, true).makeGlobal().get();
		}
	}

	@Override
	public void onItemSwapping(int position) {
		if (swipeDismissListener != null) {
			swipeDismissListener.setEnabled(false);
		}
	}

	@Override
	public void onItemsSwapped(final List<Object> items) {
		getMyApplication().runInUIThread(new Runnable() {
			@Override
			public void run() {
				if (visibleType == DashboardType.WAYPOINTS || visibleType == DashboardType.WAYPOINTS_FLAT) {
					List<TargetPoint> allTargets = new ArrayList<>();
					if (items != null) {
						for (Object obj : items) {
							if (obj instanceof LocationPointWrapper) {
								LocationPointWrapper p = (LocationPointWrapper) obj;
								if (p.getPoint() instanceof TargetPoint) {
									TargetPoint t = (TargetPoint) p.getPoint();
									if (!t.start) {
										t.intermediate = true;
										allTargets.add(t);
									}
								}
							}
						}
						if (allTargets.size() > 0) {
							allTargets.get(allTargets.size() - 1).intermediate = false;
						}
					}
					getMyApplication().getTargetPointsHelper().reorderAllTargetPoints(allTargets, false);
					newRouteIsCalculated(false, new ValueHolder<Boolean>());
					getMyApplication().getTargetPointsHelper().updateRouteAndRefresh(true);

					if (swipeDismissListener != null) {
						swipeDismissListener.setEnabled(true);
					}
				}
			}
		}, 50);
	}

	@Override
	public void newRouteIsCalculated(boolean newRoute, ValueHolder<Boolean> showToast) {
		reloadAdapter();
		showToast.value = false;
	}

	@Override
	public void routeWasCancelled() {
	}

	@Override
	public void routeWasFinished() {
	}

	@Override
	public void onWindowVisibilityChanged(int visibility) {
		if (visibility != View.VISIBLE && swipeDismissListener != null) {
			swipeDismissListener.discardUndo();
		}
	}

	@Override
	public void reloadAdapter() {
		if ((DashboardType.WAYPOINTS == visibleType || DashboardType.WAYPOINTS_FLAT == visibleType)
				&& listAdapter != null && listAdapter instanceof StableArrayAdapter) {
			StableArrayAdapter stableAdapter = (StableArrayAdapter) listAdapter;
			waypointDialogHelper.reloadListAdapter(stableAdapter);
			if (listView instanceof DynamicListView) {
				DynamicListView dynamicListView = (DynamicListView) listView;
				dynamicListView.setItemsList(stableAdapter.getObjects());
				dynamicListView.setActiveItemsList(stableAdapter.getActiveObjects());
			}
		}
	}

	@Override
	public void deleteWaypoint(int position) {
		if (swipeDismissListener != null) {
			swipeDismissListener.delete(position);
		}
	}
}
!@#$%
20190530_041533,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_a04328
package net.osmand.plus.dashboard;

import android.annotation.SuppressLint;
import android.content.Intent;
import android.content.res.Resources;
import android.graphics.drawable.ColorDrawable;
import android.graphics.drawable.Drawable;
import android.os.Build;
import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentManager;
import android.support.v4.app.FragmentTransaction;
import android.support.v7.widget.Toolbar;
import android.util.TypedValue;
import android.view.Gravity;
import android.view.View;
import android.view.animation.Animation;
import android.view.animation.Animation.AnimationListener;
import android.view.animation.TranslateAnimation;
import android.widget.AbsListView;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.ArrayAdapter;
import android.widget.Button;
import android.widget.CompoundButton;
import android.widget.FrameLayout;
import android.widget.ImageView;
import android.widget.ImageView.ScaleType;
import android.widget.ListView;
import android.widget.ScrollView;
import android.widget.TextView;

import com.github.ksoichiro.android.observablescrollview.ObservableListView;
import com.github.ksoichiro.android.observablescrollview.ObservableScrollView;
import com.github.ksoichiro.android.observablescrollview.ObservableScrollViewCallbacks;
import com.github.ksoichiro.android.observablescrollview.ScrollState;

import net.osmand.PlatformUtil;
import net.osmand.ValueHolder;
import net.osmand.data.LatLon;
import net.osmand.plus.ContextMenuAdapter;
import net.osmand.plus.ContextMenuAdapter.OnContextMenuClick;
import net.osmand.plus.ContextMenuAdapter.OnRowItemClick;
import net.osmand.plus.IconsCache;
import net.osmand.plus.OsmandApplication;
import net.osmand.plus.OsmandPlugin;
import net.osmand.plus.OsmandSettings;
import net.osmand.plus.R;
import net.osmand.plus.TargetPointsHelper.TargetPoint;
import net.osmand.plus.activities.MapActivity;
import net.osmand.plus.dashboard.tools.DashFragmentData;
import net.osmand.plus.dashboard.tools.DashboardSettingsDialogFragment;
import net.osmand.plus.dashboard.tools.TransactionBuilder;
import net.osmand.plus.dialogs.ConfigureMapMenu;
import net.osmand.plus.dialogs.RasterMapMenu;
import net.osmand.plus.download.DownloadActivity;
import net.osmand.plus.helpers.AndroidUiHelper;
import net.osmand.plus.helpers.WaypointDialogHelper;
import net.osmand.plus.helpers.WaypointDialogHelper.WaypointDialogHelperCallbacks;
import net.osmand.plus.helpers.WaypointHelper.LocationPointWrapper;
import net.osmand.plus.mapcontextmenu.other.RoutePreferencesMenu;
import net.osmand.plus.mapcontextmenu.other.RoutePreferencesMenu.LocalRoutingParameter;
import net.osmand.plus.rastermaps.OsmandRasterMapsPlugin;
import net.osmand.plus.routing.RoutingHelper;
import net.osmand.plus.routing.RoutingHelper.IRouteInformationListener;
import net.osmand.plus.views.DownloadedRegionsLayer;
import net.osmand.plus.views.OsmandMapTileView;
import net.osmand.plus.views.controls.DynamicListView;
import net.osmand.plus.views.controls.DynamicListViewCallbacks;
import net.osmand.plus.views.controls.StableArrayAdapter;
import net.osmand.plus.views.controls.SwipeDismissListViewTouchListener;
import net.osmand.plus.views.controls.SwipeDismissListViewTouchListener.Undoable;

import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import static android.util.TypedValue.COMPLEX_UNIT_DIP;

/**
 */
public class DashboardOnMap implements ObservableScrollViewCallbacks, DynamicListViewCallbacks,
		IRouteInformationListener, WaypointDialogHelperCallbacks {
	private static final org.apache.commons.logging.Log LOG =
			PlatformUtil.getLog(DashboardOnMap.class);
	private static final String TAG = "DashboardOnMap";
	public static boolean staticVisible = false;
	public static DashboardType staticVisibleType = DashboardType.DASHBOARD;
	public static final String SHOULD_SHOW = "should_show";


	private final DashFragmentData[] fragmentsData = new DashFragmentData[]{
			new DashFragmentData(DashRateUsFragment.TAG, DashRateUsFragment.class,
					DashRateUsFragment.SHOULD_SHOW_FUNCTION, 0, null),
			new DashFragmentData(DashDashboardOrDrawerFragment.TAG, DashDashboardOrDrawerFragment.class,
					DashDashboardOrDrawerFragment.SHOULD_SHOW_FUNCTION, 5, null),
			new DashFragmentData(DashErrorFragment.TAG, DashErrorFragment.class,
					DashErrorFragment.SHOULD_SHOW_FUNCTION, 30, null),
			new DashFragmentData(DashNavigationFragment.TAG, DashNavigationFragment.class,
					DashNavigationFragment.SHOULD_SHOW_FUNCTION, 40, null),
			new DashFragmentData(DashWaypointsFragment.TAG, DashWaypointsFragment.class,
					DashWaypointsFragment.SHOULD_SHOW_FUNCTION, 60, null),
			new DashFragmentData(DashSearchFragment.TAG, DashSearchFragment.class,
					DashSearchFragment.SHOULD_SHOW_FUNCTION, 70, null),
			DashRecentsFragment.FRAGMENT_DATA,
			DashFavoritesFragment.FRAGMENT_DATA,
			new DashFragmentData(DashPluginsFragment.TAG, DashPluginsFragment.class,
					DashPluginsFragment.SHOULD_SHOW_FUNCTION, 140, null)
	};

	private MapActivity mapActivity;
	private ImageView actionButton;
	private FrameLayout dashboardView;

	private ArrayAdapter<?> listAdapter;
	private OnItemClickListener listAdapterOnClickListener;
	private SwipeDismissListViewTouchListener swipeDismissListener;

	private boolean visible = false;
	private DashboardType visibleType;
	private DashboardType previousVisibleType;
	private boolean landscape;
	private List<WeakReference<DashBaseFragment>> fragList = new LinkedList<>();
	private net.osmand.Location myLocation;
	private LatLon mapViewLocation;
	private float heading;
	private boolean mapLinkedToLocation;
	private float mapRotation;
	private boolean inLocationUpdate = false;
	private ListView listView;
	private View listBackgroundView;
	private Toolbar toolbar;
	private View paddingView;
	private int mFlexibleSpaceImageHeight;
	private int mFlexibleBlurSpaceHeight;
	private boolean portrait;

	int baseColor;

	private WaypointDialogHelper waypointDialogHelper;
	private final int[] running = new int[]{-1};
	private List<LocationPointWrapper> deletedPoints = new ArrayList<>();
	private Drawable gradientToolbar;
	boolean nightMode;

	public DashFragmentData[] getFragmentsData() {
		return fragmentsData;
	}

	public enum DashboardType {
		WAYPOINTS,
		WAYPOINTS_FLAT,
		CONFIGURE_SCREEN,
		CONFIGURE_MAP,
		LIST_MENU,
		ROUTE_PREFERENCES,
		DASHBOARD,
		OVERLAY_MAP,
		UNDERLAY_MAP
	}

	private Map<DashboardActionButtonType, DashboardActionButton> actionButtons = new HashMap<>();

	public enum DashboardActionButtonType {
		MY_LOCATION,
		NAVIGATE,
		ROUTE
	}

	private class DashboardActionButton {
		private Drawable icon;
		private View.OnClickListener onClickListener;
	}

	public DashboardOnMap(MapActivity ma) {
		this.mapActivity = ma;
	}


	public void createDashboardView() {
		baseColor = mapActivity.getResources().getColor(R.color.osmand_orange) & 0x00ffffff;
		waypointDialogHelper = new WaypointDialogHelper(mapActivity);
		waypointDialogHelper.setWaypointDialogHelperCallbacks(this);
		landscape = !AndroidUiHelper.isOrientationPortrait(mapActivity);
		dashboardView = (FrameLayout) mapActivity.findViewById(R.id.dashboard);
		final View.OnClickListener listener = new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				hideDashboard();
			}
		};
		toolbar = ((Toolbar) dashboardView.findViewById(R.id.toolbar));
		ObservableScrollView scrollView = ((ObservableScrollView) dashboardView.findViewById(R.id.main_scroll));
		listView = (ListView) dashboardView.findViewById(R.id.dash_list_view);
		//listView.setChoiceMode(ListView.CHOICE_MODE_SINGLE);
		listView.setDrawSelectorOnTop(true);
		((DynamicListView) listView).setDynamicListViewCallbacks(this);

		// Create a ListView-specific touch listener. ListViews are given special treatment because
		// by default they handle touches for their list items... i.e. they're in charge of drawing
		// the pressed state (the list selector), handling list item clicks, etc.
		swipeDismissListener = new SwipeDismissListViewTouchListener(
						listView,
						new SwipeDismissListViewTouchListener.DismissCallbacks() {
							@Override
							public boolean canDismiss(int position) {
								boolean res = false;
								if (visibleType == DashboardType.WAYPOINTS && listAdapter instanceof StableArrayAdapter) {
									List<Object> activeObjects = ((StableArrayAdapter) listAdapter).getActiveObjects();
									Object obj = listAdapter.getItem(position);
									res = activeObjects.contains(obj);
								}
								return res;
							}

							@Override
							public Undoable onDismiss(final int position) {
								final Object item;
								final StableArrayAdapter stableAdapter;
								final int activeObjPos;
								if (listAdapter instanceof StableArrayAdapter) {
									stableAdapter = (StableArrayAdapter) listAdapter;
									item = stableAdapter.getItem(position);

									stableAdapter.setNotifyOnChange(false);
									stableAdapter.remove(item);
									stableAdapter.getObjects().remove(item);
									activeObjPos = stableAdapter.getActiveObjects().indexOf(item);
									stableAdapter.getActiveObjects().remove(item);
									stableAdapter.refreshData();
									stableAdapter.notifyDataSetChanged();

								} else {
									item = null;
									stableAdapter = null;
									activeObjPos = 0;
								}
								return new Undoable() {
									@Override
									public void undo() {
										if (item != null) {
											stableAdapter.setNotifyOnChange(false);
											stableAdapter.insert(item, position);
											stableAdapter.getObjects().add(position, item);
											stableAdapter.getActiveObjects().add(activeObjPos, item);
											stableAdapter.refreshData();
											onItemsSwapped(stableAdapter.getActiveObjects());
										}
									}

									@Override
									public String getTitle() {
										if (visibleType == DashboardType.WAYPOINTS
												&& (getMyApplication().getRoutingHelper().isRoutePlanningMode() || getMyApplication().getRoutingHelper().isFollowingMode())
												&& item != null
												&& stableAdapter.getActiveObjects().size() == 0) {
											return mapActivity.getResources().getString(R.string.cancel_navigation);
										} else {
											return null;
										}
									}
								};
							}

							@Override
							public void onHidePopup() {
								if (listAdapter instanceof StableArrayAdapter) {
									StableArrayAdapter stableAdapter = (StableArrayAdapter) listAdapter;
									stableAdapter.refreshData();
									onItemsSwapped(stableAdapter.getActiveObjects());
									if (stableAdapter.getActiveObjects().size() == 0) {
										hideDashboard();
										mapActivity.getMapActions().stopNavigationWithoutConfirm();
										mapActivity.getMapLayers().getMapControlsLayer().getMapRouteInfoMenu().hide();
									}
								}
							}
						});

		gradientToolbar = mapActivity.getResources().getDrawable(R.drawable.gradient_toolbar).mutate();
		if (AndroidUiHelper.isOrientationPortrait(mapActivity)) {
			this.portrait = true;
			scrollView.setScrollViewCallbacks(this);
			((ObservableListView) listView).setScrollViewCallbacks(this);
			mFlexibleSpaceImageHeight = mapActivity.getResources().getDimensionPixelSize(
					R.dimen.dashboard_map_top_padding);
			mFlexibleBlurSpaceHeight = mapActivity.getResources().getDimensionPixelSize(
					R.dimen.dashboard_map_toolbar);
			// Set padding view for ListView. This is the flexible space.
			paddingView = new FrameLayout(mapActivity);
			AbsListView.LayoutParams lp = new AbsListView.LayoutParams(AbsListView.LayoutParams.MATCH_PARENT,
					mFlexibleSpaceImageHeight);
			paddingView.setLayoutParams(lp);
			// This is required to disable header's list selector effect
			paddingView.setClickable(true);
			paddingView.setOnClickListener(listener);

			FrameLayout shadowContainer = new FrameLayout(mapActivity);
			FrameLayout.LayoutParams fl = new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT,
					FrameLayout.LayoutParams.MATCH_PARENT);
			fl.gravity = Gravity.BOTTOM;
			shadowContainer.setLayoutParams(fl);
			ImageView shadow = new ImageView(mapActivity);
			shadow.setImageDrawable(mapActivity.getResources().getDrawable(R.drawable.bg_shadow_onmap));
			shadow.setLayoutParams(new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT,
					FrameLayout.LayoutParams.WRAP_CONTENT, Gravity.BOTTOM));
			shadow.setScaleType(ScaleType.FIT_XY);
			shadowContainer.addView(shadow);
			((FrameLayout) paddingView).addView(shadowContainer);
			listView.addHeaderView(paddingView);
			listBackgroundView = mapActivity.findViewById(R.id.dash_list_background);
		}
		dashboardView.findViewById(R.id.animateContent).setOnClickListener(listener);
		dashboardView.findViewById(R.id.map_part_dashboard).setOnClickListener(listener);

		initActionButtons();
		dashboardView.addView(actionButton);
	}


	private void updateListBackgroundHeight() {

		if (listBackgroundView == null || listBackgroundView.getHeight() > 0) {
			return;
		}
		final View contentView = mapActivity.getWindow().getDecorView().findViewById(android.R.id.content);
		if (contentView.getHeight() > 0) {
			listBackgroundView.getLayoutParams().height = contentView.getHeight();
		} else {
			contentView.post(new Runnable() {
				@Override
				public void run() {
					// mListBackgroundView's should fill its parent vertically
					// but the height of the content view is 0 on 'onCreate'.
					// So we should get it with post().
					listBackgroundView.getLayoutParams().height = contentView.getHeight();
				}
			});
		}
	}

	private void updateToolbarActions() {
		TextView tv = (TextView) dashboardView.findViewById(R.id.toolbar_text);
		tv.setText("");
		boolean waypointsVisible = visibleType == DashboardType.WAYPOINTS || visibleType == DashboardType.WAYPOINTS_FLAT;
		if (waypointsVisible) {
			tv.setText(R.string.waypoints);
		} else if (visibleType == DashboardType.CONFIGURE_MAP) {
			tv.setText(R.string.configure_map);
		} else if (visibleType == DashboardType.CONFIGURE_SCREEN) {
			tv.setText(R.string.layer_map_appearance);
		} else if (visibleType == DashboardType.ROUTE_PREFERENCES) {
			tv.setText(R.string.shared_string_settings);
		} else if (visibleType == DashboardType.UNDERLAY_MAP) {
			tv.setText(R.string.map_underlay);
		} else if (visibleType == DashboardType.OVERLAY_MAP) {
			tv.setText(R.string.map_overlay);
		}
		ImageView edit = (ImageView) dashboardView.findViewById(R.id.toolbar_edit);
		edit.setVisibility(View.GONE);
		ImageView sort = (ImageView) dashboardView.findViewById(R.id.toolbar_sort);
		sort.setVisibility(View.GONE);
		ImageView ok = (ImageView) dashboardView.findViewById(R.id.toolbar_ok);
		ok.setVisibility(View.GONE);
		ImageView flat = (ImageView) dashboardView.findViewById(R.id.toolbar_flat);
		flat.setVisibility(View.GONE);
		ImageView settingsButton = (ImageView) dashboardView.findViewById(R.id.toolbar_settings);
		settingsButton.setVisibility(View.GONE);
		IconsCache iconsCache = mapActivity.getMyApplication().getIconsCache();
		ImageView lst = (ImageView) dashboardView.findViewById(R.id.toolbar_list);
		lst.setVisibility(View.GONE);
		ImageView back = (ImageView) dashboardView.findViewById(R.id.toolbar_back);
		back.setImageDrawable(
				getMyApplication().getIconsCache().getIcon(R.drawable.abc_ic_ab_back_mtrl_am_alpha));
		back.setOnClickListener(new View.OnClickListener() {

			@Override
			public void onClick(View v) {
				backPressed();
			}
		});

		if (waypointsVisible && getMyApplication().getWaypointHelper().getAllPoints().size() > 0) {
			if (getMyApplication().getWaypointHelper().isRouteCalculated()) {
				flat.setVisibility(View.VISIBLE);
				final boolean flatNow = visibleType == DashboardType.WAYPOINTS_FLAT;
				flat.setImageDrawable(iconsCache.getIcon(flatNow ? R.drawable.ic_tree_list_dark
						: R.drawable.ic_flat_list_dark));
				flat.setOnClickListener(new View.OnClickListener() {

					@Override
					public void onClick(View v) {
						setDashboardVisibility(true, flatNow ? DashboardType.WAYPOINTS : DashboardType.WAYPOINTS_FLAT,
								previousVisibleType, false);
					}
				});
			}
		}
//		if (waypointsEdit) {
//			ok.setVisibility(View.VISIBLE);
//			ok.setOnClickListener(new View.OnClickListener() {
//
//				@Override
//				public void onClick(View v) {
//					mapActivity.getMyApplication().getWaypointHelper().removeVisibleLocationPoint(deletedPoints);
//					hideDashboard();
//				}
//			});
//		}
		if (visibleType == DashboardType.DASHBOARD || visibleType == DashboardType.LIST_MENU) {
			settingsButton.setVisibility(View.VISIBLE);
			settingsButton.setOnClickListener(new View.OnClickListener() {

				@Override
				public void onClick(View v) {
					new DashboardSettingsDialogFragment().show(
							mapActivity.getSupportFragmentManager(), "dashboard_settings");
				}
			});
			lst.setVisibility(View.VISIBLE);
			lst.setOnClickListener(new View.OnClickListener() {

				@Override
				public void onClick(View v) {
					hideDashboard(false);
					mapActivity.openDrawer();
				}
			});
		}
	}


	private void initActionButtons() {
		actionButton = new ImageView(mapActivity);
		int btnSize = (int) mapActivity.getResources().getDimension(R.dimen.map_button_size);
		int topPad = (int) mapActivity.getResources().getDimension(R.dimen.dashboard_map_top_padding);
		FrameLayout.LayoutParams params = new FrameLayout.LayoutParams(
				btnSize, btnSize
		);
		int marginRight = btnSize / 4;
		params.setMargins(0, landscape ? 0 : topPad - 2 * btnSize,
				marginRight, landscape ? marginRight : 0);
		params.gravity = landscape ? Gravity.BOTTOM | Gravity.RIGHT : Gravity.TOP | Gravity.RIGHT;
		actionButton.setLayoutParams(params);
		actionButton.setScaleType(ScaleType.CENTER);
		actionButton.setBackgroundDrawable(mapActivity.getResources().getDrawable(R.drawable.btn_circle_blue));
		hideActionButton();


		DashboardActionButton myLocationButton = new DashboardActionButton();
		myLocationButton.icon = mapActivity.getResources().getDrawable(R.drawable.map_my_location);
		myLocationButton.onClickListener = new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				if (getMyApplication().accessibilityEnabled()) {
					mapActivity.getMapActions().whereAmIDialog();
				} else {
					mapActivity.getMapViewTrackingUtilities().backToLocationImpl();
				}
				hideDashboard();
			}
		};

		DashboardActionButton navigateButton = new DashboardActionButton();
		navigateButton.icon = mapActivity.getResources().getDrawable(R.drawable.map_start_navigation);
		navigateButton.onClickListener = new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				mapActivity.getMapLayers().getMapControlsLayer().doNavigate();
				hideDashboard();
			}
		};

		DashboardActionButton routeButton = new DashboardActionButton();
		routeButton.icon = mapActivity.getResources().getDrawable(R.drawable.map_directions);
		routeButton.onClickListener = new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				mapActivity.getMapLayers().getMapControlsLayer().doRoute();
				hideDashboard();
			}
		};

		actionButtons.put(DashboardActionButtonType.MY_LOCATION, myLocationButton);
		actionButtons.put(DashboardActionButtonType.NAVIGATE, navigateButton);
		actionButtons.put(DashboardActionButtonType.ROUTE, routeButton);
	}

	private void setActionButton(DashboardType type) {
		DashboardActionButton button = null;

		if (type == DashboardType.DASHBOARD
				|| type == DashboardType.LIST_MENU
				|| type == DashboardType.CONFIGURE_SCREEN) {
			button = actionButtons.get(DashboardActionButtonType.MY_LOCATION);
		} else if (type == DashboardType.ROUTE_PREFERENCES) {
			button = actionButtons.get(DashboardActionButtonType.NAVIGATE);
		} else if (type == DashboardType.WAYPOINTS || type == DashboardType.WAYPOINTS_FLAT) {
			boolean routePlanningMode = false;
			RoutingHelper rh = mapActivity.getRoutingHelper();
			if (rh.isRoutePlanningMode()) {
				routePlanningMode = true;
			} else if ((rh.isRouteCalculated() || rh.isRouteBeingCalculated()) && !rh.isFollowingMode()) {
				routePlanningMode = true;
			}
			boolean routeFollowingMode = !routePlanningMode && rh.isFollowingMode();

			if (routePlanningMode || routeFollowingMode) {
				button = actionButtons.get(DashboardActionButtonType.NAVIGATE);
			} else {
				button = actionButtons.get(DashboardActionButtonType.ROUTE);
			}
		}

		if (button != null) {
			actionButton.setImageDrawable(button.icon);
			actionButton.setOnClickListener(button.onClickListener);
		}
	}

	private void hideActionButton() {
		actionButton.setVisibility(View.GONE);
	}

	public net.osmand.Location getMyLocation() {
		return myLocation;
	}

	public LatLon getMapViewLocation() {
		return mapViewLocation;
	}

	public float getHeading() {
		return heading;
	}

	public float getMapRotation() {
		return mapRotation;
	}

	public boolean isMapLinkedToLocation() {
		return mapLinkedToLocation;
	}

	protected OsmandApplication getMyApplication() {
		return mapActivity.getMyApplication();
	}

	public ArrayAdapter<?> getListAdapter() {
		return listAdapter;
	}

	public OnItemClickListener getListAdapterOnClickListener() {
		return listAdapterOnClickListener;
	}

	public void hideDashboard() {
		setDashboardVisibility(false, visibleType);
	}

	public void hideDashboard(boolean animation) {
		setDashboardVisibility(false, visibleType, animation);
	}

	public void setDashboardVisibility(boolean visible, DashboardType type) {
		setDashboardVisibility(visible, type, this.visible ? visibleType : null, true);
	}

	public void setDashboardVisibility(boolean visible, DashboardType type, boolean animation) {
		setDashboardVisibility(visible, type, this.visible ? visibleType : null, animation);
	}

	public void refreshDashboardFragments() {
		addOrUpdateDashboardFragments();
	}

	public void setDashboardVisibility(boolean visible, DashboardType type, DashboardType prevItem, boolean animation) {
		if (visible == this.visible && type == visibleType) {
			return;
		}
		nightMode = mapActivity.getMyApplication().getDaynightHelper().isNightModeForMapControls();
		this.previousVisibleType = prevItem;
		this.visible = visible;
		boolean refresh = this.visibleType == type;
		this.visibleType = type;
		DashboardOnMap.staticVisible = visible;
		DashboardOnMap.staticVisibleType = type;
		mapActivity.enableDrawer();
		if (visible) {
			mapViewLocation = mapActivity.getMapLocation();
			mapRotation = mapActivity.getMapRotate();
			mapLinkedToLocation = mapActivity.getMapViewTrackingUtilities().isMapLinkedToLocation();
			myLocation = mapActivity.getMyApplication().getLocationProvider().getLastKnownLocation();
			mapActivity.getMapViewTrackingUtilities().setDashboard(this);
			mapActivity.disableDrawer();
			dashboardView.setVisibility(View.VISIBLE);
			if (isActionButtonVisible()) {
				setActionButton(visibleType);
				actionButton.setVisibility(View.VISIBLE);
			} else {
				hideActionButton();
			}
			updateDownloadBtn();
			View listViewLayout = dashboardView.findViewById(R.id.dash_list_view_layout);
			ScrollView scrollView = (ScrollView) dashboardView.findViewById(R.id.main_scroll);
			if (visibleType == DashboardType.DASHBOARD) {
				addOrUpdateDashboardFragments();
				scrollView.setVisibility(View.VISIBLE);
				scrollView.scrollTo(0, 0);
				listViewLayout.setVisibility(View.GONE);
				onScrollChanged(scrollView.getScrollY(), false, false);
			} else {
				scrollView.setVisibility(View.GONE);
				listViewLayout.setVisibility(View.VISIBLE);
				if (listView instanceof ObservableListView) {
					onScrollChanged(listView.getScrollY(), false, false);
				}
				if (refresh) {
					refreshContent(false);
				} else {
					updateListAdapter();
					updateListBackgroundHeight();
				}
				applyDayNightMode();
			}
			mapActivity.findViewById(R.id.toolbar_back).setVisibility(isBackButtonVisible() ? View.VISIBLE : View.GONE);
			mapActivity.findViewById(R.id.MapHudButtonsOverlay).setVisibility(View.INVISIBLE);
			boolean portrait = AndroidUiHelper.isOrientationPortrait(mapActivity);
			if (!portrait) {
				AndroidUiHelper.updateVisibility(mapActivity.findViewById(R.id.map_route_land_left_margin_external), true);
				mapActivity.getMapView().setMapPositionX(1);
				mapActivity.refreshMap();
			}

			updateToolbarActions();
			//fabButton.showFloatingActionButton();
			open(dashboardView.findViewById(R.id.animateContent), animation);
			updateLocation(true, true, false);
//			addOrUpdateDashboardFragments();
			mapActivity.getRoutingHelper().addListener(this);
		} else {
			if (swipeDismissListener != null) {
				swipeDismissListener.discardUndo();
			}
			mapActivity.getRoutingHelper().removeListener(this);
			mapActivity.getMapViewTrackingUtilities().setDashboard(null);
			hide(dashboardView.findViewById(R.id.animateContent), animation);

			if (!mapActivity.getMapLayers().getMapControlsLayer().getMapRouteInfoMenu().isVisible()) {
				AndroidUiHelper.updateVisibility(mapActivity.findViewById(R.id.map_route_land_left_margin_external), false);
				mapActivity.getMapView().setMapPositionX(0);
				mapActivity.getMapView().refreshMap();
			}

			mapActivity.findViewById(R.id.MapHudButtonsOverlay).setVisibility(View.VISIBLE);
			hideActionButton();
			for (WeakReference<DashBaseFragment> df : fragList) {
				if (df.get() != null) {
					df.get().onCloseDash();
				}
			}
		}
	}

	private void applyDayNightMode() {
		if (nightMode) {
			if (listBackgroundView != null) {
				listBackgroundView.setBackgroundColor(mapActivity.getResources().getColor(R.color.ctx_menu_info_view_bg_dark));
			} else {
				listView.setBackgroundColor(mapActivity.getResources().getColor(R.color.ctx_menu_info_view_bg_dark));
			}
			if (visibleType != DashboardType.WAYPOINTS) {
				Drawable d = new ColorDrawable(mapActivity.getResources().getColor(R.color.dashboard_divider_dark));
				listView.setDivider(d);
				listView.setDividerHeight(dpToPx(1f));
			} else {
				listView.setDivider(null);
			}
		} else {
			if (listBackgroundView != null) {
				listBackgroundView.setBackgroundColor(mapActivity.getResources().getColor(R.color.ctx_menu_info_view_bg_light));
			} else {
				listView.setBackgroundColor(mapActivity.getResources().getColor(R.color.ctx_menu_info_view_bg_light));
			}
			if (visibleType != DashboardType.WAYPOINTS) {
				Drawable d = new ColorDrawable(mapActivity.getResources().getColor(R.color.dashboard_divider_light));
				listView.setDivider(d);
				listView.setDividerHeight(dpToPx(1f));
			} else {
				listView.setDivider(null);
			}
		}
	}

	private int dpToPx(float dp) {
		Resources r = mapActivity.getResources();
		return (int) TypedValue.applyDimension(COMPLEX_UNIT_DIP, dp, r.getDisplayMetrics());
	}

	private void updateListAdapter() {
		ContextMenuAdapter cm = null;
		if (DashboardType.WAYPOINTS == visibleType || DashboardType.WAYPOINTS_FLAT == visibleType) {
			StableArrayAdapter listAdapter = waypointDialogHelper.getWaypointsDrawerAdapter(true, deletedPoints, mapActivity, running,
					DashboardType.WAYPOINTS_FLAT == visibleType, nightMode);
			OnItemClickListener listener = waypointDialogHelper.getDrawerItemClickListener(mapActivity, running,
					listAdapter);

			DynamicListView dynamicListView = (DynamicListView) listView;
			dynamicListView.setItemsList(listAdapter.getObjects());
			dynamicListView.setActiveItemsList(listAdapter.getActiveObjects());

			updateListAdapter(listAdapter, listener);

		} else {
			if (DashboardType.CONFIGURE_SCREEN == visibleType) {
				cm = mapActivity.getMapLayers().getMapWidgetRegistry().getViewConfigureMenuAdapter(mapActivity);
			} else if (DashboardType.CONFIGURE_MAP == visibleType) {
				cm = new ConfigureMapMenu().createListAdapter(mapActivity);
			} else if (DashboardType.LIST_MENU == visibleType) {
				cm = mapActivity.getMapActions().createMainOptionsMenu();
			} else if (DashboardType.ROUTE_PREFERENCES == visibleType) {
				RoutePreferencesMenu routePreferencesMenu = new RoutePreferencesMenu(mapActivity);
				ArrayAdapter<LocalRoutingParameter> listAdapter = routePreferencesMenu.getRoutePreferencesDrawerAdapter(nightMode);
				OnItemClickListener listener = routePreferencesMenu.getItemClickListener(listAdapter);
				updateListAdapter(listAdapter, listener);
			} else if (DashboardType.UNDERLAY_MAP == visibleType) {
				cm = RasterMapMenu.createListAdapter(mapActivity, OsmandRasterMapsPlugin.RasterMapType.UNDERLAY);
			} else if (DashboardType.OVERLAY_MAP == visibleType) {
				cm = RasterMapMenu.createListAdapter(mapActivity, OsmandRasterMapsPlugin.RasterMapType.OVERLAY);
			}
			if (cm != null) {
				updateListAdapter(cm);
			}
		}
	}

	public void updateListAdapter(ContextMenuAdapter cm) {
		boolean nightMode = mapActivity.getMyApplication().getDaynightHelper().isNightModeForMapControls();
		if (this.nightMode != nightMode) {
			this.nightMode = nightMode;
			applyDayNightMode();
		}
		final ArrayAdapter<?> listAdapter = cm.createListAdapter(mapActivity, !nightMode);
		OnItemClickListener listener = getOptionsMenuOnClickListener(cm, listAdapter);
		updateListAdapter(listAdapter, listener);
	}

	public void refreshContent(boolean force) {
		if (visibleType == DashboardType.WAYPOINTS || force) {
			updateListAdapter();
		} else if (visibleType == DashboardType.CONFIGURE_MAP || visibleType == DashboardType.ROUTE_PREFERENCES) {
			int index = listView.getFirstVisiblePosition();
			View v = listView.getChildAt(0);
			int top = (v == null) ? 0 : (v.getTop() - listView.getPaddingTop());
			updateListAdapter();
			listView.setSelectionFromTop(index, top);
		} else {
			listAdapter.notifyDataSetChanged();
		}
	}


	private OnItemClickListener getOptionsMenuOnClickListener(final ContextMenuAdapter cm,
															  final ArrayAdapter<?> listAdapter) {
		return new AdapterView.OnItemClickListener() {

			@Override
			public void onItemClick(AdapterView<?> parent, View view, int which, long id) {
				OnContextMenuClick click = cm.getClickAdapter(which);
				if (click instanceof OnRowItemClick) {
					boolean cl = ((OnRowItemClick) click).onRowItemClick(listAdapter, view, cm.getElementId(which), which);
					if (cl) {
						hideDashboard();
					}
				} else if (click != null) {
					CompoundButton btn = (CompoundButton) view.findViewById(R.id.check_item);
					if (btn != null && btn.getVisibility() == View.VISIBLE) {
						btn.setChecked(!btn.isChecked());
					} else {
						if (click.onContextMenuClick(listAdapter, cm.getElementId(which), which, false)) {
							hideDashboard();
						}
					}
				} else {
					hideDashboard();
				}
			}
		};
	}

	private void updateDownloadBtn() {
		Button btn = (Button) dashboardView.findViewById(R.id.map_download_button);
		String filter = null;
		String txt = "";
		OsmandMapTileView mv = mapActivity.getMapView();
		if (mv != null && !mapActivity.getMyApplication().isApplicationInitializing()) {
			if (mv.getZoom() < 11 && !mapActivity.getMyApplication().getResourceManager().containsBasemap()) {
				filter = "basemap";
				txt = mapActivity.getString(R.string.shared_string_download) + " "
						+ mapActivity.getString(R.string.base_world_map);
			} else {
				DownloadedRegionsLayer dl = mv.getLayerByClass(DownloadedRegionsLayer.class);
				if (dl != null) {
					StringBuilder btnName = new StringBuilder();
					filter = dl.getFilter(btnName);
					txt = btnName.toString();
				}
			}
		}

		btn.setText(txt);
		btn.setVisibility(filter == null ? View.GONE : View.VISIBLE);
		final String f = filter;
		btn.setOnClickListener(new View.OnClickListener() {

			@Override
			public void onClick(View v) {
				hideDashboard(false);
				final Intent intent = new Intent(mapActivity, mapActivity.getMyApplication().getAppCustomization()
						.getDownloadIndexActivity());
				if (f != null && !f.equals("basemap")) {
					intent.putExtra(DownloadActivity.FILTER_KEY, f);
				}
				intent.putExtra(DownloadActivity.TAB_TO_OPEN, DownloadActivity.DOWNLOAD_TAB);
				mapActivity.startActivity(intent);
			}
		});
		scheduleDownloadButtonCheck();
	}

	private void scheduleDownloadButtonCheck() {
		mapActivity.getMyApplication().runInUIThread(new Runnable() {

			@Override
			public void run() {
				if (isVisible()) {
					updateDownloadBtn();
				}
			}
		}, 4000);
	}


	public void navigationAction() {
		RoutingHelper routingHelper = mapActivity.getRoutingHelper();
		if (!routingHelper.isFollowingMode() && !routingHelper.isRoutePlanningMode()) {
			mapActivity.getMapActions().enterRoutePlanningMode(null, null);
		} else {
			mapActivity.getRoutingHelper().setRoutePlanningMode(true);
			mapActivity.getMapViewTrackingUtilities().switchToRoutePlanningMode();
			mapActivity.refreshMap();
		}
		hideDashboard(true);
	}


	// To animate view slide out from right to left
	private void open(View view, boolean animation) {
		if (animation) {
			TranslateAnimation animate = new TranslateAnimation(-mapActivity.findViewById(R.id.MapHudButtonsOverlay)
					.getWidth(), 0, 0, 0);
			animate.setDuration(500);
			animate.setFillAfter(true);
			view.startAnimation(animate);
			view.setVisibility(View.VISIBLE);
		} else {
			view.setVisibility(View.VISIBLE);
		}
	}

	private void hide(View view, boolean animation) {
		if (!animation) {
			dashboardView.setVisibility(View.GONE);
		} else {
			TranslateAnimation animate = new TranslateAnimation(0, -mapActivity.findViewById(R.id.MapHudButtonsOverlay)
					.getWidth(), 0, 0);
			animate.setDuration(500);
			animate.setFillAfter(true);
			animate.setAnimationListener(new AnimationListener() {

				@Override
				public void onAnimationStart(Animation animation) {

				}

				@Override
				public void onAnimationRepeat(Animation animation) {

				}

				@Override
				public void onAnimationEnd(Animation animation) {
					dashboardView.setVisibility(View.GONE);
				}
			});
			view.startAnimation(animate);
		}
		view.setVisibility(View.GONE);
	}


	private void addOrUpdateDashboardFragments() {
		OsmandSettings settings = getMyApplication().getSettings();
		TransactionBuilder builder =
				new TransactionBuilder(mapActivity.getSupportFragmentManager(), settings, mapActivity);
		builder.addFragmentsData(fragmentsData)
				.addFragmentsData(OsmandPlugin.getPluginsCardsList())
				.getFragmentTransaction().commit();
	}

	public boolean isVisible() {
		return visible;
	}

	public void onDetach(DashBaseFragment dashBaseFragment) {
		Iterator<WeakReference<DashBaseFragment>> it = fragList.iterator();
		while (it.hasNext()) {
			WeakReference<DashBaseFragment> wr = it.next();
			if (wr.get() == dashBaseFragment) {
				it.remove();
			}
		}
	}


	public void updateLocation(final boolean centerChanged, final boolean locationChanged,
							   final boolean compassChanged) {
		if (inLocationUpdate) {
			return;
		}
		inLocationUpdate = true;
		mapActivity.runOnUiThread(new Runnable() {
			@Override
			public void run() {
				inLocationUpdate = false;
				for (WeakReference<DashBaseFragment> df : fragList) {
					if (df.get() instanceof DashLocationFragment) {
						((DashLocationFragment) df.get()).updateLocation(centerChanged, locationChanged, compassChanged);
					}
				}
			}
		});

	}

	public void updateMyLocation(net.osmand.Location location) {
		myLocation = location;
		updateLocation(false, true, false);
	}

	public void updateCompassValue(double heading) {
		this.heading = (float) heading;
		updateLocation(false, false, true);
	}

	public void onAttach(DashBaseFragment dashBaseFragment) {
		fragList.add(new WeakReference<>(dashBaseFragment));
	}

	public void requestLayout() {
		dashboardView.requestLayout();
	}


	public void onMenuPressed() {
		if (!isVisible()) {
			setDashboardVisibility(true, DashboardType.DASHBOARD);
		} else {
			hideDashboard();
		}
	}


	public boolean onBackPressed() {
		if (isVisible()) {
			backPressed();
			return true;
		}
		return false;
	}


	private void backPressed() {
		if (previousVisibleType != visibleType && previousVisibleType != null) {
			visibleType = null;
			setDashboardVisibility(true, previousVisibleType);
		} else {
			hideDashboard();
		}
	}


	@Override
	public void onScrollChanged(int scrollY, boolean firstScroll, boolean dragging) {
		// Translate list background
		if (portrait) {
			if (listBackgroundView != null) {
				setTranslationY(listBackgroundView, Math.max(0, -scrollY + mFlexibleSpaceImageHeight));
			}
		}
		if (portrait) {
			setTranslationY(toolbar, Math.min(0, -scrollY + mFlexibleSpaceImageHeight - mFlexibleBlurSpaceHeight));
		}
		updateColorOfToolbar(scrollY);
		updateTopButton(scrollY);
	}

	private boolean isActionButtonVisible() {
		return visibleType == DashboardType.DASHBOARD
				|| visibleType == DashboardType.WAYPOINTS
				|| visibleType == DashboardType.WAYPOINTS_FLAT
				|| visibleType == DashboardType.LIST_MENU
				|| visibleType == DashboardType.ROUTE_PREFERENCES
				|| visibleType == DashboardType.CONFIGURE_SCREEN;
	}

	private boolean isBackButtonVisible() {
		return !(visibleType == DashboardType.DASHBOARD || visibleType == DashboardType.LIST_MENU);
	}

	private void updateTopButton(int scrollY) {

		if (actionButton != null && portrait && isActionButtonVisible()) {
			double scale = mapActivity.getResources().getDisplayMetrics().density;
			int originalPosition = mFlexibleSpaceImageHeight - (int) (80 * scale);
			int minTop = mFlexibleBlurSpaceHeight + (int) (5 * scale);
			FrameLayout.LayoutParams lp = (FrameLayout.LayoutParams) actionButton.getLayoutParams();
			if (minTop > originalPosition - scrollY) {
				hideActionButton();
			} else {
				actionButton.setVisibility(View.VISIBLE);
				lp.topMargin = originalPosition - scrollY;
				((FrameLayout) actionButton.getParent()).updateViewLayout(actionButton, lp);
			}

		}
	}


	private void updateColorOfToolbar(int scrollY) {
		if (portrait) {
			float sh = mFlexibleSpaceImageHeight - mFlexibleBlurSpaceHeight;
			float t = sh == 0 ? 1 : (1 - Math.max(0, -scrollY + sh) / sh);
			t = Math.max(0, t);

			int alpha = (int) (t * 255);
			// in order to have proper fast scroll down
			int malpha = t == 1 ? 0 : alpha;
			setAlpha(paddingView, malpha, baseColor);
			setAlpha(dashboardView.findViewById(R.id.map_part_dashboard), malpha, baseColor);
			gradientToolbar.setAlpha((int) ((1 - t) * 255));
			setAlpha(dashboardView, (int) (t * 128), 0);
			if (t < 1) {
				dashboardView.findViewById(R.id.toolbar).setBackgroundDrawable(gradientToolbar);
			} else {
				dashboardView.findViewById(R.id.toolbar).setBackgroundColor(0xff000000 | baseColor);
			}
		}
	}

	private void updateListAdapter(ArrayAdapter<?> listAdapter, OnItemClickListener listener) {
		this.listAdapter = listAdapter;
		this.listAdapterOnClickListener = listener;
		if (this.listView != null) {
			listView.setAdapter(listAdapter);
			if (!portrait) {
				listView.setOnItemClickListener(this.listAdapterOnClickListener);
			} else if (this.listAdapterOnClickListener != null) {
				listView.setOnItemClickListener(new OnItemClickListener() {

					@Override
					public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
						listAdapterOnClickListener.onItemClick(parent, view, position - 1, id);
					}
				});
			} else {
				listView.setOnItemClickListener(null);
			}
		}
	}

	@SuppressLint("NewApi")
	private void setTranslationY(View v, int y) {
		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
			v.setTranslationY(y);
		} else {
			TranslateAnimation anim = new TranslateAnimation(0, 0, y, y);
			anim.setFillAfter(true);
			anim.setDuration(0);
			v.startAnimation(anim);
		}
	}

	@SuppressLint("NewApi")
	private void setAlpha(View v, int alpha, int clr) {
//		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
//			v.setAlpha(alpha/255.f);
//		} else {
		int colr = (alpha << 24) | clr;
		v.setBackgroundColor(colr);
//		}
	}

	@Override
	public void onDownMotionEvent() {
	}


	@Override
	public void onUpOrCancelMotionEvent(ScrollState scrollState) {
//		 ActionBar ab = getSupportActionBar();
//	        if (scrollState == ScrollState.UP) {
//	            if (ab.isShowing()) {
//	                ab.hide();
//	            }
//	        } else if (scrollState == ScrollState.DOWN) {
//	            if (!ab.isShowing()) {
//	                ab.show();
//	            }
//	        }		
	}


	public <T extends DashBaseFragment> T getFragmentByClass(Class<T> class1) {
		for (WeakReference<DashBaseFragment> f : fragList) {
			DashBaseFragment b = f.get();
			if (b != null && !b.isDetached() && class1.isInstance(b)) {
				//noinspection unchecked
				return (T) b;
			}
		}
		return null;
	}

	public void blacklistFragmentByTag(String tag) {
		hideFragmentByTag(tag);
		getMyApplication().getSettings().registerBooleanPreference(SHOULD_SHOW + tag, true)
				.makeGlobal().set(false);
	}

	public void hideFragmentByTag(String tag) {
		FragmentManager manager = mapActivity.getSupportFragmentManager();
		FragmentTransaction transaction = manager.beginTransaction();
		Fragment frag = manager.findFragmentByTag(tag);
		transaction.hide(frag).commit();
	}

	public void unblacklistFragmentClass(String tag) {
		unhideFragmentByTag(tag);
		getMyApplication().getSettings().registerBooleanPreference(SHOULD_SHOW + tag, true)
				.makeGlobal().set(true);
	}

	public void unhideFragmentByTag(String tag) {
		FragmentManager manager = mapActivity.getSupportFragmentManager();
		FragmentTransaction transaction = manager.beginTransaction();
		Fragment frag = manager.findFragmentByTag(tag);
		transaction.show(frag).commit();
	}

	public void clearDeletedPoints() {
		deletedPoints.clear();
	}

	View getParentView() {
		return dashboardView;
	}

	public static <T> List<T> handleNumberOfRows(List<T> list, OsmandSettings settings,
												 String rowNumberTag) {
		int numberOfRows = settings.registerIntPreference(rowNumberTag, 3)
				.makeGlobal().get();
		if (list.size() > numberOfRows) {
			while (list.size() != numberOfRows) {
				list.remove(numberOfRows);
			}
		}
		return list;
	}

	public static class DefaultShouldShow extends DashFragmentData.ShouldShowFunction {

		public boolean shouldShow(OsmandSettings settings, MapActivity activity, String tag) {
			return settings.registerBooleanPreference(SHOULD_SHOW + tag, true).makeGlobal().get();
		}
	}

	@Override
	public void onItemSwapping(int position) {
		if (swipeDismissListener != null) {
			swipeDismissListener.setEnabled(false);
		}
	}

	@Override
	public void onItemsSwapped(final List<Object> items) {
		getMyApplication().runInUIThread(new Runnable() {
			@Override
			public void run() {
				if (visibleType == DashboardType.WAYPOINTS || visibleType == DashboardType.WAYPOINTS_FLAT) {
					List<TargetPoint> allTargets = new ArrayList<>();
					if (items != null) {
						for (Object obj : items) {
							if (obj instanceof LocationPointWrapper) {
								LocationPointWrapper p = (LocationPointWrapper) obj;
								if (p.getPoint() instanceof TargetPoint) {
									TargetPoint t = (TargetPoint) p.getPoint();
									if (!t.start) {
										t.intermediate = true;
										allTargets.add(t);
									}
								}
							}
						}
						if (allTargets.size() > 0) {
							allTargets.get(allTargets.size() - 1).intermediate = false;
						}
					}
					getMyApplication().getTargetPointsHelper().reorderAllTargetPoints(allTargets, false);
					newRouteIsCalculated(false, new ValueHolder<Boolean>());
					getMyApplication().getTargetPointsHelper().updateRouteAndRefresh(true);

					if (swipeDismissListener != null) {
						swipeDismissListener.setEnabled(true);
					}
				}
			}
		}, 50);
	}

	@Override
	public void newRouteIsCalculated(boolean newRoute, ValueHolder<Boolean> showToast) {
		reloadAdapter();
		showToast.value = false;
	}

	@Override
	public void routeWasCancelled() {
	}

	@Override
	public void routeWasFinished() {
	}

	@Override
	public void onWindowVisibilityChanged(int visibility) {
		if (visibility != View.VISIBLE && swipeDismissListener != null) {
			swipeDismissListener.discardUndo();
		}
	}

	@Override
	public void reloadAdapter() {
		if ((DashboardType.WAYPOINTS == visibleType || DashboardType.WAYPOINTS_FLAT == visibleType)
				&& listAdapter != null && listAdapter instanceof StableArrayAdapter) {
			StableArrayAdapter stableAdapter = (StableArrayAdapter) listAdapter;
			waypointDialogHelper.reloadListAdapter(stableAdapter);
			if (listView instanceof DynamicListView) {
				DynamicListView dynamicListView = (DynamicListView) listView;
				dynamicListView.setItemsList(stableAdapter.getObjects());
				dynamicListView.setActiveItemsList(stableAdapter.getActiveObjects());
			}
		}
	}

	@Override
	public void deleteWaypoint(int position) {
		if (swipeDismissListener != null) {
			swipeDismissListener.delete(position);
		}
	}
}
!@#$%
20190530_041533,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_c04328
package net.osmand.plus.dashboard;

import android.annotation.SuppressLint;
import android.content.Intent;
import android.content.res.Resources;
import android.graphics.drawable.ColorDrawable;
import android.graphics.drawable.Drawable;
import android.os.Build;
import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentManager;
import android.support.v4.app.FragmentTransaction;
import android.support.v7.widget.Toolbar;
import android.util.TypedValue;
import android.view.Gravity;
import android.view.View;
import android.view.animation.Animation;
import android.view.animation.Animation.AnimationListener;
import android.view.animation.TranslateAnimation;
import android.widget.AbsListView;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.ArrayAdapter;
import android.widget.Button;
import android.widget.CompoundButton;
import android.widget.FrameLayout;
import android.widget.ImageView;
import android.widget.ImageView.ScaleType;
import android.widget.ListView;
import android.widget.ScrollView;
import android.widget.TextView;

import com.github.ksoichiro.android.observablescrollview.ObservableListView;
import com.github.ksoichiro.android.observablescrollview.ObservableScrollView;
import com.github.ksoichiro.android.observablescrollview.ObservableScrollViewCallbacks;
import com.github.ksoichiro.android.observablescrollview.ScrollState;

import net.osmand.PlatformUtil;
import net.osmand.ValueHolder;
import net.osmand.data.LatLon;
import net.osmand.plus.ContextMenuAdapter;
import net.osmand.plus.ContextMenuAdapter.OnContextMenuClick;
import net.osmand.plus.ContextMenuAdapter.OnRowItemClick;
import net.osmand.plus.IconsCache;
import net.osmand.plus.MapMarkersHelper;
import net.osmand.plus.MapMarkersHelper.MapMarker;
import net.osmand.plus.MapMarkersHelper.MapMarkerChangedListener;
import net.osmand.plus.OsmandApplication;
import net.osmand.plus.OsmandPlugin;
import net.osmand.plus.OsmandSettings;
import net.osmand.plus.R;
import net.osmand.plus.TargetPointsHelper.TargetPoint;
import net.osmand.plus.activities.MapActivity;
import net.osmand.plus.dashboard.tools.DashFragmentData;
import net.osmand.plus.dashboard.tools.DashboardSettingsDialogFragment;
import net.osmand.plus.dashboard.tools.TransactionBuilder;
import net.osmand.plus.dialogs.ConfigureMapMenu;
import net.osmand.plus.dialogs.RasterMapMenu;
import net.osmand.plus.download.DownloadActivity;
import net.osmand.plus.helpers.AndroidUiHelper;
import net.osmand.plus.helpers.MapMarkerDialogHelper;
import net.osmand.plus.helpers.WaypointDialogHelper;
import net.osmand.plus.helpers.WaypointDialogHelper.WaypointDialogHelperCallbacks;
import net.osmand.plus.helpers.WaypointHelper.LocationPointWrapper;
import net.osmand.plus.mapcontextmenu.other.RoutePreferencesMenu;
import net.osmand.plus.mapcontextmenu.other.RoutePreferencesMenu.LocalRoutingParameter;
import net.osmand.plus.rastermaps.OsmandRasterMapsPlugin;
import net.osmand.plus.routing.RoutingHelper;
import net.osmand.plus.routing.RoutingHelper.IRouteInformationListener;
import net.osmand.plus.views.DownloadedRegionsLayer;
import net.osmand.plus.views.OsmandMapTileView;
import net.osmand.plus.views.controls.DynamicListView;
import net.osmand.plus.views.controls.DynamicListViewCallbacks;
import net.osmand.plus.views.controls.StableArrayAdapter;
import net.osmand.plus.views.controls.SwipeDismissListViewTouchListener;
import net.osmand.plus.views.controls.SwipeDismissListViewTouchListener.DismissCallbacks;
import net.osmand.plus.views.controls.SwipeDismissListViewTouchListener.Undoable;

import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import static android.util.TypedValue.COMPLEX_UNIT_DIP;

/**
 */
public class DashboardOnMap implements ObservableScrollViewCallbacks, DynamicListViewCallbacks,
		IRouteInformationListener, WaypointDialogHelperCallbacks, MapMarkerChangedListener {
	private static final org.apache.commons.logging.Log LOG =
			PlatformUtil.getLog(DashboardOnMap.class);
	private static final String TAG = "DashboardOnMap";
	public static boolean staticVisible = false;
	public static DashboardType staticVisibleType = DashboardType.DASHBOARD;
	public static final String SHOULD_SHOW = "should_show";


	private final DashFragmentData[] fragmentsData = new DashFragmentData[]{
			new DashFragmentData(DashRateUsFragment.TAG, DashRateUsFragment.class,
					DashRateUsFragment.SHOULD_SHOW_FUNCTION, 0, null),
			new DashFragmentData(DashDashboardOrDrawerFragment.TAG, DashDashboardOrDrawerFragment.class,
					DashDashboardOrDrawerFragment.SHOULD_SHOW_FUNCTION, 5, null),
			new DashFragmentData(DashErrorFragment.TAG, DashErrorFragment.class,
					DashErrorFragment.SHOULD_SHOW_FUNCTION, 30, null),
			new DashFragmentData(DashNavigationFragment.TAG, DashNavigationFragment.class,
					DashNavigationFragment.SHOULD_SHOW_FUNCTION, 40, null),
			new DashFragmentData(DashWaypointsFragment.TAG, DashWaypointsFragment.class,
					DashWaypointsFragment.SHOULD_SHOW_FUNCTION, 60, null),
			new DashFragmentData(DashSearchFragment.TAG, DashSearchFragment.class,
					DashSearchFragment.SHOULD_SHOW_FUNCTION, 70, null),
			DashRecentsFragment.FRAGMENT_DATA,
			DashFavoritesFragment.FRAGMENT_DATA,
			new DashFragmentData(DashPluginsFragment.TAG, DashPluginsFragment.class,
					DashPluginsFragment.SHOULD_SHOW_FUNCTION, 140, null)
	};

	private MapActivity mapActivity;
	private ImageView actionButton;
	private FrameLayout dashboardView;

	private ArrayAdapter<?> listAdapter;
	private OnItemClickListener listAdapterOnClickListener;
	private SwipeDismissListViewTouchListener swipeDismissListener;

	private boolean visible = false;
	private DashboardType visibleType;
	private DashboardType previousVisibleType;
	private boolean landscape;
	private List<WeakReference<DashBaseFragment>> fragList = new LinkedList<>();
	private net.osmand.Location myLocation;
	private LatLon mapViewLocation;
	private float heading;
	private boolean mapLinkedToLocation;
	private float mapRotation;
	private boolean inLocationUpdate = false;
	private ListView listView;
	private View listBackgroundView;
	private Toolbar toolbar;
	private View paddingView;
	private int mFlexibleSpaceImageHeight;
	private int mFlexibleBlurSpaceHeight;
	private boolean portrait;

	int baseColor;

	private WaypointDialogHelper waypointDialogHelper;
	private MapMarkerDialogHelper mapMarkerDialogHelper;
	private final int[] running = new int[]{-1};
	private List<LocationPointWrapper> deletedPoints = new ArrayList<>();
	private Drawable gradientToolbar;
	boolean nightMode;

	public DashFragmentData[] getFragmentsData() {
		return fragmentsData;
	}

	public enum DashboardType {
		WAYPOINTS,
		WAYPOINTS_FLAT,
		CONFIGURE_SCREEN,
		CONFIGURE_MAP,
		LIST_MENU,
		ROUTE_PREFERENCES,
		DASHBOARD,
		OVERLAY_MAP,
		UNDERLAY_MAP,
		MAP_MARKERS
	}

	private Map<DashboardActionButtonType, DashboardActionButton> actionButtons = new HashMap<>();

	public enum DashboardActionButtonType {
		MY_LOCATION,
		NAVIGATE,
		ROUTE
	}

	private class DashboardActionButton {
		private Drawable icon;
		private View.OnClickListener onClickListener;
	}

	public DashboardOnMap(MapActivity ma) {
		this.mapActivity = ma;
	}


	public void createDashboardView() {
		baseColor = mapActivity.getResources().getColor(R.color.osmand_orange) & 0x00ffffff;
		waypointDialogHelper = new WaypointDialogHelper(mapActivity);
		waypointDialogHelper.setWaypointDialogHelperCallbacks(this);
		mapMarkerDialogHelper = new MapMarkerDialogHelper(mapActivity);
		landscape = !AndroidUiHelper.isOrientationPortrait(mapActivity);
		dashboardView = (FrameLayout) mapActivity.findViewById(R.id.dashboard);
		final View.OnClickListener listener = new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				hideDashboard();
			}
		};
		toolbar = ((Toolbar) dashboardView.findViewById(R.id.toolbar));
		ObservableScrollView scrollView = ((ObservableScrollView) dashboardView.findViewById(R.id.main_scroll));
		listView = (ListView) dashboardView.findViewById(R.id.dash_list_view);
		//listView.setChoiceMode(ListView.CHOICE_MODE_SINGLE);
		listView.setDrawSelectorOnTop(true);
		((DynamicListView) listView).setDynamicListViewCallbacks(this);

		// Create a ListView-specific touch listener. ListViews are given special treatment because
		// by default they handle touches for their list items... i.e. they're in charge of drawing
		// the pressed state (the list selector), handling list item clicks, etc.
		swipeDismissListener = new SwipeDismissListViewTouchListener(
				listView,
				new DismissCallbacks() {

					private List<Object> deletedMarkers = new ArrayList<>();

					@Override
					public boolean canDismiss(int position) {
						boolean res = false;
						if (listAdapter instanceof StableArrayAdapter) {
							List<Object> activeObjects = ((StableArrayAdapter) listAdapter).getActiveObjects();
							Object obj = listAdapter.getItem(position);
							res = activeObjects.contains(obj);
						}
						return res;
					}

					@Override
					public Undoable onDismiss(final int position) {
						final Object item;
						final StableArrayAdapter stableAdapter;
						final int activeObjPos;
						if (listAdapter instanceof StableArrayAdapter) {
							stableAdapter = (StableArrayAdapter) listAdapter;
							item = stableAdapter.getItem(position);

							if (visibleType == DashboardType.MAP_MARKERS) {
								if (!((MapMarker) item).history) {
									deletedMarkers.add(item);
								}
							}

							stableAdapter.setNotifyOnChange(false);
							stableAdapter.remove(item);
							stableAdapter.getObjects().remove(item);
							activeObjPos = stableAdapter.getActiveObjects().indexOf(item);
							stableAdapter.getActiveObjects().remove(item);
							stableAdapter.refreshData();
							stableAdapter.notifyDataSetChanged();

						} else {
							item = null;
							stableAdapter = null;
							activeObjPos = 0;
						}
						return new Undoable() {
							@Override
							public void undo() {
								if (item != null) {
									stableAdapter.setNotifyOnChange(false);
									stableAdapter.insert(item, position);
									stableAdapter.getObjects().add(position, item);
									stableAdapter.getActiveObjects().add(activeObjPos, item);
									stableAdapter.refreshData();
									if (visibleType == DashboardType.WAYPOINTS || visibleType == DashboardType.WAYPOINTS_FLAT) {
										onItemsSwapped(stableAdapter.getActiveObjects());
									} else if (visibleType == DashboardType.MAP_MARKERS) {
										deletedMarkers.remove(item);
										updateMapMarkers(stableAdapter.getActiveObjects());
										reloadAdapter();
									}
								}
							}

							@Override
							public String getTitle() {
								if ((visibleType == DashboardType.WAYPOINTS || visibleType == DashboardType.WAYPOINTS_FLAT)
										&& (getMyApplication().getRoutingHelper().isRoutePlanningMode() || getMyApplication().getRoutingHelper().isFollowingMode())
										&& item != null
										&& stableAdapter.getActiveObjects().size() == 0) {
									return mapActivity.getResources().getString(R.string.cancel_navigation);
								} else {
									return null;
								}
							}
						};
					}

					@Override
					public void onHidePopup() {
						if (listAdapter instanceof StableArrayAdapter) {
							StableArrayAdapter stableAdapter = (StableArrayAdapter) listAdapter;
							stableAdapter.refreshData();
							if (visibleType == DashboardType.WAYPOINTS || visibleType == DashboardType.WAYPOINTS_FLAT) {
								onItemsSwapped(stableAdapter.getActiveObjects());
							} else if (visibleType == DashboardType.MAP_MARKERS) {
								updateMapMarkers(stableAdapter.getActiveObjects());
							}
							if (stableAdapter.getActiveObjects().size() == 0) {
								hideDashboard();
								if (visibleType == DashboardType.WAYPOINTS || visibleType == DashboardType.WAYPOINTS_FLAT) {
									mapActivity.getMapActions().stopNavigationWithoutConfirm();
									mapActivity.getMapLayers().getMapControlsLayer().getMapRouteInfoMenu().hide();
								}
							} else {
								if (visibleType == DashboardType.MAP_MARKERS) {
									reloadAdapter();
								}
							}
						}
					}

					private void updateMapMarkers(List<Object> objects) {
						List<MapMarker> markers = new ArrayList<>();
						List<MapMarker> markersHistory = new ArrayList<>();

						for (Object obj : objects) {
							MapMarker marker = (MapMarker) obj;
							if (!marker.history) {
								markers.add(marker);
							} else {
								markersHistory.add(marker);
							}
						}

						for (int i = deletedMarkers.size() - 1; i >= 0; i--) {
							markersHistory.add(0, (MapMarker) deletedMarkers.get(i));
						}
						deletedMarkers.clear();

						getMyApplication().getMapMarkersHelper().saveMapMarkers(markers, markersHistory);
					}
				});

		gradientToolbar = mapActivity.getResources().getDrawable(R.drawable.gradient_toolbar).mutate();
		if (AndroidUiHelper.isOrientationPortrait(mapActivity)) {
			this.portrait = true;
			scrollView.setScrollViewCallbacks(this);
			((ObservableListView) listView).setScrollViewCallbacks(this);
			mFlexibleSpaceImageHeight = mapActivity.getResources().getDimensionPixelSize(
					R.dimen.dashboard_map_top_padding);
			mFlexibleBlurSpaceHeight = mapActivity.getResources().getDimensionPixelSize(
					R.dimen.dashboard_map_toolbar);
			// Set padding view for ListView. This is the flexible space.
			paddingView = new FrameLayout(mapActivity);
			AbsListView.LayoutParams lp = new AbsListView.LayoutParams(AbsListView.LayoutParams.MATCH_PARENT,
					mFlexibleSpaceImageHeight);
			paddingView.setLayoutParams(lp);
			// This is required to disable header's list selector effect
			paddingView.setClickable(true);
			paddingView.setOnClickListener(listener);

			FrameLayout shadowContainer = new FrameLayout(mapActivity);
			FrameLayout.LayoutParams fl = new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT,
					FrameLayout.LayoutParams.MATCH_PARENT);
			fl.gravity = Gravity.BOTTOM;
			shadowContainer.setLayoutParams(fl);
			ImageView shadow = new ImageView(mapActivity);
			shadow.setImageDrawable(mapActivity.getResources().getDrawable(R.drawable.bg_shadow_onmap));
			shadow.setLayoutParams(new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT,
					FrameLayout.LayoutParams.WRAP_CONTENT, Gravity.BOTTOM));
			shadow.setScaleType(ScaleType.FIT_XY);
			shadowContainer.addView(shadow);
			((FrameLayout) paddingView).addView(shadowContainer);
			listView.addHeaderView(paddingView);
			listBackgroundView = mapActivity.findViewById(R.id.dash_list_background);
		}
		dashboardView.findViewById(R.id.animateContent).setOnClickListener(listener);
		dashboardView.findViewById(R.id.map_part_dashboard).setOnClickListener(listener);

		initActionButtons();
		dashboardView.addView(actionButton);
	}

	@Override
	public void onMapMarkerChanged(MapMarker mapMarker) {
		if (visible && visibleType == DashboardType.MAP_MARKERS) {
			mapMarkerDialogHelper.updateMarkerView(listView, mapMarker);
		}
	}

	@Override
	public void onMapMarkersChanged() {
	}

	private void updateListBackgroundHeight() {

		if (listBackgroundView == null || listBackgroundView.getHeight() > 0) {
			return;
		}
		final View contentView = mapActivity.getWindow().getDecorView().findViewById(android.R.id.content);
		if (contentView.getHeight() > 0) {
			listBackgroundView.getLayoutParams().height = contentView.getHeight();
		} else {
			contentView.post(new Runnable() {
				@Override
				public void run() {
					// mListBackgroundView's should fill its parent vertically
					// but the height of the content view is 0 on 'onCreate'.
					// So we should get it with post().
					listBackgroundView.getLayoutParams().height = contentView.getHeight();
				}
			});
		}
	}

	private void updateToolbarActions() {
		TextView tv = (TextView) dashboardView.findViewById(R.id.toolbar_text);
		tv.setText("");
		boolean waypointsVisible = visibleType == DashboardType.WAYPOINTS || visibleType == DashboardType.WAYPOINTS_FLAT;
		if (waypointsVisible) {
			tv.setText(R.string.waypoints);
		} else if (visibleType == DashboardType.CONFIGURE_MAP) {
			tv.setText(R.string.configure_map);
		} else if (visibleType == DashboardType.CONFIGURE_SCREEN) {
			tv.setText(R.string.layer_map_appearance);
		} else if (visibleType == DashboardType.ROUTE_PREFERENCES) {
			tv.setText(R.string.shared_string_settings);
		} else if (visibleType == DashboardType.UNDERLAY_MAP) {
			tv.setText(R.string.map_underlay);
		} else if (visibleType == DashboardType.OVERLAY_MAP) {
			tv.setText(R.string.map_overlay);
		} else if (visibleType == DashboardType.MAP_MARKERS) {
			tv.setText(R.string.map_markers);
		}
		ImageView edit = (ImageView) dashboardView.findViewById(R.id.toolbar_edit);
		edit.setVisibility(View.GONE);
		ImageView sort = (ImageView) dashboardView.findViewById(R.id.toolbar_sort);
		sort.setVisibility(View.GONE);
		ImageView ok = (ImageView) dashboardView.findViewById(R.id.toolbar_ok);
		ok.setVisibility(View.GONE);
		ImageView flat = (ImageView) dashboardView.findViewById(R.id.toolbar_flat);
		flat.setVisibility(View.GONE);
		ImageView settingsButton = (ImageView) dashboardView.findViewById(R.id.toolbar_settings);
		settingsButton.setVisibility(View.GONE);
		IconsCache iconsCache = mapActivity.getMyApplication().getIconsCache();
		ImageView lst = (ImageView) dashboardView.findViewById(R.id.toolbar_list);
		lst.setVisibility(View.GONE);
		ImageView back = (ImageView) dashboardView.findViewById(R.id.toolbar_back);
		back.setImageDrawable(
				getMyApplication().getIconsCache().getIcon(R.drawable.abc_ic_ab_back_mtrl_am_alpha));
		back.setOnClickListener(new View.OnClickListener() {

			@Override
			public void onClick(View v) {
				backPressed();
			}
		});

		if (waypointsVisible && getMyApplication().getWaypointHelper().getAllPoints().size() > 0) {
			if (getMyApplication().getWaypointHelper().isRouteCalculated()) {
				flat.setVisibility(View.VISIBLE);
				final boolean flatNow = visibleType == DashboardType.WAYPOINTS_FLAT;
				flat.setImageDrawable(iconsCache.getIcon(flatNow ? R.drawable.ic_tree_list_dark
						: R.drawable.ic_flat_list_dark));
				flat.setOnClickListener(new View.OnClickListener() {

					@Override
					public void onClick(View v) {
						setDashboardVisibility(true, flatNow ? DashboardType.WAYPOINTS : DashboardType.WAYPOINTS_FLAT,
								previousVisibleType, false);
					}
				});
			}
		}

		if (visibleType == DashboardType.MAP_MARKERS
				&& getMyApplication().getMapMarkersHelper().getActiveMapMarkers().size() > 0) {
			sort.setVisibility(View.VISIBLE);
			sort.setOnClickListener(new View.OnClickListener() {
				@Override
				public void onClick(View v) {
					mapMarkerDialogHelper.setSorted(!mapMarkerDialogHelper.isSorted());
					reloadAdapter();
				}
			});
		}

		if (visibleType == DashboardType.DASHBOARD || visibleType == DashboardType.LIST_MENU) {
			settingsButton.setVisibility(View.VISIBLE);
			settingsButton.setOnClickListener(new View.OnClickListener() {

				@Override
				public void onClick(View v) {
					new DashboardSettingsDialogFragment().show(
							mapActivity.getSupportFragmentManager(), "dashboard_settings");
				}
			});
			lst.setVisibility(View.VISIBLE);
			lst.setOnClickListener(new View.OnClickListener() {

				@Override
				public void onClick(View v) {
					hideDashboard(false);
					mapActivity.openDrawer();
				}
			});
		}
	}


	private void initActionButtons() {
		actionButton = new ImageView(mapActivity);
		int btnSize = (int) mapActivity.getResources().getDimension(R.dimen.map_button_size);
		int topPad = (int) mapActivity.getResources().getDimension(R.dimen.dashboard_map_top_padding);
		FrameLayout.LayoutParams params = new FrameLayout.LayoutParams(
				btnSize, btnSize
		);
		int marginRight = btnSize / 4;
		params.setMargins(0, landscape ? 0 : topPad - 2 * btnSize,
				marginRight, landscape ? marginRight : 0);
		params.gravity = landscape ? Gravity.BOTTOM | Gravity.RIGHT : Gravity.TOP | Gravity.RIGHT;
		actionButton.setLayoutParams(params);
		actionButton.setScaleType(ScaleType.CENTER);
		actionButton.setBackgroundDrawable(mapActivity.getResources().getDrawable(R.drawable.btn_circle_blue));
		hideActionButton();


		DashboardActionButton myLocationButton = new DashboardActionButton();
		myLocationButton.icon = mapActivity.getResources().getDrawable(R.drawable.map_my_location);
		myLocationButton.onClickListener = new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				if (getMyApplication().accessibilityEnabled()) {
					mapActivity.getMapActions().whereAmIDialog();
				} else {
					mapActivity.getMapViewTrackingUtilities().backToLocationImpl();
				}
				hideDashboard();
			}
		};

		DashboardActionButton navigateButton = new DashboardActionButton();
		navigateButton.icon = mapActivity.getResources().getDrawable(R.drawable.map_start_navigation);
		navigateButton.onClickListener = new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				mapActivity.getMapLayers().getMapControlsLayer().doNavigate();
				hideDashboard();
			}
		};

		DashboardActionButton routeButton = new DashboardActionButton();
		routeButton.icon = mapActivity.getResources().getDrawable(R.drawable.map_directions);
		routeButton.onClickListener = new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				mapActivity.getMapLayers().getMapControlsLayer().doRoute();
				hideDashboard();
			}
		};

		actionButtons.put(DashboardActionButtonType.MY_LOCATION, myLocationButton);
		actionButtons.put(DashboardActionButtonType.NAVIGATE, navigateButton);
		actionButtons.put(DashboardActionButtonType.ROUTE, routeButton);
	}

	private void setActionButton(DashboardType type) {
		DashboardActionButton button = null;

		if (type == DashboardType.DASHBOARD
				|| type == DashboardType.LIST_MENU
				|| type == DashboardType.CONFIGURE_SCREEN) {
			button = actionButtons.get(DashboardActionButtonType.MY_LOCATION);
		} else if (type == DashboardType.ROUTE_PREFERENCES) {
			button = actionButtons.get(DashboardActionButtonType.NAVIGATE);
		} else if (type == DashboardType.WAYPOINTS || type == DashboardType.WAYPOINTS_FLAT) {
			boolean routePlanningMode = false;
			RoutingHelper rh = mapActivity.getRoutingHelper();
			if (rh.isRoutePlanningMode()) {
				routePlanningMode = true;
			} else if ((rh.isRouteCalculated() || rh.isRouteBeingCalculated()) && !rh.isFollowingMode()) {
				routePlanningMode = true;
			}
			boolean routeFollowingMode = !routePlanningMode && rh.isFollowingMode();

			if (routePlanningMode || routeFollowingMode) {
				button = actionButtons.get(DashboardActionButtonType.NAVIGATE);
			} else {
				button = actionButtons.get(DashboardActionButtonType.ROUTE);
			}
		}

		if (button != null) {
			actionButton.setImageDrawable(button.icon);
			actionButton.setOnClickListener(button.onClickListener);
		}
	}

	private void hideActionButton() {
		actionButton.setVisibility(View.GONE);
	}

	public net.osmand.Location getMyLocation() {
		return myLocation;
	}

	public LatLon getMapViewLocation() {
		return mapViewLocation;
	}

	public float getHeading() {
		return heading;
	}

	public float getMapRotation() {
		return mapRotation;
	}

	public boolean isMapLinkedToLocation() {
		return mapLinkedToLocation;
	}

	protected OsmandApplication getMyApplication() {
		return mapActivity.getMyApplication();
	}

	public ArrayAdapter<?> getListAdapter() {
		return listAdapter;
	}

	public OnItemClickListener getListAdapterOnClickListener() {
		return listAdapterOnClickListener;
	}

	public void hideDashboard() {
		setDashboardVisibility(false, visibleType);
	}

	public void hideDashboard(boolean animation) {
		setDashboardVisibility(false, visibleType, animation);
	}

	public void setDashboardVisibility(boolean visible, DashboardType type) {
		setDashboardVisibility(visible, type, this.visible ? visibleType : null, true);
	}

	public void setDashboardVisibility(boolean visible, DashboardType type, boolean animation) {
		setDashboardVisibility(visible, type, this.visible ? visibleType : null, animation);
	}

	public void refreshDashboardFragments() {
		addOrUpdateDashboardFragments();
	}

	public void setDashboardVisibility(boolean visible, DashboardType type, DashboardType prevItem, boolean animation) {
		if (visible == this.visible && type == visibleType) {
			return;
		}
		nightMode = mapActivity.getMyApplication().getDaynightHelper().isNightModeForMapControls();
		this.previousVisibleType = prevItem;
		this.visible = visible;
		boolean refresh = this.visibleType == type;
		this.visibleType = type;
		DashboardOnMap.staticVisible = visible;
		DashboardOnMap.staticVisibleType = type;
		mapActivity.enableDrawer();
		if (visible) {
			mapViewLocation = mapActivity.getMapLocation();
			mapRotation = mapActivity.getMapRotate();
			mapLinkedToLocation = mapActivity.getMapViewTrackingUtilities().isMapLinkedToLocation();
			myLocation = mapActivity.getMyApplication().getLocationProvider().getLastKnownLocation();
			mapActivity.getMapViewTrackingUtilities().setDashboard(this);
			mapActivity.disableDrawer();
			dashboardView.setVisibility(View.VISIBLE);
			if (isActionButtonVisible()) {
				setActionButton(visibleType);
				actionButton.setVisibility(View.VISIBLE);
			} else {
				hideActionButton();
			}
			updateDownloadBtn();
			View listViewLayout = dashboardView.findViewById(R.id.dash_list_view_layout);
			ScrollView scrollView = (ScrollView) dashboardView.findViewById(R.id.main_scroll);
			if (visibleType == DashboardType.DASHBOARD) {
				addOrUpdateDashboardFragments();
				scrollView.setVisibility(View.VISIBLE);
				scrollView.scrollTo(0, 0);
				listViewLayout.setVisibility(View.GONE);
				onScrollChanged(scrollView.getScrollY(), false, false);
			} else {
				scrollView.setVisibility(View.GONE);
				listViewLayout.setVisibility(View.VISIBLE);
				if (listView instanceof ObservableListView) {
					onScrollChanged(listView.getScrollY(), false, false);
				}
				if (refresh) {
					refreshContent(false);
				} else {
					updateListAdapter();
					updateListBackgroundHeight();
				}
				applyDayNightMode();

				if (visibleType == DashboardType.MAP_MARKERS) {
					getMyApplication().getMapMarkersHelper().addListener(this);
				}
			}
			mapActivity.findViewById(R.id.toolbar_back).setVisibility(isBackButtonVisible() ? View.VISIBLE : View.GONE);
			mapActivity.findViewById(R.id.MapHudButtonsOverlay).setVisibility(View.INVISIBLE);
			boolean portrait = AndroidUiHelper.isOrientationPortrait(mapActivity);
			if (!portrait) {
				AndroidUiHelper.updateVisibility(mapActivity.findViewById(R.id.map_route_land_left_margin_external), true);
				mapActivity.getMapView().setMapPositionX(1);
				mapActivity.refreshMap();
			}

			updateToolbarActions();
			//fabButton.showFloatingActionButton();
			open(dashboardView.findViewById(R.id.animateContent), animation);
			updateLocation(true, true, false);
//			addOrUpdateDashboardFragments();
			mapActivity.getRoutingHelper().addListener(this);
		} else {
			if (visibleType == DashboardType.MAP_MARKERS) {
				getMyApplication().getMapMarkersHelper().removeListener(this);
			}
			if (swipeDismissListener != null) {
				swipeDismissListener.discardUndo();
			}
			mapActivity.getRoutingHelper().removeListener(this);
			mapActivity.getMapViewTrackingUtilities().setDashboard(null);
			hide(dashboardView.findViewById(R.id.animateContent), animation);

			if (!mapActivity.getMapLayers().getMapControlsLayer().getMapRouteInfoMenu().isVisible()) {
				AndroidUiHelper.updateVisibility(mapActivity.findViewById(R.id.map_route_land_left_margin_external), false);
				mapActivity.getMapView().setMapPositionX(0);
				mapActivity.getMapView().refreshMap();
			}

			mapActivity.findViewById(R.id.MapHudButtonsOverlay).setVisibility(View.VISIBLE);
			hideActionButton();
			for (WeakReference<DashBaseFragment> df : fragList) {
				if (df.get() != null) {
					df.get().onCloseDash();
				}
			}
		}
	}

	private void applyDayNightMode() {
		if (nightMode) {
			if (listBackgroundView != null) {
				listBackgroundView.setBackgroundColor(mapActivity.getResources().getColor(R.color.ctx_menu_info_view_bg_dark));
			} else {
				listView.setBackgroundColor(mapActivity.getResources().getColor(R.color.ctx_menu_info_view_bg_dark));
			}
			if (visibleType != DashboardType.WAYPOINTS && visibleType != DashboardType.MAP_MARKERS) {
				Drawable d = new ColorDrawable(mapActivity.getResources().getColor(R.color.dashboard_divider_dark));
				listView.setDivider(d);
				listView.setDividerHeight(dpToPx(1f));
			} else {
				listView.setDivider(null);
			}
		} else {
			if (listBackgroundView != null) {
				listBackgroundView.setBackgroundColor(mapActivity.getResources().getColor(R.color.ctx_menu_info_view_bg_light));
			} else {
				listView.setBackgroundColor(mapActivity.getResources().getColor(R.color.ctx_menu_info_view_bg_light));
			}
			if (visibleType != DashboardType.WAYPOINTS && visibleType != DashboardType.MAP_MARKERS) {
				Drawable d = new ColorDrawable(mapActivity.getResources().getColor(R.color.dashboard_divider_light));
				listView.setDivider(d);
				listView.setDividerHeight(dpToPx(1f));
			} else {
				listView.setDivider(null);
			}
		}
	}

	private int dpToPx(float dp) {
		Resources r = mapActivity.getResources();
		return (int) TypedValue.applyDimension(COMPLEX_UNIT_DIP, dp, r.getDisplayMetrics());
	}

	private void updateListAdapter() {
		ContextMenuAdapter cm = null;
		if (DashboardType.WAYPOINTS == visibleType || DashboardType.WAYPOINTS_FLAT == visibleType) {

			StableArrayAdapter listAdapter = waypointDialogHelper.getWaypointsDrawerAdapter(true, deletedPoints, mapActivity, running,
					DashboardType.WAYPOINTS_FLAT == visibleType, nightMode);
			OnItemClickListener listener = waypointDialogHelper.getDrawerItemClickListener(mapActivity, running,
					listAdapter);

			DynamicListView dynamicListView = (DynamicListView) listView;
			dynamicListView.setItemsList(listAdapter.getObjects());
			dynamicListView.setActiveItemsList(listAdapter.getActiveObjects());

			updateListAdapter(listAdapter, listener);

		} else if (DashboardType.MAP_MARKERS == visibleType) {

			mapMarkerDialogHelper.setNightMode(nightMode);
			StableArrayAdapter listAdapter = mapMarkerDialogHelper.getMapMarkersListAdapter();
			OnItemClickListener listener = mapMarkerDialogHelper.getItemClickListener(listAdapter);

			DynamicListView dynamicListView = (DynamicListView) listView;
			dynamicListView.setItemsList(listAdapter.getObjects());
			dynamicListView.setActiveItemsList(listAdapter.getActiveObjects());

			updateListAdapter(listAdapter, listener);

		} else {

			if (DashboardType.CONFIGURE_SCREEN == visibleType) {
				cm = mapActivity.getMapLayers().getMapWidgetRegistry().getViewConfigureMenuAdapter(mapActivity);
			} else if (DashboardType.CONFIGURE_MAP == visibleType) {
				cm = new ConfigureMapMenu().createListAdapter(mapActivity);
			} else if (DashboardType.LIST_MENU == visibleType) {
				cm = mapActivity.getMapActions().createMainOptionsMenu();
			} else if (DashboardType.ROUTE_PREFERENCES == visibleType) {
				RoutePreferencesMenu routePreferencesMenu = new RoutePreferencesMenu(mapActivity);
				ArrayAdapter<LocalRoutingParameter> listAdapter = routePreferencesMenu.getRoutePreferencesDrawerAdapter(nightMode);
				OnItemClickListener listener = routePreferencesMenu.getItemClickListener(listAdapter);
				updateListAdapter(listAdapter, listener);
			} else if (DashboardType.UNDERLAY_MAP == visibleType) {
				cm = RasterMapMenu.createListAdapter(mapActivity, OsmandRasterMapsPlugin.RasterMapType.UNDERLAY);
			} else if (DashboardType.OVERLAY_MAP == visibleType) {
				cm = RasterMapMenu.createListAdapter(mapActivity, OsmandRasterMapsPlugin.RasterMapType.OVERLAY);
			}
			if (cm != null) {
				updateListAdapter(cm);
			}
		}
	}

	public void updateListAdapter(ContextMenuAdapter cm) {
		boolean nightMode = mapActivity.getMyApplication().getDaynightHelper().isNightModeForMapControls();
		if (this.nightMode != nightMode) {
			this.nightMode = nightMode;
			applyDayNightMode();
		}
		final ArrayAdapter<?> listAdapter = cm.createListAdapter(mapActivity, !nightMode);
		OnItemClickListener listener = getOptionsMenuOnClickListener(cm, listAdapter);
		updateListAdapter(listAdapter, listener);
	}

	public void refreshContent(boolean force) {
		if (visibleType == DashboardType.WAYPOINTS || visibleType == DashboardType.MAP_MARKERS || force) {
			updateListAdapter();
		} else if (visibleType == DashboardType.CONFIGURE_MAP || visibleType == DashboardType.ROUTE_PREFERENCES) {
			int index = listView.getFirstVisiblePosition();
			View v = listView.getChildAt(0);
			int top = (v == null) ? 0 : (v.getTop() - listView.getPaddingTop());
			updateListAdapter();
			listView.setSelectionFromTop(index, top);
		} else {
			listAdapter.notifyDataSetChanged();
		}
	}


	private OnItemClickListener getOptionsMenuOnClickListener(final ContextMenuAdapter cm,
															  final ArrayAdapter<?> listAdapter) {
		return new AdapterView.OnItemClickListener() {

			@Override
			public void onItemClick(AdapterView<?> parent, View view, int which, long id) {
				OnContextMenuClick click = cm.getClickAdapter(which);
				if (click instanceof OnRowItemClick) {
					boolean cl = ((OnRowItemClick) click).onRowItemClick(listAdapter, view, cm.getElementId(which), which);
					if (cl) {
						hideDashboard();
					}
				} else if (click != null) {
					CompoundButton btn = (CompoundButton) view.findViewById(R.id.check_item);
					if (btn != null && btn.getVisibility() == View.VISIBLE) {
						btn.setChecked(!btn.isChecked());
					} else {
						if (click.onContextMenuClick(listAdapter, cm.getElementId(which), which, false)) {
							hideDashboard();
						}
					}
				} else {
					hideDashboard();
				}
			}
		};
	}

	private void updateDownloadBtn() {
		Button btn = (Button) dashboardView.findViewById(R.id.map_download_button);
		String filter = null;
		String txt = "";
		OsmandMapTileView mv = mapActivity.getMapView();
		if (mv != null && !mapActivity.getMyApplication().isApplicationInitializing()) {
			if (mv.getZoom() < 11 && !mapActivity.getMyApplication().getResourceManager().containsBasemap()) {
				filter = "basemap";
				txt = mapActivity.getString(R.string.shared_string_download) + " "
						+ mapActivity.getString(R.string.base_world_map);
			} else {
				DownloadedRegionsLayer dl = mv.getLayerByClass(DownloadedRegionsLayer.class);
				if (dl != null) {
					StringBuilder btnName = new StringBuilder();
					filter = dl.getFilter(btnName);
					txt = btnName.toString();
				}
			}
		}

		btn.setText(txt);
		btn.setVisibility(filter == null ? View.GONE : View.VISIBLE);
		final String f = filter;
		btn.setOnClickListener(new View.OnClickListener() {

			@Override
			public void onClick(View v) {
				hideDashboard(false);
				final Intent intent = new Intent(mapActivity, mapActivity.getMyApplication().getAppCustomization()
						.getDownloadIndexActivity());
				if (f != null && !f.equals("basemap")) {
					intent.putExtra(DownloadActivity.FILTER_KEY, f);
				}
				intent.putExtra(DownloadActivity.TAB_TO_OPEN, DownloadActivity.DOWNLOAD_TAB);
				mapActivity.startActivity(intent);
			}
		});
		scheduleDownloadButtonCheck();
	}

	private void scheduleDownloadButtonCheck() {
		mapActivity.getMyApplication().runInUIThread(new Runnable() {

			@Override
			public void run() {
				if (isVisible()) {
					updateDownloadBtn();
				}
			}
		}, 4000);
	}


	public void navigationAction() {
		RoutingHelper routingHelper = mapActivity.getRoutingHelper();
		if (!routingHelper.isFollowingMode() && !routingHelper.isRoutePlanningMode()) {
			mapActivity.getMapActions().enterRoutePlanningMode(null, null);
		} else {
			mapActivity.getRoutingHelper().setRoutePlanningMode(true);
			mapActivity.getMapViewTrackingUtilities().switchToRoutePlanningMode();
			mapActivity.refreshMap();
		}
		hideDashboard(true);
	}


	// To animate view slide out from right to left
	private void open(View view, boolean animation) {
		if (animation) {
			TranslateAnimation animate = new TranslateAnimation(-mapActivity.findViewById(R.id.MapHudButtonsOverlay)
					.getWidth(), 0, 0, 0);
			animate.setDuration(500);
			animate.setFillAfter(true);
			view.startAnimation(animate);
			view.setVisibility(View.VISIBLE);
		} else {
			view.setVisibility(View.VISIBLE);
		}
	}

	private void hide(View view, boolean animation) {
		if (!animation) {
			dashboardView.setVisibility(View.GONE);
		} else {
			TranslateAnimation animate = new TranslateAnimation(0, -mapActivity.findViewById(R.id.MapHudButtonsOverlay)
					.getWidth(), 0, 0);
			animate.setDuration(500);
			animate.setFillAfter(true);
			animate.setAnimationListener(new AnimationListener() {

				@Override
				public void onAnimationStart(Animation animation) {

				}

				@Override
				public void onAnimationRepeat(Animation animation) {

				}

				@Override
				public void onAnimationEnd(Animation animation) {
					dashboardView.setVisibility(View.GONE);
				}
			});
			view.startAnimation(animate);
		}
		view.setVisibility(View.GONE);
	}


	private void addOrUpdateDashboardFragments() {
		OsmandSettings settings = getMyApplication().getSettings();
		TransactionBuilder builder =
				new TransactionBuilder(mapActivity.getSupportFragmentManager(), settings, mapActivity);
		builder.addFragmentsData(fragmentsData)
				.addFragmentsData(OsmandPlugin.getPluginsCardsList())
				.getFragmentTransaction().commit();
	}

	public boolean isVisible() {
		return visible;
	}

	public void onDetach(DashBaseFragment dashBaseFragment) {
		Iterator<WeakReference<DashBaseFragment>> it = fragList.iterator();
		while (it.hasNext()) {
			WeakReference<DashBaseFragment> wr = it.next();
			if (wr.get() == dashBaseFragment) {
				it.remove();
			}
		}
	}


	public void updateLocation(final boolean centerChanged, final boolean locationChanged,
							   final boolean compassChanged) {
		if (inLocationUpdate) {
			return;
		}
		inLocationUpdate = true;
		mapActivity.runOnUiThread(new Runnable() {
			@Override
			public void run() {
				inLocationUpdate = false;
				for (WeakReference<DashBaseFragment> df : fragList) {
					if (df.get() instanceof DashLocationFragment) {
						((DashLocationFragment) df.get()).updateLocation(centerChanged, locationChanged, compassChanged);
					}
				}
				if (visibleType == DashboardType.MAP_MARKERS) {
					mapMarkerDialogHelper.updateLocation(listView, compassChanged);
				}
			}
		});

	}

	public void updateMyLocation(net.osmand.Location location) {
		myLocation = location;
		updateLocation(false, true, false);
	}

	public void updateCompassValue(double heading) {
		this.heading = (float) heading;
		updateLocation(false, false, true);
	}

	public void onAttach(DashBaseFragment dashBaseFragment) {
		fragList.add(new WeakReference<>(dashBaseFragment));
	}

	public void requestLayout() {
		dashboardView.requestLayout();
	}


	public void onMenuPressed() {
		if (!isVisible()) {
			setDashboardVisibility(true, DashboardType.DASHBOARD);
		} else {
			hideDashboard();
		}
	}


	public boolean onBackPressed() {
		if (isVisible()) {
			backPressed();
			return true;
		}
		return false;
	}


	private void backPressed() {
		if (previousVisibleType != visibleType && previousVisibleType != null) {
			visibleType = null;
			setDashboardVisibility(true, previousVisibleType);
		} else {
			hideDashboard();
		}
	}


	@Override
	public void onScrollChanged(int scrollY, boolean firstScroll, boolean dragging) {
		// Translate list background
		if (portrait) {
			if (listBackgroundView != null) {
				setTranslationY(listBackgroundView, Math.max(0, -scrollY + mFlexibleSpaceImageHeight));
			}
		}
		if (portrait) {
			setTranslationY(toolbar, Math.min(0, -scrollY + mFlexibleSpaceImageHeight - mFlexibleBlurSpaceHeight));
		}
		updateColorOfToolbar(scrollY);
		updateTopButton(scrollY);
	}

	private boolean isActionButtonVisible() {
		return visibleType == DashboardType.DASHBOARD
				|| visibleType == DashboardType.WAYPOINTS
				|| visibleType == DashboardType.WAYPOINTS_FLAT
				|| visibleType == DashboardType.LIST_MENU
				|| visibleType == DashboardType.ROUTE_PREFERENCES
				|| visibleType == DashboardType.CONFIGURE_SCREEN;
	}

	private boolean isBackButtonVisible() {
		return !(visibleType == DashboardType.DASHBOARD || visibleType == DashboardType.LIST_MENU);
	}

	private void updateTopButton(int scrollY) {

		if (actionButton != null && portrait && isActionButtonVisible()) {
			double scale = mapActivity.getResources().getDisplayMetrics().density;
			int originalPosition = mFlexibleSpaceImageHeight - (int) (80 * scale);
			int minTop = mFlexibleBlurSpaceHeight + (int) (5 * scale);
			FrameLayout.LayoutParams lp = (FrameLayout.LayoutParams) actionButton.getLayoutParams();
			if (minTop > originalPosition - scrollY) {
				hideActionButton();
			} else {
				actionButton.setVisibility(View.VISIBLE);
				lp.topMargin = originalPosition - scrollY;
				((FrameLayout) actionButton.getParent()).updateViewLayout(actionButton, lp);
			}

		}
	}


	private void updateColorOfToolbar(int scrollY) {
		if (portrait) {
			float sh = mFlexibleSpaceImageHeight - mFlexibleBlurSpaceHeight;
			float t = sh == 0 ? 1 : (1 - Math.max(0, -scrollY + sh) / sh);
			t = Math.max(0, t);

			int alpha = (int) (t * 255);
			// in order to have proper fast scroll down
			int malpha = t == 1 ? 0 : alpha;
			setAlpha(paddingView, malpha, baseColor);
			setAlpha(dashboardView.findViewById(R.id.map_part_dashboard), malpha, baseColor);
			gradientToolbar.setAlpha((int) ((1 - t) * 255));
			setAlpha(dashboardView, (int) (t * 128), 0);
			if (t < 1) {
				dashboardView.findViewById(R.id.toolbar).setBackgroundDrawable(gradientToolbar);
			} else {
				dashboardView.findViewById(R.id.toolbar).setBackgroundColor(0xff000000 | baseColor);
			}
		}
	}

	private void updateListAdapter(ArrayAdapter<?> listAdapter, OnItemClickListener listener) {
		this.listAdapter = listAdapter;
		this.listAdapterOnClickListener = listener;
		if (this.listView != null) {
			listView.setAdapter(listAdapter);
			if (!portrait) {
				listView.setOnItemClickListener(this.listAdapterOnClickListener);
			} else if (this.listAdapterOnClickListener != null) {
				listView.setOnItemClickListener(new OnItemClickListener() {

					@Override
					public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
						listAdapterOnClickListener.onItemClick(parent, view, position - 1, id);
					}
				});
			} else {
				listView.setOnItemClickListener(null);
			}
		}
	}

	@SuppressLint("NewApi")
	private void setTranslationY(View v, int y) {
		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
			v.setTranslationY(y);
		} else {
			TranslateAnimation anim = new TranslateAnimation(0, 0, y, y);
			anim.setFillAfter(true);
			anim.setDuration(0);
			v.startAnimation(anim);
		}
	}

	@SuppressLint("NewApi")
	private void setAlpha(View v, int alpha, int clr) {
//		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
//			v.setAlpha(alpha/255.f);
//		} else {
		int colr = (alpha << 24) | clr;
		v.setBackgroundColor(colr);
//		}
	}

	@Override
	public void onDownMotionEvent() {
	}


	@Override
	public void onUpOrCancelMotionEvent(ScrollState scrollState) {
//		 ActionBar ab = getSupportActionBar();
//	        if (scrollState == ScrollState.UP) {
//	            if (ab.isShowing()) {
//	                ab.hide();
//	            }
//	        } else if (scrollState == ScrollState.DOWN) {
//	            if (!ab.isShowing()) {
//	                ab.show();
//	            }
//	        }		
	}


	public <T extends DashBaseFragment> T getFragmentByClass(Class<T> class1) {
		for (WeakReference<DashBaseFragment> f : fragList) {
			DashBaseFragment b = f.get();
			if (b != null && !b.isDetached() && class1.isInstance(b)) {
				//noinspection unchecked
				return (T) b;
			}
		}
		return null;
	}

	public void blacklistFragmentByTag(String tag) {
		hideFragmentByTag(tag);
		getMyApplication().getSettings().registerBooleanPreference(SHOULD_SHOW + tag, true)
				.makeGlobal().set(false);
	}

	public void hideFragmentByTag(String tag) {
		FragmentManager manager = mapActivity.getSupportFragmentManager();
		FragmentTransaction transaction = manager.beginTransaction();
		Fragment frag = manager.findFragmentByTag(tag);
		transaction.hide(frag).commit();
	}

	public void unblacklistFragmentClass(String tag) {
		unhideFragmentByTag(tag);
		getMyApplication().getSettings().registerBooleanPreference(SHOULD_SHOW + tag, true)
				.makeGlobal().set(true);
	}

	public void unhideFragmentByTag(String tag) {
		FragmentManager manager = mapActivity.getSupportFragmentManager();
		FragmentTransaction transaction = manager.beginTransaction();
		Fragment frag = manager.findFragmentByTag(tag);
		transaction.show(frag).commit();
	}

	public void clearDeletedPoints() {
		deletedPoints.clear();
	}

	View getParentView() {
		return dashboardView;
	}

	public static <T> List<T> handleNumberOfRows(List<T> list, OsmandSettings settings,
												 String rowNumberTag) {
		int numberOfRows = settings.registerIntPreference(rowNumberTag, 3)
				.makeGlobal().get();
		if (list.size() > numberOfRows) {
			while (list.size() != numberOfRows) {
				list.remove(numberOfRows);
			}
		}
		return list;
	}

	public static class DefaultShouldShow extends DashFragmentData.ShouldShowFunction {

		public boolean shouldShow(OsmandSettings settings, MapActivity activity, String tag) {
			return settings.registerBooleanPreference(SHOULD_SHOW + tag, true).makeGlobal().get();
		}
	}

	@Override
	public void onItemSwapping(int position) {
		if (swipeDismissListener != null) {
			swipeDismissListener.setEnabled(false);
		}
	}

	@Override
	public void onItemsSwapped(final List<Object> items) {
		getMyApplication().runInUIThread(new Runnable() {
			@Override
			public void run() {
				if (visibleType == DashboardType.WAYPOINTS || visibleType == DashboardType.WAYPOINTS_FLAT) {
					List<TargetPoint> allTargets = new ArrayList<>();
					if (items != null) {
						for (Object obj : items) {
							if (obj instanceof LocationPointWrapper) {
								LocationPointWrapper p = (LocationPointWrapper) obj;
								if (p.getPoint() instanceof TargetPoint) {
									TargetPoint t = (TargetPoint) p.getPoint();
									if (!t.start) {
										t.intermediate = true;
										allTargets.add(t);
									}
								}
							}
						}
						if (allTargets.size() > 0) {
							allTargets.get(allTargets.size() - 1).intermediate = false;
						}
					}
					getMyApplication().getTargetPointsHelper().reorderAllTargetPoints(allTargets, false);
					newRouteIsCalculated(false, new ValueHolder<Boolean>());
					getMyApplication().getTargetPointsHelper().updateRouteAndRefresh(true);

					if (swipeDismissListener != null) {
						swipeDismissListener.setEnabled(true);
					}
				}
			}
		}, 50);
	}

	@Override
	public void newRouteIsCalculated(boolean newRoute, ValueHolder<Boolean> showToast) {
		reloadAdapter();
		showToast.value = false;
	}

	@Override
	public void routeWasCancelled() {
	}

	@Override
	public void routeWasFinished() {
	}

	@Override
	public void onWindowVisibilityChanged(int visibility) {
		if (visibility != View.VISIBLE && swipeDismissListener != null) {
			swipeDismissListener.discardUndo();
		}
	}

	@Override
	public void reloadAdapter() {
		if (listAdapter != null && listAdapter instanceof StableArrayAdapter) {
			StableArrayAdapter stableAdapter = (StableArrayAdapter) listAdapter;
			if (DashboardType.WAYPOINTS == visibleType || DashboardType.WAYPOINTS_FLAT == visibleType) {
				waypointDialogHelper.reloadListAdapter(stableAdapter);
			} else if (DashboardType.MAP_MARKERS == visibleType) {
				mapMarkerDialogHelper.reloadListAdapter(stableAdapter);
			}
			if (listView instanceof DynamicListView) {
				DynamicListView dynamicListView = (DynamicListView) listView;
				dynamicListView.setItemsList(stableAdapter.getObjects());
				dynamicListView.setActiveItemsList(stableAdapter.getActiveObjects());
			}
		}
	}

	@Override
	public void deleteWaypoint(int position) {
		if (swipeDismissListener != null) {
			swipeDismissListener.delete(position);
		}
	}
}
!@#$%
20190530_041535,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_b04328
package net.osmand.plus.activities;


import android.content.DialogInterface;
import android.content.Intent;
import android.support.v7.app.AlertDialog;
import android.widget.ListAdapter;
import android.widget.Toast;

import net.osmand.CallbackWithObject;
import net.osmand.ResultMatcher;
import net.osmand.StateChangedListener;
import net.osmand.access.AccessibleToast;
import net.osmand.map.ITileSource;
import net.osmand.map.TileSourceManager.TileSourceTemplate;
import net.osmand.plus.ContextMenuAdapter;
import net.osmand.plus.ContextMenuAdapter.Item;
import net.osmand.plus.GPXUtilities.GPXFile;
import net.osmand.plus.GPXUtilities.WptPt;
import net.osmand.plus.OsmandApplication;
import net.osmand.plus.OsmandPlugin;
import net.osmand.plus.OsmandSettings;
import net.osmand.plus.OsmandSettings.CommonPreference;
import net.osmand.plus.R;
import net.osmand.plus.SQLiteTileSource;
import net.osmand.plus.activities.search.SearchActivity;
import net.osmand.plus.helpers.GpxUiHelper;
import net.osmand.plus.poi.PoiFiltersHelper;
import net.osmand.plus.poi.PoiUIFilter;
import net.osmand.plus.rastermaps.OsmandRasterMapsPlugin;
import net.osmand.plus.render.MapVectorLayer;
import net.osmand.plus.render.RenderingIcons;
import net.osmand.plus.routing.RoutingHelper;
import net.osmand.plus.views.ContextMenuLayer;
import net.osmand.plus.views.DownloadedRegionsLayer;
import net.osmand.plus.views.FavoritesLayer;
import net.osmand.plus.views.GPXLayer;
import net.osmand.plus.views.ImpassableRoadsLayer;
import net.osmand.plus.views.MapControlsLayer;
import net.osmand.plus.views.MapInfoLayer;
import net.osmand.plus.views.MapTextLayer;
import net.osmand.plus.views.MapTileLayer;
import net.osmand.plus.views.OsmandMapTileView;
import net.osmand.plus.views.POIMapLayer;
import net.osmand.plus.views.PointLocationLayer;
import net.osmand.plus.views.PointNavigationLayer;
import net.osmand.plus.views.RouteLayer;
import net.osmand.plus.views.TransportInfoLayer;
import net.osmand.plus.views.TransportStopsLayer;
import net.osmand.plus.views.mapwidgets.MapWidgetRegistry;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map.Entry;

/**
 * Object is responsible to maintain layers using by map activity
 */
public class MapActivityLayers {

	private final MapActivity activity;

	// the order of layer should be preserved ! when you are inserting new layer
	private MapTileLayer mapTileLayer;
	private MapVectorLayer mapVectorLayer;
	private GPXLayer gpxLayer;
	private RouteLayer routeLayer;
	private POIMapLayer poiMapLayer;
	private FavoritesLayer favoritesLayer;
	private TransportStopsLayer transportStopsLayer;
	private TransportInfoLayer transportInfoLayer;
	private PointLocationLayer locationLayer;
	private PointNavigationLayer navigationLayer;
	private ImpassableRoadsLayer impassableRoadsLayer;
	private MapInfoLayer mapInfoLayer;
	private MapTextLayer mapTextLayer;
	private ContextMenuLayer contextMenuLayer;
	private MapControlsLayer mapControlsLayer;
	private DownloadedRegionsLayer downloadedRegionsLayer;
	private MapWidgetRegistry mapWidgetRegistry;

	private StateChangedListener<Integer> transparencyListener;

	public MapActivityLayers(MapActivity activity) {
		this.activity = activity;
		this.mapWidgetRegistry = new MapWidgetRegistry(activity.getMyApplication().getSettings());
	}

	public MapWidgetRegistry getMapWidgetRegistry() {
		return mapWidgetRegistry;
	}

	public OsmandApplication getApplication() {
		return (OsmandApplication) activity.getApplication();
	}


	public void createLayers(final OsmandMapTileView mapView) {

		OsmandApplication app = (OsmandApplication) getApplication();
		RoutingHelper routingHelper = app.getRoutingHelper();
		// first create to make accessible
		mapTextLayer = new MapTextLayer();
		// 5.95 all labels
		mapView.addLayer(mapTextLayer, 5.95f);
		// mapView.addLayer(underlayLayer, -0.5f);
		mapTileLayer = new MapTileLayer(true);
		mapView.addLayer(mapTileLayer, 0.0f);
		mapView.setMainLayer(mapTileLayer);

		// 0.5 layer
		mapVectorLayer = new MapVectorLayer(mapTileLayer, false);
		mapView.addLayer(mapVectorLayer, 0.5f);

		downloadedRegionsLayer = new DownloadedRegionsLayer();
		mapView.addLayer(downloadedRegionsLayer, 0.5f);

		// 0.9 gpx layer
		gpxLayer = new GPXLayer();
		mapView.addLayer(gpxLayer, 0.9f);

		// 1. route layer
		routeLayer = new RouteLayer(routingHelper);
		mapView.addLayer(routeLayer, 1);

		// 2. osm bugs layer
		// 3. poi layer
		poiMapLayer = new POIMapLayer(activity);
		mapView.addLayer(poiMapLayer, 3);
		// 4. favorites layer
		favoritesLayer = new FavoritesLayer();
		mapView.addLayer(favoritesLayer, 4);
		// 5. transport layer
		transportStopsLayer = new TransportStopsLayer();
		// 5.5 transport info layer 
		transportInfoLayer = new TransportInfoLayer(TransportRouteHelper.getInstance());
		mapView.addLayer(transportInfoLayer, 5.5f);
		// 5.95 all text labels
		// 6. point location layer 
		locationLayer = new PointLocationLayer(activity.getMapViewTrackingUtilities());
		mapView.addLayer(locationLayer, 6);
		// 7. point navigation layer
		navigationLayer = new PointNavigationLayer(activity);
		mapView.addLayer(navigationLayer, 7);
		// 7.5 Impassible roads
		impassableRoadsLayer = new ImpassableRoadsLayer(activity);
		mapView.addLayer(impassableRoadsLayer, 7.5f);
		// 8. context menu layer 
		contextMenuLayer = new ContextMenuLayer(activity);
		mapView.addLayer(contextMenuLayer, 8);
		// 9. map info layer
		mapInfoLayer = new MapInfoLayer(activity, routeLayer);
		mapView.addLayer(mapInfoLayer, 9);
		// 11. route info layer
		mapControlsLayer = new MapControlsLayer(activity);
		mapView.addLayer(mapControlsLayer, 11);

		transparencyListener = new StateChangedListener<Integer>() {
			@Override
			public void stateChanged(Integer change) {
				mapTileLayer.setAlpha(change);
				mapVectorLayer.setAlpha(change);
				mapView.refreshMap();
			}
		};
		app.getSettings().MAP_TRANSPARENCY.addListener(transparencyListener);

		OsmandPlugin.createLayers(mapView, activity);
		app.getAppCustomization().createLayers(mapView, activity);
	}


	public void updateLayers(OsmandMapTileView mapView) {
		OsmandSettings settings = getApplication().getSettings();
		updateMapSource(mapView, settings.MAP_TILE_SOURCES);
		boolean showStops = settings.getCustomRenderBooleanProperty(OsmandSettings.TRANSPORT_STOPS_OVER_MAP).get();
		if (mapView.getLayers().contains(transportStopsLayer) != showStops) {
			if (showStops) {
				mapView.addLayer(transportStopsLayer, 5);
			} else {
				mapView.removeLayer(transportStopsLayer);
			}
		}
		OsmandPlugin.refreshLayers(mapView, activity);
	}

	public void updateMapSource(OsmandMapTileView mapView, CommonPreference<String> settingsToWarnAboutMap) {
		OsmandSettings settings = getApplication().getSettings();

		// update transparency
		int mapTransparency = settings.MAP_UNDERLAY.get() == null ? 255 : settings.MAP_TRANSPARENCY.get();
		mapTileLayer.setAlpha(mapTransparency);
		mapVectorLayer.setAlpha(mapTransparency);

		ITileSource newSource = settings.getMapTileSource(settings.MAP_TILE_SOURCES == settingsToWarnAboutMap);
		ITileSource oldMap = mapTileLayer.getMap();
		if (newSource != oldMap) {
			if (oldMap instanceof SQLiteTileSource) {
				((SQLiteTileSource) oldMap).closeDB();
			}
			mapTileLayer.setMap(newSource);
		}

		boolean vectorData = !settings.MAP_ONLINE_DATA.get();
		mapTileLayer.setVisible(!vectorData);
		mapVectorLayer.setVisible(vectorData);
		if (vectorData) {
			mapView.setMainLayer(mapVectorLayer);
		} else {
			mapView.setMainLayer(mapTileLayer);
		}
	}


	public AlertDialog showGPXFileLayer(List<String> files, final OsmandMapTileView mapView) {
		final OsmandSettings settings = getApplication().getSettings();
		CallbackWithObject<GPXFile[]> callbackWithObject = new CallbackWithObject<GPXFile[]>() {
			@Override
			public boolean processResult(GPXFile[] result) {
				WptPt locToShow = null;
				for (GPXFile g : result) {
					if (g.showCurrentTrack) {
						if (!settings.SAVE_TRACK_TO_GPX.get() && !
								settings.SAVE_GLOBAL_TRACK_TO_GPX.get()) {
							AccessibleToast.makeText(activity,
									R.string.gpx_monitoring_disabled_warn, Toast.LENGTH_LONG).show();
						} else {
							g.path = getString(R.string.show_current_gpx_title);
						}
						break;
					}
					if (!g.showCurrentTrack || locToShow == null) {
						locToShow = g.findPointToShow();
					}
				}
				getApplication().getSelectedGpxHelper().setGpxFileToDisplay(result);
				if (locToShow != null) {
					mapView.getAnimatedDraggingThread().startMoving(locToShow.lat, locToShow.lon,
							mapView.getZoom(), true);
				}
				mapView.refreshMap();
				activity.getDashboard().refreshContent(true);
				return true;
			}
		};

		if (files == null) {
			return GpxUiHelper.selectGPXFile(activity, true, true, callbackWithObject);
		} else {
			return GpxUiHelper.selectGPXFile(files, activity, true, true, callbackWithObject);
		}
	}


	public AlertDialog selectPOIFilterLayer(final OsmandMapTileView mapView, final PoiUIFilter[] selected) {
		OsmandApplication app = (OsmandApplication) getApplication();
		final PoiFiltersHelper poiFilters = app.getPoiFilters();
		final ContextMenuAdapter adapter = new ContextMenuAdapter(activity);
		adapter.item(R.string.shared_string_search).iconColor(R.drawable.ic_action_search_dark).reg();
		final List<PoiUIFilter> list = new ArrayList<PoiUIFilter>();
		list.add(poiFilters.getCustomPOIFilter());
		for (PoiUIFilter f : poiFilters.getTopDefinedPoiFilters()) {
			addFilterToList(adapter, list, f);
		}

		AlertDialog.Builder builder = new AlertDialog.Builder(activity);
		ListAdapter listAdapter = adapter.createListAdapter(activity, app.getSettings().isLightContent());
		builder.setAdapter(listAdapter, new DialogInterface.OnClickListener() {
			@Override
			public void onClick(DialogInterface dialog, int which) {
				PoiUIFilter pf = list.get(which);
				String filterId = pf.getFilterId();
				if (filterId.equals(PoiUIFilter.CUSTOM_FILTER_ID)) {
					Intent search = new Intent(activity, SearchActivity.class);
					search.setFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);
					activity.getMyApplication().getSettings().SEARCH_TAB.set(SearchActivity.POI_TAB_INDEX);
					activity.startActivity(search);
				} else {
					pf = poiFilters.getFilterById(filterId);
					if (pf != null) {
						pf.setFilterByName(pf.getSavedFilterByName());
					}
					getApplication().getSettings().SELECTED_POI_FILTER_FOR_MAP.set(filterId);
					mapView.refreshMap();
					if (selected != null && selected.length > 0) {
						selected[0] = pf;
					}
				}
			}

		});
		builder.setNegativeButton(R.string.shared_string_cancel, null);
		return builder.show();
	}

	private void addFilterToList(final ContextMenuAdapter adapter, final List<PoiUIFilter> list, PoiUIFilter f) {
		list.add(f);
		Item it = adapter.item(f.getName()).selected(-1);
		if (RenderingIcons.containsBigIcon(f.getIconId())) {
			it.icon(RenderingIcons.getBigIconResourceId(f.getIconId()));
		} else {
			it.icon(R.drawable.mx_user_defined);
		}
		it.reg();
	}

	public void selectMapLayer(final OsmandMapTileView mapView) {
		if (OsmandPlugin.getEnabledPlugin(OsmandRasterMapsPlugin.class) == null) {
			AccessibleToast.makeText(activity, R.string.map_online_plugin_is_not_installed, Toast.LENGTH_LONG).show();
			return;
		}
		final OsmandSettings settings = getApplication().getSettings();

		final LinkedHashMap<String, String> entriesMap = new LinkedHashMap<String, String>();


		final String layerOsmVector = "LAYER_OSM_VECTOR";
		final String layerInstallMore = "LAYER_INSTALL_MORE";
		final String layerEditInstall = "LAYER_EDIT";

		entriesMap.put(layerOsmVector, getString(R.string.vector_data));
		entriesMap.putAll(settings.getTileSourceEntries());
		entriesMap.put(layerInstallMore, getString(R.string.install_more));
		entriesMap.put(layerEditInstall, getString(R.string.maps_define_edit));

		final List<Entry<String, String>> entriesMapList = new ArrayList<Entry<String, String>>(entriesMap.entrySet());

		AlertDialog.Builder builder = new AlertDialog.Builder(activity);

		String selectedTileSourceKey = settings.MAP_TILE_SOURCES.get();

		int selectedItem = -1;
		if (!settings.MAP_ONLINE_DATA.get()) {
			selectedItem = 0;
		} else {

			Entry<String, String> selectedEntry = null;
			for (Entry<String, String> entry : entriesMap.entrySet()) {
				if (entry.getKey().equals(selectedTileSourceKey)) {
					selectedEntry = entry;
					break;
				}
			}
			if (selectedEntry != null) {
				selectedItem = 0;
				entriesMapList.remove(selectedEntry);
				entriesMapList.add(0, selectedEntry);
			}
		}

		final String[] items = new String[entriesMapList.size()];
		int i = 0;
		for (Entry<String, String> entry : entriesMapList) {
			items[i++] = entry.getValue();
		}

		builder.setSingleChoiceItems(items, selectedItem, new DialogInterface.OnClickListener() {
			@Override
			public void onClick(DialogInterface dialog, int which) {
				String layerKey = entriesMapList.get(which).getKey();
				if (layerKey.equals(layerOsmVector)) {
					settings.MAP_ONLINE_DATA.set(false);
					updateMapSource(mapView, null);
				} else if (layerKey.equals(layerEditInstall)) {
					OsmandRasterMapsPlugin.defineNewEditLayer(activity, new ResultMatcher<TileSourceTemplate>() {

						@Override
						public boolean publish(TileSourceTemplate object) {
							settings.MAP_TILE_SOURCES.set(object.getName());
							settings.MAP_ONLINE_DATA.set(true);
							updateMapSource(mapView, settings.MAP_TILE_SOURCES);
							return true;
						}

						@Override
						public boolean isCancelled() {
							return false;
						}

					});
				} else if (layerKey.equals(layerInstallMore)) {
					OsmandRasterMapsPlugin.installMapLayers(activity, new ResultMatcher<TileSourceTemplate>() {
						TileSourceTemplate template = null;
						int count = 0;

						@Override
						public boolean publish(TileSourceTemplate object) {
							if (object == null) {
								if (count == 1) {
									settings.MAP_TILE_SOURCES.set(template.getName());
									settings.MAP_ONLINE_DATA.set(true);
									updateMapSource(mapView, settings.MAP_TILE_SOURCES);
								} else {
									selectMapLayer(mapView);
								}
							} else {
								count++;
								template = object;
							}
							return false;
						}

						@Override
						public boolean isCancelled() {
							return false;
						}
					});
				} else {
					settings.MAP_TILE_SOURCES.set(layerKey);
					settings.MAP_ONLINE_DATA.set(true);
					updateMapSource(mapView, settings.MAP_TILE_SOURCES);
				}

				dialog.dismiss();
			}

		});
		builder.show();
	}


	private String getString(int resId) {
		return activity.getString(resId);
	}

	public PointNavigationLayer getNavigationLayer() {
		return navigationLayer;
	}

	public ImpassableRoadsLayer getImpassableRoadsLayer() {
		return impassableRoadsLayer;
	}

	public GPXLayer getGpxLayer() {
		return gpxLayer;
	}

	public ContextMenuLayer getContextMenuLayer() {
		return contextMenuLayer;
	}

	public FavoritesLayer getFavoritesLayer() {
		return favoritesLayer;
	}

	public MapTextLayer getMapTextLayer() {
		return mapTextLayer;
	}

	public PointLocationLayer getLocationLayer() {
		return locationLayer;
	}

	public MapInfoLayer getMapInfoLayer() {
		return mapInfoLayer;
	}

	public MapControlsLayer getMapControlsLayer() {
		return mapControlsLayer;
	}


	public MapTileLayer getMapTileLayer() {
		return mapTileLayer;
	}

	public MapVectorLayer getMapVectorLayer() {
		return mapVectorLayer;
	}

	public POIMapLayer getPoiMapLayer() {
		return poiMapLayer;
	}

	public TransportInfoLayer getTransportInfoLayer() {
		return transportInfoLayer;
	}

	public DownloadedRegionsLayer getDownloadedRegionsLayer() {
		return downloadedRegionsLayer;
	}
}
!@#$%
20190530_041535,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_a04328
package net.osmand.plus.activities;


import android.content.DialogInterface;
import android.content.Intent;
import android.support.v7.app.AlertDialog;
import android.widget.ListAdapter;
import android.widget.Toast;

import net.osmand.CallbackWithObject;
import net.osmand.ResultMatcher;
import net.osmand.StateChangedListener;
import net.osmand.access.AccessibleToast;
import net.osmand.map.ITileSource;
import net.osmand.map.TileSourceManager.TileSourceTemplate;
import net.osmand.plus.ContextMenuAdapter;
import net.osmand.plus.ContextMenuAdapter.Item;
import net.osmand.plus.GPXUtilities.GPXFile;
import net.osmand.plus.GPXUtilities.WptPt;
import net.osmand.plus.OsmandApplication;
import net.osmand.plus.OsmandPlugin;
import net.osmand.plus.OsmandSettings;
import net.osmand.plus.OsmandSettings.CommonPreference;
import net.osmand.plus.R;
import net.osmand.plus.SQLiteTileSource;
import net.osmand.plus.activities.search.SearchActivity;
import net.osmand.plus.helpers.GpxUiHelper;
import net.osmand.plus.poi.PoiFiltersHelper;
import net.osmand.plus.poi.PoiUIFilter;
import net.osmand.plus.rastermaps.OsmandRasterMapsPlugin;
import net.osmand.plus.render.MapVectorLayer;
import net.osmand.plus.render.RenderingIcons;
import net.osmand.plus.routing.RoutingHelper;
import net.osmand.plus.views.ContextMenuLayer;
import net.osmand.plus.views.DownloadedRegionsLayer;
import net.osmand.plus.views.FavoritesLayer;
import net.osmand.plus.views.GPXLayer;
import net.osmand.plus.views.ImpassableRoadsLayer;
import net.osmand.plus.views.MapControlsLayer;
import net.osmand.plus.views.MapInfoLayer;
import net.osmand.plus.views.MapTextLayer;
import net.osmand.plus.views.MapTileLayer;
import net.osmand.plus.views.OsmandMapTileView;
import net.osmand.plus.views.POIMapLayer;
import net.osmand.plus.views.PointLocationLayer;
import net.osmand.plus.views.PointNavigationLayer;
import net.osmand.plus.views.RouteLayer;
import net.osmand.plus.views.TransportInfoLayer;
import net.osmand.plus.views.TransportStopsLayer;
import net.osmand.plus.views.mapwidgets.MapWidgetRegistry;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map.Entry;

/**
 * Object is responsible to maintain layers using by map activity 
 */
public class MapActivityLayers {

	private final MapActivity activity;
	
	// the order of layer should be preserved ! when you are inserting new layer
	private MapTileLayer mapTileLayer; 
	private MapVectorLayer mapVectorLayer;
	private GPXLayer gpxLayer;
	private RouteLayer routeLayer;
	private POIMapLayer poiMapLayer;
	private FavoritesLayer favoritesLayer;
	private TransportStopsLayer transportStopsLayer;
	private TransportInfoLayer transportInfoLayer;
	private PointLocationLayer locationLayer;
	private PointNavigationLayer navigationLayer;
	private ImpassableRoadsLayer impassableRoadsLayer;
	private MapInfoLayer mapInfoLayer;
	private MapTextLayer mapTextLayer;
	private ContextMenuLayer contextMenuLayer;
	private MapControlsLayer mapControlsLayer;
	private DownloadedRegionsLayer downloadedRegionsLayer;
	private MapWidgetRegistry mapWidgetRegistry;

	private StateChangedListener<Integer> transparencyListener;

	public MapActivityLayers(MapActivity activity) {
		this.activity = activity;
		this.mapWidgetRegistry = new MapWidgetRegistry(activity.getMyApplication().getSettings());
	}
	
	public MapWidgetRegistry getMapWidgetRegistry() {
		return mapWidgetRegistry;
	}

	public OsmandApplication getApplication(){
		return (OsmandApplication) activity.getApplication();
	}
	
	
	public void createLayers(final OsmandMapTileView mapView){
		
		OsmandApplication app = (OsmandApplication) getApplication();
		RoutingHelper routingHelper = app.getRoutingHelper();
		// first create to make accessible
		mapTextLayer = new MapTextLayer();
		// 5.95 all labels
		mapView.addLayer(mapTextLayer, 5.95f);
		// mapView.addLayer(underlayLayer, -0.5f);
		mapTileLayer = new MapTileLayer(true);
		mapView.addLayer(mapTileLayer, 0.0f);
		mapView.setMainLayer(mapTileLayer);
		
		// 0.5 layer
		mapVectorLayer = new MapVectorLayer(mapTileLayer, false);
		mapView.addLayer(mapVectorLayer, 0.5f);

		downloadedRegionsLayer = new DownloadedRegionsLayer();
		mapView.addLayer(downloadedRegionsLayer, 0.5f);

		// 0.9 gpx layer
		gpxLayer = new GPXLayer();
		mapView.addLayer(gpxLayer, 0.9f);
		
		// 1. route layer
		routeLayer = new RouteLayer(routingHelper);
		mapView.addLayer(routeLayer, 1);
		
		// 2. osm bugs layer
		// 3. poi layer
		poiMapLayer = new POIMapLayer(activity);
		mapView.addLayer(poiMapLayer, 3);
		// 4. favorites layer
		favoritesLayer = new FavoritesLayer();
		mapView.addLayer(favoritesLayer, 4);
		// 5. transport layer
		transportStopsLayer = new TransportStopsLayer();
		// 5.5 transport info layer 
		transportInfoLayer = new TransportInfoLayer(TransportRouteHelper.getInstance());
		mapView.addLayer(transportInfoLayer, 5.5f);
		// 5.95 all text labels
		// 6. point location layer 
		locationLayer = new PointLocationLayer(activity.getMapViewTrackingUtilities());
		mapView.addLayer(locationLayer, 6);
		// 7. point navigation layer
		navigationLayer = new PointNavigationLayer(activity);
		mapView.addLayer(navigationLayer, 7);
		// 7.5 Impassible roads
		impassableRoadsLayer = new ImpassableRoadsLayer(activity);
		mapView.addLayer(impassableRoadsLayer, 7.5f);
		// 8. context menu layer 
		contextMenuLayer = new ContextMenuLayer(activity);
		mapView.addLayer(contextMenuLayer, 8);
		// 9. map info layer
		mapInfoLayer = new MapInfoLayer(activity, routeLayer);
		mapView.addLayer(mapInfoLayer, 9);
		// 11. route info layer
		mapControlsLayer = new MapControlsLayer(activity);
		mapView.addLayer(mapControlsLayer, 11);
		
		transparencyListener = new StateChangedListener<Integer>() {
			@Override
			public void stateChanged(Integer change) {
				mapTileLayer.setAlpha(change);
				mapVectorLayer.setAlpha(change);
				mapView.refreshMap();
			}
		};
		app.getSettings().MAP_TRANSPARENCY.addListener(transparencyListener);
		
		OsmandPlugin.createLayers(mapView, activity);
		app.getAppCustomization().createLayers(mapView, activity);
	}

	
	public void updateLayers(OsmandMapTileView mapView){
		OsmandSettings settings = getApplication().getSettings();
		updateMapSource(mapView, settings.MAP_TILE_SOURCES);
		boolean showStops = settings.getCustomRenderBooleanProperty(OsmandSettings.TRANSPORT_STOPS_OVER_MAP).get();
		if(mapView.getLayers().contains(transportStopsLayer) != showStops){
			if(showStops){
				mapView.addLayer(transportStopsLayer, 5);
			} else {
				mapView.removeLayer(transportStopsLayer);
			}
		}
		OsmandPlugin.refreshLayers(mapView, activity);
	}
	
	public void updateMapSource(OsmandMapTileView mapView, CommonPreference<String> settingsToWarnAboutMap){
		OsmandSettings settings = getApplication().getSettings();
		
		// update transparency
		int mapTransparency = settings.MAP_UNDERLAY.get() == null ? 255 : settings.MAP_TRANSPARENCY.get();
		mapTileLayer.setAlpha(mapTransparency);
		mapVectorLayer.setAlpha(mapTransparency);
		
		ITileSource newSource = settings.getMapTileSource(settings.MAP_TILE_SOURCES == settingsToWarnAboutMap);
		ITileSource oldMap = mapTileLayer.getMap();
		if (newSource != oldMap) {
			if (oldMap instanceof SQLiteTileSource) {
				((SQLiteTileSource) oldMap).closeDB();
			}
			mapTileLayer.setMap(newSource);
		}
		
		boolean vectorData = !settings.MAP_ONLINE_DATA.get();
		mapTileLayer.setVisible(!vectorData);
		mapVectorLayer.setVisible(vectorData);
		if(vectorData){
			mapView.setMainLayer(mapVectorLayer);
		} else {
			mapView.setMainLayer(mapTileLayer);
		}
	}

	
	public AlertDialog showGPXFileLayer(List<String> files, final OsmandMapTileView mapView) {
		final OsmandSettings settings = getApplication().getSettings();
		CallbackWithObject<GPXFile[]> callbackWithObject = new CallbackWithObject<GPXFile[]>() {
			@Override
			public boolean processResult(GPXFile[] result) {
				WptPt locToShow = null;
				for (GPXFile g : result) {
					if (g.showCurrentTrack) {
						if (!settings.SAVE_TRACK_TO_GPX.get() && !
								settings.SAVE_GLOBAL_TRACK_TO_GPX.get()) {
							AccessibleToast.makeText(activity,
									R.string.gpx_monitoring_disabled_warn, Toast.LENGTH_LONG).show();
						} else {
							g.path = getString(R.string.show_current_gpx_title);
						}
						break;
					}
					if (!g.showCurrentTrack || locToShow == null) {
						locToShow = g.findPointToShow();
					}
				}
				getApplication().getSelectedGpxHelper().setGpxFileToDisplay(result);
				if (locToShow != null) {
					mapView.getAnimatedDraggingThread().startMoving(locToShow.lat, locToShow.lon,
							mapView.getZoom(), true);
				}
				mapView.refreshMap();
				activity.getDashboard().refreshContent(true);
				return true;
			}
		};

		if (files == null) {
			return GpxUiHelper.selectGPXFile(activity, true, true, callbackWithObject);
		} else {
			return GpxUiHelper.selectGPXFile(files, activity, true, true, callbackWithObject);
		}
	}


	public AlertDialog selectPOIFilterLayer(final OsmandMapTileView mapView, final PoiUIFilter[] selected){
		OsmandApplication app = (OsmandApplication) getApplication();
		final PoiFiltersHelper poiFilters = app.getPoiFilters();
		final ContextMenuAdapter adapter = new ContextMenuAdapter(activity);
		adapter.item(R.string.shared_string_search).iconColor(R.drawable.ic_action_search_dark).reg();
		final List<PoiUIFilter> list = new ArrayList<PoiUIFilter>();
		list.add(poiFilters.getCustomPOIFilter());
		for (PoiUIFilter f : poiFilters.getTopDefinedPoiFilters()) {
			addFilterToList(adapter, list, f);
		}
		
		AlertDialog.Builder builder = new AlertDialog.Builder(activity);
		ListAdapter listAdapter = adapter.createListAdapter(activity, app.getSettings().isLightContent());
		builder.setAdapter(listAdapter, new DialogInterface.OnClickListener(){
			@Override
			public void onClick(DialogInterface dialog, int which) {
				PoiUIFilter pf = list.get(which);
				String filterId = pf.getFilterId();
				if(filterId.equals(PoiUIFilter.CUSTOM_FILTER_ID)){
					Intent search = new Intent(activity, SearchActivity.class);
					search.setFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);
					activity.getMyApplication().getSettings().SEARCH_TAB.set(SearchActivity.POI_TAB_INDEX);
					activity.startActivity(search);
				} else {
					pf = poiFilters.getFilterById(filterId);
					if (pf != null) {
						pf.setFilterByName(pf.getSavedFilterByName());
					}
					getApplication().getSettings().SELECTED_POI_FILTER_FOR_MAP.set(filterId);
					mapView.refreshMap();
					if(selected != null && selected.length > 0) {
						selected[0] = pf;
					}
				}
			}
			
		});
		builder.setNegativeButton(R.string.shared_string_cancel, null);
		return builder.show();
	}

	private void addFilterToList(final ContextMenuAdapter adapter, final List<PoiUIFilter> list, PoiUIFilter f) {
		list.add(f);
		Item it = adapter.item(f.getName()).selected(-1);
		if (RenderingIcons.containsBigIcon(f.getIconId())) {
			it.icon(RenderingIcons.getBigIconResourceId(f.getIconId()));
		} else {
			it.icon(R.drawable.mx_user_defined);
		}
		it.reg();
	}

	public void selectMapLayer(final OsmandMapTileView mapView){
		if(OsmandPlugin.getEnabledPlugin(OsmandRasterMapsPlugin.class) == null) {
			AccessibleToast.makeText(activity, R.string.map_online_plugin_is_not_installed, Toast.LENGTH_LONG).show();
			return;
		}
		final OsmandSettings settings = getApplication().getSettings();
		
		final LinkedHashMap<String, String> entriesMap = new LinkedHashMap<String, String>();
		
		
		final String layerOsmVector = "LAYER_OSM_VECTOR";
		final String layerInstallMore = "LAYER_INSTALL_MORE";
		final String layerEditInstall = "LAYER_EDIT";
		
		entriesMap.put(layerOsmVector, getString(R.string.vector_data));
		entriesMap.putAll(settings.getTileSourceEntries());
		entriesMap.put(layerInstallMore, getString(R.string.install_more));
		entriesMap.put(layerEditInstall, getString(R.string.maps_define_edit));
		
		final List<Entry<String, String>> entriesMapList = new ArrayList<Entry<String, String>>(entriesMap.entrySet());
		
		AlertDialog.Builder builder = new AlertDialog.Builder(activity);
		
		String selectedTileSourceKey = settings.MAP_TILE_SOURCES.get();		

		int selectedItem = -1;
		if (!settings.MAP_ONLINE_DATA.get()) {
			selectedItem = 0;
		} else {
		
			Entry<String, String> selectedEntry = null;
			for (Entry<String, String> entry : entriesMap.entrySet()) {
				if (entry.getKey().equals(selectedTileSourceKey)) {
					selectedEntry = entry;
					break;
				}
			}
			if (selectedEntry != null) {
				selectedItem = 0;
				entriesMapList.remove(selectedEntry);
				entriesMapList.add(0, selectedEntry);
			}
		}
		
		final String[] items = new String[entriesMapList.size()];
		int i = 0;
		for (Entry<String, String> entry : entriesMapList) {
			items[i++] = entry.getValue();
		}
		
		builder.setSingleChoiceItems(items, selectedItem, new DialogInterface.OnClickListener(){
			@Override
			public void onClick(DialogInterface dialog, int which) {
				String layerKey = entriesMapList.get(which).getKey();
				if (layerKey.equals(layerOsmVector)) {
					settings.MAP_ONLINE_DATA.set(false);
					updateMapSource(mapView, null);
				} else if (layerKey.equals(layerEditInstall)) {
					OsmandRasterMapsPlugin.defineNewEditLayer(activity, new ResultMatcher<TileSourceTemplate>() {

						@Override
						public boolean publish(TileSourceTemplate object) {
							settings.MAP_TILE_SOURCES.set(object.getName());
							settings.MAP_ONLINE_DATA.set(true);
							updateMapSource(mapView, settings.MAP_TILE_SOURCES);
							return true;
						}

						@Override
						public boolean isCancelled() {
							return false;
						}
						
					});
				} else if (layerKey.equals(layerInstallMore)) {
					OsmandRasterMapsPlugin.installMapLayers(activity, new ResultMatcher<TileSourceTemplate>() {
						TileSourceTemplate template = null;
						int count = 0;
						@Override
						public boolean publish(TileSourceTemplate object) {
							if(object == null){
								if(count == 1){
									settings.MAP_TILE_SOURCES.set(template.getName());
									settings.MAP_ONLINE_DATA.set(true);
									updateMapSource(mapView, settings.MAP_TILE_SOURCES);
								} else {
									selectMapLayer(mapView);
								}
							} else {
								count ++;
								template = object;
							}
							return false;
						}
						
						@Override
						public boolean isCancelled() {
							return false;
						}
					});
				} else {
					settings.MAP_TILE_SOURCES.set(layerKey);
					settings.MAP_ONLINE_DATA.set(true);
					updateMapSource(mapView, settings.MAP_TILE_SOURCES);
				}

				dialog.dismiss();
			}
			
		});
		builder.show();
	}

	
	private String getString(int resId) {
		return activity.getString(resId);
	}

	public PointNavigationLayer getNavigationLayer() {
		return navigationLayer;
	}

	public ImpassableRoadsLayer getImpassableRoadsLayer() {
		return impassableRoadsLayer;
	}

	public GPXLayer getGpxLayer() {
		return gpxLayer;
	}
	
	public ContextMenuLayer getContextMenuLayer() {
		return contextMenuLayer;
	}
	
	public FavoritesLayer getFavoritesLayer() {
		return favoritesLayer;
	}
	
	public MapTextLayer getMapTextLayer() {
		return mapTextLayer;
	}
	
	public PointLocationLayer getLocationLayer() {
		return locationLayer;
	}
	
	public MapInfoLayer getMapInfoLayer() {
		return mapInfoLayer;
	}
	
	public MapControlsLayer getMapControlsLayer() {
		return mapControlsLayer;
	}
	
	
	public MapTileLayer getMapTileLayer() {
		return mapTileLayer;
	}
	
	public MapVectorLayer getMapVectorLayer() {
		return mapVectorLayer;
	}
	
	public POIMapLayer getPoiMapLayer() {
		return poiMapLayer;
	}
	
	public TransportInfoLayer getTransportInfoLayer() {
		return transportInfoLayer;
	}

	public DownloadedRegionsLayer getDownloadedRegionsLayer() {
		return downloadedRegionsLayer;
	}
}
!@#$%
20190530_041535,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_c04328
package net.osmand.plus.activities;


import android.content.DialogInterface;
import android.content.Intent;
import android.support.v7.app.AlertDialog;
import android.widget.ListAdapter;
import android.widget.Toast;

import net.osmand.CallbackWithObject;
import net.osmand.ResultMatcher;
import net.osmand.StateChangedListener;
import net.osmand.access.AccessibleToast;
import net.osmand.map.ITileSource;
import net.osmand.map.TileSourceManager.TileSourceTemplate;
import net.osmand.plus.ContextMenuAdapter;
import net.osmand.plus.ContextMenuAdapter.Item;
import net.osmand.plus.GPXUtilities.GPXFile;
import net.osmand.plus.GPXUtilities.WptPt;
import net.osmand.plus.OsmandApplication;
import net.osmand.plus.OsmandPlugin;
import net.osmand.plus.OsmandSettings;
import net.osmand.plus.OsmandSettings.CommonPreference;
import net.osmand.plus.R;
import net.osmand.plus.SQLiteTileSource;
import net.osmand.plus.activities.search.SearchActivity;
import net.osmand.plus.helpers.GpxUiHelper;
import net.osmand.plus.poi.PoiFiltersHelper;
import net.osmand.plus.poi.PoiUIFilter;
import net.osmand.plus.rastermaps.OsmandRasterMapsPlugin;
import net.osmand.plus.render.MapVectorLayer;
import net.osmand.plus.render.RenderingIcons;
import net.osmand.plus.routing.RoutingHelper;
import net.osmand.plus.views.ContextMenuLayer;
import net.osmand.plus.views.DownloadedRegionsLayer;
import net.osmand.plus.views.FavoritesLayer;
import net.osmand.plus.views.GPXLayer;
import net.osmand.plus.views.ImpassableRoadsLayer;
import net.osmand.plus.views.MapControlsLayer;
import net.osmand.plus.views.MapInfoLayer;
import net.osmand.plus.views.MapMarkersLayer;
import net.osmand.plus.views.MapTextLayer;
import net.osmand.plus.views.MapTileLayer;
import net.osmand.plus.views.OsmandMapTileView;
import net.osmand.plus.views.POIMapLayer;
import net.osmand.plus.views.PointLocationLayer;
import net.osmand.plus.views.PointNavigationLayer;
import net.osmand.plus.views.RouteLayer;
import net.osmand.plus.views.TransportInfoLayer;
import net.osmand.plus.views.TransportStopsLayer;
import net.osmand.plus.views.mapwidgets.MapWidgetRegistry;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map.Entry;

/**
 * Object is responsible to maintain layers using by map activity 
 */
public class MapActivityLayers {

	private final MapActivity activity;
	
	// the order of layer should be preserved ! when you are inserting new layer
	private MapTileLayer mapTileLayer; 
	private MapVectorLayer mapVectorLayer;
	private GPXLayer gpxLayer;
	private RouteLayer routeLayer;
	private POIMapLayer poiMapLayer;
	private FavoritesLayer favoritesLayer;
	private TransportStopsLayer transportStopsLayer;
	private TransportInfoLayer transportInfoLayer;
	private PointLocationLayer locationLayer;
	private PointNavigationLayer navigationLayer;
	private MapMarkersLayer mapMarkersLayer;
	private ImpassableRoadsLayer impassableRoadsLayer;
	private MapInfoLayer mapInfoLayer;
	private MapTextLayer mapTextLayer;
	private ContextMenuLayer contextMenuLayer;
	private MapControlsLayer mapControlsLayer;
	private DownloadedRegionsLayer downloadedRegionsLayer;
	private MapWidgetRegistry mapWidgetRegistry;

	private StateChangedListener<Integer> transparencyListener;

	public MapActivityLayers(MapActivity activity) {
		this.activity = activity;
		this.mapWidgetRegistry = new MapWidgetRegistry(activity.getMyApplication().getSettings());
	}
	
	public MapWidgetRegistry getMapWidgetRegistry() {
		return mapWidgetRegistry;
	}

	public OsmandApplication getApplication(){
		return (OsmandApplication) activity.getApplication();
	}
	
	
	public void createLayers(final OsmandMapTileView mapView){
		
		OsmandApplication app = (OsmandApplication) getApplication();
		RoutingHelper routingHelper = app.getRoutingHelper();
		// first create to make accessible
		mapTextLayer = new MapTextLayer();
		// 5.95 all labels
		mapView.addLayer(mapTextLayer, 5.95f);
		// mapView.addLayer(underlayLayer, -0.5f);
		mapTileLayer = new MapTileLayer(true);
		mapView.addLayer(mapTileLayer, 0.0f);
		mapView.setMainLayer(mapTileLayer);
		
		// 0.5 layer
		mapVectorLayer = new MapVectorLayer(mapTileLayer, false);
		mapView.addLayer(mapVectorLayer, 0.5f);

		downloadedRegionsLayer = new DownloadedRegionsLayer();
		mapView.addLayer(downloadedRegionsLayer, 0.5f);

		// 0.9 gpx layer
		gpxLayer = new GPXLayer();
		mapView.addLayer(gpxLayer, 0.9f);
		
		// 1. route layer
		routeLayer = new RouteLayer(routingHelper);
		mapView.addLayer(routeLayer, 1);
		
		// 2. osm bugs layer
		// 3. poi layer
		poiMapLayer = new POIMapLayer(activity);
		mapView.addLayer(poiMapLayer, 3);
		// 4. favorites layer
		favoritesLayer = new FavoritesLayer();
		mapView.addLayer(favoritesLayer, 4);
		// 5. transport layer
		transportStopsLayer = new TransportStopsLayer();
		// 5.5 transport info layer 
		transportInfoLayer = new TransportInfoLayer(TransportRouteHelper.getInstance());
		mapView.addLayer(transportInfoLayer, 5.5f);
		// 5.95 all text labels
		// 6. point location layer 
		locationLayer = new PointLocationLayer(activity.getMapViewTrackingUtilities());
		mapView.addLayer(locationLayer, 6);
		// 7. point navigation layer
		navigationLayer = new PointNavigationLayer(activity);
		mapView.addLayer(navigationLayer, 7);
		// 7.3 map markers layer
		if (app.getSettings().USE_MAP_MARKERS.get()) {
			mapMarkersLayer = new MapMarkersLayer(activity);
			mapView.addLayer(mapMarkersLayer, 7.3f);
		}
		// 7.5 Impassible roads
		impassableRoadsLayer = new ImpassableRoadsLayer(activity);
		mapView.addLayer(impassableRoadsLayer, 7.5f);
		// 8. context menu layer 
		contextMenuLayer = new ContextMenuLayer(activity);
		mapView.addLayer(contextMenuLayer, 8);
		// 9. map info layer
		mapInfoLayer = new MapInfoLayer(activity, routeLayer);
		mapView.addLayer(mapInfoLayer, 9);
		// 11. route info layer
		mapControlsLayer = new MapControlsLayer(activity);
		mapView.addLayer(mapControlsLayer, 11);
		
		transparencyListener = new StateChangedListener<Integer>() {
			@Override
			public void stateChanged(Integer change) {
				mapTileLayer.setAlpha(change);
				mapVectorLayer.setAlpha(change);
				mapView.refreshMap();
			}
		};
		app.getSettings().MAP_TRANSPARENCY.addListener(transparencyListener);
		
		OsmandPlugin.createLayers(mapView, activity);
		app.getAppCustomization().createLayers(mapView, activity);
	}

	
	public void updateLayers(OsmandMapTileView mapView){
		OsmandSettings settings = getApplication().getSettings();
		updateMapSource(mapView, settings.MAP_TILE_SOURCES);
		boolean showStops = settings.getCustomRenderBooleanProperty(OsmandSettings.TRANSPORT_STOPS_OVER_MAP).get();
		if(mapView.getLayers().contains(transportStopsLayer) != showStops){
			if(showStops){
				mapView.addLayer(transportStopsLayer, 5);
			} else {
				mapView.removeLayer(transportStopsLayer);
			}
		}
		OsmandPlugin.refreshLayers(mapView, activity);
	}
	
	public void updateMapSource(OsmandMapTileView mapView, CommonPreference<String> settingsToWarnAboutMap){
		OsmandSettings settings = getApplication().getSettings();
		
		// update transparency
		int mapTransparency = settings.MAP_UNDERLAY.get() == null ? 255 : settings.MAP_TRANSPARENCY.get();
		mapTileLayer.setAlpha(mapTransparency);
		mapVectorLayer.setAlpha(mapTransparency);
		
		ITileSource newSource = settings.getMapTileSource(settings.MAP_TILE_SOURCES == settingsToWarnAboutMap);
		ITileSource oldMap = mapTileLayer.getMap();
		if (newSource != oldMap) {
			if (oldMap instanceof SQLiteTileSource) {
				((SQLiteTileSource) oldMap).closeDB();
			}
			mapTileLayer.setMap(newSource);
		}
		
		boolean vectorData = !settings.MAP_ONLINE_DATA.get();
		mapTileLayer.setVisible(!vectorData);
		mapVectorLayer.setVisible(vectorData);
		if(vectorData){
			mapView.setMainLayer(mapVectorLayer);
		} else {
			mapView.setMainLayer(mapTileLayer);
		}
	}

	
	public AlertDialog showGPXFileLayer(List<String> files, final OsmandMapTileView mapView) {
		final OsmandSettings settings = getApplication().getSettings();
		CallbackWithObject<GPXFile[]> callbackWithObject = new CallbackWithObject<GPXFile[]>() {
			@Override
			public boolean processResult(GPXFile[] result) {
				WptPt locToShow = null;
				for (GPXFile g : result) {
					if (g.showCurrentTrack) {
						if (!settings.SAVE_TRACK_TO_GPX.get() && !
								settings.SAVE_GLOBAL_TRACK_TO_GPX.get()) {
							AccessibleToast.makeText(activity,
									R.string.gpx_monitoring_disabled_warn, Toast.LENGTH_LONG).show();
						} else {
							g.path = getString(R.string.show_current_gpx_title);
						}
						break;
					}
					if (!g.showCurrentTrack || locToShow == null) {
						locToShow = g.findPointToShow();
					}
				}
				getApplication().getSelectedGpxHelper().setGpxFileToDisplay(result);
				if (locToShow != null) {
					mapView.getAnimatedDraggingThread().startMoving(locToShow.lat, locToShow.lon,
							mapView.getZoom(), true);
				}
				mapView.refreshMap();
				activity.getDashboard().refreshContent(true);
				return true;
			}
		};

		if (files == null) {
			return GpxUiHelper.selectGPXFile(activity, true, true, callbackWithObject);
		} else {
			return GpxUiHelper.selectGPXFile(files, activity, true, true, callbackWithObject);
		}
	}


	public AlertDialog selectPOIFilterLayer(final OsmandMapTileView mapView, final PoiUIFilter[] selected){
		OsmandApplication app = (OsmandApplication) getApplication();
		final PoiFiltersHelper poiFilters = app.getPoiFilters();
		final ContextMenuAdapter adapter = new ContextMenuAdapter(activity);
		adapter.item(R.string.shared_string_search).iconColor(R.drawable.ic_action_search_dark).reg();
		final List<PoiUIFilter> list = new ArrayList<PoiUIFilter>();
		list.add(poiFilters.getCustomPOIFilter());
		for (PoiUIFilter f : poiFilters.getTopDefinedPoiFilters()) {
			addFilterToList(adapter, list, f);
		}
		
		AlertDialog.Builder builder = new AlertDialog.Builder(activity);
		ListAdapter listAdapter = adapter.createListAdapter(activity, app.getSettings().isLightContent());
		builder.setAdapter(listAdapter, new DialogInterface.OnClickListener(){
			@Override
			public void onClick(DialogInterface dialog, int which) {
				PoiUIFilter pf = list.get(which);
				String filterId = pf.getFilterId();
				if(filterId.equals(PoiUIFilter.CUSTOM_FILTER_ID)){
					Intent search = new Intent(activity, SearchActivity.class);
					search.setFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);
					activity.getMyApplication().getSettings().SEARCH_TAB.set(SearchActivity.POI_TAB_INDEX);
					activity.startActivity(search);
				} else {
					pf = poiFilters.getFilterById(filterId);
					if (pf != null) {
						pf.setFilterByName(pf.getSavedFilterByName());
					}
					getApplication().getSettings().SELECTED_POI_FILTER_FOR_MAP.set(filterId);
					mapView.refreshMap();
					if(selected != null && selected.length > 0) {
						selected[0] = pf;
					}
				}
			}
			
		});
		builder.setNegativeButton(R.string.shared_string_cancel, null);
		return builder.show();
	}

	private void addFilterToList(final ContextMenuAdapter adapter, final List<PoiUIFilter> list, PoiUIFilter f) {
		list.add(f);
		Item it = adapter.item(f.getName()).selected(-1);
		if (RenderingIcons.containsBigIcon(f.getIconId())) {
			it.icon(RenderingIcons.getBigIconResourceId(f.getIconId()));
		} else {
			it.icon(R.drawable.mx_user_defined);
		}
		it.reg();
	}

	public void selectMapLayer(final OsmandMapTileView mapView){
		if(OsmandPlugin.getEnabledPlugin(OsmandRasterMapsPlugin.class) == null) {
			AccessibleToast.makeText(activity, R.string.map_online_plugin_is_not_installed, Toast.LENGTH_LONG).show();
			return;
		}
		final OsmandSettings settings = getApplication().getSettings();
		
		final LinkedHashMap<String, String> entriesMap = new LinkedHashMap<String, String>();
		
		
		final String layerOsmVector = "LAYER_OSM_VECTOR";
		final String layerInstallMore = "LAYER_INSTALL_MORE";
		final String layerEditInstall = "LAYER_EDIT";
		
		entriesMap.put(layerOsmVector, getString(R.string.vector_data));
		entriesMap.putAll(settings.getTileSourceEntries());
		entriesMap.put(layerInstallMore, getString(R.string.install_more));
		entriesMap.put(layerEditInstall, getString(R.string.maps_define_edit));
		
		final List<Entry<String, String>> entriesMapList = new ArrayList<Entry<String, String>>(entriesMap.entrySet());
		
		AlertDialog.Builder builder = new AlertDialog.Builder(activity);
		
		String selectedTileSourceKey = settings.MAP_TILE_SOURCES.get();		

		int selectedItem = -1;
		if (!settings.MAP_ONLINE_DATA.get()) {
			selectedItem = 0;
		} else {
		
			Entry<String, String> selectedEntry = null;
			for (Entry<String, String> entry : entriesMap.entrySet()) {
				if (entry.getKey().equals(selectedTileSourceKey)) {
					selectedEntry = entry;
					break;
				}
			}
			if (selectedEntry != null) {
				selectedItem = 0;
				entriesMapList.remove(selectedEntry);
				entriesMapList.add(0, selectedEntry);
			}
		}
		
		final String[] items = new String[entriesMapList.size()];
		int i = 0;
		for (Entry<String, String> entry : entriesMapList) {
			items[i++] = entry.getValue();
		}
		
		builder.setSingleChoiceItems(items, selectedItem, new DialogInterface.OnClickListener(){
			@Override
			public void onClick(DialogInterface dialog, int which) {
				String layerKey = entriesMapList.get(which).getKey();
				if (layerKey.equals(layerOsmVector)) {
					settings.MAP_ONLINE_DATA.set(false);
					updateMapSource(mapView, null);
				} else if (layerKey.equals(layerEditInstall)) {
					OsmandRasterMapsPlugin.defineNewEditLayer(activity, new ResultMatcher<TileSourceTemplate>() {

						@Override
						public boolean publish(TileSourceTemplate object) {
							settings.MAP_TILE_SOURCES.set(object.getName());
							settings.MAP_ONLINE_DATA.set(true);
							updateMapSource(mapView, settings.MAP_TILE_SOURCES);
							return true;
						}

						@Override
						public boolean isCancelled() {
							return false;
						}
						
					});
				} else if (layerKey.equals(layerInstallMore)) {
					OsmandRasterMapsPlugin.installMapLayers(activity, new ResultMatcher<TileSourceTemplate>() {
						TileSourceTemplate template = null;
						int count = 0;
						@Override
						public boolean publish(TileSourceTemplate object) {
							if(object == null){
								if(count == 1){
									settings.MAP_TILE_SOURCES.set(template.getName());
									settings.MAP_ONLINE_DATA.set(true);
									updateMapSource(mapView, settings.MAP_TILE_SOURCES);
								} else {
									selectMapLayer(mapView);
								}
							} else {
								count ++;
								template = object;
							}
							return false;
						}
						
						@Override
						public boolean isCancelled() {
							return false;
						}
					});
				} else {
					settings.MAP_TILE_SOURCES.set(layerKey);
					settings.MAP_ONLINE_DATA.set(true);
					updateMapSource(mapView, settings.MAP_TILE_SOURCES);
				}

				dialog.dismiss();
			}
			
		});
		builder.show();
	}

	
	private String getString(int resId) {
		return activity.getString(resId);
	}

	public PointNavigationLayer getNavigationLayer() {
		return navigationLayer;
	}

	public ImpassableRoadsLayer getImpassableRoadsLayer() {
		return impassableRoadsLayer;
	}

	public GPXLayer getGpxLayer() {
		return gpxLayer;
	}
	
	public ContextMenuLayer getContextMenuLayer() {
		return contextMenuLayer;
	}
	
	public FavoritesLayer getFavoritesLayer() {
		return favoritesLayer;
	}
	
	public MapTextLayer getMapTextLayer() {
		return mapTextLayer;
	}
	
	public PointLocationLayer getLocationLayer() {
		return locationLayer;
	}
	
	public MapInfoLayer getMapInfoLayer() {
		return mapInfoLayer;
	}
	
	public MapControlsLayer getMapControlsLayer() {
		return mapControlsLayer;
	}

	public MapMarkersLayer getMapMarkersLayer() {
		return mapMarkersLayer;
	}

	public MapTileLayer getMapTileLayer() {
		return mapTileLayer;
	}
	
	public MapVectorLayer getMapVectorLayer() {
		return mapVectorLayer;
	}
	
	public POIMapLayer getPoiMapLayer() {
		return poiMapLayer;
	}
	
	public TransportInfoLayer getTransportInfoLayer() {
		return transportInfoLayer;
	}

	public DownloadedRegionsLayer getDownloadedRegionsLayer() {
		return downloadedRegionsLayer;
	}
}
!@#$%
20190530_045623,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_b08164
package net.osmand.plus.liveupdates;

import android.content.Intent;
import android.content.res.Resources;
import android.os.Bundle;
import android.support.design.widget.TabLayout;
import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentManager;
import android.support.v4.app.FragmentPagerAdapter;
import android.support.v4.view.ViewPager;
import android.view.MenuItem;

import net.osmand.PlatformUtil;
import net.osmand.plus.R;
import net.osmand.plus.Version;
import net.osmand.plus.download.AbstractDownloadActivity;
import net.osmand.plus.download.DownloadIndexesThread;
import net.osmand.plus.inapp.InAppHelper;

import org.apache.commons.logging.Log;

public class OsmLiveActivity extends AbstractDownloadActivity
		implements DownloadIndexesThread.DownloadEvents{
	private final static Log LOG = PlatformUtil.getLog(OsmLiveActivity.class);
	public final static String OPEN_SUBSCRIPTION_INTENT_PARAM = "open_subscription_intent_param";
	private LiveUpdatesFragmentPagerAdapter pagerAdapter;
	private InAppHelper inAppHelper;
	private boolean openSubscription;

	public InAppHelper getInAppHelper() {
		return inAppHelper;
	}

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		getMyApplication().applyTheme(this);
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_livie_updates);

		inAppHelper = new InAppHelper(getMyApplication(), false);
		if (Version.isDeveloperVersion(getMyApplication())) {
			inAppHelper = null;
		}

		Intent intent = getIntent();
		if (intent != null && intent.getExtras() != null) {
			openSubscription = intent.getExtras().getBoolean(OPEN_SUBSCRIPTION_INTENT_PARAM, false);
		}

		ViewPager viewPager = (ViewPager) findViewById(R.id.viewpager);
		pagerAdapter = new LiveUpdatesFragmentPagerAdapter(getSupportFragmentManager(), getResources());
		viewPager.setAdapter(pagerAdapter);

		final TabLayout tabLayout = (TabLayout) findViewById(R.id.tab_layout);
		tabLayout.setTabMode(TabLayout.MODE_SCROLLABLE);
		tabLayout.setupWithViewPager(viewPager);
	}

	@Override
	public boolean onOptionsItemSelected(MenuItem item) {
		switch (item.getItemId()) {
			// Respond to the action bar's Up/Home button
			case android.R.id.home:
				finish();
				return true;
		}
		return super.onOptionsItemSelected(item);
	}

	@Override
	protected void onActivityResult(int requestCode, int resultCode, Intent data) {
		// Pass on the activity result to the helper for handling
		if (inAppHelper == null || !inAppHelper.onActivityResultHandled(requestCode, resultCode, data)) {
			// not handled, so handle it ourselves (here's where you'd
			// perform any handling of activity results not related to in-app
			// billing...
			super.onActivityResult(requestCode, resultCode, data);
		}
	}

	@Override
	protected void onDestroy() {
		super.onDestroy();
		if (inAppHelper != null) {
			inAppHelper.stop();
		}
	}

	@Override
	public void newDownloadIndexes() {

	}

	@Override
	public void downloadInProgress() {

	}

	@Override
	public void downloadHasFinished() {
		((LiveUpdatesFragment) pagerAdapter.fragments[0]).notifyLiveUpdatesChanged();
	}

	public boolean shouldOpenSubscription() {
		return openSubscription;
	}

	public static class LiveUpdatesFragmentPagerAdapter extends FragmentPagerAdapter {
		private final Fragment[] fragments = new Fragment[]{new LiveUpdatesFragment(),
				new ReportsFragment()};
		private static final int[] titleIds = new int[]{LiveUpdatesFragment.TITLE,
				ReportsFragment.TITLE};
		private final String[] titles;

		public LiveUpdatesFragmentPagerAdapter(FragmentManager fm, Resources res) {
			super(fm);
			titles = new String[titleIds.length];
			for (int i = 0; i < titleIds.length; i++) {
				titles[i] = res.getString(titleIds[i]);
			}
		}

		@Override
		public int getCount() {
			return fragments.length;
		}

		@Override
		public Fragment getItem(int position) {
			return fragments[position];
		}

		@Override
		public CharSequence getPageTitle(int position) {
			return titles[position];
		}
	}
}
!@#$%
20190530_045623,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_a08164
package net.osmand.plus.liveupdates;

import android.content.Intent;
import android.content.res.Resources;
import android.os.Bundle;
import android.support.design.widget.TabLayout;
import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentManager;
import android.support.v4.app.FragmentPagerAdapter;
import android.support.v4.view.ViewPager;
import android.view.MenuItem;

import net.osmand.PlatformUtil;
import net.osmand.plus.R;
import net.osmand.plus.Version;
import net.osmand.plus.download.AbstractDownloadActivity;
import net.osmand.plus.download.DownloadIndexesThread;
import net.osmand.plus.inapp.InAppHelper;

import org.apache.commons.logging.Log;

public class OsmLiveActivity extends AbstractDownloadActivity
		implements DownloadIndexesThread.DownloadEvents{
	private final static Log LOG = PlatformUtil.getLog(OsmLiveActivity.class);
	private LiveUpdatesFragmentPagerAdapter pagerAdapter;
	private InAppHelper inAppHelper;

	public InAppHelper getInAppHelper() {
		return inAppHelper;
	}

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		getMyApplication().applyTheme(this);
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_livie_updates);

		inAppHelper = new InAppHelper(getMyApplication(), false);
		if (Version.isDeveloperVersion(getMyApplication())) {
			inAppHelper = null;
		}

		ViewPager viewPager = (ViewPager) findViewById(R.id.viewpager);
		pagerAdapter = new LiveUpdatesFragmentPagerAdapter(getSupportFragmentManager(), getResources());
		viewPager.setAdapter(pagerAdapter);

		final TabLayout tabLayout = (TabLayout) findViewById(R.id.tab_layout);
		tabLayout.setTabMode(TabLayout.MODE_SCROLLABLE);
		tabLayout.setupWithViewPager(viewPager);
	}

	@Override
	public boolean onOptionsItemSelected(MenuItem item) {
		switch (item.getItemId()) {
			// Respond to the action bar's Up/Home button
			case android.R.id.home:
				finish();
				return true;
		}
		return super.onOptionsItemSelected(item);
	}

	@Override
	protected void onActivityResult(int requestCode, int resultCode, Intent data) {
		// Pass on the activity result to the helper for handling
		if (inAppHelper == null || !inAppHelper.onActivityResultHandled(requestCode, resultCode, data)) {
			// not handled, so handle it ourselves (here's where you'd
			// perform any handling of activity results not related to in-app
			// billing...
			super.onActivityResult(requestCode, resultCode, data);
		}
	}

	@Override
	protected void onDestroy() {
		super.onDestroy();
		if (inAppHelper != null) {
			inAppHelper.stop();
		}
	}

	@Override
	public void newDownloadIndexes() {

	}

	@Override
	public void downloadInProgress() {

	}

	@Override
	public void downloadHasFinished() {
		((LiveUpdatesFragment) pagerAdapter.fragments[0]).notifyLiveUpdatesChanged();
	}

	public static class LiveUpdatesFragmentPagerAdapter extends FragmentPagerAdapter {
		private final Fragment[] fragments = new Fragment[]{new LiveUpdatesFragment(),
				new ReportsFragment()};
		private static final int[] titleIds = new int[]{LiveUpdatesFragment.TITLE,
				ReportsFragment.TITLE};
		private final String[] titles;

		public LiveUpdatesFragmentPagerAdapter(FragmentManager fm, Resources res) {
			super(fm);
			titles = new String[titleIds.length];
			for (int i = 0; i < titleIds.length; i++) {
				titles[i] = res.getString(titleIds[i]);
			}
		}

		@Override
		public int getCount() {
			return fragments.length;
		}

		@Override
		public Fragment getItem(int position) {
			return fragments[position];
		}

		@Override
		public CharSequence getPageTitle(int position) {
			return titles[position];
		}
	}
}
!@#$%
20190530_045623,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_c08164
package net.osmand.plus.liveupdates;

import android.content.Intent;
import android.content.res.Resources;
import android.os.Bundle;
import android.support.design.widget.TabLayout;
import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentManager;
import android.support.v4.app.FragmentPagerAdapter;
import android.support.v4.view.ViewPager;
import android.view.MenuItem;

import net.osmand.PlatformUtil;
import net.osmand.plus.R;
import net.osmand.plus.Version;
import net.osmand.plus.download.AbstractDownloadActivity;
import net.osmand.plus.download.DownloadIndexesThread;
import net.osmand.plus.inapp.InAppHelper;

import org.apache.commons.logging.Log;

public class OsmLiveActivity extends AbstractDownloadActivity implements DownloadIndexesThread.DownloadEvents {
	private final static Log LOG = PlatformUtil.getLog(OsmLiveActivity.class);
	private LiveUpdatesFragmentPagerAdapter pagerAdapter;
	private InAppHelper inAppHelper;

	public InAppHelper getInAppHelper() {
		return inAppHelper;
	}

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		getMyApplication().applyTheme(this);
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_livie_updates);

		inAppHelper = new InAppHelper(getMyApplication(), false);
		if (Version.isDeveloperVersion(getMyApplication())) {
			inAppHelper = null;
		}

		ViewPager viewPager = (ViewPager) findViewById(R.id.viewpager);
		pagerAdapter = new LiveUpdatesFragmentPagerAdapter(getSupportFragmentManager(), getResources());
		viewPager.setAdapter(pagerAdapter);

		final TabLayout tabLayout = (TabLayout) findViewById(R.id.tab_layout);
		tabLayout.setTabMode(TabLayout.MODE_SCROLLABLE);
		tabLayout.setupWithViewPager(viewPager);
	}

	@Override
	public boolean onOptionsItemSelected(MenuItem item) {
		switch (item.getItemId()) {
			// Respond to the action bar's Up/Home button
			case android.R.id.home:
				finish();
				return true;
		}
		return super.onOptionsItemSelected(item);
	}

	@Override
	protected void onActivityResult(int requestCode, int resultCode, Intent data) {
		// Pass on the activity result to the helper for handling
		if (inAppHelper == null || !inAppHelper.onActivityResultHandled(requestCode, resultCode, data)) {
			// not handled, so handle it ourselves (here's where you'd
			// perform any handling of activity results not related to in-app
			// billing...
			super.onActivityResult(requestCode, resultCode, data);
		}
	}

	@Override
	protected void onDestroy() {
		super.onDestroy();
		if (inAppHelper != null) {
			inAppHelper.stop();
		}
	}

	@Override
	public void newDownloadIndexes() {

	}

	@Override
	public void downloadInProgress() {

	}

	@Override
	public void downloadHasFinished() {
		((LiveUpdatesFragment) pagerAdapter.fragments[0]).notifyLiveUpdatesChanged();
	}

	public static class LiveUpdatesFragmentPagerAdapter extends FragmentPagerAdapter {
		private final Fragment[] fragments = new Fragment[]{new LiveUpdatesFragment(),
				new ReportsFragment()};
		private static final int[] titleIds = new int[]{LiveUpdatesFragment.TITLE,
				ReportsFragment.TITLE};
		private final String[] titles;

		public LiveUpdatesFragmentPagerAdapter(FragmentManager fm, Resources res) {
			super(fm);
			titles = new String[titleIds.length];
			for (int i = 0; i < titleIds.length; i++) {
				titles[i] = res.getString(titleIds[i]);
			}
		}

		@Override
		public int getCount() {
			return fragments.length;
		}

		@Override
		public Fragment getItem(int position) {
			return fragments[position];
		}

		@Override
		public CharSequence getPageTitle(int position) {
			return titles[position];
		}
	}
}
!@#$%
20190530_062613,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_b06248
package net.osmand.plus.osmedit;

import android.app.Activity;
import android.app.Dialog;
import android.app.ProgressDialog;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.res.Resources;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Build;
import android.os.Bundle;
import android.support.annotation.NonNull;
import android.support.design.widget.TabLayout;
import android.support.design.widget.TextInputLayout;
import android.support.v4.app.DialogFragment;
import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentManager;
import android.support.v4.app.FragmentPagerAdapter;
import android.support.v4.app.FragmentTransaction;
import android.support.v4.view.ViewCompat;
import android.support.v4.view.ViewPager;
import android.support.v7.app.AlertDialog;
import android.support.v7.app.AppCompatActivity;
import android.support.v7.widget.Toolbar;
import android.text.Editable;
import android.text.TextUtils;
import android.text.TextWatcher;
import android.util.TypedValue;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.view.ViewTreeObserver;
import android.view.WindowManager;
import android.view.inputmethod.EditorInfo;
import android.widget.AdapterView;
import android.widget.ArrayAdapter;
import android.widget.AutoCompleteTextView;
import android.widget.Button;
import android.widget.CheckBox;
import android.widget.EditText;
import android.widget.ImageButton;
import android.widget.LinearLayout;
import android.widget.TextView;
import android.widget.Toast;

import net.osmand.CallbackWithObject;
import net.osmand.PlatformUtil;
import net.osmand.data.Amenity;
import net.osmand.data.LatLon;
import net.osmand.osm.PoiCategory;
import net.osmand.osm.PoiType;
import net.osmand.osm.edit.EntityInfo;
import net.osmand.osm.edit.Node;
import net.osmand.osm.edit.OSMSettings;
import net.osmand.plus.OsmandApplication;
import net.osmand.plus.OsmandPlugin;
import net.osmand.plus.OsmandSettings;
import net.osmand.plus.R;
import net.osmand.plus.activities.MapActivity;
import net.osmand.plus.base.BaseOsmAndDialogFragment;
import net.osmand.plus.osmedit.dialogs.PoiSubTypeDialogFragment;
import net.osmand.plus.osmedit.dialogs.PoiTypeDialogFragment;
import net.osmand.util.Algorithms;

import org.apache.commons.logging.Log;

import java.io.Serializable;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

public class EditPoiDialogFragment extends BaseOsmAndDialogFragment {
	public static final String TAG = "EditPoiDialogFragment";
	private static final Log LOG = PlatformUtil.getLog(EditPoiDialogFragment.class);

	private static final String KEY_AMENITY_NODE = "key_amenity_node";
	private static final String TAGS_LIST = "tags_list";
	private static final String IS_ADDING_POI = "is_adding_poi";

	public static final HashSet<String> BASIC_TAGS = new HashSet<String>() ;
	static {
		BASIC_TAGS.add(OSMSettings.OSMTagKey.NAME.getValue());
		BASIC_TAGS.add(OSMSettings.OSMTagKey.ADDR_STREET.getValue());
		BASIC_TAGS.add(OSMSettings.OSMTagKey.ADDR_HOUSE_NUMBER.getValue());
		BASIC_TAGS.add(OSMSettings.OSMTagKey.PHONE.getValue());
		BASIC_TAGS.add(OSMSettings.OSMTagKey.WEBSITE.getValue());
		BASIC_TAGS.add(OSMSettings.OSMTagKey.OPENING_HOURS.getValue());
	}

	private EditPoiData editPoiData;
	private ViewPager viewPager;
	private AutoCompleteTextView poiTypeEditText;

	private OpenstreetmapUtil mOpenstreetmapUtil;
	private TextInputLayout poiTypeTextInputLayout;
	private View view;

	@Override
	public void onAttach(Activity activity) {
		super.onAttach(activity);
		OsmEditingPlugin plugin = OsmandPlugin.getPlugin(OsmEditingPlugin.class);
		if (getSettings().OFFLINE_EDITION.get()
				|| !getSettings().isInternetConnectionAvailable(true)) {
			mOpenstreetmapUtil = plugin.getPoiModificationLocalUtil();
		} else {
			mOpenstreetmapUtil = plugin.getPoiModificationRemoteUtil();
		}

		Node node = (Node) getArguments().getSerializable(KEY_AMENITY_NODE);
		editPoiData = new EditPoiData(node, getMyApplication());
	}

	@Override
	public View onCreateView(LayoutInflater inflater, ViewGroup container,
							 Bundle savedInstanceState) {
		view = inflater.inflate(R.layout.fragment_edit_poi, container, false);
		boolean isLightTheme = getSettings().OSMAND_THEME.get() == OsmandSettings.OSMAND_LIGHT_THEME;

		if (savedInstanceState != null) {
			@SuppressWarnings("unchecked")
			Map<String, String> mp = (Map<String, String>) savedInstanceState.getSerializable(TAGS_LIST);
			editPoiData.updateTags(mp);
		}

		boolean isAddingPoi = getArguments().getBoolean(IS_ADDING_POI);

		Toolbar toolbar = (Toolbar) view.findViewById(R.id.toolbar);
		toolbar.setTitle(isAddingPoi ? R.string.poi_create_title : R.string.poi_edit_title);
		toolbar.setNavigationIcon(R.drawable.ic_arrow_back);
		toolbar.setNavigationContentDescription(R.string.access_shared_string_navigate_up);
		toolbar.setNavigationOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				dismissCheckForChanges();
			}
		});

		viewPager = (ViewPager) view.findViewById(R.id.viewpager);
		String basicTitle = getResources().getString(R.string.tab_title_basic);
		String extendedTitle = getResources().getString(R.string.tab_title_advanced);
		final MyAdapter pagerAdapter = new MyAdapter(getChildFragmentManager(), basicTitle, extendedTitle);
		viewPager.setAdapter(pagerAdapter);
		viewPager.addOnPageChangeListener(new ViewPager.OnPageChangeListener() {
			@Override
			public void onPageScrolled(int i, float v, int i1) {

			}

			@Override
			public void onPageSelected(int i) {
				((OnFragmentActivatedListener) pagerAdapter.getItem(i)).onFragmentActivated();
			}

			@Override
			public void onPageScrollStateChanged(int i) {

			}
		});

		final TabLayout tabLayout = (TabLayout) view.findViewById(R.id.tab_layout);
		tabLayout.setTabMode(TabLayout.MODE_SCROLLABLE);

		// tabLayout.setupWithViewPager(viewPager);
		// Hack due to bug in design support library v22.2.1
		// https://code.google.com/p/android/issues/detail?id=180462
		// TODO remove in new version
		if (Build.VERSION.SDK_INT >= 11) {
			if (ViewCompat.isLaidOut(tabLayout)) {
				tabLayout.setupWithViewPager(viewPager);
			} else {
				tabLayout.addOnLayoutChangeListener(new View.OnLayoutChangeListener() {
					@Override
					public void onLayoutChange(View v, int left, int top, int right, int bottom,
											   int oldLeft, int oldTop, int oldRight, int oldBottom) {
						tabLayout.setupWithViewPager(viewPager);
						tabLayout.removeOnLayoutChangeListener(this);
					}
				});
			}
		} else {
			ViewTreeObserver vto = view.getViewTreeObserver();
			vto.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {

				@Override
				public void onGlobalLayout() {

					ViewTreeObserver obs = view.getViewTreeObserver();
					if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
						obs.removeGlobalOnLayoutListener(this);
					}

					if (getActivity() != null) {
						tabLayout.setupWithViewPager(viewPager);
					}
				}
			});
		}

		ImageButton onlineDocumentationButton =
				(ImageButton) view.findViewById(R.id.onlineDocumentationButton);
		onlineDocumentationButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				getActivity().startActivity(new Intent(Intent.ACTION_VIEW,
						Uri.parse("https://wiki.openstreetmap.org/wiki/Map_Features")));
			}
		});

		final int colorId = isLightTheme ? R.color.inactive_item_orange : R.color.dash_search_icon_dark;
		final int color = getResources().getColor(colorId);
		onlineDocumentationButton.setImageDrawable(getPaintedContentIcon(R.drawable.ic_action_help, color));
		final ImageButton poiTypeButton = (ImageButton) view.findViewById(R.id.poiTypeButton);
		poiTypeButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				PoiTypeDialogFragment fragment = PoiTypeDialogFragment.createInstance();
				fragment.setOnItemSelectListener(new PoiTypeDialogFragment.OnItemSelectListener() {
					@Override
					public void select(PoiCategory poiCategory) {
						setPoiCategory(poiCategory);
					}
				});
				fragment.show(getChildFragmentManager(), "PoiTypeDialogFragment");
			}
		});

		EditText poiNameEditText = (EditText) view.findViewById(R.id.poiNameEditText);
		poiNameEditText.addTextChangedListener(new TextWatcher() {
			@Override
			public void beforeTextChanged(CharSequence s, int start, int count, int after) {
			}

			@Override
			public void onTextChanged(CharSequence s, int start, int before, int count) {
			}

			@Override
			public void afterTextChanged(Editable s) {
				if (!getEditPoiData().isInEdit()) {
					if (!TextUtils.isEmpty(s)) {
						getEditPoiData().putTag(OSMSettings.OSMTagKey.NAME.getValue(),
								s.toString());
					} else {
						getEditPoiData().removeTag(OSMSettings.OSMTagKey.NAME.getValue());
					}
				}
			}
		});
		poiNameEditText.setText(editPoiData.getTag(OSMSettings.OSMTagKey.NAME.getValue()));
		poiTypeTextInputLayout = (TextInputLayout) view.findViewById(R.id.poiTypeTextInputLayout);
		poiTypeEditText = (AutoCompleteTextView) view.findViewById(R.id.poiTypeEditText);
		poiTypeEditText.addTextChangedListener(new TextWatcher() {
			@Override
			public void beforeTextChanged(CharSequence s, int start, int count, int after) {
			}

			@Override
			public void onTextChanged(CharSequence s, int start, int before, int count) {
			}

			@Override
			public void afterTextChanged(Editable s) {
				if (!getEditPoiData().isInEdit()) {
					getEditPoiData().updateTypeTag(s.toString());
					if (!getMyApplication().isApplicationInitializing()) {
						poiTypeTextInputLayout.setHint(editPoiData.getPoiCategory().getTranslation());
					}
				}
			}
		});
		poiNameEditText.setOnEditorActionListener(mOnEditorActionListener);
		poiTypeEditText.setOnEditorActionListener(mOnEditorActionListener);
		poiTypeEditText.setText(editPoiData.getPoiTypeString());
		poiTypeEditText.setOnTouchListener(new View.OnTouchListener() {
			@Override
			public boolean onTouch(final View v, MotionEvent event) {
				final EditText editText = (EditText) v;
				final int DRAWABLE_RIGHT = 2;
				if (event.getAction() == MotionEvent.ACTION_UP) {
					if (event.getX() >= (editText.getRight()
							- editText.getCompoundDrawables()[DRAWABLE_RIGHT].getBounds().width()
							- editText.getPaddingRight())) {
						if (editPoiData.getPoiCategory() != null) {
							PoiSubTypeDialogFragment dialogFragment =
									PoiSubTypeDialogFragment.createInstance(editPoiData.getPoiCategory());
							dialogFragment.setOnItemSelectListener(new PoiSubTypeDialogFragment.OnItemSelectListener() {
								@Override
								public void select(String category) {
									setSubCategory(category);
								}
							});
							dialogFragment.show(getChildFragmentManager(), "PoiSubTypeDialogFragment");
						}

						return true;
					}
				}
				return false;
			}
		});

		Button saveButton = (Button) view.findViewById(R.id.saveButton);
		saveButton.setText(mOpenstreetmapUtil instanceof OpenstreetmapRemoteUtil
				? R.string.shared_string_upload : R.string.shared_string_save);
		saveButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				trySave();
			}
		});
		Button cancelButton = (Button) view.findViewById(R.id.cancelButton);
		cancelButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				dismissCheckForChanges();
			}
		});
		setAdapterForPoiTypeEditText();
		setCancelable(false);
		return view;
	}

	@NonNull
	@Override
	public Dialog onCreateDialog(Bundle savedInstanceState) {
		final Dialog dialog = super.onCreateDialog(savedInstanceState);
		dialog.getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE);
		return dialog;
	}

	@Override
	public void onResume() {
		super.onResume();
		getDialog().setOnKeyListener(new DialogInterface.OnKeyListener() {
			@Override
			public boolean onKey(DialogInterface dialog, int keyCode, KeyEvent event) {
				if (keyCode == android.view.KeyEvent.KEYCODE_BACK) {
					if (event.getAction() == KeyEvent.ACTION_DOWN) {
						return true;
					} else {
						dismissCheckForChanges();
						return true;
					}
				}
				return false;
			}
		});
	}

	@Override
	public void onSaveInstanceState(Bundle outState) {
		outState.putSerializable(TAGS_LIST, (Serializable) editPoiData.getTagValues());
		super.onSaveInstanceState(outState);
	}

	@Override
	public void show(FragmentManager manager, String tag) {
		if (manager.findFragmentByTag(TAG) == null) {
			super.show(manager, TAG);
		}
	}

	@Override
	public int show(FragmentTransaction transaction, String tag) {
		throw new UnsupportedOperationException("Please use show(FragmentManager manager, String tag)");
	}

	private void trySave() {
		if (TextUtils.isEmpty(poiTypeEditText.getText())) {
			HashSet<String> tagsCopy = new HashSet<>();
			tagsCopy.addAll(editPoiData.getTagValues().keySet());
			if (Algorithms.isEmpty(editPoiData.getTag(OSMSettings.OSMTagKey.ADDR_HOUSE_NUMBER.getValue()))) {
				SaveExtraValidationDialogFragment f = new SaveExtraValidationDialogFragment();
				Bundle args = new Bundle();
				args.putInt("message", R.string.save_poi_without_poi_type_message);
				f.setArguments(args);
				f.show(getChildFragmentManager(), "dialog");
				// poiTypeEditText.setError(getResources().getString(R.string.please_specify_poi_type));
			} else {
				save();
			}
		} else if (testTooManyCapitalLetters(editPoiData.getTag(OSMSettings.OSMTagKey.NAME.getValue()))) {
			SaveExtraValidationDialogFragment f = new SaveExtraValidationDialogFragment();
			Bundle args = new Bundle();
			args.putInt("message", R.string.save_poi_too_many_uppercase);
			f.setArguments(args);
			f.show(getChildFragmentManager(), "dialog");			
		} else if (editPoiData.getPoiCategory() == getMyApplication().getPoiTypes().getOtherPoiCategory()) {
			poiTypeEditText.setError(getResources().getString(R.string.please_specify_poi_type));
		} else if (editPoiData.getPoiTypeDefined() == null) {
			poiTypeEditText.setError(getResources().getString(R.string.please_specify_poi_type_only_from_list));
		} else {
			save();
		}
	}

	private boolean testTooManyCapitalLetters(String name) {
		if(name == null) {
			return false;
		}
		int capital = 0;
		int lower = 0;
		int nonalpha = 0;
		for(int i = 0; i < name.length(); i++) {
			char c = name.charAt(i);
			if(Character.isLetter(c) || Character.getType(c) == Character.LETTER_NUMBER) {
				if(Character.isUpperCase(c)) {
					capital ++;
				} else {
					lower ++;
				}
			} else {
				nonalpha ++;
			}
		}
		return capital > nonalpha && capital > lower;
	}

	private void save() {
		Node original = editPoiData.getEntity();
		final boolean offlineEdit = mOpenstreetmapUtil instanceof OpenstreetmapLocalUtil;
		Node node = new Node(original.getLatitude(), original.getLongitude(), original.getId());
		OsmPoint.Action action = node.getId() < 0 ? OsmPoint.Action.CREATE : OsmPoint.Action.MODIFY;
		for (Map.Entry<String, String> tag : editPoiData.getTagValues().entrySet()) {
			if (!Algorithms.isEmpty(tag.getKey()) && !Algorithms.isEmpty(tag.getValue()) && 
					!tag.getKey().equals(EditPoiData.POI_TYPE_TAG)) {
				node.putTagNoLC(tag.getKey(), tag.getValue());
			}
		}
		String poiTypeTag = editPoiData.getTagValues().get(EditPoiData.POI_TYPE_TAG);
		String comment = "";
		if (poiTypeTag != null) {
			final PoiType poiType = editPoiData.getAllTranslatedSubTypes().get(poiTypeTag.trim().toLowerCase());
			if (poiType != null) {
				node.putTagNoLC(poiType.getOsmTag(), poiType.getOsmValue());
				node.removeTag(EditPoiData.REMOVE_TAG_PREFIX + poiType.getOsmTag());
				if (poiType.getOsmTag2() != null) {
					node.putTagNoLC(poiType.getOsmTag2(), poiType.getOsmValue2());
					node.removeTag(EditPoiData.REMOVE_TAG_PREFIX + poiType.getOsmTag2());
				}
			} else if (!Algorithms.isEmpty(poiTypeTag)) {
				node.putTagNoLC(editPoiData.getPoiCategory().getDefaultTag(), poiTypeTag);

			}
			if (offlineEdit && !Algorithms.isEmpty(poiTypeTag)) {
				node.putTagNoLC(EditPoiData.POI_TYPE_TAG, poiTypeTag);
			}
			String actionString = action == OsmPoint.Action.CREATE ? getString(R.string.default_changeset_add) : getString(R.string.default_changeset_edit);
			comment = actionString + " " + poiTypeTag;
		}
		commitNode(action, node, mOpenstreetmapUtil.getEntityInfo(node.getId()), comment, false,
				new CallbackWithObject<Node>() {

					@Override
					public boolean processResult(Node result) {
						if (result != null) {
							OsmEditingPlugin plugin = OsmandPlugin.getPlugin(OsmEditingPlugin.class);
							if (plugin != null && offlineEdit) {
								List<OpenstreetmapPoint> points = plugin.getDBPOI().getOpenstreetmapPoints();
								if (getActivity() instanceof MapActivity && points.size() > 0) {
									OsmPoint point = points.get(points.size() - 1);
									MapActivity mapActivity = (MapActivity) getActivity();
									mapActivity.getContextMenu().showOrUpdate(
											new LatLon(point.getLatitude(), point.getLongitude()),
											plugin.getOsmEditsLayer(mapActivity).getObjectName(point), point);
								}
							}

							if (getActivity() instanceof MapActivity) {
								((MapActivity) getActivity()).getMapView().refreshMap(true);
							}
							dismiss();
						} else {
							OsmEditingPlugin plugin = OsmandPlugin.getPlugin(OsmEditingPlugin.class);
							mOpenstreetmapUtil = plugin.getPoiModificationLocalUtil();
							Button saveButton = (Button) view.findViewById(R.id.saveButton);
							saveButton.setText(mOpenstreetmapUtil instanceof OpenstreetmapRemoteUtil
									? R.string.shared_string_upload : R.string.shared_string_save);
						}

						return false;
					}
				}, getActivity(), mOpenstreetmapUtil);
	}

	private void dismissCheckForChanges() {
		if (editPoiData.hasChangesBeenMade()) {
			new AreYouSureDialogFragment().show(getChildFragmentManager(),
					"AreYouSureDialogFragment");
		} else {
			dismiss();
		}
	}

	public EditPoiData getEditPoiData() {
		return editPoiData;
	}

	public void setSubCategory(String subCategory) {
		poiTypeEditText.setText(subCategory);
	}

	public static void commitNode(final OsmPoint.Action action,
								  final Node node,
								  final EntityInfo info,
								  final String comment,
								  final boolean closeChangeSet,
								  final CallbackWithObject<Node> postExecute,
								  final Activity activity,
								  final OpenstreetmapUtil openstreetmapUtil) {
		if (info == null && OsmPoint.Action.CREATE != action && openstreetmapUtil instanceof OpenstreetmapRemoteUtil) {
			Toast.makeText(activity, activity.getResources().getString(R.string.poi_error_info_not_loaded), Toast.LENGTH_LONG).show();
			return;
		}
		new AsyncTask<Void, Void, Node>() {
			ProgressDialog progress;

			@Override
			protected void onPreExecute() {
				progress = ProgressDialog.show(activity, activity.getString(R.string.uploading), activity.getString(R.string.uploading_data));
				super.onPreExecute();
			}

			@Override
			protected Node doInBackground(Void... params) {
				return openstreetmapUtil.commitNodeImpl(action, node, info, comment, closeChangeSet);
			}

			@Override
			protected void onPostExecute(Node result) {
				progress.dismiss();
				if (postExecute != null) {
					postExecute.processResult(result);
				}
			}
		}.execute();
	}

	public void setPoiCategory(PoiCategory type) {
		editPoiData.updateType(type);
		poiTypeEditText.setText(editPoiData.getPoiTypeString());
		setAdapterForPoiTypeEditText();
	}

	private void setAdapterForPoiTypeEditText() {
		final Map<String, PoiType> subCategories = new LinkedHashMap<>();
		PoiCategory ct = editPoiData.getPoiCategory();
		if (ct != null) {
			for (PoiType s : ct.getPoiTypes()) {
				if (!s.isReference() && !s.isNotEditableOsm() && s.getBaseLangType() == null) {
					addMapEntryAdapter(subCategories, s.getTranslation(), s);
					if(!s.getKeyName().contains("osmand")) {
						addMapEntryAdapter(subCategories, s.getKeyName().replace('_', ' '), s);
					}
				}
			}
		}
		for (Map.Entry<String, PoiType> s : editPoiData.getAllTranslatedSubTypes().entrySet()) {
			addMapEntryAdapter(subCategories, s.getKey(), s.getValue());
		}
		final ArrayAdapter<Object> adapter;
		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
			adapter = new ArrayAdapter<>(getActivity(),
					R.layout.list_textview, subCategories.keySet().toArray());
		} else {
			TypedValue typedValue = new TypedValue();
			Resources.Theme theme = getActivity().getTheme();
			theme.resolveAttribute(android.R.attr.textColorSecondary, typedValue, true);
			final int textColor = typedValue.data;

			adapter = new ArrayAdapter<Object>(getActivity(),
					R.layout.list_textview, subCategories.keySet().toArray()) {
				@Override
				public View getView(int position, View convertView, ViewGroup parent) {
					final View view = super.getView(position, convertView, parent);
					((TextView) view.findViewById(R.id.textView)).setTextColor(textColor);
					return view;
				}
			};
		}
		adapter.sort(new Comparator<Object>() {
			@Override
			public int compare(Object lhs, Object rhs) {
				return lhs.toString().compareTo(rhs.toString());
			}
		});
		poiTypeEditText.setAdapter(adapter);
		poiTypeEditText.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {

			@Override
			public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
				Object item = parent.getAdapter().getItem(position);
				poiTypeEditText.setText(item.toString());
				setAdapterForPoiTypeEditText();
			}

			@Override
			public void onNothingSelected(AdapterView<?> parent) {
			}
		});

	}

	private void addMapEntryAdapter(final Map<String, PoiType> subCategories, String key, PoiType v) {
		if (!subCategories.containsKey(key.toLowerCase())) {
			subCategories.put(Algorithms.capitalizeFirstLetterAndLowercase(key), v);
		}
	}

	public static EditPoiDialogFragment createAddPoiInstance(double latitude, double longitude,
															 OsmandApplication application) {
		Node node = new Node(latitude, longitude, -1);
		return createInstance(node, true);
	}

	public static EditPoiDialogFragment createInstance(Node node, boolean isAddingPoi) {
		EditPoiDialogFragment editPoiDialogFragment = new EditPoiDialogFragment();
		Bundle args = new Bundle();
		args.putSerializable(KEY_AMENITY_NODE, node);
		args.putBoolean(IS_ADDING_POI, isAddingPoi);
		editPoiDialogFragment.setArguments(args);
		return editPoiDialogFragment;
	}

	public static EditPoiDialogFragment createInstance(Node node, boolean isAddingPoi, Map<String, String> tagList) {
		EditPoiDialogFragment editPoiDialogFragment = new EditPoiDialogFragment();
		Bundle args = new Bundle();
		args.putSerializable(KEY_AMENITY_NODE, node);
		args.putBoolean(IS_ADDING_POI, isAddingPoi);
		args.putSerializable(TAGS_LIST, (Serializable) Collections.unmodifiableMap(tagList));
		editPoiDialogFragment.setArguments(args);
		return editPoiDialogFragment;
	}

	public static void showEditInstance(final Amenity amenity,
										final AppCompatActivity activity) {
		final OsmandSettings settings = ((OsmandApplication) activity.getApplication())
				.getSettings();
		final OpenstreetmapUtil openstreetmapUtilToLoad;
		OsmEditingPlugin plugin = OsmandPlugin.getPlugin(OsmEditingPlugin.class);
		if (//settings.OFFLINE_EDITION.get() ||
				!settings.isInternetConnectionAvailable(true)) {
			openstreetmapUtilToLoad = plugin.getPoiModificationLocalUtil();
		} else {
			openstreetmapUtilToLoad = plugin.getPoiModificationRemoteUtil();
		}
		new AsyncTask<Void, Void, Node>() {
			@Override
			protected Node doInBackground(Void... params) {
				return openstreetmapUtilToLoad.loadNode(amenity);
			}

			protected void onPostExecute(Node n) {
				if (n != null) {
					EditPoiDialogFragment fragment =
							EditPoiDialogFragment.createInstance(n, false);
					fragment.show(activity.getSupportFragmentManager(), TAG);
				} else {
					Toast.makeText(activity,
							activity.getString(R.string.poi_error_poi_not_found),
							Toast.LENGTH_LONG).show();
				}
			}
		}.execute();
	}

	public static class MyAdapter extends FragmentPagerAdapter {
		private final Fragment[] fragments = new Fragment[]{new BasicEditPoiFragment(),
				new AdvancedEditPoiFragment()};
		private final String[] titles;

		public MyAdapter(FragmentManager fm, String basicTitle, String extendedTitle) {
			super(fm);
			titles = new String[]{basicTitle, extendedTitle};
		}

		@Override
		public int getCount() {
			return 2;
		}

		@Override
		public Fragment getItem(int position) {
			return fragments[position];
		}

		@Override
		public CharSequence getPageTitle(int position) {
			return titles[position];
		}
	}

	public static class ShowDeleteDialogAsyncTask extends AsyncTask<Amenity, Void, Node> {
		private final OpenstreetmapUtil openstreetmapUtil;
		private final AppCompatActivity activity;

		public ShowDeleteDialogAsyncTask(AppCompatActivity activity) {
			this.activity = activity;
			OsmandSettings settings = ((OsmandApplication) activity.getApplication()).getSettings();
			OsmEditingPlugin plugin = OsmandPlugin.getPlugin(OsmEditingPlugin.class);
			if (settings.OFFLINE_EDITION.get() || !settings.isInternetConnectionAvailable(true)) {
				openstreetmapUtil = plugin.getPoiModificationLocalUtil();
			} else {
				openstreetmapUtil = plugin.getPoiModificationRemoteUtil();
			}
		}

		protected Node doInBackground(Amenity[] params) {
			return openstreetmapUtil.loadNode(params[0]);
		}

		protected void onPostExecute(final Node n) {
			if (n == null) {
				Toast.makeText(activity, activity.getResources().getString(R.string.poi_error_poi_not_found), Toast.LENGTH_LONG).show();
				return;
			}
			AlertDialog.Builder builder = new AlertDialog.Builder(activity);
			builder.setTitle(R.string.poi_remove_title);
			final EditText comment;
			final CheckBox closeChangesetCheckBox;
			final boolean isLocalEdit = openstreetmapUtil instanceof OpenstreetmapLocalUtil;
			if (isLocalEdit) {
				closeChangesetCheckBox = null;
				comment = null;
			} else {
				LinearLayout ll = new LinearLayout(activity);
				ll.setPadding(16, 2, 16, 0);
				ll.setOrientation(LinearLayout.VERTICAL);
				closeChangesetCheckBox = new CheckBox(activity);
				closeChangesetCheckBox.setText(R.string.close_changeset);
				ll.addView(closeChangesetCheckBox);
				comment = new EditText(activity);
				comment.setText(R.string.poi_remove_title);
				ll.addView(comment);
				builder.setView(ll);
			}
			builder.setNegativeButton(R.string.shared_string_cancel, null);
			builder.setPositiveButton(isLocalEdit ? R.string.shared_string_save : R.string.shared_string_delete, new DialogInterface.OnClickListener() {
				@Override
				public void onClick(DialogInterface dialog, int which) {
					String c = comment == null ? null : comment.getText().toString();
					boolean closeChangeSet = closeChangesetCheckBox != null
							&& closeChangesetCheckBox.isChecked();
					deleteNode(n, c, closeChangeSet);
				}


			});
			builder.create().show();
		}

		private void deleteNode(final Node n, final String c, final boolean closeChangeSet) {
			final boolean isLocalEdit = openstreetmapUtil instanceof OpenstreetmapLocalUtil;
			commitNode(OsmPoint.Action.DELETE, n, openstreetmapUtil.getEntityInfo(n.getId()), c, closeChangeSet,
					new CallbackWithObject<Node>() {

						@Override
						public boolean processResult(Node result) {
							if (result != null) {
								if (isLocalEdit) {
									Toast.makeText(activity, R.string.osm_changes_added_to_local_edits,
											Toast.LENGTH_LONG).show();
								} else {
									Toast.makeText(activity, R.string.poi_remove_success, Toast.LENGTH_LONG)
											.show();
								}
								if (activity instanceof MapActivity) {
									((MapActivity) activity).getMapView().refreshMap(true);
								}
							}
							return false;
						}
					}, activity, openstreetmapUtil);
		}
	}

	public static class SaveExtraValidationDialogFragment extends DialogFragment {
		@NonNull
		@Override
		public Dialog onCreateDialog(Bundle savedInstanceState) {
			AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
			String msg = getString(R.string.save_poi_without_poi_type_message);
			int i = getArguments().getInt("message", 0);
			if(i != 0) {
				msg = getString(i);
			}
			builder.setTitle(getResources().getString(R.string.are_you_sure))
					.setMessage(msg)
					.setPositiveButton(R.string.shared_string_ok, new DialogInterface.OnClickListener() {
						@Override
						public void onClick(DialogInterface dialog, int which) {
							((EditPoiDialogFragment) getParentFragment()).save();
						}
					})
					.setNegativeButton(R.string.shared_string_cancel, null);
			return builder.create();
		}
	}

	public static class AreYouSureDialogFragment extends DialogFragment {
		@NonNull
		@Override
		public Dialog onCreateDialog(Bundle savedInstanceState) {
			AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
			builder.setTitle(getResources().getString(R.string.are_you_sure))
					.setMessage(getString(R.string.unsaved_changes_will_be_lost))
					.setPositiveButton(R.string.shared_string_ok, new DialogInterface.OnClickListener() {
						@Override
						public void onClick(DialogInterface dialog, int which) {
							((DialogFragment) getParentFragment()).dismiss();
						}
					})
					.setNegativeButton(R.string.shared_string_cancel, null);
			return builder.create();
		}
	}

	private TextView.OnEditorActionListener mOnEditorActionListener =
			new TextView.OnEditorActionListener() {
				@Override
				public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
					boolean handled = false;
					if (actionId == EditorInfo.IME_ACTION_SEND) {
						trySave();
						handled = true;
					}
					return handled;
				}
			};

	public interface OnFragmentActivatedListener {
		void onFragmentActivated();
	}
}
!@#$%
20190530_062613,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_a06248
package net.osmand.plus.osmedit;

import android.app.Activity;
import android.app.Dialog;
import android.app.ProgressDialog;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.res.Resources;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Build;
import android.os.Bundle;
import android.support.annotation.NonNull;
import android.support.design.widget.TabLayout;
import android.support.design.widget.TextInputLayout;
import android.support.v4.app.DialogFragment;
import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentManager;
import android.support.v4.app.FragmentPagerAdapter;
import android.support.v4.app.FragmentTransaction;
import android.support.v4.view.ViewCompat;
import android.support.v4.view.ViewPager;
import android.support.v7.app.AlertDialog;
import android.support.v7.app.AppCompatActivity;
import android.support.v7.widget.Toolbar;
import android.text.Editable;
import android.text.TextUtils;
import android.text.TextWatcher;
import android.util.TypedValue;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.view.ViewTreeObserver;
import android.view.WindowManager;
import android.view.inputmethod.EditorInfo;
import android.widget.AdapterView;
import android.widget.ArrayAdapter;
import android.widget.AutoCompleteTextView;
import android.widget.Button;
import android.widget.CheckBox;
import android.widget.EditText;
import android.widget.ImageButton;
import android.widget.LinearLayout;
import android.widget.TextView;
import android.widget.Toast;

import net.osmand.CallbackWithObject;
import net.osmand.PlatformUtil;
import net.osmand.data.Amenity;
import net.osmand.data.LatLon;
import net.osmand.osm.PoiCategory;
import net.osmand.osm.PoiType;
import net.osmand.osm.edit.EntityInfo;
import net.osmand.osm.edit.Node;
import net.osmand.osm.edit.OSMSettings;
import net.osmand.plus.OsmandApplication;
import net.osmand.plus.OsmandPlugin;
import net.osmand.plus.OsmandSettings;
import net.osmand.plus.R;
import net.osmand.plus.activities.MapActivity;
import net.osmand.plus.base.BaseOsmAndDialogFragment;
import net.osmand.plus.osmedit.dialogs.PoiSubTypeDialogFragment;
import net.osmand.plus.osmedit.dialogs.PoiTypeDialogFragment;
import net.osmand.util.Algorithms;

import org.apache.commons.logging.Log;

import java.io.Serializable;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

public class EditPoiDialogFragment extends BaseOsmAndDialogFragment {
	public static final String TAG = "EditPoiDialogFragment";
	private static final Log LOG = PlatformUtil.getLog(EditPoiDialogFragment.class);

	private static final String KEY_AMENITY_NODE = "key_amenity_node";
	private static final String TAGS_LIST = "tags_list";
	private static final String IS_ADDING_POI = "is_adding_poi";

	public static final HashSet<String> BASIC_TAGS = new HashSet<String>() ;
	static {
		BASIC_TAGS.add(OSMSettings.OSMTagKey.NAME.getValue());
		BASIC_TAGS.add(OSMSettings.OSMTagKey.ADDR_STREET.getValue());
		BASIC_TAGS.add(OSMSettings.OSMTagKey.ADDR_HOUSE_NUMBER.getValue());
		BASIC_TAGS.add(OSMSettings.OSMTagKey.PHONE.getValue());
		BASIC_TAGS.add(OSMSettings.OSMTagKey.WEBSITE.getValue());
		BASIC_TAGS.add(OSMSettings.OSMTagKey.OPENING_HOURS.getValue());
	}

	private EditPoiData editPoiData;
	private ViewPager viewPager;
	private AutoCompleteTextView poiTypeEditText;

	private OpenstreetmapUtil mOpenstreetmapUtil;
	private TextInputLayout poiTypeTextInputLayout;
	private View view;

	@Override
	public void onAttach(Activity activity) {
		super.onAttach(activity);
		OsmEditingPlugin plugin = OsmandPlugin.getPlugin(OsmEditingPlugin.class);
		if (getSettings().OFFLINE_EDITION.get()
				|| !getSettings().isInternetConnectionAvailable(true)) {
			mOpenstreetmapUtil = plugin.getPoiModificationLocalUtil();
		} else {
			mOpenstreetmapUtil = plugin.getPoiModificationRemoteUtil();
		}

		Node node = (Node) getArguments().getSerializable(KEY_AMENITY_NODE);
		editPoiData = new EditPoiData(node, getMyApplication());
	}

	@Override
	public View onCreateView(LayoutInflater inflater, ViewGroup container,
							 Bundle savedInstanceState) {
		view = inflater.inflate(R.layout.fragment_edit_poi, container, false);
		boolean isLightTheme = getSettings().OSMAND_THEME.get() == OsmandSettings.OSMAND_LIGHT_THEME;

		if (savedInstanceState != null) {
			@SuppressWarnings("unchecked")
			Map<String, String> mp = (Map<String, String>) savedInstanceState.getSerializable(TAGS_LIST);
			editPoiData.updateTags(mp);
		}

		boolean isAddingPoi = getArguments().getBoolean(IS_ADDING_POI);

		Toolbar toolbar = (Toolbar) view.findViewById(R.id.toolbar);
		toolbar.setTitle(isAddingPoi ? R.string.poi_create_title : R.string.poi_edit_title);
		toolbar.setNavigationIcon(R.drawable.ic_arrow_back);
		toolbar.setNavigationContentDescription(R.string.access_shared_string_navigate_up);
		toolbar.setNavigationOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				dismissCheckForChanges();
			}
		});

		viewPager = (ViewPager) view.findViewById(R.id.viewpager);
		String basicTitle = getResources().getString(R.string.tab_title_basic);
		String extendedTitle = getResources().getString(R.string.tab_title_advanced);
		final MyAdapter pagerAdapter = new MyAdapter(getChildFragmentManager(), basicTitle, extendedTitle);
		viewPager.setAdapter(pagerAdapter);
		viewPager.addOnPageChangeListener(new ViewPager.OnPageChangeListener() {
			@Override
			public void onPageScrolled(int i, float v, int i1) {

			}

			@Override
			public void onPageSelected(int i) {
				((OnFragmentActivatedListener) pagerAdapter.getItem(i)).onFragmentActivated();
			}

			@Override
			public void onPageScrollStateChanged(int i) {

			}
		});

		final TabLayout tabLayout = (TabLayout) view.findViewById(R.id.tab_layout);
		tabLayout.setTabMode(TabLayout.MODE_SCROLLABLE);

		// tabLayout.setupWithViewPager(viewPager);
		// Hack due to bug in design support library v22.2.1
		// https://code.google.com/p/android/issues/detail?id=180462
		// TODO remove in new version
		if (Build.VERSION.SDK_INT >= 11) {
			if (ViewCompat.isLaidOut(tabLayout)) {
				tabLayout.setupWithViewPager(viewPager);
			} else {
				tabLayout.addOnLayoutChangeListener(new View.OnLayoutChangeListener() {
					@Override
					public void onLayoutChange(View v, int left, int top, int right, int bottom,
											   int oldLeft, int oldTop, int oldRight, int oldBottom) {
						tabLayout.setupWithViewPager(viewPager);
						tabLayout.removeOnLayoutChangeListener(this);
					}
				});
			}
		} else {
			ViewTreeObserver vto = view.getViewTreeObserver();
			vto.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {

				@Override
				public void onGlobalLayout() {

					ViewTreeObserver obs = view.getViewTreeObserver();
					if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
						obs.removeGlobalOnLayoutListener(this);
					}

					if (getActivity() != null) {
						tabLayout.setupWithViewPager(viewPager);
					}
				}
			});
		}

		ImageButton onlineDocumentationButton =
				(ImageButton) view.findViewById(R.id.onlineDocumentationButton);
		onlineDocumentationButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				getActivity().startActivity(new Intent(Intent.ACTION_VIEW,
						Uri.parse("https://wiki.openstreetmap.org/wiki/Map_Features")));
			}
		});

		final int colorId = isLightTheme ? R.color.inactive_item_orange : R.color.dash_search_icon_dark;
		final int color = getResources().getColor(colorId);
		onlineDocumentationButton.setImageDrawable(getPaintedContentIcon(R.drawable.ic_action_help, color));
		final ImageButton poiTypeButton = (ImageButton) view.findViewById(R.id.poiTypeButton);
		poiTypeButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				PoiTypeDialogFragment fragment = PoiTypeDialogFragment.createInstance();
				fragment.setOnItemSelectListener(new PoiTypeDialogFragment.OnItemSelectListener() {
					@Override
					public void select(PoiCategory poiCategory) {
						setPoiCategory(poiCategory);
					}
				});
				fragment.show(getChildFragmentManager(), "PoiTypeDialogFragment");
			}
		});

		EditText poiNameEditText = (EditText) view.findViewById(R.id.poiNameEditText);
		poiNameEditText.addTextChangedListener(new TextWatcher() {
			@Override
			public void beforeTextChanged(CharSequence s, int start, int count, int after) {
			}

			@Override
			public void onTextChanged(CharSequence s, int start, int before, int count) {
			}

			@Override
			public void afterTextChanged(Editable s) {
				if (!getEditPoiData().isInEdit()) {
					if (!TextUtils.isEmpty(s)) {
						getEditPoiData().putTag(OSMSettings.OSMTagKey.NAME.getValue(),
								s.toString());
					} else {
						getEditPoiData().removeTag(OSMSettings.OSMTagKey.NAME.getValue());
					}
				}
			}
		});
		poiNameEditText.setText(editPoiData.getTag(OSMSettings.OSMTagKey.NAME.getValue()));
		poiTypeTextInputLayout = (TextInputLayout) view.findViewById(R.id.poiTypeTextInputLayout);
		poiTypeEditText = (AutoCompleteTextView) view.findViewById(R.id.poiTypeEditText);
		poiTypeEditText.addTextChangedListener(new TextWatcher() {
			@Override
			public void beforeTextChanged(CharSequence s, int start, int count, int after) {
			}

			@Override
			public void onTextChanged(CharSequence s, int start, int before, int count) {
			}

			@Override
			public void afterTextChanged(Editable s) {
				if (!getEditPoiData().isInEdit()) {
					getEditPoiData().updateTypeTag(s.toString());
					poiTypeTextInputLayout.setHint(editPoiData.getPoiCategory().getTranslation());
				}
			}
		});
		poiNameEditText.setOnEditorActionListener(mOnEditorActionListener);
		poiTypeEditText.setOnEditorActionListener(mOnEditorActionListener);
		poiTypeEditText.setText(editPoiData.getPoiTypeString());
		poiTypeEditText.setOnTouchListener(new View.OnTouchListener() {
			@Override
			public boolean onTouch(final View v, MotionEvent event) {
				final EditText editText = (EditText) v;
				final int DRAWABLE_RIGHT = 2;
				if (event.getAction() == MotionEvent.ACTION_UP) {
					if (event.getX() >= (editText.getRight()
							- editText.getCompoundDrawables()[DRAWABLE_RIGHT].getBounds().width()
							- editText.getPaddingRight())) {
						if (editPoiData.getPoiCategory() != null) {
							PoiSubTypeDialogFragment dialogFragment =
									PoiSubTypeDialogFragment.createInstance(editPoiData.getPoiCategory());
							dialogFragment.setOnItemSelectListener(new PoiSubTypeDialogFragment.OnItemSelectListener() {
								@Override
								public void select(String category) {
									setSubCategory(category);
								}
							});
							dialogFragment.show(getChildFragmentManager(), "PoiSubTypeDialogFragment");
						}

						return true;
					}
				}
				return false;
			}
		});

		Button saveButton = (Button) view.findViewById(R.id.saveButton);
		saveButton.setText(mOpenstreetmapUtil instanceof OpenstreetmapRemoteUtil
				? R.string.shared_string_upload : R.string.shared_string_save);
		saveButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				trySave();
			}
		});
		Button cancelButton = (Button) view.findViewById(R.id.cancelButton);
		cancelButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				dismissCheckForChanges();
			}
		});
		setAdapterForPoiTypeEditText();
		setCancelable(false);
		return view;
	}

	@NonNull
	@Override
	public Dialog onCreateDialog(Bundle savedInstanceState) {
		final Dialog dialog = super.onCreateDialog(savedInstanceState);
		dialog.getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE);
		return dialog;
	}

	@Override
	public void onResume() {
		super.onResume();
		getDialog().setOnKeyListener(new DialogInterface.OnKeyListener() {
			@Override
			public boolean onKey(DialogInterface dialog, int keyCode, KeyEvent event) {
				if (keyCode == android.view.KeyEvent.KEYCODE_BACK) {
					if (event.getAction() == KeyEvent.ACTION_DOWN) {
						return true;
					} else {
						dismissCheckForChanges();
						return true;
					}
				}
				return false;
			}
		});
	}

	@Override
	public void onSaveInstanceState(Bundle outState) {
		outState.putSerializable(TAGS_LIST, (Serializable) editPoiData.getTagValues());
		super.onSaveInstanceState(outState);
	}

	@Override
	public void show(FragmentManager manager, String tag) {
		if (manager.findFragmentByTag(TAG) == null) {
			super.show(manager, TAG);
		}
	}

	@Override
	public int show(FragmentTransaction transaction, String tag) {
		throw new UnsupportedOperationException("Please use show(FragmentManager manager, String tag)");
	}

	private void trySave() {
		if (TextUtils.isEmpty(poiTypeEditText.getText())) {
			HashSet<String> tagsCopy = new HashSet<>();
			tagsCopy.addAll(editPoiData.getTagValues().keySet());
			if (Algorithms.isEmpty(editPoiData.getTag(OSMSettings.OSMTagKey.ADDR_HOUSE_NUMBER.getValue()))) {
				SaveExtraValidationDialogFragment f = new SaveExtraValidationDialogFragment();
				Bundle args = new Bundle();
				args.putInt("message", R.string.save_poi_without_poi_type_message);
				f.setArguments(args);
				f.show(getChildFragmentManager(), "dialog");
				// poiTypeEditText.setError(getResources().getString(R.string.please_specify_poi_type));
			} else {
				save();
			}
		} else if (testTooManyCapitalLetters(editPoiData.getTag(OSMSettings.OSMTagKey.NAME.getValue()))) {
			SaveExtraValidationDialogFragment f = new SaveExtraValidationDialogFragment();
			Bundle args = new Bundle();
			args.putInt("message", R.string.save_poi_too_many_uppercase);
			f.setArguments(args);
			f.show(getChildFragmentManager(), "dialog");			
		} else if (editPoiData.getPoiCategory() == getMyApplication().getPoiTypes().getOtherPoiCategory()) {
			poiTypeEditText.setError(getResources().getString(R.string.please_specify_poi_type));
		} else if (editPoiData.getPoiTypeDefined() == null) {
			poiTypeEditText.setError(getResources().getString(R.string.please_specify_poi_type_only_from_list));
		} else {
			save();
		}
	}

	private boolean testTooManyCapitalLetters(String name) {
		if(name == null) {
			return false;
		}
		int capital = 0;
		int lower = 0;
		int nonalpha = 0;
		for(int i = 0; i < name.length(); i++) {
			char c = name.charAt(i);
			if(Character.isLetter(c) || Character.getType(c) == Character.LETTER_NUMBER) {
				if(Character.isUpperCase(c)) {
					capital ++;
				} else {
					lower ++;
				}
			} else {
				nonalpha ++;
			}
		}
		return capital > nonalpha && capital > lower;
	}

	private void save() {
		Node original = editPoiData.getEntity();
		final boolean offlineEdit = mOpenstreetmapUtil instanceof OpenstreetmapLocalUtil;
		Node node = new Node(original.getLatitude(), original.getLongitude(), original.getId());
		OsmPoint.Action action = node.getId() < 0 ? OsmPoint.Action.CREATE : OsmPoint.Action.MODIFY;
		for (Map.Entry<String, String> tag : editPoiData.getTagValues().entrySet()) {
			if (!Algorithms.isEmpty(tag.getKey()) && !Algorithms.isEmpty(tag.getValue()) && 
					!tag.getKey().equals(EditPoiData.POI_TYPE_TAG)) {
				node.putTagNoLC(tag.getKey(), tag.getValue());
			}
		}
		String poiTypeTag = editPoiData.getTagValues().get(EditPoiData.POI_TYPE_TAG);
		String comment = "";
		if (poiTypeTag != null) {
			final PoiType poiType = editPoiData.getAllTranslatedSubTypes().get(poiTypeTag.trim().toLowerCase());
			if (poiType != null) {
				node.putTagNoLC(poiType.getOsmTag(), poiType.getOsmValue());
				node.removeTag(EditPoiData.REMOVE_TAG_PREFIX + poiType.getOsmTag());
				if (poiType.getOsmTag2() != null) {
					node.putTagNoLC(poiType.getOsmTag2(), poiType.getOsmValue2());
					node.removeTag(EditPoiData.REMOVE_TAG_PREFIX + poiType.getOsmTag2());
				}
			} else if (!Algorithms.isEmpty(poiTypeTag)) {
				node.putTagNoLC(editPoiData.getPoiCategory().getDefaultTag(), poiTypeTag);

			}
			if (offlineEdit && !Algorithms.isEmpty(poiTypeTag)) {
				node.putTagNoLC(EditPoiData.POI_TYPE_TAG, poiTypeTag);
			}
			String actionString = action == OsmPoint.Action.CREATE ? getString(R.string.default_changeset_add) : getString(R.string.default_changeset_edit);
			comment = actionString + " " + poiTypeTag;
		}
		commitNode(action, node, mOpenstreetmapUtil.getEntityInfo(node.getId()), comment, false,
				new CallbackWithObject<Node>() {

					@Override
					public boolean processResult(Node result) {
						if (result != null) {
							OsmEditingPlugin plugin = OsmandPlugin.getPlugin(OsmEditingPlugin.class);
							if (plugin != null && offlineEdit) {
								List<OpenstreetmapPoint> points = plugin.getDBPOI().getOpenstreetmapPoints();
								if (getActivity() instanceof MapActivity && points.size() > 0) {
									OsmPoint point = points.get(points.size() - 1);
									MapActivity mapActivity = (MapActivity) getActivity();
									mapActivity.getContextMenu().showOrUpdate(
											new LatLon(point.getLatitude(), point.getLongitude()),
											plugin.getOsmEditsLayer(mapActivity).getObjectName(point), point);
								}
							}

							if (getActivity() instanceof MapActivity) {
								((MapActivity) getActivity()).getMapView().refreshMap(true);
							}
							dismiss();
						} else {
							OsmEditingPlugin plugin = OsmandPlugin.getPlugin(OsmEditingPlugin.class);
							mOpenstreetmapUtil = plugin.getPoiModificationLocalUtil();
							Button saveButton = (Button) view.findViewById(R.id.saveButton);
							saveButton.setText(mOpenstreetmapUtil instanceof OpenstreetmapRemoteUtil
									? R.string.shared_string_upload : R.string.shared_string_save);
						}

						return false;
					}
				}, getActivity(), mOpenstreetmapUtil);
	}

	private void dismissCheckForChanges() {
		if (editPoiData.hasChangesBeenMade()) {
			new AreYouSureDialogFragment().show(getChildFragmentManager(),
					"AreYouSureDialogFragment");
		} else {
			dismiss();
		}
	}

	public EditPoiData getEditPoiData() {
		return editPoiData;
	}

	public void setSubCategory(String subCategory) {
		poiTypeEditText.setText(subCategory);
	}

	public static void commitNode(final OsmPoint.Action action,
								  final Node node,
								  final EntityInfo info,
								  final String comment,
								  final boolean closeChangeSet,
								  final CallbackWithObject<Node> postExecute,
								  final Activity activity,
								  final OpenstreetmapUtil openstreetmapUtil) {
		if (info == null && OsmPoint.Action.CREATE != action && openstreetmapUtil instanceof OpenstreetmapRemoteUtil) {
			Toast.makeText(activity, activity.getResources().getString(R.string.poi_error_info_not_loaded), Toast.LENGTH_LONG).show();
			return;
		}
		new AsyncTask<Void, Void, Node>() {
			ProgressDialog progress;

			@Override
			protected void onPreExecute() {
				progress = ProgressDialog.show(activity, activity.getString(R.string.uploading), activity.getString(R.string.uploading_data));
				super.onPreExecute();
			}

			@Override
			protected Node doInBackground(Void... params) {
				return openstreetmapUtil.commitNodeImpl(action, node, info, comment, closeChangeSet);
			}

			@Override
			protected void onPostExecute(Node result) {
				progress.dismiss();
				if (postExecute != null) {
					postExecute.processResult(result);
				}
			}
		}.execute();
	}

	public void setPoiCategory(PoiCategory type) {
		editPoiData.updateType(type);
		poiTypeEditText.setText(editPoiData.getPoiTypeString());
		setAdapterForPoiTypeEditText();
	}

	private void setAdapterForPoiTypeEditText() {
		final Map<String, PoiType> subCategories = new LinkedHashMap<>();
		PoiCategory ct = editPoiData.getPoiCategory();
		if (ct != null) {
			for (PoiType s : ct.getPoiTypes()) {
				if (!s.isReference() && !s.isNotEditableOsm() && s.getBaseLangType() == null) {
					addMapEntryAdapter(subCategories, s.getTranslation(), s);
					if(!s.getKeyName().contains("osmand")) {
						addMapEntryAdapter(subCategories, s.getKeyName().replace('_', ' '), s);
					}
				}
			}
		}
		for (Map.Entry<String, PoiType> s : editPoiData.getAllTranslatedSubTypes().entrySet()) {
			addMapEntryAdapter(subCategories, s.getKey(), s.getValue());
		}
		final ArrayAdapter<Object> adapter;
		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
			adapter = new ArrayAdapter<>(getActivity(),
					R.layout.list_textview, subCategories.keySet().toArray());
		} else {
			TypedValue typedValue = new TypedValue();
			Resources.Theme theme = getActivity().getTheme();
			theme.resolveAttribute(android.R.attr.textColorSecondary, typedValue, true);
			final int textColor = typedValue.data;

			adapter = new ArrayAdapter<Object>(getActivity(),
					R.layout.list_textview, subCategories.keySet().toArray()) {
				@Override
				public View getView(int position, View convertView, ViewGroup parent) {
					final View view = super.getView(position, convertView, parent);
					((TextView) view.findViewById(R.id.textView)).setTextColor(textColor);
					return view;
				}
			};
		}
		adapter.sort(new Comparator<Object>() {
			@Override
			public int compare(Object lhs, Object rhs) {
				return lhs.toString().compareTo(rhs.toString());
			}
		});
		poiTypeEditText.setAdapter(adapter);
		poiTypeEditText.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {

			@Override
			public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
				Object item = parent.getAdapter().getItem(position);
				poiTypeEditText.setText(item.toString());
				setAdapterForPoiTypeEditText();
			}

			@Override
			public void onNothingSelected(AdapterView<?> parent) {
			}
		});

	}

	private void addMapEntryAdapter(final Map<String, PoiType> subCategories, String key, PoiType v) {
		if (!subCategories.containsKey(key.toLowerCase())) {
			subCategories.put(Algorithms.capitalizeFirstLetterAndLowercase(key), v);
		}
	}

	public static EditPoiDialogFragment createAddPoiInstance(double latitude, double longitude,
															 OsmandApplication application) {
		Node node = new Node(latitude, longitude, -1);
		return createInstance(node, true);
	}

	public static EditPoiDialogFragment createInstance(Node node, boolean isAddingPoi) {
		EditPoiDialogFragment editPoiDialogFragment = new EditPoiDialogFragment();
		Bundle args = new Bundle();
		args.putSerializable(KEY_AMENITY_NODE, node);
		args.putBoolean(IS_ADDING_POI, isAddingPoi);
		editPoiDialogFragment.setArguments(args);
		return editPoiDialogFragment;
	}

	public static EditPoiDialogFragment createInstance(Node node, boolean isAddingPoi, Map<String, String> tagList) {
		EditPoiDialogFragment editPoiDialogFragment = new EditPoiDialogFragment();
		Bundle args = new Bundle();
		args.putSerializable(KEY_AMENITY_NODE, node);
		args.putBoolean(IS_ADDING_POI, isAddingPoi);
		args.putSerializable(TAGS_LIST, (Serializable) Collections.unmodifiableMap(tagList));
		editPoiDialogFragment.setArguments(args);
		return editPoiDialogFragment;
	}

	public static void showEditInstance(final Amenity amenity,
										final AppCompatActivity activity) {
		final OsmandSettings settings = ((OsmandApplication) activity.getApplication())
				.getSettings();
		final OpenstreetmapUtil openstreetmapUtilToLoad;
		OsmEditingPlugin plugin = OsmandPlugin.getPlugin(OsmEditingPlugin.class);
		if (//settings.OFFLINE_EDITION.get() ||
				!settings.isInternetConnectionAvailable(true)) {
			openstreetmapUtilToLoad = plugin.getPoiModificationLocalUtil();
		} else {
			openstreetmapUtilToLoad = plugin.getPoiModificationRemoteUtil();
		}
		new AsyncTask<Void, Void, Node>() {
			@Override
			protected Node doInBackground(Void... params) {
				return openstreetmapUtilToLoad.loadNode(amenity);
			}

			protected void onPostExecute(Node n) {
				if (n != null) {
					EditPoiDialogFragment fragment =
							EditPoiDialogFragment.createInstance(n, false);
					fragment.show(activity.getSupportFragmentManager(), TAG);
				} else {
					Toast.makeText(activity,
							activity.getString(R.string.poi_error_poi_not_found),
							Toast.LENGTH_LONG).show();
				}
			}
		}.execute();
	}

	public static class MyAdapter extends FragmentPagerAdapter {
		private final Fragment[] fragments = new Fragment[]{new BasicEditPoiFragment(),
				new AdvancedEditPoiFragment()};
		private final String[] titles;

		public MyAdapter(FragmentManager fm, String basicTitle, String extendedTitle) {
			super(fm);
			titles = new String[]{basicTitle, extendedTitle};
		}

		@Override
		public int getCount() {
			return 2;
		}

		@Override
		public Fragment getItem(int position) {
			return fragments[position];
		}

		@Override
		public CharSequence getPageTitle(int position) {
			return titles[position];
		}
	}

	public static class ShowDeleteDialogAsyncTask extends AsyncTask<Amenity, Void, Node> {
		private final OpenstreetmapUtil openstreetmapUtil;
		private final AppCompatActivity activity;

		public ShowDeleteDialogAsyncTask(AppCompatActivity activity) {
			this.activity = activity;
			OsmandSettings settings = ((OsmandApplication) activity.getApplication()).getSettings();
			OsmEditingPlugin plugin = OsmandPlugin.getPlugin(OsmEditingPlugin.class);
			if (settings.OFFLINE_EDITION.get() || !settings.isInternetConnectionAvailable(true)) {
				openstreetmapUtil = plugin.getPoiModificationLocalUtil();
			} else {
				openstreetmapUtil = plugin.getPoiModificationRemoteUtil();
			}
		}

		protected Node doInBackground(Amenity[] params) {
			return openstreetmapUtil.loadNode(params[0]);
		}

		protected void onPostExecute(final Node n) {
			if (n == null) {
				Toast.makeText(activity, activity.getResources().getString(R.string.poi_error_poi_not_found), Toast.LENGTH_LONG).show();
				return;
			}
			AlertDialog.Builder builder = new AlertDialog.Builder(activity);
			builder.setTitle(R.string.poi_remove_title);
			final EditText comment;
			final CheckBox closeChangesetCheckBox;
			final boolean isLocalEdit = openstreetmapUtil instanceof OpenstreetmapLocalUtil;
			if (isLocalEdit) {
				closeChangesetCheckBox = null;
				comment = null;
			} else {
				LinearLayout ll = new LinearLayout(activity);
				ll.setPadding(16, 2, 16, 0);
				ll.setOrientation(LinearLayout.VERTICAL);
				closeChangesetCheckBox = new CheckBox(activity);
				closeChangesetCheckBox.setText(R.string.close_changeset);
				ll.addView(closeChangesetCheckBox);
				comment = new EditText(activity);
				comment.setText(R.string.poi_remove_title);
				ll.addView(comment);
				builder.setView(ll);
			}
			builder.setNegativeButton(R.string.shared_string_cancel, null);
			builder.setPositiveButton(isLocalEdit ? R.string.shared_string_save : R.string.shared_string_delete, new DialogInterface.OnClickListener() {
				@Override
				public void onClick(DialogInterface dialog, int which) {
					String c = comment == null ? null : comment.getText().toString();
					boolean closeChangeSet = closeChangesetCheckBox != null
							&& closeChangesetCheckBox.isChecked();
					deleteNode(n, c, closeChangeSet);
				}


			});
			builder.create().show();
		}

		private void deleteNode(final Node n, final String c, final boolean closeChangeSet) {
			final boolean isLocalEdit = openstreetmapUtil instanceof OpenstreetmapLocalUtil;
			commitNode(OsmPoint.Action.DELETE, n, openstreetmapUtil.getEntityInfo(n.getId()), c, closeChangeSet,
					new CallbackWithObject<Node>() {

						@Override
						public boolean processResult(Node result) {
							if (result != null) {
								if (isLocalEdit) {
									Toast.makeText(activity, R.string.osm_changes_added_to_local_edits,
											Toast.LENGTH_LONG).show();
								} else {
									Toast.makeText(activity, R.string.poi_remove_success, Toast.LENGTH_LONG)
											.show();
								}
								if (activity instanceof MapActivity) {
									((MapActivity) activity).getMapView().refreshMap(true);
								}
							}
							return false;
						}
					}, activity, openstreetmapUtil);
		}
	}

	public static class SaveExtraValidationDialogFragment extends DialogFragment {
		@NonNull
		@Override
		public Dialog onCreateDialog(Bundle savedInstanceState) {
			AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
			String msg = getString(R.string.save_poi_without_poi_type_message);
			int i = getArguments().getInt("message", 0);
			if(i != 0) {
				msg = getString(i);
			}
			builder.setTitle(getResources().getString(R.string.are_you_sure))
					.setMessage(msg)
					.setPositiveButton(R.string.shared_string_ok, new DialogInterface.OnClickListener() {
						@Override
						public void onClick(DialogInterface dialog, int which) {
							((EditPoiDialogFragment) getParentFragment()).save();
						}
					})
					.setNegativeButton(R.string.shared_string_cancel, null);
			return builder.create();
		}
	}

	public static class AreYouSureDialogFragment extends DialogFragment {
		@NonNull
		@Override
		public Dialog onCreateDialog(Bundle savedInstanceState) {
			AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
			builder.setTitle(getResources().getString(R.string.are_you_sure))
					.setMessage(getString(R.string.unsaved_changes_will_be_lost))
					.setPositiveButton(R.string.shared_string_ok, new DialogInterface.OnClickListener() {
						@Override
						public void onClick(DialogInterface dialog, int which) {
							((DialogFragment) getParentFragment()).dismiss();
						}
					})
					.setNegativeButton(R.string.shared_string_cancel, null);
			return builder.create();
		}
	}

	private TextView.OnEditorActionListener mOnEditorActionListener =
			new TextView.OnEditorActionListener() {
				@Override
				public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
					boolean handled = false;
					if (actionId == EditorInfo.IME_ACTION_SEND) {
						trySave();
						handled = true;
					}
					return handled;
				}
			};

	public interface OnFragmentActivatedListener {
		void onFragmentActivated();
	}
}
!@#$%
20190530_062613,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_c06248
package net.osmand.plus.osmedit;

import android.app.Activity;
import android.app.Dialog;
import android.app.ProgressDialog;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.res.Resources;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Build;
import android.os.Bundle;
import android.support.annotation.NonNull;
import android.support.design.widget.TabLayout;
import android.support.design.widget.TextInputLayout;
import android.support.v4.app.DialogFragment;
import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentManager;
import android.support.v4.app.FragmentPagerAdapter;
import android.support.v4.app.FragmentTransaction;
import android.support.v4.view.ViewCompat;
import android.support.v4.view.ViewPager;
import android.support.v7.app.AlertDialog;
import android.support.v7.app.AppCompatActivity;
import android.support.v7.widget.Toolbar;
import android.text.Editable;
import android.text.TextUtils;
import android.text.TextWatcher;
import android.util.TypedValue;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.view.ViewTreeObserver;
import android.view.WindowManager;
import android.view.inputmethod.EditorInfo;
import android.widget.AdapterView;
import android.widget.ArrayAdapter;
import android.widget.AutoCompleteTextView;
import android.widget.Button;
import android.widget.CheckBox;
import android.widget.EditText;
import android.widget.ImageButton;
import android.widget.LinearLayout;
import android.widget.TextView;
import android.widget.Toast;

import net.osmand.CallbackWithObject;
import net.osmand.PlatformUtil;
import net.osmand.data.Amenity;
import net.osmand.data.LatLon;
import net.osmand.osm.PoiCategory;
import net.osmand.osm.PoiType;
import net.osmand.osm.edit.EntityInfo;
import net.osmand.osm.edit.Node;
import net.osmand.osm.edit.OSMSettings;
import net.osmand.plus.OsmandApplication;
import net.osmand.plus.OsmandPlugin;
import net.osmand.plus.OsmandSettings;
import net.osmand.plus.R;
import net.osmand.plus.activities.MapActivity;
import net.osmand.plus.base.BaseOsmAndDialogFragment;
import net.osmand.plus.osmedit.dialogs.PoiSubTypeDialogFragment;
import net.osmand.plus.osmedit.dialogs.PoiTypeDialogFragment;
import net.osmand.util.Algorithms;

import org.apache.commons.logging.Log;

import java.io.Serializable;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

public class EditPoiDialogFragment extends BaseOsmAndDialogFragment {
	public static final String TAG = "EditPoiDialogFragment";
	private static final Log LOG = PlatformUtil.getLog(EditPoiDialogFragment.class);

	private static final String KEY_AMENITY_NODE = "key_amenity_node";
	private static final String TAGS_LIST = "tags_list";
	private static final String IS_ADDING_POI = "is_adding_poi";

	public static final HashSet<String> BASIC_TAGS = new HashSet<String>() ;
	static {
		BASIC_TAGS.add(OSMSettings.OSMTagKey.NAME.getValue());
		BASIC_TAGS.add(OSMSettings.OSMTagKey.ADDR_STREET.getValue());
		BASIC_TAGS.add(OSMSettings.OSMTagKey.ADDR_HOUSE_NUMBER.getValue());
		BASIC_TAGS.add(OSMSettings.OSMTagKey.PHONE.getValue());
		BASIC_TAGS.add(OSMSettings.OSMTagKey.WEBSITE.getValue());
		BASIC_TAGS.add(OSMSettings.OSMTagKey.OPENING_HOURS.getValue());
	}

	private EditPoiData editPoiData;
	private ViewPager viewPager;
	private AutoCompleteTextView poiTypeEditText;

	private OpenstreetmapUtil mOpenstreetmapUtil;
	private TextInputLayout poiTypeTextInputLayout;
	private View view;

	@Override
	public void onAttach(Activity activity) {
		super.onAttach(activity);
		OsmEditingPlugin plugin = OsmandPlugin.getPlugin(OsmEditingPlugin.class);
		if (getSettings().OFFLINE_EDITION.get()
				|| !getSettings().isInternetConnectionAvailable(true)) {
			mOpenstreetmapUtil = plugin.getPoiModificationLocalUtil();
		} else {
			mOpenstreetmapUtil = plugin.getPoiModificationRemoteUtil();
		}

		Node node = (Node) getArguments().getSerializable(KEY_AMENITY_NODE);
		editPoiData = new EditPoiData(node, getMyApplication());
	}

	@Override
	public View onCreateView(LayoutInflater inflater, ViewGroup container,
							 Bundle savedInstanceState) {
		view = inflater.inflate(R.layout.fragment_edit_poi, container, false);
		boolean isLightTheme = getSettings().OSMAND_THEME.get() == OsmandSettings.OSMAND_LIGHT_THEME;

		if (savedInstanceState != null) {
			@SuppressWarnings("unchecked")
			Map<String, String> mp = (Map<String, String>) savedInstanceState.getSerializable(TAGS_LIST);
			editPoiData.updateTags(mp);
		}

		boolean isAddingPoi = getArguments().getBoolean(IS_ADDING_POI);

		Toolbar toolbar = (Toolbar) view.findViewById(R.id.toolbar);
		toolbar.setTitle(isAddingPoi ? R.string.poi_create_title : R.string.poi_edit_title);
		toolbar.setNavigationIcon(R.drawable.ic_arrow_back);
		toolbar.setNavigationContentDescription(R.string.access_shared_string_navigate_up);
		toolbar.setNavigationOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				dismissCheckForChanges();
			}
		});

		viewPager = (ViewPager) view.findViewById(R.id.viewpager);
		String basicTitle = getResources().getString(R.string.tab_title_basic);
		String extendedTitle = getResources().getString(R.string.tab_title_advanced);
		final MyAdapter pagerAdapter = new MyAdapter(getChildFragmentManager(), basicTitle, extendedTitle);
		viewPager.setAdapter(pagerAdapter);
		viewPager.addOnPageChangeListener(new ViewPager.OnPageChangeListener() {
			@Override
			public void onPageScrolled(int i, float v, int i1) {

			}

			@Override
			public void onPageSelected(int i) {
				((OnFragmentActivatedListener) pagerAdapter.getItem(i)).onFragmentActivated();
			}

			@Override
			public void onPageScrollStateChanged(int i) {

			}
		});

		final TabLayout tabLayout = (TabLayout) view.findViewById(R.id.tab_layout);
		tabLayout.setTabMode(TabLayout.MODE_SCROLLABLE);

		// tabLayout.setupWithViewPager(viewPager);
		// Hack due to bug in design support library v22.2.1
		// https://code.google.com/p/android/issues/detail?id=180462
		// TODO remove in new version
		if (Build.VERSION.SDK_INT >= 11) {
			if (ViewCompat.isLaidOut(tabLayout)) {
				tabLayout.setupWithViewPager(viewPager);
			} else {
				tabLayout.addOnLayoutChangeListener(new View.OnLayoutChangeListener() {
					@Override
					public void onLayoutChange(View v, int left, int top, int right, int bottom,
											   int oldLeft, int oldTop, int oldRight, int oldBottom) {
						tabLayout.setupWithViewPager(viewPager);
						tabLayout.removeOnLayoutChangeListener(this);
					}
				});
			}
		} else {
			ViewTreeObserver vto = view.getViewTreeObserver();
			vto.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {

				@Override
				public void onGlobalLayout() {

					ViewTreeObserver obs = view.getViewTreeObserver();
					if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
						obs.removeGlobalOnLayoutListener(this);
					}

					if (getActivity() != null) {
						tabLayout.setupWithViewPager(viewPager);
					}
				}
			});
		}

		ImageButton onlineDocumentationButton =
				(ImageButton) view.findViewById(R.id.onlineDocumentationButton);
		onlineDocumentationButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				getActivity().startActivity(new Intent(Intent.ACTION_VIEW,
						Uri.parse("https://wiki.openstreetmap.org/wiki/Map_Features")));
			}
		});

		final int colorId = isLightTheme ? R.color.inactive_item_orange : R.color.dash_search_icon_dark;
		final int color = getResources().getColor(colorId);
		onlineDocumentationButton.setImageDrawable(getPaintedContentIcon(R.drawable.ic_action_help, color));
		final ImageButton poiTypeButton = (ImageButton) view.findViewById(R.id.poiTypeButton);
		poiTypeButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				PoiTypeDialogFragment fragment = PoiTypeDialogFragment.createInstance();
				fragment.setOnItemSelectListener(new PoiTypeDialogFragment.OnItemSelectListener() {
					@Override
					public void select(PoiCategory poiCategory) {
						setPoiCategory(poiCategory);
					}
				});
				fragment.show(getChildFragmentManager(), "PoiTypeDialogFragment");
			}
		});

		EditText poiNameEditText = (EditText) view.findViewById(R.id.poiNameEditText);
		poiNameEditText.addTextChangedListener(new TextWatcher() {
			@Override
			public void beforeTextChanged(CharSequence s, int start, int count, int after) {
			}

			@Override
			public void onTextChanged(CharSequence s, int start, int before, int count) {
			}

			@Override
			public void afterTextChanged(Editable s) {
				if (!getEditPoiData().isInEdit()) {
					if (!TextUtils.isEmpty(s)) {
						getEditPoiData().putTag(OSMSettings.OSMTagKey.NAME.getValue(),
								s.toString());
					} else {
						getEditPoiData().removeTag(OSMSettings.OSMTagKey.NAME.getValue());
					}
				}
			}
		});
		poiNameEditText.setText(editPoiData.getTag(OSMSettings.OSMTagKey.NAME.getValue()));
		poiTypeTextInputLayout = (TextInputLayout) view.findViewById(R.id.poiTypeTextInputLayout);
		poiTypeEditText = (AutoCompleteTextView) view.findViewById(R.id.poiTypeEditText);
		poiTypeEditText.addTextChangedListener(new TextWatcher() {
			@Override
			public void beforeTextChanged(CharSequence s, int start, int count, int after) {
			}

			@Override
			public void onTextChanged(CharSequence s, int start, int before, int count) {
			}

			@Override
			public void afterTextChanged(Editable s) {
				if (!getEditPoiData().isInEdit()) {
					getEditPoiData().updateTypeTag(s.toString());
					poiTypeTextInputLayout.setHint(editPoiData.getPoiCategory().getTranslation());
				}
			}
		});
		poiNameEditText.setOnEditorActionListener(mOnEditorActionListener);
		poiTypeEditText.setOnEditorActionListener(mOnEditorActionListener);
		poiTypeEditText.setText(editPoiData.getPoiTypeString());
		poiTypeEditText.setOnTouchListener(new View.OnTouchListener() {
			@Override
			public boolean onTouch(final View v, MotionEvent event) {
				final EditText editText = (EditText) v;
				final int DRAWABLE_RIGHT = 2;
				if (event.getAction() == MotionEvent.ACTION_UP) {
					if (event.getX() >= (editText.getRight()
							- editText.getCompoundDrawables()[DRAWABLE_RIGHT].getBounds().width()
							- editText.getPaddingRight())) {
						if (editPoiData.getPoiCategory() != null) {
							PoiSubTypeDialogFragment dialogFragment =
									PoiSubTypeDialogFragment.createInstance(editPoiData.getPoiCategory());
							dialogFragment.setOnItemSelectListener(new PoiSubTypeDialogFragment.OnItemSelectListener() {
								@Override
								public void select(String category) {
									setSubCategory(category);
								}
							});
							dialogFragment.show(getChildFragmentManager(), "PoiSubTypeDialogFragment");
						}

						return true;
					}
				}
				return false;
			}
		});

		Button saveButton = (Button) view.findViewById(R.id.saveButton);
		saveButton.setText(mOpenstreetmapUtil instanceof OpenstreetmapRemoteUtil
				? R.string.shared_string_upload : R.string.shared_string_save);
		saveButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				trySave();
			}
		});
		Button cancelButton = (Button) view.findViewById(R.id.cancelButton);
		cancelButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				dismissCheckForChanges();
			}
		});
		setAdapterForPoiTypeEditText();
		setCancelable(false);
		return view;
	}

	@NonNull
	@Override
	public Dialog onCreateDialog(Bundle savedInstanceState) {
		final Dialog dialog = super.onCreateDialog(savedInstanceState);
		dialog.getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE);
		return dialog;
	}

	@Override
	public void onResume() {
		super.onResume();
		getDialog().setOnKeyListener(new DialogInterface.OnKeyListener() {
			@Override
			public boolean onKey(DialogInterface dialog, int keyCode, KeyEvent event) {
				if (keyCode == android.view.KeyEvent.KEYCODE_BACK) {
					if (event.getAction() == KeyEvent.ACTION_DOWN) {
						return true;
					} else {
						dismissCheckForChanges();
						return true;
					}
				}
				return false;
			}
		});
	}

	@Override
	public void onSaveInstanceState(Bundle outState) {
		outState.putSerializable(TAGS_LIST, (Serializable) editPoiData.getTagValues());
		super.onSaveInstanceState(outState);
	}

	@Override
	public void show(FragmentManager manager, String tag) {
		if (manager.findFragmentByTag(TAG) == null) {
			super.show(manager, TAG);
		}
	}

	@Override
	public int show(FragmentTransaction transaction, String tag) {
		throw new UnsupportedOperationException("Please use show(FragmentManager manager, String tag)");
	}

	private void trySave() {
		if (TextUtils.isEmpty(poiTypeEditText.getText())) {
			HashSet<String> tagsCopy = new HashSet<>();
			tagsCopy.addAll(editPoiData.getTagValues().keySet());
			if (Algorithms.isEmpty(editPoiData.getTag(OSMSettings.OSMTagKey.ADDR_HOUSE_NUMBER.getValue()))) {
				SaveExtraValidationDialogFragment f = new SaveExtraValidationDialogFragment();
				Bundle args = new Bundle();
				args.putInt("message", R.string.save_poi_without_poi_type_message);
				f.setArguments(args);
				f.show(getChildFragmentManager(), "dialog");
				// poiTypeEditText.setError(getResources().getString(R.string.please_specify_poi_type));
			} else {
				save();
			}
		} else if (testTooManyCapitalLetters(editPoiData.getTag(OSMSettings.OSMTagKey.NAME.getValue()))) {
			SaveExtraValidationDialogFragment f = new SaveExtraValidationDialogFragment();
			Bundle args = new Bundle();
			args.putInt("message", R.string.save_poi_too_many_uppercase);
			f.setArguments(args);
			f.show(getChildFragmentManager(), "dialog");			
		} else if (editPoiData.getPoiCategory() == getMyApplication().getPoiTypes().getOtherPoiCategory()) {
			poiTypeEditText.setError(getResources().getString(R.string.please_specify_poi_type));
		} else if (editPoiData.getPoiTypeDefined() == null) {
			poiTypeEditText.setError(getResources().getString(R.string.please_specify_poi_type_only_from_list));
		} else {
			save();
		}
	}

	private boolean testTooManyCapitalLetters(String name) {
		if(name == null) {
			return false;
		}
		int capital = 0;
		int lower = 0;
		int nonalpha = 0;
		for(int i = 0; i < name.length(); i++) {
			char c = name.charAt(i);
			if(Character.isLetter(c) || Character.getType(c) == Character.LETTER_NUMBER) {
				if(Character.isUpperCase(c)) {
					capital ++;
				} else {
					lower ++;
				}
			} else {
				nonalpha ++;
			}
		}
		return capital > nonalpha && capital > lower;
	}

	private void save() {
		Node original = editPoiData.getEntity();
		final boolean offlineEdit = mOpenstreetmapUtil instanceof OpenstreetmapLocalUtil;
		Node node = new Node(original.getLatitude(), original.getLongitude(), original.getId());
		OsmPoint.Action action = node.getId() < 0 ? OsmPoint.Action.CREATE : OsmPoint.Action.MODIFY;
		for (Map.Entry<String, String> tag : editPoiData.getTagValues().entrySet()) {
			if (!Algorithms.isEmpty(tag.getKey()) && !Algorithms.isEmpty(tag.getValue()) && 
					!tag.getKey().equals(EditPoiData.POI_TYPE_TAG)) {
				node.putTagNoLC(tag.getKey(), tag.getValue());
			}
		}
		String poiTypeTag = editPoiData.getTagValues().get(EditPoiData.POI_TYPE_TAG);
		String comment = "";
		if (poiTypeTag != null) {
			final PoiType poiType = editPoiData.getAllTranslatedSubTypes().get(poiTypeTag.trim().toLowerCase());
			if (poiType != null) {
				node.putTagNoLC(poiType.getOsmTag(), poiType.getOsmValue());
				node.removeTag(EditPoiData.REMOVE_TAG_PREFIX + poiType.getOsmTag());
				if (poiType.getOsmTag2() != null) {
					node.putTagNoLC(poiType.getOsmTag2(), poiType.getOsmValue2());
					node.removeTag(EditPoiData.REMOVE_TAG_PREFIX + poiType.getOsmTag2());
				}
			} else if (!Algorithms.isEmpty(poiTypeTag)) {
				node.putTagNoLC(editPoiData.getPoiCategory().getDefaultTag(), poiTypeTag);

			}
			if (offlineEdit && !Algorithms.isEmpty(poiTypeTag)) {
				node.putTagNoLC(EditPoiData.POI_TYPE_TAG, poiTypeTag);
			}
			String actionString = action == OsmPoint.Action.CREATE ? getString(R.string.default_changeset_add) : getString(R.string.default_changeset_edit);
			comment = actionString + " " + poiTypeTag;
		}
		commitNode(action, node, mOpenstreetmapUtil.getEntityInfo(node.getId()), comment, false,
				new CallbackWithObject<Node>() {

					@Override
					public boolean processResult(Node result) {
						if (result != null) {
							OsmEditingPlugin plugin = OsmandPlugin.getPlugin(OsmEditingPlugin.class);
							if (plugin != null && offlineEdit) {
								List<OpenstreetmapPoint> points = plugin.getDBPOI().getOpenstreetmapPoints();
								if (getActivity() instanceof MapActivity && points.size() > 0) {
									OsmPoint point = points.get(points.size() - 1);
									MapActivity mapActivity = (MapActivity) getActivity();
									mapActivity.getContextMenu().showOrUpdate(
											new LatLon(point.getLatitude(), point.getLongitude()),
											plugin.getOsmEditsLayer(mapActivity).getObjectName(point), point);
								}
							}

							if (getActivity() instanceof MapActivity) {
								((MapActivity) getActivity()).getMapView().refreshMap(true);
							}
							dismiss();
						} else {
							OsmEditingPlugin plugin = OsmandPlugin.getPlugin(OsmEditingPlugin.class);
							mOpenstreetmapUtil = plugin.getPoiModificationLocalUtil();
							Button saveButton = (Button) view.findViewById(R.id.saveButton);
							saveButton.setText(mOpenstreetmapUtil instanceof OpenstreetmapRemoteUtil
									? R.string.shared_string_upload : R.string.shared_string_save);
						}

						return false;
					}
				}, getActivity(), mOpenstreetmapUtil);
	}

	private void dismissCheckForChanges() {
		if (editPoiData.hasChangesBeenMade()) {
			new AreYouSureDialogFragment().show(getChildFragmentManager(),
					"AreYouSureDialogFragment");
		} else {
			dismiss();
		}
	}

	public EditPoiData getEditPoiData() {
		return editPoiData;
	}

	public void setSubCategory(String subCategory) {
		poiTypeEditText.setText(subCategory);
	}

	public static void commitNode(final OsmPoint.Action action,
								  final Node node,
								  final EntityInfo info,
								  final String comment,
								  final boolean closeChangeSet,
								  final CallbackWithObject<Node> postExecute,
								  final Activity activity,
								  final OpenstreetmapUtil openstreetmapUtil) {
		if (info == null && OsmPoint.Action.CREATE != action && openstreetmapUtil instanceof OpenstreetmapRemoteUtil) {
			Toast.makeText(activity, activity.getResources().getString(R.string.poi_error_info_not_loaded), Toast.LENGTH_LONG).show();
			return;
		}
		new AsyncTask<Void, Void, Node>() {
			ProgressDialog progress;

			@Override
			protected void onPreExecute() {
				progress = ProgressDialog.show(activity, activity.getString(R.string.uploading), activity.getString(R.string.uploading_data));
				super.onPreExecute();
			}

			@Override
			protected Node doInBackground(Void... params) {
				return openstreetmapUtil.commitNodeImpl(action, node, info, comment, closeChangeSet);
			}

			@Override
			protected void onPostExecute(Node result) {
				progress.dismiss();
				if (postExecute != null) {
					postExecute.processResult(result);
				}
			}
		}.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
	}

	public void setPoiCategory(PoiCategory type) {
		editPoiData.updateType(type);
		poiTypeEditText.setText(editPoiData.getPoiTypeString());
		setAdapterForPoiTypeEditText();
	}

	private void setAdapterForPoiTypeEditText() {
		final Map<String, PoiType> subCategories = new LinkedHashMap<>();
		PoiCategory ct = editPoiData.getPoiCategory();
		if (ct != null) {
			for (PoiType s : ct.getPoiTypes()) {
				if (!s.isReference() && !s.isNotEditableOsm() && s.getBaseLangType() == null) {
					addMapEntryAdapter(subCategories, s.getTranslation(), s);
					if(!s.getKeyName().contains("osmand")) {
						addMapEntryAdapter(subCategories, s.getKeyName().replace('_', ' '), s);
					}
				}
			}
		}
		for (Map.Entry<String, PoiType> s : editPoiData.getAllTranslatedSubTypes().entrySet()) {
			addMapEntryAdapter(subCategories, s.getKey(), s.getValue());
		}
		final ArrayAdapter<Object> adapter;
		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
			adapter = new ArrayAdapter<>(getActivity(),
					R.layout.list_textview, subCategories.keySet().toArray());
		} else {
			TypedValue typedValue = new TypedValue();
			Resources.Theme theme = getActivity().getTheme();
			theme.resolveAttribute(android.R.attr.textColorSecondary, typedValue, true);
			final int textColor = typedValue.data;

			adapter = new ArrayAdapter<Object>(getActivity(),
					R.layout.list_textview, subCategories.keySet().toArray()) {
				@Override
				public View getView(int position, View convertView, ViewGroup parent) {
					final View view = super.getView(position, convertView, parent);
					((TextView) view.findViewById(R.id.textView)).setTextColor(textColor);
					return view;
				}
			};
		}
		adapter.sort(new Comparator<Object>() {
			@Override
			public int compare(Object lhs, Object rhs) {
				return lhs.toString().compareTo(rhs.toString());
			}
		});
		poiTypeEditText.setAdapter(adapter);
		poiTypeEditText.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {

			@Override
			public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
				Object item = parent.getAdapter().getItem(position);
				poiTypeEditText.setText(item.toString());
				setAdapterForPoiTypeEditText();
			}

			@Override
			public void onNothingSelected(AdapterView<?> parent) {
			}
		});

	}

	private void addMapEntryAdapter(final Map<String, PoiType> subCategories, String key, PoiType v) {
		if (!subCategories.containsKey(key.toLowerCase())) {
			subCategories.put(Algorithms.capitalizeFirstLetterAndLowercase(key), v);
		}
	}

	public static EditPoiDialogFragment createAddPoiInstance(double latitude, double longitude,
															 OsmandApplication application) {
		Node node = new Node(latitude, longitude, -1);
		return createInstance(node, true);
	}

	public static EditPoiDialogFragment createInstance(Node node, boolean isAddingPoi) {
		EditPoiDialogFragment editPoiDialogFragment = new EditPoiDialogFragment();
		Bundle args = new Bundle();
		args.putSerializable(KEY_AMENITY_NODE, node);
		args.putBoolean(IS_ADDING_POI, isAddingPoi);
		editPoiDialogFragment.setArguments(args);
		return editPoiDialogFragment;
	}

	public static EditPoiDialogFragment createInstance(Node node, boolean isAddingPoi, Map<String, String> tagList) {
		EditPoiDialogFragment editPoiDialogFragment = new EditPoiDialogFragment();
		Bundle args = new Bundle();
		args.putSerializable(KEY_AMENITY_NODE, node);
		args.putBoolean(IS_ADDING_POI, isAddingPoi);
		args.putSerializable(TAGS_LIST, (Serializable) Collections.unmodifiableMap(tagList));
		editPoiDialogFragment.setArguments(args);
		return editPoiDialogFragment;
	}

	public static void showEditInstance(final Amenity amenity,
										final AppCompatActivity activity) {
		final OsmandSettings settings = ((OsmandApplication) activity.getApplication())
				.getSettings();
		final OpenstreetmapUtil openstreetmapUtilToLoad;
		OsmEditingPlugin plugin = OsmandPlugin.getPlugin(OsmEditingPlugin.class);
		if (//settings.OFFLINE_EDITION.get() ||
				!settings.isInternetConnectionAvailable(true)) {
			openstreetmapUtilToLoad = plugin.getPoiModificationLocalUtil();
		} else {
			openstreetmapUtilToLoad = plugin.getPoiModificationRemoteUtil();
		}
		new AsyncTask<Void, Void, Node>() {
			@Override
			protected Node doInBackground(Void... params) {
				return openstreetmapUtilToLoad.loadNode(amenity);
			}

			protected void onPostExecute(Node n) {
				if (n != null) {
					EditPoiDialogFragment fragment =
							EditPoiDialogFragment.createInstance(n, false);
					fragment.show(activity.getSupportFragmentManager(), TAG);
				} else {
					Toast.makeText(activity,
							activity.getString(R.string.poi_error_poi_not_found),
							Toast.LENGTH_LONG).show();
				}
			}
		}.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
	}

	public static class MyAdapter extends FragmentPagerAdapter {
		private final Fragment[] fragments = new Fragment[]{new BasicEditPoiFragment(),
				new AdvancedEditPoiFragment()};
		private final String[] titles;

		public MyAdapter(FragmentManager fm, String basicTitle, String extendedTitle) {
			super(fm);
			titles = new String[]{basicTitle, extendedTitle};
		}

		@Override
		public int getCount() {
			return 2;
		}

		@Override
		public Fragment getItem(int position) {
			return fragments[position];
		}

		@Override
		public CharSequence getPageTitle(int position) {
			return titles[position];
		}
	}

	public static class ShowDeleteDialogAsyncTask extends AsyncTask<Amenity, Void, Node> {
		private final OpenstreetmapUtil openstreetmapUtil;
		private final AppCompatActivity activity;

		public ShowDeleteDialogAsyncTask(AppCompatActivity activity) {
			this.activity = activity;
			OsmandSettings settings = ((OsmandApplication) activity.getApplication()).getSettings();
			OsmEditingPlugin plugin = OsmandPlugin.getPlugin(OsmEditingPlugin.class);
			if (settings.OFFLINE_EDITION.get() || !settings.isInternetConnectionAvailable(true)) {
				openstreetmapUtil = plugin.getPoiModificationLocalUtil();
			} else {
				openstreetmapUtil = plugin.getPoiModificationRemoteUtil();
			}
		}

		protected Node doInBackground(Amenity[] params) {
			return openstreetmapUtil.loadNode(params[0]);
		}

		protected void onPostExecute(final Node n) {
			if (n == null) {
				Toast.makeText(activity, activity.getResources().getString(R.string.poi_error_poi_not_found), Toast.LENGTH_LONG).show();
				return;
			}
			AlertDialog.Builder builder = new AlertDialog.Builder(activity);
			builder.setTitle(R.string.poi_remove_title);
			final EditText comment;
			final CheckBox closeChangesetCheckBox;
			final boolean isLocalEdit = openstreetmapUtil instanceof OpenstreetmapLocalUtil;
			if (isLocalEdit) {
				closeChangesetCheckBox = null;
				comment = null;
			} else {
				LinearLayout ll = new LinearLayout(activity);
				ll.setPadding(16, 2, 16, 0);
				ll.setOrientation(LinearLayout.VERTICAL);
				closeChangesetCheckBox = new CheckBox(activity);
				closeChangesetCheckBox.setText(R.string.close_changeset);
				ll.addView(closeChangesetCheckBox);
				comment = new EditText(activity);
				comment.setText(R.string.poi_remove_title);
				ll.addView(comment);
				builder.setView(ll);
			}
			builder.setNegativeButton(R.string.shared_string_cancel, null);
			builder.setPositiveButton(isLocalEdit ? R.string.shared_string_save : R.string.shared_string_delete, new DialogInterface.OnClickListener() {
				@Override
				public void onClick(DialogInterface dialog, int which) {
					String c = comment == null ? null : comment.getText().toString();
					boolean closeChangeSet = closeChangesetCheckBox != null
							&& closeChangesetCheckBox.isChecked();
					deleteNode(n, c, closeChangeSet);
				}


			});
			builder.create().show();
		}

		private void deleteNode(final Node n, final String c, final boolean closeChangeSet) {
			final boolean isLocalEdit = openstreetmapUtil instanceof OpenstreetmapLocalUtil;
			commitNode(OsmPoint.Action.DELETE, n, openstreetmapUtil.getEntityInfo(n.getId()), c, closeChangeSet,
					new CallbackWithObject<Node>() {

						@Override
						public boolean processResult(Node result) {
							if (result != null) {
								if (isLocalEdit) {
									Toast.makeText(activity, R.string.osm_changes_added_to_local_edits,
											Toast.LENGTH_LONG).show();
								} else {
									Toast.makeText(activity, R.string.poi_remove_success, Toast.LENGTH_LONG)
											.show();
								}
								if (activity instanceof MapActivity) {
									((MapActivity) activity).getMapView().refreshMap(true);
								}
							}
							return false;
						}
					}, activity, openstreetmapUtil);
		}
	}

	public static class SaveExtraValidationDialogFragment extends DialogFragment {
		@NonNull
		@Override
		public Dialog onCreateDialog(Bundle savedInstanceState) {
			AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
			String msg = getString(R.string.save_poi_without_poi_type_message);
			int i = getArguments().getInt("message", 0);
			if(i != 0) {
				msg = getString(i);
			}
			builder.setTitle(getResources().getString(R.string.are_you_sure))
					.setMessage(msg)
					.setPositiveButton(R.string.shared_string_ok, new DialogInterface.OnClickListener() {
						@Override
						public void onClick(DialogInterface dialog, int which) {
							((EditPoiDialogFragment) getParentFragment()).save();
						}
					})
					.setNegativeButton(R.string.shared_string_cancel, null);
			return builder.create();
		}
	}

	public static class AreYouSureDialogFragment extends DialogFragment {
		@NonNull
		@Override
		public Dialog onCreateDialog(Bundle savedInstanceState) {
			AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
			builder.setTitle(getResources().getString(R.string.are_you_sure))
					.setMessage(getString(R.string.unsaved_changes_will_be_lost))
					.setPositiveButton(R.string.shared_string_ok, new DialogInterface.OnClickListener() {
						@Override
						public void onClick(DialogInterface dialog, int which) {
							((DialogFragment) getParentFragment()).dismiss();
						}
					})
					.setNegativeButton(R.string.shared_string_cancel, null);
			return builder.create();
		}
	}

	private TextView.OnEditorActionListener mOnEditorActionListener =
			new TextView.OnEditorActionListener() {
				@Override
				public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
					boolean handled = false;
					if (actionId == EditorInfo.IME_ACTION_SEND) {
						trySave();
						handled = true;
					}
					return handled;
				}
			};

	public interface OnFragmentActivatedListener {
		void onFragmentActivated();
	}
}
!@#$%
20190530_062733,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_b03008
package net.osmand.plus.osmedit;

import android.app.Activity;
import android.app.Dialog;
import android.app.ProgressDialog;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.res.Resources;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Build;
import android.os.Bundle;
import android.support.annotation.NonNull;
import android.support.design.widget.TabLayout;
import android.support.design.widget.TextInputLayout;
import android.support.v4.app.DialogFragment;
import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentManager;
import android.support.v4.app.FragmentPagerAdapter;
import android.support.v4.app.FragmentTransaction;
import android.support.v4.view.ViewCompat;
import android.support.v4.view.ViewPager;
import android.support.v7.app.AlertDialog;
import android.support.v7.app.AppCompatActivity;
import android.support.v7.widget.Toolbar;
import android.text.Editable;
import android.text.TextUtils;
import android.text.TextWatcher;
import android.util.TypedValue;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.view.ViewTreeObserver;
import android.view.WindowManager;
import android.view.inputmethod.EditorInfo;
import android.widget.AdapterView;
import android.widget.ArrayAdapter;
import android.widget.AutoCompleteTextView;
import android.widget.Button;
import android.widget.CheckBox;
import android.widget.EditText;
import android.widget.ImageButton;
import android.widget.LinearLayout;
import android.widget.TextView;
import android.widget.Toast;

import net.osmand.CallbackWithObject;
import net.osmand.PlatformUtil;
import net.osmand.data.Amenity;
import net.osmand.data.LatLon;
import net.osmand.osm.PoiCategory;
import net.osmand.osm.PoiType;
import net.osmand.osm.edit.EntityInfo;
import net.osmand.osm.edit.Node;
import net.osmand.osm.edit.OSMSettings;
import net.osmand.plus.OsmandApplication;
import net.osmand.plus.OsmandPlugin;
import net.osmand.plus.OsmandSettings;
import net.osmand.plus.R;
import net.osmand.plus.activities.MapActivity;
import net.osmand.plus.base.BaseOsmAndDialogFragment;
import net.osmand.plus.osmedit.dialogs.PoiSubTypeDialogFragment;
import net.osmand.plus.osmedit.dialogs.PoiTypeDialogFragment;
import net.osmand.util.Algorithms;

import org.apache.commons.logging.Log;

import java.io.Serializable;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

public class EditPoiDialogFragment extends BaseOsmAndDialogFragment {
	public static final String TAG = "EditPoiDialogFragment";
	private static final Log LOG = PlatformUtil.getLog(EditPoiDialogFragment.class);

	private static final String KEY_AMENITY_NODE = "key_amenity_node";
	private static final String TAGS_LIST = "tags_list";
	private static final String IS_ADDING_POI = "is_adding_poi";

	public static final HashSet<String> BASIC_TAGS = new HashSet<String>() ;
	static {
		BASIC_TAGS.add(OSMSettings.OSMTagKey.NAME.getValue());
		BASIC_TAGS.add(OSMSettings.OSMTagKey.ADDR_STREET.getValue());
		BASIC_TAGS.add(OSMSettings.OSMTagKey.ADDR_HOUSE_NUMBER.getValue());
		BASIC_TAGS.add(OSMSettings.OSMTagKey.PHONE.getValue());
		BASIC_TAGS.add(OSMSettings.OSMTagKey.WEBSITE.getValue());
		BASIC_TAGS.add(OSMSettings.OSMTagKey.OPENING_HOURS.getValue());
	}

	private EditPoiData editPoiData;
	private ViewPager viewPager;
	private AutoCompleteTextView poiTypeEditText;

	private OpenstreetmapUtil mOpenstreetmapUtil;
	private TextInputLayout poiTypeTextInputLayout;
	private View view;

	@Override
	public void onAttach(Activity activity) {
		super.onAttach(activity);
		OsmEditingPlugin plugin = OsmandPlugin.getPlugin(OsmEditingPlugin.class);
		if (getSettings().OFFLINE_EDITION.get()
				|| !getSettings().isInternetConnectionAvailable(true)) {
			mOpenstreetmapUtil = plugin.getPoiModificationLocalUtil();
		} else {
			mOpenstreetmapUtil = plugin.getPoiModificationRemoteUtil();
		}

		Node node = (Node) getArguments().getSerializable(KEY_AMENITY_NODE);
		editPoiData = new EditPoiData(node, getMyApplication());
	}

	@Override
	public View onCreateView(LayoutInflater inflater, ViewGroup container,
							 Bundle savedInstanceState) {
		view = inflater.inflate(R.layout.fragment_edit_poi, container, false);
		boolean isLightTheme = getSettings().OSMAND_THEME.get() == OsmandSettings.OSMAND_LIGHT_THEME;

		if (savedInstanceState != null) {
			@SuppressWarnings("unchecked")
			Map<String, String> mp = (Map<String, String>) savedInstanceState.getSerializable(TAGS_LIST);
			editPoiData.updateTags(mp);
		}

		boolean isAddingPoi = getArguments().getBoolean(IS_ADDING_POI);

		Toolbar toolbar = (Toolbar) view.findViewById(R.id.toolbar);
		toolbar.setTitle(isAddingPoi ? R.string.poi_create_title : R.string.poi_edit_title);
		toolbar.setNavigationIcon(R.drawable.ic_arrow_back);
		toolbar.setNavigationContentDescription(R.string.access_shared_string_navigate_up);
		toolbar.setNavigationOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				dismissCheckForChanges();
			}
		});

		viewPager = (ViewPager) view.findViewById(R.id.viewpager);
		String basicTitle = getResources().getString(R.string.tab_title_basic);
		String extendedTitle = getResources().getString(R.string.tab_title_advanced);
		final MyAdapter pagerAdapter = new MyAdapter(getChildFragmentManager(), basicTitle, extendedTitle);
		viewPager.setAdapter(pagerAdapter);
		viewPager.addOnPageChangeListener(new ViewPager.OnPageChangeListener() {
			@Override
			public void onPageScrolled(int i, float v, int i1) {

			}

			@Override
			public void onPageSelected(int i) {
				((OnFragmentActivatedListener) pagerAdapter.getItem(i)).onFragmentActivated();
			}

			@Override
			public void onPageScrollStateChanged(int i) {

			}
		});

		final TabLayout tabLayout = (TabLayout) view.findViewById(R.id.tab_layout);
		tabLayout.setTabMode(TabLayout.MODE_SCROLLABLE);

		// tabLayout.setupWithViewPager(viewPager);
		// Hack due to bug in design support library v22.2.1
		// https://code.google.com/p/android/issues/detail?id=180462
		// TODO remove in new version
		if (Build.VERSION.SDK_INT >= 11) {
			if (ViewCompat.isLaidOut(tabLayout)) {
				tabLayout.setupWithViewPager(viewPager);
			} else {
				tabLayout.addOnLayoutChangeListener(new View.OnLayoutChangeListener() {
					@Override
					public void onLayoutChange(View v, int left, int top, int right, int bottom,
											   int oldLeft, int oldTop, int oldRight, int oldBottom) {
						tabLayout.setupWithViewPager(viewPager);
						tabLayout.removeOnLayoutChangeListener(this);
					}
				});
			}
		} else {
			ViewTreeObserver vto = view.getViewTreeObserver();
			vto.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {

				@Override
				public void onGlobalLayout() {

					ViewTreeObserver obs = view.getViewTreeObserver();
					if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
						obs.removeGlobalOnLayoutListener(this);
					}

					if (getActivity() != null) {
						tabLayout.setupWithViewPager(viewPager);
					}
				}
			});
		}

		ImageButton onlineDocumentationButton =
				(ImageButton) view.findViewById(R.id.onlineDocumentationButton);
		onlineDocumentationButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				getActivity().startActivity(new Intent(Intent.ACTION_VIEW,
						Uri.parse("https://wiki.openstreetmap.org/wiki/Map_Features")));
			}
		});

		final int colorId = isLightTheme ? R.color.inactive_item_orange : R.color.dash_search_icon_dark;
		final int color = getResources().getColor(colorId);
		onlineDocumentationButton.setImageDrawable(getPaintedContentIcon(R.drawable.ic_action_help, color));
		final ImageButton poiTypeButton = (ImageButton) view.findViewById(R.id.poiTypeButton);
		poiTypeButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				PoiTypeDialogFragment fragment = PoiTypeDialogFragment.createInstance();
				fragment.setOnItemSelectListener(new PoiTypeDialogFragment.OnItemSelectListener() {
					@Override
					public void select(PoiCategory poiCategory) {
						setPoiCategory(poiCategory);
					}
				});
				fragment.show(getChildFragmentManager(), "PoiTypeDialogFragment");
			}
		});

		EditText poiNameEditText = (EditText) view.findViewById(R.id.poiNameEditText);
		poiNameEditText.addTextChangedListener(new TextWatcher() {
			@Override
			public void beforeTextChanged(CharSequence s, int start, int count, int after) {
			}

			@Override
			public void onTextChanged(CharSequence s, int start, int before, int count) {
			}

			@Override
			public void afterTextChanged(Editable s) {
				if (!getEditPoiData().isInEdit()) {
					if (!TextUtils.isEmpty(s)) {
						getEditPoiData().putTag(OSMSettings.OSMTagKey.NAME.getValue(),
								s.toString());
					} else {
						getEditPoiData().removeTag(OSMSettings.OSMTagKey.NAME.getValue());
					}
				}
			}
		});
		poiNameEditText.setText(editPoiData.getTag(OSMSettings.OSMTagKey.NAME.getValue()));
		poiTypeTextInputLayout = (TextInputLayout) view.findViewById(R.id.poiTypeTextInputLayout);
		poiTypeEditText = (AutoCompleteTextView) view.findViewById(R.id.poiTypeEditText);
		poiTypeEditText.addTextChangedListener(new TextWatcher() {
			@Override
			public void beforeTextChanged(CharSequence s, int start, int count, int after) {
			}

			@Override
			public void onTextChanged(CharSequence s, int start, int before, int count) {
			}

			@Override
			public void afterTextChanged(Editable s) {
				if (!getEditPoiData().isInEdit()) {
					getEditPoiData().updateTypeTag(s.toString());
					if (!getMyApplication().isApplicationInitializing()) {
						poiTypeTextInputLayout.setHint(editPoiData.getPoiCategory().getTranslation());
					}
				}
			}
		});
		poiNameEditText.setOnEditorActionListener(mOnEditorActionListener);
		poiTypeEditText.setOnEditorActionListener(mOnEditorActionListener);
		poiTypeEditText.setText(editPoiData.getPoiTypeString());
		poiTypeEditText.setOnTouchListener(new View.OnTouchListener() {
			@Override
			public boolean onTouch(final View v, MotionEvent event) {
				final EditText editText = (EditText) v;
				final int DRAWABLE_RIGHT = 2;
				if (event.getAction() == MotionEvent.ACTION_UP) {
					if (event.getX() >= (editText.getRight()
							- editText.getCompoundDrawables()[DRAWABLE_RIGHT].getBounds().width()
							- editText.getPaddingRight())) {
						if (editPoiData.getPoiCategory() != null) {
							PoiSubTypeDialogFragment dialogFragment =
									PoiSubTypeDialogFragment.createInstance(editPoiData.getPoiCategory());
							dialogFragment.setOnItemSelectListener(new PoiSubTypeDialogFragment.OnItemSelectListener() {
								@Override
								public void select(String category) {
									setSubCategory(category);
								}
							});
							dialogFragment.show(getChildFragmentManager(), "PoiSubTypeDialogFragment");
						}

						return true;
					}
				}
				return false;
			}
		});

		Button saveButton = (Button) view.findViewById(R.id.saveButton);
		saveButton.setText(mOpenstreetmapUtil instanceof OpenstreetmapRemoteUtil
				? R.string.shared_string_upload : R.string.shared_string_save);
		saveButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				trySave();
			}
		});
		Button cancelButton = (Button) view.findViewById(R.id.cancelButton);
		cancelButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				dismissCheckForChanges();
			}
		});
		setAdapterForPoiTypeEditText();
		setCancelable(false);
		return view;
	}

	@NonNull
	@Override
	public Dialog onCreateDialog(Bundle savedInstanceState) {
		final Dialog dialog = super.onCreateDialog(savedInstanceState);
		dialog.getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE);
		return dialog;
	}

	@Override
	public void onResume() {
		super.onResume();
		getDialog().setOnKeyListener(new DialogInterface.OnKeyListener() {
			@Override
			public boolean onKey(DialogInterface dialog, int keyCode, KeyEvent event) {
				if (keyCode == android.view.KeyEvent.KEYCODE_BACK) {
					if (event.getAction() == KeyEvent.ACTION_DOWN) {
						return true;
					} else {
						dismissCheckForChanges();
						return true;
					}
				}
				return false;
			}
		});
	}

	@Override
	public void onSaveInstanceState(Bundle outState) {
		outState.putSerializable(TAGS_LIST, (Serializable) editPoiData.getTagValues());
		super.onSaveInstanceState(outState);
	}

	@Override
	public void show(FragmentManager manager, String tag) {
		if (manager.findFragmentByTag(TAG) == null) {
			super.show(manager, TAG);
		}
	}

	@Override
	public int show(FragmentTransaction transaction, String tag) {
		throw new UnsupportedOperationException("Please use show(FragmentManager manager, String tag)");
	}

	private void trySave() {
		if (TextUtils.isEmpty(poiTypeEditText.getText())) {
			HashSet<String> tagsCopy = new HashSet<>();
			tagsCopy.addAll(editPoiData.getTagValues().keySet());
			if (Algorithms.isEmpty(editPoiData.getTag(OSMSettings.OSMTagKey.ADDR_HOUSE_NUMBER.getValue()))) {
				SaveExtraValidationDialogFragment f = new SaveExtraValidationDialogFragment();
				Bundle args = new Bundle();
				args.putInt("message", R.string.save_poi_without_poi_type_message);
				f.setArguments(args);
				f.show(getChildFragmentManager(), "dialog");
				// poiTypeEditText.setError(getResources().getString(R.string.please_specify_poi_type));
			} else {
				save();
			}
		} else if (testTooManyCapitalLetters(editPoiData.getTag(OSMSettings.OSMTagKey.NAME.getValue()))) {
			SaveExtraValidationDialogFragment f = new SaveExtraValidationDialogFragment();
			Bundle args = new Bundle();
			args.putInt("message", R.string.save_poi_too_many_uppercase);
			f.setArguments(args);
			f.show(getChildFragmentManager(), "dialog");			
		} else if (editPoiData.getPoiCategory() == getMyApplication().getPoiTypes().getOtherPoiCategory()) {
			poiTypeEditText.setError(getResources().getString(R.string.please_specify_poi_type));
		} else if (editPoiData.getPoiTypeDefined() == null) {
			poiTypeEditText.setError(getResources().getString(R.string.please_specify_poi_type_only_from_list));
		} else {
			save();
		}
	}

	private boolean testTooManyCapitalLetters(String name) {
		if(name == null) {
			return false;
		}
		int capital = 0;
		int lower = 0;
		int nonalpha = 0;
		for(int i = 0; i < name.length(); i++) {
			char c = name.charAt(i);
			if(Character.isLetter(c) || Character.getType(c) == Character.LETTER_NUMBER) {
				if(Character.isUpperCase(c)) {
					capital ++;
				} else {
					lower ++;
				}
			} else {
				nonalpha ++;
			}
		}
		return capital > nonalpha && capital > lower;
	}

	private void save() {
		Node original = editPoiData.getEntity();
		final boolean offlineEdit = mOpenstreetmapUtil instanceof OpenstreetmapLocalUtil;
		Node node = new Node(original.getLatitude(), original.getLongitude(), original.getId());
		OsmPoint.Action action = node.getId() < 0 ? OsmPoint.Action.CREATE : OsmPoint.Action.MODIFY;
		for (Map.Entry<String, String> tag : editPoiData.getTagValues().entrySet()) {
			if (!Algorithms.isEmpty(tag.getKey()) && !Algorithms.isEmpty(tag.getValue()) && 
					!tag.getKey().equals(EditPoiData.POI_TYPE_TAG)) {
				node.putTagNoLC(tag.getKey(), tag.getValue());
			}
		}
		String poiTypeTag = editPoiData.getTagValues().get(EditPoiData.POI_TYPE_TAG);
		String comment = "";
		if (poiTypeTag != null) {
			final PoiType poiType = editPoiData.getAllTranslatedSubTypes().get(poiTypeTag.trim().toLowerCase());
			if (poiType != null) {
				node.putTagNoLC(poiType.getOsmTag(), poiType.getOsmValue());
				node.removeTag(EditPoiData.REMOVE_TAG_PREFIX + poiType.getOsmTag());
				if (poiType.getOsmTag2() != null) {
					node.putTagNoLC(poiType.getOsmTag2(), poiType.getOsmValue2());
					node.removeTag(EditPoiData.REMOVE_TAG_PREFIX + poiType.getOsmTag2());
				}
			} else if (!Algorithms.isEmpty(poiTypeTag)) {
				node.putTagNoLC(editPoiData.getPoiCategory().getDefaultTag(), poiTypeTag);

			}
			if (offlineEdit && !Algorithms.isEmpty(poiTypeTag)) {
				node.putTagNoLC(EditPoiData.POI_TYPE_TAG, poiTypeTag);
			}
			String actionString = action == OsmPoint.Action.CREATE ? getString(R.string.default_changeset_add) : getString(R.string.default_changeset_edit);
			comment = actionString + " " + poiTypeTag;
		}
		commitNode(action, node, mOpenstreetmapUtil.getEntityInfo(node.getId()), comment, false,
				new CallbackWithObject<Node>() {

					@Override
					public boolean processResult(Node result) {
						if (result != null) {
							OsmEditingPlugin plugin = OsmandPlugin.getPlugin(OsmEditingPlugin.class);
							if (plugin != null && offlineEdit) {
								List<OpenstreetmapPoint> points = plugin.getDBPOI().getOpenstreetmapPoints();
								if (getActivity() instanceof MapActivity && points.size() > 0) {
									OsmPoint point = points.get(points.size() - 1);
									MapActivity mapActivity = (MapActivity) getActivity();
									mapActivity.getContextMenu().showOrUpdate(
											new LatLon(point.getLatitude(), point.getLongitude()),
											plugin.getOsmEditsLayer(mapActivity).getObjectName(point), point);
								}
							}

							if (getActivity() instanceof MapActivity) {
								((MapActivity) getActivity()).getMapView().refreshMap(true);
							}
							dismiss();
						} else {
							OsmEditingPlugin plugin = OsmandPlugin.getPlugin(OsmEditingPlugin.class);
							mOpenstreetmapUtil = plugin.getPoiModificationLocalUtil();
							Button saveButton = (Button) view.findViewById(R.id.saveButton);
							saveButton.setText(mOpenstreetmapUtil instanceof OpenstreetmapRemoteUtil
									? R.string.shared_string_upload : R.string.shared_string_save);
						}

						return false;
					}
				}, getActivity(), mOpenstreetmapUtil);
	}

	private void dismissCheckForChanges() {
		if (editPoiData.hasChangesBeenMade()) {
			new AreYouSureDialogFragment().show(getChildFragmentManager(),
					"AreYouSureDialogFragment");
		} else {
			dismiss();
		}
	}

	public EditPoiData getEditPoiData() {
		return editPoiData;
	}

	public void setSubCategory(String subCategory) {
		poiTypeEditText.setText(subCategory);
	}

	public static void commitNode(final OsmPoint.Action action,
								  final Node node,
								  final EntityInfo info,
								  final String comment,
								  final boolean closeChangeSet,
								  final CallbackWithObject<Node> postExecute,
								  final Activity activity,
								  final OpenstreetmapUtil openstreetmapUtil) {
		if (info == null && OsmPoint.Action.CREATE != action && openstreetmapUtil instanceof OpenstreetmapRemoteUtil) {
			Toast.makeText(activity, activity.getResources().getString(R.string.poi_error_info_not_loaded), Toast.LENGTH_LONG).show();
			return;
		}
		new AsyncTask<Void, Void, Node>() {
			ProgressDialog progress;

			@Override
			protected void onPreExecute() {
				progress = ProgressDialog.show(activity, activity.getString(R.string.uploading), activity.getString(R.string.uploading_data));
				super.onPreExecute();
			}

			@Override
			protected Node doInBackground(Void... params) {
				return openstreetmapUtil.commitNodeImpl(action, node, info, comment, closeChangeSet);
			}

			@Override
			protected void onPostExecute(Node result) {
				progress.dismiss();
				if (postExecute != null) {
					postExecute.processResult(result);
				}
			}
		}.execute();
	}

	public void setPoiCategory(PoiCategory type) {
		editPoiData.updateType(type);
		poiTypeEditText.setText(editPoiData.getPoiTypeString());
		setAdapterForPoiTypeEditText();
	}

	private void setAdapterForPoiTypeEditText() {
		final Map<String, PoiType> subCategories = new LinkedHashMap<>();
		PoiCategory ct = editPoiData.getPoiCategory();
		if (ct != null) {
			for (PoiType s : ct.getPoiTypes()) {
				if (!s.isReference() && !s.isNotEditableOsm() && s.getBaseLangType() == null) {
					addMapEntryAdapter(subCategories, s.getTranslation(), s);
					if(!s.getKeyName().contains("osmand")) {
						addMapEntryAdapter(subCategories, s.getKeyName().replace('_', ' '), s);
					}
				}
			}
		}
		for (Map.Entry<String, PoiType> s : editPoiData.getAllTranslatedSubTypes().entrySet()) {
			addMapEntryAdapter(subCategories, s.getKey(), s.getValue());
		}
		final ArrayAdapter<Object> adapter;
		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
			adapter = new ArrayAdapter<>(getActivity(),
					R.layout.list_textview, subCategories.keySet().toArray());
		} else {
			TypedValue typedValue = new TypedValue();
			Resources.Theme theme = getActivity().getTheme();
			theme.resolveAttribute(android.R.attr.textColorSecondary, typedValue, true);
			final int textColor = typedValue.data;

			adapter = new ArrayAdapter<Object>(getActivity(),
					R.layout.list_textview, subCategories.keySet().toArray()) {
				@Override
				public View getView(int position, View convertView, ViewGroup parent) {
					final View view = super.getView(position, convertView, parent);
					((TextView) view.findViewById(R.id.textView)).setTextColor(textColor);
					return view;
				}
			};
		}
		adapter.sort(new Comparator<Object>() {
			@Override
			public int compare(Object lhs, Object rhs) {
				return lhs.toString().compareTo(rhs.toString());
			}
		});
		poiTypeEditText.setAdapter(adapter);
		poiTypeEditText.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {

			@Override
			public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
				Object item = parent.getAdapter().getItem(position);
				poiTypeEditText.setText(item.toString());
				setAdapterForPoiTypeEditText();
			}

			@Override
			public void onNothingSelected(AdapterView<?> parent) {
			}
		});

	}

	private void addMapEntryAdapter(final Map<String, PoiType> subCategories, String key, PoiType v) {
		if (!subCategories.containsKey(key.toLowerCase())) {
			subCategories.put(Algorithms.capitalizeFirstLetterAndLowercase(key), v);
		}
	}

	public static EditPoiDialogFragment createAddPoiInstance(double latitude, double longitude,
															 OsmandApplication application) {
		Node node = new Node(latitude, longitude, -1);
		return createInstance(node, true);
	}

	public static EditPoiDialogFragment createInstance(Node node, boolean isAddingPoi) {
		EditPoiDialogFragment editPoiDialogFragment = new EditPoiDialogFragment();
		Bundle args = new Bundle();
		args.putSerializable(KEY_AMENITY_NODE, node);
		args.putBoolean(IS_ADDING_POI, isAddingPoi);
		editPoiDialogFragment.setArguments(args);
		return editPoiDialogFragment;
	}

	public static EditPoiDialogFragment createInstance(Node node, boolean isAddingPoi, Map<String, String> tagList) {
		EditPoiDialogFragment editPoiDialogFragment = new EditPoiDialogFragment();
		Bundle args = new Bundle();
		args.putSerializable(KEY_AMENITY_NODE, node);
		args.putBoolean(IS_ADDING_POI, isAddingPoi);
		args.putSerializable(TAGS_LIST, (Serializable) Collections.unmodifiableMap(tagList));
		editPoiDialogFragment.setArguments(args);
		return editPoiDialogFragment;
	}

	public static void showEditInstance(final Amenity amenity,
										final AppCompatActivity activity) {
		final OsmandSettings settings = ((OsmandApplication) activity.getApplication())
				.getSettings();
		final OpenstreetmapUtil openstreetmapUtilToLoad;
		OsmEditingPlugin plugin = OsmandPlugin.getPlugin(OsmEditingPlugin.class);
		if (//settings.OFFLINE_EDITION.get() ||
				!settings.isInternetConnectionAvailable(true)) {
			openstreetmapUtilToLoad = plugin.getPoiModificationLocalUtil();
		} else {
			openstreetmapUtilToLoad = plugin.getPoiModificationRemoteUtil();
		}
		new AsyncTask<Void, Void, Node>() {
			@Override
			protected Node doInBackground(Void... params) {
				return openstreetmapUtilToLoad.loadNode(amenity);
			}

			protected void onPostExecute(Node n) {
				if (n != null) {
					EditPoiDialogFragment fragment =
							EditPoiDialogFragment.createInstance(n, false);
					fragment.show(activity.getSupportFragmentManager(), TAG);
				} else {
					Toast.makeText(activity,
							activity.getString(R.string.poi_error_poi_not_found),
							Toast.LENGTH_LONG).show();
				}
			}
		}.execute();
	}

	public static class MyAdapter extends FragmentPagerAdapter {
		private final Fragment[] fragments = new Fragment[]{new BasicEditPoiFragment(),
				new AdvancedEditPoiFragment()};
		private final String[] titles;

		public MyAdapter(FragmentManager fm, String basicTitle, String extendedTitle) {
			super(fm);
			titles = new String[]{basicTitle, extendedTitle};
		}

		@Override
		public int getCount() {
			return 2;
		}

		@Override
		public Fragment getItem(int position) {
			return fragments[position];
		}

		@Override
		public CharSequence getPageTitle(int position) {
			return titles[position];
		}
	}

	public static class ShowDeleteDialogAsyncTask extends AsyncTask<Amenity, Void, Node> {
		private final OpenstreetmapUtil openstreetmapUtil;
		private final AppCompatActivity activity;

		public ShowDeleteDialogAsyncTask(AppCompatActivity activity) {
			this.activity = activity;
			OsmandSettings settings = ((OsmandApplication) activity.getApplication()).getSettings();
			OsmEditingPlugin plugin = OsmandPlugin.getPlugin(OsmEditingPlugin.class);
			if (settings.OFFLINE_EDITION.get() || !settings.isInternetConnectionAvailable(true)) {
				openstreetmapUtil = plugin.getPoiModificationLocalUtil();
			} else {
				openstreetmapUtil = plugin.getPoiModificationRemoteUtil();
			}
		}

		protected Node doInBackground(Amenity[] params) {
			return openstreetmapUtil.loadNode(params[0]);
		}

		protected void onPostExecute(final Node n) {
			if (n == null) {
				Toast.makeText(activity, activity.getResources().getString(R.string.poi_error_poi_not_found), Toast.LENGTH_LONG).show();
				return;
			}
			AlertDialog.Builder builder = new AlertDialog.Builder(activity);
			builder.setTitle(R.string.poi_remove_title);
			final EditText comment;
			final CheckBox closeChangesetCheckBox;
			final boolean isLocalEdit = openstreetmapUtil instanceof OpenstreetmapLocalUtil;
			if (isLocalEdit) {
				closeChangesetCheckBox = null;
				comment = null;
			} else {
				LinearLayout ll = new LinearLayout(activity);
				ll.setPadding(16, 2, 16, 0);
				ll.setOrientation(LinearLayout.VERTICAL);
				closeChangesetCheckBox = new CheckBox(activity);
				closeChangesetCheckBox.setText(R.string.close_changeset);
				ll.addView(closeChangesetCheckBox);
				comment = new EditText(activity);
				comment.setText(R.string.poi_remove_title);
				ll.addView(comment);
				builder.setView(ll);
			}
			builder.setNegativeButton(R.string.shared_string_cancel, null);
			builder.setPositiveButton(isLocalEdit ? R.string.shared_string_save : R.string.shared_string_delete, new DialogInterface.OnClickListener() {
				@Override
				public void onClick(DialogInterface dialog, int which) {
					String c = comment == null ? null : comment.getText().toString();
					boolean closeChangeSet = closeChangesetCheckBox != null
							&& closeChangesetCheckBox.isChecked();
					deleteNode(n, c, closeChangeSet);
				}


			});
			builder.create().show();
		}

		private void deleteNode(final Node n, final String c, final boolean closeChangeSet) {
			final boolean isLocalEdit = openstreetmapUtil instanceof OpenstreetmapLocalUtil;
			commitNode(OsmPoint.Action.DELETE, n, openstreetmapUtil.getEntityInfo(n.getId()), c, closeChangeSet,
					new CallbackWithObject<Node>() {

						@Override
						public boolean processResult(Node result) {
							if (result != null) {
								if (isLocalEdit) {
									Toast.makeText(activity, R.string.osm_changes_added_to_local_edits,
											Toast.LENGTH_LONG).show();
								} else {
									Toast.makeText(activity, R.string.poi_remove_success, Toast.LENGTH_LONG)
											.show();
								}
								if (activity instanceof MapActivity) {
									((MapActivity) activity).getMapView().refreshMap(true);
								}
							}
							return false;
						}
					}, activity, openstreetmapUtil);
		}
	}

	public static class SaveExtraValidationDialogFragment extends DialogFragment {
		@NonNull
		@Override
		public Dialog onCreateDialog(Bundle savedInstanceState) {
			AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
			String msg = getString(R.string.save_poi_without_poi_type_message);
			int i = getArguments().getInt("message", 0);
			if(i != 0) {
				msg = getString(i);
			}
			builder.setTitle(getResources().getString(R.string.are_you_sure))
					.setMessage(msg)
					.setPositiveButton(R.string.shared_string_ok, new DialogInterface.OnClickListener() {
						@Override
						public void onClick(DialogInterface dialog, int which) {
							((EditPoiDialogFragment) getParentFragment()).save();
						}
					})
					.setNegativeButton(R.string.shared_string_cancel, null);
			return builder.create();
		}
	}

	public static class AreYouSureDialogFragment extends DialogFragment {
		@NonNull
		@Override
		public Dialog onCreateDialog(Bundle savedInstanceState) {
			AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
			builder.setTitle(getResources().getString(R.string.are_you_sure))
					.setMessage(getString(R.string.unsaved_changes_will_be_lost))
					.setPositiveButton(R.string.shared_string_ok, new DialogInterface.OnClickListener() {
						@Override
						public void onClick(DialogInterface dialog, int which) {
							((DialogFragment) getParentFragment()).dismiss();
						}
					})
					.setNegativeButton(R.string.shared_string_cancel, null);
			return builder.create();
		}
	}

	private TextView.OnEditorActionListener mOnEditorActionListener =
			new TextView.OnEditorActionListener() {
				@Override
				public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
					boolean handled = false;
					if (actionId == EditorInfo.IME_ACTION_SEND) {
						trySave();
						handled = true;
					}
					return handled;
				}
			};

	public interface OnFragmentActivatedListener {
		void onFragmentActivated();
	}
}
!@#$%
20190530_062733,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_a03008
package net.osmand.plus.osmedit;

import android.app.Activity;
import android.app.Dialog;
import android.app.ProgressDialog;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.res.Resources;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Build;
import android.os.Bundle;
import android.support.annotation.NonNull;
import android.support.design.widget.TabLayout;
import android.support.design.widget.TextInputLayout;
import android.support.v4.app.DialogFragment;
import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentManager;
import android.support.v4.app.FragmentPagerAdapter;
import android.support.v4.app.FragmentTransaction;
import android.support.v4.view.ViewCompat;
import android.support.v4.view.ViewPager;
import android.support.v7.app.AlertDialog;
import android.support.v7.app.AppCompatActivity;
import android.support.v7.widget.Toolbar;
import android.text.Editable;
import android.text.TextUtils;
import android.text.TextWatcher;
import android.util.TypedValue;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.view.ViewTreeObserver;
import android.view.WindowManager;
import android.view.inputmethod.EditorInfo;
import android.widget.AdapterView;
import android.widget.ArrayAdapter;
import android.widget.AutoCompleteTextView;
import android.widget.Button;
import android.widget.CheckBox;
import android.widget.EditText;
import android.widget.ImageButton;
import android.widget.LinearLayout;
import android.widget.TextView;
import android.widget.Toast;

import net.osmand.CallbackWithObject;
import net.osmand.PlatformUtil;
import net.osmand.data.Amenity;
import net.osmand.data.LatLon;
import net.osmand.osm.PoiCategory;
import net.osmand.osm.PoiType;
import net.osmand.osm.edit.EntityInfo;
import net.osmand.osm.edit.Node;
import net.osmand.osm.edit.OSMSettings;
import net.osmand.plus.OsmandApplication;
import net.osmand.plus.OsmandPlugin;
import net.osmand.plus.OsmandSettings;
import net.osmand.plus.R;
import net.osmand.plus.activities.MapActivity;
import net.osmand.plus.base.BaseOsmAndDialogFragment;
import net.osmand.plus.osmedit.dialogs.PoiSubTypeDialogFragment;
import net.osmand.plus.osmedit.dialogs.PoiTypeDialogFragment;
import net.osmand.util.Algorithms;

import org.apache.commons.logging.Log;

import java.io.Serializable;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

public class EditPoiDialogFragment extends BaseOsmAndDialogFragment {
	public static final String TAG = "EditPoiDialogFragment";
	private static final Log LOG = PlatformUtil.getLog(EditPoiDialogFragment.class);

	private static final String KEY_AMENITY_NODE = "key_amenity_node";
	private static final String TAGS_LIST = "tags_list";
	private static final String IS_ADDING_POI = "is_adding_poi";

	public static final HashSet<String> BASIC_TAGS = new HashSet<String>() ;
	static {
		BASIC_TAGS.add(OSMSettings.OSMTagKey.NAME.getValue());
		BASIC_TAGS.add(OSMSettings.OSMTagKey.ADDR_STREET.getValue());
		BASIC_TAGS.add(OSMSettings.OSMTagKey.ADDR_HOUSE_NUMBER.getValue());
		BASIC_TAGS.add(OSMSettings.OSMTagKey.PHONE.getValue());
		BASIC_TAGS.add(OSMSettings.OSMTagKey.WEBSITE.getValue());
		BASIC_TAGS.add(OSMSettings.OSMTagKey.OPENING_HOURS.getValue());
	}

	private EditPoiData editPoiData;
	private ViewPager viewPager;
	private AutoCompleteTextView poiTypeEditText;

	private OpenstreetmapUtil mOpenstreetmapUtil;
	private TextInputLayout poiTypeTextInputLayout;
	private View view;

	@Override
	public void onAttach(Activity activity) {
		super.onAttach(activity);
		OsmEditingPlugin plugin = OsmandPlugin.getPlugin(OsmEditingPlugin.class);
		if (getSettings().OFFLINE_EDITION.get()
				|| !getSettings().isInternetConnectionAvailable(true)) {
			mOpenstreetmapUtil = plugin.getPoiModificationLocalUtil();
		} else {
			mOpenstreetmapUtil = plugin.getPoiModificationRemoteUtil();
		}

		Node node = (Node) getArguments().getSerializable(KEY_AMENITY_NODE);
		editPoiData = new EditPoiData(node, getMyApplication());
	}

	@Override
	public View onCreateView(LayoutInflater inflater, ViewGroup container,
							 Bundle savedInstanceState) {
		view = inflater.inflate(R.layout.fragment_edit_poi, container, false);
		boolean isLightTheme = getSettings().OSMAND_THEME.get() == OsmandSettings.OSMAND_LIGHT_THEME;

		if (savedInstanceState != null) {
			@SuppressWarnings("unchecked")
			Map<String, String> mp = (Map<String, String>) savedInstanceState.getSerializable(TAGS_LIST);
			editPoiData.updateTags(mp);
		}

		boolean isAddingPoi = getArguments().getBoolean(IS_ADDING_POI);

		Toolbar toolbar = (Toolbar) view.findViewById(R.id.toolbar);
		toolbar.setTitle(isAddingPoi ? R.string.poi_create_title : R.string.poi_edit_title);
		toolbar.setNavigationIcon(R.drawable.ic_arrow_back);
		toolbar.setNavigationContentDescription(R.string.access_shared_string_navigate_up);
		toolbar.setNavigationOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				dismissCheckForChanges();
			}
		});

		viewPager = (ViewPager) view.findViewById(R.id.viewpager);
		String basicTitle = getResources().getString(R.string.tab_title_basic);
		String extendedTitle = getResources().getString(R.string.tab_title_advanced);
		final MyAdapter pagerAdapter = new MyAdapter(getChildFragmentManager(), basicTitle, extendedTitle);
		viewPager.setAdapter(pagerAdapter);
		viewPager.addOnPageChangeListener(new ViewPager.OnPageChangeListener() {
			@Override
			public void onPageScrolled(int i, float v, int i1) {

			}

			@Override
			public void onPageSelected(int i) {
				((OnFragmentActivatedListener) pagerAdapter.getItem(i)).onFragmentActivated();
			}

			@Override
			public void onPageScrollStateChanged(int i) {

			}
		});

		final TabLayout tabLayout = (TabLayout) view.findViewById(R.id.tab_layout);
		tabLayout.setTabMode(TabLayout.MODE_SCROLLABLE);

		// tabLayout.setupWithViewPager(viewPager);
		// Hack due to bug in design support library v22.2.1
		// https://code.google.com/p/android/issues/detail?id=180462
		// TODO remove in new version
		if (Build.VERSION.SDK_INT >= 11) {
			if (ViewCompat.isLaidOut(tabLayout)) {
				tabLayout.setupWithViewPager(viewPager);
			} else {
				tabLayout.addOnLayoutChangeListener(new View.OnLayoutChangeListener() {
					@Override
					public void onLayoutChange(View v, int left, int top, int right, int bottom,
											   int oldLeft, int oldTop, int oldRight, int oldBottom) {
						tabLayout.setupWithViewPager(viewPager);
						tabLayout.removeOnLayoutChangeListener(this);
					}
				});
			}
		} else {
			ViewTreeObserver vto = view.getViewTreeObserver();
			vto.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {

				@Override
				public void onGlobalLayout() {

					ViewTreeObserver obs = view.getViewTreeObserver();
					if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
						obs.removeGlobalOnLayoutListener(this);
					}

					if (getActivity() != null) {
						tabLayout.setupWithViewPager(viewPager);
					}
				}
			});
		}

		ImageButton onlineDocumentationButton =
				(ImageButton) view.findViewById(R.id.onlineDocumentationButton);
		onlineDocumentationButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				getActivity().startActivity(new Intent(Intent.ACTION_VIEW,
						Uri.parse("https://wiki.openstreetmap.org/wiki/Map_Features")));
			}
		});

		final int colorId = isLightTheme ? R.color.inactive_item_orange : R.color.dash_search_icon_dark;
		final int color = getResources().getColor(colorId);
		onlineDocumentationButton.setImageDrawable(getPaintedContentIcon(R.drawable.ic_action_help, color));
		final ImageButton poiTypeButton = (ImageButton) view.findViewById(R.id.poiTypeButton);
		poiTypeButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				PoiTypeDialogFragment fragment = PoiTypeDialogFragment.createInstance();
				fragment.setOnItemSelectListener(new PoiTypeDialogFragment.OnItemSelectListener() {
					@Override
					public void select(PoiCategory poiCategory) {
						setPoiCategory(poiCategory);
					}
				});
				fragment.show(getChildFragmentManager(), "PoiTypeDialogFragment");
			}
		});

		EditText poiNameEditText = (EditText) view.findViewById(R.id.poiNameEditText);
		poiNameEditText.addTextChangedListener(new TextWatcher() {
			@Override
			public void beforeTextChanged(CharSequence s, int start, int count, int after) {
			}

			@Override
			public void onTextChanged(CharSequence s, int start, int before, int count) {
			}

			@Override
			public void afterTextChanged(Editable s) {
				if (!getEditPoiData().isInEdit()) {
					if (!TextUtils.isEmpty(s)) {
						getEditPoiData().putTag(OSMSettings.OSMTagKey.NAME.getValue(),
								s.toString());
					} else {
						getEditPoiData().removeTag(OSMSettings.OSMTagKey.NAME.getValue());
					}
				}
			}
		});
		poiNameEditText.setText(editPoiData.getTag(OSMSettings.OSMTagKey.NAME.getValue()));
		poiTypeTextInputLayout = (TextInputLayout) view.findViewById(R.id.poiTypeTextInputLayout);
		poiTypeEditText = (AutoCompleteTextView) view.findViewById(R.id.poiTypeEditText);
		poiTypeEditText.addTextChangedListener(new TextWatcher() {
			@Override
			public void beforeTextChanged(CharSequence s, int start, int count, int after) {
			}

			@Override
			public void onTextChanged(CharSequence s, int start, int before, int count) {
			}

			@Override
			public void afterTextChanged(Editable s) {
				if (!getEditPoiData().isInEdit()) {
					getEditPoiData().updateTypeTag(s.toString());
					poiTypeTextInputLayout.setHint(editPoiData.getPoiCategory().getTranslation());
				}
			}
		});
		poiNameEditText.setOnEditorActionListener(mOnEditorActionListener);
		poiTypeEditText.setOnEditorActionListener(mOnEditorActionListener);
		poiTypeEditText.setText(editPoiData.getPoiTypeString());
		poiTypeEditText.setOnTouchListener(new View.OnTouchListener() {
			@Override
			public boolean onTouch(final View v, MotionEvent event) {
				final EditText editText = (EditText) v;
				final int DRAWABLE_RIGHT = 2;
				if (event.getAction() == MotionEvent.ACTION_UP) {
					if (event.getX() >= (editText.getRight()
							- editText.getCompoundDrawables()[DRAWABLE_RIGHT].getBounds().width()
							- editText.getPaddingRight())) {
						if (editPoiData.getPoiCategory() != null) {
							PoiSubTypeDialogFragment dialogFragment =
									PoiSubTypeDialogFragment.createInstance(editPoiData.getPoiCategory());
							dialogFragment.setOnItemSelectListener(new PoiSubTypeDialogFragment.OnItemSelectListener() {
								@Override
								public void select(String category) {
									setSubCategory(category);
								}
							});
							dialogFragment.show(getChildFragmentManager(), "PoiSubTypeDialogFragment");
						}

						return true;
					}
				}
				return false;
			}
		});

		Button saveButton = (Button) view.findViewById(R.id.saveButton);
		saveButton.setText(mOpenstreetmapUtil instanceof OpenstreetmapRemoteUtil
				? R.string.shared_string_upload : R.string.shared_string_save);
		saveButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				trySave();
			}
		});
		Button cancelButton = (Button) view.findViewById(R.id.cancelButton);
		cancelButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				dismissCheckForChanges();
			}
		});
		setAdapterForPoiTypeEditText();
		setCancelable(false);
		return view;
	}

	@NonNull
	@Override
	public Dialog onCreateDialog(Bundle savedInstanceState) {
		final Dialog dialog = super.onCreateDialog(savedInstanceState);
		dialog.getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE);
		return dialog;
	}

	@Override
	public void onResume() {
		super.onResume();
		getDialog().setOnKeyListener(new DialogInterface.OnKeyListener() {
			@Override
			public boolean onKey(DialogInterface dialog, int keyCode, KeyEvent event) {
				if (keyCode == android.view.KeyEvent.KEYCODE_BACK) {
					if (event.getAction() == KeyEvent.ACTION_DOWN) {
						return true;
					} else {
						dismissCheckForChanges();
						return true;
					}
				}
				return false;
			}
		});
	}

	@Override
	public void onSaveInstanceState(Bundle outState) {
		outState.putSerializable(TAGS_LIST, (Serializable) editPoiData.getTagValues());
		super.onSaveInstanceState(outState);
	}

	@Override
	public void show(FragmentManager manager, String tag) {
		if (manager.findFragmentByTag(TAG) == null) {
			super.show(manager, TAG);
		}
	}

	@Override
	public int show(FragmentTransaction transaction, String tag) {
		throw new UnsupportedOperationException("Please use show(FragmentManager manager, String tag)");
	}

	private void trySave() {
		if (TextUtils.isEmpty(poiTypeEditText.getText())) {
			HashSet<String> tagsCopy = new HashSet<>();
			tagsCopy.addAll(editPoiData.getTagValues().keySet());
			if (Algorithms.isEmpty(editPoiData.getTag(OSMSettings.OSMTagKey.ADDR_HOUSE_NUMBER.getValue()))) {
				SaveExtraValidationDialogFragment f = new SaveExtraValidationDialogFragment();
				Bundle args = new Bundle();
				args.putInt("message", R.string.save_poi_without_poi_type_message);
				f.setArguments(args);
				f.show(getChildFragmentManager(), "dialog");
				// poiTypeEditText.setError(getResources().getString(R.string.please_specify_poi_type));
			} else {
				save();
			}
		} else if (testTooManyCapitalLetters(editPoiData.getTag(OSMSettings.OSMTagKey.NAME.getValue()))) {
			SaveExtraValidationDialogFragment f = new SaveExtraValidationDialogFragment();
			Bundle args = new Bundle();
			args.putInt("message", R.string.save_poi_too_many_uppercase);
			f.setArguments(args);
			f.show(getChildFragmentManager(), "dialog");			
		} else if (editPoiData.getPoiCategory() == getMyApplication().getPoiTypes().getOtherPoiCategory()) {
			poiTypeEditText.setError(getResources().getString(R.string.please_specify_poi_type));
		} else if (editPoiData.getPoiTypeDefined() == null) {
			poiTypeEditText.setError(getResources().getString(R.string.please_specify_poi_type_only_from_list));
		} else {
			save();
		}
	}

	private boolean testTooManyCapitalLetters(String name) {
		if(name == null) {
			return false;
		}
		int capital = 0;
		int lower = 0;
		int nonalpha = 0;
		for(int i = 0; i < name.length(); i++) {
			char c = name.charAt(i);
			if(Character.isLetter(c) || Character.getType(c) == Character.LETTER_NUMBER) {
				if(Character.isUpperCase(c)) {
					capital ++;
				} else {
					lower ++;
				}
			} else {
				nonalpha ++;
			}
		}
		return capital > nonalpha && capital > lower;
	}

	private void save() {
		Node original = editPoiData.getEntity();
		final boolean offlineEdit = mOpenstreetmapUtil instanceof OpenstreetmapLocalUtil;
		Node node = new Node(original.getLatitude(), original.getLongitude(), original.getId());
		OsmPoint.Action action = node.getId() < 0 ? OsmPoint.Action.CREATE : OsmPoint.Action.MODIFY;
		for (Map.Entry<String, String> tag : editPoiData.getTagValues().entrySet()) {
			if (!Algorithms.isEmpty(tag.getKey()) && !Algorithms.isEmpty(tag.getValue()) && 
					!tag.getKey().equals(EditPoiData.POI_TYPE_TAG)) {
				node.putTagNoLC(tag.getKey(), tag.getValue());
			}
		}
		String poiTypeTag = editPoiData.getTagValues().get(EditPoiData.POI_TYPE_TAG);
		String comment = "";
		if (poiTypeTag != null) {
			final PoiType poiType = editPoiData.getAllTranslatedSubTypes().get(poiTypeTag.trim().toLowerCase());
			if (poiType != null) {
				node.putTagNoLC(poiType.getOsmTag(), poiType.getOsmValue());
				node.removeTag(EditPoiData.REMOVE_TAG_PREFIX + poiType.getOsmTag());
				if (poiType.getOsmTag2() != null) {
					node.putTagNoLC(poiType.getOsmTag2(), poiType.getOsmValue2());
					node.removeTag(EditPoiData.REMOVE_TAG_PREFIX + poiType.getOsmTag2());
				}
			} else if (!Algorithms.isEmpty(poiTypeTag)) {
				node.putTagNoLC(editPoiData.getPoiCategory().getDefaultTag(), poiTypeTag);

			}
			if (offlineEdit && !Algorithms.isEmpty(poiTypeTag)) {
				node.putTagNoLC(EditPoiData.POI_TYPE_TAG, poiTypeTag);
			}
			String actionString = action == OsmPoint.Action.CREATE ? getString(R.string.default_changeset_add) : getString(R.string.default_changeset_edit);
			comment = actionString + " " + poiTypeTag;
		}
		commitNode(action, node, mOpenstreetmapUtil.getEntityInfo(node.getId()), comment, false,
				new CallbackWithObject<Node>() {

					@Override
					public boolean processResult(Node result) {
						if (result != null) {
							OsmEditingPlugin plugin = OsmandPlugin.getPlugin(OsmEditingPlugin.class);
							if (plugin != null && offlineEdit) {
								List<OpenstreetmapPoint> points = plugin.getDBPOI().getOpenstreetmapPoints();
								if (getActivity() instanceof MapActivity && points.size() > 0) {
									OsmPoint point = points.get(points.size() - 1);
									MapActivity mapActivity = (MapActivity) getActivity();
									mapActivity.getContextMenu().showOrUpdate(
											new LatLon(point.getLatitude(), point.getLongitude()),
											plugin.getOsmEditsLayer(mapActivity).getObjectName(point), point);
								}
							}

							if (getActivity() instanceof MapActivity) {
								((MapActivity) getActivity()).getMapView().refreshMap(true);
							}
							dismiss();
						} else {
							OsmEditingPlugin plugin = OsmandPlugin.getPlugin(OsmEditingPlugin.class);
							mOpenstreetmapUtil = plugin.getPoiModificationLocalUtil();
							Button saveButton = (Button) view.findViewById(R.id.saveButton);
							saveButton.setText(mOpenstreetmapUtil instanceof OpenstreetmapRemoteUtil
									? R.string.shared_string_upload : R.string.shared_string_save);
						}

						return false;
					}
				}, getActivity(), mOpenstreetmapUtil);
	}

	private void dismissCheckForChanges() {
		if (editPoiData.hasChangesBeenMade()) {
			new AreYouSureDialogFragment().show(getChildFragmentManager(),
					"AreYouSureDialogFragment");
		} else {
			dismiss();
		}
	}

	public EditPoiData getEditPoiData() {
		return editPoiData;
	}

	public void setSubCategory(String subCategory) {
		poiTypeEditText.setText(subCategory);
	}

	public static void commitNode(final OsmPoint.Action action,
								  final Node node,
								  final EntityInfo info,
								  final String comment,
								  final boolean closeChangeSet,
								  final CallbackWithObject<Node> postExecute,
								  final Activity activity,
								  final OpenstreetmapUtil openstreetmapUtil) {
		if (info == null && OsmPoint.Action.CREATE != action && openstreetmapUtil instanceof OpenstreetmapRemoteUtil) {
			Toast.makeText(activity, activity.getResources().getString(R.string.poi_error_info_not_loaded), Toast.LENGTH_LONG).show();
			return;
		}
		new AsyncTask<Void, Void, Node>() {
			ProgressDialog progress;

			@Override
			protected void onPreExecute() {
				progress = ProgressDialog.show(activity, activity.getString(R.string.uploading), activity.getString(R.string.uploading_data));
				super.onPreExecute();
			}

			@Override
			protected Node doInBackground(Void... params) {
				return openstreetmapUtil.commitNodeImpl(action, node, info, comment, closeChangeSet);
			}

			@Override
			protected void onPostExecute(Node result) {
				progress.dismiss();
				if (postExecute != null) {
					postExecute.processResult(result);
				}
			}
		}.execute();
	}

	public void setPoiCategory(PoiCategory type) {
		editPoiData.updateType(type);
		poiTypeEditText.setText(editPoiData.getPoiTypeString());
		setAdapterForPoiTypeEditText();
	}

	private void setAdapterForPoiTypeEditText() {
		final Map<String, PoiType> subCategories = new LinkedHashMap<>();
		PoiCategory ct = editPoiData.getPoiCategory();
		if (ct != null) {
			for (PoiType s : ct.getPoiTypes()) {
				if (!s.isReference() && !s.isNotEditableOsm() && s.getBaseLangType() == null) {
					addMapEntryAdapter(subCategories, s.getTranslation(), s);
					if(!s.getKeyName().contains("osmand")) {
						addMapEntryAdapter(subCategories, s.getKeyName().replace('_', ' '), s);
					}
				}
			}
		}
		for (Map.Entry<String, PoiType> s : editPoiData.getAllTranslatedSubTypes().entrySet()) {
			addMapEntryAdapter(subCategories, s.getKey(), s.getValue());
		}
		final ArrayAdapter<Object> adapter;
		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
			adapter = new ArrayAdapter<>(getActivity(),
					R.layout.list_textview, subCategories.keySet().toArray());
		} else {
			TypedValue typedValue = new TypedValue();
			Resources.Theme theme = getActivity().getTheme();
			theme.resolveAttribute(android.R.attr.textColorSecondary, typedValue, true);
			final int textColor = typedValue.data;

			adapter = new ArrayAdapter<Object>(getActivity(),
					R.layout.list_textview, subCategories.keySet().toArray()) {
				@Override
				public View getView(int position, View convertView, ViewGroup parent) {
					final View view = super.getView(position, convertView, parent);
					((TextView) view.findViewById(R.id.textView)).setTextColor(textColor);
					return view;
				}
			};
		}
		adapter.sort(new Comparator<Object>() {
			@Override
			public int compare(Object lhs, Object rhs) {
				return lhs.toString().compareTo(rhs.toString());
			}
		});
		poiTypeEditText.setAdapter(adapter);
		poiTypeEditText.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {

			@Override
			public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
				Object item = parent.getAdapter().getItem(position);
				poiTypeEditText.setText(item.toString());
				setAdapterForPoiTypeEditText();
			}

			@Override
			public void onNothingSelected(AdapterView<?> parent) {
			}
		});

	}

	private void addMapEntryAdapter(final Map<String, PoiType> subCategories, String key, PoiType v) {
		if (!subCategories.containsKey(key.toLowerCase())) {
			subCategories.put(Algorithms.capitalizeFirstLetterAndLowercase(key), v);
		}
	}

	public static EditPoiDialogFragment createAddPoiInstance(double latitude, double longitude,
															 OsmandApplication application) {
		Node node = new Node(latitude, longitude, -1);
		return createInstance(node, true);
	}

	public static EditPoiDialogFragment createInstance(Node node, boolean isAddingPoi) {
		EditPoiDialogFragment editPoiDialogFragment = new EditPoiDialogFragment();
		Bundle args = new Bundle();
		args.putSerializable(KEY_AMENITY_NODE, node);
		args.putBoolean(IS_ADDING_POI, isAddingPoi);
		editPoiDialogFragment.setArguments(args);
		return editPoiDialogFragment;
	}

	public static EditPoiDialogFragment createInstance(Node node, boolean isAddingPoi, Map<String, String> tagList) {
		EditPoiDialogFragment editPoiDialogFragment = new EditPoiDialogFragment();
		Bundle args = new Bundle();
		args.putSerializable(KEY_AMENITY_NODE, node);
		args.putBoolean(IS_ADDING_POI, isAddingPoi);
		args.putSerializable(TAGS_LIST, (Serializable) Collections.unmodifiableMap(tagList));
		editPoiDialogFragment.setArguments(args);
		return editPoiDialogFragment;
	}

	public static void showEditInstance(final Amenity amenity,
										final AppCompatActivity activity) {
		final OsmandSettings settings = ((OsmandApplication) activity.getApplication())
				.getSettings();
		final OpenstreetmapUtil openstreetmapUtilToLoad;
		OsmEditingPlugin plugin = OsmandPlugin.getPlugin(OsmEditingPlugin.class);
		if (//settings.OFFLINE_EDITION.get() ||
				!settings.isInternetConnectionAvailable(true)) {
			openstreetmapUtilToLoad = plugin.getPoiModificationLocalUtil();
		} else {
			openstreetmapUtilToLoad = plugin.getPoiModificationRemoteUtil();
		}
		new AsyncTask<Void, Void, Node>() {
			@Override
			protected Node doInBackground(Void... params) {
				return openstreetmapUtilToLoad.loadNode(amenity);
			}

			protected void onPostExecute(Node n) {
				if (n != null) {
					EditPoiDialogFragment fragment =
							EditPoiDialogFragment.createInstance(n, false);
					fragment.show(activity.getSupportFragmentManager(), TAG);
				} else {
					Toast.makeText(activity,
							activity.getString(R.string.poi_error_poi_not_found),
							Toast.LENGTH_LONG).show();
				}
			}
		}.execute();
	}

	public static class MyAdapter extends FragmentPagerAdapter {
		private final Fragment[] fragments = new Fragment[]{new BasicEditPoiFragment(),
				new AdvancedEditPoiFragment()};
		private final String[] titles;

		public MyAdapter(FragmentManager fm, String basicTitle, String extendedTitle) {
			super(fm);
			titles = new String[]{basicTitle, extendedTitle};
		}

		@Override
		public int getCount() {
			return 2;
		}

		@Override
		public Fragment getItem(int position) {
			return fragments[position];
		}

		@Override
		public CharSequence getPageTitle(int position) {
			return titles[position];
		}
	}

	public static class ShowDeleteDialogAsyncTask extends AsyncTask<Amenity, Void, Node> {
		private final OpenstreetmapUtil openstreetmapUtil;
		private final AppCompatActivity activity;

		public ShowDeleteDialogAsyncTask(AppCompatActivity activity) {
			this.activity = activity;
			OsmandSettings settings = ((OsmandApplication) activity.getApplication()).getSettings();
			OsmEditingPlugin plugin = OsmandPlugin.getPlugin(OsmEditingPlugin.class);
			if (settings.OFFLINE_EDITION.get() || !settings.isInternetConnectionAvailable(true)) {
				openstreetmapUtil = plugin.getPoiModificationLocalUtil();
			} else {
				openstreetmapUtil = plugin.getPoiModificationRemoteUtil();
			}
		}

		protected Node doInBackground(Amenity[] params) {
			return openstreetmapUtil.loadNode(params[0]);
		}

		protected void onPostExecute(final Node n) {
			if (n == null) {
				Toast.makeText(activity, activity.getResources().getString(R.string.poi_error_poi_not_found), Toast.LENGTH_LONG).show();
				return;
			}
			AlertDialog.Builder builder = new AlertDialog.Builder(activity);
			builder.setTitle(R.string.poi_remove_title);
			final EditText comment;
			final CheckBox closeChangesetCheckBox;
			final boolean isLocalEdit = openstreetmapUtil instanceof OpenstreetmapLocalUtil;
			if (isLocalEdit) {
				closeChangesetCheckBox = null;
				comment = null;
			} else {
				LinearLayout ll = new LinearLayout(activity);
				ll.setPadding(16, 2, 16, 0);
				ll.setOrientation(LinearLayout.VERTICAL);
				closeChangesetCheckBox = new CheckBox(activity);
				closeChangesetCheckBox.setText(R.string.close_changeset);
				ll.addView(closeChangesetCheckBox);
				comment = new EditText(activity);
				comment.setText(R.string.poi_remove_title);
				ll.addView(comment);
				builder.setView(ll);
			}
			builder.setNegativeButton(R.string.shared_string_cancel, null);
			builder.setPositiveButton(isLocalEdit ? R.string.shared_string_save : R.string.shared_string_delete, new DialogInterface.OnClickListener() {
				@Override
				public void onClick(DialogInterface dialog, int which) {
					String c = comment == null ? null : comment.getText().toString();
					boolean closeChangeSet = closeChangesetCheckBox != null
							&& closeChangesetCheckBox.isChecked();
					deleteNode(n, c, closeChangeSet);
				}


			});
			builder.create().show();
		}

		private void deleteNode(final Node n, final String c, final boolean closeChangeSet) {
			final boolean isLocalEdit = openstreetmapUtil instanceof OpenstreetmapLocalUtil;
			commitNode(OsmPoint.Action.DELETE, n, openstreetmapUtil.getEntityInfo(n.getId()), c, closeChangeSet,
					new CallbackWithObject<Node>() {

						@Override
						public boolean processResult(Node result) {
							if (result != null) {
								if (isLocalEdit) {
									Toast.makeText(activity, R.string.osm_changes_added_to_local_edits,
											Toast.LENGTH_LONG).show();
								} else {
									Toast.makeText(activity, R.string.poi_remove_success, Toast.LENGTH_LONG)
											.show();
								}
								if (activity instanceof MapActivity) {
									((MapActivity) activity).getMapView().refreshMap(true);
								}
							}
							return false;
						}
					}, activity, openstreetmapUtil);
		}
	}

	public static class SaveExtraValidationDialogFragment extends DialogFragment {
		@NonNull
		@Override
		public Dialog onCreateDialog(Bundle savedInstanceState) {
			AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
			String msg = getString(R.string.save_poi_without_poi_type_message);
			int i = getArguments().getInt("message", 0);
			if(i != 0) {
				msg = getString(i);
			}
			builder.setTitle(getResources().getString(R.string.are_you_sure))
					.setMessage(msg)
					.setPositiveButton(R.string.shared_string_ok, new DialogInterface.OnClickListener() {
						@Override
						public void onClick(DialogInterface dialog, int which) {
							((EditPoiDialogFragment) getParentFragment()).save();
						}
					})
					.setNegativeButton(R.string.shared_string_cancel, null);
			return builder.create();
		}
	}

	public static class AreYouSureDialogFragment extends DialogFragment {
		@NonNull
		@Override
		public Dialog onCreateDialog(Bundle savedInstanceState) {
			AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
			builder.setTitle(getResources().getString(R.string.are_you_sure))
					.setMessage(getString(R.string.unsaved_changes_will_be_lost))
					.setPositiveButton(R.string.shared_string_ok, new DialogInterface.OnClickListener() {
						@Override
						public void onClick(DialogInterface dialog, int which) {
							((DialogFragment) getParentFragment()).dismiss();
						}
					})
					.setNegativeButton(R.string.shared_string_cancel, null);
			return builder.create();
		}
	}

	private TextView.OnEditorActionListener mOnEditorActionListener =
			new TextView.OnEditorActionListener() {
				@Override
				public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
					boolean handled = false;
					if (actionId == EditorInfo.IME_ACTION_SEND) {
						trySave();
						handled = true;
					}
					return handled;
				}
			};

	public interface OnFragmentActivatedListener {
		void onFragmentActivated();
	}
}
!@#$%
20190530_062733,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_c03008
package net.osmand.plus.osmedit;

import android.app.Activity;
import android.app.Dialog;
import android.app.ProgressDialog;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.res.Resources;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Build;
import android.os.Bundle;
import android.support.annotation.NonNull;
import android.support.design.widget.TabLayout;
import android.support.design.widget.TextInputLayout;
import android.support.v4.app.DialogFragment;
import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentManager;
import android.support.v4.app.FragmentPagerAdapter;
import android.support.v4.app.FragmentTransaction;
import android.support.v4.view.ViewCompat;
import android.support.v4.view.ViewPager;
import android.support.v7.app.AlertDialog;
import android.support.v7.app.AppCompatActivity;
import android.support.v7.widget.Toolbar;
import android.text.Editable;
import android.text.TextUtils;
import android.text.TextWatcher;
import android.util.TypedValue;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.view.ViewTreeObserver;
import android.view.WindowManager;
import android.view.inputmethod.EditorInfo;
import android.widget.AdapterView;
import android.widget.ArrayAdapter;
import android.widget.AutoCompleteTextView;
import android.widget.Button;
import android.widget.CheckBox;
import android.widget.EditText;
import android.widget.ImageButton;
import android.widget.LinearLayout;
import android.widget.TextView;
import android.widget.Toast;

import net.osmand.CallbackWithObject;
import net.osmand.PlatformUtil;
import net.osmand.data.Amenity;
import net.osmand.data.LatLon;
import net.osmand.osm.PoiCategory;
import net.osmand.osm.PoiType;
import net.osmand.osm.edit.EntityInfo;
import net.osmand.osm.edit.Node;
import net.osmand.osm.edit.OSMSettings;
import net.osmand.plus.OsmandApplication;
import net.osmand.plus.OsmandPlugin;
import net.osmand.plus.OsmandSettings;
import net.osmand.plus.R;
import net.osmand.plus.activities.MapActivity;
import net.osmand.plus.base.BaseOsmAndDialogFragment;
import net.osmand.plus.osmedit.dialogs.PoiSubTypeDialogFragment;
import net.osmand.plus.osmedit.dialogs.PoiTypeDialogFragment;
import net.osmand.util.Algorithms;

import org.apache.commons.logging.Log;

import java.io.Serializable;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

public class EditPoiDialogFragment extends BaseOsmAndDialogFragment {
	public static final String TAG = "EditPoiDialogFragment";
	private static final Log LOG = PlatformUtil.getLog(EditPoiDialogFragment.class);

	private static final String KEY_AMENITY_NODE = "key_amenity_node";
	private static final String TAGS_LIST = "tags_list";
	private static final String IS_ADDING_POI = "is_adding_poi";

	public static final HashSet<String> BASIC_TAGS = new HashSet<String>() ;
	static {
		BASIC_TAGS.add(OSMSettings.OSMTagKey.NAME.getValue());
		BASIC_TAGS.add(OSMSettings.OSMTagKey.ADDR_STREET.getValue());
		BASIC_TAGS.add(OSMSettings.OSMTagKey.ADDR_HOUSE_NUMBER.getValue());
		BASIC_TAGS.add(OSMSettings.OSMTagKey.PHONE.getValue());
		BASIC_TAGS.add(OSMSettings.OSMTagKey.WEBSITE.getValue());
		BASIC_TAGS.add(OSMSettings.OSMTagKey.OPENING_HOURS.getValue());
	}

	private EditPoiData editPoiData;
	private ViewPager viewPager;
	private AutoCompleteTextView poiTypeEditText;

	private OpenstreetmapUtil mOpenstreetmapUtil;
	private TextInputLayout poiTypeTextInputLayout;
	private View view;

	@Override
	public void onAttach(Activity activity) {
		super.onAttach(activity);
		OsmEditingPlugin plugin = OsmandPlugin.getPlugin(OsmEditingPlugin.class);
		if (getSettings().OFFLINE_EDITION.get()
				|| !getSettings().isInternetConnectionAvailable(true)) {
			mOpenstreetmapUtil = plugin.getPoiModificationLocalUtil();
		} else {
			mOpenstreetmapUtil = plugin.getPoiModificationRemoteUtil();
		}

		Node node = (Node) getArguments().getSerializable(KEY_AMENITY_NODE);
		editPoiData = new EditPoiData(node, getMyApplication());
	}

	@Override
	public View onCreateView(LayoutInflater inflater, ViewGroup container,
							 Bundle savedInstanceState) {
		view = inflater.inflate(R.layout.fragment_edit_poi, container, false);
		boolean isLightTheme = getSettings().OSMAND_THEME.get() == OsmandSettings.OSMAND_LIGHT_THEME;

		if (savedInstanceState != null) {
			@SuppressWarnings("unchecked")
			Map<String, String> mp = (Map<String, String>) savedInstanceState.getSerializable(TAGS_LIST);
			editPoiData.updateTags(mp);
		}

		boolean isAddingPoi = getArguments().getBoolean(IS_ADDING_POI);

		Toolbar toolbar = (Toolbar) view.findViewById(R.id.toolbar);
		toolbar.setTitle(isAddingPoi ? R.string.poi_create_title : R.string.poi_edit_title);
		toolbar.setNavigationIcon(R.drawable.ic_arrow_back);
		toolbar.setNavigationContentDescription(R.string.access_shared_string_navigate_up);
		toolbar.setNavigationOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				dismissCheckForChanges();
			}
		});

		viewPager = (ViewPager) view.findViewById(R.id.viewpager);
		String basicTitle = getResources().getString(R.string.tab_title_basic);
		String extendedTitle = getResources().getString(R.string.tab_title_advanced);
		final MyAdapter pagerAdapter = new MyAdapter(getChildFragmentManager(), basicTitle, extendedTitle);
		viewPager.setAdapter(pagerAdapter);
		viewPager.addOnPageChangeListener(new ViewPager.OnPageChangeListener() {
			@Override
			public void onPageScrolled(int i, float v, int i1) {

			}

			@Override
			public void onPageSelected(int i) {
				((OnFragmentActivatedListener) pagerAdapter.getItem(i)).onFragmentActivated();
			}

			@Override
			public void onPageScrollStateChanged(int i) {

			}
		});

		final TabLayout tabLayout = (TabLayout) view.findViewById(R.id.tab_layout);
		tabLayout.setTabMode(TabLayout.MODE_SCROLLABLE);

		// tabLayout.setupWithViewPager(viewPager);
		// Hack due to bug in design support library v22.2.1
		// https://code.google.com/p/android/issues/detail?id=180462
		// TODO remove in new version
		if (Build.VERSION.SDK_INT >= 11) {
			if (ViewCompat.isLaidOut(tabLayout)) {
				tabLayout.setupWithViewPager(viewPager);
			} else {
				tabLayout.addOnLayoutChangeListener(new View.OnLayoutChangeListener() {
					@Override
					public void onLayoutChange(View v, int left, int top, int right, int bottom,
											   int oldLeft, int oldTop, int oldRight, int oldBottom) {
						tabLayout.setupWithViewPager(viewPager);
						tabLayout.removeOnLayoutChangeListener(this);
					}
				});
			}
		} else {
			ViewTreeObserver vto = view.getViewTreeObserver();
			vto.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {

				@Override
				public void onGlobalLayout() {

					ViewTreeObserver obs = view.getViewTreeObserver();
					if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
						obs.removeGlobalOnLayoutListener(this);
					}

					if (getActivity() != null) {
						tabLayout.setupWithViewPager(viewPager);
					}
				}
			});
		}

		ImageButton onlineDocumentationButton =
				(ImageButton) view.findViewById(R.id.onlineDocumentationButton);
		onlineDocumentationButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				getActivity().startActivity(new Intent(Intent.ACTION_VIEW,
						Uri.parse("https://wiki.openstreetmap.org/wiki/Map_Features")));
			}
		});

		final int colorId = isLightTheme ? R.color.inactive_item_orange : R.color.dash_search_icon_dark;
		final int color = getResources().getColor(colorId);
		onlineDocumentationButton.setImageDrawable(getPaintedContentIcon(R.drawable.ic_action_help, color));
		final ImageButton poiTypeButton = (ImageButton) view.findViewById(R.id.poiTypeButton);
		poiTypeButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				PoiTypeDialogFragment fragment = PoiTypeDialogFragment.createInstance();
				fragment.setOnItemSelectListener(new PoiTypeDialogFragment.OnItemSelectListener() {
					@Override
					public void select(PoiCategory poiCategory) {
						setPoiCategory(poiCategory);
					}
				});
				fragment.show(getChildFragmentManager(), "PoiTypeDialogFragment");
			}
		});

		EditText poiNameEditText = (EditText) view.findViewById(R.id.poiNameEditText);
		poiNameEditText.addTextChangedListener(new TextWatcher() {
			@Override
			public void beforeTextChanged(CharSequence s, int start, int count, int after) {
			}

			@Override
			public void onTextChanged(CharSequence s, int start, int before, int count) {
			}

			@Override
			public void afterTextChanged(Editable s) {
				if (!getEditPoiData().isInEdit()) {
					if (!TextUtils.isEmpty(s)) {
						getEditPoiData().putTag(OSMSettings.OSMTagKey.NAME.getValue(),
								s.toString());
					} else {
						getEditPoiData().removeTag(OSMSettings.OSMTagKey.NAME.getValue());
					}
				}
			}
		});
		poiNameEditText.setText(editPoiData.getTag(OSMSettings.OSMTagKey.NAME.getValue()));
		poiTypeTextInputLayout = (TextInputLayout) view.findViewById(R.id.poiTypeTextInputLayout);
		poiTypeEditText = (AutoCompleteTextView) view.findViewById(R.id.poiTypeEditText);
		poiTypeEditText.addTextChangedListener(new TextWatcher() {
			@Override
			public void beforeTextChanged(CharSequence s, int start, int count, int after) {
			}

			@Override
			public void onTextChanged(CharSequence s, int start, int before, int count) {
			}

			@Override
			public void afterTextChanged(Editable s) {
				if (!getEditPoiData().isInEdit()) {
					getEditPoiData().updateTypeTag(s.toString());
					if (!getMyApplication().isApplicationInitializing()) {
						poiTypeTextInputLayout.setHint(editPoiData.getPoiCategory().getTranslation());
					}
				}
			}
		});
		poiNameEditText.setOnEditorActionListener(mOnEditorActionListener);
		poiTypeEditText.setOnEditorActionListener(mOnEditorActionListener);
		poiTypeEditText.setText(editPoiData.getPoiTypeString());
		poiTypeEditText.setOnTouchListener(new View.OnTouchListener() {
			@Override
			public boolean onTouch(final View v, MotionEvent event) {
				final EditText editText = (EditText) v;
				final int DRAWABLE_RIGHT = 2;
				if (event.getAction() == MotionEvent.ACTION_UP) {
					if (event.getX() >= (editText.getRight()
							- editText.getCompoundDrawables()[DRAWABLE_RIGHT].getBounds().width()
							- editText.getPaddingRight())) {
						if (editPoiData.getPoiCategory() != null) {
							PoiSubTypeDialogFragment dialogFragment =
									PoiSubTypeDialogFragment.createInstance(editPoiData.getPoiCategory());
							dialogFragment.setOnItemSelectListener(new PoiSubTypeDialogFragment.OnItemSelectListener() {
								@Override
								public void select(String category) {
									setSubCategory(category);
								}
							});
							dialogFragment.show(getChildFragmentManager(), "PoiSubTypeDialogFragment");
						}

						return true;
					}
				}
				return false;
			}
		});

		Button saveButton = (Button) view.findViewById(R.id.saveButton);
		saveButton.setText(mOpenstreetmapUtil instanceof OpenstreetmapRemoteUtil
				? R.string.shared_string_upload : R.string.shared_string_save);
		saveButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				trySave();
			}
		});
		Button cancelButton = (Button) view.findViewById(R.id.cancelButton);
		cancelButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				dismissCheckForChanges();
			}
		});
		setAdapterForPoiTypeEditText();
		setCancelable(false);
		return view;
	}

	@NonNull
	@Override
	public Dialog onCreateDialog(Bundle savedInstanceState) {
		final Dialog dialog = super.onCreateDialog(savedInstanceState);
		dialog.getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE);
		return dialog;
	}

	@Override
	public void onResume() {
		super.onResume();
		getDialog().setOnKeyListener(new DialogInterface.OnKeyListener() {
			@Override
			public boolean onKey(DialogInterface dialog, int keyCode, KeyEvent event) {
				if (keyCode == android.view.KeyEvent.KEYCODE_BACK) {
					if (event.getAction() == KeyEvent.ACTION_DOWN) {
						return true;
					} else {
						dismissCheckForChanges();
						return true;
					}
				}
				return false;
			}
		});
	}

	@Override
	public void onSaveInstanceState(Bundle outState) {
		outState.putSerializable(TAGS_LIST, (Serializable) editPoiData.getTagValues());
		super.onSaveInstanceState(outState);
	}

	@Override
	public void show(FragmentManager manager, String tag) {
		if (manager.findFragmentByTag(TAG) == null) {
			super.show(manager, TAG);
		}
	}

	@Override
	public int show(FragmentTransaction transaction, String tag) {
		throw new UnsupportedOperationException("Please use show(FragmentManager manager, String tag)");
	}

	private void trySave() {
		if (TextUtils.isEmpty(poiTypeEditText.getText())) {
			HashSet<String> tagsCopy = new HashSet<>();
			tagsCopy.addAll(editPoiData.getTagValues().keySet());
			if (Algorithms.isEmpty(editPoiData.getTag(OSMSettings.OSMTagKey.ADDR_HOUSE_NUMBER.getValue()))) {
				SaveExtraValidationDialogFragment f = new SaveExtraValidationDialogFragment();
				Bundle args = new Bundle();
				args.putInt("message", R.string.save_poi_without_poi_type_message);
				f.setArguments(args);
				f.show(getChildFragmentManager(), "dialog");
				// poiTypeEditText.setError(getResources().getString(R.string.please_specify_poi_type));
			} else {
				save();
			}
		} else if (testTooManyCapitalLetters(editPoiData.getTag(OSMSettings.OSMTagKey.NAME.getValue()))) {
			SaveExtraValidationDialogFragment f = new SaveExtraValidationDialogFragment();
			Bundle args = new Bundle();
			args.putInt("message", R.string.save_poi_too_many_uppercase);
			f.setArguments(args);
			f.show(getChildFragmentManager(), "dialog");			
		} else if (editPoiData.getPoiCategory() == getMyApplication().getPoiTypes().getOtherPoiCategory()) {
			poiTypeEditText.setError(getResources().getString(R.string.please_specify_poi_type));
		} else if (editPoiData.getPoiTypeDefined() == null) {
			poiTypeEditText.setError(getResources().getString(R.string.please_specify_poi_type_only_from_list));
		} else {
			save();
		}
	}

	private boolean testTooManyCapitalLetters(String name) {
		if(name == null) {
			return false;
		}
		int capital = 0;
		int lower = 0;
		int nonalpha = 0;
		for(int i = 0; i < name.length(); i++) {
			char c = name.charAt(i);
			if(Character.isLetter(c) || Character.getType(c) == Character.LETTER_NUMBER) {
				if(Character.isUpperCase(c)) {
					capital ++;
				} else {
					lower ++;
				}
			} else {
				nonalpha ++;
			}
		}
		return capital > nonalpha && capital > lower;
	}

	private void save() {
		Node original = editPoiData.getEntity();
		final boolean offlineEdit = mOpenstreetmapUtil instanceof OpenstreetmapLocalUtil;
		Node node = new Node(original.getLatitude(), original.getLongitude(), original.getId());
		OsmPoint.Action action = node.getId() < 0 ? OsmPoint.Action.CREATE : OsmPoint.Action.MODIFY;
		for (Map.Entry<String, String> tag : editPoiData.getTagValues().entrySet()) {
			if (!Algorithms.isEmpty(tag.getKey()) && !Algorithms.isEmpty(tag.getValue()) && 
					!tag.getKey().equals(EditPoiData.POI_TYPE_TAG)) {
				node.putTagNoLC(tag.getKey(), tag.getValue());
			}
		}
		String poiTypeTag = editPoiData.getTagValues().get(EditPoiData.POI_TYPE_TAG);
		String comment = "";
		if (poiTypeTag != null) {
			final PoiType poiType = editPoiData.getAllTranslatedSubTypes().get(poiTypeTag.trim().toLowerCase());
			if (poiType != null) {
				node.putTagNoLC(poiType.getOsmTag(), poiType.getOsmValue());
				node.removeTag(EditPoiData.REMOVE_TAG_PREFIX + poiType.getOsmTag());
				if (poiType.getOsmTag2() != null) {
					node.putTagNoLC(poiType.getOsmTag2(), poiType.getOsmValue2());
					node.removeTag(EditPoiData.REMOVE_TAG_PREFIX + poiType.getOsmTag2());
				}
			} else if (!Algorithms.isEmpty(poiTypeTag)) {
				node.putTagNoLC(editPoiData.getPoiCategory().getDefaultTag(), poiTypeTag);

			}
			if (offlineEdit && !Algorithms.isEmpty(poiTypeTag)) {
				node.putTagNoLC(EditPoiData.POI_TYPE_TAG, poiTypeTag);
			}
			String actionString = action == OsmPoint.Action.CREATE ? getString(R.string.default_changeset_add) : getString(R.string.default_changeset_edit);
			comment = actionString + " " + poiTypeTag;
		}
		commitNode(action, node, mOpenstreetmapUtil.getEntityInfo(node.getId()), comment, false,
				new CallbackWithObject<Node>() {

					@Override
					public boolean processResult(Node result) {
						if (result != null) {
							OsmEditingPlugin plugin = OsmandPlugin.getPlugin(OsmEditingPlugin.class);
							if (plugin != null && offlineEdit) {
								List<OpenstreetmapPoint> points = plugin.getDBPOI().getOpenstreetmapPoints();
								if (getActivity() instanceof MapActivity && points.size() > 0) {
									OsmPoint point = points.get(points.size() - 1);
									MapActivity mapActivity = (MapActivity) getActivity();
									mapActivity.getContextMenu().showOrUpdate(
											new LatLon(point.getLatitude(), point.getLongitude()),
											plugin.getOsmEditsLayer(mapActivity).getObjectName(point), point);
								}
							}

							if (getActivity() instanceof MapActivity) {
								((MapActivity) getActivity()).getMapView().refreshMap(true);
							}
							dismiss();
						} else {
							OsmEditingPlugin plugin = OsmandPlugin.getPlugin(OsmEditingPlugin.class);
							mOpenstreetmapUtil = plugin.getPoiModificationLocalUtil();
							Button saveButton = (Button) view.findViewById(R.id.saveButton);
							saveButton.setText(mOpenstreetmapUtil instanceof OpenstreetmapRemoteUtil
									? R.string.shared_string_upload : R.string.shared_string_save);
						}

						return false;
					}
				}, getActivity(), mOpenstreetmapUtil);
	}

	private void dismissCheckForChanges() {
		if (editPoiData.hasChangesBeenMade()) {
			new AreYouSureDialogFragment().show(getChildFragmentManager(),
					"AreYouSureDialogFragment");
		} else {
			dismiss();
		}
	}

	public EditPoiData getEditPoiData() {
		return editPoiData;
	}

	public void setSubCategory(String subCategory) {
		poiTypeEditText.setText(subCategory);
	}

	public static void commitNode(final OsmPoint.Action action,
								  final Node node,
								  final EntityInfo info,
								  final String comment,
								  final boolean closeChangeSet,
								  final CallbackWithObject<Node> postExecute,
								  final Activity activity,
								  final OpenstreetmapUtil openstreetmapUtil) {
		if (info == null && OsmPoint.Action.CREATE != action && openstreetmapUtil instanceof OpenstreetmapRemoteUtil) {
			Toast.makeText(activity, activity.getResources().getString(R.string.poi_error_info_not_loaded), Toast.LENGTH_LONG).show();
			return;
		}
		new AsyncTask<Void, Void, Node>() {
			ProgressDialog progress;

			@Override
			protected void onPreExecute() {
				progress = ProgressDialog.show(activity, activity.getString(R.string.uploading), activity.getString(R.string.uploading_data));
				super.onPreExecute();
			}

			@Override
			protected Node doInBackground(Void... params) {
				return openstreetmapUtil.commitNodeImpl(action, node, info, comment, closeChangeSet);
			}

			@Override
			protected void onPostExecute(Node result) {
				progress.dismiss();
				if (postExecute != null) {
					postExecute.processResult(result);
				}
			}
		}.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
	}

	public void setPoiCategory(PoiCategory type) {
		editPoiData.updateType(type);
		poiTypeEditText.setText(editPoiData.getPoiTypeString());
		setAdapterForPoiTypeEditText();
	}

	private void setAdapterForPoiTypeEditText() {
		final Map<String, PoiType> subCategories = new LinkedHashMap<>();
		PoiCategory ct = editPoiData.getPoiCategory();
		if (ct != null) {
			for (PoiType s : ct.getPoiTypes()) {
				if (!s.isReference() && !s.isNotEditableOsm() && s.getBaseLangType() == null) {
					addMapEntryAdapter(subCategories, s.getTranslation(), s);
					if(!s.getKeyName().contains("osmand")) {
						addMapEntryAdapter(subCategories, s.getKeyName().replace('_', ' '), s);
					}
				}
			}
		}
		for (Map.Entry<String, PoiType> s : editPoiData.getAllTranslatedSubTypes().entrySet()) {
			addMapEntryAdapter(subCategories, s.getKey(), s.getValue());
		}
		final ArrayAdapter<Object> adapter;
		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
			adapter = new ArrayAdapter<>(getActivity(),
					R.layout.list_textview, subCategories.keySet().toArray());
		} else {
			TypedValue typedValue = new TypedValue();
			Resources.Theme theme = getActivity().getTheme();
			theme.resolveAttribute(android.R.attr.textColorSecondary, typedValue, true);
			final int textColor = typedValue.data;

			adapter = new ArrayAdapter<Object>(getActivity(),
					R.layout.list_textview, subCategories.keySet().toArray()) {
				@Override
				public View getView(int position, View convertView, ViewGroup parent) {
					final View view = super.getView(position, convertView, parent);
					((TextView) view.findViewById(R.id.textView)).setTextColor(textColor);
					return view;
				}
			};
		}
		adapter.sort(new Comparator<Object>() {
			@Override
			public int compare(Object lhs, Object rhs) {
				return lhs.toString().compareTo(rhs.toString());
			}
		});
		poiTypeEditText.setAdapter(adapter);
		poiTypeEditText.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {

			@Override
			public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
				Object item = parent.getAdapter().getItem(position);
				poiTypeEditText.setText(item.toString());
				setAdapterForPoiTypeEditText();
			}

			@Override
			public void onNothingSelected(AdapterView<?> parent) {
			}
		});

	}

	private void addMapEntryAdapter(final Map<String, PoiType> subCategories, String key, PoiType v) {
		if (!subCategories.containsKey(key.toLowerCase())) {
			subCategories.put(Algorithms.capitalizeFirstLetterAndLowercase(key), v);
		}
	}

	public static EditPoiDialogFragment createAddPoiInstance(double latitude, double longitude,
															 OsmandApplication application) {
		Node node = new Node(latitude, longitude, -1);
		return createInstance(node, true);
	}

	public static EditPoiDialogFragment createInstance(Node node, boolean isAddingPoi) {
		EditPoiDialogFragment editPoiDialogFragment = new EditPoiDialogFragment();
		Bundle args = new Bundle();
		args.putSerializable(KEY_AMENITY_NODE, node);
		args.putBoolean(IS_ADDING_POI, isAddingPoi);
		editPoiDialogFragment.setArguments(args);
		return editPoiDialogFragment;
	}

	public static EditPoiDialogFragment createInstance(Node node, boolean isAddingPoi, Map<String, String> tagList) {
		EditPoiDialogFragment editPoiDialogFragment = new EditPoiDialogFragment();
		Bundle args = new Bundle();
		args.putSerializable(KEY_AMENITY_NODE, node);
		args.putBoolean(IS_ADDING_POI, isAddingPoi);
		args.putSerializable(TAGS_LIST, (Serializable) Collections.unmodifiableMap(tagList));
		editPoiDialogFragment.setArguments(args);
		return editPoiDialogFragment;
	}

	public static void showEditInstance(final Amenity amenity,
										final AppCompatActivity activity) {
		final OsmandSettings settings = ((OsmandApplication) activity.getApplication())
				.getSettings();
		final OpenstreetmapUtil openstreetmapUtilToLoad;
		OsmEditingPlugin plugin = OsmandPlugin.getPlugin(OsmEditingPlugin.class);
		if (//settings.OFFLINE_EDITION.get() ||
				!settings.isInternetConnectionAvailable(true)) {
			openstreetmapUtilToLoad = plugin.getPoiModificationLocalUtil();
		} else {
			openstreetmapUtilToLoad = plugin.getPoiModificationRemoteUtil();
		}
		new AsyncTask<Void, Void, Node>() {
			@Override
			protected Node doInBackground(Void... params) {
				return openstreetmapUtilToLoad.loadNode(amenity);
			}

			protected void onPostExecute(Node n) {
				if (n != null) {
					EditPoiDialogFragment fragment =
							EditPoiDialogFragment.createInstance(n, false);
					fragment.show(activity.getSupportFragmentManager(), TAG);
				} else {
					Toast.makeText(activity,
							activity.getString(R.string.poi_error_poi_not_found),
							Toast.LENGTH_LONG).show();
				}
			}
		}.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
	}

	public static class MyAdapter extends FragmentPagerAdapter {
		private final Fragment[] fragments = new Fragment[]{new BasicEditPoiFragment(),
				new AdvancedEditPoiFragment()};
		private final String[] titles;

		public MyAdapter(FragmentManager fm, String basicTitle, String extendedTitle) {
			super(fm);
			titles = new String[]{basicTitle, extendedTitle};
		}

		@Override
		public int getCount() {
			return 2;
		}

		@Override
		public Fragment getItem(int position) {
			return fragments[position];
		}

		@Override
		public CharSequence getPageTitle(int position) {
			return titles[position];
		}
	}

	public static class ShowDeleteDialogAsyncTask extends AsyncTask<Amenity, Void, Node> {
		private final OpenstreetmapUtil openstreetmapUtil;
		private final AppCompatActivity activity;

		public ShowDeleteDialogAsyncTask(AppCompatActivity activity) {
			this.activity = activity;
			OsmandSettings settings = ((OsmandApplication) activity.getApplication()).getSettings();
			OsmEditingPlugin plugin = OsmandPlugin.getPlugin(OsmEditingPlugin.class);
			if (settings.OFFLINE_EDITION.get() || !settings.isInternetConnectionAvailable(true)) {
				openstreetmapUtil = plugin.getPoiModificationLocalUtil();
			} else {
				openstreetmapUtil = plugin.getPoiModificationRemoteUtil();
			}
		}

		protected Node doInBackground(Amenity[] params) {
			return openstreetmapUtil.loadNode(params[0]);
		}

		protected void onPostExecute(final Node n) {
			if (n == null) {
				Toast.makeText(activity, activity.getResources().getString(R.string.poi_error_poi_not_found), Toast.LENGTH_LONG).show();
				return;
			}
			AlertDialog.Builder builder = new AlertDialog.Builder(activity);
			builder.setTitle(R.string.poi_remove_title);
			final EditText comment;
			final CheckBox closeChangesetCheckBox;
			final boolean isLocalEdit = openstreetmapUtil instanceof OpenstreetmapLocalUtil;
			if (isLocalEdit) {
				closeChangesetCheckBox = null;
				comment = null;
			} else {
				LinearLayout ll = new LinearLayout(activity);
				ll.setPadding(16, 2, 16, 0);
				ll.setOrientation(LinearLayout.VERTICAL);
				closeChangesetCheckBox = new CheckBox(activity);
				closeChangesetCheckBox.setText(R.string.close_changeset);
				ll.addView(closeChangesetCheckBox);
				comment = new EditText(activity);
				comment.setText(R.string.poi_remove_title);
				ll.addView(comment);
				builder.setView(ll);
			}
			builder.setNegativeButton(R.string.shared_string_cancel, null);
			builder.setPositiveButton(isLocalEdit ? R.string.shared_string_save : R.string.shared_string_delete, new DialogInterface.OnClickListener() {
				@Override
				public void onClick(DialogInterface dialog, int which) {
					String c = comment == null ? null : comment.getText().toString();
					boolean closeChangeSet = closeChangesetCheckBox != null
							&& closeChangesetCheckBox.isChecked();
					deleteNode(n, c, closeChangeSet);
				}


			});
			builder.create().show();
		}

		private void deleteNode(final Node n, final String c, final boolean closeChangeSet) {
			final boolean isLocalEdit = openstreetmapUtil instanceof OpenstreetmapLocalUtil;
			commitNode(OsmPoint.Action.DELETE, n, openstreetmapUtil.getEntityInfo(n.getId()), c, closeChangeSet,
					new CallbackWithObject<Node>() {

						@Override
						public boolean processResult(Node result) {
							if (result != null) {
								if (isLocalEdit) {
									Toast.makeText(activity, R.string.osm_changes_added_to_local_edits,
											Toast.LENGTH_LONG).show();
								} else {
									Toast.makeText(activity, R.string.poi_remove_success, Toast.LENGTH_LONG)
											.show();
								}
								if (activity instanceof MapActivity) {
									((MapActivity) activity).getMapView().refreshMap(true);
								}
							}
							return false;
						}
					}, activity, openstreetmapUtil);
		}
	}

	public static class SaveExtraValidationDialogFragment extends DialogFragment {
		@NonNull
		@Override
		public Dialog onCreateDialog(Bundle savedInstanceState) {
			AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
			String msg = getString(R.string.save_poi_without_poi_type_message);
			int i = getArguments().getInt("message", 0);
			if(i != 0) {
				msg = getString(i);
			}
			builder.setTitle(getResources().getString(R.string.are_you_sure))
					.setMessage(msg)
					.setPositiveButton(R.string.shared_string_ok, new DialogInterface.OnClickListener() {
						@Override
						public void onClick(DialogInterface dialog, int which) {
							((EditPoiDialogFragment) getParentFragment()).save();
						}
					})
					.setNegativeButton(R.string.shared_string_cancel, null);
			return builder.create();
		}
	}

	public static class AreYouSureDialogFragment extends DialogFragment {
		@NonNull
		@Override
		public Dialog onCreateDialog(Bundle savedInstanceState) {
			AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
			builder.setTitle(getResources().getString(R.string.are_you_sure))
					.setMessage(getString(R.string.unsaved_changes_will_be_lost))
					.setPositiveButton(R.string.shared_string_ok, new DialogInterface.OnClickListener() {
						@Override
						public void onClick(DialogInterface dialog, int which) {
							((DialogFragment) getParentFragment()).dismiss();
						}
					})
					.setNegativeButton(R.string.shared_string_cancel, null);
			return builder.create();
		}
	}

	private TextView.OnEditorActionListener mOnEditorActionListener =
			new TextView.OnEditorActionListener() {
				@Override
				public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
					boolean handled = false;
					if (actionId == EditorInfo.IME_ACTION_SEND) {
						trySave();
						handled = true;
					}
					return handled;
				}
			};

	public interface OnFragmentActivatedListener {
		void onFragmentActivated();
	}
}
!@#$%
20190530_062751,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_b03008
package net.osmand.search.core;

import net.osmand.Collator;
import net.osmand.CollatorStringMatcher;
import net.osmand.CollatorStringMatcher.StringMatcherMode;
import net.osmand.StringMatcher;
import net.osmand.binary.BinaryMapIndexReader;
import net.osmand.binary.CommonWords;
import net.osmand.binary.BinaryMapIndexReader.SearchRequest;
import net.osmand.data.LatLon;
import net.osmand.data.QuadRect;
import net.osmand.util.Algorithms;
import net.osmand.util.MapUtils;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.regex.Pattern;

//immutable object
public class SearchPhrase {
	
	private List<SearchWord> words = new ArrayList<>();
	private List<String> unknownWords = new ArrayList<>();
	private List<NameStringMatcher> unknownWordsMatcher = new ArrayList<>();
	private String unknownSearchWordTrim;
	private String unknownSearchPhrase = "";
	
	private NameStringMatcher sm;
	private SearchSettings settings;
	private List<BinaryMapIndexReader> indexes;
	
	private QuadRect cache1kmRect;
	private boolean lastUnknownSearchWordComplete;
	private static final String DELIMITER = " ";
	private static final String ALLDELIMITERS = "\\s|,";
	private static final Pattern reg = Pattern.compile(ALLDELIMITERS);
	private Collator clt;
	
	private static Set<String> conjunctions = new TreeSet<>();
	static {
		// the
		conjunctions.add("the");
		conjunctions.add("der");
		conjunctions.add("den");
		conjunctions.add("die");
		conjunctions.add("das");
		conjunctions.add("la");
		conjunctions.add("le");
		conjunctions.add("el");
		conjunctions.add("il");
		// and
		conjunctions.add("and");
		conjunctions.add("und");
		conjunctions.add("en");
		conjunctions.add("et");
		conjunctions.add("y");
		conjunctions.add("?");
		// short 
		conjunctions.add("f");
		conjunctions.add("u");
		conjunctions.add("jl.");
		conjunctions.add("j");
		conjunctions.add("sk");
		conjunctions.add("w");
		conjunctions.add("a.");
		conjunctions.add("of");
		conjunctions.add("k");
		conjunctions.add("r");
		conjunctions.add("h");
		conjunctions.add("mc");
		conjunctions.add("sw");
		conjunctions.add("g");
		conjunctions.add("v");
		conjunctions.add("m");
		conjunctions.add("c.");
		conjunctions.add("r.");
		conjunctions.add("ct");
		conjunctions.add("e.");
		conjunctions.add("dr.");
		conjunctions.add("j.");		
		conjunctions.add("in");
		conjunctions.add("al");
		conjunctions.add("t");
		conjunctions.add("per");
		conjunctions.add("ne");
		conjunctions.add("p");
		conjunctions.add("et");
		conjunctions.add("s.");
		conjunctions.add("f.");
		conjunctions.add("t");
		conjunctions.add("fe");
		conjunctions.add("");
		conjunctions.add("i");
		conjunctions.add("c");
		conjunctions.add("le");
		conjunctions.add("s");
		conjunctions.add("av.");
		conjunctions.add("den");
		conjunctions.add("dr");
		conjunctions.add("y");
	}
	
	
	public enum SearchPhraseDataType {
		MAP, ADDRESS, ROUTING, POI
	}
	
	
	public SearchPhrase(SearchSettings settings, Collator clt) {
		this.settings = settings;
		this.clt = clt;
	}
	
	public Collator getCollator() {
		return clt;
	}
	
	public SearchPhrase generateNewPhrase(String text, SearchSettings settings) {
		SearchPhrase sp = new SearchPhrase(settings, this.clt);
		String restText = text;
		List<SearchWord> leftWords = this.words;
		String thisTxt = getText(true);
		if (text.startsWith(thisTxt)) {
			// string is longer
			restText = text.substring(getText(false).length());
			sp.words = new ArrayList<>(this.words);
			leftWords = leftWords.subList(leftWords.size(), leftWords.size());
		}
		for(SearchWord w : leftWords) {
			if(restText.startsWith(w.getWord() + DELIMITER)) {
				sp.words.add(w);
				restText = restText.substring(w.getWord().length() + DELIMITER.length()).trim();
			} else {
				break;
			}
		}
		sp.unknownSearchPhrase = restText;
		sp.unknownWords.clear();
		sp.unknownWordsMatcher.clear();
		
		if (!reg.matcher(restText).find()) {
			sp.unknownSearchWordTrim = sp.unknownSearchPhrase.trim();
		} else {
			sp.unknownSearchWordTrim = "";
			String[] ws = restText.split(ALLDELIMITERS);
			boolean first = true;
			for (int i = 0; i < ws.length ; i++) {
				String wd = ws[i].trim();
				if (wd.length() > 0 && !conjunctions.contains(wd.toLowerCase())) {
					if (first) {
						sp.unknownSearchWordTrim = wd;
						first = false;
					} else {
						sp.unknownWords.add(wd);
					}
				}
			}
		}
		sp.lastUnknownSearchWordComplete = false;
		if (text.length() > 0 ) {
			char ch = text.charAt(text.length() - 1);
			sp.lastUnknownSearchWordComplete = ch == ' ' || ch == ',' || ch == '\r' || ch == '\n'
					|| ch == ';';
		}
		
		return sp;
	}
	

	public List<SearchWord> getWords() {
		return words;
	}
	

	public boolean isUnknownSearchWordComplete() {
		return lastUnknownSearchWordComplete || unknownWords.size() > 0;
	}
	
	public boolean isLastUnknownSearchWordComplete() {
		return lastUnknownSearchWordComplete;
	}


	public List<String> getUnknownSearchWords() {
		return unknownWords;
	}
	
	public List<String> getUnknownSearchWords(Collection<String> exclude) {
		if(exclude == null || unknownWords.size() == 0 || exclude.size() == 0) {
			return unknownWords;
		}
		List<String> l = new ArrayList<>();
		for(String uw : unknownWords) {
			if(exclude == null || !exclude.contains(uw)) {
				l.add(uw);
			}
		}
		return l;
	}
	
	
	public String getUnknownSearchWord() {
		return unknownSearchWordTrim;
	}
	
	public String getUnknownSearchPhrase() {
		return unknownSearchPhrase;
	}
	
	public boolean isUnknownSearchWordPresent() {
		return unknownSearchWordTrim.length() > 0;
	}
	
	public int getUnknownSearchWordLength() {
		return unknownSearchWordTrim.length() ;
	}
	
	
	public QuadRect getRadiusBBoxToSearch(int radius) {
		int radiusInMeters = getRadiusSearch(radius);
		QuadRect cache1kmRect = get1km31Rect();
		if(cache1kmRect == null) {
			return null;
		}
		int max = (1 << 31) - 1;
		double dx = (cache1kmRect.width() / 2) * radiusInMeters / 1000;
		double dy = (cache1kmRect.height() / 2) * radiusInMeters / 1000;
		double topLeftX = Math.max(0, cache1kmRect.left - dx);
		double topLeftY = Math.max(0, cache1kmRect.top - dy);
		double bottomRightX = Math.min(max, cache1kmRect.right + dx);
		double bottomRightY = Math.min(max, cache1kmRect.bottom + dy);
		return new QuadRect(topLeftX, topLeftY, bottomRightX, bottomRightY);
	}
	
	public QuadRect get1km31Rect() {
		if(cache1kmRect != null) {
			return cache1kmRect;
		}
		LatLon l = getLastTokenLocation();
		if (l == null) {
			return null;
		}
		float coeff = (float) (1000 / MapUtils.getTileDistanceWidth(SearchRequest.ZOOM_TO_SEARCH_POI));
		double tx = MapUtils.getTileNumberX(SearchRequest.ZOOM_TO_SEARCH_POI, l.getLongitude());
		double ty = MapUtils.getTileNumberY(SearchRequest.ZOOM_TO_SEARCH_POI, l.getLatitude());
		double topLeftX = Math.max(0, tx - coeff);
		double topLeftY = Math.max(0, ty - coeff);
		int max = (1 << SearchRequest.ZOOM_TO_SEARCH_POI)  - 1;
		double bottomRightX = Math.min(max, tx + coeff);
		double bottomRightY = Math.min(max, ty + coeff);
		double pw = MapUtils.getPowZoom(31 - SearchRequest.ZOOM_TO_SEARCH_POI);
		cache1kmRect = new QuadRect(topLeftX * pw, topLeftY * pw, bottomRightX * pw, bottomRightY * pw);
		return cache1kmRect;
	}
	
	
	public Iterator<BinaryMapIndexReader> getRadiusOfflineIndexes(int meters, final SearchPhraseDataType dt) {
		final QuadRect rect = meters > 0 ? getRadiusBBoxToSearch(meters) : null;
		return getOfflineIndexes(rect, dt);
		
	}

	public Iterator<BinaryMapIndexReader> getOfflineIndexes(final QuadRect rect, final SearchPhraseDataType dt) {
		List<BinaryMapIndexReader> list = indexes != null ? indexes : settings.getOfflineIndexes();
		final Iterator<BinaryMapIndexReader> lit = list.iterator();
		return new Iterator<BinaryMapIndexReader>() {
			BinaryMapIndexReader next = null;
			@Override
			public boolean hasNext() {
				while (lit.hasNext()) {
					next = lit.next();
					if(rect != null) {
						if(dt == SearchPhraseDataType.POI) {
							if(next.containsPoiData((int)rect.left, (int)rect.top, (int)rect.right, (int)rect.bottom)) {
								return true;
							}
						} else if(dt == SearchPhraseDataType.ADDRESS) {
							// containsAddressData not all maps supported
							if(next.containsPoiData((int)rect.left, (int)rect.top, (int)rect.right, (int)rect.bottom) && 
									next.containsAddressData()) {
								return true;
							}
						} else if(dt == SearchPhraseDataType.ROUTING) {
							if(next.containsRouteData((int)rect.left, (int)rect.top, (int)rect.right, (int)rect.bottom, 15)) {
								return true;
							}
						} else {
							if(next.containsMapData((int)rect.left, (int)rect.top, (int)rect.right, (int)rect.bottom, 15)) {
								return true;
							}
						}
					} else {
						return true;
					}
				}
				return false;
			}

			@Override
			public BinaryMapIndexReader next() {
				return next;
			}

			@Override
			public void remove() {
			}
		};
	}
	
	public List<BinaryMapIndexReader> getOfflineIndexes() {
		if(indexes != null) {
			return indexes; 
		}
		return settings.getOfflineIndexes();
	}
	
	public SearchSettings getSettings() {
		return settings;
	}
	
	
	public int getRadiusLevel() {
		return settings.getRadiusLevel();
	}

	public ObjectType[] getSearchTypes() {
		return settings == null ? null : settings.getSearchTypes();
	}

	public boolean isCustomSearch() {
		return getSearchTypes() != null;
	}

	public boolean isSearchTypeAllowed(ObjectType searchType) {
		if (getSearchTypes() == null) {
			return true;
		} else {
			for (ObjectType type : getSearchTypes()) {
				if (type == searchType) {
					return true;
				}
			}
			return false;
		}
	}

	public boolean isEmptyQueryAllowed() {
		return settings.isEmptyQueryAllowed();
	}

	public boolean isSortByName() {
		return settings.isSortByName();
	}

	public boolean isInAddressSearch() {
		return settings.isInAddressSearch();
	}

	public SearchPhrase selectWord(SearchResult res) {
		return selectWord(res, null, false);
	}
	
	public SearchPhrase selectWord(SearchResult res, List<String> unknownWords, boolean lastComplete) {
		SearchPhrase sp = new SearchPhrase(this.settings, this.clt);
		addResult(res, sp);
		SearchResult prnt = res.parentSearchResult;
		while(prnt != null) {
			addResult(prnt, sp);
			prnt = prnt.parentSearchResult;
		}
		sp.words.addAll(0, this.words);	
		if(unknownWords != null) {
			sp.lastUnknownSearchWordComplete = lastComplete;
			for (int i = 0; i < unknownWords.size(); i++) {
				if (i == 0) {
					sp.unknownSearchWordTrim = unknownWords.get(0);
				} else {
					sp.unknownWords.add(unknownWords.get(i));
				}
			}
		}
		return sp;
	}

	private void addResult(SearchResult res, SearchPhrase sp) {
		SearchWord sw = new SearchWord(res.wordsSpan != null ? res.wordsSpan : res.localeName.trim(), res);
		sp.words.add(0, sw);
	}
	
	public boolean isLastWord(ObjectType... p) {
		for (int i = words.size() - 1; i >= 0; i--) {
			SearchWord sw = words.get(i);
			for(ObjectType o : p) {
				if (sw.getType() == o) {
					return true;
				}
			}
			if (sw.getType() != ObjectType.UNKNOWN_NAME_FILTER) {
				return false;
			}
		}
		return false;
	}

	public ObjectType getExclusiveSearchType() {
		SearchWord lastWord = getLastSelectedWord();
		if (lastWord != null) {
			return ObjectType.getExclusiveSearchType(lastWord.getType());
		}
		return null;
	}

	public NameStringMatcher getNameStringMatcher() {
		if(sm != null) {
			return sm;
		}
		sm = getNameStringMatcher(unknownSearchWordTrim, lastUnknownSearchWordComplete);
		return sm;
	}
	
	
	public NameStringMatcher getNameStringMatcher(String word, boolean complete) {
		return new NameStringMatcher(word, 
				(complete ?  
					StringMatcherMode.CHECK_EQUALS_FROM_SPACE : 
					StringMatcherMode.CHECK_STARTS_FROM_SPACE));
	}
	
	public boolean hasObjectType(ObjectType p) {
		for(SearchWord s : words) {
			if(s.getType() == p) {
				return true;
			}
		}
		return false;
	}

	public void syncWordsWithResults() {
		for(SearchWord w : words) {
			w.syncWordWithResult();
		}
	}

	public String getText(boolean includeLastWord) {
		StringBuilder sb = new StringBuilder();
		for(SearchWord s : words) {
			sb.append(s.getWord()).append(DELIMITER.trim() + " ");
		}
		if(includeLastWord) {
			sb.append(unknownSearchPhrase);
		}
		return sb.toString();
	}

	public String getTextWithoutLastWord() {
		StringBuilder sb = new StringBuilder();
		List<SearchWord> words = new ArrayList<>(this.words);
		if(Algorithms.isEmpty(unknownSearchWordTrim) && words.size() > 0) {
			words.remove(words.size() - 1);
		}
		for(SearchWord s : words) {
			sb.append(s.getWord()).append(DELIMITER.trim() + " ");
		}
		return sb.toString();
	}

	public String getStringRerpresentation() {
		StringBuilder sb = new StringBuilder();
		for(SearchWord s : words) {
			sb.append(s.getWord()).append(" [" + s.getType() + "], ");
		}
		sb.append(unknownSearchPhrase);
		return sb.toString();
	}
	
	@Override
	public String toString() {
		return getStringRerpresentation();
	}

	public boolean isNoSelectedType() {
		return words.isEmpty();
	}

	public boolean isEmpty() {
		return words.isEmpty() && unknownSearchPhrase.isEmpty();
	}

	public SearchWord getLastSelectedWord() {
		if(words.isEmpty()) {
			return null;
		}
		return words.get(words.size() - 1);
	}
	
	public LatLon getWordLocation() {
		for(int i = words.size() - 1; i >= 0; i--) {
			SearchWord sw = words.get(i);
			if(sw.getLocation() != null) {
				return sw.getLocation();
			}
		}
		return null;
	}
	
	public LatLon getLastTokenLocation() {
		for(int i = words.size() - 1; i >= 0; i--) {
			SearchWord sw = words.get(i);
			if(sw.getLocation() != null) {
				return sw.getLocation();
			}
		}
		// last token or myLocationOrVisibleMap if not selected 
		return settings.getOriginalLocation();
	}

	public void selectFile(BinaryMapIndexReader object) {
		if(indexes == null) {
			indexes = new ArrayList<>();
		}
		if(!this.indexes.contains(object)) {
			this.indexes.add(object);
		}
	}

    public void sortFiles() {
        if (indexes == null) {
            indexes = new ArrayList<>(getOfflineIndexes());
        }
        Map<String, List<BinaryMapIndexReader>> diffsByRegion = getDiffsByRegion();
        final LatLon ll = getLastTokenLocation();
        if (ll != null) {
            Collections.sort(indexes, new Comparator<BinaryMapIndexReader>() {
                Map<BinaryMapIndexReader, LatLon> locations = new HashMap<>();

                @Override
                public int compare(BinaryMapIndexReader o1, BinaryMapIndexReader o2) {
                    LatLon rc1 = o1 == null ? null : getLocation(o1);
                    LatLon rc2 = o2 == null ? null : getLocation(o2);
                    double d1 = rc1 == null ? 10000000d : MapUtils.getDistance(rc1, ll);
                    double d2 = rc2 == null ? 10000000d : MapUtils.getDistance(rc2, ll);
                    return Double.compare(d1, d2);
                }

                private LatLon getLocation(BinaryMapIndexReader o1) {
                    if (locations.containsKey(o1)) {
                        return locations.get(o1);
                    }
                    LatLon rc1 = null;
                    if (o1.containsMapData()) {
                        rc1 = o1.getMapIndexes().get(0).getCenterLatLon();
                    } else {
                        rc1 = o1.getRegionCenter();
                    }
                    locations.put(o1, rc1);
                    return rc1;
                }
            });
            if (!diffsByRegion.isEmpty()) {
                List<BinaryMapIndexReader> finalSort = new ArrayList<>();
                for (int i = 0; i < indexes.size(); i++) {
                    BinaryMapIndexReader currFile = indexes.get(i);
                    if (diffsByRegion.get(currFile.getRegionName()) != null) {
                        finalSort.addAll(diffsByRegion.get(currFile.getRegionName()));
                        finalSort.add(currFile);
                    } else {
                        finalSort.add(currFile);
                    }
                }
                indexes.clear();
                indexes.addAll(finalSort);
            }
        }
    }

    private Map<String, List<BinaryMapIndexReader>> getDiffsByRegion() {
        Map<String, List<BinaryMapIndexReader>> result = new HashMap<>();
        Iterator<BinaryMapIndexReader> it = indexes.iterator();
        while (it.hasNext()) {
            BinaryMapIndexReader r = it.next();
            String filename = r.getFile().getName();
            if (filename.matches("([a-zA-Z-]+_)+([0-9]+_){2}[0-9]+\\.obf")) {
                String currRegionName = r.getRegionName();
                if (result.containsKey(currRegionName)) {
                    result.get(currRegionName).add(r);
                } else {
                    result.put(currRegionName, new ArrayList<>(Arrays.asList(r)));
                }
                it.remove();
            }
        }
        return result;
    }

	public static class NameStringMatcher implements StringMatcher {

		private CollatorStringMatcher sm;

		public NameStringMatcher(String lastWordTrim, StringMatcherMode mode) {
			sm = new CollatorStringMatcher(lastWordTrim, mode);
		}
		
		public boolean matches(Collection<String> map) {
			if(map == null) {
				return false;
			}
			for(String v : map) {
				if(sm.matches(v)) {
					return true;
				}
			}
			return false;
		}

		@Override
		public boolean matches(String name) {
			return sm.matches(name);
		}
		
	}
	
	public void countUnknownWordsMatch(SearchResult sr) {
		countUnknownWordsMatch(sr, sr.localeName, sr.otherNames);
	}
	
	public void countUnknownWordsMatch(SearchResult sr, String localeName, Collection<String> otherNames) {
		if(unknownWords.size() > 0) {
			for(int i = 0; i < unknownWords.size(); i++) {
				if(unknownWordsMatcher.size() == i) {
					unknownWordsMatcher.add(new NameStringMatcher(unknownWords.get(i), 
							i < unknownWords.size() - 1 ? StringMatcherMode.CHECK_EQUALS_FROM_SPACE :
								StringMatcherMode.CHECK_STARTS_FROM_SPACE));
				}
				NameStringMatcher ms = unknownWordsMatcher.get(i);
				if(ms.matches(localeName) || ms.matches(otherNames)) {
					if(sr.otherWordsMatch == null) {
						sr.otherWordsMatch = new TreeSet<>();
					}
					sr.otherWordsMatch.add(unknownWords.get(i));
				}
			}
		}
		if(!sr.firstUnknownWordMatches) {
			sr.firstUnknownWordMatches = localeName.equals(getUnknownSearchWord()) ||
					getNameStringMatcher().matches(localeName) || 
					getNameStringMatcher().matches(otherNames);	
		}
		
	}
	public int getRadiusSearch(int meters) {
		return (1 << (getRadiusLevel() - 1)) * meters;
	}

	public static int icompare(int x, int y) {
        return (x < y) ? -1 : ((x == y) ? 0 : 1);
    }
	
	public String getUnknownWordToSearchBuilding() {
		List<String> unknownSearchWords = getUnknownSearchWords();
		if(unknownSearchWords.size() > 0 && Algorithms.extractFirstIntegerNumber(getUnknownSearchWord()) == 0) {
			for(String wrd : unknownSearchWords) {
				if(Algorithms.extractFirstIntegerNumber(wrd) != 0) {
					return wrd;
				}
			}
		}
		return getUnknownSearchWord();
	}
	
	public String getUnknownWordToSearch() {
		List<String> unknownSearchWords = getUnknownSearchWords();
		
		String wordToSearch = getUnknownSearchWord();
		if (unknownSearchWords.size() > 0) {
			List<String> searchWords = new ArrayList<>(unknownSearchWords);
			searchWords.add(0, getUnknownSearchWord());
			Collections.sort(searchWords, new Comparator<String>() {

				private int lengthWithoutNumbers(String s) {
					int len = 0;
					for(int k = 0; k < s.length(); k++) {
						if(s.charAt(k) >= '0' && s.charAt(k) <= '9') {
							
						} else {
							len++;
						}
					}
					return len;
				}
				
				@Override
				public int compare(String o1, String o2) {
					int i1 = CommonWords.getCommonSearch(o1.toLowerCase());
					int i2 = CommonWords.getCommonSearch(o2.toLowerCase());
					if (i1 != i2) {
						return icompare(i1, i2);
					}
					// compare length without numbers to not include house numbers
					return -icompare(lengthWithoutNumbers(o1), lengthWithoutNumbers(o2));
				}
			});						
			wordToSearch = searchWords.get(0);
		}

		return wordToSearch;
	}

	
}
!@#$%
20190530_062751,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_a03008
package net.osmand.search.core;

import net.osmand.Collator;
import net.osmand.CollatorStringMatcher;
import net.osmand.CollatorStringMatcher.StringMatcherMode;
import net.osmand.StringMatcher;
import net.osmand.binary.BinaryMapIndexReader;
import net.osmand.binary.CommonWords;
import net.osmand.binary.BinaryMapIndexReader.SearchRequest;
import net.osmand.data.LatLon;
import net.osmand.data.QuadRect;
import net.osmand.util.Algorithms;
import net.osmand.util.MapUtils;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.regex.Pattern;

//immutable object
public class SearchPhrase {
	
	private List<SearchWord> words = new ArrayList<>();
	private List<String> unknownWords = new ArrayList<>();
	private List<NameStringMatcher> unknownWordsMatcher = new ArrayList<>();
	private String unknownSearchWordTrim;
	private String unknownSearchPhrase = "";
	
	private NameStringMatcher sm;
	private SearchSettings settings;
	private List<BinaryMapIndexReader> indexes;
	
	private QuadRect cache1kmRect;
	private boolean lastUnknownSearchWordComplete;
	private static final String DELIMITER = " ";
	private static final String ALLDELIMITERS = "\\s|,";
	private static final Pattern reg = Pattern.compile(ALLDELIMITERS);
	private Collator clt;
	
	private static Set<String> conjunctions = new TreeSet<>();
	static {
		// the
		conjunctions.add("the");
		conjunctions.add("der");
		conjunctions.add("den");
		conjunctions.add("die");
		conjunctions.add("das");
		conjunctions.add("la");
		conjunctions.add("le");
		conjunctions.add("el");
		conjunctions.add("il");
		// and
		conjunctions.add("and");
		conjunctions.add("und");
		conjunctions.add("en");
		conjunctions.add("et");
		conjunctions.add("y");
		conjunctions.add("?");
		// short 
		conjunctions.add("f");
		conjunctions.add("u");
		conjunctions.add("jl.");
		conjunctions.add("j");
		conjunctions.add("sk");
		conjunctions.add("w");
		conjunctions.add("a.");
		conjunctions.add("of");
		conjunctions.add("k");
		conjunctions.add("r");
		conjunctions.add("h");
		conjunctions.add("mc");
		conjunctions.add("sw");
		conjunctions.add("g");
		conjunctions.add("v");
		conjunctions.add("m");
		conjunctions.add("c.");
		conjunctions.add("r.");
		conjunctions.add("ct");
		conjunctions.add("e.");
		conjunctions.add("dr.");
		conjunctions.add("j.");		
		conjunctions.add("in");
		conjunctions.add("al");
		conjunctions.add("t");
		conjunctions.add("per");
		conjunctions.add("ne");
		conjunctions.add("p");
		conjunctions.add("et");
		conjunctions.add("s.");
		conjunctions.add("f.");
		conjunctions.add("t");
		conjunctions.add("fe");
		conjunctions.add("");
		conjunctions.add("i");
		conjunctions.add("c");
		conjunctions.add("le");
		conjunctions.add("s");
		conjunctions.add("av.");
		conjunctions.add("den");
		conjunctions.add("dr");
		conjunctions.add("y");
	}
	
	
	public enum SearchPhraseDataType {
		MAP, ADDRESS, ROUTING, POI
	}
	
	
	public SearchPhrase(SearchSettings settings, Collator clt) {
		this.settings = settings;
		this.clt = clt;
	}
	
	public Collator getCollator() {
		return clt;
	}
	
	public SearchPhrase generateNewPhrase(String text, SearchSettings settings) {
		SearchPhrase sp = new SearchPhrase(settings, this.clt);
		String restText = text;
		List<SearchWord> leftWords = this.words;
		String thisTxt = getText(true);
		if (text.startsWith(thisTxt)) {
			// string is longer
			restText = text.substring(getText(false).length());
			sp.words = new ArrayList<>(this.words);
			leftWords = leftWords.subList(leftWords.size(), leftWords.size());
		}
		for(SearchWord w : leftWords) {
			if(restText.startsWith(w.getWord() + DELIMITER)) {
				sp.words.add(w);
				restText = restText.substring(w.getWord().length() + DELIMITER.length()).trim();
			} else {
				break;
			}
		}
		sp.unknownSearchPhrase = restText;
		sp.unknownWords.clear();
		sp.unknownWordsMatcher.clear();
		
		if (!reg.matcher(restText).find()) {
			sp.unknownSearchWordTrim = sp.unknownSearchPhrase.trim();
		} else {
			sp.unknownSearchWordTrim = "";
			String[] ws = restText.split(ALLDELIMITERS);
			boolean first = true;
			for (int i = 0; i < ws.length ; i++) {
				String wd = ws[i].trim();
				if (wd.length() > 0 && !conjunctions.contains(wd.toLowerCase())) {
					if (first) {
						sp.unknownSearchWordTrim = wd;
						first = false;
					} else {
						sp.unknownWords.add(wd);
					}
				}
			}
		}
		sp.lastUnknownSearchWordComplete = false;
		if (text.length() > 0 ) {
			char ch = text.charAt(text.length() - 1);
			sp.lastUnknownSearchWordComplete = ch == ' ' || ch == ',' || ch == '\r' || ch == '\n'
					|| ch == ';';
		}
		
		return sp;
	}
	

	public List<SearchWord> getWords() {
		return words;
	}
	

	public boolean isUnknownSearchWordComplete() {
		return lastUnknownSearchWordComplete || unknownWords.size() > 0;
	}
	
	public boolean isLastUnknownSearchWordComplete() {
		return lastUnknownSearchWordComplete;
	}


	public List<String> getUnknownSearchWords() {
		return unknownWords;
	}
	
	public List<String> getUnknownSearchWords(Collection<String> exclude) {
		if(exclude == null || unknownWords.size() == 0 || exclude.size() == 0) {
			return unknownWords;
		}
		List<String> l = new ArrayList<>();
		for(String uw : unknownWords) {
			if(exclude == null || !exclude.contains(uw)) {
				l.add(uw);
			}
		}
		return l;
	}
	
	
	public String getUnknownSearchWord() {
		return unknownSearchWordTrim;
	}
	
	public String getUnknownSearchPhrase() {
		return unknownSearchPhrase;
	}
	
	public boolean isUnknownSearchWordPresent() {
		return unknownSearchWordTrim.length() > 0;
	}
	
	public int getUnknownSearchWordLength() {
		return unknownSearchWordTrim.length() ;
	}
	
	
	public QuadRect getRadiusBBoxToSearch(int radius) {
		int radiusInMeters = getRadiusSearch(radius);
		QuadRect cache1kmRect = get1km31Rect();
		if(cache1kmRect == null) {
			return null;
		}
		int max = (1 << 31) - 1;
		double dx = (cache1kmRect.width() / 2) * radiusInMeters / 1000;
		double dy = (cache1kmRect.height() / 2) * radiusInMeters / 1000;
		double topLeftX = Math.max(0, cache1kmRect.left - dx);
		double topLeftY = Math.max(0, cache1kmRect.top - dy);
		double bottomRightX = Math.min(max, cache1kmRect.right + dx);
		double bottomRightY = Math.min(max, cache1kmRect.bottom + dy);
		return new QuadRect(topLeftX, topLeftY, bottomRightX, bottomRightY);
	}
	
	public QuadRect get1km31Rect() {
		if(cache1kmRect != null) {
			return cache1kmRect;
		}
		LatLon l = getLastTokenLocation();
		if (l == null) {
			return null;
		}
		float coeff = (float) (1000 / MapUtils.getTileDistanceWidth(SearchRequest.ZOOM_TO_SEARCH_POI));
		double tx = MapUtils.getTileNumberX(SearchRequest.ZOOM_TO_SEARCH_POI, l.getLongitude());
		double ty = MapUtils.getTileNumberY(SearchRequest.ZOOM_TO_SEARCH_POI, l.getLatitude());
		double topLeftX = Math.max(0, tx - coeff);
		double topLeftY = Math.max(0, ty - coeff);
		int max = (1 << SearchRequest.ZOOM_TO_SEARCH_POI)  - 1;
		double bottomRightX = Math.min(max, tx + coeff);
		double bottomRightY = Math.min(max, ty + coeff);
		double pw = MapUtils.getPowZoom(31 - SearchRequest.ZOOM_TO_SEARCH_POI);
		cache1kmRect = new QuadRect(topLeftX * pw, topLeftY * pw, bottomRightX * pw, bottomRightY * pw);
		return cache1kmRect;
	}
	
	
	public Iterator<BinaryMapIndexReader> getRadiusOfflineIndexes(int meters, final SearchPhraseDataType dt) {
		final QuadRect rect = meters > 0 ? getRadiusBBoxToSearch(meters) : null;
		return getOfflineIndexes(rect, dt);
		
	}

	public Iterator<BinaryMapIndexReader> getOfflineIndexes(final QuadRect rect, final SearchPhraseDataType dt) {
		List<BinaryMapIndexReader> list = indexes != null ? indexes : settings.getOfflineIndexes();
		final Iterator<BinaryMapIndexReader> lit = list.iterator();
		return new Iterator<BinaryMapIndexReader>() {
			BinaryMapIndexReader next = null;
			@Override
			public boolean hasNext() {
				while (lit.hasNext()) {
					next = lit.next();
					if(rect != null) {
						if(dt == SearchPhraseDataType.POI) {
							if(next.containsPoiData((int)rect.left, (int)rect.top, (int)rect.right, (int)rect.bottom)) {
								return true;
							}
						} else if(dt == SearchPhraseDataType.ADDRESS) {
							// containsAddressData not all maps supported
							if(next.containsPoiData((int)rect.left, (int)rect.top, (int)rect.right, (int)rect.bottom) && 
									next.containsAddressData()) {
								return true;
							}
						} else if(dt == SearchPhraseDataType.ROUTING) {
							if(next.containsRouteData((int)rect.left, (int)rect.top, (int)rect.right, (int)rect.bottom, 15)) {
								return true;
							}
						} else {
							if(next.containsMapData((int)rect.left, (int)rect.top, (int)rect.right, (int)rect.bottom, 15)) {
								return true;
							}
						}
					} else {
						return true;
					}
				}
				return false;
			}

			@Override
			public BinaryMapIndexReader next() {
				return next;
			}

			@Override
			public void remove() {
			}
		};
	}
	
	public List<BinaryMapIndexReader> getOfflineIndexes() {
		if(indexes != null) {
			return indexes; 
		}
		return settings.getOfflineIndexes();
	}
	
	public SearchSettings getSettings() {
		return settings;
	}
	
	
	public int getRadiusLevel() {
		return settings.getRadiusLevel();
	}

	public ObjectType[] getSearchTypes() {
		return settings == null ? null : settings.getSearchTypes();
	}

	public boolean isCustomSearch() {
		return getSearchTypes() != null;
	}

	public boolean isSearchTypeAllowed(ObjectType searchType) {
		if (getSearchTypes() == null) {
			return true;
		} else {
			for (ObjectType type : getSearchTypes()) {
				if (type == searchType) {
					return true;
				}
			}
			return false;
		}
	}

	public boolean isEmptyQueryAllowed() {
		return settings.isEmptyQueryAllowed();
	}

	public boolean isSortByName() {
		return settings.isSortByName();
	}

	public boolean isInAddressSearch() {
		return settings.isInAddressSearch();
	}

	public SearchPhrase selectWord(SearchResult res) {
		return selectWord(res, null, false);
	}
	
	public SearchPhrase selectWord(SearchResult res, List<String> unknownWords, boolean lastComplete) {
		SearchPhrase sp = new SearchPhrase(this.settings, this.clt);
		addResult(res, sp);
		SearchResult prnt = res.parentSearchResult;
		while(prnt != null) {
			addResult(prnt, sp);
			prnt = prnt.parentSearchResult;
		}
		sp.words.addAll(0, this.words);	
		if(unknownWords != null) {
			sp.lastUnknownSearchWordComplete = lastComplete;
			for (int i = 0; i < unknownWords.size(); i++) {
				if (i == 0) {
					sp.unknownSearchWordTrim = unknownWords.get(0);
				} else {
					sp.unknownWords.add(unknownWords.get(i));
				}
			}
		}
		return sp;
	}

	private void addResult(SearchResult res, SearchPhrase sp) {
		SearchWord sw = new SearchWord(res.wordsSpan != null ? res.wordsSpan : res.localeName.trim(), res);
		sp.words.add(0, sw);
	}
	
	public boolean isLastWord(ObjectType... p) {
		for (int i = words.size() - 1; i >= 0; i--) {
			SearchWord sw = words.get(i);
			for(ObjectType o : p) {
				if (sw.getType() == o) {
					return true;
				}
			}
			if (sw.getType() != ObjectType.UNKNOWN_NAME_FILTER) {
				return false;
			}
		}
		return false;
	}

	public ObjectType getExclusiveSearchType() {
		SearchWord lastWord = getLastSelectedWord();
		if (lastWord != null) {
			return ObjectType.getExclusiveSearchType(lastWord.getType());
		}
		return null;
	}

	public NameStringMatcher getNameStringMatcher() {
		if(sm != null) {
			return sm;
		}
		sm = getNameStringMatcher(unknownSearchWordTrim, lastUnknownSearchWordComplete);
		return sm;
	}
	
	
	public NameStringMatcher getNameStringMatcher(String word, boolean complete) {
		return new NameStringMatcher(word, 
				(complete ?  
					StringMatcherMode.CHECK_EQUALS_FROM_SPACE : 
					StringMatcherMode.CHECK_STARTS_FROM_SPACE));
	}
	
	public boolean hasObjectType(ObjectType p) {
		for(SearchWord s : words) {
			if(s.getType() == p) {
				return true;
			}
		}
		return false;
	}

	public void syncWordsWithResults() {
		for(SearchWord w : words) {
			w.syncWordWithResult();
		}
	}

	public String getText(boolean includeLastWord) {
		StringBuilder sb = new StringBuilder();
		for(SearchWord s : words) {
			sb.append(s.getWord()).append(DELIMITER.trim() + " ");
		}
		if(includeLastWord) {
			sb.append(unknownSearchPhrase);
		}
		return sb.toString();
	}

	public String getTextWithoutLastWord() {
		StringBuilder sb = new StringBuilder();
		List<SearchWord> words = new ArrayList<>(this.words);
		if(Algorithms.isEmpty(unknownSearchWordTrim) && words.size() > 0) {
			words.remove(words.size() - 1);
		}
		for(SearchWord s : words) {
			sb.append(s.getWord()).append(DELIMITER.trim() + " ");
		}
		return sb.toString();
	}

	public String getStringRerpresentation() {
		StringBuilder sb = new StringBuilder();
		for(SearchWord s : words) {
			sb.append(s.getWord()).append(" [" + s.getType() + "], ");
		}
		sb.append(unknownSearchPhrase);
		return sb.toString();
	}
	
	@Override
	public String toString() {
		return getStringRerpresentation();
	}

	public boolean isNoSelectedType() {
		return words.isEmpty();
	}

	public boolean isEmpty() {
		return words.isEmpty() && unknownSearchPhrase.isEmpty();
	}

	public SearchWord getLastSelectedWord() {
		if(words.isEmpty()) {
			return null;
		}
		return words.get(words.size() - 1);
	}
	
	public LatLon getWordLocation() {
		for(int i = words.size() - 1; i >= 0; i--) {
			SearchWord sw = words.get(i);
			if(sw.getLocation() != null) {
				return sw.getLocation();
			}
		}
		return null;
	}
	
	public LatLon getLastTokenLocation() {
		for(int i = words.size() - 1; i >= 0; i--) {
			SearchWord sw = words.get(i);
			if(sw.getLocation() != null) {
				return sw.getLocation();
			}
		}
		// last token or myLocationOrVisibleMap if not selected 
		return settings.getOriginalLocation();
	}

	public void selectFile(BinaryMapIndexReader object) {
		if(indexes == null) {
			indexes = new ArrayList<>();
		}
		if(!this.indexes.contains(object)) {
			this.indexes.add(object);
		}
	}

    public void sortFiles() {
        if (indexes == null) {
            indexes = new ArrayList<>(getOfflineIndexes());
        }
        Map<String, List<BinaryMapIndexReader>> diffsByRegion = getDiffsByRegion();
        final LatLon ll = getLastTokenLocation();
        if (ll != null) {
            Collections.sort(indexes, new Comparator<BinaryMapIndexReader>() {
                Map<BinaryMapIndexReader, LatLon> locations = new HashMap<>();

                @Override
                public int compare(BinaryMapIndexReader o1, BinaryMapIndexReader o2) {
                    LatLon rc1 = o1 == null ? null : getLocation(o1);
                    LatLon rc2 = o2 == null ? null : getLocation(o2);
                    double d1 = rc1 == null ? 10000000d : MapUtils.getDistance(rc1, ll);
                    double d2 = rc2 == null ? 10000000d : MapUtils.getDistance(rc2, ll);
                    return Double.compare(d1, d2);
                }

                private LatLon getLocation(BinaryMapIndexReader o1) {
                    if (locations.containsKey(o1)) {
                        return locations.get(o1);
                    }
                    LatLon rc1 = null;
                    if (o1.containsMapData()) {
                        rc1 = o1.getMapIndexes().get(0).getCenterLatLon();
                    } else {
                        rc1 = o1.getRegionCenter();
                    }
                    locations.put(o1, rc1);
                    return rc1;
                }
            });
            if (!diffsByRegion.isEmpty()) {
                List<BinaryMapIndexReader> finalSort = new ArrayList<>();
                for (int i = 0; i < indexes.size(); i++) {
                    BinaryMapIndexReader currFile = indexes.get(i);
                    if (diffsByRegion.get(currFile.getRegionName()) != null) {
                        finalSort.addAll(diffsByRegion.get(currFile.getRegionName()));
                        finalSort.add(currFile);
                    } else {
                        finalSort.add(currFile);
                    }
                }
                indexes.clear();
                indexes.addAll(finalSort);
            }
        }
    }

    private Map<String, List<BinaryMapIndexReader>> getDiffsByRegion() {
        Map<String, List<BinaryMapIndexReader>> result = new HashMap<>();
        Iterator<BinaryMapIndexReader> it = indexes.iterator();
        while (it.hasNext()) {
            BinaryMapIndexReader r = it.next();
            if (r.getFile().getName().matches(".*([0-9]+_*){3}\\.obf")) {
                String currRegionName = r.getRegionName();
                if (result.containsKey(currRegionName)) {
                    result.get(currRegionName).add(r);
                } else {
                    result.put(currRegionName, new ArrayList<>(Arrays.asList(r)));
                }
                it.remove();
            }
        }
        return result;
    }

	public static class NameStringMatcher implements StringMatcher {

		private CollatorStringMatcher sm;

		public NameStringMatcher(String lastWordTrim, StringMatcherMode mode) {
			sm = new CollatorStringMatcher(lastWordTrim, mode);
		}
		
		public boolean matches(Collection<String> map) {
			if(map == null) {
				return false;
			}
			for(String v : map) {
				if(sm.matches(v)) {
					return true;
				}
			}
			return false;
		}

		@Override
		public boolean matches(String name) {
			return sm.matches(name);
		}
		
	}
	
	public void countUnknownWordsMatch(SearchResult sr) {
		countUnknownWordsMatch(sr, sr.localeName, sr.otherNames);
	}
	
	public void countUnknownWordsMatch(SearchResult sr, String localeName, Collection<String> otherNames) {
		if(unknownWords.size() > 0) {
			for(int i = 0; i < unknownWords.size(); i++) {
				if(unknownWordsMatcher.size() == i) {
					unknownWordsMatcher.add(new NameStringMatcher(unknownWords.get(i), 
							i < unknownWords.size() - 1 ? StringMatcherMode.CHECK_EQUALS_FROM_SPACE :
								StringMatcherMode.CHECK_STARTS_FROM_SPACE));
				}
				NameStringMatcher ms = unknownWordsMatcher.get(i);
				if(ms.matches(localeName) || ms.matches(otherNames)) {
					if(sr.otherWordsMatch == null) {
						sr.otherWordsMatch = new TreeSet<>();
					}
					sr.otherWordsMatch.add(unknownWords.get(i));
				}
			}
		}
		if(!sr.firstUnknownWordMatches) {
			sr.firstUnknownWordMatches = localeName.equals(getUnknownSearchWord()) ||
					getNameStringMatcher().matches(localeName) || 
					getNameStringMatcher().matches(otherNames);	
		}
		
	}
	public int getRadiusSearch(int meters) {
		return (1 << (getRadiusLevel() - 1)) * meters;
	}

	public static int icompare(int x, int y) {
        return (x < y) ? -1 : ((x == y) ? 0 : 1);
    }
	
	public String getUnknownWordToSearchBuilding() {
		List<String> unknownSearchWords = getUnknownSearchWords();
		if(unknownSearchWords.size() > 0 && Algorithms.extractFirstIntegerNumber(getUnknownSearchWord()) == 0) {
			for(String wrd : unknownSearchWords) {
				if(Algorithms.extractFirstIntegerNumber(wrd) != 0) {
					return wrd;
				}
			}
		}
		return getUnknownSearchWord();
	}
	
	public String getUnknownWordToSearch() {
		List<String> unknownSearchWords = getUnknownSearchWords();
		
		String wordToSearch = getUnknownSearchWord();
		if (unknownSearchWords.size() > 0) {
			List<String> searchWords = new ArrayList<>(unknownSearchWords);
			searchWords.add(0, getUnknownSearchWord());
			Collections.sort(searchWords, new Comparator<String>() {

				private int lengthWithoutNumbers(String s) {
					int len = 0;
					for(int k = 0; k < s.length(); k++) {
						if(s.charAt(k) >= '0' && s.charAt(k) <= '9') {
							
						} else {
							len++;
						}
					}
					return len;
				}
				
				@Override
				public int compare(String o1, String o2) {
					int i1 = CommonWords.getCommonSearch(o1.toLowerCase());
					int i2 = CommonWords.getCommonSearch(o2.toLowerCase());
					if (i1 != i2) {
						return icompare(i1, i2);
					}
					// compare length without numbers to not include house numbers
					return -icompare(lengthWithoutNumbers(o1), lengthWithoutNumbers(o2));
				}
			});						
			wordToSearch = searchWords.get(0);
		}

		return wordToSearch;
	}

	
}
!@#$%
20190530_062751,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_c03008
package net.osmand.search.core;

import net.osmand.Collator;
import net.osmand.CollatorStringMatcher;
import net.osmand.CollatorStringMatcher.StringMatcherMode;
import net.osmand.StringMatcher;
import net.osmand.binary.BinaryMapIndexReader;
import net.osmand.binary.CommonWords;
import net.osmand.binary.BinaryMapIndexReader.SearchRequest;
import net.osmand.data.LatLon;
import net.osmand.data.QuadRect;
import net.osmand.util.Algorithms;
import net.osmand.util.MapUtils;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.regex.Pattern;

//immutable object
public class SearchPhrase {
	
	private List<SearchWord> words = new ArrayList<>();
	private List<String> unknownWords = new ArrayList<>();
	private List<NameStringMatcher> unknownWordsMatcher = new ArrayList<>();
	private String unknownSearchWordTrim;
	private String unknownSearchPhrase = "";
	
	private NameStringMatcher sm;
	private SearchSettings settings;
	private List<BinaryMapIndexReader> indexes;
	
	private QuadRect cache1kmRect;
	private boolean lastUnknownSearchWordComplete;
	private static final String DELIMITER = " ";
	private static final String ALLDELIMITERS = "\\s|,";
	private static final Pattern reg = Pattern.compile(ALLDELIMITERS);
	private Collator clt;
	
	private static Set<String> conjunctions = new TreeSet<>();
	static {
		// the
		conjunctions.add("the");
		conjunctions.add("der");
		conjunctions.add("den");
		conjunctions.add("die");
		conjunctions.add("das");
		conjunctions.add("la");
		conjunctions.add("le");
		conjunctions.add("el");
		conjunctions.add("il");
		// and
		conjunctions.add("and");
		conjunctions.add("und");
		conjunctions.add("en");
		conjunctions.add("et");
		conjunctions.add("y");
		conjunctions.add("?");
		// short 
		conjunctions.add("f");
		conjunctions.add("u");
		conjunctions.add("jl.");
		conjunctions.add("j");
		conjunctions.add("sk");
		conjunctions.add("w");
		conjunctions.add("a.");
		conjunctions.add("of");
		conjunctions.add("k");
		conjunctions.add("r");
		conjunctions.add("h");
		conjunctions.add("mc");
		conjunctions.add("sw");
		conjunctions.add("g");
		conjunctions.add("v");
		conjunctions.add("m");
		conjunctions.add("c.");
		conjunctions.add("r.");
		conjunctions.add("ct");
		conjunctions.add("e.");
		conjunctions.add("dr.");
		conjunctions.add("j.");		
		conjunctions.add("in");
		conjunctions.add("al");
		conjunctions.add("t");
		conjunctions.add("per");
		conjunctions.add("ne");
		conjunctions.add("p");
		conjunctions.add("et");
		conjunctions.add("s.");
		conjunctions.add("f.");
		conjunctions.add("t");
		conjunctions.add("fe");
		conjunctions.add("");
		conjunctions.add("i");
		conjunctions.add("c");
		conjunctions.add("le");
		conjunctions.add("s");
		conjunctions.add("av.");
		conjunctions.add("den");
		conjunctions.add("dr");
		conjunctions.add("y");
	}
	
	
	public enum SearchPhraseDataType {
		MAP, ADDRESS, ROUTING, POI
	}
	
	
	public SearchPhrase(SearchSettings settings, Collator clt) {
		this.settings = settings;
		this.clt = clt;
	}
	
	public Collator getCollator() {
		return clt;
	}
	
	public SearchPhrase generateNewPhrase(String text, SearchSettings settings) {
		SearchPhrase sp = new SearchPhrase(settings, this.clt);
		String restText = text;
		List<SearchWord> leftWords = this.words;
		String thisTxt = getText(true);
		if (text.startsWith(thisTxt)) {
			// string is longer
			restText = text.substring(getText(false).length());
			sp.words = new ArrayList<>(this.words);
			leftWords = leftWords.subList(leftWords.size(), leftWords.size());
		}
		for(SearchWord w : leftWords) {
			if(restText.startsWith(w.getWord() + DELIMITER)) {
				sp.words.add(w);
				restText = restText.substring(w.getWord().length() + DELIMITER.length()).trim();
			} else {
				break;
			}
		}
		sp.unknownSearchPhrase = restText;
		sp.unknownWords.clear();
		sp.unknownWordsMatcher.clear();
		
		if (!reg.matcher(restText).find()) {
			sp.unknownSearchWordTrim = sp.unknownSearchPhrase.trim();
		} else {
			sp.unknownSearchWordTrim = "";
			String[] ws = restText.split(ALLDELIMITERS);
			boolean first = true;
			for (int i = 0; i < ws.length ; i++) {
				String wd = ws[i].trim();
				if (wd.length() > 0 && !conjunctions.contains(wd.toLowerCase())) {
					if (first) {
						sp.unknownSearchWordTrim = wd;
						first = false;
					} else {
						sp.unknownWords.add(wd);
					}
				}
			}
		}
		sp.lastUnknownSearchWordComplete = false;
		if (text.length() > 0 ) {
			char ch = text.charAt(text.length() - 1);
			sp.lastUnknownSearchWordComplete = ch == ' ' || ch == ',' || ch == '\r' || ch == '\n'
					|| ch == ';';
		}
		
		return sp;
	}
	

	public List<SearchWord> getWords() {
		return words;
	}
	

	public boolean isUnknownSearchWordComplete() {
		return lastUnknownSearchWordComplete || unknownWords.size() > 0;
	}
	
	public boolean isLastUnknownSearchWordComplete() {
		return lastUnknownSearchWordComplete;
	}


	public List<String> getUnknownSearchWords() {
		return unknownWords;
	}
	
	public List<String> getUnknownSearchWords(Collection<String> exclude) {
		if(exclude == null || unknownWords.size() == 0 || exclude.size() == 0) {
			return unknownWords;
		}
		List<String> l = new ArrayList<>();
		for(String uw : unknownWords) {
			if(exclude == null || !exclude.contains(uw)) {
				l.add(uw);
			}
		}
		return l;
	}
	
	
	public String getUnknownSearchWord() {
		return unknownSearchWordTrim;
	}
	
	public String getUnknownSearchPhrase() {
		return unknownSearchPhrase;
	}
	
	public boolean isUnknownSearchWordPresent() {
		return unknownSearchWordTrim.length() > 0;
	}
	
	public int getUnknownSearchWordLength() {
		return unknownSearchWordTrim.length() ;
	}
	
	
	public QuadRect getRadiusBBoxToSearch(int radius) {
		int radiusInMeters = getRadiusSearch(radius);
		QuadRect cache1kmRect = get1km31Rect();
		if(cache1kmRect == null) {
			return null;
		}
		int max = (1 << 31) - 1;
		double dx = (cache1kmRect.width() / 2) * radiusInMeters / 1000;
		double dy = (cache1kmRect.height() / 2) * radiusInMeters / 1000;
		double topLeftX = Math.max(0, cache1kmRect.left - dx);
		double topLeftY = Math.max(0, cache1kmRect.top - dy);
		double bottomRightX = Math.min(max, cache1kmRect.right + dx);
		double bottomRightY = Math.min(max, cache1kmRect.bottom + dy);
		return new QuadRect(topLeftX, topLeftY, bottomRightX, bottomRightY);
	}
	
	public QuadRect get1km31Rect() {
		if(cache1kmRect != null) {
			return cache1kmRect;
		}
		LatLon l = getLastTokenLocation();
		if (l == null) {
			return null;
		}
		float coeff = (float) (1000 / MapUtils.getTileDistanceWidth(SearchRequest.ZOOM_TO_SEARCH_POI));
		double tx = MapUtils.getTileNumberX(SearchRequest.ZOOM_TO_SEARCH_POI, l.getLongitude());
		double ty = MapUtils.getTileNumberY(SearchRequest.ZOOM_TO_SEARCH_POI, l.getLatitude());
		double topLeftX = Math.max(0, tx - coeff);
		double topLeftY = Math.max(0, ty - coeff);
		int max = (1 << SearchRequest.ZOOM_TO_SEARCH_POI)  - 1;
		double bottomRightX = Math.min(max, tx + coeff);
		double bottomRightY = Math.min(max, ty + coeff);
		double pw = MapUtils.getPowZoom(31 - SearchRequest.ZOOM_TO_SEARCH_POI);
		cache1kmRect = new QuadRect(topLeftX * pw, topLeftY * pw, bottomRightX * pw, bottomRightY * pw);
		return cache1kmRect;
	}
	
	
	public Iterator<BinaryMapIndexReader> getRadiusOfflineIndexes(int meters, final SearchPhraseDataType dt) {
		final QuadRect rect = meters > 0 ? getRadiusBBoxToSearch(meters) : null;
		return getOfflineIndexes(rect, dt);
		
	}

	public Iterator<BinaryMapIndexReader> getOfflineIndexes(final QuadRect rect, final SearchPhraseDataType dt) {
		List<BinaryMapIndexReader> list = indexes != null ? indexes : settings.getOfflineIndexes();
		final Iterator<BinaryMapIndexReader> lit = list.iterator();
		return new Iterator<BinaryMapIndexReader>() {
			BinaryMapIndexReader next = null;
			@Override
			public boolean hasNext() {
				while (lit.hasNext()) {
					next = lit.next();
					if(rect != null) {
						if(dt == SearchPhraseDataType.POI) {
							if(next.containsPoiData((int)rect.left, (int)rect.top, (int)rect.right, (int)rect.bottom)) {
								return true;
							}
						} else if(dt == SearchPhraseDataType.ADDRESS) {
							// containsAddressData not all maps supported
							if(next.containsPoiData((int)rect.left, (int)rect.top, (int)rect.right, (int)rect.bottom) && 
									next.containsAddressData()) {
								return true;
							}
						} else if(dt == SearchPhraseDataType.ROUTING) {
							if(next.containsRouteData((int)rect.left, (int)rect.top, (int)rect.right, (int)rect.bottom, 15)) {
								return true;
							}
						} else {
							if(next.containsMapData((int)rect.left, (int)rect.top, (int)rect.right, (int)rect.bottom, 15)) {
								return true;
							}
						}
					} else {
						return true;
					}
				}
				return false;
			}

			@Override
			public BinaryMapIndexReader next() {
				return next;
			}

			@Override
			public void remove() {
			}
		};
	}
	
	public List<BinaryMapIndexReader> getOfflineIndexes() {
		if(indexes != null) {
			return indexes; 
		}
		return settings.getOfflineIndexes();
	}
	
	public SearchSettings getSettings() {
		return settings;
	}
	
	
	public int getRadiusLevel() {
		return settings.getRadiusLevel();
	}

	public ObjectType[] getSearchTypes() {
		return settings == null ? null : settings.getSearchTypes();
	}

	public boolean isCustomSearch() {
		return getSearchTypes() != null;
	}

	public boolean hasCustomSearchType(ObjectType type) {
		return settings.hasCustomSearchType(type);
	}

	public boolean isSearchTypeAllowed(ObjectType searchType) {
		if (getSearchTypes() == null) {
			return true;
		} else {
			for (ObjectType type : getSearchTypes()) {
				if (type == searchType) {
					return true;
				}
			}
			return false;
		}
	}

	public boolean isEmptyQueryAllowed() {
		return settings.isEmptyQueryAllowed();
	}

	public boolean isSortByName() {
		return settings.isSortByName();
	}

	public SearchPhrase selectWord(SearchResult res) {
		return selectWord(res, null, false);
	}
	
	public SearchPhrase selectWord(SearchResult res, List<String> unknownWords, boolean lastComplete) {
		SearchPhrase sp = new SearchPhrase(this.settings, this.clt);
		addResult(res, sp);
		SearchResult prnt = res.parentSearchResult;
		while(prnt != null) {
			addResult(prnt, sp);
			prnt = prnt.parentSearchResult;
		}
		sp.words.addAll(0, this.words);	
		if(unknownWords != null) {
			sp.lastUnknownSearchWordComplete = lastComplete;
			for (int i = 0; i < unknownWords.size(); i++) {
				if (i == 0) {
					sp.unknownSearchWordTrim = unknownWords.get(0);
				} else {
					sp.unknownWords.add(unknownWords.get(i));
				}
			}
		}
		return sp;
	}

	private void addResult(SearchResult res, SearchPhrase sp) {
		SearchWord sw = new SearchWord(res.wordsSpan != null ? res.wordsSpan : res.localeName.trim(), res);
		sp.words.add(0, sw);
	}
	
	public boolean isLastWord(ObjectType... p) {
		for (int i = words.size() - 1; i >= 0; i--) {
			SearchWord sw = words.get(i);
			for(ObjectType o : p) {
				if (sw.getType() == o) {
					return true;
				}
			}
			if (sw.getType() != ObjectType.UNKNOWN_NAME_FILTER) {
				return false;
			}
		}
		return false;
	}

	public ObjectType getExclusiveSearchType() {
		SearchWord lastWord = getLastSelectedWord();
		if (lastWord != null) {
			return ObjectType.getExclusiveSearchType(lastWord.getType());
		}
		return null;
	}

	public NameStringMatcher getNameStringMatcher() {
		if(sm != null) {
			return sm;
		}
		sm = getNameStringMatcher(unknownSearchWordTrim, lastUnknownSearchWordComplete);
		return sm;
	}
	
	
	public NameStringMatcher getNameStringMatcher(String word, boolean complete) {
		return new NameStringMatcher(word, 
				(complete ?  
					StringMatcherMode.CHECK_EQUALS_FROM_SPACE : 
					StringMatcherMode.CHECK_STARTS_FROM_SPACE));
	}
	
	public boolean hasObjectType(ObjectType p) {
		for(SearchWord s : words) {
			if(s.getType() == p) {
				return true;
			}
		}
		return false;
	}

	public void syncWordsWithResults() {
		for(SearchWord w : words) {
			w.syncWordWithResult();
		}
	}

	public String getText(boolean includeLastWord) {
		StringBuilder sb = new StringBuilder();
		for(SearchWord s : words) {
			sb.append(s.getWord()).append(DELIMITER.trim() + " ");
		}
		if(includeLastWord) {
			sb.append(unknownSearchPhrase);
		}
		return sb.toString();
	}

	public String getTextWithoutLastWord() {
		StringBuilder sb = new StringBuilder();
		List<SearchWord> words = new ArrayList<>(this.words);
		if(Algorithms.isEmpty(unknownSearchWordTrim) && words.size() > 0) {
			words.remove(words.size() - 1);
		}
		for(SearchWord s : words) {
			sb.append(s.getWord()).append(DELIMITER.trim() + " ");
		}
		return sb.toString();
	}

	public String getStringRerpresentation() {
		StringBuilder sb = new StringBuilder();
		for(SearchWord s : words) {
			sb.append(s.getWord()).append(" [" + s.getType() + "], ");
		}
		sb.append(unknownSearchPhrase);
		return sb.toString();
	}
	
	@Override
	public String toString() {
		return getStringRerpresentation();
	}

	public boolean isNoSelectedType() {
		return words.isEmpty();
	}

	public boolean isEmpty() {
		return words.isEmpty() && unknownSearchPhrase.isEmpty();
	}

	public SearchWord getLastSelectedWord() {
		if(words.isEmpty()) {
			return null;
		}
		return words.get(words.size() - 1);
	}
	
	public LatLon getWordLocation() {
		for(int i = words.size() - 1; i >= 0; i--) {
			SearchWord sw = words.get(i);
			if(sw.getLocation() != null) {
				return sw.getLocation();
			}
		}
		return null;
	}
	
	public LatLon getLastTokenLocation() {
		for(int i = words.size() - 1; i >= 0; i--) {
			SearchWord sw = words.get(i);
			if(sw.getLocation() != null) {
				return sw.getLocation();
			}
		}
		// last token or myLocationOrVisibleMap if not selected 
		return settings.getOriginalLocation();
	}

	public void selectFile(BinaryMapIndexReader object) {
		if(indexes == null) {
			indexes = new ArrayList<>();
		}
		if(!this.indexes.contains(object)) {
			this.indexes.add(object);
		}
	}

    public void sortFiles() {
        if (indexes == null) {
            indexes = new ArrayList<>(getOfflineIndexes());
        }
        Map<String, List<BinaryMapIndexReader>> diffsByRegion = getDiffsByRegion();
        final LatLon ll = getLastTokenLocation();
        if (ll != null) {
            Collections.sort(indexes, new Comparator<BinaryMapIndexReader>() {
                Map<BinaryMapIndexReader, LatLon> locations = new HashMap<>();

                @Override
                public int compare(BinaryMapIndexReader o1, BinaryMapIndexReader o2) {
                    LatLon rc1 = o1 == null ? null : getLocation(o1);
                    LatLon rc2 = o2 == null ? null : getLocation(o2);
                    double d1 = rc1 == null ? 10000000d : MapUtils.getDistance(rc1, ll);
                    double d2 = rc2 == null ? 10000000d : MapUtils.getDistance(rc2, ll);
                    return Double.compare(d1, d2);
                }

                private LatLon getLocation(BinaryMapIndexReader o1) {
                    if (locations.containsKey(o1)) {
                        return locations.get(o1);
                    }
                    LatLon rc1 = null;
                    if (o1.containsMapData()) {
                        rc1 = o1.getMapIndexes().get(0).getCenterLatLon();
                    } else {
                        rc1 = o1.getRegionCenter();
                    }
                    locations.put(o1, rc1);
                    return rc1;
                }
            });
            if (!diffsByRegion.isEmpty()) {
                List<BinaryMapIndexReader> finalSort = new ArrayList<>();
                for (int i = 0; i < indexes.size(); i++) {
                    BinaryMapIndexReader currFile = indexes.get(i);
                    if (diffsByRegion.get(currFile.getRegionName()) != null) {
                        finalSort.addAll(diffsByRegion.get(currFile.getRegionName()));
                        finalSort.add(currFile);
                    } else {
                        finalSort.add(currFile);
                    }
                }
                indexes.clear();
                indexes.addAll(finalSort);
            }
        }
    }

    private Map<String, List<BinaryMapIndexReader>> getDiffsByRegion() {
        Map<String, List<BinaryMapIndexReader>> result = new HashMap<>();
        Iterator<BinaryMapIndexReader> it = indexes.iterator();
        while (it.hasNext()) {
            BinaryMapIndexReader r = it.next();
            String filename = r.getFile().getName();
            if (filename.matches("([a-zA-Z-]+_)+([0-9]+_){2}[0-9]+\\.obf")) {
                String currRegionName = r.getRegionName();
                if (result.containsKey(currRegionName)) {
                    result.get(currRegionName).add(r);
                } else {
                    result.put(currRegionName, new ArrayList<>(Arrays.asList(r)));
                }
                it.remove();
            }
        }
        return result;
    }

	public static class NameStringMatcher implements StringMatcher {

		private CollatorStringMatcher sm;

		public NameStringMatcher(String lastWordTrim, StringMatcherMode mode) {
			sm = new CollatorStringMatcher(lastWordTrim, mode);
		}
		
		public boolean matches(Collection<String> map) {
			if(map == null) {
				return false;
			}
			for(String v : map) {
				if(sm.matches(v)) {
					return true;
				}
			}
			return false;
		}

		@Override
		public boolean matches(String name) {
			return sm.matches(name);
		}
		
	}
	
	public void countUnknownWordsMatch(SearchResult sr) {
		countUnknownWordsMatch(sr, sr.localeName, sr.otherNames);
	}
	
	public void countUnknownWordsMatch(SearchResult sr, String localeName, Collection<String> otherNames) {
		if(unknownWords.size() > 0) {
			for(int i = 0; i < unknownWords.size(); i++) {
				if(unknownWordsMatcher.size() == i) {
					unknownWordsMatcher.add(new NameStringMatcher(unknownWords.get(i), 
							i < unknownWords.size() - 1 ? StringMatcherMode.CHECK_EQUALS_FROM_SPACE :
								StringMatcherMode.CHECK_STARTS_FROM_SPACE));
				}
				NameStringMatcher ms = unknownWordsMatcher.get(i);
				if(ms.matches(localeName) || ms.matches(otherNames)) {
					if(sr.otherWordsMatch == null) {
						sr.otherWordsMatch = new TreeSet<>();
					}
					sr.otherWordsMatch.add(unknownWords.get(i));
				}
			}
		}
		if(!sr.firstUnknownWordMatches) {
			sr.firstUnknownWordMatches = localeName.equals(getUnknownSearchWord()) ||
					getNameStringMatcher().matches(localeName) || 
					getNameStringMatcher().matches(otherNames);	
		}
		
	}
	public int getRadiusSearch(int meters) {
		return (1 << (getRadiusLevel() - 1)) * meters;
	}

	public static int icompare(int x, int y) {
        return (x < y) ? -1 : ((x == y) ? 0 : 1);
    }
	
	public String getUnknownWordToSearchBuilding() {
		List<String> unknownSearchWords = getUnknownSearchWords();
		if(unknownSearchWords.size() > 0 && Algorithms.extractFirstIntegerNumber(getUnknownSearchWord()) == 0) {
			for(String wrd : unknownSearchWords) {
				if(Algorithms.extractFirstIntegerNumber(wrd) != 0) {
					return wrd;
				}
			}
		}
		return getUnknownSearchWord();
	}
	
	public String getUnknownWordToSearch() {
		List<String> unknownSearchWords = getUnknownSearchWords();
		
		String wordToSearch = getUnknownSearchWord();
		if (unknownSearchWords.size() > 0) {
			List<String> searchWords = new ArrayList<>(unknownSearchWords);
			searchWords.add(0, getUnknownSearchWord());
			Collections.sort(searchWords, new Comparator<String>() {

				private int lengthWithoutNumbers(String s) {
					int len = 0;
					for(int k = 0; k < s.length(); k++) {
						if(s.charAt(k) >= '0' && s.charAt(k) <= '9') {
							
						} else {
							len++;
						}
					}
					return len;
				}
				
				@Override
				public int compare(String o1, String o2) {
					int i1 = CommonWords.getCommonSearch(o1.toLowerCase());
					int i2 = CommonWords.getCommonSearch(o2.toLowerCase());
					if (i1 != i2) {
						return icompare(i1, i2);
					}
					// compare length without numbers to not include house numbers
					return -icompare(lengthWithoutNumbers(o1), lengthWithoutNumbers(o2));
				}
			});						
			wordToSearch = searchWords.get(0);
		}

		return wordToSearch;
	}

	
}
!@#$%
20190530_064301,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_b11712
package net.osmand.util;
/* Can be commented out in order to run the main function separately */

import java.io.Serializable;
import java.text.DateFormatSymbols;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Set;

import gnu.trove.list.array.TIntArrayList;

/**
 * Class used to parse opening hours
 * <p/>
 * the method "parseOpenedHours" will parse an OSM opening_hours string and
 * return an object of the type OpeningHours. That object can be used to check
 * if the OSM feature is open at a certain time.
 */
public class OpeningHoursParser {
	private static final String[] daysStr;
	private static final String[] localDaysStr;
	private static final String[] monthsStr;
	private static final String[] localMothsStr;

	private static final int LOW_TIME_LIMIT = 120;
	private static final int WITHOUT_TIME_LIMIT = -1;
	private static final int CURRENT_DAY_TIME_LIMIT = -2;

	static {
		DateFormatSymbols dateFormatSymbols = DateFormatSymbols.getInstance(Locale.US);
		monthsStr = dateFormatSymbols.getShortMonths();
		daysStr = getTwoLettersStringArray(dateFormatSymbols.getShortWeekdays());
		dateFormatSymbols = DateFormatSymbols.getInstance();
		localMothsStr = dateFormatSymbols.getShortMonths();
		localDaysStr = getTwoLettersStringArray(dateFormatSymbols.getShortWeekdays());
	}

	/**
	 * Default values for sunrise and sunset. Might be computed afterwards, not final.
	 */
	private static String sunrise = "07:00", sunset = "21:00";

	/**
	 * Hour of when you would expect a day to be ended.
	 * This is to be used when no end hour is known (like pubs that open at a certain time,
	 * but close at a variable time, depending on the number of clients).
	 * OsmAnd needs to show a value, so there is some arbitrary default value chosen.
	 */
	private static String endOfDay = "24:00";

	private static String[] getTwoLettersStringArray(String[] strings) {
		String[] newStrings = new String[strings.length];
		for (int i = 0; i < strings.length; i++) {
			if (strings[i] != null) {
				if (strings[i].length() > 2) {
					newStrings[i] = strings[i].substring(0, 2);
				} else {
					newStrings[i] = strings[i];
				}
			}
		}
		return newStrings;
	}

	private static int getDayIndex(int i) {
		switch (i) {
			case 0: return Calendar.MONDAY;
			case 1: return Calendar.TUESDAY;
			case 2: return Calendar.WEDNESDAY;
			case 3: return Calendar.THURSDAY;
			case 4: return Calendar.FRIDAY;
			case 5: return Calendar.SATURDAY;
			case 6: return Calendar.SUNDAY;
			default: return -1;
		}
	}

	/**
	 * This class contains the entire OpeningHours schema and
	 * offers methods to check directly weather something is open
	 *
	 * @author sander
	 */
	public static class OpeningHours implements Serializable {

		/**
		 * list of the different rules
		 */
		private ArrayList<OpeningHoursRule> rules;
		private String original;

		/**
		 * Constructor
		 *
		 * @param rules List of OpeningHoursRule to be given
		 */
		public OpeningHours(ArrayList<OpeningHoursRule> rules) {
			this.rules = rules;
		}

		/**
		 * Empty constructor
		 */
		public OpeningHours() {
			rules = new ArrayList<OpeningHoursRule>();
		}

		/**
		 * add a rule to the opening hours
		 *
		 * @param r rule to add
		 */
		public void addRule(OpeningHoursRule r) {
			rules.add(r);
		}

		/**
		 * return the list of rules
		 *
		 * @return the rules
		 */
		public ArrayList<OpeningHoursRule> getRules() {
			return rules;
		}
		
		/**
		 * check if the feature is opened at time "cal"
		 *
		 * @param cal the time to check
		 * @return true if feature is open
		 */
		public boolean isOpenedForTimeV2(Calendar cal) {
			// make exception for overlapping times i.e.
			// (1) Mo 14:00-16:00; Tu off
			// (2) Mo 14:00-02:00; Tu off
			// in (2) we need to check first rule even though it is against specification
			boolean overlap = false;
			for(int i = rules.size() - 1; i >= 0 ; i--) {
				OpeningHoursRule r = rules.get(i);
				if(r.hasOverlapTimes()) {
					overlap = true;
					break;
				}
			}
			// start from the most specific rule
			for(int i = rules.size() - 1; i >= 0 ; i--) {
				OpeningHoursRule r = rules.get(i);
				if(r.contains(cal)) {
					boolean open = r.isOpenedForTime(cal);
					if(!open && overlap ) {
						continue;
					} else {
						return open;
					}
				}
			}
			return false;
		}

		/**
		 * check if the feature is opened at time "cal"
		 *
		 * @param cal the time to check
		 * @return true if feature is open
		 */
		public boolean isOpenedForTime(Calendar cal) {
			/*
			 * first check for rules that contain the current day
			 * afterwards check for rules that contain the previous
			 * day with overlapping times (times after midnight)
			 */
			boolean isOpenDay = false;
			for (OpeningHoursRule r : rules) {
				if (r.containsDay(cal) && r.containsMonth(cal)) {
					isOpenDay = r.isOpenedForTime(cal, false);
				}
			}
			boolean isOpenPrevious = false;
			for (OpeningHoursRule r : rules) {
				if (r.containsPreviousDay(cal) && r.containsMonth(cal)) {
					isOpenPrevious = r.isOpenedForTime(cal, true);
				}
			}
			return isOpenDay || isOpenPrevious;
		}

		public boolean isOpened24_7() {
			boolean opened24_7 = false;
			for (OpeningHoursRule r : rules) {
				opened24_7 = r.isOpened24_7();
			}
			return opened24_7;
		}

		public String getNearToOpeningTime(Calendar cal) {
			return getTime(cal, LOW_TIME_LIMIT, true);
		}

		public String getOpeningTime(Calendar cal) {
			return getTime(cal, CURRENT_DAY_TIME_LIMIT, true);
		}

		public String getNearToClosingTime(Calendar cal) {
			return getTime(cal, LOW_TIME_LIMIT, false);
		}

		public String getClosingTime(Calendar cal) {
			return getTime(cal, WITHOUT_TIME_LIMIT, false);
		}

		public String getOpeningDay(Calendar calendar) {
			Calendar cal = (Calendar) calendar.clone();
			String openingTime = "";
			for (int i = 0; i < 7; i++) {
				cal.add(Calendar.DAY_OF_MONTH, 1);
				for (OpeningHoursRule r : rules) {
					if (r.containsDay(cal) && r.containsMonth(cal)) {
						openingTime = r.getTime(cal, false, WITHOUT_TIME_LIMIT, true);
					}
				}
				if (!Algorithms.isEmpty(openingTime)) {
					openingTime += " " + localDaysStr[cal.get(Calendar.DAY_OF_WEEK)];
					break;
				}
			}
			return openingTime;
		}

		private String getTime(Calendar cal, int limit, boolean opening) {
			String time = getTimeDay(cal, limit, opening);
			if (Algorithms.isEmpty(time)) {
				time = getTimeAnotherDay(cal, limit, opening);
			}
			return time;
		}

		private String getTimeDay(Calendar cal, int limit, boolean opening) {
			String atTime = "";
			for (OpeningHoursRule r : rules) {
				if (r.containsDay(cal) && r.containsMonth(cal)) {
					atTime = r.getTime(cal, false, limit, opening);
				}
			}
			return atTime;
		}

		private String getTimeAnotherDay(Calendar cal, int limit, boolean opening) {
			String atTime = "";
			for (OpeningHoursRule r : rules) {
				if (((opening && r.containsPreviousDay(cal)) || (!opening && r.containsNextDay(cal))) && r.containsMonth(cal)) {
					atTime = r.getTime(cal, true, limit, opening);
				}
			}
			return atTime;
		}

		public String getCurrentRuleTime(Calendar cal) {
			// make exception for overlapping times i.e.
			// (1) Mo 14:00-16:00; Tu off
			// (2) Mo 14:00-02:00; Tu off
			// in (2) we need to check first rule even though it is against specification
			String ruleClosed = null;
			boolean overlap = false;
			for (int i = rules.size() - 1; i >= 0; i--) {
				OpeningHoursRule r = rules.get(i);
				if (r.hasOverlapTimes()) {
					overlap = true;
					break;
				}
			}
			// start from the most specific rule
			for (int i = rules.size() - 1; i >= 0; i--) {
				OpeningHoursRule r = rules.get(i);
				if (r.contains(cal)) {
					boolean open = r.isOpenedForTime(cal);
					if (!open && overlap) {
						ruleClosed = r.toLocalRuleString();
					} else {
						return r.toLocalRuleString();
					}
				}
			}
			return ruleClosed;
		}
		
		public String getCurrentRuleTimeV1(Calendar cal) {
			String ruleOpen = null;
			String ruleClosed = null;
			for (OpeningHoursRule r : rules) {
				if (r.containsPreviousDay(cal) && r.containsMonth(cal)) {
					if (r.isOpenedForTime(cal, true)) {
						ruleOpen = r.toLocalRuleString();
					} else {
						ruleClosed = r.toLocalRuleString();
					}
				}
			}
			for (OpeningHoursRule r : rules) {
				if (r.containsDay(cal) && r.containsMonth(cal)) {
					if (r.isOpenedForTime(cal, false)) {
						ruleOpen = r.toLocalRuleString();
					} else {
						ruleClosed = r.toLocalRuleString();
					}
				}
			}

			if (ruleOpen != null) {
				return ruleOpen;
			}
			return ruleClosed;
		}

		@Override
		public String toString() {
			StringBuilder s = new StringBuilder();
			if (rules.isEmpty()) {
				return "";
			}
			for (OpeningHoursRule r : rules) {
				s.append(r.toString()).append("; ");
			}
			return s.substring(0, s.length() - 2);
		}

		public String toLocalString() {
			StringBuilder s = new StringBuilder();
			if (rules.isEmpty()) {
				return "";
			}

			for (OpeningHoursRule r : rules) {
				s.append(r.toLocalRuleString()).append("; ");
			}

			return s.substring(0, s.length() - 2);
		}

		public void setOriginal(String original) {
			this.original = original;
		}
		
		public String getOriginal() {
			return original;
		}
	}

	/**
	 * Interface to represent a single rule
	 * <p/>
	 * A rule consist out of
	 * - a collection of days/dates
	 * - a time range
	 */
	public static interface OpeningHoursRule extends Serializable {

		/**
		 * Check if, for this rule, the feature is opened for time "cal"
		 *
		 * @param cal           the time to check
		 * @param checkPrevious only check for overflowing times (after midnight) or don't check for it
		 * @return true if the feature is open
		 */
		public boolean isOpenedForTime(Calendar cal, boolean checkPrevious);
		
		/**
		 * Check if, for this rule, the feature is opened for time "cal" 
		 * @param cal
		 * @return true if the feature is open
		 */
		public boolean isOpenedForTime(Calendar cal);

		/**
		 * Check if the previous day before "cal" is part of this rule
		 *
		 * @param cal; the time to check
		 * @return true if the previous day is part of the rule
		 */
		public boolean containsPreviousDay(Calendar cal);

		/**
		 * Check if the day of "cal" is part of this rule
		 *
		 * @param cal the time to check
		 * @return true if the day is part of the rule
		 */
		public boolean containsDay(Calendar cal);

		/**
		 * Check if the next day after "cal" is part of this rule
		 *
		 * @param cal the time to check
		 * @return true if the next day is part of the rule
		 */
		boolean containsNextDay(Calendar cal);

		/**
		 * Check if the month of "cal" is part of this rule
		 *
		 * @param cal the time to check
		 * @return true if the month is part of the rule
		 */
		public boolean containsMonth(Calendar cal);
		
		/**
		 * @return true if the rule overlap to the next day
		 */
		public boolean hasOverlapTimes();
		
		/**
		 * @param cal
		 * @return true if rule applies for current time
		 */
		public boolean contains(Calendar cal);


		public String toRuleString();

		public String toLocalRuleString();

		boolean isOpened24_7();

		String getTime(Calendar cal, boolean checkAnotherDay, int limit, boolean opening);
	}

	/**
	 * implementation of the basic OpeningHoursRule
	 * <p/>
	 * This implementation only supports month, day of weeks and numeral times, or the value "off"
	 */
	public static class BasicOpeningHourRule implements OpeningHoursRule {
		/**
		 * represents the list on which days it is open.
		 * Day number 0 is MONDAY
		 */
		private boolean[] days = new boolean[7];

		/**
		 * represents the list on which month it is open.
		 * Day number 0 is JANUARY.
		 */
		private boolean[] months = new boolean[12];
		
		/**
		 * represents the list on which day it is open.
		 */
		private boolean[] dayMonths = new boolean[31];

		/**
		 * lists of equal size representing the start and end times
		 */
		private TIntArrayList startTimes = new TIntArrayList(), endTimes = new TIntArrayList();
		
		private boolean publicHoliday = false;
		private boolean schoolHoliday = false;
		private boolean easter = false;
		
		/**
		 * Flag that means that time is off
		 */
		private boolean off = false;

		/**
		 * return an array representing the days of the rule
		 *
		 * @return the days of the rule
		 */
		public boolean[] getDays() {
			return days;
		}
		
		/**
		 * @return the day months of the rule
		 */
		public boolean[] getDayMonths() {
			return dayMonths;
		}

		/**
		 * return an array representing the months of the rule
		 *
		 * @return the months of the rule
		 */
		public boolean[] getMonths() {
			return months;
		}
		
		public boolean appliesToPublicHolidays() {
			return publicHoliday;
		}
		
		public boolean appliesEaster() {
			return easter;
		}
		
		public boolean appliesToSchoolHolidays() {
			return schoolHoliday;
		}
		

		/**
		 * set a single start time, erase all previously added start times
		 *
		 * @param s startTime to set
		 */
		public void setStartTime(int s) {
			setSingleValueForArrayList(startTimes, s);
			if (endTimes.size() != 1) {
				setSingleValueForArrayList(endTimes, 0);
			}
		}

		/**
		 * set a single end time, erase all previously added end times
		 *
		 * @param e endTime to set
		 */
		public void setEndTime(int e) {
			setSingleValueForArrayList(endTimes, e);
			if (startTimes.size() != 1) {
				setSingleValueForArrayList(startTimes, 0);
			}
		}

		/**
		 * Set single start time. If position exceeds index of last item by one
		 * then new value will be added.
		 * If value is between 0 and last index, then value in the position p will be overwritten
		 * with new one.
		 * Else exception will be thrown.
		 *
		 * @param s        - value
		 * @param position - position to add
		 */
		public void setStartTime(int s, int position) {
			if (position == startTimes.size()) {
				startTimes.add(s);
				endTimes.add(0);
			} else {
				startTimes.set(position, s);
			}
		}

		/**
		 * Set single end time. If position exceeds index of last item by one
		 * then new value will be added.
		 * If value is between 0 and last index, then value in the position p will be overwritten
		 * with new one.
		 * Else exception will be thrown.
		 *
		 * @param s        - value
		 * @param position - position to add
		 */
		public void setEndTime(int s, int position) {
			if (position == startTimes.size()) {
				endTimes.add(s);
				startTimes.add(0);
			} else {
				endTimes.set(position, s);
			}
		}

		/**
		 * get a single start time
		 *
		 * @return a single start time
		 */
		public int getStartTime() {
			if (startTimes.size() == 0) {
				return 0;
			}
			return startTimes.get(0);
		}

		/**
		 * get a single start time in position
		 *
		 * @param position position to get value from
		 * @return a single start time
		 */
		public int getStartTime(int position) {
			return startTimes.get(position);
		}

		/**
		 * get a single end time
		 *
		 * @return a single end time
		 */
		public int getEndTime() {
			if (endTimes.size() == 0) {
				return 0;
			}
			return endTimes.get(0);
		}

		/**
		 * get a single end time in position
		 *
		 * @param position position to get value from
		 * @return a single end time
		 */
		public int getEndTime(int position) {
			return endTimes.get(position);
		}

		/**
		 * get all start times as independent list
		 *
		 * @return all start times
		 */
		public TIntArrayList getStartTimes() {
			return new TIntArrayList(startTimes);
		}

		/**
		 * get all end times as independent list
		 *
		 * @return all end times
		 */
		public TIntArrayList getEndTimes() {
			return new TIntArrayList(endTimes);
		}

		/**
		 * Check if the weekday of time "cal" is part of this rule
		 *
		 * @param cal the time to check
		 * @return true if this day is part of the rule
		 */
		@Override
		public boolean containsDay(Calendar cal) {
			int i = cal.get(Calendar.DAY_OF_WEEK);
			int d = (i + 5) % 7;
			if (days[d]) {
				return true;
			}
			return false;
		}

		@Override
		public boolean containsNextDay(Calendar cal) {
			int i = cal.get(Calendar.DAY_OF_WEEK);
			int p = (i + 6) % 7;
			if (days[p]) {
				return true;
			}
			return false;
		}

		/**
		 * Check if the previous weekday of time "cal" is part of this rule
		 *
		 * @param cal the time to check
		 * @return true if the previous day is part of the rule
		 */
		@Override
		public boolean containsPreviousDay(Calendar cal) {
			int i = cal.get(Calendar.DAY_OF_WEEK);
			int p = (i + 4) % 7;
			if (days[p]) {
				return true;
			}
			return false;
		}

		/**
		 * Check if the month of "cal" is part of this rule
		 *
		 * @param cal the time to check
		 * @return true if the month is part of the rule
		 */
		@Override
		public boolean containsMonth(Calendar cal) {
			int i = cal.get(Calendar.MONTH);
			if (months[i]) {
				return true;
			}
			return false;
		}

		/**
		 * Check if this rule says the feature is open at time "cal"
		 *
		 * @param cal the time to check
		 * @return false in all other cases, also if only day is wrong
		 */
		@Override
		public boolean isOpenedForTime(Calendar cal, boolean checkPrevious) {
			int d = getCurrentDay(cal);
			int p = getPreviousDay(d);
			int time = getCurrentTimeInMinutes(cal); // Time in minutes
			for (int i = 0; i < startTimes.size(); i++) {
				int startTime = this.startTimes.get(i);
				int endTime = this.endTimes.get(i);
				if (startTime < endTime || endTime == -1) {
					// one day working like 10:00-20:00 (not 20:00-04:00)
					if (days[d] && !checkPrevious) {
						if (time >= startTime && (endTime == -1 || time <= endTime)) {
							return !off;
						}
					}
				} else {
					// opening_hours includes day wrap like
					// "We 20:00-03:00" or "We 07:00-07:00"
					if (time >= startTime && days[d] && !checkPrevious) {
						return !off;
					} else if (time < endTime && days[p] && checkPrevious) {
						// check in previous day
						return !off;
					}
				}
			}
			return false;
		}

		private int getCurrentDay(Calendar cal) {
			int i = cal.get(Calendar.DAY_OF_WEEK);
			return (i + 5) % 7;
		}

		private int getPreviousDay(int currentDay) {
			int p = currentDay - 1;
			if (p < 0) {
				p += 7;
			}
			return p;
		}

		private int getNextDay(int currentDay) {
			int n = currentDay + 1;
			if (n > 6) {
				n -= 7;
			}
			return n;
		}

		private int getCurrentTimeInMinutes(Calendar cal) {
			return cal.get(Calendar.HOUR_OF_DAY) * 60 + cal.get(Calendar.MINUTE);
		}

		@Override
		public String toRuleString() {
			return toRuleString(daysStr, monthsStr);
		}

		private String toRuleString(String[] dayNames, String[] monthNames) {
			StringBuilder b = new StringBuilder(25);
			boolean allMonths = true;
			for (int i = 0; i < months.length; i++) {
				if (!months[i]) {
					allMonths = false;
					break;
				}
			}
			// Month
			if (!allMonths) {
				addArray(months, monthNames, b);
			}
			boolean allDays = true;
			for (int i = 0; i < dayMonths.length; i++) {
				if (!dayMonths[i]) {
					allDays = false;
					break;
				}
			}
			if (!allDays) {
				addArray(dayMonths, null, b);
			}
			// Day
			appendDaysString(b, dayNames);
			// Time
			if (startTimes == null || startTimes.size() == 0) {
				b.append("off");
			} else {
				if (isOpened24_7()) {
					return "24/7";
				}
				for (int i = 0; i < startTimes.size(); i++) {
					int startTime = startTimes.get(i);
					int endTime = endTimes.get(i);
					if(i > 0) {
						b.append(", ");
					}
					int stHour = startTime / 60;
					int stTime = startTime - stHour * 60;
					int enHour = endTime / 60;
					int enTime = endTime - enHour * 60;
					formatTime(stHour, stTime, b);
					b.append("-"); //$NON-NLS-1$
					formatTime(enHour, enTime, b);
				}
				if(off) {
					b.append(" off");
				}
			}
			return b.toString();
		}

		private void addArray(boolean[] array, String[] arrayNames, StringBuilder b) {
			boolean dash = false;
			boolean first = true;
			for (int i = 0; i < array.length; i++) {
				if (array[i]) {
					if (i > 0 && array[i - 1] && i < array.length - 1 && array[i + 1]) {
						if (!dash) {
							dash = true;
							b.append("-"); //$NON-NLS-1$
						}
						continue;
					}
					if (first) {
						first = false;
					} else if (!dash) {
						b.append(", "); //$NON-NLS-1$
					}
					b.append(arrayNames == null ? (i + 1) : arrayNames[i]);
					dash = false;
				}
			}
			if(!first) {
				b.append(" ");
			}
		}

		@Override
		public String toLocalRuleString() {
			return toRuleString(localDaysStr, localMothsStr);
		}

		@Override
		public boolean isOpened24_7() {
			boolean opened24_7 = true;
			for (int i = 0; i < 7; i++) {
				if (!days[i]) {
					opened24_7 = false;
					break;
				}
			}

			if (opened24_7 && startTimes != null && startTimes.size() > 0) {
				for (int i = 0; i < startTimes.size(); i++) {
					int startTime = startTimes.get(i);
					int endTime = endTimes.get(i);
					if (startTime == 0 && endTime / 60 == 24) {
						return true;
					}
				}
			}
			return false;
		}

		@Override
		public String getTime(Calendar cal, boolean checkAnotherDay, int limit, boolean opening) {
			StringBuilder sb = new StringBuilder();
			int d = getCurrentDay(cal);
			int ad = opening ? getNextDay(d) : getPreviousDay(d);
			int time = getCurrentTimeInMinutes(cal);
			for (int i = 0; i < startTimes.size(); i++) {
				int startTime = startTimes.get(i);
				int endTime = endTimes.get(i);
				if (opening != off) {
					if (startTime < endTime || endTime == -1) {
						if (days[d] && !checkAnotherDay) {
							int diff = startTime - time;
							if (limit == WITHOUT_TIME_LIMIT || (time <= startTime && (diff <= limit || limit == CURRENT_DAY_TIME_LIMIT))) { 
								formatTime(startTime, sb);
								break;
							}
						}
					} else {
						int diff = -1;
						if (time <= startTime && days[d] && !checkAnotherDay) {
							diff = startTime - time;
						} else if (time > endTime && days[ad] && checkAnotherDay) {
							diff = 24 * 60 - endTime  + time;
						}
						if (limit == WITHOUT_TIME_LIMIT || (diff != -1 && diff <= limit || limit == CURRENT_DAY_TIME_LIMIT)) {
							formatTime(startTime, sb);
							break;
						}
					}
				} else {
					if (startTime < endTime && endTime != -1) {
						if (days[d] && !checkAnotherDay) {
							int diff = endTime - time;
							if ((limit == WITHOUT_TIME_LIMIT && diff >= 0) || (time <= endTime && diff <= limit)) {
								formatTime(endTime, sb);
								break;
							}
						}
					} else {
						int diff = -1;
						if (time <= endTime && days[d] && !checkAnotherDay) {
							diff = 24 * 60 - time + endTime;
						} else if (time < endTime && days[ad] && checkAnotherDay) {
							diff = endTime - time;
						}
						if (limit == WITHOUT_TIME_LIMIT || (diff != -1 && diff <= limit)) {
							formatTime(endTime, sb);
							break;
						}
					}
				}
			}
			return sb.toString();
		}

		@Override
		public String toString() {
			return toRuleString();
		}

		public void appendDaysString(StringBuilder builder) {
			appendDaysString(builder, daysStr);
		}

		public void appendDaysString(StringBuilder builder, String[] daysNames) {
			boolean dash = false;
			boolean first = true;
			for (int i = 0; i < 7; i++) {
				if (days[i]) {
					if (i > 0 && days[i - 1] && i < 6 && days[i + 1]) {
						if (!dash) {
							dash = true;
							builder.append("-"); //$NON-NLS-1$
						}
						continue;
					}
					if (first) {
						first = false;
					} else if (!dash) {
						builder.append(", "); //$NON-NLS-1$
					}
					builder.append(daysNames[getDayIndex(i)]);
					dash = false;
				}
			}
			if (publicHoliday) {
				if (!first) {
					builder.append(", ");
				}
				builder.append("PH");
				first = false;
			}
			if (schoolHoliday) {
				if (!first) {
					builder.append(", ");
				}
				builder.append("SH");
				first = false;
			}
			if (easter) {
				if (!first) {
					builder.append(", ");
				}
				builder.append("Easter");
				first = false;
			}
			if(!first) {
				builder.append(" ");
			}
		}

		/**
		 * Add a time range (startTime-endTime) to this rule
		 *
		 * @param startTime startTime to add
		 * @param endTime   endTime to add
		 */
		public void addTimeRange(int startTime, int endTime) {
			startTimes.add(startTime);
			endTimes.add(endTime);
		}

		public int timesSize() {
			return startTimes.size();
		}

		public void deleteTimeRange(int position) {
			startTimes.removeAt(position);
			endTimes.removeAt(position);
		}

		private static void setSingleValueForArrayList(TIntArrayList arrayList, int s) {
			if (arrayList.size() > 0) {
				arrayList.remove(0, arrayList.size());
			}
			arrayList.add(s);
		}

		@Override
		public boolean isOpenedForTime(Calendar cal) {
			int c = calculate(cal);
			return c > 0;
		}

		@Override
		public boolean contains(Calendar cal) {
			int c = calculate(cal);
			return c != 0;
		}
		
		@Override
		public boolean hasOverlapTimes() {
			for (int i = 0; i < startTimes.size(); i++) {
				int startTime = this.startTimes.get(i);
				int endTime = this.endTimes.get(i);
				if (startTime >= endTime && endTime != -1) {
					return true;
				}
			}
			return false;
		}

		private int calculate(Calendar cal) {
			int month = cal.get(Calendar.MONTH);
			if (!months[month]) {
				return 0;
			}
			int dmonth = cal.get(Calendar.DAY_OF_MONTH) - 1;
			int i = cal.get(Calendar.DAY_OF_WEEK);
			int day = (i + 5) % 7;
			int previous = (day + 6) % 7;
			boolean thisDay = days[day] || dayMonths[dmonth];
			// potential error for Dec 31 12:00-01:00
			boolean previousDay = days[previous] || (dmonth > 0 && dayMonths[dmonth - 1]);
			if (!thisDay && !previousDay) {
				return 0;
			}
			int time = cal.get(Calendar.HOUR_OF_DAY) * 60 + cal.get(Calendar.MINUTE); // Time in minutes
			for (i = 0; i < startTimes.size(); i++) {
				int startTime = this.startTimes.get(i);
				int endTime = this.endTimes.get(i);
				if (startTime < endTime || endTime == -1) {
					// one day working like 10:00-20:00 (not 20:00-04:00)
					if (time >= startTime && (endTime == -1 || time <= endTime) && thisDay) {
						return off ? -1 : 1;
					}
				} else {
					// opening_hours includes day wrap like
					// "We 20:00-03:00" or "We 07:00-07:00"
					if (time >= startTime && thisDay) {
						return off ? -1 : 1;
					} else if (time < endTime && previousDay) {
						return off ? -1 : 1;
					}
				}
			}
			if (thisDay && (startTimes == null || startTimes.isEmpty() || !off)) {
				return -1;
			}
			return 0;
		}
	}

	public static class UnparseableRule implements OpeningHoursParser.OpeningHoursRule {
		private String ruleString;

		public UnparseableRule(String ruleString) {
			this.ruleString = ruleString;
		}

		@Override
		public boolean isOpenedForTime(Calendar cal, boolean checkPrevious) {
			return false;
		}

		@Override
		public boolean containsPreviousDay(Calendar cal) {
			return false;
		}
		
		@Override
		public boolean hasOverlapTimes() {
			return false;
		}

		@Override
		public boolean containsDay(Calendar cal) {
			return false;
		}

		@Override
		public boolean containsNextDay(Calendar cal) {
			return false;
		}

		@Override
		public boolean containsMonth(Calendar cal) {
			return false;
		}

		@Override
		public String toRuleString() {
			return ruleString;
		}

		@Override
		public String toLocalRuleString() {
			return toRuleString();
		}

		@Override
		public boolean isOpened24_7() {
			return false;
		}

		@Override
		public String getTime(Calendar cal, boolean checkAnotherDay, int limit, boolean opening) {
			return "";
		}

		@Override
		public String toString() {
			return toRuleString();
		}

		@Override
		public boolean isOpenedForTime(Calendar cal) {
			return false;
		}

		@Override
		public boolean contains(Calendar cal) {
			return false;
		}
	}
	
	private enum TokenType { 
		TOKEN_UNKNOWN(0),
		TOKEN_COLON(1),
		TOKEN_COMMA(2),
		TOKEN_DASH(3),
		// order is important
		TOKEN_MONTH(4),
		TOKEN_DAY_MONTH(5),
		TOKEN_HOLIDAY(6),
		TOKEN_DAY_WEEK(6),
		TOKEN_HOUR_MINUTES (7),
		TOKEN_OFF_ON(8);
		public final int ord;

		private TokenType(int ord) {
			this.ord = ord;
		}

		public int ord() {
			return ord;
		}

	}
	
	private static class Token {
		public Token(TokenType tokenType, String string) {
			type = tokenType;
			text = string;
			try {
				mainNumber = Integer.parseInt(string);
			} catch(NumberFormatException e){
			}
		}
		int mainNumber = -1;
		TokenType type;
		String text;
		
		@Override
		public String toString() {
			return text + " [" + type + "] ";
		}
	}

	public static OpeningHoursParser.OpeningHoursRule parseRuleV2(String r) {
		r = r.toLowerCase();
		
		final String[] daysStr = new String[]{"mo", "tu", "we", "th", "fr", "sa", "su"};
		final String[] monthsStr = new String[]{"jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec"};
		final String[] holidayStr = new String[]{"ph", "sh", "easter"};
		String sunrise = "07:00";
		String sunset = "21:00";
		String endOfDay = "24:00";
		r = r.replace('(', ' '); // avoid "(mo-su 17:00-20:00"
		r = r.replace(')', ' ');
		String localRuleString = r.replaceAll("sunset", sunset).replaceAll("sunrise", sunrise)
				.replaceAll("\\+", "-" + endOfDay);
		BasicOpeningHourRule basic = new BasicOpeningHourRule();
		boolean[] days = basic.getDays();
		boolean[] months = basic.getMonths();
		boolean[] dayMonths = basic.getDayMonths();
		if ("24/7".equals(localRuleString)) {
			Arrays.fill(days, true);
			Arrays.fill(months, true);
			basic.addTimeRange(0, 24 * 60);
			return basic;
		}
		List<Token> tokens = new ArrayList<>();
		int startWord = 0;
		for(int i = 0; i <= localRuleString.length(); i++) {
			char ch = i == localRuleString.length() ? ' ' : localRuleString.charAt(i);
			boolean delimiter = false;
			Token del = null;
			if(Character.isWhitespace(ch)) {
				delimiter = true;
			} else if(ch == ':') {
				del = new Token(TokenType.TOKEN_COLON, ":");
			} else if(ch == '-') {
				del = new Token(TokenType.TOKEN_DASH, "-");
			} else if(ch == ',') {
				del = new Token(TokenType.TOKEN_COMMA, ",");
			}
			if(delimiter || del != null) {
				String wrd = localRuleString.substring(startWord, i).trim();
				if(wrd.length() > 0) {
					tokens.add(new Token(TokenType.TOKEN_UNKNOWN, wrd));
				}
				startWord = i + 1;
				if(del != null) {
					tokens.add(del);
				}
			}
		}
		// recognize day of week
		for(Token t : tokens) {
			if(t.type == TokenType.TOKEN_UNKNOWN) {
				findInArray(t, daysStr, TokenType.TOKEN_DAY_WEEK);
			}
			if(t.type == TokenType.TOKEN_UNKNOWN) {
				findInArray(t, monthsStr, TokenType.TOKEN_MONTH);
			}
			if(t.type == TokenType.TOKEN_UNKNOWN) {
				findInArray(t, holidayStr, TokenType.TOKEN_HOLIDAY);
			}
			if(t.type == TokenType.TOKEN_UNKNOWN && ("off".equals(t.text) || "closed".equals(t.text))) {
				t.type = TokenType.TOKEN_OFF_ON;
				t.mainNumber = 0;
			}
			if(t.type == TokenType.TOKEN_UNKNOWN && ("24/7".equals(t.text) || "open".equals(t.text))) {
				t.type = TokenType.TOKEN_OFF_ON;
				t.mainNumber = 1;
			}
		}
		// recognize hours minutes ( Dec 25: 08:30-20:00)
		for(int i = tokens.size() - 1; i >= 0; i --) {
			if(tokens.get(i).type == TokenType.TOKEN_COLON) {
				if(i > 0 && i < tokens.size() - 1) {
					if(tokens.get(i - 1).type == TokenType.TOKEN_UNKNOWN && tokens.get(i - 1).mainNumber != -1 && 
							tokens.get(i + 1).type == TokenType.TOKEN_UNKNOWN && tokens.get(i + 1).mainNumber != -1 ) {
						tokens.get(i).mainNumber = 60 * tokens.get(i - 1).mainNumber + tokens.get(i + 1).mainNumber;
						tokens.get(i).type = TokenType.TOKEN_HOUR_MINUTES;
						tokens.remove(i + 1);
						tokens.remove(i - 1);
					}
				}
				
			}
		}
		// recognize other numbers
		// if there is no on/off and minutes/hours
		boolean hoursSpecified = false;
		for(int i = 0; i < tokens.size(); i ++) {
			if(tokens.get(i).type == TokenType.TOKEN_HOUR_MINUTES || 
					tokens.get(i).type == TokenType.TOKEN_OFF_ON) {
				hoursSpecified = true;
				break;
			}
		}
		for(int i = 0; i < tokens.size(); i ++) {
			if(tokens.get(i).type == TokenType.TOKEN_UNKNOWN && tokens.get(i).mainNumber >= 0) {
				tokens.get(i).type = hoursSpecified ? TokenType.TOKEN_DAY_MONTH : TokenType.TOKEN_HOUR_MINUTES;
				if(tokens.get(i).type == TokenType.TOKEN_HOUR_MINUTES) {
					tokens.get(i).mainNumber = tokens.get(i).mainNumber * 60;
				} else {
					tokens.get(i).mainNumber = tokens.get(i).mainNumber - 1;
				}
			}
		}
		// order MONTH MONTH_DAY DAY_WEEK HOUR_MINUTE OPEN_OFF
		TokenType currentParse = TokenType.TOKEN_UNKNOWN;
		List<Token[]> listOfPairs = new ArrayList<>();
		Set<TokenType> presentTokens = new HashSet<>();
		Token[] currentPair = new Token[2];
		listOfPairs.add(currentPair);
		int indexP = 0;
		for(int i = 0; i <= tokens.size(); i++) {
			Token t = i == tokens.size() ? null : tokens.get(i);
			if (t == null || t.type.ord() > currentParse.ord()) {
				presentTokens.add(currentParse);
				// case tokens.get(i).type.ordinal() < currentParse.ordinal() - not supported (Fr 15:00-18:00, Sa 16-18)
				if (currentParse == TokenType.TOKEN_MONTH || currentParse == TokenType.TOKEN_DAY_MONTH
						|| currentParse == TokenType.TOKEN_DAY_WEEK || currentParse == TokenType.TOKEN_HOLIDAY) {
					
					boolean[] array = (currentParse == TokenType.TOKEN_MONTH) ? basic.getMonths()
							: (currentParse == TokenType.TOKEN_DAY_MONTH) ? basic.getDayMonths() : basic.getDays();
					for (Token[] pair : listOfPairs) {
						if (pair[0] != null && pair[1] != null) {
							if (pair[0].mainNumber <= pair[1].mainNumber) {
								for (int j = pair[0].mainNumber; j <= pair[1].mainNumber && j < array.length; j++) {
									array[j] = true;
								}
							} else {
								// overflow
								for (int j = pair[0].mainNumber; j < array.length; j++) {
									array[j] = true;
								}
								for (int j = 0; j <= pair[1].mainNumber; j++) {
									array[j] = true;
								}
							}
						} else if (pair[0] != null) {
							if(pair[0].type == TokenType.TOKEN_HOLIDAY) {
								if(pair[0].mainNumber == 0) {
									basic.publicHoliday = true;
								} else if(pair[0].mainNumber == 1) {
									basic.schoolHoliday = true;
								} else if(pair[0].mainNumber == 2) {
									basic.easter = true;
								}
							} else if(pair[0].mainNumber >= 0){
								array[pair[0].mainNumber] = true;
							}
						}
					}
				} else if (currentParse == TokenType.TOKEN_HOUR_MINUTES) {
					for (Token[] pair : listOfPairs) {
						if(pair[0] != null && pair[1] != null) {
							basic.addTimeRange(pair[0].mainNumber, pair[1].mainNumber);
						}
					}
				} else if (currentParse == TokenType.TOKEN_OFF_ON) {
					Token[] l = listOfPairs.get(0);
					if(l[0] != null && l[0].mainNumber == 0) {
						basic.off = true;
					}
				}
				listOfPairs.clear();
				currentPair = new Token[2];
				indexP = 0;
				listOfPairs.add(currentPair);
				currentPair[indexP++] = t;
				if(t != null) {
					currentParse = t.type;
				}
			} else if(t.type == TokenType.TOKEN_COMMA) {
				currentPair = new Token[2];
				indexP = 0;
				listOfPairs.add(currentPair);
			} else if(t.type == TokenType.TOKEN_DASH) {
				
			} else if(t.type.ord() == currentParse.ord()) {
				if(indexP < 2) {
					currentPair[indexP++] = t;
				}
			}
		}
		if(!presentTokens.contains(TokenType.TOKEN_MONTH)) {
			Arrays.fill(basic.getMonths(), true);
		}
//		if(!presentTokens.contains(TokenType.TOKEN_DAY_MONTH)) {
//			Arrays.fill(basic.getDayMonths(), true);
//		}
		if(!presentTokens.contains(TokenType.TOKEN_DAY_WEEK) && !presentTokens.contains(TokenType.TOKEN_HOLIDAY) && 
				!presentTokens.contains(TokenType.TOKEN_DAY_MONTH)) {
			Arrays.fill(basic.getDays(), true);
		}
//		if(!presentTokens.contains(TokenType.TOKEN_HOUR_MINUTES)) {
//			basic.addTimeRange(0, 24 * 60);
//		}
//		System.out.println(r + " " +  tokens);
		return basic;
	}

	private static void findInArray(Token t, String[] list, TokenType tokenType) {
		for(int i = 0; i < list.length; i++) {
			if(list[i].equals(t.text)) {
				t.type = tokenType;
				t.mainNumber = i;
				break;
			}
		}
	}

	/**
	 * Parse an opening_hours string from OSM to an OpeningHours object which can be used to check
	 *
	 * @param r the string to parse
	 * @return BasicRule if the String is successfully parsed and UnparseableRule otherwise
	 */
	public static OpeningHoursParser.OpeningHoursRule parseRule(String r) {
		return parseRuleV2(r);
	}

	/**
	 * parse OSM opening_hours string to an OpeningHours object
	 *
	 * @param format the string to parse
	 * @return null when parsing was unsuccessful
	 */
	public static OpeningHours parseOpenedHours(String format) {
		if (format == null) {
			return null;
		}
		// split the OSM string in multiple rules
		String[] rules = format.split(";"); //$NON-NLS-1$
		// FIXME: What if the semicolon is inside a quoted string?
		OpeningHours rs = new OpeningHours();
		rs.setOriginal(format);
		for (String r : rules) {
			r = r.trim();
			if (r.length() == 0) {
				continue;
			}
			// check if valid
			final OpeningHoursRule r1 = parseRule(r);
			boolean rule = r1 instanceof BasicOpeningHourRule;
			if (rule) {
				rs.addRule(r1);
			}
		}
		return rs;
	}

	/**
	 * parse OSM opening_hours string to an OpeningHours object.
	 * Does not return null when parsing unsuccessful. When parsing rule is unsuccessful,
	 * such rule is stored as UnparseableRule.
	 *
	 * @param format the string to parse
	 * @return the OpeningHours object
	 */
	public static OpeningHoursParser.OpeningHours parseOpenedHoursHandleErrors(String format) {
		if (format == null) {
			return null;
		}
		String[] rules = format.split(";"); //$NON-NLS-1$
		OpeningHoursParser.OpeningHours rs = new OpeningHoursParser.OpeningHours();
		rs.setOriginal(format);
		for (String r : rules) {
			r = r.trim();
			if (r.length() == 0) {
				continue;
			}
			// check if valid
			rs.addRule(OpeningHoursParser.parseRule(r));
		}
		return rs;
	}

	private static void formatTime(int h, int t, StringBuilder b) {
		if (h < 10) {
			b.append("0"); //$NON-NLS-1$
		}
		b.append(h).append(":"); //$NON-NLS-1$
		if (t < 10) {
			b.append("0"); //$NON-NLS-1$
		}
		b.append(t);
	}

	private static void formatTime(int minutes, StringBuilder sb) {
		int hour = minutes / 60;
		int time = minutes - hour * 60;
		formatTime(hour, time, sb);
	}

	/**
	 * test if the calculated opening hours are what you expect
	 *
	 * @param time     the time to test in the format "dd.MM.yyyy HH:mm"
	 * @param hours    the OpeningHours object
	 * @param expected the expected state
	 */
	private static void testOpened(String time, OpeningHours hours, boolean expected) throws ParseException {
		Calendar cal = Calendar.getInstance();
		cal.setTime(new SimpleDateFormat("dd.MM.yyyy HH:mm", Locale.US).parse(time));
		boolean calculated = hours.isOpenedForTimeV2(cal);
		System.out.printf("  %sok: Expected %s: %b = %b (rule %s)\n",
				((calculated != expected) ? "NOT " : ""), time, expected, calculated, hours.getCurrentRuleTime(cal));
		if (calculated != expected) {
			throw new IllegalArgumentException("BUG!!!");
		}
	}

	/**
	 * test if the calculated opening hours are what you expect
	 *
	 * @param time        the time to test in the format "dd.MM.yyyy HH:mm"
	 * @param hours       the OpeningHours object
	 * @param expected    the expected string in format:
	 *                         "Open from HH:mm"     - open in 5 hours
	 *                         "Will open at HH:mm"  - open in 2 hours
	 *                         "Open till HH:mm"     - close in 5 hours
	 *                         "Will close at HH:mm" - close in 2 hours
	 *                         "Will open on HH:mm (Mo,Tu,We,Th,Fr,Sa,Su)" - open in >5 hours
	 *                         "Open 24/7"           - open 24/7
	 */
	private static void testInfo(String time, OpeningHours hours, String expected) throws ParseException
	{
		Calendar cal = Calendar.getInstance();
		cal.setTime(new SimpleDateFormat("dd.MM.yyyy HH:mm", Locale.US).parse(time));
	    
	    boolean opened24_calc = false;
	    boolean openFrom_calc = false;
	    boolean willOpenAt_calc = false;
	    boolean openTill_calc = false;
	    boolean willCloseAt_calc = false;
	    boolean willOpenOn_calc = false;
	    
	    boolean opened = hours.isOpenedForTimeV2(cal);
	    if (opened) {
	        opened24_calc = hours.isOpened24_7();
	        openTill_calc = !Algorithms.isEmpty(hours.getClosingTime(cal));
	        willCloseAt_calc = !Algorithms.isEmpty(hours.getNearToClosingTime(cal));
	    } else {
	        openFrom_calc = !Algorithms.isEmpty(hours.getOpeningTime(cal));
	        willOpenAt_calc = !Algorithms.isEmpty(hours.getNearToOpeningTime(cal));
	        willOpenOn_calc = !Algorithms.isEmpty(hours.getOpeningDay(cal));
	    }
	    
	    String description = "Unknown";
	    if (opened24_calc) {
	        description = "Open 24/7";
	    } else if (willOpenAt_calc) {
	        description = "Will open at " + hours.getNearToOpeningTime(cal);
	    } else if (openFrom_calc) {
	        description = "Open from " + hours.getOpeningTime(cal);
	    } else if (willCloseAt_calc) {
	        description = "Will close at " + hours.getNearToClosingTime(cal);
	    } else if (openTill_calc) {
	        description = "Open till " + hours.getClosingTime(cal);
	    } else if (willOpenOn_calc) {
	        description = "Will open on " + hours.getOpeningDay(cal);
	    }
	    
	    boolean result = expected.equalsIgnoreCase(description);
	    
		System.out.printf("  %sok: Expected %s (%s): %s (rule %s)\n",
				(!result ? "NOT " : ""), time, expected, description, hours.getCurrentRuleTime(cal));

	    if (!result)
			throw new IllegalArgumentException("BUG!!!");
	}
	
	private static void testParsedAndAssembledCorrectly(String timeString, OpeningHours hours) {
		String assembledString = hours.toString();
		boolean isCorrect = assembledString.equalsIgnoreCase(timeString);
		System.out.printf("  %sok: Expected: \"%s\" got: \"%s\"\n",
				(!isCorrect ? "NOT " : ""), timeString, assembledString);
		if (!isCorrect) {
			throw new IllegalArgumentException("BUG!!!");
		}
	}

	public static void main(String[] args) throws ParseException {
		// 0. not supported MON DAY-MON DAY (only supported Feb 2-14 or Feb-Oct: 09:00-17:30)
		// parseOpenedHours("Feb 16-Oct 15: 09:00-18:30; Oct 16-Nov 15: 09:00-17:30; Nov 16-Feb 15: 09:00-16:30");
		
		// 1. not supported (,)
		// hours = parseOpenedHours("Mo-Su 07:00-23:00, Fr 08:00-20:00");
		
		// 2. not supported break properly
		// parseOpenedHours("Sa-Su 10:00-17:00 || \"by appointment\"");
		// comment is dropped
		
		// 3. not properly supported
		// hours = parseOpenedHours("Mo-Su (sunrise-00:30)-(sunset+00:30)");
		
		// Test basic case
		OpeningHours hours = parseOpenedHours("Mo-Fr 08:30-14:40"); //$NON-NLS-1$
		testOpened("09.08.2012 11:00", hours, true);
		testOpened("09.08.2012 16:00", hours, false);
		hours = parseOpenedHours("mo-fr 07:00-19:00; sa 12:00-18:00");
		System.out.println(hours);

		String string = "Mo-Fr 11:30-15:00, 17:30-23:00; Sa, Su, PH 11:30-23:00";
		hours = parseOpenedHours(string);
		testParsedAndAssembledCorrectly(string, hours);
		System.out.println(hours);
		testOpened("7.09.2015 14:54", hours, true); // monday
		testOpened("7.09.2015 15:05", hours, false);
		testOpened("6.09.2015 16:05", hours, true);


		// two time and date ranges
		hours = parseOpenedHours("Mo-We, Fr 08:30-14:40,15:00-19:00"); //$NON-NLS-1$
		System.out.println(hours);
		testOpened("08.08.2012 14:00", hours, true);
		testOpened("08.08.2012 14:50", hours, false);
		testOpened("10.08.2012 15:00", hours, true);

		// test exception on general schema
		hours = parseOpenedHours("Mo-Sa 08:30-14:40; Tu 08:00 - 14:00"); //$NON-NLS-1$
		System.out.println(hours);
		testOpened("07.08.2012 14:20", hours, false);
		testOpened("07.08.2012 08:15", hours, true); // Tuesday

		// test off value
		hours = parseOpenedHours("Mo-Sa 09:00-18:25; Th off"); //$NON-NLS-1$
		System.out.println(hours);
		testOpened("08.08.2012 12:00", hours, true);
		testOpened("09.08.2012 12:00", hours, false);

		// test 24/7
		hours = parseOpenedHours("24/7"); //$NON-NLS-1$
		System.out.println(hours);
		testOpened("08.08.2012 23:59", hours, true);
		testOpened("08.08.2012 12:23", hours, true);
		testOpened("08.08.2012 06:23", hours, true);

		// some people seem to use the following syntax:
		hours = parseOpenedHours("Sa-Su 24/7");
		System.out.println(hours);
		hours = parseOpenedHours("Mo-Fr 9-19");
		System.out.println(hours);
		hours = parseOpenedHours("09:00-17:00");
		System.out.println(hours);
		hours = parseOpenedHours("sunrise-sunset");
		System.out.println(hours);
		hours = parseOpenedHours("10:00+");
		System.out.println(hours);
		hours = parseOpenedHours("Su-Th sunset-24:00, 04:00-sunrise; Fr-Sa sunset-sunrise");
		System.out.println(hours);
		testOpened("12.08.2012 04:00", hours, true);
		testOpened("12.08.2012 23:00", hours, true);
		testOpened("08.08.2012 12:00", hours, false);
		testOpened("08.08.2012 05:00", hours, true);

		// test simple day wrap
		hours = parseOpenedHours("Mo 20:00-02:00");
		System.out.println(hours);
		testOpened("05.05.2013 10:30", hours, false);
		testOpened("05.05.2013 23:59", hours, false);
		testOpened("06.05.2013 10:30", hours, false);
		testOpened("06.05.2013 20:30", hours, true);
		testOpened("06.05.2013 23:59", hours, true);
		testOpened("07.05.2013 00:00", hours, true);
		testOpened("07.05.2013 00:30", hours, true);
		testOpened("07.05.2013 01:59", hours, true);
		testOpened("07.05.2013 20:30", hours, false);

		// test maximum day wrap
		hours = parseOpenedHours("Su 10:00-10:00");
		System.out.println(hours);
		testOpened("05.05.2013 09:59", hours, false);
		testOpened("05.05.2013 10:00", hours, true);
		testOpened("05.05.2013 23:59", hours, true);
		testOpened("06.05.2013 00:00", hours, true);
		testOpened("06.05.2013 09:59", hours, true);
		testOpened("06.05.2013 10:00", hours, false);

		// test day wrap as seen on OSM
		hours = parseOpenedHours("Tu-Th 07:00-2:00; Fr 17:00-4:00; Sa 18:00-05:00; Su,Mo off");
		System.out.println(hours);
		testOpened("05.05.2013 04:59", hours, true); // sunday 05.05.2013
		testOpened("05.05.2013 05:00", hours, false);
		testOpened("05.05.2013 12:30", hours, false);
		testOpened("06.05.2013 10:30", hours, false);
		testOpened("07.05.2013 01:00", hours, false);
		testOpened("07.05.2013 20:25", hours, true);
		testOpened("07.05.2013 23:59", hours, true);
		testOpened("08.05.2013 00:00", hours, true);
		testOpened("08.05.2013 02:00", hours, false);

		// test day wrap as seen on OSM
		hours = parseOpenedHours("Mo-Th 09:00-03:00; Fr-Sa 09:00-04:00; Su off");
		testOpened("11.05.2015 08:59", hours, false);
		testOpened("11.05.2015 09:01", hours, true);
		testOpened("12.05.2015 02:59", hours, true);
		testOpened("12.05.2015 03:00", hours, false);
		testOpened("16.05.2015 03:59", hours, true);
		testOpened("16.05.2015 04:01", hours, false);
		testOpened("17.05.2015 01:00", hours, true);
		testOpened("17.05.2015 04:01", hours, false);

		hours = parseOpenedHours("Tu-Th 07:00-2:00; Fr 17:00-4:00; Sa 18:00-05:00; Su,Mo off");
		testOpened("11.05.2015 08:59", hours, false);
		testOpened("11.05.2015 09:01", hours, false);
		testOpened("12.05.2015 01:59", hours, false);
		testOpened("12.05.2015 02:59", hours, false);
		testOpened("12.05.2015 03:00", hours, false);
		testOpened("13.05.2015 01:59", hours, true);
		testOpened("13.05.2015 02:59", hours, false);
		testOpened("16.05.2015 03:59", hours, true);
		testOpened("16.05.2015 04:01", hours, false);
		testOpened("17.05.2015 01:00", hours, true);
		testOpened("17.05.2015 05:01", hours, false);

		// tests single month value
		hours = parseOpenedHours("May: 07:00-19:00");
		System.out.println(hours);
		testOpened("05.05.2013 12:00", hours, true);
		testOpened("05.05.2013 05:00", hours, false);
		testOpened("05.05.2013 21:00", hours, false);
		testOpened("05.01.2013 12:00", hours, false);
		testOpened("05.01.2013 05:00", hours, false);

		// tests multi month value
		hours = parseOpenedHours("Apr-Sep 8:00-22:00; Oct-Mar 10:00-18:00");
		System.out.println(hours);
		testOpened("05.03.2013 15:00", hours, true);
		testOpened("05.03.2013 20:00", hours, false);

		testOpened("05.05.2013 20:00", hours, true);
		testOpened("05.05.2013 23:00", hours, false);

		testOpened("05.10.2013 15:00", hours, true);
		testOpened("05.10.2013 20:00", hours, false);

		// Test time with breaks
		hours = parseOpenedHours("Mo-Fr: 9:00-13:00, 14:00-18:00");
		System.out.println(hours);
		testOpened("02.12.2015 12:00", hours, true);
		testOpened("02.12.2015 13:30", hours, false);
		testOpened("02.12.2015 16:00", hours, true);

		testOpened("05.12.2015 16:00", hours, false);
		
		hours = parseOpenedHours("Mo-Su 07:00-23:00; Dec 25 08:00-20:00");
		System.out.println(hours);
		testOpened("25.12.2015 07:00", hours, false);
		testOpened("24.12.2015 07:00", hours, true);
		testOpened("24.12.2015 22:00", hours, true);
		testOpened("25.12.2015 08:00", hours, true);
		testOpened("25.12.2015 22:00", hours, false);
		
		hours = parseOpenedHours("Mo-Su 07:00-23:00; Dec 25 off");
		System.out.println(hours);
		testOpened("25.12.2015 14:00", hours, false);
		testOpened("24.12.2015 08:00", hours, true);
		
		// easter itself as public holiday is not supported
		hours = parseOpenedHours("Mo-Su 07:00-23:00; Easter off; Dec 25 off");
		System.out.println(hours);
		testOpened("25.12.2015 14:00", hours, false);
		testOpened("24.12.2015 08:00", hours, true);

		// test time off (not days
		hours = parseOpenedHours("Mo-Fr 08:30-17:00; 12:00-12:40 off;");
		System.out.println(hours);
		testOpened("07.05.2017 14:00", hours, false); // Sunday
		testOpened("06.05.2017 12:15", hours, false); // Saturday
		testOpened("05.05.2017 14:00", hours, true); // Friday
		testOpened("05.05.2017 12:15", hours, false);
		testOpened("05.05.2017 12:00", hours, false);
		testOpened("05.05.2017 11:45", hours, true);
		
		// Test holidays
		String hoursString = "mo-fr 11:00-21:00; PH off";
		hours = parseOpenedHoursHandleErrors(hoursString);
		testParsedAndAssembledCorrectly(hoursString, hours);

	    // test open from/till
		hours = parseOpenedHours("Mo-Fr 08:30-17:00; 12:00-12:40 off;");
		System.out.println(hours);
	    testInfo("15.01.2018 09:00", hours, "Open till 12:00");
	    testInfo("15.01.2018 11:00", hours, "Will close at 12:00");
	    testInfo("15.01.2018 12:00", hours, "Will open at 12:40");

		hours = parseOpenedHours("Mo-Fr: 9:00-13:00, 14:00-18:00");
		System.out.println(hours);
	    testInfo("15.01.2018 08:00", hours, "Will open at 09:00");
	    testInfo("15.01.2018 09:00", hours, "Open till 13:00");
	    testInfo("15.01.2018 12:00", hours, "Will close at 13:00");
	    testInfo("15.01.2018 13:10", hours, "Will open at 14:00");
	    testInfo("15.01.2018 14:00", hours, "Open till 18:00");
	    testInfo("15.01.2018 16:00", hours, "Will close at 18:00");
	    testInfo("15.01.2018 18:10", hours, "Will open on 09:00 Tu");
		
	    hours = parseOpenedHours("Mo-Sa 02:00-10:00; Th off");
		System.out.println(hours);
	    testInfo("15.01.2018 23:00", hours, "Will open on 02:00 Tu");

	    hours = parseOpenedHours("Mo-Sa 23:00-02:00; Th off");
		System.out.println(hours);
	    testInfo("15.01.2018 22:00", hours, "Will open at 23:00");
	    testInfo("15.01.2018 23:00", hours, "Open till 02:00");
	    testInfo("16.01.2018 00:30", hours, "Will close at 02:00");
	    testInfo("16.01.2018 02:00", hours, "Open from 23:00");

	    hours = parseOpenedHours("Mo-Sa 08:30-17:00; Th off");
		System.out.println(hours);
	    testInfo("17.01.2018 20:00", hours, "Will open on 08:30 Fr");
	    testInfo("18.01.2018 05:00", hours, "Will open on 08:30 Fr");
	    testInfo("20.01.2018 05:00", hours, "Open from 08:30");
	    testInfo("21.01.2018 05:00", hours, "Will open on 08:30 Mo");
	    testInfo("22.01.2018 02:00", hours, "Open from 08:30");
	    testInfo("22.01.2018 04:00", hours, "Open from 08:30");
	    testInfo("22.01.2018 07:00", hours, "Will open at 08:30");
	    testInfo("23.01.2018 10:00", hours, "Open till 17:00");
	    testInfo("23.01.2018 16:00", hours, "Will close at 17:00");

	    hours = parseOpenedHours("24/7");
		System.out.println(hours);
	    testInfo("24.01.2018 02:00", hours, "Open 24/7");
	}
}
!@#$%
20190530_064301,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_a11712
package net.osmand.util;
/* Can be commented out in order to run the main function separately */

import java.io.Serializable;
import java.text.DateFormatSymbols;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Set;

import gnu.trove.list.array.TIntArrayList;

/**
 * Class used to parse opening hours
 * <p/>
 * the method "parseOpenedHours" will parse an OSM opening_hours string and
 * return an object of the type OpeningHours. That object can be used to check
 * if the OSM feature is open at a certain time.
 */
public class OpeningHoursParser {
	private static final String[] daysStr;
	private static final String[] localDaysStr;
	private static final String[] monthsStr;
	private static final String[] localMothsStr;

	private static final int LOW_TIME_LIMIT = 120;
	private static final int HIGH_TIME_LIMIT = 300;
	private static final int WITHOUT_TIME_LIMIT = -1;

	static {
		DateFormatSymbols dateFormatSymbols = DateFormatSymbols.getInstance(Locale.US);
		monthsStr = dateFormatSymbols.getShortMonths();
		daysStr = getTwoLettersStringArray(dateFormatSymbols.getShortWeekdays());
		dateFormatSymbols = DateFormatSymbols.getInstance();
		localMothsStr = dateFormatSymbols.getShortMonths();
		localDaysStr = getTwoLettersStringArray(dateFormatSymbols.getShortWeekdays());
	}

	/**
	 * Default values for sunrise and sunset. Might be computed afterwards, not final.
	 */
	private static String sunrise = "07:00", sunset = "21:00";

	/**
	 * Hour of when you would expect a day to be ended.
	 * This is to be used when no end hour is known (like pubs that open at a certain time,
	 * but close at a variable time, depending on the number of clients).
	 * OsmAnd needs to show a value, so there is some arbitrary default value chosen.
	 */
	private static String endOfDay = "24:00";

	private static String[] getTwoLettersStringArray(String[] strings) {
		String[] newStrings = new String[strings.length];
		for (int i = 0; i < strings.length; i++) {
			if (strings[i] != null) {
				if (strings[i].length() > 2) {
					newStrings[i] = strings[i].substring(0, 2);
				} else {
					newStrings[i] = strings[i];
				}
			}
		}
		return newStrings;
	}

	private static int getDayIndex(int i) {
		switch (i) {
			case 0: return Calendar.MONDAY;
			case 1: return Calendar.TUESDAY;
			case 2: return Calendar.WEDNESDAY;
			case 3: return Calendar.THURSDAY;
			case 4: return Calendar.FRIDAY;
			case 5: return Calendar.SATURDAY;
			case 6: return Calendar.SUNDAY;
			default: return -1;
		}
	}

	/**
	 * This class contains the entire OpeningHours schema and
	 * offers methods to check directly weather something is open
	 *
	 * @author sander
	 */
	public static class OpeningHours implements Serializable {

		/**
		 * list of the different rules
		 */
		private ArrayList<OpeningHoursRule> rules;
		private String original;

		/**
		 * Constructor
		 *
		 * @param rules List of OpeningHoursRule to be given
		 */
		public OpeningHours(ArrayList<OpeningHoursRule> rules) {
			this.rules = rules;
		}

		/**
		 * Empty constructor
		 */
		public OpeningHours() {
			rules = new ArrayList<OpeningHoursRule>();
		}

		/**
		 * add a rule to the opening hours
		 *
		 * @param r rule to add
		 */
		public void addRule(OpeningHoursRule r) {
			rules.add(r);
		}

		/**
		 * return the list of rules
		 *
		 * @return the rules
		 */
		public ArrayList<OpeningHoursRule> getRules() {
			return rules;
		}
		
		/**
		 * check if the feature is opened at time "cal"
		 *
		 * @param cal the time to check
		 * @return true if feature is open
		 */
		public boolean isOpenedForTimeV2(Calendar cal) {
			// make exception for overlapping times i.e.
			// (1) Mo 14:00-16:00; Tu off
			// (2) Mo 14:00-02:00; Tu off
			// in (2) we need to check first rule even though it is against specification
			boolean overlap = false;
			for(int i = rules.size() - 1; i >= 0 ; i--) {
				OpeningHoursRule r = rules.get(i);
				if(r.hasOverlapTimes()) {
					overlap = true;
					break;
				}
			}
			// start from the most specific rule
			for(int i = rules.size() - 1; i >= 0 ; i--) {
				OpeningHoursRule r = rules.get(i);
				if(r.contains(cal)) {
					boolean open = r.isOpenedForTime(cal);
					if(!open && overlap ) {
						continue;
					} else {
						return open;
					}
				}
			}
			return false;
		}

		/**
		 * check if the feature is opened at time "cal"
		 *
		 * @param cal the time to check
		 * @return true if feature is open
		 */
		public boolean isOpenedForTime(Calendar cal) {
			/*
			 * first check for rules that contain the current day
			 * afterwards check for rules that contain the previous
			 * day with overlapping times (times after midnight)
			 */
			boolean isOpenDay = false;
			for (OpeningHoursRule r : rules) {
				if (r.containsDay(cal) && r.containsMonth(cal)) {
					isOpenDay = r.isOpenedForTime(cal, false);
				}
			}
			boolean isOpenPrevious = false;
			for (OpeningHoursRule r : rules) {
				if (r.containsPreviousDay(cal) && r.containsMonth(cal)) {
					isOpenPrevious = r.isOpenedForTime(cal, true);
				}
			}
			return isOpenDay || isOpenPrevious;
		}

		public boolean isOpened24_7() {
			boolean opened24_7 = false;
			for (OpeningHoursRule r : rules) {
				opened24_7 = r.isOpened24_7();
			}
			return opened24_7;
		}

		public String getNearToOpeningTime(Calendar cal) {
			return getTime(cal, LOW_TIME_LIMIT, true);
		}

		public String getOpeningTime(Calendar cal) {
			return getTime(cal, HIGH_TIME_LIMIT, true);
		}

		public String getNearToClosingTime(Calendar cal) {
			return getTime(cal, LOW_TIME_LIMIT, false);
		}

		public String getClosingTime(Calendar cal) {
			return getTime(cal, WITHOUT_TIME_LIMIT, false);
		}

		public String getOpeningDay(Calendar calendar) {
			Calendar cal = (Calendar) calendar.clone();
			String openingTime = "";
			for (int i = 0; i < 7; i++) {
				cal.add(Calendar.DAY_OF_MONTH, 1);
				for (OpeningHoursRule r : rules) {
					if (r.containsDay(cal) && r.containsMonth(cal)) {
						openingTime = r.getTime(cal, false, WITHOUT_TIME_LIMIT, true);
					}
				}
				if (!Algorithms.isEmpty(openingTime)) {
					openingTime += " " + localDaysStr[cal.get(Calendar.DAY_OF_WEEK)];
					break;
				}
			}
			return openingTime;
		}

		private String getTime(Calendar cal, int limit, boolean opening) {
			String time = getTimeDay(cal, limit, opening);
			if (Algorithms.isEmpty(time)) {
				time = getTimeAnotherDay(cal, limit, opening);
			}
			return time;
		}

		private String getTimeDay(Calendar cal, int limit, boolean opening) {
			String atTime = "";
			for (OpeningHoursRule r : rules) {
				if (r.containsDay(cal) && r.containsMonth(cal)) {
					atTime = r.getTime(cal, false, limit, opening);
				}
			}
			return atTime;
		}

		private String getTimeAnotherDay(Calendar cal, int limit, boolean opening) {
			String atTime = "";
			for (OpeningHoursRule r : rules) {
				if (((opening && r.containsPreviousDay(cal)) || (!opening && r.containsNextDay(cal))) && r.containsMonth(cal)) {
					atTime = r.getTime(cal, true, limit, opening);
				}
			}
			return atTime;
		}

		public String getCurrentRuleTime(Calendar cal) {
			// make exception for overlapping times i.e.
			// (1) Mo 14:00-16:00; Tu off
			// (2) Mo 14:00-02:00; Tu off
			// in (2) we need to check first rule even though it is against specification
			String ruleClosed = null;
			boolean overlap = false;
			for (int i = rules.size() - 1; i >= 0; i--) {
				OpeningHoursRule r = rules.get(i);
				if (r.hasOverlapTimes()) {
					overlap = true;
					break;
				}
			}
			// start from the most specific rule
			for (int i = rules.size() - 1; i >= 0; i--) {
				OpeningHoursRule r = rules.get(i);
				if (r.contains(cal)) {
					boolean open = r.isOpenedForTime(cal);
					if (!open && overlap) {
						ruleClosed = r.toLocalRuleString();
					} else {
						return r.toLocalRuleString();
					}
				}
			}
			return ruleClosed;
		}
		
		public String getCurrentRuleTimeV1(Calendar cal) {
			String ruleOpen = null;
			String ruleClosed = null;
			for (OpeningHoursRule r : rules) {
				if (r.containsPreviousDay(cal) && r.containsMonth(cal)) {
					if (r.isOpenedForTime(cal, true)) {
						ruleOpen = r.toLocalRuleString();
					} else {
						ruleClosed = r.toLocalRuleString();
					}
				}
			}
			for (OpeningHoursRule r : rules) {
				if (r.containsDay(cal) && r.containsMonth(cal)) {
					if (r.isOpenedForTime(cal, false)) {
						ruleOpen = r.toLocalRuleString();
					} else {
						ruleClosed = r.toLocalRuleString();
					}
				}
			}

			if (ruleOpen != null) {
				return ruleOpen;
			}
			return ruleClosed;
		}

		@Override
		public String toString() {
			StringBuilder s = new StringBuilder();
			if (rules.isEmpty()) {
				return "";
			}
			for (OpeningHoursRule r : rules) {
				s.append(r.toString()).append("; ");
			}
			return s.substring(0, s.length() - 2);
		}

		public String toLocalString() {
			StringBuilder s = new StringBuilder();
			if (rules.isEmpty()) {
				return "";
			}

			for (OpeningHoursRule r : rules) {
				s.append(r.toLocalRuleString()).append("; ");
			}

			return s.substring(0, s.length() - 2);
		}

		public void setOriginal(String original) {
			this.original = original;
		}
		
		public String getOriginal() {
			return original;
		}
	}

	/**
	 * Interface to represent a single rule
	 * <p/>
	 * A rule consist out of
	 * - a collection of days/dates
	 * - a time range
	 */
	public static interface OpeningHoursRule extends Serializable {

		/**
		 * Check if, for this rule, the feature is opened for time "cal"
		 *
		 * @param cal           the time to check
		 * @param checkPrevious only check for overflowing times (after midnight) or don't check for it
		 * @return true if the feature is open
		 */
		public boolean isOpenedForTime(Calendar cal, boolean checkPrevious);
		
		/**
		 * Check if, for this rule, the feature is opened for time "cal" 
		 * @param cal
		 * @return true if the feature is open
		 */
		public boolean isOpenedForTime(Calendar cal);

		/**
		 * Check if the previous day before "cal" is part of this rule
		 *
		 * @param cal; the time to check
		 * @return true if the previous day is part of the rule
		 */
		public boolean containsPreviousDay(Calendar cal);

		/**
		 * Check if the day of "cal" is part of this rule
		 *
		 * @param cal the time to check
		 * @return true if the day is part of the rule
		 */
		public boolean containsDay(Calendar cal);

		/**
		 * Check if the next day after "cal" is part of this rule
		 *
		 * @param cal the time to check
		 * @return true if the next day is part of the rule
		 */
		boolean containsNextDay(Calendar cal);

		/**
		 * Check if the month of "cal" is part of this rule
		 *
		 * @param cal the time to check
		 * @return true if the month is part of the rule
		 */
		public boolean containsMonth(Calendar cal);
		
		/**
		 * @return true if the rule overlap to the next day
		 */
		public boolean hasOverlapTimes();
		
		/**
		 * @param cal
		 * @return true if rule applies for current time
		 */
		public boolean contains(Calendar cal);


		public String toRuleString();

		public String toLocalRuleString();

		boolean isOpened24_7();

		String getTime(Calendar cal, boolean checkAnotherDay, int limit, boolean opening);
	}

	/**
	 * implementation of the basic OpeningHoursRule
	 * <p/>
	 * This implementation only supports month, day of weeks and numeral times, or the value "off"
	 */
	public static class BasicOpeningHourRule implements OpeningHoursRule {
		/**
		 * represents the list on which days it is open.
		 * Day number 0 is MONDAY
		 */
		private boolean[] days = new boolean[7];

		/**
		 * represents the list on which month it is open.
		 * Day number 0 is JANUARY.
		 */
		private boolean[] months = new boolean[12];
		
		/**
		 * represents the list on which day it is open.
		 */
		private boolean[] dayMonths = new boolean[31];

		/**
		 * lists of equal size representing the start and end times
		 */
		private TIntArrayList startTimes = new TIntArrayList(), endTimes = new TIntArrayList();
		
		private boolean publicHoliday = false;
		private boolean schoolHoliday = false;
		private boolean easter = false;
		
		/**
		 * Flag that means that time is off
		 */
		private boolean off = false;

		/**
		 * return an array representing the days of the rule
		 *
		 * @return the days of the rule
		 */
		public boolean[] getDays() {
			return days;
		}
		
		/**
		 * @return the day months of the rule
		 */
		public boolean[] getDayMonths() {
			return dayMonths;
		}

		/**
		 * return an array representing the months of the rule
		 *
		 * @return the months of the rule
		 */
		public boolean[] getMonths() {
			return months;
		}
		
		public boolean appliesToPublicHolidays() {
			return publicHoliday;
		}
		
		public boolean appliesEaster() {
			return easter;
		}
		
		public boolean appliesToSchoolHolidays() {
			return schoolHoliday;
		}
		

		/**
		 * set a single start time, erase all previously added start times
		 *
		 * @param s startTime to set
		 */
		public void setStartTime(int s) {
			setSingleValueForArrayList(startTimes, s);
			if (endTimes.size() != 1) {
				setSingleValueForArrayList(endTimes, 0);
			}
		}

		/**
		 * set a single end time, erase all previously added end times
		 *
		 * @param e endTime to set
		 */
		public void setEndTime(int e) {
			setSingleValueForArrayList(endTimes, e);
			if (startTimes.size() != 1) {
				setSingleValueForArrayList(startTimes, 0);
			}
		}

		/**
		 * Set single start time. If position exceeds index of last item by one
		 * then new value will be added.
		 * If value is between 0 and last index, then value in the position p will be overwritten
		 * with new one.
		 * Else exception will be thrown.
		 *
		 * @param s        - value
		 * @param position - position to add
		 */
		public void setStartTime(int s, int position) {
			if (position == startTimes.size()) {
				startTimes.add(s);
				endTimes.add(0);
			} else {
				startTimes.set(position, s);
			}
		}

		/**
		 * Set single end time. If position exceeds index of last item by one
		 * then new value will be added.
		 * If value is between 0 and last index, then value in the position p will be overwritten
		 * with new one.
		 * Else exception will be thrown.
		 *
		 * @param s        - value
		 * @param position - position to add
		 */
		public void setEndTime(int s, int position) {
			if (position == startTimes.size()) {
				endTimes.add(s);
				startTimes.add(0);
			} else {
				endTimes.set(position, s);
			}
		}

		/**
		 * get a single start time
		 *
		 * @return a single start time
		 */
		public int getStartTime() {
			if (startTimes.size() == 0) {
				return 0;
			}
			return startTimes.get(0);
		}

		/**
		 * get a single start time in position
		 *
		 * @param position position to get value from
		 * @return a single start time
		 */
		public int getStartTime(int position) {
			return startTimes.get(position);
		}

		/**
		 * get a single end time
		 *
		 * @return a single end time
		 */
		public int getEndTime() {
			if (endTimes.size() == 0) {
				return 0;
			}
			return endTimes.get(0);
		}

		/**
		 * get a single end time in position
		 *
		 * @param position position to get value from
		 * @return a single end time
		 */
		public int getEndTime(int position) {
			return endTimes.get(position);
		}

		/**
		 * get all start times as independent list
		 *
		 * @return all start times
		 */
		public TIntArrayList getStartTimes() {
			return new TIntArrayList(startTimes);
		}

		/**
		 * get all end times as independent list
		 *
		 * @return all end times
		 */
		public TIntArrayList getEndTimes() {
			return new TIntArrayList(endTimes);
		}

		/**
		 * Check if the weekday of time "cal" is part of this rule
		 *
		 * @param cal the time to check
		 * @return true if this day is part of the rule
		 */
		@Override
		public boolean containsDay(Calendar cal) {
			int i = cal.get(Calendar.DAY_OF_WEEK);
			int d = (i + 5) % 7;
			if (days[d]) {
				return true;
			}
			return false;
		}

		@Override
		public boolean containsNextDay(Calendar cal) {
			int i = cal.get(Calendar.DAY_OF_WEEK);
			int p = (i + 6) % 7;
			if (days[p]) {
				return true;
			}
			return false;
		}

		/**
		 * Check if the previous weekday of time "cal" is part of this rule
		 *
		 * @param cal the time to check
		 * @return true if the previous day is part of the rule
		 */
		@Override
		public boolean containsPreviousDay(Calendar cal) {
			int i = cal.get(Calendar.DAY_OF_WEEK);
			int p = (i + 4) % 7;
			if (days[p]) {
				return true;
			}
			return false;
		}

		/**
		 * Check if the month of "cal" is part of this rule
		 *
		 * @param cal the time to check
		 * @return true if the month is part of the rule
		 */
		@Override
		public boolean containsMonth(Calendar cal) {
			int i = cal.get(Calendar.MONTH);
			if (months[i]) {
				return true;
			}
			return false;
		}

		/**
		 * Check if this rule says the feature is open at time "cal"
		 *
		 * @param cal the time to check
		 * @return false in all other cases, also if only day is wrong
		 */
		@Override
		public boolean isOpenedForTime(Calendar cal, boolean checkPrevious) {
			int d = getCurrentDay(cal);
			int p = getPreviousDay(d);
			int time = getCurrentTimeInMinutes(cal); // Time in minutes
			for (int i = 0; i < startTimes.size(); i++) {
				int startTime = this.startTimes.get(i);
				int endTime = this.endTimes.get(i);
				if (startTime < endTime || endTime == -1) {
					// one day working like 10:00-20:00 (not 20:00-04:00)
					if (days[d] && !checkPrevious) {
						if (time >= startTime && (endTime == -1 || time <= endTime)) {
							return !off;
						}
					}
				} else {
					// opening_hours includes day wrap like
					// "We 20:00-03:00" or "We 07:00-07:00"
					if (time >= startTime && days[d] && !checkPrevious) {
						return !off;
					} else if (time < endTime && days[p] && checkPrevious) {
						// check in previous day
						return !off;
					}
				}
			}
			return false;
		}

		private int getCurrentDay(Calendar cal) {
			int i = cal.get(Calendar.DAY_OF_WEEK);
			return (i + 5) % 7;
		}

		private int getPreviousDay(int currentDay) {
			int p = currentDay - 1;
			if (p < 0) {
				p += 7;
			}
			return p;
		}

		private int getNextDay(int currentDay) {
			int n = currentDay + 1;
			if (n > 6) {
				n -= 7;
			}
			return n;
		}

		private int getCurrentTimeInMinutes(Calendar cal) {
			return cal.get(Calendar.HOUR_OF_DAY) * 60 + cal.get(Calendar.MINUTE);
		}

		@Override
		public String toRuleString() {
			return toRuleString(daysStr, monthsStr);
		}

		private String toRuleString(String[] dayNames, String[] monthNames) {
			StringBuilder b = new StringBuilder(25);
			boolean allMonths = true;
			for (int i = 0; i < months.length; i++) {
				if (!months[i]) {
					allMonths = false;
					break;
				}
			}
			// Month
			if (!allMonths) {
				addArray(months, monthNames, b);
			}
			boolean allDays = true;
			for (int i = 0; i < dayMonths.length; i++) {
				if (!dayMonths[i]) {
					allDays = false;
					break;
				}
			}
			if (!allDays) {
				addArray(dayMonths, null, b);
			}
			// Day
			appendDaysString(b, dayNames);
			// Time
			if (startTimes == null || startTimes.size() == 0) {
				b.append("off");
			} else {
				if (isOpened24_7()) {
					return "24/7";
				}
				for (int i = 0; i < startTimes.size(); i++) {
					int startTime = startTimes.get(i);
					int endTime = endTimes.get(i);
					if(i > 0) {
						b.append(", ");
					}
					int stHour = startTime / 60;
					int stTime = startTime - stHour * 60;
					int enHour = endTime / 60;
					int enTime = endTime - enHour * 60;
					formatTime(stHour, stTime, b);
					b.append("-"); //$NON-NLS-1$
					formatTime(enHour, enTime, b);
				}
				if(off) {
					b.append(" off");
				}
			}
			return b.toString();
		}

		private void addArray(boolean[] array, String[] arrayNames, StringBuilder b) {
			boolean dash = false;
			boolean first = true;
			for (int i = 0; i < array.length; i++) {
				if (array[i]) {
					if (i > 0 && array[i - 1] && i < array.length - 1 && array[i + 1]) {
						if (!dash) {
							dash = true;
							b.append("-"); //$NON-NLS-1$
						}
						continue;
					}
					if (first) {
						first = false;
					} else if (!dash) {
						b.append(", "); //$NON-NLS-1$
					}
					b.append(arrayNames == null ? (i + 1) : arrayNames[i]);
					dash = false;
				}
			}
			if(!first) {
				b.append(" ");
			}
		}

		@Override
		public String toLocalRuleString() {
			return toRuleString(localDaysStr, localMothsStr);
		}

		@Override
		public boolean isOpened24_7() {
			boolean opened24_7 = true;
			for (int i = 0; i < 7; i++) {
				if (!days[i]) {
					opened24_7 = false;
					break;
				}
			}

			if (opened24_7 && startTimes != null && startTimes.size() > 0) {
				for (int i = 0; i < startTimes.size(); i++) {
					int startTime = startTimes.get(i);
					int endTime = endTimes.get(i);
					if (startTime == 0 && endTime / 60 == 24) {
						return true;
					}
				}
			}
			return false;
		}

		@Override
		public String getTime(Calendar cal, boolean checkAnotherDay, int limit, boolean opening) {
			StringBuilder sb = new StringBuilder();
			int d = getCurrentDay(cal);
			int ad = opening ? getNextDay(d) : getPreviousDay(d);
			int time = getCurrentTimeInMinutes(cal);
			for (int i = 0; i < startTimes.size(); i++) {
				int startTime = startTimes.get(i);
				int endTime = endTimes.get(i);
				if (opening) {
					if (startTime < endTime || endTime == -1) {
						if (days[d] && !checkAnotherDay) {
							int diff = startTime - time;
							if (limit == WITHOUT_TIME_LIMIT || ((time <= startTime) && (diff <= limit))) {
								formatTime(startTime, sb);
								break;
							}
						}
					} else {
						int diff = -1;
						if (time <= startTime && days[d] && !checkAnotherDay) {
							diff = startTime - time;
						} else if (time > endTime && days[ad] && checkAnotherDay) {
							diff = 24 * 60 - endTime  + time;
						}
						if (limit == WITHOUT_TIME_LIMIT || ((diff != -1) && (diff <= limit))) {
							formatTime(startTime, sb);
							break;
						}
					}
				} else {
					if (startTime < endTime && endTime != -1) {
						if (days[d] && !checkAnotherDay) {
							int diff = endTime - time;
							if (limit == WITHOUT_TIME_LIMIT || ((time <= endTime) && (diff <= limit))) {
								formatTime(endTime, sb);
								break;
							}
						}
					} else {
						int diff = -1;
						if (time <= endTime && days[d] && !checkAnotherDay) {
							diff = 24 * 60 - time + endTime;
						} else if (time < endTime && days[ad] && checkAnotherDay) {
							diff = startTime - time;
						}
						if (limit == WITHOUT_TIME_LIMIT || ((diff != -1) && (diff <= limit))) {
							formatTime(endTime, sb);
							break;
						}
					}
				}
			}
			return sb.toString();
		}

		@Override
		public String toString() {
			return toRuleString();
		}

		public void appendDaysString(StringBuilder builder) {
			appendDaysString(builder, daysStr);
		}

		public void appendDaysString(StringBuilder builder, String[] daysNames) {
			boolean dash = false;
			boolean first = true;
			for (int i = 0; i < 7; i++) {
				if (days[i]) {
					if (i > 0 && days[i - 1] && i < 6 && days[i + 1]) {
						if (!dash) {
							dash = true;
							builder.append("-"); //$NON-NLS-1$
						}
						continue;
					}
					if (first) {
						first = false;
					} else if (!dash) {
						builder.append(", "); //$NON-NLS-1$
					}
					builder.append(daysNames[getDayIndex(i)]);
					dash = false;
				}
			}
			if (publicHoliday) {
				if (!first) {
					builder.append(", ");
				}
				builder.append("PH");
				first = false;
			}
			if (schoolHoliday) {
				if (!first) {
					builder.append(", ");
				}
				builder.append("SH");
				first = false;
			}
			if (easter) {
				if (!first) {
					builder.append(", ");
				}
				builder.append("Easter");
				first = false;
			}
			if(!first) {
				builder.append(" ");
			}
		}

		/**
		 * Add a time range (startTime-endTime) to this rule
		 *
		 * @param startTime startTime to add
		 * @param endTime   endTime to add
		 */
		public void addTimeRange(int startTime, int endTime) {
			startTimes.add(startTime);
			endTimes.add(endTime);
		}

		public int timesSize() {
			return startTimes.size();
		}

		public void deleteTimeRange(int position) {
			startTimes.removeAt(position);
			endTimes.removeAt(position);
		}

		private static void setSingleValueForArrayList(TIntArrayList arrayList, int s) {
			if (arrayList.size() > 0) {
				arrayList.remove(0, arrayList.size());
			}
			arrayList.add(s);
		}

		@Override
		public boolean isOpenedForTime(Calendar cal) {
			int c = calculate(cal);
			return c > 0;
		}

		@Override
		public boolean contains(Calendar cal) {
			int c = calculate(cal);
			return c != 0;
		}
		
		@Override
		public boolean hasOverlapTimes() {
			for (int i = 0; i < startTimes.size(); i++) {
				int startTime = this.startTimes.get(i);
				int endTime = this.endTimes.get(i);
				if (startTime >= endTime && endTime != -1) {
					return true;
				}
			}
			return false;
		}

		private int calculate(Calendar cal) {
			int month = cal.get(Calendar.MONTH);
			if (!months[month]) {
				return 0;
			}
			int dmonth = cal.get(Calendar.DAY_OF_MONTH) - 1;
			int i = cal.get(Calendar.DAY_OF_WEEK);
			int day = (i + 5) % 7;
			int previous = (day + 6) % 7;
			boolean thisDay = days[day] || dayMonths[dmonth];
			// potential error for Dec 31 12:00-01:00
			boolean previousDay = days[previous] || (dmonth > 0 && dayMonths[dmonth - 1]);
			if (!thisDay && !previousDay) {
				return 0;
			}
			int time = cal.get(Calendar.HOUR_OF_DAY) * 60 + cal.get(Calendar.MINUTE); // Time in minutes
			for (i = 0; i < startTimes.size(); i++) {
				int startTime = this.startTimes.get(i);
				int endTime = this.endTimes.get(i);
				if (startTime < endTime || endTime == -1) {
					// one day working like 10:00-20:00 (not 20:00-04:00)
					if (time >= startTime && (endTime == -1 || time <= endTime) && thisDay) {
						return off ? -1 : 1;
					}
				} else {
					// opening_hours includes day wrap like
					// "We 20:00-03:00" or "We 07:00-07:00"
					if (time >= startTime && thisDay) {
						return off ? -1 : 1;
					} else if (time < endTime && previousDay) {
						return off ? -1 : 1;
					}
				}
			}
			if (thisDay && (startTimes == null || startTimes.isEmpty() || !off)) {
				return -1;
			}
			return 0;
		}
	}

	public static class UnparseableRule implements OpeningHoursParser.OpeningHoursRule {
		private String ruleString;

		public UnparseableRule(String ruleString) {
			this.ruleString = ruleString;
		}

		@Override
		public boolean isOpenedForTime(Calendar cal, boolean checkPrevious) {
			return false;
		}

		@Override
		public boolean containsPreviousDay(Calendar cal) {
			return false;
		}
		
		@Override
		public boolean hasOverlapTimes() {
			return false;
		}

		@Override
		public boolean containsDay(Calendar cal) {
			return false;
		}

		@Override
		public boolean containsNextDay(Calendar cal) {
			return false;
		}

		@Override
		public boolean containsMonth(Calendar cal) {
			return false;
		}

		@Override
		public String toRuleString() {
			return ruleString;
		}

		@Override
		public String toLocalRuleString() {
			return toRuleString();
		}

		@Override
		public boolean isOpened24_7() {
			return false;
		}

		@Override
		public String getTime(Calendar cal, boolean checkAnotherDay, int limit, boolean opening) {
			return "";
		}

		@Override
		public String toString() {
			return toRuleString();
		}

		@Override
		public boolean isOpenedForTime(Calendar cal) {
			return false;
		}

		@Override
		public boolean contains(Calendar cal) {
			return false;
		}
	}
	
	private enum TokenType { 
		TOKEN_UNKNOWN(0),
		TOKEN_COLON(1),
		TOKEN_COMMA(2),
		TOKEN_DASH(3),
		// order is important
		TOKEN_MONTH(4),
		TOKEN_DAY_MONTH(5),
		TOKEN_HOLIDAY(6),
		TOKEN_DAY_WEEK(6),
		TOKEN_HOUR_MINUTES (7),
		TOKEN_OFF_ON(8);
		public final int ord;

		private TokenType(int ord) {
			this.ord = ord;
		}

		public int ord() {
			return ord;
		}

	}
	
	private static class Token {
		public Token(TokenType tokenType, String string) {
			type = tokenType;
			text = string;
			try {
				mainNumber = Integer.parseInt(string);
			} catch(NumberFormatException e){
			}
		}
		int mainNumber = -1;
		TokenType type;
		String text;
		
		@Override
		public String toString() {
			return text + " [" + type + "] ";
		}
	}

	public static OpeningHoursParser.OpeningHoursRule parseRuleV2(String r) {
		r = r.toLowerCase();
		
		final String[] daysStr = new String[]{"mo", "tu", "we", "th", "fr", "sa", "su"};
		final String[] monthsStr = new String[]{"jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec"};
		final String[] holidayStr = new String[]{"ph", "sh", "easter"};
		String sunrise = "07:00";
		String sunset = "21:00";
		String endOfDay = "24:00";
		r = r.replace('(', ' '); // avoid "(mo-su 17:00-20:00"
		r = r.replace(')', ' ');
		String localRuleString = r.replaceAll("sunset", sunset).replaceAll("sunrise", sunrise)
				.replaceAll("\\+", "-" + endOfDay);
		BasicOpeningHourRule basic = new BasicOpeningHourRule();
		boolean[] days = basic.getDays();
		boolean[] months = basic.getMonths();
		boolean[] dayMonths = basic.getDayMonths();
		if ("24/7".equals(localRuleString)) {
			Arrays.fill(days, true);
			Arrays.fill(months, true);
			basic.addTimeRange(0, 24 * 60);
			return basic;
		}
		List<Token> tokens = new ArrayList<>();
		int startWord = 0;
		for(int i = 0; i <= localRuleString.length(); i++) {
			char ch = i == localRuleString.length() ? ' ' : localRuleString.charAt(i);
			boolean delimiter = false;
			Token del = null;
			if(Character.isWhitespace(ch)) {
				delimiter = true;
			} else if(ch == ':') {
				del = new Token(TokenType.TOKEN_COLON, ":");
			} else if(ch == '-') {
				del = new Token(TokenType.TOKEN_DASH, "-");
			} else if(ch == ',') {
				del = new Token(TokenType.TOKEN_COMMA, ",");
			}
			if(delimiter || del != null) {
				String wrd = localRuleString.substring(startWord, i).trim();
				if(wrd.length() > 0) {
					tokens.add(new Token(TokenType.TOKEN_UNKNOWN, wrd));
				}
				startWord = i + 1;
				if(del != null) {
					tokens.add(del);
				}
			}
		}
		// recognize day of week
		for(Token t : tokens) {
			if(t.type == TokenType.TOKEN_UNKNOWN) {
				findInArray(t, daysStr, TokenType.TOKEN_DAY_WEEK);
			}
			if(t.type == TokenType.TOKEN_UNKNOWN) {
				findInArray(t, monthsStr, TokenType.TOKEN_MONTH);
			}
			if(t.type == TokenType.TOKEN_UNKNOWN) {
				findInArray(t, holidayStr, TokenType.TOKEN_HOLIDAY);
			}
			if(t.type == TokenType.TOKEN_UNKNOWN && ("off".equals(t.text) || "closed".equals(t.text))) {
				t.type = TokenType.TOKEN_OFF_ON;
				t.mainNumber = 0;
			}
			if(t.type == TokenType.TOKEN_UNKNOWN && ("24/7".equals(t.text) || "open".equals(t.text))) {
				t.type = TokenType.TOKEN_OFF_ON;
				t.mainNumber = 1;
			}
		}
		// recognize hours minutes ( Dec 25: 08:30-20:00)
		for(int i = tokens.size() - 1; i >= 0; i --) {
			if(tokens.get(i).type == TokenType.TOKEN_COLON) {
				if(i > 0 && i < tokens.size() - 1) {
					if(tokens.get(i - 1).type == TokenType.TOKEN_UNKNOWN && tokens.get(i - 1).mainNumber != -1 && 
							tokens.get(i + 1).type == TokenType.TOKEN_UNKNOWN && tokens.get(i + 1).mainNumber != -1 ) {
						tokens.get(i).mainNumber = 60 * tokens.get(i - 1).mainNumber + tokens.get(i + 1).mainNumber;
						tokens.get(i).type = TokenType.TOKEN_HOUR_MINUTES;
						tokens.remove(i + 1);
						tokens.remove(i - 1);
					}
				}
				
			}
		}
		// recognize other numbers
		// if there is no on/off and minutes/hours
		boolean hoursSpecified = false;
		for(int i = 0; i < tokens.size(); i ++) {
			if(tokens.get(i).type == TokenType.TOKEN_HOUR_MINUTES || 
					tokens.get(i).type == TokenType.TOKEN_OFF_ON) {
				hoursSpecified = true;
				break;
			}
		}
		for(int i = 0; i < tokens.size(); i ++) {
			if(tokens.get(i).type == TokenType.TOKEN_UNKNOWN && tokens.get(i).mainNumber >= 0) {
				tokens.get(i).type = hoursSpecified ? TokenType.TOKEN_DAY_MONTH : TokenType.TOKEN_HOUR_MINUTES;
				if(tokens.get(i).type == TokenType.TOKEN_HOUR_MINUTES) {
					tokens.get(i).mainNumber = tokens.get(i).mainNumber * 60;
				} else {
					tokens.get(i).mainNumber = tokens.get(i).mainNumber - 1;
				}
			}
		}
		// order MONTH MONTH_DAY DAY_WEEK HOUR_MINUTE OPEN_OFF
		TokenType currentParse = TokenType.TOKEN_UNKNOWN;
		List<Token[]> listOfPairs = new ArrayList<>();
		Set<TokenType> presentTokens = new HashSet<>();
		Token[] currentPair = new Token[2];
		listOfPairs.add(currentPair);
		int indexP = 0;
		for(int i = 0; i <= tokens.size(); i++) {
			Token t = i == tokens.size() ? null : tokens.get(i);
			if (t == null || t.type.ord() > currentParse.ord()) {
				presentTokens.add(currentParse);
				// case tokens.get(i).type.ordinal() < currentParse.ordinal() - not supported (Fr 15:00-18:00, Sa 16-18)
				if (currentParse == TokenType.TOKEN_MONTH || currentParse == TokenType.TOKEN_DAY_MONTH
						|| currentParse == TokenType.TOKEN_DAY_WEEK || currentParse == TokenType.TOKEN_HOLIDAY) {
					
					boolean[] array = (currentParse == TokenType.TOKEN_MONTH) ? basic.getMonths()
							: (currentParse == TokenType.TOKEN_DAY_MONTH) ? basic.getDayMonths() : basic.getDays();
					for (Token[] pair : listOfPairs) {
						if (pair[0] != null && pair[1] != null) {
							if (pair[0].mainNumber <= pair[1].mainNumber) {
								for (int j = pair[0].mainNumber; j <= pair[1].mainNumber && j < array.length; j++) {
									array[j] = true;
								}
							} else {
								// overflow
								for (int j = pair[0].mainNumber; j < array.length; j++) {
									array[j] = true;
								}
								for (int j = 0; j <= pair[1].mainNumber; j++) {
									array[j] = true;
								}
							}
						} else if (pair[0] != null) {
							if(pair[0].type == TokenType.TOKEN_HOLIDAY) {
								if(pair[0].mainNumber == 0) {
									basic.publicHoliday = true;
								} else if(pair[0].mainNumber == 1) {
									basic.schoolHoliday = true;
								} else if(pair[0].mainNumber == 2) {
									basic.easter = true;
								}
							} else if(pair[0].mainNumber >= 0){
								array[pair[0].mainNumber] = true;
							}
						}
					}
				} else if (currentParse == TokenType.TOKEN_HOUR_MINUTES) {
					for (Token[] pair : listOfPairs) {
						if(pair[0] != null && pair[1] != null) {
							basic.addTimeRange(pair[0].mainNumber, pair[1].mainNumber);
						}
					}
				} else if (currentParse == TokenType.TOKEN_OFF_ON) {
					Token[] l = listOfPairs.get(0);
					if(l[0] != null && l[0].mainNumber == 0) {
						basic.off = true;
					}
				}
				listOfPairs.clear();
				currentPair = new Token[2];
				indexP = 0;
				listOfPairs.add(currentPair);
				currentPair[indexP++] = t;
				if(t != null) {
					currentParse = t.type;
				}
			} else if(t.type == TokenType.TOKEN_COMMA) {
				currentPair = new Token[2];
				indexP = 0;
				listOfPairs.add(currentPair);
			} else if(t.type == TokenType.TOKEN_DASH) {
				
			} else if(t.type.ord() == currentParse.ord()) {
				if(indexP < 2) {
					currentPair[indexP++] = t;
				}
			}
		}
		if(!presentTokens.contains(TokenType.TOKEN_MONTH)) {
			Arrays.fill(basic.getMonths(), true);
		}
//		if(!presentTokens.contains(TokenType.TOKEN_DAY_MONTH)) {
//			Arrays.fill(basic.getDayMonths(), true);
//		}
		if(!presentTokens.contains(TokenType.TOKEN_DAY_WEEK) && !presentTokens.contains(TokenType.TOKEN_HOLIDAY) && 
				!presentTokens.contains(TokenType.TOKEN_DAY_MONTH)) {
			Arrays.fill(basic.getDays(), true);
		}
//		if(!presentTokens.contains(TokenType.TOKEN_HOUR_MINUTES)) {
//			basic.addTimeRange(0, 24 * 60);
//		}
//		System.out.println(r + " " +  tokens);
		return basic;
	}

	private static void findInArray(Token t, String[] list, TokenType tokenType) {
		for(int i = 0; i < list.length; i++) {
			if(list[i].equals(t.text)) {
				t.type = tokenType;
				t.mainNumber = i;
				break;
			}
		}
	}

	/**
	 * Parse an opening_hours string from OSM to an OpeningHours object which can be used to check
	 *
	 * @param r the string to parse
	 * @return BasicRule if the String is successfully parsed and UnparseableRule otherwise
	 */
	public static OpeningHoursParser.OpeningHoursRule parseRule(String r) {
		return parseRuleV2(r);
	}

	/**
	 * parse OSM opening_hours string to an OpeningHours object
	 *
	 * @param format the string to parse
	 * @return null when parsing was unsuccessful
	 */
	public static OpeningHours parseOpenedHours(String format) {
		if (format == null) {
			return null;
		}
		// split the OSM string in multiple rules
		String[] rules = format.split(";"); //$NON-NLS-1$
		// FIXME: What if the semicolon is inside a quoted string?
		OpeningHours rs = new OpeningHours();
		rs.setOriginal(format);
		for (String r : rules) {
			r = r.trim();
			if (r.length() == 0) {
				continue;
			}
			// check if valid
			final OpeningHoursRule r1 = parseRule(r);
			boolean rule = r1 instanceof BasicOpeningHourRule;
			if (rule) {
				rs.addRule(r1);
			}
		}
		return rs;
	}

	/**
	 * parse OSM opening_hours string to an OpeningHours object.
	 * Does not return null when parsing unsuccessful. When parsing rule is unsuccessful,
	 * such rule is stored as UnparseableRule.
	 *
	 * @param format the string to parse
	 * @return the OpeningHours object
	 */
	public static OpeningHoursParser.OpeningHours parseOpenedHoursHandleErrors(String format) {
		if (format == null) {
			return null;
		}
		String[] rules = format.split(";"); //$NON-NLS-1$
		OpeningHoursParser.OpeningHours rs = new OpeningHoursParser.OpeningHours();
		rs.setOriginal(format);
		for (String r : rules) {
			r = r.trim();
			if (r.length() == 0) {
				continue;
			}
			// check if valid
			rs.addRule(OpeningHoursParser.parseRule(r));
		}
		return rs;
	}

	private static void formatTime(int h, int t, StringBuilder b) {
		if (h < 10) {
			b.append("0"); //$NON-NLS-1$
		}
		b.append(h).append(":"); //$NON-NLS-1$
		if (t < 10) {
			b.append("0"); //$NON-NLS-1$
		}
		b.append(t);
	}

	private static void formatTime(int minutes, StringBuilder sb) {
		int hour = minutes / 60;
		int time = minutes - hour * 60;
		formatTime(hour, time, sb);
	}

	/**
	 * test if the calculated opening hours are what you expect
	 *
	 * @param time     the time to test in the format "dd.MM.yyyy HH:mm"
	 * @param hours    the OpeningHours object
	 * @param expected the expected state
	 */
	private static void testOpened(String time, OpeningHours hours, boolean expected) throws ParseException {
		Calendar cal = Calendar.getInstance();
		cal.setTime(new SimpleDateFormat("dd.MM.yyyy HH:mm", Locale.US).parse(time));
		boolean calculated = hours.isOpenedForTimeV2(cal);
		System.out.printf("  %sok: Expected %s: %b = %b (rule %s)\n",
				((calculated != expected) ? "NOT " : ""), time, expected, calculated, hours.getCurrentRuleTime(cal));
		if (calculated != expected) {
			throw new IllegalArgumentException("BUG!!!");
		}
	}

	private static void testParsedAndAssembledCorrectly(String timeString, OpeningHours hours) {
		String assembledString = hours.toString();
		boolean isCorrect = assembledString.equalsIgnoreCase(timeString);
		System.out.printf("  %sok: Expected: \"%s\" got: \"%s\"\n",
				(!isCorrect ? "NOT " : ""), timeString, assembledString);
		if (!isCorrect) {
			throw new IllegalArgumentException("BUG!!!");
		}
	}

	public static void main(String[] args) throws ParseException {
		// 0. not supported MON DAY-MON DAY (only supported Feb 2-14 or Feb-Oct: 09:00-17:30)
		// parseOpenedHours("Feb 16-Oct 15: 09:00-18:30; Oct 16-Nov 15: 09:00-17:30; Nov 16-Feb 15: 09:00-16:30");
		
		// 1. not supported (,)
		// hours = parseOpenedHours("Mo-Su 07:00-23:00, Fr 08:00-20:00");
		
		// 2. not supported break properly
		// parseOpenedHours("Sa-Su 10:00-17:00 || \"by appointment\"");
		// comment is dropped
		
		// 3. not properly supported
		// hours = parseOpenedHours("Mo-Su (sunrise-00:30)-(sunset+00:30)");
		
		// Test basic case
		OpeningHours hours = parseOpenedHours("Mo-Fr 08:30-14:40"); //$NON-NLS-1$
		testOpened("09.08.2012 11:00", hours, true);
		testOpened("09.08.2012 16:00", hours, false);
		hours = parseOpenedHours("mo-fr 07:00-19:00; sa 12:00-18:00");
		System.out.println(hours);

		String string = "Mo-Fr 11:30-15:00, 17:30-23:00; Sa, Su, PH 11:30-23:00";
		hours = parseOpenedHours(string);
		testParsedAndAssembledCorrectly(string, hours);
		System.out.println(hours);
		testOpened("7.09.2015 14:54", hours, true); // monday
		testOpened("7.09.2015 15:05", hours, false);
		testOpened("6.09.2015 16:05", hours, true);


		// two time and date ranges
		hours = parseOpenedHours("Mo-We, Fr 08:30-14:40,15:00-19:00"); //$NON-NLS-1$
		System.out.println(hours);
		testOpened("08.08.2012 14:00", hours, true);
		testOpened("08.08.2012 14:50", hours, false);
		testOpened("10.08.2012 15:00", hours, true);

		// test exception on general schema
		hours = parseOpenedHours("Mo-Sa 08:30-14:40; Tu 08:00 - 14:00"); //$NON-NLS-1$
		System.out.println(hours);
		testOpened("07.08.2012 14:20", hours, false);
		testOpened("07.08.2012 08:15", hours, true); // Tuesday

		// test off value
		hours = parseOpenedHours("Mo-Sa 09:00-18:25; Th off"); //$NON-NLS-1$
		System.out.println(hours);
		testOpened("08.08.2012 12:00", hours, true);
		testOpened("09.08.2012 12:00", hours, false);

		// test 24/7
		hours = parseOpenedHours("24/7"); //$NON-NLS-1$
		System.out.println(hours);
		testOpened("08.08.2012 23:59", hours, true);
		testOpened("08.08.2012 12:23", hours, true);
		testOpened("08.08.2012 06:23", hours, true);

		// some people seem to use the following syntax:
		hours = parseOpenedHours("Sa-Su 24/7");
		System.out.println(hours);
		hours = parseOpenedHours("Mo-Fr 9-19");
		System.out.println(hours);
		hours = parseOpenedHours("09:00-17:00");
		System.out.println(hours);
		hours = parseOpenedHours("sunrise-sunset");
		System.out.println(hours);
		hours = parseOpenedHours("10:00+");
		System.out.println(hours);
		hours = parseOpenedHours("Su-Th sunset-24:00, 04:00-sunrise; Fr-Sa sunset-sunrise");
		System.out.println(hours);
		testOpened("12.08.2012 04:00", hours, true);
		testOpened("12.08.2012 23:00", hours, true);
		testOpened("08.08.2012 12:00", hours, false);
		testOpened("08.08.2012 05:00", hours, true);

		// test simple day wrap
		hours = parseOpenedHours("Mo 20:00-02:00");
		System.out.println(hours);
		testOpened("05.05.2013 10:30", hours, false);
		testOpened("05.05.2013 23:59", hours, false);
		testOpened("06.05.2013 10:30", hours, false);
		testOpened("06.05.2013 20:30", hours, true);
		testOpened("06.05.2013 23:59", hours, true);
		testOpened("07.05.2013 00:00", hours, true);
		testOpened("07.05.2013 00:30", hours, true);
		testOpened("07.05.2013 01:59", hours, true);
		testOpened("07.05.2013 20:30", hours, false);

		// test maximum day wrap
		hours = parseOpenedHours("Su 10:00-10:00");
		System.out.println(hours);
		testOpened("05.05.2013 09:59", hours, false);
		testOpened("05.05.2013 10:00", hours, true);
		testOpened("05.05.2013 23:59", hours, true);
		testOpened("06.05.2013 00:00", hours, true);
		testOpened("06.05.2013 09:59", hours, true);
		testOpened("06.05.2013 10:00", hours, false);

		// test day wrap as seen on OSM
		hours = parseOpenedHours("Tu-Th 07:00-2:00; Fr 17:00-4:00; Sa 18:00-05:00; Su,Mo off");
		System.out.println(hours);
		testOpened("05.05.2013 04:59", hours, true); // sunday 05.05.2013
		testOpened("05.05.2013 05:00", hours, false);
		testOpened("05.05.2013 12:30", hours, false);
		testOpened("06.05.2013 10:30", hours, false);
		testOpened("07.05.2013 01:00", hours, false);
		testOpened("07.05.2013 20:25", hours, true);
		testOpened("07.05.2013 23:59", hours, true);
		testOpened("08.05.2013 00:00", hours, true);
		testOpened("08.05.2013 02:00", hours, false);

		// test day wrap as seen on OSM
		hours = parseOpenedHours("Mo-Th 09:00-03:00; Fr-Sa 09:00-04:00; Su off");
		testOpened("11.05.2015 08:59", hours, false);
		testOpened("11.05.2015 09:01", hours, true);
		testOpened("12.05.2015 02:59", hours, true);
		testOpened("12.05.2015 03:00", hours, false);
		testOpened("16.05.2015 03:59", hours, true);
		testOpened("16.05.2015 04:01", hours, false);
		testOpened("17.05.2015 01:00", hours, true);
		testOpened("17.05.2015 04:01", hours, false);

		hours = parseOpenedHours("Tu-Th 07:00-2:00; Fr 17:00-4:00; Sa 18:00-05:00; Su,Mo off");
		testOpened("11.05.2015 08:59", hours, false);
		testOpened("11.05.2015 09:01", hours, false);
		testOpened("12.05.2015 01:59", hours, false);
		testOpened("12.05.2015 02:59", hours, false);
		testOpened("12.05.2015 03:00", hours, false);
		testOpened("13.05.2015 01:59", hours, true);
		testOpened("13.05.2015 02:59", hours, false);
		testOpened("16.05.2015 03:59", hours, true);
		testOpened("16.05.2015 04:01", hours, false);
		testOpened("17.05.2015 01:00", hours, true);
		testOpened("17.05.2015 05:01", hours, false);

		// tests single month value
		hours = parseOpenedHours("May: 07:00-19:00");
		System.out.println(hours);
		testOpened("05.05.2013 12:00", hours, true);
		testOpened("05.05.2013 05:00", hours, false);
		testOpened("05.05.2013 21:00", hours, false);
		testOpened("05.01.2013 12:00", hours, false);
		testOpened("05.01.2013 05:00", hours, false);

		// tests multi month value
		hours = parseOpenedHours("Apr-Sep 8:00-22:00; Oct-Mar 10:00-18:00");
		System.out.println(hours);
		testOpened("05.03.2013 15:00", hours, true);
		testOpened("05.03.2013 20:00", hours, false);

		testOpened("05.05.2013 20:00", hours, true);
		testOpened("05.05.2013 23:00", hours, false);

		testOpened("05.10.2013 15:00", hours, true);
		testOpened("05.10.2013 20:00", hours, false);

		// Test time with breaks
		hours = parseOpenedHours("Mo-Fr: 9:00-13:00, 14:00-18:00");
		System.out.println(hours);
		testOpened("02.12.2015 12:00", hours, true);
		testOpened("02.12.2015 13:30", hours, false);
		testOpened("02.12.2015 16:00", hours, true);

		testOpened("05.12.2015 16:00", hours, false);
		
		hours = parseOpenedHours("Mo-Su 07:00-23:00; Dec 25 08:00-20:00");
		System.out.println(hours);
		testOpened("25.12.2015 07:00", hours, false);
		testOpened("24.12.2015 07:00", hours, true);
		testOpened("24.12.2015 22:00", hours, true);
		testOpened("25.12.2015 08:00", hours, true);
		testOpened("25.12.2015 22:00", hours, false);
		
		hours = parseOpenedHours("Mo-Su 07:00-23:00; Dec 25 off");
		System.out.println(hours);
		testOpened("25.12.2015 14:00", hours, false);
		testOpened("24.12.2015 08:00", hours, true);
		
		// easter itself as public holiday is not supported
		hours = parseOpenedHours("Mo-Su 07:00-23:00; Easter off; Dec 25 off");
		System.out.println(hours);
		testOpened("25.12.2015 14:00", hours, false);
		testOpened("24.12.2015 08:00", hours, true);

		// test time off (not days
		hours = parseOpenedHours("Mo-Fr 08:30-17:00; 12:00-12:40 off;");
		System.out.println(hours);
		testOpened("07.05.2017 14:00", hours, false); // Sunday
		testOpened("06.05.2017 12:15", hours, false); // Saturday
		testOpened("05.05.2017 14:00", hours, true); // Friday
		testOpened("05.05.2017 12:15", hours, false);
		testOpened("05.05.2017 12:00", hours, false);
		testOpened("05.05.2017 11:45", hours, true);
		
		// Test holidays
		String hoursString = "mo-fr 11:00-21:00; PH off";
		hours = parseOpenedHoursHandleErrors(hoursString);
		testParsedAndAssembledCorrectly(hoursString, hours);
		

		
	}
}
!@#$%
20190530_064301,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_c11712
package net.osmand.util;
/* Can be commented out in order to run the main function separately */

import java.io.Serializable;
import java.text.DateFormatSymbols;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Set;

import gnu.trove.list.array.TIntArrayList;

/**
 * Class used to parse opening hours
 * <p/>
 * the method "parseOpenedHours" will parse an OSM opening_hours string and
 * return an object of the type OpeningHours. That object can be used to check
 * if the OSM feature is open at a certain time.
 */
public class OpeningHoursParser {
	private static final String[] daysStr;
	private static final String[] localDaysStr;
	private static final String[] monthsStr;
	private static final String[] localMothsStr;

	private static final int LOW_TIME_LIMIT = 120;
	private static final int HIGH_TIME_LIMIT = 300;
	private static final int WITHOUT_TIME_LIMIT = -1;

	static {
		DateFormatSymbols dateFormatSymbols = DateFormatSymbols.getInstance(Locale.US);
		monthsStr = dateFormatSymbols.getShortMonths();
		daysStr = getTwoLettersStringArray(dateFormatSymbols.getShortWeekdays());
		dateFormatSymbols = DateFormatSymbols.getInstance();
		localMothsStr = dateFormatSymbols.getShortMonths();
		localDaysStr = getTwoLettersStringArray(dateFormatSymbols.getShortWeekdays());
	}

	/**
	 * Default values for sunrise and sunset. Might be computed afterwards, not final.
	 */
	private static String sunrise = "07:00", sunset = "21:00";

	/**
	 * Hour of when you would expect a day to be ended.
	 * This is to be used when no end hour is known (like pubs that open at a certain time,
	 * but close at a variable time, depending on the number of clients).
	 * OsmAnd needs to show a value, so there is some arbitrary default value chosen.
	 */
	private static String endOfDay = "24:00";

	private static String[] getTwoLettersStringArray(String[] strings) {
		String[] newStrings = new String[strings.length];
		for (int i = 0; i < strings.length; i++) {
			if (strings[i] != null) {
				if (strings[i].length() > 2) {
					newStrings[i] = Algorithms.capitalizeFirstLetter(strings[i].substring(0, 2));
				} else {
					newStrings[i] = Algorithms.capitalizeFirstLetter(strings[i]);
				}
			}
		}
		return newStrings;
	}

	private static int getDayIndex(int i) {
		switch (i) {
			case 0: return Calendar.MONDAY;
			case 1: return Calendar.TUESDAY;
			case 2: return Calendar.WEDNESDAY;
			case 3: return Calendar.THURSDAY;
			case 4: return Calendar.FRIDAY;
			case 5: return Calendar.SATURDAY;
			case 6: return Calendar.SUNDAY;
			default: return -1;
		}
	}

	/**
	 * This class contains the entire OpeningHours schema and
	 * offers methods to check directly weather something is open
	 *
	 * @author sander
	 */
	public static class OpeningHours implements Serializable {

		/**
		 * list of the different rules
		 */
		private ArrayList<OpeningHoursRule> rules;
		private String original;

		/**
		 * Constructor
		 *
		 * @param rules List of OpeningHoursRule to be given
		 */
		public OpeningHours(ArrayList<OpeningHoursRule> rules) {
			this.rules = rules;
		}

		/**
		 * Empty constructor
		 */
		public OpeningHours() {
			rules = new ArrayList<OpeningHoursRule>();
		}

		/**
		 * add a rule to the opening hours
		 *
		 * @param r rule to add
		 */
		public void addRule(OpeningHoursRule r) {
			rules.add(r);
		}

		/**
		 * return the list of rules
		 *
		 * @return the rules
		 */
		public ArrayList<OpeningHoursRule> getRules() {
			return rules;
		}
		
		/**
		 * check if the feature is opened at time "cal"
		 *
		 * @param cal the time to check
		 * @return true if feature is open
		 */
		public boolean isOpenedForTimeV2(Calendar cal) {
			// make exception for overlapping times i.e.
			// (1) Mo 14:00-16:00; Tu off
			// (2) Mo 14:00-02:00; Tu off
			// in (2) we need to check first rule even though it is against specification
			boolean overlap = false;
			for(int i = rules.size() - 1; i >= 0 ; i--) {
				OpeningHoursRule r = rules.get(i);
				if(r.hasOverlapTimes()) {
					overlap = true;
					break;
				}
			}
			// start from the most specific rule
			for(int i = rules.size() - 1; i >= 0 ; i--) {
				OpeningHoursRule r = rules.get(i);
				if(r.contains(cal)) {
					boolean open = r.isOpenedForTime(cal);
					if(!open && overlap ) {
						continue;
					} else {
						return open;
					}
				}
			}
			return false;
		}

		/**
		 * check if the feature is opened at time "cal"
		 *
		 * @param cal the time to check
		 * @return true if feature is open
		 */
		public boolean isOpenedForTime(Calendar cal) {
			/*
			 * first check for rules that contain the current day
			 * afterwards check for rules that contain the previous
			 * day with overlapping times (times after midnight)
			 */
			boolean isOpenDay = false;
			for (OpeningHoursRule r : rules) {
				if (r.containsDay(cal) && r.containsMonth(cal)) {
					isOpenDay = r.isOpenedForTime(cal, false);
				}
			}
			boolean isOpenPrevious = false;
			for (OpeningHoursRule r : rules) {
				if (r.containsPreviousDay(cal) && r.containsMonth(cal)) {
					isOpenPrevious = r.isOpenedForTime(cal, true);
				}
			}
			return isOpenDay || isOpenPrevious;
		}

		public boolean isOpened24_7() {
			boolean opened24_7 = false;
			for (OpeningHoursRule r : rules) {
				opened24_7 = r.isOpened24_7();
			}
			return opened24_7;
		}

		public String getNearToOpeningTime(Calendar cal) {
			return getTime(cal, LOW_TIME_LIMIT, true);
		}

		public String getOpeningTime(Calendar cal) {
			return getTime(cal, HIGH_TIME_LIMIT, true);
		}

		public String getNearToClosingTime(Calendar cal) {
			return getTime(cal, LOW_TIME_LIMIT, false);
		}

		public String getClosingTime(Calendar cal) {
			return getTime(cal, WITHOUT_TIME_LIMIT, false);
		}

		public String getOpeningDay(Calendar calendar) {
			Calendar cal = (Calendar) calendar.clone();
			String openingTime = "";
			for (int i = 0; i < 7; i++) {
				cal.add(Calendar.DAY_OF_MONTH, 1);
				for (OpeningHoursRule r : rules) {
					if (r.containsDay(cal) && r.containsMonth(cal)) {
						openingTime = r.getTime(cal, false, WITHOUT_TIME_LIMIT, true);
					}
				}
				if (!Algorithms.isEmpty(openingTime)) {
					openingTime += " " + localDaysStr[cal.get(Calendar.DAY_OF_WEEK)];
					break;
				}
			}
			return openingTime;
		}

		private String getTime(Calendar cal, int limit, boolean opening) {
			String time = getTimeDay(cal, limit, opening);
			if (Algorithms.isEmpty(time)) {
				time = getTimeAnotherDay(cal, limit, opening);
			}
			return time;
		}

		private String getTimeDay(Calendar cal, int limit, boolean opening) {
			String atTime = "";
			for (OpeningHoursRule r : rules) {
				if (r.containsDay(cal) && r.containsMonth(cal)) {
					atTime = r.getTime(cal, false, limit, opening);
				}
			}
			return atTime;
		}

		private String getTimeAnotherDay(Calendar cal, int limit, boolean opening) {
			String atTime = "";
			for (OpeningHoursRule r : rules) {
				if (((opening && r.containsPreviousDay(cal)) || (!opening && r.containsNextDay(cal))) && r.containsMonth(cal)) {
					atTime = r.getTime(cal, true, limit, opening);
				}
			}
			return atTime;
		}

		public String getCurrentRuleTime(Calendar cal) {
			// make exception for overlapping times i.e.
			// (1) Mo 14:00-16:00; Tu off
			// (2) Mo 14:00-02:00; Tu off
			// in (2) we need to check first rule even though it is against specification
			String ruleClosed = null;
			boolean overlap = false;
			for (int i = rules.size() - 1; i >= 0; i--) {
				OpeningHoursRule r = rules.get(i);
				if (r.hasOverlapTimes()) {
					overlap = true;
					break;
				}
			}
			// start from the most specific rule
			for (int i = rules.size() - 1; i >= 0; i--) {
				OpeningHoursRule r = rules.get(i);
				if (r.contains(cal)) {
					boolean open = r.isOpenedForTime(cal);
					if (!open && overlap) {
						ruleClosed = r.toLocalRuleString();
					} else {
						return r.toLocalRuleString();
					}
				}
			}
			return ruleClosed;
		}
		
		public String getCurrentRuleTimeV1(Calendar cal) {
			String ruleOpen = null;
			String ruleClosed = null;
			for (OpeningHoursRule r : rules) {
				if (r.containsPreviousDay(cal) && r.containsMonth(cal)) {
					if (r.isOpenedForTime(cal, true)) {
						ruleOpen = r.toLocalRuleString();
					} else {
						ruleClosed = r.toLocalRuleString();
					}
				}
			}
			for (OpeningHoursRule r : rules) {
				if (r.containsDay(cal) && r.containsMonth(cal)) {
					if (r.isOpenedForTime(cal, false)) {
						ruleOpen = r.toLocalRuleString();
					} else {
						ruleClosed = r.toLocalRuleString();
					}
				}
			}

			if (ruleOpen != null) {
				return ruleOpen;
			}
			return ruleClosed;
		}

		@Override
		public String toString() {
			StringBuilder s = new StringBuilder();
			if (rules.isEmpty()) {
				return "";
			}
			for (OpeningHoursRule r : rules) {
				s.append(r.toString()).append("; ");
			}
			return s.substring(0, s.length() - 2);
		}

		public String toLocalString() {
			StringBuilder s = new StringBuilder();
			if (rules.isEmpty()) {
				return "";
			}

			for (OpeningHoursRule r : rules) {
				s.append(r.toLocalRuleString()).append("; ");
			}

			return s.substring(0, s.length() - 2);
		}

		public void setOriginal(String original) {
			this.original = original;
		}
		
		public String getOriginal() {
			return original;
		}
	}

	/**
	 * Interface to represent a single rule
	 * <p/>
	 * A rule consist out of
	 * - a collection of days/dates
	 * - a time range
	 */
	public static interface OpeningHoursRule extends Serializable {

		/**
		 * Check if, for this rule, the feature is opened for time "cal"
		 *
		 * @param cal           the time to check
		 * @param checkPrevious only check for overflowing times (after midnight) or don't check for it
		 * @return true if the feature is open
		 */
		public boolean isOpenedForTime(Calendar cal, boolean checkPrevious);
		
		/**
		 * Check if, for this rule, the feature is opened for time "cal" 
		 * @param cal
		 * @return true if the feature is open
		 */
		public boolean isOpenedForTime(Calendar cal);

		/**
		 * Check if the previous day before "cal" is part of this rule
		 *
		 * @param cal; the time to check
		 * @return true if the previous day is part of the rule
		 */
		public boolean containsPreviousDay(Calendar cal);

		/**
		 * Check if the day of "cal" is part of this rule
		 *
		 * @param cal the time to check
		 * @return true if the day is part of the rule
		 */
		public boolean containsDay(Calendar cal);

		/**
		 * Check if the next day after "cal" is part of this rule
		 *
		 * @param cal the time to check
		 * @return true if the next day is part of the rule
		 */
		boolean containsNextDay(Calendar cal);

		/**
		 * Check if the month of "cal" is part of this rule
		 *
		 * @param cal the time to check
		 * @return true if the month is part of the rule
		 */
		public boolean containsMonth(Calendar cal);
		
		/**
		 * @return true if the rule overlap to the next day
		 */
		public boolean hasOverlapTimes();
		
		/**
		 * @param cal
		 * @return true if rule applies for current time
		 */
		public boolean contains(Calendar cal);


		public String toRuleString();

		public String toLocalRuleString();

		boolean isOpened24_7();

		String getTime(Calendar cal, boolean checkAnotherDay, int limit, boolean opening);
	}

	/**
	 * implementation of the basic OpeningHoursRule
	 * <p/>
	 * This implementation only supports month, day of weeks and numeral times, or the value "off"
	 */
	public static class BasicOpeningHourRule implements OpeningHoursRule {
		/**
		 * represents the list on which days it is open.
		 * Day number 0 is MONDAY
		 */
		private boolean[] days = new boolean[7];

		/**
		 * represents the list on which month it is open.
		 * Day number 0 is JANUARY.
		 */
		private boolean[] months = new boolean[12];
		
		/**
		 * represents the list on which day it is open.
		 */
		private boolean[] dayMonths = new boolean[31];

		/**
		 * lists of equal size representing the start and end times
		 */
		private TIntArrayList startTimes = new TIntArrayList(), endTimes = new TIntArrayList();
		
		private boolean publicHoliday = false;
		private boolean schoolHoliday = false;
		private boolean easter = false;
		
		/**
		 * Flag that means that time is off
		 */
		private boolean off = false;

		/**
		 * return an array representing the days of the rule
		 *
		 * @return the days of the rule
		 */
		public boolean[] getDays() {
			return days;
		}
		
		/**
		 * @return the day months of the rule
		 */
		public boolean[] getDayMonths() {
			return dayMonths;
		}

		/**
		 * return an array representing the months of the rule
		 *
		 * @return the months of the rule
		 */
		public boolean[] getMonths() {
			return months;
		}
		
		public boolean appliesToPublicHolidays() {
			return publicHoliday;
		}
		
		public boolean appliesEaster() {
			return easter;
		}
		
		public boolean appliesToSchoolHolidays() {
			return schoolHoliday;
		}
		

		/**
		 * set a single start time, erase all previously added start times
		 *
		 * @param s startTime to set
		 */
		public void setStartTime(int s) {
			setSingleValueForArrayList(startTimes, s);
			if (endTimes.size() != 1) {
				setSingleValueForArrayList(endTimes, 0);
			}
		}

		/**
		 * set a single end time, erase all previously added end times
		 *
		 * @param e endTime to set
		 */
		public void setEndTime(int e) {
			setSingleValueForArrayList(endTimes, e);
			if (startTimes.size() != 1) {
				setSingleValueForArrayList(startTimes, 0);
			}
		}

		/**
		 * Set single start time. If position exceeds index of last item by one
		 * then new value will be added.
		 * If value is between 0 and last index, then value in the position p will be overwritten
		 * with new one.
		 * Else exception will be thrown.
		 *
		 * @param s        - value
		 * @param position - position to add
		 */
		public void setStartTime(int s, int position) {
			if (position == startTimes.size()) {
				startTimes.add(s);
				endTimes.add(0);
			} else {
				startTimes.set(position, s);
			}
		}

		/**
		 * Set single end time. If position exceeds index of last item by one
		 * then new value will be added.
		 * If value is between 0 and last index, then value in the position p will be overwritten
		 * with new one.
		 * Else exception will be thrown.
		 *
		 * @param s        - value
		 * @param position - position to add
		 */
		public void setEndTime(int s, int position) {
			if (position == startTimes.size()) {
				endTimes.add(s);
				startTimes.add(0);
			} else {
				endTimes.set(position, s);
			}
		}

		/**
		 * get a single start time
		 *
		 * @return a single start time
		 */
		public int getStartTime() {
			if (startTimes.size() == 0) {
				return 0;
			}
			return startTimes.get(0);
		}

		/**
		 * get a single start time in position
		 *
		 * @param position position to get value from
		 * @return a single start time
		 */
		public int getStartTime(int position) {
			return startTimes.get(position);
		}

		/**
		 * get a single end time
		 *
		 * @return a single end time
		 */
		public int getEndTime() {
			if (endTimes.size() == 0) {
				return 0;
			}
			return endTimes.get(0);
		}

		/**
		 * get a single end time in position
		 *
		 * @param position position to get value from
		 * @return a single end time
		 */
		public int getEndTime(int position) {
			return endTimes.get(position);
		}

		/**
		 * get all start times as independent list
		 *
		 * @return all start times
		 */
		public TIntArrayList getStartTimes() {
			return new TIntArrayList(startTimes);
		}

		/**
		 * get all end times as independent list
		 *
		 * @return all end times
		 */
		public TIntArrayList getEndTimes() {
			return new TIntArrayList(endTimes);
		}

		/**
		 * Check if the weekday of time "cal" is part of this rule
		 *
		 * @param cal the time to check
		 * @return true if this day is part of the rule
		 */
		@Override
		public boolean containsDay(Calendar cal) {
			int i = cal.get(Calendar.DAY_OF_WEEK);
			int d = (i + 5) % 7;
			if (days[d]) {
				return true;
			}
			return false;
		}

		@Override
		public boolean containsNextDay(Calendar cal) {
			int i = cal.get(Calendar.DAY_OF_WEEK);
			int p = (i + 6) % 7;
			if (days[p]) {
				return true;
			}
			return false;
		}

		/**
		 * Check if the previous weekday of time "cal" is part of this rule
		 *
		 * @param cal the time to check
		 * @return true if the previous day is part of the rule
		 */
		@Override
		public boolean containsPreviousDay(Calendar cal) {
			int i = cal.get(Calendar.DAY_OF_WEEK);
			int p = (i + 4) % 7;
			if (days[p]) {
				return true;
			}
			return false;
		}

		/**
		 * Check if the month of "cal" is part of this rule
		 *
		 * @param cal the time to check
		 * @return true if the month is part of the rule
		 */
		@Override
		public boolean containsMonth(Calendar cal) {
			int i = cal.get(Calendar.MONTH);
			if (months[i]) {
				return true;
			}
			return false;
		}

		/**
		 * Check if this rule says the feature is open at time "cal"
		 *
		 * @param cal the time to check
		 * @return false in all other cases, also if only day is wrong
		 */
		@Override
		public boolean isOpenedForTime(Calendar cal, boolean checkPrevious) {
			int d = getCurrentDay(cal);
			int p = getPreviousDay(d);
			int time = getCurrentTimeInMinutes(cal); // Time in minutes
			for (int i = 0; i < startTimes.size(); i++) {
				int startTime = this.startTimes.get(i);
				int endTime = this.endTimes.get(i);
				if (startTime < endTime || endTime == -1) {
					// one day working like 10:00-20:00 (not 20:00-04:00)
					if (days[d] && !checkPrevious) {
						if (time >= startTime && (endTime == -1 || time <= endTime)) {
							return !off;
						}
					}
				} else {
					// opening_hours includes day wrap like
					// "We 20:00-03:00" or "We 07:00-07:00"
					if (time >= startTime && days[d] && !checkPrevious) {
						return !off;
					} else if (time < endTime && days[p] && checkPrevious) {
						// check in previous day
						return !off;
					}
				}
			}
			return false;
		}

		private int getCurrentDay(Calendar cal) {
			int i = cal.get(Calendar.DAY_OF_WEEK);
			return (i + 5) % 7;
		}

		private int getPreviousDay(int currentDay) {
			int p = currentDay - 1;
			if (p < 0) {
				p += 7;
			}
			return p;
		}

		private int getNextDay(int currentDay) {
			int n = currentDay + 1;
			if (n > 6) {
				n -= 7;
			}
			return n;
		}

		private int getCurrentTimeInMinutes(Calendar cal) {
			return cal.get(Calendar.HOUR_OF_DAY) * 60 + cal.get(Calendar.MINUTE);
		}

		@Override
		public String toRuleString() {
			return toRuleString(daysStr, monthsStr);
		}

		private String toRuleString(String[] dayNames, String[] monthNames) {
			StringBuilder b = new StringBuilder(25);
			boolean allMonths = true;
			for (int i = 0; i < months.length; i++) {
				if (!months[i]) {
					allMonths = false;
					break;
				}
			}
			// Month
			if (!allMonths) {
				addArray(months, monthNames, b);
			}
			boolean allDays = true;
			for (int i = 0; i < dayMonths.length; i++) {
				if (!dayMonths[i]) {
					allDays = false;
					break;
				}
			}
			if (!allDays) {
				addArray(dayMonths, null, b);
			}
			// Day
			appendDaysString(b, dayNames);
			// Time
			if (startTimes == null || startTimes.size() == 0) {
				b.append("off");
			} else {
				if (isOpened24_7()) {
					return "24/7";
				}
				for (int i = 0; i < startTimes.size(); i++) {
					int startTime = startTimes.get(i);
					int endTime = endTimes.get(i);
					if(i > 0) {
						b.append(", ");
					}
					int stHour = startTime / 60;
					int stTime = startTime - stHour * 60;
					int enHour = endTime / 60;
					int enTime = endTime - enHour * 60;
					formatTime(stHour, stTime, b);
					b.append("-"); //$NON-NLS-1$
					formatTime(enHour, enTime, b);
				}
				if(off) {
					b.append(" off");
				}
			}
			return b.toString();
		}

		private void addArray(boolean[] array, String[] arrayNames, StringBuilder b) {
			boolean dash = false;
			boolean first = true;
			for (int i = 0; i < array.length; i++) {
				if (array[i]) {
					if (i > 0 && array[i - 1] && i < array.length - 1 && array[i + 1]) {
						if (!dash) {
							dash = true;
							b.append("-"); //$NON-NLS-1$
						}
						continue;
					}
					if (first) {
						first = false;
					} else if (!dash) {
						b.append(", "); //$NON-NLS-1$
					}
					b.append(arrayNames == null ? (i + 1) : arrayNames[i]);
					dash = false;
				}
			}
			if(!first) {
				b.append(" ");
			}
		}

		@Override
		public String toLocalRuleString() {
			return toRuleString(localDaysStr, localMothsStr);
		}

		@Override
		public boolean isOpened24_7() {
			boolean opened24_7 = true;
			for (int i = 0; i < 7; i++) {
				if (!days[i]) {
					opened24_7 = false;
					break;
				}
			}

			if (opened24_7 && startTimes != null && startTimes.size() > 0) {
				for (int i = 0; i < startTimes.size(); i++) {
					int startTime = startTimes.get(i);
					int endTime = endTimes.get(i);
					if (startTime == 0 && endTime / 60 == 24) {
						return true;
					}
				}
			}
			return false;
		}

		@Override
		public String getTime(Calendar cal, boolean checkAnotherDay, int limit, boolean opening) {
			StringBuilder sb = new StringBuilder();
			int d = getCurrentDay(cal);
			int ad = opening ? getNextDay(d) : getPreviousDay(d);
			int time = getCurrentTimeInMinutes(cal);
			for (int i = 0; i < startTimes.size(); i++) {
				int startTime = startTimes.get(i);
				int endTime = endTimes.get(i);
				if (opening) {
					if (startTime < endTime || endTime == -1) {
						if (days[d] && !checkAnotherDay) {
							int diff = startTime - time;
							if (limit == WITHOUT_TIME_LIMIT || ((time <= startTime) && (diff <= limit))) {
								formatTime(startTime, sb);
								break;
							}
						}
					} else {
						int diff = -1;
						if (time <= startTime && days[d] && !checkAnotherDay) {
							diff = startTime - time;
						} else if (time > endTime && days[ad] && checkAnotherDay) {
							diff = 24 * 60 - endTime  + time;
						}
						if (limit == WITHOUT_TIME_LIMIT || ((diff != -1) && (diff <= limit))) {
							formatTime(startTime, sb);
							break;
						}
					}
				} else {
					if (startTime < endTime && endTime != -1) {
						if (days[d] && !checkAnotherDay) {
							int diff = endTime - time;
							if (limit == WITHOUT_TIME_LIMIT || ((time <= endTime) && (diff <= limit))) {
								formatTime(endTime, sb);
								break;
							}
						}
					} else {
						int diff = -1;
						if (time <= endTime && days[d] && !checkAnotherDay) {
							diff = 24 * 60 - time + endTime;
						} else if (time < endTime && days[ad] && checkAnotherDay) {
							diff = startTime - time;
						}
						if (limit == WITHOUT_TIME_LIMIT || ((diff != -1) && (diff <= limit))) {
							formatTime(endTime, sb);
							break;
						}
					}
				}
			}
			return sb.toString();
		}

		@Override
		public String toString() {
			return toRuleString();
		}

		public void appendDaysString(StringBuilder builder) {
			appendDaysString(builder, daysStr);
		}

		public void appendDaysString(StringBuilder builder, String[] daysNames) {
			boolean dash = false;
			boolean first = true;
			for (int i = 0; i < 7; i++) {
				if (days[i]) {
					if (i > 0 && days[i - 1] && i < 6 && days[i + 1]) {
						if (!dash) {
							dash = true;
							builder.append("-"); //$NON-NLS-1$
						}
						continue;
					}
					if (first) {
						first = false;
					} else if (!dash) {
						builder.append(", "); //$NON-NLS-1$
					}
					builder.append(daysNames[getDayIndex(i)]);
					dash = false;
				}
			}
			if (publicHoliday) {
				if (!first) {
					builder.append(", ");
				}
				builder.append("PH");
				first = false;
			}
			if (schoolHoliday) {
				if (!first) {
					builder.append(", ");
				}
				builder.append("SH");
				first = false;
			}
			if (easter) {
				if (!first) {
					builder.append(", ");
				}
				builder.append("Easter");
				first = false;
			}
			if(!first) {
				builder.append(" ");
			}
		}

		/**
		 * Add a time range (startTime-endTime) to this rule
		 *
		 * @param startTime startTime to add
		 * @param endTime   endTime to add
		 */
		public void addTimeRange(int startTime, int endTime) {
			startTimes.add(startTime);
			endTimes.add(endTime);
		}

		public int timesSize() {
			return startTimes.size();
		}

		public void deleteTimeRange(int position) {
			startTimes.removeAt(position);
			endTimes.removeAt(position);
		}

		private static void setSingleValueForArrayList(TIntArrayList arrayList, int s) {
			if (arrayList.size() > 0) {
				arrayList.remove(0, arrayList.size());
			}
			arrayList.add(s);
		}

		@Override
		public boolean isOpenedForTime(Calendar cal) {
			int c = calculate(cal);
			return c > 0;
		}

		@Override
		public boolean contains(Calendar cal) {
			int c = calculate(cal);
			return c != 0;
		}
		
		@Override
		public boolean hasOverlapTimes() {
			for (int i = 0; i < startTimes.size(); i++) {
				int startTime = this.startTimes.get(i);
				int endTime = this.endTimes.get(i);
				if (startTime >= endTime && endTime != -1) {
					return true;
				}
			}
			return false;
		}

		private int calculate(Calendar cal) {
			int month = cal.get(Calendar.MONTH);
			if (!months[month]) {
				return 0;
			}
			int dmonth = cal.get(Calendar.DAY_OF_MONTH) - 1;
			int i = cal.get(Calendar.DAY_OF_WEEK);
			int day = (i + 5) % 7;
			int previous = (day + 6) % 7;
			boolean thisDay = days[day] || dayMonths[dmonth];
			// potential error for Dec 31 12:00-01:00
			boolean previousDay = days[previous] || (dmonth > 0 && dayMonths[dmonth - 1]);
			if (!thisDay && !previousDay) {
				return 0;
			}
			int time = cal.get(Calendar.HOUR_OF_DAY) * 60 + cal.get(Calendar.MINUTE); // Time in minutes
			for (i = 0; i < startTimes.size(); i++) {
				int startTime = this.startTimes.get(i);
				int endTime = this.endTimes.get(i);
				if (startTime < endTime || endTime == -1) {
					// one day working like 10:00-20:00 (not 20:00-04:00)
					if (time >= startTime && (endTime == -1 || time <= endTime) && thisDay) {
						return off ? -1 : 1;
					}
				} else {
					// opening_hours includes day wrap like
					// "We 20:00-03:00" or "We 07:00-07:00"
					if (time >= startTime && thisDay) {
						return off ? -1 : 1;
					} else if (time < endTime && previousDay) {
						return off ? -1 : 1;
					}
				}
			}
			if (thisDay && (startTimes == null || startTimes.isEmpty() || !off)) {
				return -1;
			}
			return 0;
		}
	}

	public static class UnparseableRule implements OpeningHoursParser.OpeningHoursRule {
		private String ruleString;

		public UnparseableRule(String ruleString) {
			this.ruleString = ruleString;
		}

		@Override
		public boolean isOpenedForTime(Calendar cal, boolean checkPrevious) {
			return false;
		}

		@Override
		public boolean containsPreviousDay(Calendar cal) {
			return false;
		}
		
		@Override
		public boolean hasOverlapTimes() {
			return false;
		}

		@Override
		public boolean containsDay(Calendar cal) {
			return false;
		}

		@Override
		public boolean containsNextDay(Calendar cal) {
			return false;
		}

		@Override
		public boolean containsMonth(Calendar cal) {
			return false;
		}

		@Override
		public String toRuleString() {
			return ruleString;
		}

		@Override
		public String toLocalRuleString() {
			return toRuleString();
		}

		@Override
		public boolean isOpened24_7() {
			return false;
		}

		@Override
		public String getTime(Calendar cal, boolean checkAnotherDay, int limit, boolean opening) {
			return "";
		}

		@Override
		public String toString() {
			return toRuleString();
		}

		@Override
		public boolean isOpenedForTime(Calendar cal) {
			return false;
		}

		@Override
		public boolean contains(Calendar cal) {
			return false;
		}
	}
	
	private enum TokenType { 
		TOKEN_UNKNOWN(0),
		TOKEN_COLON(1),
		TOKEN_COMMA(2),
		TOKEN_DASH(3),
		// order is important
		TOKEN_MONTH(4),
		TOKEN_DAY_MONTH(5),
		TOKEN_HOLIDAY(6),
		TOKEN_DAY_WEEK(6),
		TOKEN_HOUR_MINUTES (7),
		TOKEN_OFF_ON(8);
		public final int ord;

		private TokenType(int ord) {
			this.ord = ord;
		}

		public int ord() {
			return ord;
		}

	}
	
	private static class Token {
		public Token(TokenType tokenType, String string) {
			type = tokenType;
			text = string;
			try {
				mainNumber = Integer.parseInt(string);
			} catch(NumberFormatException e){
			}
		}
		int mainNumber = -1;
		TokenType type;
		String text;
		
		@Override
		public String toString() {
			return text + " [" + type + "] ";
		}
	}

	public static OpeningHoursParser.OpeningHoursRule parseRuleV2(String r) {
		r = r.toLowerCase();
		
		final String[] daysStr = new String[]{"mo", "tu", "we", "th", "fr", "sa", "su"};
		final String[] monthsStr = new String[]{"jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec"};
		final String[] holidayStr = new String[]{"ph", "sh", "easter"};
		String sunrise = "07:00";
		String sunset = "21:00";
		String endOfDay = "24:00";
		r = r.replace('(', ' '); // avoid "(mo-su 17:00-20:00"
		r = r.replace(')', ' ');
		String localRuleString = r.replaceAll("sunset", sunset).replaceAll("sunrise", sunrise)
				.replaceAll("\\+", "-" + endOfDay);
		BasicOpeningHourRule basic = new BasicOpeningHourRule();
		boolean[] days = basic.getDays();
		boolean[] months = basic.getMonths();
		boolean[] dayMonths = basic.getDayMonths();
		if ("24/7".equals(localRuleString)) {
			Arrays.fill(days, true);
			Arrays.fill(months, true);
			basic.addTimeRange(0, 24 * 60);
			return basic;
		}
		List<Token> tokens = new ArrayList<>();
		int startWord = 0;
		for(int i = 0; i <= localRuleString.length(); i++) {
			char ch = i == localRuleString.length() ? ' ' : localRuleString.charAt(i);
			boolean delimiter = false;
			Token del = null;
			if(Character.isWhitespace(ch)) {
				delimiter = true;
			} else if(ch == ':') {
				del = new Token(TokenType.TOKEN_COLON, ":");
			} else if(ch == '-') {
				del = new Token(TokenType.TOKEN_DASH, "-");
			} else if(ch == ',') {
				del = new Token(TokenType.TOKEN_COMMA, ",");
			}
			if(delimiter || del != null) {
				String wrd = localRuleString.substring(startWord, i).trim();
				if(wrd.length() > 0) {
					tokens.add(new Token(TokenType.TOKEN_UNKNOWN, wrd));
				}
				startWord = i + 1;
				if(del != null) {
					tokens.add(del);
				}
			}
		}
		// recognize day of week
		for(Token t : tokens) {
			if(t.type == TokenType.TOKEN_UNKNOWN) {
				findInArray(t, daysStr, TokenType.TOKEN_DAY_WEEK);
			}
			if(t.type == TokenType.TOKEN_UNKNOWN) {
				findInArray(t, monthsStr, TokenType.TOKEN_MONTH);
			}
			if(t.type == TokenType.TOKEN_UNKNOWN) {
				findInArray(t, holidayStr, TokenType.TOKEN_HOLIDAY);
			}
			if(t.type == TokenType.TOKEN_UNKNOWN && ("off".equals(t.text) || "closed".equals(t.text))) {
				t.type = TokenType.TOKEN_OFF_ON;
				t.mainNumber = 0;
			}
			if(t.type == TokenType.TOKEN_UNKNOWN && ("24/7".equals(t.text) || "open".equals(t.text))) {
				t.type = TokenType.TOKEN_OFF_ON;
				t.mainNumber = 1;
			}
		}
		// recognize hours minutes ( Dec 25: 08:30-20:00)
		for(int i = tokens.size() - 1; i >= 0; i --) {
			if(tokens.get(i).type == TokenType.TOKEN_COLON) {
				if(i > 0 && i < tokens.size() - 1) {
					if(tokens.get(i - 1).type == TokenType.TOKEN_UNKNOWN && tokens.get(i - 1).mainNumber != -1 && 
							tokens.get(i + 1).type == TokenType.TOKEN_UNKNOWN && tokens.get(i + 1).mainNumber != -1 ) {
						tokens.get(i).mainNumber = 60 * tokens.get(i - 1).mainNumber + tokens.get(i + 1).mainNumber;
						tokens.get(i).type = TokenType.TOKEN_HOUR_MINUTES;
						tokens.remove(i + 1);
						tokens.remove(i - 1);
					}
				}
				
			}
		}
		// recognize other numbers
		// if there is no on/off and minutes/hours
		boolean hoursSpecified = false;
		for(int i = 0; i < tokens.size(); i ++) {
			if(tokens.get(i).type == TokenType.TOKEN_HOUR_MINUTES || 
					tokens.get(i).type == TokenType.TOKEN_OFF_ON) {
				hoursSpecified = true;
				break;
			}
		}
		for(int i = 0; i < tokens.size(); i ++) {
			if(tokens.get(i).type == TokenType.TOKEN_UNKNOWN && tokens.get(i).mainNumber >= 0) {
				tokens.get(i).type = hoursSpecified ? TokenType.TOKEN_DAY_MONTH : TokenType.TOKEN_HOUR_MINUTES;
				if(tokens.get(i).type == TokenType.TOKEN_HOUR_MINUTES) {
					tokens.get(i).mainNumber = tokens.get(i).mainNumber * 60;
				} else {
					tokens.get(i).mainNumber = tokens.get(i).mainNumber - 1;
				}
			}
		}
		// order MONTH MONTH_DAY DAY_WEEK HOUR_MINUTE OPEN_OFF
		TokenType currentParse = TokenType.TOKEN_UNKNOWN;
		List<Token[]> listOfPairs = new ArrayList<>();
		Set<TokenType> presentTokens = new HashSet<>();
		Token[] currentPair = new Token[2];
		listOfPairs.add(currentPair);
		int indexP = 0;
		for(int i = 0; i <= tokens.size(); i++) {
			Token t = i == tokens.size() ? null : tokens.get(i);
			if (t == null || t.type.ord() > currentParse.ord()) {
				presentTokens.add(currentParse);
				// case tokens.get(i).type.ordinal() < currentParse.ordinal() - not supported (Fr 15:00-18:00, Sa 16-18)
				if (currentParse == TokenType.TOKEN_MONTH || currentParse == TokenType.TOKEN_DAY_MONTH
						|| currentParse == TokenType.TOKEN_DAY_WEEK || currentParse == TokenType.TOKEN_HOLIDAY) {
					
					boolean[] array = (currentParse == TokenType.TOKEN_MONTH) ? basic.getMonths()
							: (currentParse == TokenType.TOKEN_DAY_MONTH) ? basic.getDayMonths() : basic.getDays();
					for (Token[] pair : listOfPairs) {
						if (pair[0] != null && pair[1] != null) {
							if (pair[0].mainNumber <= pair[1].mainNumber) {
								for (int j = pair[0].mainNumber; j <= pair[1].mainNumber && j < array.length; j++) {
									array[j] = true;
								}
							} else {
								// overflow
								for (int j = pair[0].mainNumber; j < array.length; j++) {
									array[j] = true;
								}
								for (int j = 0; j <= pair[1].mainNumber; j++) {
									array[j] = true;
								}
							}
						} else if (pair[0] != null) {
							if(pair[0].type == TokenType.TOKEN_HOLIDAY) {
								if(pair[0].mainNumber == 0) {
									basic.publicHoliday = true;
								} else if(pair[0].mainNumber == 1) {
									basic.schoolHoliday = true;
								} else if(pair[0].mainNumber == 2) {
									basic.easter = true;
								}
							} else if(pair[0].mainNumber >= 0){
								array[pair[0].mainNumber] = true;
							}
						}
					}
				} else if (currentParse == TokenType.TOKEN_HOUR_MINUTES) {
					for (Token[] pair : listOfPairs) {
						if(pair[0] != null && pair[1] != null) {
							basic.addTimeRange(pair[0].mainNumber, pair[1].mainNumber);
						}
					}
				} else if (currentParse == TokenType.TOKEN_OFF_ON) {
					Token[] l = listOfPairs.get(0);
					if(l[0] != null && l[0].mainNumber == 0) {
						basic.off = true;
					}
				}
				listOfPairs.clear();
				currentPair = new Token[2];
				indexP = 0;
				listOfPairs.add(currentPair);
				currentPair[indexP++] = t;
				if(t != null) {
					currentParse = t.type;
				}
			} else if(t.type == TokenType.TOKEN_COMMA) {
				currentPair = new Token[2];
				indexP = 0;
				listOfPairs.add(currentPair);
			} else if(t.type == TokenType.TOKEN_DASH) {
				
			} else if(t.type.ord() == currentParse.ord()) {
				if(indexP < 2) {
					currentPair[indexP++] = t;
				}
			}
		}
		if(!presentTokens.contains(TokenType.TOKEN_MONTH)) {
			Arrays.fill(basic.getMonths(), true);
		}
//		if(!presentTokens.contains(TokenType.TOKEN_DAY_MONTH)) {
//			Arrays.fill(basic.getDayMonths(), true);
//		}
		if(!presentTokens.contains(TokenType.TOKEN_DAY_WEEK) && !presentTokens.contains(TokenType.TOKEN_HOLIDAY) && 
				!presentTokens.contains(TokenType.TOKEN_DAY_MONTH)) {
			Arrays.fill(basic.getDays(), true);
		}
//		if(!presentTokens.contains(TokenType.TOKEN_HOUR_MINUTES)) {
//			basic.addTimeRange(0, 24 * 60);
//		}
//		System.out.println(r + " " +  tokens);
		return basic;
	}

	private static void findInArray(Token t, String[] list, TokenType tokenType) {
		for(int i = 0; i < list.length; i++) {
			if(list[i].equals(t.text)) {
				t.type = tokenType;
				t.mainNumber = i;
				break;
			}
		}
	}

	/**
	 * Parse an opening_hours string from OSM to an OpeningHours object which can be used to check
	 *
	 * @param r the string to parse
	 * @return BasicRule if the String is successfully parsed and UnparseableRule otherwise
	 */
	public static OpeningHoursParser.OpeningHoursRule parseRule(String r) {
		return parseRuleV2(r);
	}

	/**
	 * parse OSM opening_hours string to an OpeningHours object
	 *
	 * @param format the string to parse
	 * @return null when parsing was unsuccessful
	 */
	public static OpeningHours parseOpenedHours(String format) {
		if (format == null) {
			return null;
		}
		// split the OSM string in multiple rules
		String[] rules = format.split(";"); //$NON-NLS-1$
		// FIXME: What if the semicolon is inside a quoted string?
		OpeningHours rs = new OpeningHours();
		rs.setOriginal(format);
		for (String r : rules) {
			r = r.trim();
			if (r.length() == 0) {
				continue;
			}
			// check if valid
			final OpeningHoursRule r1 = parseRule(r);
			boolean rule = r1 instanceof BasicOpeningHourRule;
			if (rule) {
				rs.addRule(r1);
			}
		}
		return rs;
	}

	/**
	 * parse OSM opening_hours string to an OpeningHours object.
	 * Does not return null when parsing unsuccessful. When parsing rule is unsuccessful,
	 * such rule is stored as UnparseableRule.
	 *
	 * @param format the string to parse
	 * @return the OpeningHours object
	 */
	public static OpeningHoursParser.OpeningHours parseOpenedHoursHandleErrors(String format) {
		if (format == null) {
			return null;
		}
		String[] rules = format.split(";"); //$NON-NLS-1$
		OpeningHoursParser.OpeningHours rs = new OpeningHoursParser.OpeningHours();
		rs.setOriginal(format);
		for (String r : rules) {
			r = r.trim();
			if (r.length() == 0) {
				continue;
			}
			// check if valid
			rs.addRule(OpeningHoursParser.parseRule(r));
		}
		return rs;
	}

	private static void formatTime(int h, int t, StringBuilder b) {
		if (h < 10) {
			b.append("0"); //$NON-NLS-1$
		}
		b.append(h).append(":"); //$NON-NLS-1$
		if (t < 10) {
			b.append("0"); //$NON-NLS-1$
		}
		b.append(t);
	}

	private static void formatTime(int minutes, StringBuilder sb) {
		int hour = minutes / 60;
		int time = minutes - hour * 60;
		formatTime(hour, time, sb);
	}

	/**
	 * test if the calculated opening hours are what you expect
	 *
	 * @param time     the time to test in the format "dd.MM.yyyy HH:mm"
	 * @param hours    the OpeningHours object
	 * @param expected the expected state
	 */
	private static void testOpened(String time, OpeningHours hours, boolean expected) throws ParseException {
		Calendar cal = Calendar.getInstance();
		cal.setTime(new SimpleDateFormat("dd.MM.yyyy HH:mm", Locale.US).parse(time));
		boolean calculated = hours.isOpenedForTimeV2(cal);
		System.out.printf("  %sok: Expected %s: %b = %b (rule %s)\n",
				((calculated != expected) ? "NOT " : ""), time, expected, calculated, hours.getCurrentRuleTime(cal));
		if (calculated != expected) {
			throw new IllegalArgumentException("BUG!!!");
		}
	}

	private static void testParsedAndAssembledCorrectly(String timeString, OpeningHours hours) {
		String assembledString = hours.toString();
		boolean isCorrect = assembledString.equalsIgnoreCase(timeString);
		System.out.printf("  %sok: Expected: \"%s\" got: \"%s\"\n",
				(!isCorrect ? "NOT " : ""), timeString, assembledString);
		if (!isCorrect) {
			throw new IllegalArgumentException("BUG!!!");
		}
	}

	public static void main(String[] args) throws ParseException {
		// 0. not supported MON DAY-MON DAY (only supported Feb 2-14 or Feb-Oct: 09:00-17:30)
		// parseOpenedHours("Feb 16-Oct 15: 09:00-18:30; Oct 16-Nov 15: 09:00-17:30; Nov 16-Feb 15: 09:00-16:30");
		
		// 1. not supported (,)
		// hours = parseOpenedHours("Mo-Su 07:00-23:00, Fr 08:00-20:00");
		
		// 2. not supported break properly
		// parseOpenedHours("Sa-Su 10:00-17:00 || \"by appointment\"");
		// comment is dropped
		
		// 3. not properly supported
		// hours = parseOpenedHours("Mo-Su (sunrise-00:30)-(sunset+00:30)");
		
		// Test basic case
		OpeningHours hours = parseOpenedHours("Mo-Fr 08:30-14:40"); //$NON-NLS-1$
		testOpened("09.08.2012 11:00", hours, true);
		testOpened("09.08.2012 16:00", hours, false);
		hours = parseOpenedHours("mo-fr 07:00-19:00; sa 12:00-18:00");
		System.out.println(hours);

		String string = "Mo-Fr 11:30-15:00, 17:30-23:00; Sa, Su, PH 11:30-23:00";
		hours = parseOpenedHours(string);
		testParsedAndAssembledCorrectly(string, hours);
		System.out.println(hours);
		testOpened("7.09.2015 14:54", hours, true); // monday
		testOpened("7.09.2015 15:05", hours, false);
		testOpened("6.09.2015 16:05", hours, true);


		// two time and date ranges
		hours = parseOpenedHours("Mo-We, Fr 08:30-14:40,15:00-19:00"); //$NON-NLS-1$
		System.out.println(hours);
		testOpened("08.08.2012 14:00", hours, true);
		testOpened("08.08.2012 14:50", hours, false);
		testOpened("10.08.2012 15:00", hours, true);

		// test exception on general schema
		hours = parseOpenedHours("Mo-Sa 08:30-14:40; Tu 08:00 - 14:00"); //$NON-NLS-1$
		System.out.println(hours);
		testOpened("07.08.2012 14:20", hours, false);
		testOpened("07.08.2012 08:15", hours, true); // Tuesday

		// test off value
		hours = parseOpenedHours("Mo-Sa 09:00-18:25; Th off"); //$NON-NLS-1$
		System.out.println(hours);
		testOpened("08.08.2012 12:00", hours, true);
		testOpened("09.08.2012 12:00", hours, false);

		// test 24/7
		hours = parseOpenedHours("24/7"); //$NON-NLS-1$
		System.out.println(hours);
		testOpened("08.08.2012 23:59", hours, true);
		testOpened("08.08.2012 12:23", hours, true);
		testOpened("08.08.2012 06:23", hours, true);

		// some people seem to use the following syntax:
		hours = parseOpenedHours("Sa-Su 24/7");
		System.out.println(hours);
		hours = parseOpenedHours("Mo-Fr 9-19");
		System.out.println(hours);
		hours = parseOpenedHours("09:00-17:00");
		System.out.println(hours);
		hours = parseOpenedHours("sunrise-sunset");
		System.out.println(hours);
		hours = parseOpenedHours("10:00+");
		System.out.println(hours);
		hours = parseOpenedHours("Su-Th sunset-24:00, 04:00-sunrise; Fr-Sa sunset-sunrise");
		System.out.println(hours);
		testOpened("12.08.2012 04:00", hours, true);
		testOpened("12.08.2012 23:00", hours, true);
		testOpened("08.08.2012 12:00", hours, false);
		testOpened("08.08.2012 05:00", hours, true);

		// test simple day wrap
		hours = parseOpenedHours("Mo 20:00-02:00");
		System.out.println(hours);
		testOpened("05.05.2013 10:30", hours, false);
		testOpened("05.05.2013 23:59", hours, false);
		testOpened("06.05.2013 10:30", hours, false);
		testOpened("06.05.2013 20:30", hours, true);
		testOpened("06.05.2013 23:59", hours, true);
		testOpened("07.05.2013 00:00", hours, true);
		testOpened("07.05.2013 00:30", hours, true);
		testOpened("07.05.2013 01:59", hours, true);
		testOpened("07.05.2013 20:30", hours, false);

		// test maximum day wrap
		hours = parseOpenedHours("Su 10:00-10:00");
		System.out.println(hours);
		testOpened("05.05.2013 09:59", hours, false);
		testOpened("05.05.2013 10:00", hours, true);
		testOpened("05.05.2013 23:59", hours, true);
		testOpened("06.05.2013 00:00", hours, true);
		testOpened("06.05.2013 09:59", hours, true);
		testOpened("06.05.2013 10:00", hours, false);

		// test day wrap as seen on OSM
		hours = parseOpenedHours("Tu-Th 07:00-2:00; Fr 17:00-4:00; Sa 18:00-05:00; Su,Mo off");
		System.out.println(hours);
		testOpened("05.05.2013 04:59", hours, true); // sunday 05.05.2013
		testOpened("05.05.2013 05:00", hours, false);
		testOpened("05.05.2013 12:30", hours, false);
		testOpened("06.05.2013 10:30", hours, false);
		testOpened("07.05.2013 01:00", hours, false);
		testOpened("07.05.2013 20:25", hours, true);
		testOpened("07.05.2013 23:59", hours, true);
		testOpened("08.05.2013 00:00", hours, true);
		testOpened("08.05.2013 02:00", hours, false);

		// test day wrap as seen on OSM
		hours = parseOpenedHours("Mo-Th 09:00-03:00; Fr-Sa 09:00-04:00; Su off");
		testOpened("11.05.2015 08:59", hours, false);
		testOpened("11.05.2015 09:01", hours, true);
		testOpened("12.05.2015 02:59", hours, true);
		testOpened("12.05.2015 03:00", hours, false);
		testOpened("16.05.2015 03:59", hours, true);
		testOpened("16.05.2015 04:01", hours, false);
		testOpened("17.05.2015 01:00", hours, true);
		testOpened("17.05.2015 04:01", hours, false);

		hours = parseOpenedHours("Tu-Th 07:00-2:00; Fr 17:00-4:00; Sa 18:00-05:00; Su,Mo off");
		testOpened("11.05.2015 08:59", hours, false);
		testOpened("11.05.2015 09:01", hours, false);
		testOpened("12.05.2015 01:59", hours, false);
		testOpened("12.05.2015 02:59", hours, false);
		testOpened("12.05.2015 03:00", hours, false);
		testOpened("13.05.2015 01:59", hours, true);
		testOpened("13.05.2015 02:59", hours, false);
		testOpened("16.05.2015 03:59", hours, true);
		testOpened("16.05.2015 04:01", hours, false);
		testOpened("17.05.2015 01:00", hours, true);
		testOpened("17.05.2015 05:01", hours, false);

		// tests single month value
		hours = parseOpenedHours("May: 07:00-19:00");
		System.out.println(hours);
		testOpened("05.05.2013 12:00", hours, true);
		testOpened("05.05.2013 05:00", hours, false);
		testOpened("05.05.2013 21:00", hours, false);
		testOpened("05.01.2013 12:00", hours, false);
		testOpened("05.01.2013 05:00", hours, false);

		// tests multi month value
		hours = parseOpenedHours("Apr-Sep 8:00-22:00; Oct-Mar 10:00-18:00");
		System.out.println(hours);
		testOpened("05.03.2013 15:00", hours, true);
		testOpened("05.03.2013 20:00", hours, false);

		testOpened("05.05.2013 20:00", hours, true);
		testOpened("05.05.2013 23:00", hours, false);

		testOpened("05.10.2013 15:00", hours, true);
		testOpened("05.10.2013 20:00", hours, false);

		// Test time with breaks
		hours = parseOpenedHours("Mo-Fr: 9:00-13:00, 14:00-18:00");
		System.out.println(hours);
		testOpened("02.12.2015 12:00", hours, true);
		testOpened("02.12.2015 13:30", hours, false);
		testOpened("02.12.2015 16:00", hours, true);

		testOpened("05.12.2015 16:00", hours, false);
		
		hours = parseOpenedHours("Mo-Su 07:00-23:00; Dec 25 08:00-20:00");
		System.out.println(hours);
		testOpened("25.12.2015 07:00", hours, false);
		testOpened("24.12.2015 07:00", hours, true);
		testOpened("24.12.2015 22:00", hours, true);
		testOpened("25.12.2015 08:00", hours, true);
		testOpened("25.12.2015 22:00", hours, false);
		
		hours = parseOpenedHours("Mo-Su 07:00-23:00; Dec 25 off");
		System.out.println(hours);
		testOpened("25.12.2015 14:00", hours, false);
		testOpened("24.12.2015 08:00", hours, true);
		
		// easter itself as public holiday is not supported
		hours = parseOpenedHours("Mo-Su 07:00-23:00; Easter off; Dec 25 off");
		System.out.println(hours);
		testOpened("25.12.2015 14:00", hours, false);
		testOpened("24.12.2015 08:00", hours, true);

		// test time off (not days
		hours = parseOpenedHours("Mo-Fr 08:30-17:00; 12:00-12:40 off;");
		System.out.println(hours);
		testOpened("07.05.2017 14:00", hours, false); // Sunday
		testOpened("06.05.2017 12:15", hours, false); // Saturday
		testOpened("05.05.2017 14:00", hours, true); // Friday
		testOpened("05.05.2017 12:15", hours, false);
		testOpened("05.05.2017 12:00", hours, false);
		testOpened("05.05.2017 11:45", hours, true);
		
		// Test holidays
		String hoursString = "mo-fr 11:00-21:00; PH off";
		hours = parseOpenedHoursHandleErrors(hoursString);
		testParsedAndAssembledCorrectly(hoursString, hours);
		

		
	}
}
!@#$%
20190530_070404,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_b01364
package net.osmand.plus.wikivoyage;

import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;

import net.osmand.plus.OsmandApplication;
import net.osmand.plus.OsmandSettings.WikivoyageShowImages;
import net.osmand.plus.R;
import net.osmand.plus.base.BottomSheetDialogFragment;

public class WikivoyageShowPicturesDialogFragment  extends BottomSheetDialogFragment {
	public static final String TAG = WikivoyageShowPicturesDialogFragment.class.getSimpleName();

	public static final int SHOW_PICTURES_CHANGED_REQUEST_CODE = 1;

	@Override
	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {

		View view = inflater.inflate(R.layout.fragment_wikivoyage_show_images_first_time, container, false);
		view.findViewById(R.id.button_no).setOnClickListener(new View.OnClickListener() {
					@Override
					public void onClick(View v) {
						OsmandApplication app = getMyApplication();
						if (app != null) {
							app.getSettings().WIKIVOYAGE_SHOW_IMAGES.set(WikivoyageShowImages.OFF);
						}
						sendResult();
						dismiss();
					}
				});
		view.findViewById(R.id.button_wifi).setOnClickListener(new View.OnClickListener() {
					@Override
					public void onClick(View v) {
						OsmandApplication app = getMyApplication();
						if (app != null) {
							app.getSettings().WIKIVOYAGE_SHOW_IMAGES.set(WikivoyageShowImages.WIFI);
						}
						sendResult();
						dismiss();
					}
				});
		view.findViewById(R.id.button_yes).setOnClickListener(new View.OnClickListener() {
					@Override
					public void onClick(View v) {
						OsmandApplication app = getMyApplication();
						if (app != null) {
							app.getSettings().WIKIVOYAGE_SHOW_IMAGES.set(WikivoyageShowImages.ON);
						}
						sendResult();
						dismiss();
					}
				});

		return view;
	}

	private void sendResult() {
		Fragment fragment = getTargetFragment();
		if (fragment != null) {
			fragment.onActivityResult(getTargetRequestCode(), SHOW_PICTURES_CHANGED_REQUEST_CODE, null);
		}
	}
}
!@#$%
20190530_070404,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_a01364
package net.osmand.plus.wikivoyage;

import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;

import net.osmand.plus.OsmandApplication;
import net.osmand.plus.OsmandSettings.WikivoyageShowImages;
import net.osmand.plus.R;
import net.osmand.plus.base.BottomSheetDialogFragment;

public class WikivoyageShowPicturesDialogFragment  extends BottomSheetDialogFragment {
	public static final String TAG = WikivoyageShowPicturesDialogFragment.class.getSimpleName();

	public static final int SHOW_PICTURES_CHANGED = 1;

	@Override
	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {

		View view = inflater.inflate(R.layout.fragment_wikivoyage_show_images_first_time, container, false);
		view.findViewById(R.id.button_no).setOnClickListener(new View.OnClickListener() {
					@Override
					public void onClick(View v) {
						OsmandApplication app = getMyApplication();
						if (app != null) {
							app.getSettings().WIKIVOYAGE_SHOW_IMAGES.set(WikivoyageShowImages.OFF);
						}
						sendResult();
						dismiss();
					}
				});
		view.findViewById(R.id.button_wifi).setOnClickListener(new View.OnClickListener() {
					@Override
					public void onClick(View v) {
						OsmandApplication app = getMyApplication();
						if (app != null) {
							app.getSettings().WIKIVOYAGE_SHOW_IMAGES.set(WikivoyageShowImages.WIFI);
						}
						sendResult();
						dismiss();
					}
				});
		view.findViewById(R.id.button_yes).setOnClickListener(new View.OnClickListener() {
					@Override
					public void onClick(View v) {
						OsmandApplication app = getMyApplication();
						if (app != null) {
							app.getSettings().WIKIVOYAGE_SHOW_IMAGES.set(WikivoyageShowImages.ON);
						}
						sendResult();
						dismiss();
					}
				});

		return view;
	}

	private void sendResult() {
		Fragment fragment = getTargetFragment();
		if (fragment != null) {
			fragment.onActivityResult(getTargetRequestCode(), SHOW_PICTURES_CHANGED, null);
		}
	}
}
!@#$%
20190530_070404,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_c01364
package net.osmand.plus.wikivoyage;

import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;

import net.osmand.plus.OsmandApplication;
import net.osmand.plus.OsmandSettings.WikivoyageShowImages;
import net.osmand.plus.R;
import net.osmand.plus.base.BottomSheetDialogFragment;

public class WikivoyageShowPicturesDialogFragment extends BottomSheetDialogFragment {

	public static final String TAG = WikivoyageShowPicturesDialogFragment.class.getSimpleName();

	public static final int SHOW_PICTURES_CHANGED = 1;

	@Override
	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {

		View view = inflater.inflate(R.layout.fragment_wikivoyage_show_images_first_time, container, false);
		view.findViewById(R.id.button_no).setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				OsmandApplication app = getMyApplication();
				if (app != null) {
					app.getSettings().WIKIVOYAGE_SHOW_IMAGES.set(WikivoyageShowImages.OFF);
				}
				sendResult();
				dismiss();
			}
		});
		view.findViewById(R.id.button_wifi).setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				OsmandApplication app = getMyApplication();
				if (app != null) {
					app.getSettings().WIKIVOYAGE_SHOW_IMAGES.set(WikivoyageShowImages.WIFI);
				}
				sendResult();
				dismiss();
			}
		});
		view.findViewById(R.id.button_yes).setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				OsmandApplication app = getMyApplication();
				if (app != null) {
					app.getSettings().WIKIVOYAGE_SHOW_IMAGES.set(WikivoyageShowImages.ON);
				}
				sendResult();
				dismiss();
			}
		});

		return view;
	}

	private void sendResult() {
		Fragment fragment = getTargetFragment();
		if (fragment != null) {
			fragment.onActivityResult(getTargetRequestCode(), SHOW_PICTURES_CHANGED, null);
		}
	}
}
!@#$%
20190530_071000,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_b01380
package net.osmand.plus.wikivoyage.data;

import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.text.TextUtils;
import net.osmand.Collator;
import net.osmand.CollatorStringMatcher;
import net.osmand.CollatorStringMatcher.StringMatcherMode;
import net.osmand.IndexConstants;
import net.osmand.Location;
import net.osmand.OsmAndCollator;
import net.osmand.PlatformUtil;
import net.osmand.data.LatLon;
import net.osmand.plus.GPXUtilities;
import net.osmand.plus.GPXUtilities.GPXFile;
import net.osmand.plus.OsmandApplication;
import net.osmand.plus.R;
import net.osmand.plus.api.SQLiteAPI.SQLiteConnection;
import net.osmand.plus.api.SQLiteAPI.SQLiteCursor;
import net.osmand.util.Algorithms;
import net.osmand.util.MapUtils;

import org.apache.commons.logging.Log;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import gnu.trove.map.hash.TLongObjectHashMap;

public class TravelDbHelper {

	private static final Log LOG = PlatformUtil.getLog(TravelDbHelper.class);

	private static final String ARTICLES_TABLE_NAME = "wikivoyage_articles";
	private static final String POPULAR_TABLE_NAME = "popular_articles";
	private static final String ARTICLES_COL_ID = "article_id";
	private static final String ARTICLES_POP_INDEX = "popularity_index";
	private static final String ARTICLES_COL_TITLE = "title";
	private static final String ARTICLES_COL_CONTENT = "content_gz";
	private static final String ARTICLES_COL_IS_PART_OF = "is_part_of";
	private static final String ARTICLES_COL_LAT = "lat";
	private static final String ARTICLES_COL_LON = "lon";
	private static final String ARTICLES_COL_IMAGE_TITLE = "image_title";
	private static final String ARTICLES_COL_GPX_GZ = "gpx_gz";
	private static final String ARTICLES_COL_CITY_ID = "city_id";
	private static final String ARTICLES_COL_ORIGINAL_ID = "original_id";
	private static final String ARTICLES_COL_LANG = "lang";
	private static final String ARTICLES_COL_CONTENTS_JSON = "contents_json";
	private static final String ARTICLES_COL_AGGREGATED_PART_OF = "aggregated_part_of";

	private static final String ARTICLES_TABLE_SELECT = "SELECT " +
			ARTICLES_COL_ID + ", " +
			ARTICLES_COL_TITLE + ", " +
			ARTICLES_COL_CONTENT + ", " +
			ARTICLES_COL_IS_PART_OF + ", " +
			ARTICLES_COL_LAT + ", " +
			ARTICLES_COL_LON + ", " +
			ARTICLES_COL_IMAGE_TITLE + ", " +
			ARTICLES_COL_GPX_GZ + ", " +
			ARTICLES_COL_CITY_ID + ", " +
			ARTICLES_COL_ORIGINAL_ID + ", " +
			ARTICLES_COL_LANG + ", " +
			ARTICLES_COL_CONTENTS_JSON + ", " +
			ARTICLES_COL_AGGREGATED_PART_OF +
			" FROM " + ARTICLES_TABLE_NAME;
	
	private static final String POP_ARTICLES_TABLE_SELECT = "SELECT " +
			ARTICLES_COL_TITLE + ", " +
			ARTICLES_COL_LAT + ", " +
			ARTICLES_COL_LON + ", " +
			ARTICLES_COL_CITY_ID + ", " +
			ARTICLES_COL_LANG + ", " +
			ARTICLES_POP_INDEX +
			" FROM " + POPULAR_TABLE_NAME;

	private static final String SEARCH_TABLE_NAME = "wikivoyage_search";
	private static final String SEARCH_COL_SEARCH_TERM = "search_term";
	private static final String SEARCH_COL_CITY_ID = "city_id";
	private static final String SEARCH_COL_ARTICLE_TITLE = "article_title";
	private static final String SEARCH_COL_LANG = "lang";

	private static final int POPULAR_LIMIT = 25;

	private final OsmandApplication application;

	private TravelLocalDataHelper localDataHelper;
	private Collator collator;

	private SQLiteConnection connection = null;

	private File selectedTravelBook = null;
	private List<File> existingTravelBooks = new ArrayList<>();
	private List<TravelArticle> popularArticles = new ArrayList<TravelArticle>();
	
	
	public TravelDbHelper(OsmandApplication application) {
		this.application = application;
		collator = OsmAndCollator.primaryCollator();
		localDataHelper = new TravelLocalDataHelper(application);
	}

	public TravelLocalDataHelper getLocalDataHelper() {
		return localDataHelper;
	}

	public void initTravelBooks() {
		File[] possibleFiles = application.getAppPath(IndexConstants.WIKIVOYAGE_INDEX_DIR).listFiles();
		String travelBook = application.getSettings().SELECTED_TRAVEL_BOOK.get();
		existingTravelBooks.clear();
		if (possibleFiles != null && possibleFiles.length > 0) {
			for (File f : possibleFiles) {
				if (f.getName().endsWith(IndexConstants.BINARY_WIKIVOYAGE_MAP_INDEX_EXT)) {
					existingTravelBooks.add(f);
					if (selectedTravelBook == null) {
						selectedTravelBook = f;
					} else if (Algorithms.objectEquals(travelBook, f.getName())) {
						selectedTravelBook = f;
					}
				}
			}
		} else {
			selectedTravelBook = null;
		}
	}
	
	public void loadDataForSelectedTravelBook() {
		localDataHelper.refreshCachedData();
		loadPopularArticles();
	}

	public File getSelectedTravelBook() {
		return selectedTravelBook;
	}

	public List<File> getExistingTravelBooks() {
		return existingTravelBooks;
	}

	@Nullable
	private SQLiteConnection openConnection() {
		if (connection == null && selectedTravelBook != null) {
			application.getSettings().SELECTED_TRAVEL_BOOK.set(selectedTravelBook.getName());
			connection = application.getSQLiteAPI().openByAbsolutePath(selectedTravelBook.getAbsolutePath(), true);
		}
		return connection;
	}

	public void selectTravelBook(File f) {
		closeConnection();
		if (f.exists()) {
			connection = application.getSQLiteAPI().openByAbsolutePath(f.getAbsolutePath(), true);
			selectedTravelBook = f;
			application.getSettings().SELECTED_TRAVEL_BOOK.set(selectedTravelBook.getName());
		}
	}

	private void closeConnection() {
		if (connection != null) {
			connection.close();
			connection = null;
		}
	}

	@NonNull
	public List<WikivoyageSearchResult> search(final String searchQuery) {
		List<WikivoyageSearchResult> res = new ArrayList<>();
		SQLiteConnection conn = openConnection();
		String[] queries = searchQuery.replace('_', ' ').replace('/', ' ').split(" ");
		if (conn != null) {
			List<String> params = new ArrayList<>();
			String query = "SELECT  distinct wa.city_id, wa.title, wa.lang, wa.is_part_of, wa.image_title "
					+ "FROM wikivoyage_articles wa WHERE wa.city_id in "
					+ " (SELECT city_id FROM wikivoyage_search WHERE search_term LIKE";
			for (String q : queries) {
				if (q.trim().length() > 0) {
					if (params.size() > 5) {
						// don't explode the query search much
						break;
					}
					if (params.size() > 0) {
						query += " AND city_id IN (SELECT city_id FROM wikivoyage_search WHERE search_term LIKE ?) ";
					} else {
						query += "?";
					}
					params.add(q.trim() + "%");
				}
			}
			query += ") ";
			if (params.size() > 0) {
				SQLiteCursor cursor = conn.rawQuery(query, params.toArray(new String[params.size()]));
				if (cursor.moveToFirst()) {
					do {
						WikivoyageSearchResult rs = new WikivoyageSearchResult();
						rs.cityId = cursor.getLong(0);
						rs.articleTitles.add(cursor.getString(1));
						rs.langs.add(cursor.getString(2));
						rs.isPartOf.add(cursor.getString(3));
						rs.imageTitle = cursor.getString(4);
						res.add(rs);
					} while (cursor.moveToNext());
				}
				cursor.close();
			}
		}

		List<WikivoyageSearchResult> list = new ArrayList<>(groupSearchResultsByCityId(res));
		sortSearchResults(searchQuery, list);

		return list;
	}

	@NonNull
	public List<TravelArticle> getPopularArticles() {
		return popularArticles;
	}
	
	@NonNull
	public List<TravelArticle> loadPopularArticles() {
		List<TravelArticle> res = new ArrayList<>();
		String language = application.getLanguage();
		List<PopularArticle> popReadArticles = new ArrayList<>();
		SQLiteConnection conn = openConnection();
		if (conn != null) {
			SQLiteCursor cursor = conn.rawQuery(POP_ARTICLES_TABLE_SELECT, null);
			if (cursor.moveToFirst()) {
				do {
					PopularArticle travelArticle = PopularArticle.readArticle(cursor);
					if(language.equals(travelArticle.lang)) {
						popReadArticles.add(travelArticle);
					}
				} while (cursor.moveToNext());
			}
			cursor.close();
		}
		sortPopArticlesByDistance(popReadArticles);
		StringBuilder bld = new StringBuilder();
		bld.append(ARTICLES_TABLE_SELECT).append(" WHERE "+ARTICLES_COL_LANG+" = '"+language+"'"
				+ " and "+ARTICLES_COL_CITY_ID+" IN (");
		for (int i = 0; i < popReadArticles.size() && i < POPULAR_LIMIT; i++) {
			if (i > 0) {
				bld.append(", ");
			}
			bld.append(popReadArticles.get(i).cityId);
		}
		bld.append(")");
		SQLiteCursor cursor = conn.rawQuery(bld.toString(), null);
		if (cursor.moveToFirst()) {
			do {
				TravelArticle travelArticle = readArticle(cursor);
				res.add(travelArticle);
			} while (cursor.moveToNext());
		}
		cursor.close();
		sortArticlesByDistance(res);
		popularArticles = res;
		return res;
	}

	private void sortSearchResults(final String searchQuery, List<WikivoyageSearchResult> list) {
		Collections.sort(list, new Comparator<WikivoyageSearchResult>() {
			@Override
			public int compare(WikivoyageSearchResult o1, WikivoyageSearchResult o2) {
				boolean c1 = CollatorStringMatcher.cmatches(collator, searchQuery, o1.articleTitles.get(0),
						StringMatcherMode.CHECK_ONLY_STARTS_WITH);
				boolean c2 = CollatorStringMatcher.cmatches(collator, searchQuery, o2.articleTitles.get(0),
						StringMatcherMode.CHECK_ONLY_STARTS_WITH);
				if (c1 == c2) {
					return collator.compare(o1.articleTitles.get(0), o2.articleTitles.get(0));
				} else if (c1) {
					return -1;
				} else if (c2) {
					return 1;
				}
				return 0;
			}
		});
	}

	private void sortArticlesByDistance(List<TravelArticle> list) {
		Location location = application.getLocationProvider().getLastKnownLocation();
		if (location != null) {
			final LatLon loc = new LatLon(location.getLatitude(), location.getLongitude());
			Collections.sort(list, new Comparator<TravelArticle>() {
				@Override
				public int compare(TravelArticle article1, TravelArticle article2) {
					return Double.compare(MapUtils.getDistance(loc, article1.getLat(), article1.getLon()), MapUtils.getDistance(loc, article2.getLat(), article2.getLon()));
				}
			});
		}
	}
	
	private void sortPopArticlesByDistance(List<PopularArticle> list) {
		Location location = application.getLocationProvider().getLastKnownLocation();
		if (location != null) {
			final LatLon loc = new LatLon(location.getLatitude(), location.getLongitude());
			Collections.sort(list, new Comparator<PopularArticle>() {
				@Override
				public int compare(PopularArticle article1, PopularArticle article2) {
					return Double.compare(MapUtils.getDistance(loc, article1.lat, article1.lon), 
							MapUtils.getDistance(loc, article2.lat, article2.lon));
				}
			});
		}
	}

	private Collection<WikivoyageSearchResult> groupSearchResultsByCityId(List<WikivoyageSearchResult> res) {
		String baseLng = application.getLanguage();
		TLongObjectHashMap<WikivoyageSearchResult> wikivoyage = new TLongObjectHashMap<>();
		for (WikivoyageSearchResult rs : res) {
			WikivoyageSearchResult prev = wikivoyage.get(rs.cityId);
			if (prev != null) {
				int insInd = prev.langs.size();
				if (rs.langs.get(0).equals(baseLng)) {
					insInd = 0;
				} else if (rs.langs.get(0).equals("en")) {
					if (!prev.langs.get(0).equals(baseLng)) {
						insInd = 0;
					} else {
						insInd = 1;
					}
				}
				prev.articleTitles.add(insInd, rs.articleTitles.get(0));
				prev.langs.add(insInd, rs.langs.get(0));
				prev.isPartOf.add(insInd, rs.isPartOf.get(0));
			} else {
				wikivoyage.put(rs.cityId, rs);
			}
		}
		return wikivoyage.valueCollection();
	}

	@NonNull
	public LinkedHashMap<WikivoyageSearchResult, List<WikivoyageSearchResult>> getNavigationMap(final TravelArticle article) {
		String lang = article.getLang();
		String title = article.getTitle();
		if (TextUtils.isEmpty(lang) || TextUtils.isEmpty(title)) {
			return new LinkedHashMap<>();
		}
		String[] parts = null;
		if (!TextUtils.isEmpty(article.getAggregatedPartOf())) {
			String[] originalParts = article.getAggregatedPartOf().split(",");
			if (originalParts.length > 1) {
				parts = new String[originalParts.length];
				for (int i = 0; i < originalParts.length; i++) {
					parts[i] = originalParts[originalParts.length - i - 1];
				}
			} else {
				parts = originalParts;
			}
		}
		Map<String, List<WikivoyageSearchResult>> navMap = new HashMap<>();
		SQLiteConnection conn = openConnection();
		Set<String> headers = null;
		Map<String, WikivoyageSearchResult> headerObjs = new HashMap<>();
		if (conn != null) {
			List<String> params = new ArrayList<>();
			StringBuilder query = new StringBuilder("SELECT a.city_id, a.title, a.lang, a.is_part_of " +
					"FROM wikivoyage_articles a WHERE is_part_of = ? and lang = ? ");
			params.add(title);
			params.add(lang);
			if (parts != null && parts.length > 0) {
				headers = new HashSet<>(Arrays.asList(parts));
				headers.add(title);
				query.append("UNION SELECT a.city_id, a.title, a.lang, a.is_part_of " +
						"FROM wikivoyage_articles a WHERE title = ? and lang = ? ");
				params.add(parts[0]);
				params.add(lang);
				for (String part : parts) {
					query.append("UNION SELECT a.city_id, a.title, a.lang, a.is_part_of " +
							"FROM wikivoyage_articles a WHERE is_part_of = ? and lang = ? ");
					params.add(part);
					params.add(lang);
				}
			}
			SQLiteCursor cursor = conn.rawQuery(query.toString(), params.toArray(new String[params.size()]));
			if (cursor.moveToFirst()) {
				do {
					WikivoyageSearchResult rs = new WikivoyageSearchResult();
					rs.cityId = cursor.getLong(0);
					rs.articleTitles.add(cursor.getString(1));
					rs.langs.add(cursor.getString(2));
					rs.isPartOf.add(cursor.getString(3));
					List<WikivoyageSearchResult> l = navMap.get(rs.isPartOf.get(0));
					if (l == null) {
						l = new ArrayList<>();
						navMap.put(rs.isPartOf.get(0), l);
					}
					l.add(rs);
					String key = rs.getArticleTitles().get(0);
					if (headers != null && headers.contains(key)) {
						headerObjs.put(key, rs);
					}
				} while (cursor.moveToNext());
			}
			cursor.close();
		}
		LinkedHashMap<WikivoyageSearchResult, List<WikivoyageSearchResult>> res = new LinkedHashMap<>();
		if (parts != null) {
			for (String header : parts) {
				WikivoyageSearchResult searchResult = headerObjs.get(header);
				List<WikivoyageSearchResult> results = navMap.get(header);
				if (results != null) {
					Collections.sort(results, new Comparator<WikivoyageSearchResult>() {
						@Override
						public int compare(WikivoyageSearchResult o1, WikivoyageSearchResult o2) {
							return collator.compare(o1.articleTitles.get(0), o2.articleTitles.get(0));
						}
					});
					WikivoyageSearchResult emptyResult = new WikivoyageSearchResult();
					emptyResult.articleTitles.add(header);
					emptyResult.cityId = -1;
					searchResult = searchResult != null ? searchResult : emptyResult;
					res.put(searchResult, results);
				}
			}
		}
		return res;
	}

	@Nullable
	public TravelArticle getArticle(long cityId, String lang) {
		TravelArticle res = null;
		SQLiteConnection conn = openConnection();
		if (conn != null) {
			SQLiteCursor cursor = conn.rawQuery(ARTICLES_TABLE_SELECT + " WHERE " + ARTICLES_COL_CITY_ID + " = ? AND "
					+ ARTICLES_COL_LANG + " = ?", new String[]{String.valueOf(cityId), lang});
			if (cursor.moveToFirst()) {
				res = readArticle(cursor);
			}
			cursor.close();
		}
		return res;
	}

	public long getArticleId(String title, String lang) {
		long res = 0;
		SQLiteConnection conn = openConnection();
		if (conn != null) {
			SQLiteCursor cursor = conn.rawQuery("SELECT " + ARTICLES_COL_CITY_ID + " FROM "
					+ ARTICLES_TABLE_NAME + " WHERE " + ARTICLES_COL_TITLE + " = ? AND "
					+ ARTICLES_COL_LANG + " = ?", new String[]{title, lang});
			if (cursor.moveToFirst()) {
				res = cursor.getLong(0);
			}
			cursor.close();
		}
		return res;
	}

	@NonNull
	public ArrayList<String> getArticleLangs(long cityId) {
		ArrayList<String> res = new ArrayList<>();
		SQLiteConnection conn = openConnection();
		if (conn != null) {
			SQLiteCursor cursor = conn.rawQuery("SELECT " + ARTICLES_COL_LANG + " FROM " + ARTICLES_TABLE_NAME
					+ " WHERE " + ARTICLES_COL_CITY_ID + " = ?", new String[]{String.valueOf(cityId)});
			if (cursor.moveToFirst()) {
				String baseLang = application.getLanguage();
				do {
					String lang = cursor.getString(0);
					if (lang.equals(baseLang)) {
						res.add(0, lang);
					} else if (lang.equals("en")) {
						if (res.size() > 0 && res.get(0).equals(baseLang)) {
							res.add(1, lang);
						} else {
							res.add(0, lang);
						}
					} else {
						res.add(lang);
					}
				} while (cursor.moveToNext());
			}
			cursor.close();
		}
		return res;
	}

	@NonNull
	private TravelArticle readArticle(SQLiteCursor cursor) {
		TravelArticle res = new TravelArticle();

		res.id = cursor.getString(0);
		res.title = cursor.getString(1);
		try {
			res.content = Algorithms.gzipToString(cursor.getBlob(2));
		} catch (IOException e) {
			LOG.error(e.getMessage(), e);
		}
		res.isPartOf = cursor.getString(3);
		res.lat = cursor.isNull(4) ? Double.NaN : cursor.getDouble(4);
		res.lon = cursor.isNull(5) ? Double.NaN : cursor.getDouble(5);
		res.imageTitle = cursor.getString(6);
		res.cityId = cursor.getLong(8);
		res.originalId = cursor.isNull(9) ? 0 : cursor.getLong(9);
		res.lang = cursor.getString(10);
		res.contentsJson = cursor.getString(11);
		res.aggregatedPartOf = cursor.getString(12);
		try {
			String gpxContent = Algorithms.gzipToString(cursor.getBlob(7));
			res.gpxFile = GPXUtilities.loadGPXFile(application, new ByteArrayInputStream(gpxContent.getBytes("UTF-8")));
		} catch (IOException e) {
			LOG.error(e.getMessage(), e);
		}

		return res;
	}

	public String formatTravelBookName(File tb) {
		if (tb == null) {
			return application.getString(R.string.shared_string_none);
		}
		String nm = tb.getName();
		return nm.substring(0, nm.indexOf('.')).replace('_', ' ');
	}

	public String getGPXName(TravelArticle article) {
		return article.getTitle().replace('/', '_').replace('\'', '_').replace('\"', '_') + ".gpx";
	}

	public File createGpxFile(TravelArticle article) {
		final GPXFile gpx = article.getGpxFile();
		File file = application.getAppPath(IndexConstants.GPX_TRAVEL_DIR + getGPXName(article));
		if (!file.exists()) {
			GPXUtilities.writeGpxFile(file, gpx, application);
		}
		return file;
	}
	
	private static class PopularArticle {
		long cityId;
		String title;
		String lang;
		int popIndex;
		double lat;
		double lon;
		
		public boolean isLocationSpecified() {
			return !Double.isNaN(lat) && !Double.isNaN(lon);
		}
		
		public static PopularArticle readArticle(SQLiteCursor cursor) {
			PopularArticle res = new PopularArticle();
			res.title = cursor.getString(0);
			res.lat = cursor.isNull(1) ? Double.NaN : cursor.getDouble(1);
			res.lon = cursor.isNull(2) ? Double.NaN : cursor.getDouble(2);
			res.cityId = cursor.getLong(3);
			res.lang = cursor.getString(4);
			res.popIndex = cursor.isNull(5) ? 0 : cursor.getInt(5);
			return res;
		}
	}
}
!@#$%
20190530_071000,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_a01380
package net.osmand.plus.wikivoyage.data;

import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.text.TextUtils;

import net.osmand.Collator;
import net.osmand.CollatorStringMatcher;
import net.osmand.CollatorStringMatcher.StringMatcherMode;
import net.osmand.IndexConstants;
import net.osmand.Location;
import net.osmand.OsmAndCollator;
import net.osmand.PlatformUtil;
import net.osmand.data.LatLon;
import net.osmand.plus.GPXUtilities;
import net.osmand.plus.GPXUtilities.GPXFile;
import net.osmand.plus.OsmandApplication;
import net.osmand.plus.R;
import net.osmand.plus.api.SQLiteAPI.SQLiteConnection;
import net.osmand.plus.api.SQLiteAPI.SQLiteCursor;
import net.osmand.util.Algorithms;
import net.osmand.util.MapUtils;

import org.apache.commons.logging.Log;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import gnu.trove.map.hash.TLongObjectHashMap;

public class TravelDbHelper {

	private static final Log LOG = PlatformUtil.getLog(TravelDbHelper.class);

	private static final String ARTICLES_TABLE_NAME = "wikivoyage_articles";
	private static final String ARTICLES_COL_ID = "article_id";
	private static final String ARTICLES_COL_TITLE = "title";
	private static final String ARTICLES_COL_CONTENT = "content_gz";
	private static final String ARTICLES_COL_IS_PART_OF = "is_part_of";
	private static final String ARTICLES_COL_LAT = "lat";
	private static final String ARTICLES_COL_LON = "lon";
	private static final String ARTICLES_COL_IMAGE_TITLE = "image_title";
	private static final String ARTICLES_COL_GPX_GZ = "gpx_gz";
	private static final String ARTICLES_COL_CITY_ID = "city_id";
	private static final String ARTICLES_COL_ORIGINAL_ID = "original_id";
	private static final String ARTICLES_COL_LANG = "lang";
	private static final String ARTICLES_COL_CONTENTS_JSON = "contents_json";
	private static final String ARTICLES_COL_AGGREGATED_PART_OF = "aggregated_part_of";

	private static final String ARTICLES_TABLE_SELECT = "SELECT " +
			ARTICLES_COL_ID + ", " +
			ARTICLES_COL_TITLE + ", " +
			ARTICLES_COL_CONTENT + ", " +
			ARTICLES_COL_IS_PART_OF + ", " +
			ARTICLES_COL_LAT + ", " +
			ARTICLES_COL_LON + ", " +
			ARTICLES_COL_IMAGE_TITLE + ", " +
			ARTICLES_COL_GPX_GZ + ", " +
			ARTICLES_COL_CITY_ID + ", " +
			ARTICLES_COL_ORIGINAL_ID + ", " +
			ARTICLES_COL_LANG + ", " +
			ARTICLES_COL_CONTENTS_JSON + ", " +
			ARTICLES_COL_AGGREGATED_PART_OF +
			" FROM " + ARTICLES_TABLE_NAME;

	private static final String SEARCH_TABLE_NAME = "wikivoyage_search";
	private static final String SEARCH_COL_SEARCH_TERM = "search_term";
	private static final String SEARCH_COL_CITY_ID = "city_id";
	private static final String SEARCH_COL_ARTICLE_TITLE = "article_title";
	private static final String SEARCH_COL_LANG = "lang";

	private final OsmandApplication application;

	private TravelLocalDataHelper localDataHelper;
	private Collator collator;

	private SQLiteConnection connection = null;

	private File selectedTravelBook = null;
	private List<File> existingTravelBooks = new ArrayList<>();
	private List<TravelArticle> popularArticles = new ArrayList<TravelArticle>();

	public TravelDbHelper(OsmandApplication application) {
		this.application = application;
		collator = OsmAndCollator.primaryCollator();
		localDataHelper = new TravelLocalDataHelper(application);
	}

	public TravelLocalDataHelper getLocalDataHelper() {
		return localDataHelper;
	}

	public void initTravelBooks() {
		File[] possibleFiles = application.getAppPath(IndexConstants.WIKIVOYAGE_INDEX_DIR).listFiles();
		String travelBook = application.getSettings().SELECTED_TRAVEL_BOOK.get();
		existingTravelBooks.clear();
		if (possibleFiles != null && possibleFiles.length > 0) {
			for (File f : possibleFiles) {
				if (f.getName().endsWith(IndexConstants.BINARY_WIKIVOYAGE_MAP_INDEX_EXT)) {
					existingTravelBooks.add(f);
					if (selectedTravelBook == null) {
						selectedTravelBook = f;
					} else if (Algorithms.objectEquals(travelBook, f.getName())) {
						selectedTravelBook = f;
					}
				}
			}
		} else {
			selectedTravelBook = null;
		}
	}
	
	public void loadDataForSelectedTravelBook() {
		localDataHelper.refreshCachedData();
		loadPopularArticles();
	}

	public File getSelectedTravelBook() {
		return selectedTravelBook;
	}

	public List<File> getExistingTravelBooks() {
		return existingTravelBooks;
	}

	@Nullable
	private SQLiteConnection openConnection() {
		if (connection == null && selectedTravelBook != null) {
			application.getSettings().SELECTED_TRAVEL_BOOK.set(selectedTravelBook.getName());
			connection = application.getSQLiteAPI().openByAbsolutePath(selectedTravelBook.getAbsolutePath(), true);
		}
		return connection;
	}

	public void selectTravelBook(File f) {
		closeConnection();
		if (f.exists()) {
			connection = application.getSQLiteAPI().openByAbsolutePath(f.getAbsolutePath(), true);
			selectedTravelBook = f;
			application.getSettings().SELECTED_TRAVEL_BOOK.set(selectedTravelBook.getName());
		}
	}

	private void closeConnection() {
		if (connection != null) {
			connection.close();
			connection = null;
		}
	}

	@NonNull
	public List<WikivoyageSearchResult> search(final String searchQuery) {
		List<WikivoyageSearchResult> res = new ArrayList<>();
		SQLiteConnection conn = openConnection();
		String[] queries = searchQuery.replace('_', ' ').replace('/', ' ').split(" ");
		if (conn != null) {
			List<String> params = new ArrayList<>();
			String query = "SELECT  distinct wa.city_id, wa.title, wa.lang, wa.is_part_of, wa.image_title "
					+ "FROM wikivoyage_articles wa WHERE wa.city_id in "
					+ " (SELECT city_id FROM wikivoyage_search WHERE search_term LIKE";
			for (String q : queries) {
				if (q.trim().length() > 0) {
					if (params.size() > 5) {
						// don't explode the query search much
						break;
					}
					if (params.size() > 0) {
						query += " AND city_id IN (SELECT city_id FROM wikivoyage_search WHERE search_term LIKE ?) ";
					} else {
						query += "?";
					}
					params.add(q.trim() + "%");
				}
			}
			query += ") ";
			if (params.size() > 0) {
				SQLiteCursor cursor = conn.rawQuery(query, params.toArray(new String[params.size()]));
				if (cursor.moveToFirst()) {
					do {
						WikivoyageSearchResult rs = new WikivoyageSearchResult();
						rs.cityId = cursor.getLong(0);
						rs.articleTitles.add(cursor.getString(1));
						rs.langs.add(cursor.getString(2));
						rs.isPartOf.add(cursor.getString(3));
						rs.imageTitle = cursor.getString(4);
						res.add(rs);
					} while (cursor.moveToNext());
				}
				cursor.close();
			}
		}

		List<WikivoyageSearchResult> list = new ArrayList<>(groupSearchResultsByCityId(res));
		sortSearchResults(searchQuery, list);

		return list;
	}

	@NonNull
	public List<TravelArticle> getPopularArticles() {
		return popularArticles;
	}
	
	@NonNull
	public List<TravelArticle> loadPopularArticles() {
		List<TravelArticle> res = new ArrayList<>();
		SQLiteConnection conn = openConnection();
		if (conn != null) {
			TravelArticle travelArticle;
			SQLiteCursor cursor = conn.rawQuery("SELECT * FROM "
					+ ARTICLES_TABLE_NAME
					+ " WHERE article_id IN (SELECT article_id FROM "
					+ ARTICLES_TABLE_NAME
					+ " ORDER BY RANDOM() LIMIT 20) LIMIT 20", null);
			if (cursor.moveToFirst()) {
				do {
					travelArticle = readArticle(cursor);
					res.add(travelArticle);
				} while (cursor.moveToNext());
			}
			cursor.close();
		}
		sortArticlesByDistance(res);
		popularArticles = res;
		return res;
	}

	private void sortSearchResults(final String searchQuery, List<WikivoyageSearchResult> list) {
		Collections.sort(list, new Comparator<WikivoyageSearchResult>() {
			@Override
			public int compare(WikivoyageSearchResult o1, WikivoyageSearchResult o2) {
				boolean c1 = CollatorStringMatcher.cmatches(collator, searchQuery, o1.articleTitles.get(0),
						StringMatcherMode.CHECK_ONLY_STARTS_WITH);
				boolean c2 = CollatorStringMatcher.cmatches(collator, searchQuery, o2.articleTitles.get(0),
						StringMatcherMode.CHECK_ONLY_STARTS_WITH);
				if (c1 == c2) {
					return collator.compare(o1.articleTitles.get(0), o2.articleTitles.get(0));
				} else if (c1) {
					return -1;
				} else if (c2) {
					return 1;
				}
				return 0;
			}
		});
	}

	private void sortArticlesByDistance(List<TravelArticle> list) {
		Location location = application.getLocationProvider().getLastKnownLocation();
		if (location != null) {
			final LatLon loc = new LatLon(location.getLatitude(), location.getLongitude());
			Collections.sort(list, new Comparator<TravelArticle>() {
				@Override
				public int compare(TravelArticle article1, TravelArticle article2) {
					int d1 = (int) MapUtils.getDistance(loc, article1.getLat(), article1.getLon());
					int d2 = (int) MapUtils.getDistance(loc, article2.getLat(), article2.getLon());
					if (d1 > d2) {
						return 1;
					} else if (d1 == d2) {
						return 0;
					} else {
						return -1;
					}
				}
			});
		}
	}

	private Collection<WikivoyageSearchResult> groupSearchResultsByCityId(List<WikivoyageSearchResult> res) {
		String baseLng = application.getLanguage();
		TLongObjectHashMap<WikivoyageSearchResult> wikivoyage = new TLongObjectHashMap<>();
		for (WikivoyageSearchResult rs : res) {
			WikivoyageSearchResult prev = wikivoyage.get(rs.cityId);
			if (prev != null) {
				int insInd = prev.langs.size();
				if (rs.langs.get(0).equals(baseLng)) {
					insInd = 0;
				} else if (rs.langs.get(0).equals("en")) {
					if (!prev.langs.get(0).equals(baseLng)) {
						insInd = 0;
					} else {
						insInd = 1;
					}
				}
				prev.articleTitles.add(insInd, rs.articleTitles.get(0));
				prev.langs.add(insInd, rs.langs.get(0));
				prev.isPartOf.add(insInd, rs.isPartOf.get(0));
			} else {
				wikivoyage.put(rs.cityId, rs);
			}
		}
		return wikivoyage.valueCollection();
	}

	@NonNull
	public LinkedHashMap<WikivoyageSearchResult, List<WikivoyageSearchResult>> getNavigationMap(final TravelArticle article) {
		String lang = article.getLang();
		String title = article.getTitle();
		if (TextUtils.isEmpty(lang) || TextUtils.isEmpty(title)) {
			return new LinkedHashMap<>();
		}
		String[] parts = null;
		if (!TextUtils.isEmpty(article.getAggregatedPartOf())) {
			String[] originalParts = article.getAggregatedPartOf().split(",");
			if (originalParts.length > 1) {
				parts = new String[originalParts.length];
				for (int i = 0; i < originalParts.length; i++) {
					parts[i] = originalParts[originalParts.length - i - 1];
				}
			} else {
				parts = originalParts;
			}
		}
		Map<String, List<WikivoyageSearchResult>> navMap = new HashMap<>();
		SQLiteConnection conn = openConnection();
		Set<String> headers = null;
		Map<String, WikivoyageSearchResult> headerObjs = new HashMap<>();
		if (conn != null) {
			List<String> params = new ArrayList<>();
			StringBuilder query = new StringBuilder("SELECT a.city_id, a.title, a.lang, a.is_part_of " +
					"FROM wikivoyage_articles a WHERE is_part_of = ? and lang = ? ");
			params.add(title);
			params.add(lang);
			if (parts != null && parts.length > 0) {
				headers = new HashSet<>(Arrays.asList(parts));
				headers.add(title);
				query.append("UNION SELECT a.city_id, a.title, a.lang, a.is_part_of " +
						"FROM wikivoyage_articles a WHERE title = ? and lang = ? ");
				params.add(parts[0]);
				params.add(lang);
				for (String part : parts) {
					query.append("UNION SELECT a.city_id, a.title, a.lang, a.is_part_of " +
							"FROM wikivoyage_articles a WHERE is_part_of = ? and lang = ? ");
					params.add(part);
					params.add(lang);
				}
			}
			SQLiteCursor cursor = conn.rawQuery(query.toString(), params.toArray(new String[params.size()]));
			if (cursor.moveToFirst()) {
				do {
					WikivoyageSearchResult rs = new WikivoyageSearchResult();
					rs.cityId = cursor.getLong(0);
					rs.articleTitles.add(cursor.getString(1));
					rs.langs.add(cursor.getString(2));
					rs.isPartOf.add(cursor.getString(3));
					List<WikivoyageSearchResult> l = navMap.get(rs.isPartOf.get(0));
					if (l == null) {
						l = new ArrayList<>();
						navMap.put(rs.isPartOf.get(0), l);
					}
					l.add(rs);
					String key = rs.getArticleTitles().get(0);
					if (headers != null && headers.contains(key)) {
						headerObjs.put(key, rs);
					}
				} while (cursor.moveToNext());
			}
			cursor.close();
		}
		LinkedHashMap<WikivoyageSearchResult, List<WikivoyageSearchResult>> res = new LinkedHashMap<>();
		if (parts != null) {
			for (String header : parts) {
				WikivoyageSearchResult searchResult = headerObjs.get(header);
				List<WikivoyageSearchResult> results = navMap.get(header);
				if (results != null) {
					Collections.sort(results, new Comparator<WikivoyageSearchResult>() {
						@Override
						public int compare(WikivoyageSearchResult o1, WikivoyageSearchResult o2) {
							return collator.compare(o1.articleTitles.get(0), o2.articleTitles.get(0));
						}
					});
					WikivoyageSearchResult emptyResult = new WikivoyageSearchResult();
					emptyResult.articleTitles.add(header);
					emptyResult.cityId = -1;
					searchResult = searchResult != null ? searchResult : emptyResult;
					res.put(searchResult, results);
				}
			}
		}
		return res;
	}

	@Nullable
	public TravelArticle getArticle(long cityId, String lang) {
		TravelArticle res = null;
		SQLiteConnection conn = openConnection();
		if (conn != null) {
			SQLiteCursor cursor = conn.rawQuery(ARTICLES_TABLE_SELECT + " WHERE " + ARTICLES_COL_CITY_ID + " = ? AND "
					+ ARTICLES_COL_LANG + " = ?", new String[]{String.valueOf(cityId), lang});
			if (cursor.moveToFirst()) {
				res = readArticle(cursor);
			}
			cursor.close();
		}
		return res;
	}

	public long getArticleId(String title, String lang) {
		long res = 0;
		SQLiteConnection conn = openConnection();
		if (conn != null) {
			SQLiteCursor cursor = conn.rawQuery("SELECT " + ARTICLES_COL_CITY_ID + " FROM "
					+ ARTICLES_TABLE_NAME + " WHERE " + ARTICLES_COL_TITLE + " = ? AND "
					+ ARTICLES_COL_LANG + " = ?", new String[]{title, lang});
			if (cursor.moveToFirst()) {
				res = cursor.getLong(0);
			}
			cursor.close();
		}
		return res;
	}

	@NonNull
	public ArrayList<String> getArticleLangs(long cityId) {
		ArrayList<String> res = new ArrayList<>();
		SQLiteConnection conn = openConnection();
		if (conn != null) {
			SQLiteCursor cursor = conn.rawQuery("SELECT " + ARTICLES_COL_LANG + " FROM " + ARTICLES_TABLE_NAME
					+ " WHERE " + ARTICLES_COL_CITY_ID + " = ?", new String[]{String.valueOf(cityId)});
			if (cursor.moveToFirst()) {
				String baseLang = application.getLanguage();
				do {
					String lang = cursor.getString(0);
					if (lang.equals(baseLang)) {
						res.add(0, lang);
					} else if (lang.equals("en")) {
						if (res.size() > 0 && res.get(0).equals(baseLang)) {
							res.add(1, lang);
						} else {
							res.add(0, lang);
						}
					} else {
						res.add(lang);
					}
				} while (cursor.moveToNext());
			}
			cursor.close();
		}
		return res;
	}

	@NonNull
	private TravelArticle readArticle(SQLiteCursor cursor) {
		TravelArticle res = new TravelArticle();

		res.id = cursor.getString(0);
		res.title = cursor.getString(1);
		try {
			res.content = Algorithms.gzipToString(cursor.getBlob(2));
		} catch (IOException e) {
			LOG.error(e.getMessage(), e);
		}
		res.isPartOf = cursor.getString(3);
		res.lat = cursor.getDouble(4);
		res.lon = cursor.getDouble(5);
		res.imageTitle = cursor.getString(6);
		res.cityId = cursor.getLong(8);
		res.originalId = cursor.getLong(9);
		res.lang = cursor.getString(10);
		res.contentsJson = cursor.getString(11);
		res.aggregatedPartOf = cursor.getString(12);
		try {
			String gpxContent = Algorithms.gzipToString(cursor.getBlob(7));
			res.gpxFile = GPXUtilities.loadGPXFile(application, new ByteArrayInputStream(gpxContent.getBytes("UTF-8")));
		} catch (IOException e) {
			LOG.error(e.getMessage(), e);
		}

		return res;
	}

	public String formatTravelBookName(File tb) {
		if (tb == null) {
			return application.getString(R.string.shared_string_none);
		}
		String nm = tb.getName();
		return nm.substring(0, nm.indexOf('.')).replace('_', ' ');
	}

	public String getGPXName(TravelArticle article) {
		return article.getTitle().replace('/', '_').replace('\'', '_').replace('\"', '_') + ".gpx";
	}

	public File createGpxFile(TravelArticle article) {
		final GPXFile gpx = article.getGpxFile();
		File file = application.getAppPath(IndexConstants.GPX_TRAVEL_DIR + getGPXName(article));
		if (!file.exists()) {
			GPXUtilities.writeGpxFile(file, gpx, application);
		}
		return file;
	}
}
!@#$%
20190530_071000,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_c01380
package net.osmand.plus.wikivoyage.data;

import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.text.TextUtils;

import net.osmand.Collator;
import net.osmand.CollatorStringMatcher;
import net.osmand.CollatorStringMatcher.StringMatcherMode;
import net.osmand.IndexConstants;
import net.osmand.Location;
import net.osmand.OsmAndCollator;
import net.osmand.PlatformUtil;
import net.osmand.data.LatLon;
import net.osmand.plus.GPXUtilities;
import net.osmand.plus.GPXUtilities.GPXFile;
import net.osmand.plus.OsmandApplication;
import net.osmand.plus.R;
import net.osmand.plus.api.SQLiteAPI.SQLiteConnection;
import net.osmand.plus.api.SQLiteAPI.SQLiteCursor;
import net.osmand.util.Algorithms;
import net.osmand.util.MapUtils;

import org.apache.commons.logging.Log;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import gnu.trove.map.hash.TLongObjectHashMap;

public class TravelDbHelper {

	private static final Log LOG = PlatformUtil.getLog(TravelDbHelper.class);

	private static final String ARTICLES_TABLE_NAME = "wikivoyage_articles";
	private static final String ARTICLES_COL_ID = "article_id";
	private static final String ARTICLES_COL_TITLE = "title";
	private static final String ARTICLES_COL_CONTENT = "content_gz";
	private static final String ARTICLES_COL_IS_PART_OF = "is_part_of";
	private static final String ARTICLES_COL_LAT = "lat";
	private static final String ARTICLES_COL_LON = "lon";
	private static final String ARTICLES_COL_IMAGE_TITLE = "image_title";
	private static final String ARTICLES_COL_GPX_GZ = "gpx_gz";
	private static final String ARTICLES_COL_CITY_ID = "city_id";
	private static final String ARTICLES_COL_ORIGINAL_ID = "original_id";
	private static final String ARTICLES_COL_LANG = "lang";
	private static final String ARTICLES_COL_CONTENTS_JSON = "contents_json";
	private static final String ARTICLES_COL_AGGREGATED_PART_OF = "aggregated_part_of";

	private static final String ARTICLES_TABLE_SELECT = "SELECT " +
			ARTICLES_COL_ID + ", " +
			ARTICLES_COL_TITLE + ", " +
			ARTICLES_COL_CONTENT + ", " +
			ARTICLES_COL_IS_PART_OF + ", " +
			ARTICLES_COL_LAT + ", " +
			ARTICLES_COL_LON + ", " +
			ARTICLES_COL_IMAGE_TITLE + ", " +
			ARTICLES_COL_GPX_GZ + ", " +
			ARTICLES_COL_CITY_ID + ", " +
			ARTICLES_COL_ORIGINAL_ID + ", " +
			ARTICLES_COL_LANG + ", " +
			ARTICLES_COL_CONTENTS_JSON + ", " +
			ARTICLES_COL_AGGREGATED_PART_OF +
			" FROM " + ARTICLES_TABLE_NAME;

	private static final String SEARCH_TABLE_NAME = "wikivoyage_search";
	private static final String SEARCH_COL_SEARCH_TERM = "search_term";
	private static final String SEARCH_COL_CITY_ID = "city_id";
	private static final String SEARCH_COL_ARTICLE_TITLE = "article_title";
	private static final String SEARCH_COL_LANG = "lang";

	private final OsmandApplication application;

	private TravelLocalDataHelper localDataHelper;
	private Collator collator;

	private SQLiteConnection connection = null;

	private File selectedTravelBook = null;
	private List<File> existingTravelBooks = new ArrayList<>();
	private List<TravelArticle> popularArticles = new ArrayList<TravelArticle>();

	public TravelDbHelper(OsmandApplication application) {
		this.application = application;
		collator = OsmAndCollator.primaryCollator();
		localDataHelper = new TravelLocalDataHelper(application);
	}

	public TravelLocalDataHelper getLocalDataHelper() {
		return localDataHelper;
	}

	public void initTravelBooks() {
		File[] possibleFiles = application.getAppPath(IndexConstants.WIKIVOYAGE_INDEX_DIR).listFiles();
		String travelBook = application.getSettings().SELECTED_TRAVEL_BOOK.get();
		existingTravelBooks.clear();
		if (possibleFiles != null && possibleFiles.length > 0) {
			for (File f : possibleFiles) {
				if (f.getName().endsWith(IndexConstants.BINARY_WIKIVOYAGE_MAP_INDEX_EXT)) {
					existingTravelBooks.add(f);
					if (selectedTravelBook == null) {
						selectedTravelBook = f;
					} else if (Algorithms.objectEquals(travelBook, f.getName())) {
						selectedTravelBook = f;
					}
				}
			}
		} else {
			selectedTravelBook = null;
		}
	}

	public void loadDataForSelectedTravelBook() {
		localDataHelper.refreshCachedData();
		loadPopularArticles();
	}

	public File getSelectedTravelBook() {
		return selectedTravelBook;
	}

	public List<File> getExistingTravelBooks() {
		return existingTravelBooks;
	}

	@Nullable
	private SQLiteConnection openConnection() {
		if (connection == null && selectedTravelBook != null) {
			application.getSettings().SELECTED_TRAVEL_BOOK.set(selectedTravelBook.getName());
			connection = application.getSQLiteAPI().openByAbsolutePath(selectedTravelBook.getAbsolutePath(), true);
		}
		return connection;
	}

	public void selectTravelBook(File f) {
		closeConnection();
		if (f.exists()) {
			connection = application.getSQLiteAPI().openByAbsolutePath(f.getAbsolutePath(), true);
			selectedTravelBook = f;
			application.getSettings().SELECTED_TRAVEL_BOOK.set(selectedTravelBook.getName());
		}
	}

	private void closeConnection() {
		if (connection != null) {
			connection.close();
			connection = null;
		}
	}

	@NonNull
	public List<WikivoyageSearchResult> search(final String searchQuery) {
		List<WikivoyageSearchResult> res = new ArrayList<>();
		SQLiteConnection conn = openConnection();
		String[] queries = searchQuery.replace('_', ' ').replace('/', ' ').split(" ");
		if (conn != null) {
			List<String> params = new ArrayList<>();
			String query = "SELECT  distinct wa.city_id, wa.title, wa.lang, wa.is_part_of, wa.image_title "
					+ "FROM wikivoyage_articles wa WHERE wa.city_id in "
					+ " (SELECT city_id FROM wikivoyage_search WHERE search_term LIKE";
			for (String q : queries) {
				if (q.trim().length() > 0) {
					if (params.size() > 5) {
						// don't explode the query search much
						break;
					}
					if (params.size() > 0) {
						query += " AND city_id IN (SELECT city_id FROM wikivoyage_search WHERE search_term LIKE ?) ";
					} else {
						query += "?";
					}
					params.add(q.trim() + "%");
				}
			}
			query += ") ";
			if (params.size() > 0) {
				SQLiteCursor cursor = conn.rawQuery(query, params.toArray(new String[params.size()]));
				if (cursor.moveToFirst()) {
					do {
						WikivoyageSearchResult rs = new WikivoyageSearchResult();
						rs.cityId = cursor.getLong(0);
						rs.articleTitles.add(cursor.getString(1));
						rs.langs.add(cursor.getString(2));
						rs.isPartOf.add(cursor.getString(3));
						rs.imageTitle = cursor.getString(4);
						res.add(rs);
					} while (cursor.moveToNext());
				}
				cursor.close();
			}
		}

		List<WikivoyageSearchResult> list = new ArrayList<>(groupSearchResultsByCityId(res));
		sortSearchResults(searchQuery, list);

		return list;
	}

	@NonNull
	public List<TravelArticle> getPopularArticles() {
		return popularArticles;
	}

	@NonNull
	public List<TravelArticle> loadPopularArticles() {
		List<TravelArticle> res = new ArrayList<>();
		SQLiteConnection conn = openConnection();
		if (conn != null) {
			TravelArticle travelArticle;
			SQLiteCursor cursor = conn.rawQuery("SELECT * FROM "
					+ ARTICLES_TABLE_NAME
					+ " WHERE article_id IN (SELECT article_id FROM "
					+ ARTICLES_TABLE_NAME
					+ " ORDER BY RANDOM() LIMIT 20) LIMIT 20", null);
			if (cursor.moveToFirst()) {
				do {
					travelArticle = readArticle(cursor);
					res.add(travelArticle);
				} while (cursor.moveToNext());
			}
			cursor.close();
		}
		sortArticlesByDistance(res);
		popularArticles = res;
		return res;
	}

	private void sortSearchResults(final String searchQuery, List<WikivoyageSearchResult> list) {
		Collections.sort(list, new Comparator<WikivoyageSearchResult>() {
			@Override
			public int compare(WikivoyageSearchResult o1, WikivoyageSearchResult o2) {
				boolean c1 = CollatorStringMatcher.cmatches(collator, searchQuery, o1.articleTitles.get(0),
						StringMatcherMode.CHECK_ONLY_STARTS_WITH);
				boolean c2 = CollatorStringMatcher.cmatches(collator, searchQuery, o2.articleTitles.get(0),
						StringMatcherMode.CHECK_ONLY_STARTS_WITH);
				if (c1 == c2) {
					return collator.compare(o1.articleTitles.get(0), o2.articleTitles.get(0));
				} else if (c1) {
					return -1;
				} else if (c2) {
					return 1;
				}
				return 0;
			}
		});
	}

	private void sortArticlesByDistance(List<TravelArticle> list) {
		Location location = application.getLocationProvider().getLastKnownLocation();
		if (location != null) {
			final LatLon loc = new LatLon(location.getLatitude(), location.getLongitude());
			Collections.sort(list, new Comparator<TravelArticle>() {
				@Override
				public int compare(TravelArticle article1, TravelArticle article2) {
					int d1 = (int) MapUtils.getDistance(loc, article1.getLat(), article1.getLon());
					int d2 = (int) MapUtils.getDistance(loc, article2.getLat(), article2.getLon());
					if (d1 > d2) {
						return 1;
					} else if (d1 == d2) {
						return 0;
					} else {
						return -1;
					}
				}
			});
		}
	}

	private Collection<WikivoyageSearchResult> groupSearchResultsByCityId(List<WikivoyageSearchResult> res) {
		String baseLng = application.getLanguage();
		TLongObjectHashMap<WikivoyageSearchResult> wikivoyage = new TLongObjectHashMap<>();
		for (WikivoyageSearchResult rs : res) {
			WikivoyageSearchResult prev = wikivoyage.get(rs.cityId);
			if (prev != null) {
				int insInd = prev.langs.size();
				if (rs.langs.get(0).equals(baseLng)) {
					insInd = 0;
				} else if (rs.langs.get(0).equals("en")) {
					if (!prev.langs.get(0).equals(baseLng)) {
						insInd = 0;
					} else {
						insInd = 1;
					}
				}
				prev.articleTitles.add(insInd, rs.articleTitles.get(0));
				prev.langs.add(insInd, rs.langs.get(0));
				prev.isPartOf.add(insInd, rs.isPartOf.get(0));
			} else {
				wikivoyage.put(rs.cityId, rs);
			}
		}
		return wikivoyage.valueCollection();
	}

	@NonNull
	public LinkedHashMap<WikivoyageSearchResult, List<WikivoyageSearchResult>> getNavigationMap(final TravelArticle article) {
		String lang = article.getLang();
		String title = article.getTitle();
		if (TextUtils.isEmpty(lang) || TextUtils.isEmpty(title)) {
			return new LinkedHashMap<>();
		}
		String[] parts = null;
		if (!TextUtils.isEmpty(article.getAggregatedPartOf())) {
			String[] originalParts = article.getAggregatedPartOf().split(",");
			if (originalParts.length > 1) {
				parts = new String[originalParts.length];
				for (int i = 0; i < originalParts.length; i++) {
					parts[i] = originalParts[originalParts.length - i - 1];
				}
			} else {
				parts = originalParts;
			}
		}
		Map<String, List<WikivoyageSearchResult>> navMap = new HashMap<>();
		SQLiteConnection conn = openConnection();
		Set<String> headers = null;
		Map<String, WikivoyageSearchResult> headerObjs = new HashMap<>();
		if (conn != null) {
			List<String> params = new ArrayList<>();
			StringBuilder query = new StringBuilder("SELECT a.city_id, a.title, a.lang, a.is_part_of " +
					"FROM wikivoyage_articles a WHERE is_part_of = ? and lang = ? ");
			params.add(title);
			params.add(lang);
			if (parts != null && parts.length > 0) {
				headers = new HashSet<>(Arrays.asList(parts));
				headers.add(title);
				query.append("UNION SELECT a.city_id, a.title, a.lang, a.is_part_of " +
						"FROM wikivoyage_articles a WHERE title = ? and lang = ? ");
				params.add(parts[0]);
				params.add(lang);
				for (String part : parts) {
					query.append("UNION SELECT a.city_id, a.title, a.lang, a.is_part_of " +
							"FROM wikivoyage_articles a WHERE is_part_of = ? and lang = ? ");
					params.add(part);
					params.add(lang);
				}
			}
			SQLiteCursor cursor = conn.rawQuery(query.toString(), params.toArray(new String[params.size()]));
			if (cursor.moveToFirst()) {
				do {
					WikivoyageSearchResult rs = new WikivoyageSearchResult();
					rs.cityId = cursor.getLong(0);
					rs.articleTitles.add(cursor.getString(1));
					rs.langs.add(cursor.getString(2));
					rs.isPartOf.add(cursor.getString(3));
					List<WikivoyageSearchResult> l = navMap.get(rs.isPartOf.get(0));
					if (l == null) {
						l = new ArrayList<>();
						navMap.put(rs.isPartOf.get(0), l);
					}
					l.add(rs);
					String key = rs.getArticleTitles().get(0);
					if (headers != null && headers.contains(key)) {
						headerObjs.put(key, rs);
					}
				} while (cursor.moveToNext());
			}
			cursor.close();
		}
		LinkedHashMap<WikivoyageSearchResult, List<WikivoyageSearchResult>> res = new LinkedHashMap<>();
		if (parts != null) {
			for (String header : parts) {
				WikivoyageSearchResult searchResult = headerObjs.get(header);
				List<WikivoyageSearchResult> results = navMap.get(header);
				if (results != null) {
					Collections.sort(results, new Comparator<WikivoyageSearchResult>() {
						@Override
						public int compare(WikivoyageSearchResult o1, WikivoyageSearchResult o2) {
							return collator.compare(o1.articleTitles.get(0), o2.articleTitles.get(0));
						}
					});
					WikivoyageSearchResult emptyResult = new WikivoyageSearchResult();
					emptyResult.articleTitles.add(header);
					emptyResult.cityId = -1;
					searchResult = searchResult != null ? searchResult : emptyResult;
					res.put(searchResult, results);
				}
			}
		}
		return res;
	}

	@Nullable
	public TravelArticle getArticle(long cityId, String lang) {
		TravelArticle res = null;
		SQLiteConnection conn = openConnection();
		if (conn != null) {
			SQLiteCursor cursor = conn.rawQuery(ARTICLES_TABLE_SELECT + " WHERE " + ARTICLES_COL_CITY_ID + " = ? AND "
					+ ARTICLES_COL_LANG + " = ?", new String[]{String.valueOf(cityId), lang});
			if (cursor.moveToFirst()) {
				res = readArticle(cursor);
			}
			cursor.close();
		}
		return res;
	}

	public long getArticleId(String title, String lang) {
		long res = 0;
		SQLiteConnection conn = openConnection();
		if (conn != null) {
			SQLiteCursor cursor = conn.rawQuery("SELECT " + ARTICLES_COL_CITY_ID + " FROM "
					+ ARTICLES_TABLE_NAME + " WHERE " + ARTICLES_COL_TITLE + " = ? AND "
					+ ARTICLES_COL_LANG + " = ?", new String[]{title, lang});
			if (cursor.moveToFirst()) {
				res = cursor.getLong(0);
			}
			cursor.close();
		}
		return res;
	}

	@NonNull
	public ArrayList<String> getArticleLangs(long cityId) {
		ArrayList<String> res = new ArrayList<>();
		SQLiteConnection conn = openConnection();
		if (conn != null) {
			SQLiteCursor cursor = conn.rawQuery("SELECT " + ARTICLES_COL_LANG + " FROM " + ARTICLES_TABLE_NAME
					+ " WHERE " + ARTICLES_COL_CITY_ID + " = ?", new String[]{String.valueOf(cityId)});
			if (cursor.moveToFirst()) {
				String baseLang = application.getLanguage();
				do {
					String lang = cursor.getString(0);
					if (lang.equals(baseLang)) {
						res.add(0, lang);
					} else if (lang.equals("en")) {
						if (res.size() > 0 && res.get(0).equals(baseLang)) {
							res.add(1, lang);
						} else {
							res.add(0, lang);
						}
					} else {
						res.add(lang);
					}
				} while (cursor.moveToNext());
			}
			cursor.close();
		}
		return res;
	}

	@NonNull
	private TravelArticle readArticle(SQLiteCursor cursor) {
		TravelArticle res = new TravelArticle();

		res.id = cursor.getString(0);
		res.title = cursor.getString(1);
		try {
			res.content = Algorithms.gzipToString(cursor.getBlob(2));
		} catch (IOException e) {
			LOG.error(e.getMessage(), e);
		}
		res.isPartOf = cursor.getString(3);
		res.lat = cursor.getDouble(4);
		res.lon = cursor.getDouble(5);
		res.imageTitle = cursor.getString(6);
		res.cityId = cursor.getLong(8);
		res.originalId = cursor.getLong(9);
		res.lang = cursor.getString(10);
		res.contentsJson = cursor.getString(11);
		res.aggregatedPartOf = cursor.getString(12);
		try {
			String gpxContent = Algorithms.gzipToString(cursor.getBlob(7));
			res.gpxFile = GPXUtilities.loadGPXFile(application, new ByteArrayInputStream(gpxContent.getBytes("UTF-8")));
		} catch (IOException e) {
			LOG.error(e.getMessage(), e);
		}

		return res;
	}

	public String formatTravelBookName(File tb) {
		if (tb == null) {
			return application.getString(R.string.shared_string_none);
		}
		String nm = tb.getName();
		return nm.substring(0, nm.indexOf('.')).replace('_', ' ');
	}

	public String getGPXName(TravelArticle article) {
		return article.getTitle().replace('/', '_').replace('\'', '_').replace('\"', '_') + ".gpx";
	}

	public File createGpxFile(TravelArticle article) {
		final GPXFile gpx = article.getGpxFile();
		File file = application.getAppPath(IndexConstants.GPX_TRAVEL_DIR + getGPXName(article));
		if (!file.exists()) {
			GPXUtilities.writeGpxFile(file, gpx, application);
		}
		return file;
	}
}
!@#$%
20190530_074946,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_b01944
package net.osmand.router;

import gnu.trove.iterator.TIntIterator;
import gnu.trove.list.array.TIntArrayList;
import gnu.trove.map.hash.TIntObjectHashMap;
import gnu.trove.map.hash.TLongObjectHashMap;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.PriorityQueue;

import net.osmand.binary.BinaryMapIndexReader;
import net.osmand.binary.BinaryMapIndexReader.SearchRequest;
import net.osmand.data.LatLon;
import net.osmand.data.TransportRoute;
import net.osmand.data.TransportSchedule;
import net.osmand.data.TransportStop;
import net.osmand.osm.edit.Node;
import net.osmand.osm.edit.Way;
import net.osmand.util.MapUtils;

public class TransportRoutePlanner {
	


	public List<TransportRouteResult> buildRoute(TransportRoutingContext ctx, LatLon start, LatLon end) throws IOException {
		ctx.startCalcTime = System.currentTimeMillis();
		List<TransportRouteSegment> startStops = ctx.getTransportStops(start);
		List<TransportRouteSegment> endStops = ctx.getTransportStops(end);
		
		TLongObjectHashMap<TransportRouteSegment> endSegments = new TLongObjectHashMap<TransportRouteSegment>();
		for(TransportRouteSegment s : endStops) {
			endSegments.put(s.getId(), s);
		}
		PriorityQueue<TransportRouteSegment> queue = new PriorityQueue<TransportRouteSegment>(new SegmentsComparator(ctx));
		for(TransportRouteSegment r : startStops){
			r.walkDist = (float) MapUtils.getDistance(r.getLocation(), start);
			r.distFromStart = r.walkDist / ctx.cfg.walkSpeed;
			queue.add(r);
		}
		double finishTime = ctx.cfg.maxRouteTime;
		List<TransportRouteSegment> results = new ArrayList<TransportRouteSegment>();
		
		while (!queue.isEmpty()) {
			TransportRouteSegment segment = queue.poll();
			TransportRouteSegment ex = ctx.visitedSegments.get(segment.getId());
			if(ex != null) {
				if(ex.distFromStart > segment.distFromStart) {
					System.err.println(String.format("%.1f (%s) > %.1f (%s)", ex.distFromStart, ex, segment.distFromStart, segment));
				}
				continue;
			}
			ctx.visitedRoutesCount++;
			System.out.println(segment);
			ctx.visitedSegments.put(segment.getId(), segment);
			if (segment.getDepth() > ctx.cfg.maxNumberOfChanges) {
				continue;
			}
			if (segment.distFromStart > finishTime + ctx.cfg.finishTimeSeconds) {
				break;
			}
			long segmentId = segment.getId();
			TransportRouteSegment finish = null;
			double minDist = 0;
			double travelDist = 0;
			double travelTime = 0;
			TransportStop prevStop = segment.getStop(segment.segStart);
			List<TransportRouteSegment> sgms = new ArrayList<TransportRouteSegment>();
			for (int ind = 1 + segment.segStart; ind < segment.getLength(); ind++) {
				segmentId ++; 
				ctx.visitedSegments.put(segmentId, segment);
				TransportStop stop = segment.getStop(ind);
				// could be geometry size
				double segmentDist = MapUtils.getDistance(prevStop.getLocation(), stop.getLocation());
				travelDist += segmentDist;
				if(ctx.cfg.useSchedule) {
					TransportSchedule sc = segment.road.getSchedule();
					int interval = sc.avgStopIntervals.get(ind - 1);
					travelTime += interval * 10;
				} else {
					travelTime += ctx.cfg.stopTime + segmentDist / ctx.cfg.travelSpeed;
				}
				sgms.clear();
				sgms = ctx.getTransportStops(stop.x31, stop.y31, true, sgms);
				for (TransportRouteSegment sgm : sgms) {
					if (segment.wasVisited(sgm)) {
						continue;
					}
					TransportRouteSegment rrs = new TransportRouteSegment(sgm);
					rrs.parentRoute = segment;
					rrs.parentStop = ind;
					rrs.walkDist = MapUtils.getDistance(rrs.getLocation(), stop.getLocation());
					rrs.parentTravelTime = travelTime;
					rrs.parentTravelDist = travelDist;
					double walkTime = rrs.walkDist / ctx.cfg.walkSpeed
							+ (ctx.cfg.getChangeTime());
					rrs.distFromStart = segment.distFromStart + travelTime + walkTime;
					if(ctx.cfg.useSchedule) {
						int tm = (sgm.departureTime - ctx.cfg.scheduleTimeOfDay) * 10;
						if(tm >= rrs.distFromStart) {
							rrs.distFromStart = tm;
							queue.add(rrs);
						}
					} else {
						queue.add(rrs);
					}
				}
				TransportRouteSegment f = endSegments.get(segmentId);
				double distToEnd = MapUtils.getDistance(stop.getLocation(), end);
				if (f != null && distToEnd < ctx.cfg.walkRadius) {
					if (finish == null || minDist > distToEnd) {
						minDist = distToEnd;
						finish = new TransportRouteSegment(f);
						finish.parentRoute = segment;
						finish.parentStop = ind;
						finish.walkDist = distToEnd;
						finish.parentTravelTime = travelTime;
						finish.parentTravelDist = travelDist;

						double walkTime = distToEnd / ctx.cfg.walkSpeed;
						finish.distFromStart = segment.distFromStart + travelTime + walkTime;

					}
				}
				prevStop = stop;
			}
			if (finish != null) {
				if (finishTime > finish.distFromStart) {
					finishTime = finish.distFromStart;
				}
				if(finish.distFromStart < finishTime + ctx.cfg.finishTimeSeconds) {
					results.add(finish);
				}
			}
		}
		
		return prepareResults(ctx, results);
	}

	private List<TransportRouteResult> prepareResults(TransportRoutingContext ctx, List<TransportRouteSegment> results) {
		Collections.sort(results, new SegmentsComparator(ctx));
		List<TransportRouteResult> lst = new ArrayList<TransportRouteResult>();
		System.out.println(String.format("Calculated %.1f seconds, found %d results, visited %d routes, loaded %d tiles (%d ms read, %d ms total),",
				(System.currentTimeMillis() - ctx.startCalcTime) / 1000.0, results.size(), ctx.visitedRoutesCount, 
				ctx.quadTree.size(), ctx.readTime / (1000 * 1000), ctx.loadTime / (1000 * 1000)));
		for(TransportRouteSegment res : results) {
			TransportRouteResult route = new TransportRouteResult(ctx);
			route.routeTime = res.distFromStart;
			route.finishWalkDist = res.walkDist;
			TransportRouteSegment p = res;
			while (p != null) {
				if (p.parentRoute != null) {
					TransportRouteResultSegment sg = new TransportRouteResultSegment(p.parentRoute.road, 
							p.parentRoute.segStart, p.parentStop, p.parentRoute.walkDist, 
							p.departureTime);
					route.segments.add(0, sg);
				}
				p = p.parentRoute;
			}
			// test if faster routes fully included
			boolean include = false;
			for(TransportRouteResult s : lst) {
				if(includeRoute(s, route)) {
					include = true;
					break;
				}
			}
			if(!include) {
				lst.add(route);
				System.out.println(route.toString());
			} else {
//				System.err.println(route.toString());
			}
		}
		return lst;
	}

	private boolean includeRoute(TransportRouteResult fastRoute, TransportRouteResult testRoute) {
		if(testRoute.segments.size() < fastRoute.segments.size()) {
			return false;
		}
		int j = 0;
		for(int i = 0; i < fastRoute.segments.size(); i++, j++) {
			TransportRouteResultSegment fs = fastRoute.segments.get(i);
			while(j < testRoute.segments.size()) {
				TransportRouteResultSegment ts = testRoute.segments.get(j);
				if(fs.route.getId().longValue() != ts.route.getId().longValue()) {
					j++;	
				} else {
					break;
				}
			}
			if(j >= testRoute.segments.size()) {
				return false;
			}
		}
		
		return true;
	}

	private static class SegmentsComparator implements Comparator<TransportRouteSegment> {

		public SegmentsComparator(TransportRoutingContext ctx) {
		}

		@Override
		public int compare(TransportRouteSegment o1, TransportRouteSegment o2) {
			return Double.compare(o1.distFromStart, o2.distFromStart);
		}
	}
	
	
	public static class TransportRouteResultSegment {
		public final TransportRoute route;
		public final int start;
		public final int end;
		public final double walkDist ;
		public final int depTime;
		
		public TransportRouteResultSegment(TransportRoute route, int start, int end, double walkDist, int depTime) {
			this.route = route;
			this.start = start;
			this.end = end;
			this.walkDist = walkDist;
			this.depTime = depTime;
		}
		
		public int getArrivalTime() {
			if(route.getSchedule() != null && depTime != -1) {
				int tm = depTime;
				TIntArrayList intervals = route.getSchedule().avgStopIntervals;
				for(int i = start; i <= end; i++) {
					if(i == end) {
						return tm;
					}
					if(intervals.size() > i) {
						tm += intervals.get(i); 
					} else {
						break;
					}
				}
			}
			return -1;
		}
		
		public TransportStop getStart() {
			return route.getForwardStops().get(start);
		}
		
		public TransportStop getEnd() {
			return route.getForwardStops().get(end);
		}
		
		public List<Way> getGeometry() {
			List<Way> list = new ArrayList<Way>();
			route.mergeForwardWays();
			List<Way> fw = route.getForwardWays();
			double minStart = 150;
			double minEnd = 150;
			LatLon str = getStart().getLocation();
			LatLon en = getEnd().getLocation();
			int endInd = -1;
			List<Node> res = new ArrayList<Node>();
			for(int i = 0;  i < fw.size() ; i++) {
				List<Node> nodes = fw.get(i).getNodes();
				for(int j = 0; j < nodes.size(); j++) {
					Node n = nodes.get(j);
					if(MapUtils.getDistance(str, n.getLatitude(), n.getLongitude()) < minStart) {
						minStart = MapUtils.getDistance(str, n.getLatitude(), n.getLongitude());
						res.clear();
					}
					res.add(n);
					if(MapUtils.getDistance(en, n.getLatitude(), n.getLongitude()) < minEnd) {
						endInd = res.size();
						minEnd = MapUtils.getDistance(en, n.getLatitude(), n.getLongitude());
					} 
				}
			}
			Way way = new Way(-1);
			if (res.isEmpty()) {
				for (int i = start; i <= end; i++) {
					LatLon l = getStop(i).getLocation();
					Node n = new Node(l.getLatitude(), l.getLongitude(), -1);
					way.addNode(n);
				}
				list.add(way);
			} else {
				for(int k = 0; k < res.size()  && k < endInd; k++) {
					way.addNode(res.get(k));
				}
			}
			list.add(way);
			return list;
			
		}
		
		public double getTravelDist() {
			double d = 0;
			for (int k = start; k < end; k++) {
				d += MapUtils.getDistance(route.getForwardStops().get(k).getLocation(),
						route.getForwardStops().get(k + 1).getLocation());
			}
			return d;
		}

		public TransportStop getStop(int i) {
			return route.getForwardStops().get(i);
		}
	}
	
	public static class TransportRouteResult {
		
		List<TransportRouteResultSegment> segments  = new ArrayList<TransportRouteResultSegment>(4);
		double finishWalkDist;
		double routeTime;
		private final TransportRoutingConfiguration cfg;
		
		public TransportRouteResult(TransportRoutingContext ctx) {
			cfg = ctx.cfg;
		}
		
		public List<TransportRouteResultSegment> getSegments() {
			return segments;
		}
		
		public double getWalkDist() {
			double d = finishWalkDist;
			for (TransportRouteResultSegment s : segments) {
				d += s.walkDist;
			}
			return d;
		}

		public double getFinishWalkDist() {
			return finishWalkDist;
		}

		public double getWalkSpeed() {
			return  cfg.walkSpeed;
		}

		public double getRouteTime() {
			return routeTime;
		}
		
		public int getStops() {
			int stops = 0;
			for(TransportRouteResultSegment s : segments) {
				stops += (s.end - s.start);
			}
			return stops;
		}
		
		public double getTravelDist() {
			double d = 0;
			for (TransportRouteResultSegment s : segments) {
				d += s.getTravelDist();
			}
			return d;
		}
		
		public double getTravelTime() {
			if(cfg.useSchedule) {
				int t = 0;
				for(TransportRouteResultSegment s : segments) {
					TransportSchedule sts = s.route.getSchedule();
					for (int k = s.start; k < s.end; k++) {
						t += sts.getAvgStopIntervals()[k] * 10;
					}
				}
				return t;
			}
			return getTravelDist() / cfg.travelSpeed + cfg.stopTime * getStops() + 
					cfg.getChangeTime() * getChanges();
		}
		
		public double getWalkTime() {
			return getWalkDist() / cfg.walkSpeed;
		}
		
		public int getChanges() {
			return segments.size() - 1;
		}
		
		@Override
		public String toString() {
			StringBuilder bld = new StringBuilder();
			bld.append(String.format("Route %d stops, %d changes, %.2f min: %.2f m (%.1f min) to walk, %.2f m (%.1f min) to travel\n",
					getStops(), getChanges(), routeTime / 60, getWalkDist(), getWalkTime() / 60.0, 
					getTravelDist(), getTravelTime() / 60.0));
			for(int i = 0; i < segments.size(); i++) {
				TransportRouteResultSegment s = segments.get(i);
				String time = "";
				String arriveTime = "";
				if(s.depTime != -1) {
					time = String.format("at %s", formatTransporTime(s.depTime));
				}
				int aTime = s.getArrivalTime();
				if(aTime != -1) {
					arriveTime = String.format("and arrive at %s", formatTransporTime(aTime));
				}
				bld.append(String.format(" %d. %s: walk %.1f m to '%s' and travel %s to '%s' by %s %d stops %s\n",
						i + 1, s.route.getRef(), s.walkDist, s.getStart().getName(), 
						 time, s.getEnd().getName(),s.route.getName(),  (s.end - s.start), arriveTime));
			}
			bld.append(String.format(" F. Walk %.1f m to reach your destination", finishWalkDist));
			return bld.toString();
		}
	}
	
	public static String formatTransporTime(int i) {
		int h = i / 60 / 6;
		int mh = i - h * 60 * 6;
		int m = mh / 6;
		int s = (mh - m * 6) * 10;
		String tm = String.format("%02d:%02d:%02d ", h, m, s);
		return tm;
	}
	
	public static class TransportRouteSegment {
		
		final int segStart;
		final TransportRoute road;
		final int departureTime;
		private static final int SHIFT = 10; // assume less than 1024 stops
		private static final int SHIFT_DEPTIME = 14; // assume less than 1024 stops
		
		TransportRouteSegment parentRoute = null;
		int parentStop;
		double parentTravelTime; // travel time
		double parentTravelDist; // inaccurate
		// walk distance to start route location (or finish in case last segment)
		double walkDist = 0;
		
		// main field accumulated all time spent from beginning of journey
		double distFromStart = 0;
		
		
		
		
		public TransportRouteSegment(TransportRoute road, int stopIndex) {
			this.road = road;
			this.segStart = (short) stopIndex;
			this.departureTime = -1;
		}
		
		public TransportRouteSegment(TransportRoute road, int stopIndex, int depTime) {
			this.road = road;
			this.segStart = (short) stopIndex;
			this.departureTime = depTime;
		}
		
		public TransportRouteSegment(TransportRouteSegment c) {
			this.road = c.road;
			this.segStart = c.segStart;
			this.departureTime = c.departureTime;
		}
		
		
		public boolean wasVisited(TransportRouteSegment rrs) {
			if (rrs.road.getId().longValue() == road.getId().longValue() && 
					rrs.departureTime == departureTime) {
				return true;
			}
			if(parentRoute != null) {
				return parentRoute.wasVisited(rrs);
			}
			return false;
		}


		public TransportStop getStop(int i) {
			return road.getForwardStops().get(i);
		}


		public LatLon getLocation() {
			return road.getForwardStops().get(segStart).getLocation();
		}


		public int getLength() {
			return road.getForwardStops().size();
		}
		
		
		public long getId() {
			long l = road.getId();
			
			l = l << SHIFT_DEPTIME;
			if(departureTime >= (1 << SHIFT_DEPTIME)) {
				throw new IllegalStateException("too long dep time" + departureTime);
			}
			l += (departureTime + 1);

			l = l << SHIFT;
			if (segStart >= (1 << SHIFT)) {
				throw new IllegalStateException("too many stops " + road.getId() + " " + segStart);
			}
			l += segStart;
			
			if(l < 0 ) {
				throw new IllegalStateException("too long id " + road.getId());
			}
			return l  ;
		}

		
		public int getDepth() {
			if(parentRoute != null) {
				return parentRoute.getDepth() + 1;
			}
			return 1;
		}
		
		@Override
		public String toString() {
			return String.format("Route: %s, stop: %s %s", road.getName(), road.getForwardStops().get(segStart).getName(),
					departureTime == -1 ? "" : formatTransporTime(departureTime) );
		}

	}
	
	public static class TransportRoutingContext {
		
		public RouteCalculationProgress calculationProgress;
		public TLongObjectHashMap<TransportRouteSegment> visitedSegments = new TLongObjectHashMap<TransportRouteSegment>();
		public TransportRoutingConfiguration cfg;
		
		
		public TLongObjectHashMap<List<TransportRouteSegment>> quadTree;
		public final Map<BinaryMapIndexReader, TIntObjectHashMap<TransportRoute>> routeMap = 
				new LinkedHashMap<BinaryMapIndexReader, TIntObjectHashMap<TransportRoute>>();
		
		// stats
		public long startCalcTime;
		public int visitedRoutesCount;
		public int wrongLoadedWays;
		public int loadedWays;
		public long loadTime;
		public long readTime;
		
		
		
		private final int walkRadiusIn31;
		private final int walkChangeRadiusIn31;
		
		
		
		
		public TransportRoutingContext(TransportRoutingConfiguration cfg, BinaryMapIndexReader... readers) {
			this.cfg = cfg;
			walkRadiusIn31 = (int) (cfg.walkRadius / MapUtils.getTileDistanceWidth(31));
			walkChangeRadiusIn31 = (int) (cfg.walkChangeRadius / MapUtils.getTileDistanceWidth(31));
			quadTree = new TLongObjectHashMap<List<TransportRouteSegment>>();
			for (BinaryMapIndexReader r : readers) {
				routeMap.put(r, new TIntObjectHashMap<TransportRoute>());
			}
		}
		
		public List<TransportRouteSegment> getTransportStops(LatLon loc) throws IOException {
			int y = MapUtils.get31TileNumberY(loc.getLatitude());
			int x = MapUtils.get31TileNumberX(loc.getLongitude());
			return getTransportStops(x, y, false, new ArrayList<TransportRouteSegment>());
		}
		
		public List<TransportRouteSegment> getTransportStops(int x, int y, boolean change, List<TransportRouteSegment> res) throws IOException {
			return loadNativeTransportStops(x, y, change, res);
		}

		private List<TransportRouteSegment> loadNativeTransportStops(int sx, int sy, boolean change, List<TransportRouteSegment> res) throws IOException {
			long nanoTime = System.nanoTime();
			int d = change ? walkChangeRadiusIn31 : walkRadiusIn31;
			int lx = (sx - d ) >> (31 - cfg.ZOOM_TO_LOAD_TILES);
			int rx = (sx + d ) >> (31 - cfg.ZOOM_TO_LOAD_TILES);
			int ty = (sy - d ) >> (31 - cfg.ZOOM_TO_LOAD_TILES);
			int by = (sy + d ) >> (31 - cfg.ZOOM_TO_LOAD_TILES);
			for(int x = lx; x <= rx; x++) {
				for(int y = ty; y <= by; y++) {
					int tileId = x << (cfg.ZOOM_TO_LOAD_TILES + 1) + y;
					List<TransportRouteSegment> list = quadTree.get(tileId);
					if(list == null) {
						list = loadTile(x, y);
						quadTree.put(tileId, list);
					}
					for(TransportRouteSegment r : list) {
						TransportStop st = r.getStop(r.segStart);
						if (Math.abs(st.x31 - sx) > walkRadiusIn31 || Math.abs(st.y31 - sy) > walkRadiusIn31) {
							wrongLoadedWays++;
						} else {
							loadedWays++;
							res.add(r);
						}
					}
				}
			}
			loadTime += System.nanoTime() - nanoTime;
			return res;
		}


		private List<TransportRouteSegment> loadTile(int x, int y) throws IOException {
			long nanoTime = System.nanoTime();
			List<TransportRouteSegment> lst = new ArrayList<TransportRouteSegment>();
			int pz = (31 - cfg.ZOOM_TO_LOAD_TILES);
			SearchRequest<TransportStop> sr = BinaryMapIndexReader.buildSearchTransportRequest(x << pz, (x + 1) << pz, 
					y << pz, (y + 1) << pz, -1, null);
			TIntArrayList allPoints = new TIntArrayList();
			TIntArrayList allPointsLoad = new TIntArrayList();
			// should it be global?
			TLongObjectHashMap<TransportStop> loadedTransportStops = new TLongObjectHashMap<TransportStop>();
			for(BinaryMapIndexReader r : routeMap.keySet()) {
				sr.clearSearchResults();
				allPoints.clear();
				allPointsLoad.clear();
				
				List<TransportStop> stops = r.searchTransportIndex(sr);
				for(TransportStop s : stops) {
					if(!loadedTransportStops.contains(s.getId())) {
						loadedTransportStops.put(s.getId(), s);
						allPoints.addAll(s.getReferencesToRoutes());
					}
				}
				
				if(allPoints.size() > 0) {
					allPoints.sort();
					TIntObjectHashMap<TransportRoute> loadedRoutes = routeMap.get(r);
					TIntObjectHashMap<TransportRoute> routes  = new TIntObjectHashMap<TransportRoute>();
					TIntIterator it = allPoints.iterator();
					int p = allPoints.get(0) + 1; // different
					while(it.hasNext()) {
						int nxt = it.next();
						if (p != nxt) {
							if (loadedRoutes.contains(nxt)) {
								routes.put(nxt, loadedRoutes.get(nxt));
							} else {
								allPointsLoad.add(nxt);
							}
						}
					}
					r.loadTransportRoutes(allPointsLoad.toArray(), routes);
					loadedRoutes.putAll(routes);
					loadTransportSegments(routes, r, stops, lst);
				}
			}			
			readTime += System.nanoTime() - nanoTime;
			return lst;
		}

		private void loadTransportSegments(TIntObjectHashMap<TransportRoute> routes, BinaryMapIndexReader r,
				List<TransportStop> stops, List<TransportRouteSegment> lst) throws IOException {
			for(TransportStop s : stops) {
				for (int ref : s.getReferencesToRoutes()) {
					TransportRoute route = routes.get(ref);
					if (route != null) {
						int stopIndex = -1;
						double dist = TransportRoute.SAME_STOP;
						for (int k = 0; k < route.getForwardStops().size(); k++) {
							TransportStop st = route.getForwardStops().get(k);
							double d = MapUtils.getDistance(st.getLocation(), s.getLocation());
							if (d < dist) {
								stopIndex = k;
								dist = d; 
							}
						}
						if (stopIndex != -1) {
							if(cfg.useSchedule) {
								loadScheduleRouteSegment(lst, route, stopIndex);
							} else {
								TransportRouteSegment segment = new TransportRouteSegment(route, stopIndex);
								lst.add(segment);
							}
						} else {
							System.err.println("Routing error: missing stop in route");
						}
						
					}
				}
			}
		}

		private void loadScheduleRouteSegment(List<TransportRouteSegment> lst, TransportRoute route, int stopIndex) {
			if(route.getSchedule() != null) {
				TIntArrayList ti = route.getSchedule().tripIntervals;
				int cnt = ti.size();
				int t = 0;
				// improve by using exact data
				int stopTravelTime = 0;
				TIntArrayList avgStopIntervals = route.getSchedule().avgStopIntervals;
				for (int i = 0; i < stopIndex; i++) {
					if (avgStopIntervals.size() > i) {
						stopTravelTime += avgStopIntervals.getQuick(i);
					}
				}
				for(int i = 0; i < cnt; i++) {
					t += ti.getQuick(i);
					int startTime = t + stopTravelTime;
					if(startTime >= cfg.scheduleTimeOfDay && startTime <= cfg.scheduleTimeOfDay + cfg.scheduleMaxTime ) {
						TransportRouteSegment segment = new TransportRouteSegment(route, stopIndex, startTime);
						lst.add(segment);
					}
				}
			}
		}

		

	}

}
!@#$%
20190530_074946,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_a01944
package net.osmand.router;

import gnu.trove.iterator.TIntIterator;
import gnu.trove.list.array.TIntArrayList;
import gnu.trove.map.hash.TIntObjectHashMap;
import gnu.trove.map.hash.TLongObjectHashMap;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.PriorityQueue;

import net.osmand.binary.BinaryMapIndexReader;
import net.osmand.binary.BinaryMapIndexReader.SearchRequest;
import net.osmand.data.LatLon;
import net.osmand.data.TransportRoute;
import net.osmand.data.TransportSchedule;
import net.osmand.data.TransportStop;
import net.osmand.osm.edit.Node;
import net.osmand.osm.edit.Way;
import net.osmand.util.MapUtils;

public class TransportRoutePlanner {
	


	public List<TransportRouteResult> buildRoute(TransportRoutingContext ctx, LatLon start, LatLon end) throws IOException {
		ctx.startCalcTime = System.currentTimeMillis();
		List<TransportRouteSegment> startStops = ctx.getTransportStops(start);
		List<TransportRouteSegment> endStops = ctx.getTransportStops(end);
		
		TLongObjectHashMap<TransportRouteSegment> endSegments = new TLongObjectHashMap<TransportRouteSegment>();
		for(TransportRouteSegment s : endStops) {
			endSegments.put(s.getId(), s);
		}
		PriorityQueue<TransportRouteSegment> queue = new PriorityQueue<TransportRouteSegment>(new SegmentsComparator(ctx));
		for(TransportRouteSegment r : startStops){
			r.walkDist = (float) MapUtils.getDistance(r.getLocation(), start);
			r.distFromStart = r.walkDist / ctx.cfg.walkSpeed;
			queue.add(r);
		}
		double finishTime = ctx.cfg.maxRouteTime;
		List<TransportRouteSegment> results = new ArrayList<TransportRouteSegment>();
		
		while (!queue.isEmpty()) {
			TransportRouteSegment segment = queue.poll();
			TransportRouteSegment ex = ctx.visitedSegments.get(segment.getId());
			if(ex != null) {
				if(ex.distFromStart > segment.distFromStart) {
					System.err.println(String.format("%.1f (%s) > %.1f (%s)", ex.distFromStart, ex, segment.distFromStart, segment));
				}
				continue;
			}
			ctx.visitedRoutesCount++;
			System.out.println(segment);
			ctx.visitedSegments.put(segment.getId(), segment);
			if (segment.getDepth() > ctx.cfg.maxNumberOfChanges) {
				continue;
			}
			if (segment.distFromStart > finishTime + ctx.cfg.finishTimeSeconds) {
				break;
			}
			long segmentId = segment.getId();
			TransportRouteSegment finish = null;
			double minDist = 0;
			double travelDist = 0;
			double travelTime = 0;
			TransportStop prevStop = segment.getStop(segment.segStart);
			List<TransportRouteSegment> sgms = new ArrayList<TransportRouteSegment>();
			for (int ind = 1 + segment.segStart; ind < segment.getLength(); ind++) {
				segmentId ++; 
				ctx.visitedSegments.put(segmentId, segment);
				TransportStop stop = segment.getStop(ind);
				// could be geometry size
				double segmentDist = MapUtils.getDistance(prevStop.getLocation(), stop.getLocation());
				travelDist += segmentDist;
				if(ctx.cfg.useSchedule) {
					TransportSchedule sc = segment.road.getSchedule();
					int interval = sc.avgStopIntervals.get(ind - 1);
					travelTime += interval * 10;
				} else {
					travelTime += ctx.cfg.stopTime + segmentDist / ctx.cfg.travelSpeed;
				}
				sgms.clear();
				sgms = ctx.getTransportStops(stop.x31, stop.y31, true, sgms);
				for (TransportRouteSegment sgm : sgms) {
					if (segment.wasVisited(sgm)) {
						continue;
					}
					TransportRouteSegment rrs = new TransportRouteSegment(sgm);
					rrs.parentRoute = segment;
					rrs.parentStop = ind;
					rrs.walkDist = MapUtils.getDistance(rrs.getLocation(), stop.getLocation());
					rrs.parentTravelTime = travelTime;
					rrs.parentTravelDist = travelDist;
					double walkTime = rrs.walkDist / ctx.cfg.walkSpeed
							+ (ctx.cfg.getChangeTime());
					rrs.distFromStart = segment.distFromStart + travelTime + walkTime;
					if(ctx.cfg.useSchedule) {
						int tm = (sgm.departureTime - ctx.cfg.scheduleTimeOfDay) * 10;
						if(tm >= rrs.distFromStart) {
							rrs.distFromStart = tm;
							queue.add(rrs);
						}
					} else {
						queue.add(rrs);
					}
				}
				TransportRouteSegment f = endSegments.get(segmentId);
				double distToEnd = MapUtils.getDistance(stop.getLocation(), end);
				if (f != null && distToEnd < ctx.cfg.walkRadius) {
					if (finish == null || minDist > distToEnd) {
						minDist = distToEnd;
						finish = new TransportRouteSegment(f);
						finish.parentRoute = segment;
						finish.parentStop = ind;
						finish.walkDist = distToEnd;
						finish.parentTravelTime = travelTime;
						finish.parentTravelDist = travelDist;

						double walkTime = distToEnd / ctx.cfg.walkSpeed;
						finish.distFromStart = segment.distFromStart + travelTime + walkTime;

					}
				}
				prevStop = stop;
			}
			if (finish != null) {
				if (finishTime > finish.distFromStart) {
					finishTime = finish.distFromStart;
				}
				if(finish.distFromStart < finishTime + ctx.cfg.finishTimeSeconds) {
					results.add(finish);
				}
			}
		}
		
		return prepareResults(ctx, results);
	}

	private List<TransportRouteResult> prepareResults(TransportRoutingContext ctx, List<TransportRouteSegment> results) {
		Collections.sort(results, new SegmentsComparator(ctx));
		List<TransportRouteResult> lst = new ArrayList<TransportRouteResult>();
		System.out.println(String.format("Calculated %.1f seconds, found %d results, visited %d routes, loaded %d tiles (%d ms read, %d ms total),",
				(System.currentTimeMillis() - ctx.startCalcTime) / 1000.0, results.size(), ctx.visitedRoutesCount, 
				ctx.quadTree.size(), ctx.readTime / (1000 * 1000), ctx.loadTime / (1000 * 1000)));
		for(TransportRouteSegment res : results) {
			TransportRouteResult route = new TransportRouteResult(ctx);
			route.routeTime = res.distFromStart;
			route.finishWalkDist = res.walkDist;
			TransportRouteSegment p = res;
			while (p != null) {
				if (p.parentRoute != null) {
					TransportRouteResultSegment sg = new TransportRouteResultSegment(p.parentRoute.road, 
							p.parentRoute.segStart, p.parentStop, p.parentRoute.walkDist, 
							p.departureTime);
					route.segments.add(0, sg);
				}
				p = p.parentRoute;
			}
			// test if faster routes fully included
			boolean include = false;
			for(TransportRouteResult s : lst) {
				if(includeRoute(s, route)) {
					include = true;
					break;
				}
			}
			if(!include) {
				lst.add(route);
				System.out.println(route.toString());
			} else {
//				System.err.println(route.toString());
			}
		}
		return lst;
	}

	private boolean includeRoute(TransportRouteResult fastRoute, TransportRouteResult testRoute) {
		if(testRoute.segments.size() < fastRoute.segments.size()) {
			return false;
		}
		int j = 0;
		for(int i = 0; i < fastRoute.segments.size(); i++, j++) {
			TransportRouteResultSegment fs = fastRoute.segments.get(i);
			while(j < testRoute.segments.size()) {
				TransportRouteResultSegment ts = testRoute.segments.get(j);
				if(fs.route.getId().longValue() != ts.route.getId().longValue()) {
					j++;	
				} else {
					break;
				}
			}
			if(j >= testRoute.segments.size()) {
				return false;
			}
		}
		
		return true;
	}

	private static class SegmentsComparator implements Comparator<TransportRouteSegment> {

		public SegmentsComparator(TransportRoutingContext ctx) {
		}

		@Override
		public int compare(TransportRouteSegment o1, TransportRouteSegment o2) {
			return Double.compare(o1.distFromStart, o2.distFromStart);
		}
	}
	
	
	public static class TransportRouteResultSegment {
		public final TransportRoute route;
		public final int start;
		public final int end;
		public final double walkDist ;
		public final int depTime;
		
		public TransportRouteResultSegment(TransportRoute route, int start, int end, double walkDist, int depTime) {
			this.route = route;
			this.start = start;
			this.end = end;
			this.walkDist = walkDist;
			this.depTime = depTime;
		}
		
		public int getArrivalTime() {
			if(route.getSchedule() != null && depTime != -1) {
				int tm = depTime;
				TIntArrayList intervals = route.getSchedule().avgStopIntervals;
				for(int i = start; i <= end; i++) {
					if(i == end) {
						return tm;
					}
					if(intervals.size() > i) {
						tm += intervals.get(i); 
					} else {
						break;
					}
				}
			}
			return -1;
		}
		
		public TransportStop getStart() {
			return route.getForwardStops().get(start);
		}
		
		public TransportStop getEnd() {
			return route.getForwardStops().get(end);
		}
		
		public List<Way> getGeometry() {
			List<Way> list = new ArrayList<Way>();
			route.mergeForwardWays();
			List<Way> fw = route.getForwardWays();
			double minStart = 150;
			double minEnd = 150;
			LatLon str = getStart().getLocation();
			LatLon en = getEnd().getLocation();
			int endInd = -1;
			List<Node> res = new ArrayList<Node>();
			for(int i = 0;  i < fw.size() ; i++) {
				List<Node> nodes = fw.get(i).getNodes();
				for(int j = 0; j < nodes.size(); j++) {
					Node n = nodes.get(j);
					if(MapUtils.getDistance(str, n.getLatitude(), n.getLongitude()) < minStart) {
						minStart = MapUtils.getDistance(str, n.getLatitude(), n.getLongitude());
						res.clear();
					}
					res.add(n);
					if(MapUtils.getDistance(en, n.getLatitude(), n.getLongitude()) < minEnd) {
						endInd = res.size();
						minEnd = MapUtils.getDistance(en, n.getLatitude(), n.getLongitude());
					} 
				}
			}
			Way way = new Way(-1);
			if (res.isEmpty()) {
				for (int i = start; i <= end; i++) {
					LatLon l = getStop(i).getLocation();
					Node n = new Node(l.getLatitude(), l.getLongitude(), -1);
					way.addNode(n);
				}
				list.add(way);
			} else {
				for(int k = 0; k < res.size()  && k < endInd; k++) {
					way.addNode(res.get(k));
				}
			}
			list.add(way);
			return list;
			
		}
		
		public double getTravelDist() {
			double d = 0;
			for (int k = start; k < end; k++) {
				d += MapUtils.getDistance(route.getForwardStops().get(k).getLocation(),
						route.getForwardStops().get(k + 1).getLocation());
			}
			return d;
		}

		public TransportStop getStop(int i) {
			return route.getForwardStops().get(i);
		}
	}
	
	public static class TransportRouteResult {
		
		List<TransportRouteResultSegment> segments  = new ArrayList<TransportRouteResultSegment>(4);
		double finishWalkDist;
		double routeTime;
		private final TransportRoutingConfiguration cfg;
		
		public TransportRouteResult(TransportRoutingContext ctx) {
			cfg = ctx.cfg;
		}
		
		public List<TransportRouteResultSegment> getSegments() {
			return segments;
		}
		
		public double getWalkDist() {
			double d = finishWalkDist;
			for (TransportRouteResultSegment s : segments) {
				d += s.walkDist;
			}
			return d;
		}
		
		public double getRouteTime() {
			return routeTime;
		}
		
		public int getStops() {
			int stops = 0;
			for(TransportRouteResultSegment s : segments) {
				stops += (s.end - s.start);
			}
			return stops;
		}
		
		public double getTravelDist() {
			double d = 0;
			for (TransportRouteResultSegment s : segments) {
				d += s.getTravelDist();
			}
			return d;
		}
		
		public double getTravelTime() {
			if(cfg.useSchedule) {
				int t = 0;
				for(TransportRouteResultSegment s : segments) {
					TransportSchedule sts = s.route.getSchedule();
					for (int k = s.start; k < s.end; k++) {
						t += sts.getAvgStopIntervals()[k] * 10;
					}
				}
				return t;
			}
			return getTravelDist() / cfg.travelSpeed + cfg.stopTime * getStops() + 
					cfg.getChangeTime() * getChanges();
		}
		
		public double getWalkTime() {
			return getWalkDist() / cfg.walkSpeed;
		}
		
		public int getChanges() {
			return segments.size() - 1;
		}
		
		@Override
		public String toString() {
			StringBuilder bld = new StringBuilder();
			bld.append(String.format("Route %d stops, %d changes, %.2f min: %.2f m (%.1f min) to walk, %.2f m (%.1f min) to travel\n",
					getStops(), getChanges(), routeTime / 60, getWalkDist(), getWalkTime() / 60.0, 
					getTravelDist(), getTravelTime() / 60.0));
			for(int i = 0; i < segments.size(); i++) {
				TransportRouteResultSegment s = segments.get(i);
				String time = "";
				String arriveTime = "";
				if(s.depTime != -1) {
					time = String.format("at %s", formatTransporTime(s.depTime));
				}
				int aTime = s.getArrivalTime();
				if(aTime != -1) {
					arriveTime = String.format("and arrive at %s", formatTransporTime(aTime));
				}
				bld.append(String.format(" %d. %s: walk %.1f m to '%s' and travel %s to '%s' by %s %d stops %s\n",
						i + 1, s.route.getRef(), s.walkDist, s.getStart().getName(), 
						 time, s.getEnd().getName(),s.route.getName(),  (s.end - s.start), arriveTime));
			}
			bld.append(String.format(" F. Walk %.1f m to reach your destination", finishWalkDist));
			return bld.toString();
		}
	}
	
	public static String formatTransporTime(int i) {
		int h = i / 60 / 6;
		int mh = i - h * 60 * 6;
		int m = mh / 6;
		int s = (mh - m * 6) * 10;
		String tm = String.format("%02d:%02d:%02d ", h, m, s);
		return tm;
	}
	
	public static class TransportRouteSegment {
		
		final int segStart;
		final TransportRoute road;
		final int departureTime;
		private static final int SHIFT = 10; // assume less than 1024 stops
		private static final int SHIFT_DEPTIME = 14; // assume less than 1024 stops
		
		TransportRouteSegment parentRoute = null;
		int parentStop;
		double parentTravelTime; // travel time
		double parentTravelDist; // inaccurate
		// walk distance to start route location (or finish in case last segment)
		double walkDist = 0;
		
		// main field accumulated all time spent from beginning of journey
		double distFromStart = 0;
		
		
		
		
		public TransportRouteSegment(TransportRoute road, int stopIndex) {
			this.road = road;
			this.segStart = (short) stopIndex;
			this.departureTime = -1;
		}
		
		public TransportRouteSegment(TransportRoute road, int stopIndex, int depTime) {
			this.road = road;
			this.segStart = (short) stopIndex;
			this.departureTime = depTime;
		}
		
		public TransportRouteSegment(TransportRouteSegment c) {
			this.road = c.road;
			this.segStart = c.segStart;
			this.departureTime = c.departureTime;
		}
		
		
		public boolean wasVisited(TransportRouteSegment rrs) {
			if (rrs.road.getId().longValue() == road.getId().longValue() && 
					rrs.departureTime == departureTime) {
				return true;
			}
			if(parentRoute != null) {
				return parentRoute.wasVisited(rrs);
			}
			return false;
		}


		public TransportStop getStop(int i) {
			return road.getForwardStops().get(i);
		}


		public LatLon getLocation() {
			return road.getForwardStops().get(segStart).getLocation();
		}


		public int getLength() {
			return road.getForwardStops().size();
		}
		
		
		public long getId() {
			long l = road.getId();
			
			l = l << SHIFT_DEPTIME;
			if(departureTime >= (1 << SHIFT_DEPTIME)) {
				throw new IllegalStateException("too long dep time" + departureTime);
			}
			l += (departureTime + 1);

			l = l << SHIFT;
			if (segStart >= (1 << SHIFT)) {
				throw new IllegalStateException("too many stops " + road.getId() + " " + segStart);
			}
			l += segStart;
			
			if(l < 0 ) {
				throw new IllegalStateException("too long id " + road.getId());
			}
			return l  ;
		}

		
		public int getDepth() {
			if(parentRoute != null) {
				return parentRoute.getDepth() + 1;
			}
			return 1;
		}
		
		@Override
		public String toString() {
			return String.format("Route: %s, stop: %s %s", road.getName(), road.getForwardStops().get(segStart).getName(),
					departureTime == -1 ? "" : formatTransporTime(departureTime) );
		}

	}
	
	public static class TransportRoutingContext {
		
		public RouteCalculationProgress calculationProgress;
		public TLongObjectHashMap<TransportRouteSegment> visitedSegments = new TLongObjectHashMap<TransportRouteSegment>();
		public TransportRoutingConfiguration cfg;
		
		
		public TLongObjectHashMap<List<TransportRouteSegment>> quadTree;
		public final Map<BinaryMapIndexReader, TIntObjectHashMap<TransportRoute>> routeMap = 
				new LinkedHashMap<BinaryMapIndexReader, TIntObjectHashMap<TransportRoute>>();
		
		// stats
		public long startCalcTime;
		public int visitedRoutesCount;
		public int wrongLoadedWays;
		public int loadedWays;
		public long loadTime;
		public long readTime;
		
		
		
		private final int walkRadiusIn31;
		private final int walkChangeRadiusIn31;
		
		
		
		
		public TransportRoutingContext(TransportRoutingConfiguration cfg, BinaryMapIndexReader... readers) {
			this.cfg = cfg;
			walkRadiusIn31 = (int) (cfg.walkRadius / MapUtils.getTileDistanceWidth(31));
			walkChangeRadiusIn31 = (int) (cfg.walkChangeRadius / MapUtils.getTileDistanceWidth(31));
			quadTree = new TLongObjectHashMap<List<TransportRouteSegment>>();
			for (BinaryMapIndexReader r : readers) {
				routeMap.put(r, new TIntObjectHashMap<TransportRoute>());
			}
		}
		
		public List<TransportRouteSegment> getTransportStops(LatLon loc) throws IOException {
			int y = MapUtils.get31TileNumberY(loc.getLatitude());
			int x = MapUtils.get31TileNumberX(loc.getLongitude());
			return getTransportStops(x, y, false, new ArrayList<TransportRouteSegment>());
		}
		
		public List<TransportRouteSegment> getTransportStops(int x, int y, boolean change, List<TransportRouteSegment> res) throws IOException {
			return loadNativeTransportStops(x, y, change, res);
		}

		private List<TransportRouteSegment> loadNativeTransportStops(int sx, int sy, boolean change, List<TransportRouteSegment> res) throws IOException {
			long nanoTime = System.nanoTime();
			int d = change ? walkChangeRadiusIn31 : walkRadiusIn31;
			int lx = (sx - d ) >> (31 - cfg.ZOOM_TO_LOAD_TILES);
			int rx = (sx + d ) >> (31 - cfg.ZOOM_TO_LOAD_TILES);
			int ty = (sy - d ) >> (31 - cfg.ZOOM_TO_LOAD_TILES);
			int by = (sy + d ) >> (31 - cfg.ZOOM_TO_LOAD_TILES);
			for(int x = lx; x <= rx; x++) {
				for(int y = ty; y <= by; y++) {
					int tileId = x << (cfg.ZOOM_TO_LOAD_TILES + 1) + y;
					List<TransportRouteSegment> list = quadTree.get(tileId);
					if(list == null) {
						list = loadTile(x, y);
						quadTree.put(tileId, list);
					}
					for(TransportRouteSegment r : list) {
						TransportStop st = r.getStop(r.segStart);
						if (Math.abs(st.x31 - sx) > walkRadiusIn31 || Math.abs(st.y31 - sy) > walkRadiusIn31) {
							wrongLoadedWays++;
						} else {
							loadedWays++;
							res.add(r);
						}
					}
				}
			}
			loadTime += System.nanoTime() - nanoTime;
			return res;
		}


		private List<TransportRouteSegment> loadTile(int x, int y) throws IOException {
			long nanoTime = System.nanoTime();
			List<TransportRouteSegment> lst = new ArrayList<TransportRouteSegment>();
			int pz = (31 - cfg.ZOOM_TO_LOAD_TILES);
			SearchRequest<TransportStop> sr = BinaryMapIndexReader.buildSearchTransportRequest(x << pz, (x + 1) << pz, 
					y << pz, (y + 1) << pz, -1, null);
			TIntArrayList allPoints = new TIntArrayList();
			TIntArrayList allPointsLoad = new TIntArrayList();
			// should it be global?
			TLongObjectHashMap<TransportStop> loadedTransportStops = new TLongObjectHashMap<TransportStop>();
			for(BinaryMapIndexReader r : routeMap.keySet()) {
				sr.clearSearchResults();
				allPoints.clear();
				allPointsLoad.clear();
				
				List<TransportStop> stops = r.searchTransportIndex(sr);
				for(TransportStop s : stops) {
					if(!loadedTransportStops.contains(s.getId())) {
						loadedTransportStops.put(s.getId(), s);
						allPoints.addAll(s.getReferencesToRoutes());
					}
				}
				
				if(allPoints.size() > 0) {
					allPoints.sort();
					TIntObjectHashMap<TransportRoute> loadedRoutes = routeMap.get(r);
					TIntObjectHashMap<TransportRoute> routes  = new TIntObjectHashMap<TransportRoute>();
					TIntIterator it = allPoints.iterator();
					int p = allPoints.get(0) + 1; // different
					while(it.hasNext()) {
						int nxt = it.next();
						if (p != nxt) {
							if (loadedRoutes.contains(nxt)) {
								routes.put(nxt, loadedRoutes.get(nxt));
							} else {
								allPointsLoad.add(nxt);
							}
						}
					}
					r.loadTransportRoutes(allPointsLoad.toArray(), routes);
					loadedRoutes.putAll(routes);
					loadTransportSegments(routes, r, stops, lst);
				}
			}			
			readTime += System.nanoTime() - nanoTime;
			return lst;
		}

		private void loadTransportSegments(TIntObjectHashMap<TransportRoute> routes, BinaryMapIndexReader r,
				List<TransportStop> stops, List<TransportRouteSegment> lst) throws IOException {
			for(TransportStop s : stops) {
				for (int ref : s.getReferencesToRoutes()) {
					TransportRoute route = routes.get(ref);
					if (route != null) {
						int stopIndex = -1;
						double dist = TransportRoute.SAME_STOP;
						for (int k = 0; k < route.getForwardStops().size(); k++) {
							TransportStop st = route.getForwardStops().get(k);
							double d = MapUtils.getDistance(st.getLocation(), s.getLocation());
							if (d < dist) {
								stopIndex = k;
								dist = d; 
							}
						}
						if (stopIndex != -1) {
							if(cfg.useSchedule) {
								loadScheduleRouteSegment(lst, route, stopIndex);
							} else {
								TransportRouteSegment segment = new TransportRouteSegment(route, stopIndex);
								lst.add(segment);
							}
						} else {
							System.err.println("Routing error: missing stop in route");
						}
						
					}
				}
			}
		}

		private void loadScheduleRouteSegment(List<TransportRouteSegment> lst, TransportRoute route, int stopIndex) {
			if(route.getSchedule() != null) {
				TIntArrayList ti = route.getSchedule().tripIntervals;
				int cnt = ti.size();
				int t = 0;
				// improve by using exact data
				int stopTravelTime = 0;
				TIntArrayList avgStopIntervals = route.getSchedule().avgStopIntervals;
				for (int i = 0; i < stopIndex; i++) {
					if (avgStopIntervals.size() > i) {
						stopTravelTime += avgStopIntervals.getQuick(i);
					}
				}
				for(int i = 0; i < cnt; i++) {
					t += ti.getQuick(i);
					int startTime = t + stopTravelTime;
					if(startTime >= cfg.scheduleTimeOfDay && startTime <= cfg.scheduleTimeOfDay + cfg.scheduleMaxTime ) {
						TransportRouteSegment segment = new TransportRouteSegment(route, stopIndex, startTime);
						lst.add(segment);
					}
				}
			}
		}

		

	}

}
!@#$%
20190530_074946,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_c01944
package net.osmand.router;

import gnu.trove.iterator.TIntIterator;
import gnu.trove.list.array.TIntArrayList;
import gnu.trove.map.hash.TIntObjectHashMap;
import gnu.trove.map.hash.TLongObjectHashMap;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.PriorityQueue;

import net.osmand.binary.BinaryMapIndexReader;
import net.osmand.binary.BinaryMapIndexReader.SearchRequest;
import net.osmand.data.LatLon;
import net.osmand.data.TransportRoute;
import net.osmand.data.TransportSchedule;
import net.osmand.data.TransportStop;
import net.osmand.osm.edit.Node;
import net.osmand.osm.edit.Way;
import net.osmand.util.MapUtils;

public class TransportRoutePlanner {
	


	public List<TransportRouteResult> buildRoute(TransportRoutingContext ctx, LatLon start, LatLon end) throws IOException {
		ctx.startCalcTime = System.currentTimeMillis();
		List<TransportRouteSegment> startStops = ctx.getTransportStops(start);
		List<TransportRouteSegment> endStops = ctx.getTransportStops(end);
		
		TLongObjectHashMap<TransportRouteSegment> endSegments = new TLongObjectHashMap<TransportRouteSegment>();
		for(TransportRouteSegment s : endStops) {
			endSegments.put(s.getId(), s);
		}
		PriorityQueue<TransportRouteSegment> queue = new PriorityQueue<TransportRouteSegment>(new SegmentsComparator(ctx));
		for(TransportRouteSegment r : startStops){
			r.walkDist = (float) MapUtils.getDistance(r.getLocation(), start);
			r.distFromStart = r.walkDist / ctx.cfg.walkSpeed;
			queue.add(r);
		}
		double finishTime = ctx.cfg.maxRouteTime;
		List<TransportRouteSegment> results = new ArrayList<TransportRouteSegment>();
		
		while (!queue.isEmpty()) {
			TransportRouteSegment segment = queue.poll();
			TransportRouteSegment ex = ctx.visitedSegments.get(segment.getId());
			if(ex != null) {
				if(ex.distFromStart > segment.distFromStart) {
					System.err.println(String.format("%.1f (%s) > %.1f (%s)", ex.distFromStart, ex, segment.distFromStart, segment));
				}
				continue;
			}
			ctx.visitedRoutesCount++;
			System.out.println(segment);
			ctx.visitedSegments.put(segment.getId(), segment);
			if (segment.getDepth() > ctx.cfg.maxNumberOfChanges) {
				continue;
			}
			if (segment.distFromStart > finishTime + ctx.cfg.finishTimeSeconds) {
				break;
			}
			long segmentId = segment.getId();
			TransportRouteSegment finish = null;
			double minDist = 0;
			double travelDist = 0;
			double travelTime = 0;
			TransportStop prevStop = segment.getStop(segment.segStart);
			List<TransportRouteSegment> sgms = new ArrayList<TransportRouteSegment>();
			for (int ind = 1 + segment.segStart; ind < segment.getLength(); ind++) {
				segmentId ++; 
				ctx.visitedSegments.put(segmentId, segment);
				TransportStop stop = segment.getStop(ind);
				// could be geometry size
				double segmentDist = MapUtils.getDistance(prevStop.getLocation(), stop.getLocation());
				travelDist += segmentDist;
				if(ctx.cfg.useSchedule) {
					TransportSchedule sc = segment.road.getSchedule();
					int interval = sc.avgStopIntervals.get(ind - 1);
					travelTime += interval * 10;
				} else {
					travelTime += ctx.cfg.stopTime + segmentDist / ctx.cfg.travelSpeed;
				}
				sgms.clear();
				sgms = ctx.getTransportStops(stop.x31, stop.y31, true, sgms);
				for (TransportRouteSegment sgm : sgms) {
					if (segment.wasVisited(sgm)) {
						continue;
					}
					TransportRouteSegment rrs = new TransportRouteSegment(sgm);
					rrs.parentRoute = segment;
					rrs.parentStop = ind;
					rrs.walkDist = MapUtils.getDistance(rrs.getLocation(), stop.getLocation());
					rrs.parentTravelTime = travelTime;
					rrs.parentTravelDist = travelDist;
					double walkTime = rrs.walkDist / ctx.cfg.walkSpeed
							+ (ctx.cfg.getChangeTime());
					rrs.distFromStart = segment.distFromStart + travelTime + walkTime;
					if(ctx.cfg.useSchedule) {
						int tm = (sgm.departureTime - ctx.cfg.scheduleTimeOfDay) * 10;
						if(tm >= rrs.distFromStart) {
							rrs.distFromStart = tm;
							queue.add(rrs);
						}
					} else {
						queue.add(rrs);
					}
				}
				TransportRouteSegment f = endSegments.get(segmentId);
				double distToEnd = MapUtils.getDistance(stop.getLocation(), end);
				if (f != null && distToEnd < ctx.cfg.walkRadius) {
					if (finish == null || minDist > distToEnd) {
						minDist = distToEnd;
						finish = new TransportRouteSegment(f);
						finish.parentRoute = segment;
						finish.parentStop = ind;
						finish.walkDist = distToEnd;
						finish.parentTravelTime = travelTime;
						finish.parentTravelDist = travelDist;

						double walkTime = distToEnd / ctx.cfg.walkSpeed;
						finish.distFromStart = segment.distFromStart + travelTime + walkTime;

					}
				}
				prevStop = stop;
			}
			if (finish != null) {
				if (finishTime > finish.distFromStart) {
					finishTime = finish.distFromStart;
				}
				if(finish.distFromStart < finishTime + ctx.cfg.finishTimeSeconds) {
					results.add(finish);
				}
			}
		}
		
		return prepareResults(ctx, results);
	}

	private List<TransportRouteResult> prepareResults(TransportRoutingContext ctx, List<TransportRouteSegment> results) {
		Collections.sort(results, new SegmentsComparator(ctx));
		List<TransportRouteResult> lst = new ArrayList<TransportRouteResult>();
		System.out.println(String.format("Calculated %.1f seconds, found %d results, visited %d routes, loaded %d tiles (%d ms read, %d ms total),",
				(System.currentTimeMillis() - ctx.startCalcTime) / 1000.0, results.size(), ctx.visitedRoutesCount, 
				ctx.quadTree.size(), ctx.readTime / (1000 * 1000), ctx.loadTime / (1000 * 1000)));
		for(TransportRouteSegment res : results) {
			TransportRouteResult route = new TransportRouteResult(ctx);
			route.routeTime = res.distFromStart;
			route.finishWalkDist = res.walkDist;
			TransportRouteSegment p = res;
			while (p != null) {
				if (p.parentRoute != null) {
					TransportRouteResultSegment sg = new TransportRouteResultSegment(p.parentRoute.road, 
							p.parentRoute.segStart, p.parentStop, p.parentRoute.walkDist, 
							p.departureTime);
					route.segments.add(0, sg);
				}
				p = p.parentRoute;
			}
			// test if faster routes fully included
			boolean include = false;
			for(TransportRouteResult s : lst) {
				if(includeRoute(s, route)) {
					include = true;
					break;
				}
			}
			if(!include) {
				lst.add(route);
				System.out.println(route.toString());
			} else {
//				System.err.println(route.toString());
			}
		}
		return lst;
	}

	private boolean includeRoute(TransportRouteResult fastRoute, TransportRouteResult testRoute) {
		if(testRoute.segments.size() < fastRoute.segments.size()) {
			return false;
		}
		int j = 0;
		for(int i = 0; i < fastRoute.segments.size(); i++, j++) {
			TransportRouteResultSegment fs = fastRoute.segments.get(i);
			while(j < testRoute.segments.size()) {
				TransportRouteResultSegment ts = testRoute.segments.get(j);
				if(fs.route.getId().longValue() != ts.route.getId().longValue()) {
					j++;	
				} else {
					break;
				}
			}
			if(j >= testRoute.segments.size()) {
				return false;
			}
		}
		
		return true;
	}

	private static class SegmentsComparator implements Comparator<TransportRouteSegment> {

		public SegmentsComparator(TransportRoutingContext ctx) {
		}

		@Override
		public int compare(TransportRouteSegment o1, TransportRouteSegment o2) {
			return Double.compare(o1.distFromStart, o2.distFromStart);
		}
	}
	
	
	public static class TransportRouteResultSegment {
		public final TransportRoute route;
		public final int start;
		public final int end;
		public final double walkDist ;
		public final int depTime;
		
		public TransportRouteResultSegment(TransportRoute route, int start, int end, double walkDist, int depTime) {
			this.route = route;
			this.start = start;
			this.end = end;
			this.walkDist = walkDist;
			this.depTime = depTime;
		}
		
		public int getArrivalTime() {
			if(route.getSchedule() != null && depTime != -1) {
				int tm = depTime;
				TIntArrayList intervals = route.getSchedule().avgStopIntervals;
				for(int i = start; i <= end; i++) {
					if(i == end) {
						return tm;
					}
					if(intervals.size() > i) {
						tm += intervals.get(i); 
					} else {
						break;
					}
				}
			}
			return -1;
		}
		
		public TransportStop getStart() {
			return route.getForwardStops().get(start);
		}
		
		public TransportStop getEnd() {
			return route.getForwardStops().get(end);
		}
		
		public List<Way> getGeometry() {
			List<Way> list = new ArrayList<Way>();
			route.mergeForwardWays();
			List<Way> fw = route.getForwardWays();
			double minStart = 150;
			double minEnd = 150;
			LatLon str = getStart().getLocation();
			LatLon en = getEnd().getLocation();
			int endInd = -1;
			List<Node> res = new ArrayList<Node>();
			for(int i = 0;  i < fw.size() ; i++) {
				List<Node> nodes = fw.get(i).getNodes();
				for(int j = 0; j < nodes.size(); j++) {
					Node n = nodes.get(j);
					if(MapUtils.getDistance(str, n.getLatitude(), n.getLongitude()) < minStart) {
						minStart = MapUtils.getDistance(str, n.getLatitude(), n.getLongitude());
						res.clear();
					}
					res.add(n);
					if(MapUtils.getDistance(en, n.getLatitude(), n.getLongitude()) < minEnd) {
						endInd = res.size();
						minEnd = MapUtils.getDistance(en, n.getLatitude(), n.getLongitude());
					} 
				}
			}
			Way way = new Way(-1);
			if (res.isEmpty()) {
				for (int i = start; i <= end; i++) {
					LatLon l = getStop(i).getLocation();
					Node n = new Node(l.getLatitude(), l.getLongitude(), -1);
					way.addNode(n);
				}
				list.add(way);
			} else {
				for(int k = 0; k < res.size()  && k < endInd; k++) {
					way.addNode(res.get(k));
				}
			}
			list.add(way);
			return list;
			
		}
		
		public double getTravelDist() {
			double d = 0;
			for (int k = start; k < end; k++) {
				d += MapUtils.getDistance(route.getForwardStops().get(k).getLocation(),
						route.getForwardStops().get(k + 1).getLocation());
			}
			return d;
		}

		public TransportStop getStop(int i) {
			return route.getForwardStops().get(i);
		}
	}
	
	public static class TransportRouteResult {
		
		List<TransportRouteResultSegment> segments  = new ArrayList<TransportRouteResultSegment>(4);
		double finishWalkDist;
		double routeTime;
		private final TransportRoutingConfiguration cfg;
		
		public TransportRouteResult(TransportRoutingContext ctx) {
			cfg = ctx.cfg;
		}
		
		public List<TransportRouteResultSegment> getSegments() {
			return segments;
		}

		public double getWalkDist() {
			double d = finishWalkDist;
			for (TransportRouteResultSegment s : segments) {
				d += s.walkDist;
			}
			return d;
		}
		
		public double getRouteTime() {
			return routeTime;
		}
		
		public int getStops() {
			int stops = 0;
			for(TransportRouteResultSegment s : segments) {
				stops += (s.end - s.start);
			}
			return stops;
		}
		
		public double getTravelDist() {
			double d = 0;
			for (TransportRouteResultSegment s : segments) {
				d += s.getTravelDist();
			}
			return d;
		}
		
		public double getTravelTime() {
			if(cfg.useSchedule) {
				int t = 0;
				for(TransportRouteResultSegment s : segments) {
					TransportSchedule sts = s.route.getSchedule();
					for (int k = s.start; k < s.end; k++) {
						t += sts.getAvgStopIntervals()[k] * 10;
					}
				}
				return t;
			}
			return getTravelDist() / cfg.travelSpeed + cfg.stopTime * getStops() + 
					cfg.getChangeTime() * getChanges();
		}
		
		public double getWalkTime() {
			return getWalkDist() / cfg.walkSpeed;
		}
		
		public int getChanges() {
			return segments.size() - 1;
		}
		
		@Override
		public String toString() {
			StringBuilder bld = new StringBuilder();
			bld.append(String.format("Route %d stops, %d changes, %.2f min: %.2f m (%.1f min) to walk, %.2f m (%.1f min) to travel\n",
					getStops(), getChanges(), routeTime / 60, getWalkDist(), getWalkTime() / 60.0, 
					getTravelDist(), getTravelTime() / 60.0));
			for(int i = 0; i < segments.size(); i++) {
				TransportRouteResultSegment s = segments.get(i);
				String time = "";
				String arriveTime = "";
				if(s.depTime != -1) {
					time = String.format("at %s", formatTransporTime(s.depTime));
				}
				int aTime = s.getArrivalTime();
				if(aTime != -1) {
					arriveTime = String.format("and arrive at %s", formatTransporTime(aTime));
				}
				bld.append(String.format(" %d. %s: walk %.1f m to '%s' and travel %s to '%s' by %s %d stops %s\n",
						i + 1, s.route.getRef(), s.walkDist, s.getStart().getName(), 
						 time, s.getEnd().getName(),s.route.getName(),  (s.end - s.start), arriveTime));
			}
			bld.append(String.format(" F. Walk %.1f m to reach your destination", finishWalkDist));
			return bld.toString();
		}
	}
	
	public static String formatTransporTime(int i) {
		int h = i / 60 / 6;
		int mh = i - h * 60 * 6;
		int m = mh / 6;
		int s = (mh - m * 6) * 10;
		String tm = String.format("%02d:%02d:%02d ", h, m, s);
		return tm;
	}
	
	public static class TransportRouteSegment {
		
		final int segStart;
		final TransportRoute road;
		final int departureTime;
		private static final int SHIFT = 10; // assume less than 1024 stops
		private static final int SHIFT_DEPTIME = 14; // assume less than 1024 stops
		
		TransportRouteSegment parentRoute = null;
		int parentStop;
		double parentTravelTime; // travel time
		double parentTravelDist; // inaccurate
		// walk distance to start route location (or finish in case last segment)
		double walkDist = 0;
		
		// main field accumulated all time spent from beginning of journey
		double distFromStart = 0;
		
		
		
		
		public TransportRouteSegment(TransportRoute road, int stopIndex) {
			this.road = road;
			this.segStart = (short) stopIndex;
			this.departureTime = -1;
		}
		
		public TransportRouteSegment(TransportRoute road, int stopIndex, int depTime) {
			this.road = road;
			this.segStart = (short) stopIndex;
			this.departureTime = depTime;
		}
		
		public TransportRouteSegment(TransportRouteSegment c) {
			this.road = c.road;
			this.segStart = c.segStart;
			this.departureTime = c.departureTime;
		}
		
		
		public boolean wasVisited(TransportRouteSegment rrs) {
			if (rrs.road.getId().longValue() == road.getId().longValue() && 
					rrs.departureTime == departureTime) {
				return true;
			}
			if(parentRoute != null) {
				return parentRoute.wasVisited(rrs);
			}
			return false;
		}


		public TransportStop getStop(int i) {
			return road.getForwardStops().get(i);
		}


		public LatLon getLocation() {
			return road.getForwardStops().get(segStart).getLocation();
		}


		public int getLength() {
			return road.getForwardStops().size();
		}
		
		
		public long getId() {
			long l = road.getId();
			
			l = l << SHIFT_DEPTIME;
			if(departureTime >= (1 << SHIFT_DEPTIME)) {
				throw new IllegalStateException("too long dep time" + departureTime);
			}
			l += (departureTime + 1);

			l = l << SHIFT;
			if (segStart >= (1 << SHIFT)) {
				throw new IllegalStateException("too many stops " + road.getId() + " " + segStart);
			}
			l += segStart;
			
			if(l < 0 ) {
				throw new IllegalStateException("too long id " + road.getId());
			}
			return l  ;
		}

		
		public int getDepth() {
			if(parentRoute != null) {
				return parentRoute.getDepth() + 1;
			}
			return 1;
		}
		
		@Override
		public String toString() {
			return String.format("Route: %s, stop: %s %s", road.getName(), road.getForwardStops().get(segStart).getName(),
					departureTime == -1 ? "" : formatTransporTime(departureTime) );
		}

	}
	
	public static class TransportRoutingContext {
		
		public RouteCalculationProgress calculationProgress;
		public TLongObjectHashMap<TransportRouteSegment> visitedSegments = new TLongObjectHashMap<TransportRouteSegment>();
		public TransportRoutingConfiguration cfg;
		
		
		public TLongObjectHashMap<List<TransportRouteSegment>> quadTree;
		public final Map<BinaryMapIndexReader, TIntObjectHashMap<TransportRoute>> routeMap = 
				new LinkedHashMap<BinaryMapIndexReader, TIntObjectHashMap<TransportRoute>>();
		
		// stats
		public long startCalcTime;
		public int visitedRoutesCount;
		public int wrongLoadedWays;
		public int loadedWays;
		public long loadTime;
		public long readTime;
		
		
		
		private final int walkRadiusIn31;
		private final int walkChangeRadiusIn31;
		
		
		
		
		public TransportRoutingContext(TransportRoutingConfiguration cfg, BinaryMapIndexReader... readers) {
			this.cfg = cfg;
			walkRadiusIn31 = (int) (cfg.walkRadius / MapUtils.getTileDistanceWidth(31));
			walkChangeRadiusIn31 = (int) (cfg.walkChangeRadius / MapUtils.getTileDistanceWidth(31));
			quadTree = new TLongObjectHashMap<List<TransportRouteSegment>>();
			for (BinaryMapIndexReader r : readers) {
				routeMap.put(r, new TIntObjectHashMap<TransportRoute>());
			}
		}
		
		public List<TransportRouteSegment> getTransportStops(LatLon loc) throws IOException {
			int y = MapUtils.get31TileNumberY(loc.getLatitude());
			int x = MapUtils.get31TileNumberX(loc.getLongitude());
			return getTransportStops(x, y, false, new ArrayList<TransportRouteSegment>());
		}
		
		public List<TransportRouteSegment> getTransportStops(int x, int y, boolean change, List<TransportRouteSegment> res) throws IOException {
			return loadNativeTransportStops(x, y, change, res);
		}

		private List<TransportRouteSegment> loadNativeTransportStops(int sx, int sy, boolean change, List<TransportRouteSegment> res) throws IOException {
			long nanoTime = System.nanoTime();
			int d = change ? walkChangeRadiusIn31 : walkRadiusIn31;
			int lx = (sx - d ) >> (31 - cfg.ZOOM_TO_LOAD_TILES);
			int rx = (sx + d ) >> (31 - cfg.ZOOM_TO_LOAD_TILES);
			int ty = (sy - d ) >> (31 - cfg.ZOOM_TO_LOAD_TILES);
			int by = (sy + d ) >> (31 - cfg.ZOOM_TO_LOAD_TILES);
			for(int x = lx; x <= rx; x++) {
				for(int y = ty; y <= by; y++) {
					int tileId = x << (cfg.ZOOM_TO_LOAD_TILES + 1) + y;
					List<TransportRouteSegment> list = quadTree.get(tileId);
					if(list == null) {
						list = loadTile(x, y);
						quadTree.put(tileId, list);
					}
					for(TransportRouteSegment r : list) {
						TransportStop st = r.getStop(r.segStart);
						if (Math.abs(st.x31 - sx) > walkRadiusIn31 || Math.abs(st.y31 - sy) > walkRadiusIn31) {
							wrongLoadedWays++;
						} else {
							loadedWays++;
							res.add(r);
						}
					}
				}
			}
			loadTime += System.nanoTime() - nanoTime;
			return res;
		}


		private List<TransportRouteSegment> loadTile(int x, int y) throws IOException {
			long nanoTime = System.nanoTime();
			List<TransportRouteSegment> lst = new ArrayList<TransportRouteSegment>();
			int pz = (31 - cfg.ZOOM_TO_LOAD_TILES);
			SearchRequest<TransportStop> sr = BinaryMapIndexReader.buildSearchTransportRequest(x << pz, (x + 1) << pz, 
					y << pz, (y + 1) << pz, -1, null);
			TIntArrayList allPoints = new TIntArrayList();
			TIntArrayList allPointsLoad = new TIntArrayList();
			// should it be global?
			TLongObjectHashMap<TransportStop> loadedTransportStops = new TLongObjectHashMap<TransportStop>();
			for(BinaryMapIndexReader r : routeMap.keySet()) {
				sr.clearSearchResults();
				allPoints.clear();
				allPointsLoad.clear();
				
				List<TransportStop> stops = r.searchTransportIndex(sr);
				for(TransportStop s : stops) {
					if(!loadedTransportStops.contains(s.getId())) {
						loadedTransportStops.put(s.getId(), s);
						allPoints.addAll(s.getReferencesToRoutes());
					}
				}
				
				if(allPoints.size() > 0) {
					allPoints.sort();
					TIntObjectHashMap<TransportRoute> loadedRoutes = routeMap.get(r);
					TIntObjectHashMap<TransportRoute> routes  = new TIntObjectHashMap<TransportRoute>();
					TIntIterator it = allPoints.iterator();
					int p = allPoints.get(0) + 1; // different
					while(it.hasNext()) {
						int nxt = it.next();
						if (p != nxt) {
							if (loadedRoutes.contains(nxt)) {
								routes.put(nxt, loadedRoutes.get(nxt));
							} else {
								allPointsLoad.add(nxt);
							}
						}
					}
					r.loadTransportRoutes(allPointsLoad.toArray(), routes);
					loadedRoutes.putAll(routes);
					loadTransportSegments(routes, r, stops, lst);
				}
			}			
			readTime += System.nanoTime() - nanoTime;
			return lst;
		}

		private void loadTransportSegments(TIntObjectHashMap<TransportRoute> routes, BinaryMapIndexReader r,
				List<TransportStop> stops, List<TransportRouteSegment> lst) throws IOException {
			for(TransportStop s : stops) {
				for (int ref : s.getReferencesToRoutes()) {
					TransportRoute route = routes.get(ref);
					if (route != null) {
						int stopIndex = -1;
						double dist = TransportRoute.SAME_STOP;
						for (int k = 0; k < route.getForwardStops().size(); k++) {
							TransportStop st = route.getForwardStops().get(k);
							double d = MapUtils.getDistance(st.getLocation(), s.getLocation());
							if (d < dist) {
								stopIndex = k;
								dist = d; 
							}
						}
						if (stopIndex != -1) {
							if(cfg.useSchedule) {
								loadScheduleRouteSegment(lst, route, stopIndex);
							} else {
								TransportRouteSegment segment = new TransportRouteSegment(route, stopIndex);
								lst.add(segment);
							}
						} else {
							System.err.println("Routing error: missing stop in route");
						}
						
					}
				}
			}
		}

		private void loadScheduleRouteSegment(List<TransportRouteSegment> lst, TransportRoute route, int stopIndex) {
			if(route.getSchedule() != null) {
				TIntArrayList ti = route.getSchedule().tripIntervals;
				int cnt = ti.size();
				int t = 0;
				// improve by using exact data
				int stopTravelTime = 0;
				TIntArrayList avgStopIntervals = route.getSchedule().avgStopIntervals;
				for (int i = 0; i < stopIndex; i++) {
					if (avgStopIntervals.size() > i) {
						stopTravelTime += avgStopIntervals.getQuick(i);
					}
				}
				for(int i = 0; i < cnt; i++) {
					t += ti.getQuick(i);
					int startTime = t + stopTravelTime;
					if(startTime >= cfg.scheduleTimeOfDay && startTime <= cfg.scheduleTimeOfDay + cfg.scheduleMaxTime ) {
						TransportRouteSegment segment = new TransportRouteSegment(route, stopIndex, startTime);
						lst.add(segment);
					}
				}
			}
		}

		

	}

}
!@#$%
20190530_075140,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_b03536
package net.osmand.plus;

public interface OsmAndCustomizationConstants {

	// Navigation Drawer:

	String DRAWER_ITEM_ID_SCHEME = "drawer.action.";
	String DRAWER_DASHBOARD_ID = DRAWER_ITEM_ID_SCHEME + "dashboard";
	String DRAWER_MAP_MARKERS_ID = DRAWER_ITEM_ID_SCHEME + "map_markers";
	String DRAWER_MY_PLACES_ID = DRAWER_ITEM_ID_SCHEME + "my_places";
	String DRAWER_SEARCH_ID = DRAWER_ITEM_ID_SCHEME + "search";
	String DRAWER_DIRECTIONS_ID = DRAWER_ITEM_ID_SCHEME + "directions";
	String DRAWER_CONFIGURE_MAP_ID = DRAWER_ITEM_ID_SCHEME + "configure_map";
	String DRAWER_DOWNLOAD_MAPS_ID = DRAWER_ITEM_ID_SCHEME + "download_maps";
	String DRAWER_OSMAND_LIVE_ID = DRAWER_ITEM_ID_SCHEME + "osmand_live";
	String DRAWER_TRAVEL_GUIDES_ID = DRAWER_ITEM_ID_SCHEME + "travel_guides";
	String DRAWER_MEASURE_DISTANCE_ID = DRAWER_ITEM_ID_SCHEME + "measure_distance";
	String DRAWER_CONFIGURE_SCREEN_ID = DRAWER_ITEM_ID_SCHEME + "configure_screen";
	String DRAWER_PLUGINS_ID = DRAWER_ITEM_ID_SCHEME + "plugins";
	String DRAWER_SETTINGS_ID = DRAWER_ITEM_ID_SCHEME + "settings";
	String DRAWER_HELP_ID = DRAWER_ITEM_ID_SCHEME + "help";
	String DRAWER_BUILDS_ID = DRAWER_ITEM_ID_SCHEME + "builds";
	String DRAWER_DIVIDER_ID = DRAWER_ITEM_ID_SCHEME + "divider";

	// Configure Map:

	String CONFIGURE_MAP_ITEM_ID_SCHEME = "map.configure.";
	String SHOW_ITEMS_ID_SCHEME = CONFIGURE_MAP_ITEM_ID_SCHEME + "show.";
	String RENDERING_ITEMS_ID_SCHEME = CONFIGURE_MAP_ITEM_ID_SCHEME + "rendering.";
	String CUSTOM_RENDERING_ITEMS_ID_SCHEME = RENDERING_ITEMS_ID_SCHEME + "custom.";

	String APP_PROFILES_ID = CONFIGURE_MAP_ITEM_ID_SCHEME + "app_profiles";

	String SHOW_CATEGORY_ID = SHOW_ITEMS_ID_SCHEME + "category";
	String FAVORITES_ID = SHOW_ITEMS_ID_SCHEME + "favorites";
	String POI_OVERLAY_ID = SHOW_ITEMS_ID_SCHEME + "poi_overlay";
	String POI_OVERLAY_LABELS_ID = SHOW_ITEMS_ID_SCHEME + "poi_overlay_labels";
	String TRANSPORT_ID = SHOW_ITEMS_ID_SCHEME + "transport";
	String GPX_FILES_ID = SHOW_ITEMS_ID_SCHEME + "gpx_files";
	String MAP_MARKERS_ID = SHOW_ITEMS_ID_SCHEME + "map_markers";
	String MAP_SOURCE_ID = SHOW_ITEMS_ID_SCHEME + "map_source";
	String RECORDING_LAYER = SHOW_ITEMS_ID_SCHEME + "recording_layer";
	String MAPILLARY = SHOW_ITEMS_ID_SCHEME + "mapillary";
	String OSM_NOTES = SHOW_ITEMS_ID_SCHEME + "osm_notes";
	String OVERLAY_MAP = SHOW_ITEMS_ID_SCHEME + "overlay_map";
	String UNDERLAY_MAP = SHOW_ITEMS_ID_SCHEME + "underlay_map";
	String CONTOUR_LINES = SHOW_ITEMS_ID_SCHEME + "contour_lines";
	String HILLSHADE_LAYER = SHOW_ITEMS_ID_SCHEME + "hillshade_layer";

	String MAP_RENDERING_CATEGORY_ID = RENDERING_ITEMS_ID_SCHEME + "category";
	String MAP_STYLE_ID = RENDERING_ITEMS_ID_SCHEME + "map_style";
	String MAP_MODE_ID = RENDERING_ITEMS_ID_SCHEME + "map_mode";
	String MAP_MAGNIFIER_ID = RENDERING_ITEMS_ID_SCHEME + "map_marnifier";
	String ROAD_STYLE_ID = RENDERING_ITEMS_ID_SCHEME + "road_style";
	String TEXT_SIZE_ID = RENDERING_ITEMS_ID_SCHEME + "text_size";
	String MAP_LANGUAGE_ID = RENDERING_ITEMS_ID_SCHEME + "map_language";
	String TRANSPORT_RENDERING_ID = RENDERING_ITEMS_ID_SCHEME + "transport";
	String DETAILS_ID = RENDERING_ITEMS_ID_SCHEME + "details";
	String HIDE_ID = RENDERING_ITEMS_ID_SCHEME + "hide";
	String ROUTES_ID = RENDERING_ITEMS_ID_SCHEME + "routes";

	// Map Controls:

	String HUD_BTN_ID_SCHEME = "map.view.";
	String LAYERS_HUD_ID = HUD_BTN_ID_SCHEME + "layers";
	String COMPASS_HUD_ID = HUD_BTN_ID_SCHEME + "compass";
	String QUICK_SEARCH_HUD_ID = HUD_BTN_ID_SCHEME + "quick_search";
	String BACK_TO_LOC_HUD_ID = HUD_BTN_ID_SCHEME + "back_to_loc";
	String MENU_HUD_ID = HUD_BTN_ID_SCHEME + "menu";
	String ROUTE_PLANNING_HUD_ID = HUD_BTN_ID_SCHEME + "route_planning";
	String ZOOM_IN_HUD_ID = HUD_BTN_ID_SCHEME + "zoom_id";
	String ZOOM_OUT_HUD_ID = HUD_BTN_ID_SCHEME + "zoom_out";

	//Map Context Menu Actions:
	String MAP_CONTEXT_MENU_ACTIONS = "point.actions.";
	String MAP_CONTEXT_MENU_DIRECTIONS_FROM_ID = MAP_CONTEXT_MENU_ACTIONS + "directions_from";
	String MAP_CONTEXT_MENU_SEARCH_NEARBY = MAP_CONTEXT_MENU_ACTIONS + "search_nearby";
	String MAP_CONTEXT_MENU_CHANGE_MARKER_POSITION = MAP_CONTEXT_MENU_ACTIONS + "change_m_position";
	String MAP_CONTEXT_MENU_MARK_AS_PARKING_LOC = MAP_CONTEXT_MENU_ACTIONS + "mark_as_parking";
	String MAP_CONTEXT_MENU_MEASURE_DISTANCE = MAP_CONTEXT_MENU_ACTIONS + "measure_distance";
	String MAP_CONTEXT_MENU_EDIT_GPX_WP = MAP_CONTEXT_MENU_ACTIONS + "edit_gpx_waypoint";
	String MAP_CONTEXT_MENU_ADD_GPX_WAYPOINT = MAP_CONTEXT_MENU_ACTIONS + "add_gpx_waypoint";
  String MAP_CONTEXT_MENU_UPDATE_MAP = MAP_CONTEXT_MENU_ACTIONS + "update_map";
  String MAP_CONTEXT_MENU_DOWNLOAD_MAP = MAP_CONTEXT_MENU_ACTIONS + "download_map";
  String MAP_CONTEXT_MENU_MODIFY_POI = MAP_CONTEXT_MENU_ACTIONS + "modify_poi";
  String MAP_CONTEXT_MENU_MODIFY_OSM_CHANGE = MAP_CONTEXT_MENU_ACTIONS + "modify_osm_change";
  String MAP_CONTEXT_MENU_CREATE_POI = MAP_CONTEXT_MENU_ACTIONS + "create_poi";
  String MAP_CONTEXT_MENU_MODIFY_OSM_NOTE = MAP_CONTEXT_MENU_ACTIONS + "modify_osm_note";
  String MAP_CONTEXT_MENU_OPEN_OSM_NOTE = MAP_CONTEXT_MENU_ACTIONS + "open_osm_note";

	//Plug-in's IDs:
	String PLUGIN_OSMAND_MONITOR = "osmand.monitoring";
	String PLUGIN_MAPILLARY = "osmand.mapillary";
	String PLUGIN_OSMAND_DEV = "osmand.development";
	String PLUGIN_AUDIO_VIDEO_NOTES = "osmand.audionotes";
	String PLUGIN_NAUTICAL = "nauticalPlugin.plugin";
	String PLUGIN_OSMAND_EDITING = "osm.editing";
	String PLUGIN_PARKING_POSITION = "osmand.parking.position";
	String PLUGIN_RASTER_MAPS = "osmand.rastermaps";
	String PLUGIN_SKI_MAPS = "skimaps.plugin";
	String PLUGIN_SRTM = "osmand.srtm";

}
!@#$%
20190530_075140,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_a03536
package net.osmand.plus;

public interface OsmAndCustomizationConstants {

	// Navigation Drawer:

	String DRAWER_ITEM_ID_SCHEME = "drawer.action.";
	String DRAWER_DASHBOARD_ID = DRAWER_ITEM_ID_SCHEME + "dashboard";
	String DRAWER_MAP_MARKERS_ID = DRAWER_ITEM_ID_SCHEME + "map_markers";
	String DRAWER_MY_PLACES_ID = DRAWER_ITEM_ID_SCHEME + "my_places";
	String DRAWER_SEARCH_ID = DRAWER_ITEM_ID_SCHEME + "search";
	String DRAWER_DIRECTIONS_ID = DRAWER_ITEM_ID_SCHEME + "directions";
	String DRAWER_CONFIGURE_MAP_ID = DRAWER_ITEM_ID_SCHEME + "configure_map";
	String DRAWER_DOWNLOAD_MAPS_ID = DRAWER_ITEM_ID_SCHEME + "download_maps";
	String DRAWER_OSMAND_LIVE_ID = DRAWER_ITEM_ID_SCHEME + "osmand_live";
	String DRAWER_TRAVEL_GUIDES_ID = DRAWER_ITEM_ID_SCHEME + "travel_guides";
	String DRAWER_MEASURE_DISTANCE_ID = DRAWER_ITEM_ID_SCHEME + "measure_distance";
	String DRAWER_CONFIGURE_SCREEN_ID = DRAWER_ITEM_ID_SCHEME + "configure_screen";
	String DRAWER_PLUGINS_ID = DRAWER_ITEM_ID_SCHEME + "plugins";
	String DRAWER_SETTINGS_ID = DRAWER_ITEM_ID_SCHEME + "settings";
	String DRAWER_HELP_ID = DRAWER_ITEM_ID_SCHEME + "help";
	String DRAWER_BUILDS_ID = DRAWER_ITEM_ID_SCHEME + "builds";
	String DRAWER_DIVIDER_ID = DRAWER_ITEM_ID_SCHEME + "divider";

	// Configure Map:

	String CONFIGURE_MAP_ITEM_ID_SCHEME = "map.configure.";
	String SHOW_ITEMS_ID_SCHEME = CONFIGURE_MAP_ITEM_ID_SCHEME + "show.";
	String RENDERING_ITEMS_ID_SCHEME = CONFIGURE_MAP_ITEM_ID_SCHEME + "rendering.";
	String CUSTOM_RENDERING_ITEMS_ID_SCHEME = RENDERING_ITEMS_ID_SCHEME + "custom.";

	String APP_PROFILES_ID = CONFIGURE_MAP_ITEM_ID_SCHEME + "app_profiles";

	String SHOW_CATEGORY_ID = SHOW_ITEMS_ID_SCHEME + "category";
	String FAVORITES_ID = SHOW_ITEMS_ID_SCHEME + "favorites";
	String POI_OVERLAY_ID = SHOW_ITEMS_ID_SCHEME + "poi_overlay";
	String POI_OVERLAY_LABELS_ID = SHOW_ITEMS_ID_SCHEME + "poi_overlay_labels";
	String TRANSPORT_ID = SHOW_ITEMS_ID_SCHEME + "transport";
	String GPX_FILES_ID = SHOW_ITEMS_ID_SCHEME + "gpx_files";
	String MAP_MARKERS_ID = SHOW_ITEMS_ID_SCHEME + "map_markers";
	String MAP_SOURCE_ID = SHOW_ITEMS_ID_SCHEME + "map_source";
	String RECORDING_LAYER = SHOW_ITEMS_ID_SCHEME + "recording_layer";
	String MAPILLARY = SHOW_ITEMS_ID_SCHEME + "mapillary";
	String OSM_NOTES = SHOW_ITEMS_ID_SCHEME + "osm_notes";
	String OVERLAY_MAP = SHOW_ITEMS_ID_SCHEME + "overlay_map";
	String UNDERLAY_MAP = SHOW_ITEMS_ID_SCHEME + "underlay_map";
	String CONTOUR_LINES = SHOW_ITEMS_ID_SCHEME + "contour_lines";
	String HILLSHADE_LAYER = SHOW_ITEMS_ID_SCHEME + "hillshade_layer";

	String MAP_RENDERING_CATEGORY_ID = RENDERING_ITEMS_ID_SCHEME + "category";
	String MAP_STYLE_ID = RENDERING_ITEMS_ID_SCHEME + "map_style";
	String MAP_MODE_ID = RENDERING_ITEMS_ID_SCHEME + "map_mode";
	String MAP_MAGNIFIER_ID = RENDERING_ITEMS_ID_SCHEME + "map_marnifier";
	String ROAD_STYLE_ID = RENDERING_ITEMS_ID_SCHEME + "road_style";
	String TEXT_SIZE_ID = RENDERING_ITEMS_ID_SCHEME + "text_size";
	String MAP_LANGUAGE_ID = RENDERING_ITEMS_ID_SCHEME + "map_language";
	String TRANSPORT_RENDERING_ID = RENDERING_ITEMS_ID_SCHEME + "transport";
	String DETAILS_ID = RENDERING_ITEMS_ID_SCHEME + "details";
	String HIDE_ID = RENDERING_ITEMS_ID_SCHEME + "hide";
	String ROUTES_ID = RENDERING_ITEMS_ID_SCHEME + "routes";

	// Map Controls:

	String HUD_BTN_ID_SCHEME = "map.view.";
	String LAYERS_HUD_ID = HUD_BTN_ID_SCHEME + "layers";
	String COMPASS_HUD_ID = HUD_BTN_ID_SCHEME + "compass";
	String QUICK_SEARCH_HUD_ID = HUD_BTN_ID_SCHEME + "quick_search";
	String BACK_TO_LOC_HUD_ID = HUD_BTN_ID_SCHEME + "back_to_loc";
	String MENU_HUD_ID = HUD_BTN_ID_SCHEME + "menu";
	String ROUTE_PLANNING_HUD_ID = HUD_BTN_ID_SCHEME + "route_planning";
	String ZOOM_IN_HUD_ID = HUD_BTN_ID_SCHEME + "zoom_id";
	String ZOOM_OUT_HUD_ID = HUD_BTN_ID_SCHEME + "zoom_out";

	//Point's Context Action Menu:
	String POINTS_ACTION_MENU = "point.actions.";
	String POINT_DIRECTIONS_FROM_ID = POINTS_ACTION_MENU + "directions_from";
	String POINT_SEARCH_NEARBY = POINTS_ACTION_MENU + "search_nearby";
	String POINT_CHANGE_MARKER_POSITION = POINTS_ACTION_MENU + "change_m_position";
	String POINT_MARK_AS_PARKING_LOC = POINTS_ACTION_MENU + "mark_as_parking";
	String POINT_MEASURE_DISTANCE = POINTS_ACTION_MENU + "measure_distance";
	String POINT_EDIT_GPX_WP = POINTS_ACTION_MENU + "edit_gpx_waypoint";
	String POINT_ADD_GPX_WAYPOINT = POINTS_ACTION_MENU + "add_gpx_waypoint";
  String POINT_UPDATE_MAP = POINTS_ACTION_MENU + "update_map";
  String POINT_DOWNLOAD_MAP = POINTS_ACTION_MENU + "download_map";
  String POINT_MODIFY_POI = POINTS_ACTION_MENU + "modify_poi";
  String POINT_MODIFY_OSM_CHANGE = POINTS_ACTION_MENU + "modify_osm_change";
  String POINT_CREATE_POI = POINTS_ACTION_MENU + "create_poi";
  String POINT_MODIFY_OSM_NOTE = POINTS_ACTION_MENU + "modify_osm_note";
  String POINT_OPEN_OSM_NOTE = POINTS_ACTION_MENU + "open_osm_note";


}
!@#$%
20190530_075140,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_c03536
package net.osmand.plus;

public interface OsmAndCustomizationConstants {

	// Navigation Drawer:

	String DRAWER_ITEM_ID_SCHEME = "drawer.action.";
	String DRAWER_DASHBOARD_ID = DRAWER_ITEM_ID_SCHEME + "dashboard";
	String DRAWER_MAP_MARKERS_ID = DRAWER_ITEM_ID_SCHEME + "map_markers";
	String DRAWER_MY_PLACES_ID = DRAWER_ITEM_ID_SCHEME + "my_places";
	String DRAWER_SEARCH_ID = DRAWER_ITEM_ID_SCHEME + "search";
	String DRAWER_DIRECTIONS_ID = DRAWER_ITEM_ID_SCHEME + "directions";
	String DRAWER_CONFIGURE_MAP_ID = DRAWER_ITEM_ID_SCHEME + "configure_map";
	String DRAWER_DOWNLOAD_MAPS_ID = DRAWER_ITEM_ID_SCHEME + "download_maps";
	String DRAWER_OSMAND_LIVE_ID = DRAWER_ITEM_ID_SCHEME + "osmand_live";
	String DRAWER_TRAVEL_GUIDES_ID = DRAWER_ITEM_ID_SCHEME + "travel_guides";
	String DRAWER_MEASURE_DISTANCE_ID = DRAWER_ITEM_ID_SCHEME + "measure_distance";
	String DRAWER_CONFIGURE_SCREEN_ID = DRAWER_ITEM_ID_SCHEME + "configure_screen";
	String DRAWER_PLUGINS_ID = DRAWER_ITEM_ID_SCHEME + "plugins";
	String DRAWER_SETTINGS_ID = DRAWER_ITEM_ID_SCHEME + "settings";
	String DRAWER_HELP_ID = DRAWER_ITEM_ID_SCHEME + "help";
	String DRAWER_BUILDS_ID = DRAWER_ITEM_ID_SCHEME + "builds";
	String DRAWER_DIVIDER_ID = DRAWER_ITEM_ID_SCHEME + "divider";

	// Configure Map:

	String CONFIGURE_MAP_ITEM_ID_SCHEME = "map.configure.";
	String SHOW_ITEMS_ID_SCHEME = CONFIGURE_MAP_ITEM_ID_SCHEME + "show.";
	String RENDERING_ITEMS_ID_SCHEME = CONFIGURE_MAP_ITEM_ID_SCHEME + "rendering.";
	String CUSTOM_RENDERING_ITEMS_ID_SCHEME = RENDERING_ITEMS_ID_SCHEME + "custom.";

	String APP_PROFILES_ID = CONFIGURE_MAP_ITEM_ID_SCHEME + "app_profiles";

	String SHOW_CATEGORY_ID = SHOW_ITEMS_ID_SCHEME + "category";
	String FAVORITES_ID = SHOW_ITEMS_ID_SCHEME + "favorites";
	String POI_OVERLAY_ID = SHOW_ITEMS_ID_SCHEME + "poi_overlay";
	String POI_OVERLAY_LABELS_ID = SHOW_ITEMS_ID_SCHEME + "poi_overlay_labels";
	String TRANSPORT_ID = SHOW_ITEMS_ID_SCHEME + "transport";
	String GPX_FILES_ID = SHOW_ITEMS_ID_SCHEME + "gpx_files";
	String MAP_MARKERS_ID = SHOW_ITEMS_ID_SCHEME + "map_markers";
	String MAP_SOURCE_ID = SHOW_ITEMS_ID_SCHEME + "map_source";
	String RECORDING_LAYER = SHOW_ITEMS_ID_SCHEME + "recording_layer";
	String MAPILLARY = SHOW_ITEMS_ID_SCHEME + "mapillary";
	String OSM_NOTES = SHOW_ITEMS_ID_SCHEME + "osm_notes";
	String OVERLAY_MAP = SHOW_ITEMS_ID_SCHEME + "overlay_map";
	String UNDERLAY_MAP = SHOW_ITEMS_ID_SCHEME + "underlay_map";
	String CONTOUR_LINES = SHOW_ITEMS_ID_SCHEME + "contour_lines";
	String HILLSHADE_LAYER = SHOW_ITEMS_ID_SCHEME + "hillshade_layer";

	String MAP_RENDERING_CATEGORY_ID = RENDERING_ITEMS_ID_SCHEME + "category";
	String MAP_STYLE_ID = RENDERING_ITEMS_ID_SCHEME + "map_style";
	String MAP_MODE_ID = RENDERING_ITEMS_ID_SCHEME + "map_mode";
	String MAP_MAGNIFIER_ID = RENDERING_ITEMS_ID_SCHEME + "map_marnifier";
	String ROAD_STYLE_ID = RENDERING_ITEMS_ID_SCHEME + "road_style";
	String TEXT_SIZE_ID = RENDERING_ITEMS_ID_SCHEME + "text_size";
	String MAP_LANGUAGE_ID = RENDERING_ITEMS_ID_SCHEME + "map_language";
	String TRANSPORT_RENDERING_ID = RENDERING_ITEMS_ID_SCHEME + "transport";
	String DETAILS_ID = RENDERING_ITEMS_ID_SCHEME + "details";
	String HIDE_ID = RENDERING_ITEMS_ID_SCHEME + "hide";
	String ROUTES_ID = RENDERING_ITEMS_ID_SCHEME + "routes";

	// Map Controls:

	String HUD_BTN_ID_SCHEME = "map.view.";
	String LAYERS_HUD_ID = HUD_BTN_ID_SCHEME + "layers";
	String COMPASS_HUD_ID = HUD_BTN_ID_SCHEME + "compass";
	String QUICK_SEARCH_HUD_ID = HUD_BTN_ID_SCHEME + "quick_search";
	String BACK_TO_LOC_HUD_ID = HUD_BTN_ID_SCHEME + "back_to_loc";
	String MENU_HUD_ID = HUD_BTN_ID_SCHEME + "menu";
	String ROUTE_PLANNING_HUD_ID = HUD_BTN_ID_SCHEME + "route_planning";
	String ZOOM_IN_HUD_ID = HUD_BTN_ID_SCHEME + "zoom_id";
	String ZOOM_OUT_HUD_ID = HUD_BTN_ID_SCHEME + "zoom_out";

	//Point's Context Action Menu:
	String POINTS_ACTION_MENU = "point.actions.";
	String POINT_DIRECTIONS_FROM_ID = POINTS_ACTION_MENU + "directions_from";
	String POINT_SEARCH_NEARBY = POINTS_ACTION_MENU + "search_nearby";
	String POINT_CHANGE_MARKER_POSITION = POINTS_ACTION_MENU + "change_m_position";
	String POINT_MARK_AS_PARKING_LOC = POINTS_ACTION_MENU + "mark_as_parking";
	String POINT_MEASURE_DISTANCE = POINTS_ACTION_MENU + "measure_distance";
	String POINT_EDIT_GPX_WP = POINTS_ACTION_MENU + "edit_gpx_waypoint";
	String POINT_ADD_GPX_WAYPOINT = POINTS_ACTION_MENU + "add_gpx_waypoint";
  	String POINT_UPDATE_MAP = POINTS_ACTION_MENU + "update_map";
	String POINT_DOWNLOAD_MAP = POINTS_ACTION_MENU + "download_map";
	String POINT_MODIFY_POI = POINTS_ACTION_MENU + "modify_poi";
	String POINT_MODIFY_OSM_CHANGE = POINTS_ACTION_MENU + "modify_osm_change";
	String POINT_CREATE_POI = POINTS_ACTION_MENU + "create_poi";
	String POINT_MODIFY_OSM_NOTE = POINTS_ACTION_MENU + "modify_osm_note";
	String POINT_OPEN_OSM_NOTE = POINTS_ACTION_MENU + "open_osm_note";


}
!@#$%
20190530_075256,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_b10616
package net.osmand.binary;

import gnu.trove.list.array.TIntArrayList;
import gnu.trove.map.hash.TIntObjectHashMap;

import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import net.osmand.binary.BinaryMapIndexReader.SearchRequest;
import net.osmand.data.TransportSchedule;
import net.osmand.data.TransportStop;
import net.osmand.data.TransportStopExit;
import net.osmand.osm.edit.Node;
import net.osmand.osm.edit.Way;
import net.osmand.util.MapUtils;
import net.sf.junidecode.Junidecode;

import com.google.protobuf.CodedInputStream;
import com.google.protobuf.WireFormat;

public class BinaryMapTransportReaderAdapter {
	private CodedInputStream codedIS;
	private final BinaryMapIndexReader map;
	
	protected BinaryMapTransportReaderAdapter(BinaryMapIndexReader map){
		this.codedIS = map.codedIS;
		this.map = map;
	}

	private void skipUnknownField(int t) throws IOException {
		map.skipUnknownField(t);
	}
	
	private int readInt() throws IOException {
		return map.readInt();
	}

	public static class TransportIndex extends BinaryIndexPart {
		int left = 0;
		int right = 0;
		int top = 0;
		int bottom = 0;

		int stopsFileOffset = 0;
		int stopsFileLength = 0;
		
		public String getPartName() {
			return "Transport";
		}

		public int getFieldNumber() {
			return OsmandOdb.OsmAndStructure.TRANSPORTINDEX_FIELD_NUMBER;
		}

		public int getLeft() {
			return left;
		}

		public int getRight() {
			return right;
		}

		public int getTop() {
			return top;
		}

		public int getBottom() {
			return bottom;
		}

		IndexStringTable stringTable = null;
	}

	protected static class IndexStringTable {
		int fileOffset = 0;
		int length = 0;

		// offset from start for each SIZE_OFFSET_ARRAY elements
		// (SIZE_OFFSET_ARRAY + 1) offset = offsets[0] + skipOneString()
		TIntArrayList offsets = new TIntArrayList();

	}
	
	
	protected void readTransportIndex(TransportIndex ind) throws IOException {
		while(true){
			int t = codedIS.readTag();
			int tag = WireFormat.getTagFieldNumber(t);
			switch (tag) {
			case 0:
				return;
			case OsmandOdb.OsmAndTransportIndex.ROUTES_FIELD_NUMBER :
				skipUnknownField(t);
				break;
			case OsmandOdb.OsmAndTransportIndex.NAME_FIELD_NUMBER :
				ind.setName(codedIS.readString());
				break;
			case OsmandOdb.OsmAndTransportIndex.STOPS_FIELD_NUMBER :
				ind.stopsFileLength = readInt();
				ind.stopsFileOffset = codedIS.getTotalBytesRead();
				int old = codedIS.pushLimit(ind.stopsFileLength);
				readTransportBounds(ind);
				codedIS.popLimit(old);
				break;
			case OsmandOdb.OsmAndTransportIndex.STRINGTABLE_FIELD_NUMBER :
				IndexStringTable st = new IndexStringTable();
				st.length = codedIS.readRawVarint32();
				st.fileOffset = codedIS.getTotalBytesRead();
				// Do not cache for now save memory
				// readStringTable(st, 0, 20, true);
				ind.stringTable = st;
				codedIS.seek(st.length + st.fileOffset);
				break;
			default:
				skipUnknownField(t);
				break;
			}
		}
	}
	
	private void readTransportBounds(TransportIndex ind) throws IOException {
		while(true){
			int t = codedIS.readTag();
			int tag = WireFormat.getTagFieldNumber(t);
			switch (tag) {
			case 0:
				return;
			case OsmandOdb.TransportStopsTree.LEFT_FIELD_NUMBER :
				ind.left = codedIS.readSInt32();
				break;
			case OsmandOdb.TransportStopsTree.RIGHT_FIELD_NUMBER :
				ind.right = codedIS.readSInt32(); 
				break;
			case OsmandOdb.TransportStopsTree.TOP_FIELD_NUMBER :
				ind.top = codedIS.readSInt32();
				break;
			case OsmandOdb.TransportStopsTree.BOTTOM_FIELD_NUMBER :
				ind.bottom = codedIS.readSInt32(); 
				break;
			default:
				skipUnknownField(t);
				break;
			}
		}
	}
	
	protected void searchTransportTreeBounds(int pleft, int pright, int ptop, int pbottom,
			SearchRequest<TransportStop> req) throws IOException {
		int init = 0;
		int lastIndexResult = -1;
		int cright = 0;
		int cleft = 0;
		int ctop = 0;
		int cbottom = 0;
		req.numberOfReadSubtrees++;
		while(true){
			if(req.isCancelled()){
				return;
			}
			int t = codedIS.readTag();
			int tag = WireFormat.getTagFieldNumber(t);
			if(init == 0xf){
				// coordinates are init
				init = 0;
				if(cright < req.left || cleft > req.right || ctop > req.bottom || cbottom < req.top){
					return;
				} else {
					req.numberOfAcceptedSubtrees++;
				}
			}
			switch (tag) {
			case 0:
				return;
			case OsmandOdb.TransportStopsTree.BOTTOM_FIELD_NUMBER :
				cbottom = codedIS.readSInt32() + pbottom;
				init |= 1;
				break;
			case OsmandOdb.TransportStopsTree.LEFT_FIELD_NUMBER :
				cleft = codedIS.readSInt32() + pleft;
				init |= 2;
				break;
			case OsmandOdb.TransportStopsTree.RIGHT_FIELD_NUMBER :
				cright = codedIS.readSInt32() + pright;
				init |= 4;
				break;
			case OsmandOdb.TransportStopsTree.TOP_FIELD_NUMBER :
				ctop = codedIS.readSInt32() + ptop;
				init |= 8;
				break;
			case OsmandOdb.TransportStopsTree.LEAFS_FIELD_NUMBER :
				int stopOffset = codedIS.getTotalBytesRead();
				int length = codedIS.readRawVarint32();
				int oldLimit = codedIS.pushLimit(length);
				if(lastIndexResult == -1){
					lastIndexResult = req.getSearchResults().size();
				}
				req.numberOfVisitedObjects++;
				TransportStop transportStop = readTransportStop(stopOffset, cleft, cright, ctop, cbottom, req);
				if(transportStop != null){
					req.publish(transportStop);
				}
				codedIS.popLimit(oldLimit);
				break;
			case OsmandOdb.TransportStopsTree.SUBTREES_FIELD_NUMBER :
				// left, ... already initialized 
				length = readInt();
				int filePointer = codedIS.getTotalBytesRead();
				if (req.limit == -1 || req.limit >= req.getSearchResults().size()) {
					oldLimit = codedIS.pushLimit(length);
					searchTransportTreeBounds(cleft, cright, ctop, cbottom, req);
					codedIS.popLimit(oldLimit);
				}
				codedIS.seek(filePointer + length);
				
				if(lastIndexResult >= 0){
					throw new IllegalStateException();
				}
				break;
			case OsmandOdb.TransportStopsTree.BASEID_FIELD_NUMBER :
				long baseId = codedIS.readUInt64();
				if (lastIndexResult != -1) {
					for (int i = lastIndexResult; i < req.getSearchResults().size(); i++) {
						TransportStop rs = req.getSearchResults().get(i);
						rs.setId(rs.getId() + baseId);
					}
				}
				break;
			default:
				skipUnknownField(t);
				break;
			}
		}
	}
	
	private String regStr(TIntObjectHashMap<String> stringTable) throws IOException{
		int i = codedIS.readUInt32();
		stringTable.putIfAbsent(i, "");
		return ((char) i)+"";
	}

	private String regStr(TIntObjectHashMap<String> stringTable, int i) throws IOException{
		stringTable.putIfAbsent(i, "");
		return ((char) i)+"";
	}
	
	public net.osmand.data.TransportRoute getTransportRoute(int filePointer, TIntObjectHashMap<String> stringTable,
			boolean onlyDescription) throws IOException {
		codedIS.seek(filePointer);
		int routeLength = codedIS.readRawVarint32();
		int old = codedIS.pushLimit(routeLength);
		net.osmand.data.TransportRoute dataObject = new net.osmand.data.TransportRoute();
		boolean end = false;
		long rid = 0;
		int rx = 0;
		int ry = 0;
		while(!end){
			int t = codedIS.readTag();
			int tag = WireFormat.getTagFieldNumber(t);
			switch (tag) {
			case 0:
				end = true;
				break;
			case OsmandOdb.TransportRoute.DISTANCE_FIELD_NUMBER :
				dataObject.setDistance(codedIS.readUInt32());
				break;
			case OsmandOdb.TransportRoute.ID_FIELD_NUMBER :
				dataObject.setId(codedIS.readUInt64());
				break;
			case OsmandOdb.TransportRoute.REF_FIELD_NUMBER :
				dataObject.setRef(codedIS.readString());
				break;
			case OsmandOdb.TransportRoute.TYPE_FIELD_NUMBER :
				dataObject.setType(regStr(stringTable)); //$NON-NLS-1$
				break;
			case OsmandOdb.TransportRoute.NAME_EN_FIELD_NUMBER :
				dataObject.setEnName(regStr(stringTable)); //$NON-NLS-1$
				break;
			case OsmandOdb.TransportRoute.NAME_FIELD_NUMBER :
				dataObject.setName(regStr(stringTable)); //$NON-NLS-1$
				break;
			case OsmandOdb.TransportRoute.OPERATOR_FIELD_NUMBER:
				dataObject.setOperator(regStr(stringTable)); //$NON-NLS-1$
				break;
			case OsmandOdb.TransportRoute.COLOR_FIELD_NUMBER:
				dataObject.setColor(regStr(stringTable));
				break;
			case OsmandOdb.TransportRoute.GEOMETRY_FIELD_NUMBER:
				int sizeL = codedIS.readRawVarint32();
				int pold = codedIS.pushLimit(sizeL);
				int px = 0; 
				int py = 0;
				Way w = new Way(-1);
				while (codedIS.getBytesUntilLimit() > 0) {
					int ddx = (codedIS.readSInt32() << BinaryMapIndexReader.SHIFT_COORDINATES);
					int ddy = (codedIS.readSInt32() << BinaryMapIndexReader.SHIFT_COORDINATES);
					if(ddx == 0 && ddy == 0) {
						if(w.getNodes().size() > 0) {
							dataObject.addWay(w);
						}
						w = new Way(-1);
					} else {
						int x = ddx + px;
						int y = ddy + py;
						w.addNode(new Node(MapUtils.get31LatitudeY(y), MapUtils.get31LongitudeX(x), -1));
						px = x;
						py = y;
					}
				}
				if(w.getNodes().size() > 0) {
					dataObject.addWay(w);
				}
				codedIS.popLimit(pold);
				break;
			// deprecated
//			case OsmandOdb.TransportRoute.REVERSESTOPS_FIELD_NUMBER:
//				break;
			case OsmandOdb.TransportRoute.SCHEDULETRIP_FIELD_NUMBER:
				sizeL = codedIS.readRawVarint32();
				pold = codedIS.pushLimit(sizeL);
				readTransportSchedule(dataObject.getOrCreateSchedule());
				codedIS.popLimit(pold);
				break;
			case OsmandOdb.TransportRoute.DIRECTSTOPS_FIELD_NUMBER:
				if(onlyDescription){
					end = true;
					codedIS.skipRawBytes(codedIS.getBytesUntilLimit());
					break;
				}
				int length = codedIS.readRawVarint32();
				int olds = codedIS.pushLimit(length);
				TransportStop stop = readTransportRouteStop(rx, ry, rid, stringTable, filePointer);
				dataObject.getForwardStops().add(stop);
				rid = stop.getId();
				rx = (int) MapUtils.getTileNumberX(BinaryMapIndexReader.TRANSPORT_STOP_ZOOM, stop.getLocation().getLongitude());
				ry = (int) MapUtils.getTileNumberY(BinaryMapIndexReader.TRANSPORT_STOP_ZOOM, stop.getLocation().getLatitude());
				codedIS.popLimit(olds);
				break;
			default:
				skipUnknownField(t);
				break;
			}
		}
		codedIS.popLimit(old);
		
		
		return dataObject;
	}
	
	private void readTransportSchedule(TransportSchedule schedule) throws IOException {
		while(true){
			int t = codedIS.readTag();
			int interval, sizeL, old;
			int tag = WireFormat.getTagFieldNumber(t);
			switch (tag) {
			case 0:
				return;
			case OsmandOdb.TransportRouteSchedule.TRIPINTERVALS_FIELD_NUMBER:
				sizeL = codedIS.readRawVarint32();
				old = codedIS.pushLimit(sizeL);
				while (codedIS.getBytesUntilLimit() > 0) {
					interval = codedIS.readRawVarint32();
					schedule.tripIntervals.add(interval);
				}
				codedIS.popLimit(old);				
				break;
			case OsmandOdb.TransportRouteSchedule.AVGSTOPINTERVALS_FIELD_NUMBER:
				sizeL = codedIS.readRawVarint32();
				old = codedIS.pushLimit(sizeL);
				while (codedIS.getBytesUntilLimit() > 0) {
					interval = codedIS.readRawVarint32();
					schedule.avgStopIntervals.add(interval);
				}
				codedIS.popLimit(old);
				break;
			case OsmandOdb.TransportRouteSchedule.AVGWAITINTERVALS_FIELD_NUMBER:
				sizeL = codedIS.readRawVarint32();
				old = codedIS.pushLimit(sizeL);
				while (codedIS.getBytesUntilLimit() > 0) {
					interval = codedIS.readRawVarint32();
					schedule.avgWaitIntervals.add(interval);
				}
				codedIS.popLimit(old);
				break;
//			case OsmandOdb.TransportRouteSchedule.EXCEPTIONS_FIELD_NUMBER:
//				break;
			default:
				skipUnknownField(t);
				break;
			}
		}
		
	}

	protected void initializeStringTable(TransportIndex ind, TIntObjectHashMap<String> stringTable) throws IOException {
		int[] values = stringTable.keys();
		Arrays.sort(values);
		codedIS.seek(ind.stringTable.fileOffset);
		int oldLimit = codedIS.pushLimit(ind.stringTable.length);
		int current = 0;
		int i = 0;
		while (i < values.length) {
			int t = codedIS.readTag();
			int tag = WireFormat.getTagFieldNumber(t);
			switch (tag) {
			case 0:
				break;
			case OsmandOdb.StringTable.S_FIELD_NUMBER:
				if (current == values[i]) {
					String value = codedIS.readString();
					stringTable.put(values[i], value);
					i++;
				} else {
					skipUnknownField(t);
				}
				current ++;
				break;
			default:
				skipUnknownField(t);
				break;
			}
		}
		codedIS.popLimit(oldLimit);
	}

	protected void initializeNames(boolean onlyDescription, net.osmand.data.TransportRoute dataObject,
			TIntObjectHashMap<String> stringTable) throws IOException {
		if(dataObject.getName().length() > 0){
			dataObject.setName(stringTable.get(dataObject.getName().charAt(0)));
		}
		if(dataObject.getEnName(false).length() > 0){
			dataObject.setEnName(stringTable.get(dataObject.getEnName(false).charAt(0)));
		}
		if(dataObject.getName().length() > 0 && dataObject.getName("en").length() == 0){
			dataObject.setEnName(Junidecode.unidecode(dataObject.getName()));
		}
		if(dataObject.getOperator() != null && dataObject.getOperator().length() > 0){
			dataObject.setOperator(stringTable.get(dataObject.getOperator().charAt(0)));
		}
		if(dataObject.getColor() != null && dataObject.getColor().length() > 0){
			dataObject.setColor(stringTable.get(dataObject.getColor().charAt(0)));
		}
		if(dataObject.getType() != null && dataObject.getType().length() > 0){
			dataObject.setType(stringTable.get(dataObject.getType().charAt(0)));
		}
		if (!onlyDescription) {
			for (TransportStop s : dataObject.getForwardStops()) {
				initializeNames(stringTable, s);
			}
		}
	}

	protected void initializeNames(TIntObjectHashMap<String> stringTable, TransportStop s) {
		for (TransportStopExit exit : s.getExits())	{
			if (exit.getRef().length() > 0) {
				exit.setRef(stringTable.get(exit.getRef().charAt(0)));
			}
		}
		if (s.getName().length() > 0) {
			s.setName(stringTable.get(s.getName().charAt(0)));
		}
		if (s.getEnName(false).length() > 0) {
			s.setEnName(stringTable.get(s.getEnName(false).charAt(0)));
		}
		Map<String, String> namesMap = new HashMap<>(s.getNamesMap(false));
		if (!s.getNamesMap(false).isEmpty()) {
			s.getNamesMap(false).clear();
		}
		Iterator<Map.Entry<String, String>> it = namesMap.entrySet().iterator();
		while (it.hasNext()) {
			Map.Entry<String, String> e = it.next();
			s.setName(stringTable.get(e.getKey().charAt(0)), stringTable.get(e.getValue().charAt(0)));
		}
	}

	
	
	private TransportStop readTransportRouteStop(int dx, int dy, long did, TIntObjectHashMap<String> stringTable, 
			int filePointer) throws IOException {
		TransportStop dataObject = new TransportStop();
		dataObject.setFileOffset(codedIS.getTotalBytesRead());
		// dataObject.setReferencesToRoutes(new int[] {filePointer});
		boolean end = false;
		while(!end){
			int t = codedIS.readTag();
			int tag = WireFormat.getTagFieldNumber(t);
			switch (tag) {
			case 0:
				end = true;
				break;
			case OsmandOdb.TransportRouteStop.NAME_EN_FIELD_NUMBER :
				dataObject.setEnName(regStr(stringTable)); //$NON-NLS-1$
				break;
			case OsmandOdb.TransportRouteStop.NAME_FIELD_NUMBER :
				dataObject.setName(regStr(stringTable)); //$NON-NLS-1$
				break;
			case OsmandOdb.TransportRouteStop.ID_FIELD_NUMBER :
				did += codedIS.readSInt64();
				break;
			case OsmandOdb.TransportRouteStop.DX_FIELD_NUMBER :
				dx += codedIS.readSInt32();
				break;
			case OsmandOdb.TransportRouteStop.DY_FIELD_NUMBER :
				dy += codedIS.readSInt32();
				break;
			default:
				skipUnknownField(t);
				break;
			}
		}
		dataObject.setId(did);
		dataObject.setLocation(BinaryMapIndexReader.TRANSPORT_STOP_ZOOM, dx, dy);
		return dataObject;
	}
	
	private TransportStop readTransportStop(int shift, int cleft, int cright, int ctop, int cbottom, SearchRequest<TransportStop> req) throws IOException {
		int tag = WireFormat.getTagFieldNumber(codedIS.readTag());
		if(OsmandOdb.TransportStop.DX_FIELD_NUMBER != tag) {
			throw new IllegalArgumentException();
		}
		int x = codedIS.readSInt32() + cleft;
		
		tag = WireFormat.getTagFieldNumber(codedIS.readTag());
		if(OsmandOdb.TransportStop.DY_FIELD_NUMBER != tag) {
			throw new IllegalArgumentException();
		}
		int y = codedIS.readSInt32() + ctop;
		if(req.right < x || req.left > x || req.top > y || req.bottom < y){
			codedIS.skipRawBytes(codedIS.getBytesUntilLimit());
			return null;
		}
		
		req.numberOfAcceptedObjects++;
		req.cacheTypes.clear();
		
		TransportStop dataObject = new TransportStop();
		dataObject.setLocation(BinaryMapIndexReader.TRANSPORT_STOP_ZOOM, x, y);
		dataObject.setFileOffset(shift);
		List<String> names = null;
		while(true){
			int t = codedIS.readTag();
			tag = WireFormat.getTagFieldNumber(t);
			switch (tag) {
			case 0:
				dataObject.setReferencesToRoutes(req.cacheTypes.toArray());
				if(dataObject.getName("en").length() == 0){
					dataObject.setEnName(Junidecode.unidecode(dataObject.getName()));
				}
				return dataObject;
			case OsmandOdb.TransportStop.ROUTES_FIELD_NUMBER :
				req.cacheTypes.add(shift - codedIS.readUInt32());
				break;
			case OsmandOdb.TransportStop.NAME_EN_FIELD_NUMBER :
				if (req.stringTable != null) {
					dataObject.setEnName(regStr(req.stringTable)); //$NON-NLS-1$
				} else {
					skipUnknownField(t);
				}
				break;
			case OsmandOdb.TransportStop.NAME_FIELD_NUMBER :
				if (req.stringTable != null) {
					dataObject.setName(regStr(req.stringTable)); //$NON-NLS-1$
				} else {
					skipUnknownField(t);
				}
				break;
			case OsmandOdb.TransportStop.ADDITIONALNAMEPAIRS_FIELD_NUMBER :
				if (req.stringTable != null) {
					int sizeL = codedIS.readRawVarint32();
					int oldRef = codedIS.pushLimit(sizeL);
					while (codedIS.getBytesUntilLimit() > 0) {
						dataObject.setName(regStr(req.stringTable,codedIS.readRawVarint32()),
								regStr(req.stringTable,codedIS.readRawVarint32()));
					}
					codedIS.popLimit(oldRef);
				} else {
					skipUnknownField(t);
				}
				break;
			case OsmandOdb.TransportStop.ID_FIELD_NUMBER :
				dataObject.setId(codedIS.readSInt64());
				break;
			case OsmandOdb.TransportStop.EXITS_FIELD_NUMBER :
				int length = codedIS.readRawVarint32();
				int oldLimit = codedIS.pushLimit(length);

				TransportStopExit transportStopExit = readTransportStopExit(cleft, ctop, req);
				dataObject.addExit(transportStopExit);
				codedIS.popLimit(oldLimit);
				break;
			default:
				skipUnknownField(t);
				break;
			}
		}
	}

	private TransportStopExit readTransportStopExit(int cleft, int ctop, SearchRequest<TransportStop> req) throws IOException {

		TransportStopExit dataObject = new TransportStopExit();
		int x = 0;
		int y = 0;

		while (true) {
			int t = codedIS.readTag();
			int tag = WireFormat.getTagFieldNumber(t);

			switch (tag) {
				case 0:
					if (dataObject.getName("en").length() == 0) {
						dataObject.setEnName(Junidecode.unidecode(dataObject.getName()));
					}
					if (x != 0 || y != 0) {
						dataObject.setLocation(BinaryMapIndexReader.TRANSPORT_STOP_ZOOM, x, y);
					}
					return dataObject;
				case OsmandOdb.TransportStopExit.REF_FIELD_NUMBER:
					if (req.stringTable != null) {
						dataObject.setRef(regStr(req.stringTable));
					} else {
						skipUnknownField(t);
					}
					break;
				case OsmandOdb.TransportStopExit.DX_FIELD_NUMBER:
					x = codedIS.readSInt32() + cleft;
					break;
				case OsmandOdb.TransportStopExit.DY_FIELD_NUMBER:
					y = codedIS.readSInt32() + ctop;
					break;
				default:
					skipUnknownField(t);
					break;
			}
		}
	}


}
!@#$%
20190530_075256,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_a10616
package net.osmand.binary;

import gnu.trove.list.array.TIntArrayList;
import gnu.trove.map.hash.TIntObjectHashMap;

import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import net.osmand.binary.BinaryMapIndexReader.SearchRequest;
import net.osmand.data.TransportSchedule;
import net.osmand.data.TransportStop;
import net.osmand.data.TransportStopExit;
import net.osmand.osm.edit.Node;
import net.osmand.osm.edit.Way;
import net.osmand.util.MapUtils;
import net.sf.junidecode.Junidecode;

import com.google.protobuf.CodedInputStream;
import com.google.protobuf.WireFormat;

public class BinaryMapTransportReaderAdapter {
	private CodedInputStream codedIS;
	private final BinaryMapIndexReader map;
	
	protected BinaryMapTransportReaderAdapter(BinaryMapIndexReader map){
		this.codedIS = map.codedIS;
		this.map = map;
	}

	private void skipUnknownField(int t) throws IOException {
		map.skipUnknownField(t);
	}
	
	private int readInt() throws IOException {
		return map.readInt();
	}

	public static class TransportIndex extends BinaryIndexPart {
		int left = 0;
		int right = 0;
		int top = 0;
		int bottom = 0;

		int stopsFileOffset = 0;
		int stopsFileLength = 0;
		
		public String getPartName() {
			return "Transport";
		}

		public int getFieldNumber() {
			return OsmandOdb.OsmAndStructure.TRANSPORTINDEX_FIELD_NUMBER;
		}

		public int getLeft() {
			return left;
		}

		public int getRight() {
			return right;
		}

		public int getTop() {
			return top;
		}

		public int getBottom() {
			return bottom;
		}

		IndexStringTable stringTable = null;
	}

	protected static class IndexStringTable {
		int fileOffset = 0;
		int length = 0;

		// offset from start for each SIZE_OFFSET_ARRAY elements
		// (SIZE_OFFSET_ARRAY + 1) offset = offsets[0] + skipOneString()
		TIntArrayList offsets = new TIntArrayList();

	}
	
	
	protected void readTransportIndex(TransportIndex ind) throws IOException {
		while(true){
			int t = codedIS.readTag();
			int tag = WireFormat.getTagFieldNumber(t);
			switch (tag) {
			case 0:
				return;
			case OsmandOdb.OsmAndTransportIndex.ROUTES_FIELD_NUMBER :
				skipUnknownField(t);
				break;
			case OsmandOdb.OsmAndTransportIndex.NAME_FIELD_NUMBER :
				ind.setName(codedIS.readString());
				break;
			case OsmandOdb.OsmAndTransportIndex.STOPS_FIELD_NUMBER :
				ind.stopsFileLength = readInt();
				ind.stopsFileOffset = codedIS.getTotalBytesRead();
				int old = codedIS.pushLimit(ind.stopsFileLength);
				readTransportBounds(ind);
				codedIS.popLimit(old);
				break;
			case OsmandOdb.OsmAndTransportIndex.STRINGTABLE_FIELD_NUMBER :
				IndexStringTable st = new IndexStringTable();
				st.length = codedIS.readRawVarint32();
				st.fileOffset = codedIS.getTotalBytesRead();
				// Do not cache for now save memory
				// readStringTable(st, 0, 20, true);
				ind.stringTable = st;
				codedIS.seek(st.length + st.fileOffset);
				break;
			default:
				skipUnknownField(t);
				break;
			}
		}
	}
	
	private void readTransportBounds(TransportIndex ind) throws IOException {
		while(true){
			int t = codedIS.readTag();
			int tag = WireFormat.getTagFieldNumber(t);
			switch (tag) {
			case 0:
				return;
			case OsmandOdb.TransportStopsTree.LEFT_FIELD_NUMBER :
				ind.left = codedIS.readSInt32();
				break;
			case OsmandOdb.TransportStopsTree.RIGHT_FIELD_NUMBER :
				ind.right = codedIS.readSInt32(); 
				break;
			case OsmandOdb.TransportStopsTree.TOP_FIELD_NUMBER :
				ind.top = codedIS.readSInt32();
				break;
			case OsmandOdb.TransportStopsTree.BOTTOM_FIELD_NUMBER :
				ind.bottom = codedIS.readSInt32(); 
				break;
			default:
				skipUnknownField(t);
				break;
			}
		}
	}
	
	protected void searchTransportTreeBounds(int pleft, int pright, int ptop, int pbottom,
			SearchRequest<TransportStop> req) throws IOException {
		int init = 0;
		int lastIndexResult = -1;
		int cright = 0;
		int cleft = 0;
		int ctop = 0;
		int cbottom = 0;
		req.numberOfReadSubtrees++;
		while(true){
			if(req.isCancelled()){
				return;
			}
			int t = codedIS.readTag();
			int tag = WireFormat.getTagFieldNumber(t);
			if(init == 0xf){
				// coordinates are init
				init = 0;
				if(cright < req.left || cleft > req.right || ctop > req.bottom || cbottom < req.top){
					return;
				} else {
					req.numberOfAcceptedSubtrees++;
				}
			}
			switch (tag) {
			case 0:
				return;
			case OsmandOdb.TransportStopsTree.BOTTOM_FIELD_NUMBER :
				cbottom = codedIS.readSInt32() + pbottom;
				init |= 1;
				break;
			case OsmandOdb.TransportStopsTree.LEFT_FIELD_NUMBER :
				cleft = codedIS.readSInt32() + pleft;
				init |= 2;
				break;
			case OsmandOdb.TransportStopsTree.RIGHT_FIELD_NUMBER :
				cright = codedIS.readSInt32() + pright;
				init |= 4;
				break;
			case OsmandOdb.TransportStopsTree.TOP_FIELD_NUMBER :
				ctop = codedIS.readSInt32() + ptop;
				init |= 8;
				break;
			case OsmandOdb.TransportStopsTree.LEAFS_FIELD_NUMBER :
				int stopOffset = codedIS.getTotalBytesRead();
				int length = codedIS.readRawVarint32();
				int oldLimit = codedIS.pushLimit(length);
				if(lastIndexResult == -1){
					lastIndexResult = req.getSearchResults().size();
				}
				req.numberOfVisitedObjects++;
				TransportStop transportStop = readTransportStop(stopOffset, cleft, cright, ctop, cbottom, req);
				if(transportStop != null){
					req.publish(transportStop);
				}
				codedIS.popLimit(oldLimit);
				break;
			case OsmandOdb.TransportStopsTree.SUBTREES_FIELD_NUMBER :
				// left, ... already initialized 
				length = readInt();
				int filePointer = codedIS.getTotalBytesRead();
				if (req.limit == -1 || req.limit >= req.getSearchResults().size()) {
					oldLimit = codedIS.pushLimit(length);
					searchTransportTreeBounds(cleft, cright, ctop, cbottom, req);
					codedIS.popLimit(oldLimit);
				}
				codedIS.seek(filePointer + length);
				
				if(lastIndexResult >= 0){
					throw new IllegalStateException();
				}
				break;
			case OsmandOdb.TransportStopsTree.BASEID_FIELD_NUMBER :
				long baseId = codedIS.readUInt64();
				if (lastIndexResult != -1) {
					for (int i = lastIndexResult; i < req.getSearchResults().size(); i++) {
						TransportStop rs = req.getSearchResults().get(i);
						rs.setId(rs.getId() + baseId);
					}
				}
				break;
			default:
				skipUnknownField(t);
				break;
			}
		}
	}
	
	private String regStr(TIntObjectHashMap<String> stringTable) throws IOException{
		int i = codedIS.readUInt32();
		stringTable.putIfAbsent(i, "");
		return ((char) i)+"";
	}

	private String regStr(TIntObjectHashMap<String> stringTable, int i) throws IOException{
		stringTable.putIfAbsent(i, "");
		return ((char) i)+"";
	}
	
	public net.osmand.data.TransportRoute getTransportRoute(int filePointer, TIntObjectHashMap<String> stringTable,
			boolean onlyDescription) throws IOException {
		codedIS.seek(filePointer);
		int routeLength = codedIS.readRawVarint32();
		int old = codedIS.pushLimit(routeLength);
		net.osmand.data.TransportRoute dataObject = new net.osmand.data.TransportRoute();
		boolean end = false;
		long rid = 0;
		int rx = 0;
		int ry = 0;
		while(!end){
			int t = codedIS.readTag();
			int tag = WireFormat.getTagFieldNumber(t);
			switch (tag) {
			case 0:
				end = true;
				break;
			case OsmandOdb.TransportRoute.DISTANCE_FIELD_NUMBER :
				dataObject.setDistance(codedIS.readUInt32());
				break;
			case OsmandOdb.TransportRoute.ID_FIELD_NUMBER :
				dataObject.setId(codedIS.readUInt64());
				break;
			case OsmandOdb.TransportRoute.REF_FIELD_NUMBER :
				dataObject.setRef(codedIS.readString());
				break;
			case OsmandOdb.TransportRoute.TYPE_FIELD_NUMBER :
				dataObject.setType(regStr(stringTable)); //$NON-NLS-1$
				break;
			case OsmandOdb.TransportRoute.NAME_EN_FIELD_NUMBER :
				dataObject.setEnName(regStr(stringTable)); //$NON-NLS-1$
				break;
			case OsmandOdb.TransportRoute.NAME_FIELD_NUMBER :
				dataObject.setName(regStr(stringTable)); //$NON-NLS-1$
				break;
			case OsmandOdb.TransportRoute.OPERATOR_FIELD_NUMBER:
				dataObject.setOperator(regStr(stringTable)); //$NON-NLS-1$
				break;
			case OsmandOdb.TransportRoute.COLOR_FIELD_NUMBER:
				dataObject.setColor(regStr(stringTable));
				break;
			case OsmandOdb.TransportRoute.GEOMETRY_FIELD_NUMBER:
				int sizeL = codedIS.readRawVarint32();
				int pold = codedIS.pushLimit(sizeL);
				int px = 0; 
				int py = 0;
				Way w = new Way(-1);
				while (codedIS.getBytesUntilLimit() > 0) {
					int ddx = (codedIS.readSInt32() << BinaryMapIndexReader.SHIFT_COORDINATES);
					int ddy = (codedIS.readSInt32() << BinaryMapIndexReader.SHIFT_COORDINATES);
					if(ddx == 0 && ddy == 0) {
						if(w.getNodes().size() > 0) {
							dataObject.addWay(w);
						}
						w = new Way(-1);
					} else {
						int x = ddx + px;
						int y = ddy + py;
						w.addNode(new Node(MapUtils.get31LatitudeY(y), MapUtils.get31LongitudeX(x), -1));
						px = x;
						py = y;
					}
				}
				if(w.getNodes().size() > 0) {
					dataObject.addWay(w);
				}
				codedIS.popLimit(pold);
				break;
			// deprecated
//			case OsmandOdb.TransportRoute.REVERSESTOPS_FIELD_NUMBER:
//				break;
			case OsmandOdb.TransportRoute.SCHEDULETRIP_FIELD_NUMBER:
				sizeL = codedIS.readRawVarint32();
				pold = codedIS.pushLimit(sizeL);
				readTransportSchedule(dataObject.getOrCreateSchedule());
				codedIS.popLimit(pold);
				break;
			case OsmandOdb.TransportRoute.DIRECTSTOPS_FIELD_NUMBER:
				if(onlyDescription){
					end = true;
					codedIS.skipRawBytes(codedIS.getBytesUntilLimit());
					break;
				}
				int length = codedIS.readRawVarint32();
				int olds = codedIS.pushLimit(length);
				TransportStop stop = readTransportRouteStop(rx, ry, rid, stringTable, filePointer);
				dataObject.getForwardStops().add(stop);
				rid = stop.getId();
				rx = (int) MapUtils.getTileNumberX(BinaryMapIndexReader.TRANSPORT_STOP_ZOOM, stop.getLocation().getLongitude());
				ry = (int) MapUtils.getTileNumberY(BinaryMapIndexReader.TRANSPORT_STOP_ZOOM, stop.getLocation().getLatitude());
				codedIS.popLimit(olds);
				break;
			default:
				skipUnknownField(t);
				break;
			}
		}
		codedIS.popLimit(old);
		
		
		return dataObject;
	}
	
	private void readTransportSchedule(TransportSchedule schedule) throws IOException {
		while(true){
			int t = codedIS.readTag();
			int interval, sizeL, old;
			int tag = WireFormat.getTagFieldNumber(t);
			switch (tag) {
			case 0:
				return;
			case OsmandOdb.TransportRouteSchedule.TRIPINTERVALS_FIELD_NUMBER:
				sizeL = codedIS.readRawVarint32();
				old = codedIS.pushLimit(sizeL);
				while (codedIS.getBytesUntilLimit() > 0) {
					interval = codedIS.readRawVarint32();
					schedule.tripIntervals.add(interval);
				}
				codedIS.popLimit(old);				
				break;
			case OsmandOdb.TransportRouteSchedule.AVGSTOPINTERVALS_FIELD_NUMBER:
				sizeL = codedIS.readRawVarint32();
				old = codedIS.pushLimit(sizeL);
				while (codedIS.getBytesUntilLimit() > 0) {
					interval = codedIS.readRawVarint32();
					schedule.avgStopIntervals.add(interval);
				}
				codedIS.popLimit(old);
				break;
			case OsmandOdb.TransportRouteSchedule.AVGWAITINTERVALS_FIELD_NUMBER:
				sizeL = codedIS.readRawVarint32();
				old = codedIS.pushLimit(sizeL);
				while (codedIS.getBytesUntilLimit() > 0) {
					interval = codedIS.readRawVarint32();
					schedule.avgWaitIntervals.add(interval);
				}
				codedIS.popLimit(old);
				break;
//			case OsmandOdb.TransportRouteSchedule.EXCEPTIONS_FIELD_NUMBER:
//				break;
			default:
				skipUnknownField(t);
				break;
			}
		}
		
	}

	protected void initializeStringTable(TransportIndex ind, TIntObjectHashMap<String> stringTable) throws IOException {
		int[] values = stringTable.keys();
		Arrays.sort(values);
		codedIS.seek(ind.stringTable.fileOffset);
		int oldLimit = codedIS.pushLimit(ind.stringTable.length);
		int current = 0;
		int i = 0;
		while (i < values.length) {
			int t = codedIS.readTag();
			int tag = WireFormat.getTagFieldNumber(t);
			switch (tag) {
			case 0:
				break;
			case OsmandOdb.StringTable.S_FIELD_NUMBER:
				if (current == values[i]) {
					String value = codedIS.readString();
					stringTable.put(values[i], value);
					i++;
				} else {
					skipUnknownField(t);
				}
				current ++;
				break;
			default:
				skipUnknownField(t);
				break;
			}
		}
		codedIS.popLimit(oldLimit);
	}

	protected void initializeNames(boolean onlyDescription, net.osmand.data.TransportRoute dataObject,
			TIntObjectHashMap<String> stringTable) throws IOException {
		if(dataObject.getName().length() > 0){
			dataObject.setName(stringTable.get(dataObject.getName().charAt(0)));
		}
		if(dataObject.getEnName(false).length() > 0){
			dataObject.setEnName(stringTable.get(dataObject.getEnName(false).charAt(0)));
		}
		if(dataObject.getName().length() > 0 && dataObject.getName("en").length() == 0){
			dataObject.setEnName(Junidecode.unidecode(dataObject.getName()));
		}
		if(dataObject.getOperator() != null && dataObject.getOperator().length() > 0){
			dataObject.setOperator(stringTable.get(dataObject.getOperator().charAt(0)));
		}
		if(dataObject.getColor() != null && dataObject.getColor().length() > 0){
			dataObject.setColor(stringTable.get(dataObject.getColor().charAt(0)));
		}
		if(dataObject.getType() != null && dataObject.getType().length() > 0){
			dataObject.setType(stringTable.get(dataObject.getType().charAt(0)));
		}
		if (!onlyDescription) {
			for (TransportStop s : dataObject.getForwardStops()) {
				initializeNames(stringTable, s);
			}
		}
	}

	protected void initializeNames(TIntObjectHashMap<String> stringTable, TransportStop s) {
		for (TransportStopExit exit : s.getExits())	{
			if (exit.getRef().length() > 0) {
				exit.setRef(stringTable.get(exit.getRef().charAt(0)));
			}
		}
		if (s.getName().length() > 0) {
			s.setName(stringTable.get(s.getName().charAt(0)));
		}
		if (s.getEnName(false).length() > 0) {
			s.setEnName(stringTable.get(s.getEnName(false).charAt(0)));
		}
		Map<String, String> namesMap = new HashMap<>(s.getNamesMap(false));
		if (!s.getNamesMap(false).isEmpty()) {
			s.getNamesMap(false).clear();
		}
		Iterator<Map.Entry<String, String>> it = namesMap.entrySet().iterator();
		while (it.hasNext()) {
			Map.Entry<String, String> e = it.next();
			s.setName(stringTable.get(e.getKey().charAt(0)),stringTable.get(e.getValue().charAt(0)));
		}
	}

	
	
	private TransportStop readTransportRouteStop(int dx, int dy, long did, TIntObjectHashMap<String> stringTable, 
			int filePointer) throws IOException {
		TransportStop dataObject = new TransportStop();
		dataObject.setFileOffset(codedIS.getTotalBytesRead());
		// dataObject.setReferencesToRoutes(new int[] {filePointer});
		boolean end = false;
		while(!end){
			int t = codedIS.readTag();
			int tag = WireFormat.getTagFieldNumber(t);
			switch (tag) {
			case 0:
				end = true;
				break;
			case OsmandOdb.TransportRouteStop.NAME_EN_FIELD_NUMBER :
				dataObject.setEnName(regStr(stringTable)); //$NON-NLS-1$
				break;
			case OsmandOdb.TransportRouteStop.NAME_FIELD_NUMBER :
				dataObject.setName(regStr(stringTable)); //$NON-NLS-1$
				break;
			case OsmandOdb.TransportRouteStop.ID_FIELD_NUMBER :
				did += codedIS.readSInt64();
				break;
			case OsmandOdb.TransportRouteStop.DX_FIELD_NUMBER :
				dx += codedIS.readSInt32();
				break;
			case OsmandOdb.TransportRouteStop.DY_FIELD_NUMBER :
				dy += codedIS.readSInt32();
				break;
			default:
				skipUnknownField(t);
				break;
			}
		}
		dataObject.setId(did);
		dataObject.setLocation(BinaryMapIndexReader.TRANSPORT_STOP_ZOOM, dx, dy);
		return dataObject;
	}
	
	private TransportStop readTransportStop(int shift, int cleft, int cright, int ctop, int cbottom, SearchRequest<TransportStop> req) throws IOException {
		int tag = WireFormat.getTagFieldNumber(codedIS.readTag());
		if(OsmandOdb.TransportStop.DX_FIELD_NUMBER != tag) {
			throw new IllegalArgumentException();
		}
		int x = codedIS.readSInt32() + cleft;
		
		tag = WireFormat.getTagFieldNumber(codedIS.readTag());
		if(OsmandOdb.TransportStop.DY_FIELD_NUMBER != tag) {
			throw new IllegalArgumentException();
		}
		int y = codedIS.readSInt32() + ctop;
		if(req.right < x || req.left > x || req.top > y || req.bottom < y){
			codedIS.skipRawBytes(codedIS.getBytesUntilLimit());
			return null;
		}
		
		req.numberOfAcceptedObjects++;
		req.cacheTypes.clear();
		
		TransportStop dataObject = new TransportStop();
		dataObject.setLocation(BinaryMapIndexReader.TRANSPORT_STOP_ZOOM, x, y);
		dataObject.setFileOffset(shift);
		List<String> names = null;
		while(true){
			int t = codedIS.readTag();
			tag = WireFormat.getTagFieldNumber(t);
			switch (tag) {
			case 0:
				dataObject.setReferencesToRoutes(req.cacheTypes.toArray());
				if(dataObject.getName("en").length() == 0){
					dataObject.setEnName(Junidecode.unidecode(dataObject.getName()));
				}
				return dataObject;
			case OsmandOdb.TransportStop.ROUTES_FIELD_NUMBER :
				req.cacheTypes.add(shift - codedIS.readUInt32());
				break;
			case OsmandOdb.TransportStop.NAME_EN_FIELD_NUMBER :
				if (req.stringTable != null) {
					dataObject.setEnName(regStr(req.stringTable)); //$NON-NLS-1$
				} else {
					skipUnknownField(t);
				}
				break;
			case OsmandOdb.TransportStop.NAME_FIELD_NUMBER :
				if (req.stringTable != null) {
					dataObject.setName(regStr(req.stringTable)); //$NON-NLS-1$
				} else {
					skipUnknownField(t);
				}
				break;
			case OsmandOdb.TransportStop.ADDITIONALNAMEPAIRS_FIELD_NUMBER :
				if (req.stringTable != null) {
					int sizeL = codedIS.readRawVarint32();
					int oldRef = codedIS.pushLimit(sizeL);
					while (codedIS.getBytesUntilLimit() > 0) {
						dataObject.setName(regStr(req.stringTable,codedIS.readRawVarint32()),
								regStr(req.stringTable,codedIS.readRawVarint32()));
					}
					codedIS.popLimit(oldRef);
				} else {
					skipUnknownField(t);
				}
				break;
			case OsmandOdb.TransportStop.ID_FIELD_NUMBER :
				dataObject.setId(codedIS.readSInt64());
				break;
			case OsmandOdb.TransportStop.EXITS_FIELD_NUMBER :
				int length = codedIS.readRawVarint32();
				int oldLimit = codedIS.pushLimit(length);

				TransportStopExit transportStopExit = readTransportStopExit(cleft, ctop, req);
				dataObject.addExit(transportStopExit);
				codedIS.popLimit(oldLimit);
				break;
			default:
				skipUnknownField(t);
				break;
			}
		}
	}

	private TransportStopExit readTransportStopExit(int cleft, int ctop, SearchRequest<TransportStop> req) throws IOException {

		TransportStopExit dataObject = new TransportStopExit();
		int x = 0;
		int y = 0;

		while (true) {
			int t = codedIS.readTag();
			int tag = WireFormat.getTagFieldNumber(t);

			switch (tag) {
				case 0:
					if (dataObject.getName("en").length() == 0) {
						dataObject.setEnName(Junidecode.unidecode(dataObject.getName()));
					}
					if (x != 0 || y != 0) {
						dataObject.setLocation(BinaryMapIndexReader.TRANSPORT_STOP_ZOOM, x, y);
					}
					return dataObject;
				case OsmandOdb.TransportStopExit.REF_FIELD_NUMBER:
					if (req.stringTable != null) {
						dataObject.setRef(regStr(req.stringTable));
					} else {
						skipUnknownField(t);
					}
					break;
				case OsmandOdb.TransportStopExit.DX_FIELD_NUMBER:
					x = codedIS.readSInt32() + cleft;
					break;
				case OsmandOdb.TransportStopExit.DY_FIELD_NUMBER:
					y = codedIS.readSInt32() + ctop;
					break;
				default:
					skipUnknownField(t);
					break;
			}
		}
	}


}
!@#$%
20190530_075256,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_c10616
package net.osmand.binary;

import gnu.trove.list.array.TIntArrayList;
import gnu.trove.map.hash.TIntObjectHashMap;

import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import net.osmand.binary.BinaryMapIndexReader.SearchRequest;
import net.osmand.data.TransportSchedule;
import net.osmand.data.TransportStop;
import net.osmand.data.TransportStopExit;
import net.osmand.osm.edit.Node;
import net.osmand.osm.edit.Way;
import net.osmand.util.MapUtils;
import net.sf.junidecode.Junidecode;

import com.google.protobuf.CodedInputStream;
import com.google.protobuf.WireFormat;

public class BinaryMapTransportReaderAdapter {
	private CodedInputStream codedIS;
	private final BinaryMapIndexReader map;
	
	protected BinaryMapTransportReaderAdapter(BinaryMapIndexReader map){
		this.codedIS = map.codedIS;
		this.map = map;
	}

	private void skipUnknownField(int t) throws IOException {
		map.skipUnknownField(t);
	}
	
	private int readInt() throws IOException {
		return map.readInt();
	}

	public static class TransportIndex extends BinaryIndexPart {
		int left = 0;
		int right = 0;
		int top = 0;
		int bottom = 0;

		int stopsFileOffset = 0;
		int stopsFileLength = 0;
		
		public String getPartName() {
			return "Transport";
		}

		public int getFieldNumber() {
			return OsmandOdb.OsmAndStructure.TRANSPORTINDEX_FIELD_NUMBER;
		}

		public int getLeft() {
			return left;
		}

		public int getRight() {
			return right;
		}

		public int getTop() {
			return top;
		}

		public int getBottom() {
			return bottom;
		}

		IndexStringTable stringTable = null;
	}

	protected static class IndexStringTable {
		int fileOffset = 0;
		int length = 0;

		// offset from start for each SIZE_OFFSET_ARRAY elements
		// (SIZE_OFFSET_ARRAY + 1) offset = offsets[0] + skipOneString()
		TIntArrayList offsets = new TIntArrayList();

	}
	
	
	protected void readTransportIndex(TransportIndex ind) throws IOException {
		while(true){
			int t = codedIS.readTag();
			int tag = WireFormat.getTagFieldNumber(t);
			switch (tag) {
			case 0:
				return;
			case OsmandOdb.OsmAndTransportIndex.ROUTES_FIELD_NUMBER :
				skipUnknownField(t);
				break;
			case OsmandOdb.OsmAndTransportIndex.NAME_FIELD_NUMBER :
				ind.setName(codedIS.readString());
				break;
			case OsmandOdb.OsmAndTransportIndex.STOPS_FIELD_NUMBER :
				ind.stopsFileLength = readInt();
				ind.stopsFileOffset = codedIS.getTotalBytesRead();
				int old = codedIS.pushLimit(ind.stopsFileLength);
				readTransportBounds(ind);
				codedIS.popLimit(old);
				break;
			case OsmandOdb.OsmAndTransportIndex.STRINGTABLE_FIELD_NUMBER :
				IndexStringTable st = new IndexStringTable();
				st.length = codedIS.readRawVarint32();
				st.fileOffset = codedIS.getTotalBytesRead();
				// Do not cache for now save memory
				// readStringTable(st, 0, 20, true);
				ind.stringTable = st;
				codedIS.seek(st.length + st.fileOffset);
				break;
			default:
				skipUnknownField(t);
				break;
			}
		}
	}
	
	private void readTransportBounds(TransportIndex ind) throws IOException {
		while(true){
			int t = codedIS.readTag();
			int tag = WireFormat.getTagFieldNumber(t);
			switch (tag) {
			case 0:
				return;
			case OsmandOdb.TransportStopsTree.LEFT_FIELD_NUMBER :
				ind.left = codedIS.readSInt32();
				break;
			case OsmandOdb.TransportStopsTree.RIGHT_FIELD_NUMBER :
				ind.right = codedIS.readSInt32(); 
				break;
			case OsmandOdb.TransportStopsTree.TOP_FIELD_NUMBER :
				ind.top = codedIS.readSInt32();
				break;
			case OsmandOdb.TransportStopsTree.BOTTOM_FIELD_NUMBER :
				ind.bottom = codedIS.readSInt32(); 
				break;
			default:
				skipUnknownField(t);
				break;
			}
		}
	}
	
	protected void searchTransportTreeBounds(int pleft, int pright, int ptop, int pbottom,
			SearchRequest<TransportStop> req) throws IOException {
		int init = 0;
		int lastIndexResult = -1;
		int cright = 0;
		int cleft = 0;
		int ctop = 0;
		int cbottom = 0;
		req.numberOfReadSubtrees++;
		while(true){
			if(req.isCancelled()){
				return;
			}
			int t = codedIS.readTag();
			int tag = WireFormat.getTagFieldNumber(t);
			if(init == 0xf){
				// coordinates are init
				init = 0;
				if(cright < req.left || cleft > req.right || ctop > req.bottom || cbottom < req.top){
					return;
				} else {
					req.numberOfAcceptedSubtrees++;
				}
			}
			switch (tag) {
			case 0:
				return;
			case OsmandOdb.TransportStopsTree.BOTTOM_FIELD_NUMBER :
				cbottom = codedIS.readSInt32() + pbottom;
				init |= 1;
				break;
			case OsmandOdb.TransportStopsTree.LEFT_FIELD_NUMBER :
				cleft = codedIS.readSInt32() + pleft;
				init |= 2;
				break;
			case OsmandOdb.TransportStopsTree.RIGHT_FIELD_NUMBER :
				cright = codedIS.readSInt32() + pright;
				init |= 4;
				break;
			case OsmandOdb.TransportStopsTree.TOP_FIELD_NUMBER :
				ctop = codedIS.readSInt32() + ptop;
				init |= 8;
				break;
			case OsmandOdb.TransportStopsTree.LEAFS_FIELD_NUMBER :
				int stopOffset = codedIS.getTotalBytesRead();
				int length = codedIS.readRawVarint32();
				int oldLimit = codedIS.pushLimit(length);
				if(lastIndexResult == -1){
					lastIndexResult = req.getSearchResults().size();
				}
				req.numberOfVisitedObjects++;
				TransportStop transportStop = readTransportStop(stopOffset, cleft, cright, ctop, cbottom, req);
				if(transportStop != null){
					req.publish(transportStop);
				}
				codedIS.popLimit(oldLimit);
				break;
			case OsmandOdb.TransportStopsTree.SUBTREES_FIELD_NUMBER :
				// left, ... already initialized 
				length = readInt();
				int filePointer = codedIS.getTotalBytesRead();
				if (req.limit == -1 || req.limit >= req.getSearchResults().size()) {
					oldLimit = codedIS.pushLimit(length);
					searchTransportTreeBounds(cleft, cright, ctop, cbottom, req);
					codedIS.popLimit(oldLimit);
				}
				codedIS.seek(filePointer + length);
				
				if(lastIndexResult >= 0){
					throw new IllegalStateException();
				}
				break;
			case OsmandOdb.TransportStopsTree.BASEID_FIELD_NUMBER :
				long baseId = codedIS.readUInt64();
				if (lastIndexResult != -1) {
					for (int i = lastIndexResult; i < req.getSearchResults().size(); i++) {
						TransportStop rs = req.getSearchResults().get(i);
						rs.setId(rs.getId() + baseId);
					}
				}
				break;
			default:
				skipUnknownField(t);
				break;
			}
		}
	}
	
	private String regStr(TIntObjectHashMap<String> stringTable) throws IOException{
		int i = codedIS.readUInt32();
		stringTable.putIfAbsent(i, "");
		return ((char) i)+"";
	}

	private String regStr(TIntObjectHashMap<String> stringTable, int i) throws IOException{
		stringTable.putIfAbsent(i, "");
		return ((char) i)+"";
	}
	
	public net.osmand.data.TransportRoute getTransportRoute(int filePointer, TIntObjectHashMap<String> stringTable,
			boolean onlyDescription) throws IOException {
		codedIS.seek(filePointer);
		int routeLength = codedIS.readRawVarint32();
		int old = codedIS.pushLimit(routeLength);
		net.osmand.data.TransportRoute dataObject = new net.osmand.data.TransportRoute();
		boolean end = false;
		long rid = 0;
		int rx = 0;
		int ry = 0;
		while(!end){
			int t = codedIS.readTag();
			int tag = WireFormat.getTagFieldNumber(t);
			switch (tag) {
			case 0:
				end = true;
				break;
			case OsmandOdb.TransportRoute.DISTANCE_FIELD_NUMBER :
				dataObject.setDistance(codedIS.readUInt32());
				break;
			case OsmandOdb.TransportRoute.ID_FIELD_NUMBER :
				dataObject.setId(codedIS.readUInt64());
				break;
			case OsmandOdb.TransportRoute.REF_FIELD_NUMBER :
				dataObject.setRef(codedIS.readString());
				break;
			case OsmandOdb.TransportRoute.TYPE_FIELD_NUMBER :
				dataObject.setType(regStr(stringTable)); //$NON-NLS-1$
				break;
			case OsmandOdb.TransportRoute.NAME_EN_FIELD_NUMBER :
				dataObject.setEnName(regStr(stringTable)); //$NON-NLS-1$
				break;
			case OsmandOdb.TransportRoute.NAME_FIELD_NUMBER :
				dataObject.setName(regStr(stringTable)); //$NON-NLS-1$
				break;
			case OsmandOdb.TransportRoute.OPERATOR_FIELD_NUMBER:
				dataObject.setOperator(regStr(stringTable)); //$NON-NLS-1$
				break;
			case OsmandOdb.TransportRoute.COLOR_FIELD_NUMBER:
				dataObject.setColor(regStr(stringTable));
				break;
			case OsmandOdb.TransportRoute.GEOMETRY_FIELD_NUMBER:
				int sizeL = codedIS.readRawVarint32();
				int pold = codedIS.pushLimit(sizeL);
				int px = 0; 
				int py = 0;
				Way w = new Way(-1);
				while (codedIS.getBytesUntilLimit() > 0) {
					int ddx = (codedIS.readSInt32() << BinaryMapIndexReader.SHIFT_COORDINATES);
					int ddy = (codedIS.readSInt32() << BinaryMapIndexReader.SHIFT_COORDINATES);
					if(ddx == 0 && ddy == 0) {
						if(w.getNodes().size() > 0) {
							dataObject.addWay(w);
						}
						w = new Way(-1);
					} else {
						int x = ddx + px;
						int y = ddy + py;
						w.addNode(new Node(MapUtils.get31LatitudeY(y), MapUtils.get31LongitudeX(x), -1));
						px = x;
						py = y;
					}
				}
				if(w.getNodes().size() > 0) {
					dataObject.addWay(w);
				}
				codedIS.popLimit(pold);
				break;
			// deprecated
//			case OsmandOdb.TransportRoute.REVERSESTOPS_FIELD_NUMBER:
//				break;
			case OsmandOdb.TransportRoute.SCHEDULETRIP_FIELD_NUMBER:
				sizeL = codedIS.readRawVarint32();
				pold = codedIS.pushLimit(sizeL);
				readTransportSchedule(dataObject.getOrCreateSchedule());
				codedIS.popLimit(pold);
				break;
			case OsmandOdb.TransportRoute.DIRECTSTOPS_FIELD_NUMBER:
				if(onlyDescription){
					end = true;
					codedIS.skipRawBytes(codedIS.getBytesUntilLimit());
					break;
				}
				int length = codedIS.readRawVarint32();
				int olds = codedIS.pushLimit(length);
				TransportStop stop = readTransportRouteStop(rx, ry, rid, stringTable, filePointer);
				dataObject.getForwardStops().add(stop);
				rid = stop.getId();
				rx = (int) MapUtils.getTileNumberX(BinaryMapIndexReader.TRANSPORT_STOP_ZOOM, stop.getLocation().getLongitude());
				ry = (int) MapUtils.getTileNumberY(BinaryMapIndexReader.TRANSPORT_STOP_ZOOM, stop.getLocation().getLatitude());
				codedIS.popLimit(olds);
				break;
			default:
				skipUnknownField(t);
				break;
			}
		}
		codedIS.popLimit(old);
		
		
		return dataObject;
	}
	
	private void readTransportSchedule(TransportSchedule schedule) throws IOException {
		while(true){
			int t = codedIS.readTag();
			int interval, sizeL, old;
			int tag = WireFormat.getTagFieldNumber(t);
			switch (tag) {
			case 0:
				return;
			case OsmandOdb.TransportRouteSchedule.TRIPINTERVALS_FIELD_NUMBER:
				sizeL = codedIS.readRawVarint32();
				old = codedIS.pushLimit(sizeL);
				while (codedIS.getBytesUntilLimit() > 0) {
					interval = codedIS.readRawVarint32();
					schedule.tripIntervals.add(interval);
				}
				codedIS.popLimit(old);				
				break;
			case OsmandOdb.TransportRouteSchedule.AVGSTOPINTERVALS_FIELD_NUMBER:
				sizeL = codedIS.readRawVarint32();
				old = codedIS.pushLimit(sizeL);
				while (codedIS.getBytesUntilLimit() > 0) {
					interval = codedIS.readRawVarint32();
					schedule.avgStopIntervals.add(interval);
				}
				codedIS.popLimit(old);
				break;
			case OsmandOdb.TransportRouteSchedule.AVGWAITINTERVALS_FIELD_NUMBER:
				sizeL = codedIS.readRawVarint32();
				old = codedIS.pushLimit(sizeL);
				while (codedIS.getBytesUntilLimit() > 0) {
					interval = codedIS.readRawVarint32();
					schedule.avgWaitIntervals.add(interval);
				}
				codedIS.popLimit(old);
				break;
//			case OsmandOdb.TransportRouteSchedule.EXCEPTIONS_FIELD_NUMBER:
//				break;
			default:
				skipUnknownField(t);
				break;
			}
		}
		
	}

	protected void initializeStringTable(TransportIndex ind, TIntObjectHashMap<String> stringTable) throws IOException {
		int[] values = stringTable.keys();
		Arrays.sort(values);
		codedIS.seek(ind.stringTable.fileOffset);
		int oldLimit = codedIS.pushLimit(ind.stringTable.length);
		int current = 0;
		int i = 0;
		while (i < values.length && codedIS.getBytesUntilLimit() > 0) {
			int t = codedIS.readTag();
			int tag = WireFormat.getTagFieldNumber(t);
			switch (tag) {
			case 0:
				return;
			case OsmandOdb.StringTable.S_FIELD_NUMBER:
				if (current == values[i]) {
					String value = codedIS.readString();
					stringTable.put(values[i], value);
					i++;
				} else {
					skipUnknownField(t);
				}
				current ++;
				break;
			default:
				skipUnknownField(t);
				break;
			}
		}
		codedIS.popLimit(oldLimit);
	}

	protected void initializeNames(boolean onlyDescription, net.osmand.data.TransportRoute dataObject,
			TIntObjectHashMap<String> stringTable) throws IOException {
		if(dataObject.getName().length() > 0){
			dataObject.setName(stringTable.get(dataObject.getName().charAt(0)));
		}
		if(dataObject.getEnName(false).length() > 0){
			dataObject.setEnName(stringTable.get(dataObject.getEnName(false).charAt(0)));
		}
		if(dataObject.getName().length() > 0 && dataObject.getName("en").length() == 0){
			dataObject.setEnName(Junidecode.unidecode(dataObject.getName()));
		}
		if(dataObject.getOperator() != null && dataObject.getOperator().length() > 0){
			dataObject.setOperator(stringTable.get(dataObject.getOperator().charAt(0)));
		}
		if(dataObject.getColor() != null && dataObject.getColor().length() > 0){
			dataObject.setColor(stringTable.get(dataObject.getColor().charAt(0)));
		}
		if(dataObject.getType() != null && dataObject.getType().length() > 0){
			dataObject.setType(stringTable.get(dataObject.getType().charAt(0)));
		}
		if (!onlyDescription) {
			for (TransportStop s : dataObject.getForwardStops()) {
				initializeNames(stringTable, s);
			}
		}
	}

	protected void initializeNames(TIntObjectHashMap<String> stringTable, TransportStop s) {
		for (TransportStopExit exit : s.getExits())	{
			if (exit.getRef().length() > 0) {
				exit.setRef(stringTable.get(exit.getRef().charAt(0)));
			}
		}
		if (s.getName().length() > 0) {
			s.setName(stringTable.get(s.getName().charAt(0)));
		}
		if (s.getEnName(false).length() > 0) {
			s.setEnName(stringTable.get(s.getEnName(false).charAt(0)));
		}
		Map<String, String> namesMap = new HashMap<>(s.getNamesMap(false));
		if (!s.getNamesMap(false).isEmpty()) {
			s.getNamesMap(false).clear();
		}
		Iterator<Map.Entry<String, String>> it = namesMap.entrySet().iterator();
		while (it.hasNext()) {
			Map.Entry<String, String> e = it.next();
			s.setName(stringTable.get(e.getKey().charAt(0)),stringTable.get(e.getValue().charAt(0)));
		}
	}

	
	
	private TransportStop readTransportRouteStop(int dx, int dy, long did, TIntObjectHashMap<String> stringTable, 
			int filePointer) throws IOException {
		TransportStop dataObject = new TransportStop();
		dataObject.setFileOffset(codedIS.getTotalBytesRead());
		// dataObject.setReferencesToRoutes(new int[] {filePointer});
		boolean end = false;
		while(!end){
			int t = codedIS.readTag();
			int tag = WireFormat.getTagFieldNumber(t);
			switch (tag) {
			case 0:
				end = true;
				break;
			case OsmandOdb.TransportRouteStop.NAME_EN_FIELD_NUMBER :
				dataObject.setEnName(regStr(stringTable)); //$NON-NLS-1$
				break;
			case OsmandOdb.TransportRouteStop.NAME_FIELD_NUMBER :
				dataObject.setName(regStr(stringTable)); //$NON-NLS-1$
				break;
			case OsmandOdb.TransportRouteStop.ID_FIELD_NUMBER :
				did += codedIS.readSInt64();
				break;
			case OsmandOdb.TransportRouteStop.DX_FIELD_NUMBER :
				dx += codedIS.readSInt32();
				break;
			case OsmandOdb.TransportRouteStop.DY_FIELD_NUMBER :
				dy += codedIS.readSInt32();
				break;
			default:
				skipUnknownField(t);
				break;
			}
		}
		dataObject.setId(did);
		dataObject.setLocation(BinaryMapIndexReader.TRANSPORT_STOP_ZOOM, dx, dy);
		return dataObject;
	}
	
	private TransportStop readTransportStop(int shift, int cleft, int cright, int ctop, int cbottom, SearchRequest<TransportStop> req) throws IOException {
		int tag = WireFormat.getTagFieldNumber(codedIS.readTag());
		if(OsmandOdb.TransportStop.DX_FIELD_NUMBER != tag) {
			throw new IllegalArgumentException();
		}
		int x = codedIS.readSInt32() + cleft;
		
		tag = WireFormat.getTagFieldNumber(codedIS.readTag());
		if(OsmandOdb.TransportStop.DY_FIELD_NUMBER != tag) {
			throw new IllegalArgumentException();
		}
		int y = codedIS.readSInt32() + ctop;
		if(req.right < x || req.left > x || req.top > y || req.bottom < y){
			codedIS.skipRawBytes(codedIS.getBytesUntilLimit());
			return null;
		}
		
		req.numberOfAcceptedObjects++;
		req.cacheTypes.clear();
		
		TransportStop dataObject = new TransportStop();
		dataObject.setLocation(BinaryMapIndexReader.TRANSPORT_STOP_ZOOM, x, y);
		dataObject.setFileOffset(shift);
		List<String> names = null;
		while(true){
			int t = codedIS.readTag();
			tag = WireFormat.getTagFieldNumber(t);
			switch (tag) {
			case 0:
				dataObject.setReferencesToRoutes(req.cacheTypes.toArray());
				if(dataObject.getName("en").length() == 0){
					dataObject.setEnName(Junidecode.unidecode(dataObject.getName()));
				}
				return dataObject;
			case OsmandOdb.TransportStop.ROUTES_FIELD_NUMBER :
				req.cacheTypes.add(shift - codedIS.readUInt32());
				break;
			case OsmandOdb.TransportStop.NAME_EN_FIELD_NUMBER :
				if (req.stringTable != null) {
					dataObject.setEnName(regStr(req.stringTable)); //$NON-NLS-1$
				} else {
					skipUnknownField(t);
				}
				break;
			case OsmandOdb.TransportStop.NAME_FIELD_NUMBER :
				if (req.stringTable != null) {
					dataObject.setName(regStr(req.stringTable)); //$NON-NLS-1$
				} else {
					skipUnknownField(t);
				}
				break;
			case OsmandOdb.TransportStop.ADDITIONALNAMEPAIRS_FIELD_NUMBER :
				if (req.stringTable != null) {
					int sizeL = codedIS.readRawVarint32();
					int oldRef = codedIS.pushLimit(sizeL);
					while (codedIS.getBytesUntilLimit() > 0) {
						dataObject.setName(regStr(req.stringTable,codedIS.readRawVarint32()),
								regStr(req.stringTable,codedIS.readRawVarint32()));
					}
					codedIS.popLimit(oldRef);
				} else {
					skipUnknownField(t);
				}
				break;
			case OsmandOdb.TransportStop.ID_FIELD_NUMBER :
				dataObject.setId(codedIS.readSInt64());
				break;
			case OsmandOdb.TransportStop.EXITS_FIELD_NUMBER :
				int length = codedIS.readRawVarint32();
				int oldLimit = codedIS.pushLimit(length);

				TransportStopExit transportStopExit = readTransportStopExit(cleft, ctop, req);
				dataObject.addExit(transportStopExit);
				codedIS.popLimit(oldLimit);
				break;
			default:
				skipUnknownField(t);
				break;
			}
		}
	}

	private TransportStopExit readTransportStopExit(int cleft, int ctop, SearchRequest<TransportStop> req) throws IOException {

		TransportStopExit dataObject = new TransportStopExit();
		int x = 0;
		int y = 0;

		while (true) {
			int t = codedIS.readTag();
			int tag = WireFormat.getTagFieldNumber(t);

			switch (tag) {
				case 0:
					if (dataObject.getName("en").length() == 0) {
						dataObject.setEnName(Junidecode.unidecode(dataObject.getName()));
					}
					if (x != 0 || y != 0) {
						dataObject.setLocation(BinaryMapIndexReader.TRANSPORT_STOP_ZOOM, x, y);
					}
					return dataObject;
				case OsmandOdb.TransportStopExit.REF_FIELD_NUMBER:
					if (req.stringTable != null) {
						dataObject.setRef(regStr(req.stringTable));
					} else {
						skipUnknownField(t);
					}
					break;
				case OsmandOdb.TransportStopExit.DX_FIELD_NUMBER:
					x = codedIS.readSInt32() + cleft;
					break;
				case OsmandOdb.TransportStopExit.DY_FIELD_NUMBER:
					y = codedIS.readSInt32() + ctop;
					break;
				default:
					skipUnknownField(t);
					break;
			}
		}
	}


}
!@#$%
20190530_075321,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_b09896
package net.osmand.plus;

import android.content.Context;

import net.osmand.StateChangedListener;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;


public class ApplicationMode {
	private static Map<String, Set<ApplicationMode>> widgetsVisibilityMap = new LinkedHashMap<>();
	private static Map<String, Set<ApplicationMode>> widgetsAvailabilityMap = new LinkedHashMap<>();
	private static List<ApplicationMode> values = new ArrayList<>();
	private static List<ApplicationMode> cachedFilteredValues = new ArrayList<>();
	/*
	 * DEFAULT("Browse map"), CAR("Car"), BICYCLE("Bicycle"), PEDESTRIAN("Pedestrian");
	 */
	public static final ApplicationMode DEFAULT = create(R.string.app_mode_default, "default").speed(1.5f, 5).arrivalDistance(90).defLocation().
			icon(R.drawable.map_world_globe_dark, R.drawable.ic_world_globe_dark).reg();

	public static final ApplicationMode CAR = create(R.string.app_mode_car, "car").speed(15.3f, 35).carLocation().
			icon(R.drawable.map_action_car_dark, R.drawable.ic_action_car_dark).reg();

	public static final ApplicationMode BICYCLE = create(R.string.app_mode_bicycle, "bicycle").speed(5.5f, 15).arrivalDistance(60).offRouteDistance(50).bicycleLocation().
			icon(R.drawable.map_action_bicycle_dark, R.drawable.ic_action_bicycle_dark).reg();

	public static final ApplicationMode PEDESTRIAN = create(R.string.app_mode_pedestrian, "pedestrian").speed(1.5f, 5).arrivalDistance(45).offRouteDistance(20).
			icon(R.drawable.map_action_pedestrian_dark, R.drawable.ic_action_pedestrian_dark).reg();

	public static final ApplicationMode AIRCRAFT = create(R.string.app_mode_aircraft, "aircraft").speed(40f, 100).carLocation().
			icon(R.drawable.map_action_aircraft, R.drawable.ic_action_aircraft).reg();

	public static final ApplicationMode BOAT = create(R.string.app_mode_boat, "boat").speed(5.5f, 20).carLocation().
			icon(R.drawable.map_action_sail_boat_dark, R.drawable.ic_action_sail_boat_dark).reg();

	public static final ApplicationMode HIKING = create(R.string.app_mode_hiking, "hiking").speed(1.5f, 5).parent(PEDESTRIAN).
			icon(R.drawable.map_action_trekking_dark, R.drawable.ic_action_trekking_dark).reg();

	public static final ApplicationMode MOTORCYCLE = create(R.string.app_mode_motorcycle, "motorcycle").speed(15.3f, 40).
			carLocation().parent(CAR).
			icon(R.drawable.map_action_motorcycle_dark, R.drawable.ic_action_motorcycle_dark).reg();

	public static final ApplicationMode TRUCK = create(R.string.app_mode_truck, "truck").speed(15.3f, 40).
			carLocation().parent(CAR).
			icon(R.drawable.map_action_truck_dark, R.drawable.ic_action_truck_dark).reg();

	public static final ApplicationMode BUS = create(R.string.app_mode_bus, "bus").speed(15.3f, 40).
			carLocation().parent(CAR).
			icon(R.drawable.map_action_bus_dark, R.drawable.ic_action_bus_dark).reg();

	public static final ApplicationMode TRAIN = create(R.string.app_mode_train, "train").speed(25f, 40).
			carLocation().icon(R.drawable.map_action_train, R.drawable.ic_action_train).reg();

	public static final ApplicationMode PUBLIC_TRANSPORT = create(R.string.app_mode_public_transport, "public_transport").
			icon(R.drawable.map_action_bus_dark, R.drawable.ic_action_bus_dark).reg();

	static {
		ApplicationMode[] exceptDefault = new ApplicationMode[]{CAR, PEDESTRIAN, BICYCLE, BOAT, AIRCRAFT, BUS, TRAIN};
		ApplicationMode[] exceptPedestrianAndDefault = new ApplicationMode[]{CAR, BICYCLE, BOAT, AIRCRAFT, BUS, TRAIN};
		ApplicationMode[] exceptAirBoatDefault = new ApplicationMode[]{CAR, BICYCLE, PEDESTRIAN};
		ApplicationMode[] pedestrian = new ApplicationMode[]{PEDESTRIAN};
		ApplicationMode[] pedestrianBicycle = new ApplicationMode[]{PEDESTRIAN, BICYCLE};

		ApplicationMode[] all = null;
		ApplicationMode[] none = new ApplicationMode[]{};

		// left
		regWidgetVisibility("next_turn", exceptPedestrianAndDefault);
		regWidgetVisibility("next_turn_small", pedestrian);
		regWidgetVisibility("next_next_turn", exceptPedestrianAndDefault);
		regWidgetAvailability("next_turn", exceptDefault);
		regWidgetAvailability("next_turn_small", exceptDefault);
		regWidgetAvailability("next_next_turn", exceptDefault);

		// right
		regWidgetVisibility("intermediate_distance", all);
		regWidgetVisibility("distance", all);
		regWidgetVisibility("time", all);
		regWidgetVisibility("intermediate_time", all);
		regWidgetVisibility("speed", exceptPedestrianAndDefault);
		regWidgetVisibility("max_speed", CAR);
		regWidgetVisibility("altitude", pedestrianBicycle);
		regWidgetVisibility("gps_info", none);
		regWidgetAvailability("intermediate_distance", all);
		regWidgetAvailability("distance", all);
		regWidgetAvailability("time", all);
		regWidgetAvailability("intermediate_time", all);
		regWidgetAvailability("map_marker_1st", none);
		regWidgetAvailability("map_marker_2nd", none);

		// top
		regWidgetVisibility("config", none);
		regWidgetVisibility("layers", none);
		regWidgetVisibility("compass", none);
		regWidgetVisibility("street_name", exceptAirBoatDefault);
		regWidgetVisibility("back_to_location", all);
		regWidgetVisibility("monitoring_services", none);
		regWidgetVisibility("bgService", none);
	}


	private static class ApplicationModeBuilder {


		private ApplicationMode applicationMode;

		public ApplicationMode reg() {
			values.add(applicationMode);
			return applicationMode;
		}

		public ApplicationModeBuilder icon(int mapIcon, int smallIconDark) {
			applicationMode.mapIconId = mapIcon;
			applicationMode.smallIconDark = smallIconDark;
			return this;
		}

		public ApplicationModeBuilder carLocation() {
			applicationMode.bearingIconDay = R.drawable.map_car_bearing;
			applicationMode.bearingIconNight = R.drawable.map_car_bearing_night;
			applicationMode.headingIconDay = R.drawable.map_car_location_view_angle;
			applicationMode.headingIconNight = R.drawable.map_car_location_view_angle_night;
			applicationMode.locationIconDay = R.drawable.map_car_location;
			applicationMode.locationIconNight = R.drawable.map_car_location_night;
			applicationMode.locationIconDayLost = R.drawable.map_car_location_lost;
			applicationMode.locationIconNightLost = R.drawable.map_car_location_lost_night;
			return this;
		}

		public ApplicationModeBuilder parent(ApplicationMode parent) {
			applicationMode.parent = parent;
			return this;
		}

		public ApplicationModeBuilder bicycleLocation() {
			applicationMode.bearingIconDay = R.drawable.map_bicycle_bearing;
			applicationMode.bearingIconNight = R.drawable.map_bicycle_bearing_night;
			applicationMode.headingIconDay = R.drawable.map_bicycle_location_view_angle;
			applicationMode.headingIconNight = R.drawable.map_bicycle_location_view_angle_night;
			applicationMode.locationIconDay = R.drawable.map_bicycle_location;
			applicationMode.locationIconNight = R.drawable.map_bicycle_location_night;
			applicationMode.locationIconDayLost = R.drawable.map_bicycle_location_lost;
			applicationMode.locationIconNightLost = R.drawable.map_bicycle_location_lost_night;
			return this;
		}

		public ApplicationModeBuilder defLocation() {
			applicationMode.bearingIconDay = R.drawable.map_pedestrian_bearing;
			applicationMode.bearingIconNight = R.drawable.map_pedestrian_bearing_night;
			applicationMode.headingIconDay = R.drawable.map_default_location_view_angle;
			applicationMode.headingIconNight = R.drawable.map_default_location_view_angle_night;
			applicationMode.locationIconDay = R.drawable.map_pedestrian_location;
			applicationMode.locationIconNight = R.drawable.map_pedestrian_location_night;
			applicationMode.locationIconDayLost = R.drawable.map_pedestrian_location_lost;
			applicationMode.locationIconNightLost = R.drawable.map_pedestrian_location_lost_night;
			return this;
		}

		public ApplicationModeBuilder speed(float defSpeed, int distForTurn) {
			applicationMode.defaultSpeed = defSpeed;
			applicationMode.minDistanceForTurn = distForTurn;
			return this;
		}

		public ApplicationModeBuilder arrivalDistance(int arrivalDistance) {
			applicationMode.arrivalDistance = arrivalDistance;
			return this;
		}

		public ApplicationModeBuilder offRouteDistance(int offRouteDistance) {
			applicationMode.offRouteDistance = offRouteDistance;
			return this;
		}
	}

	private static ApplicationModeBuilder create(int key, String stringKey) {
		ApplicationModeBuilder builder = new ApplicationModeBuilder();
		builder.applicationMode = new ApplicationMode(key, stringKey);
		return builder;
	}

	private ApplicationMode(int key, String stringKey) {
		this.key = key;
		this.stringKey = stringKey;
	}

	public static List<ApplicationMode> values(OsmandApplication app) {
		if (customizationListener == null) {
			customizationListener = new OsmAndAppCustomization.OsmAndAppCustomizationListener() {
				@Override
				public void onOsmAndSettingsCustomized() {
					cachedFilteredValues = new ArrayList<>();
				}
			};
			app.getAppCustomization().addListener(customizationListener);
		}
		if (cachedFilteredValues.isEmpty()) {
			OsmandSettings settings = app.getSettings();
			if (listener == null) {
				listener = new StateChangedListener<String>() {
					@Override
					public void stateChanged(String change) {
						cachedFilteredValues = new ArrayList<>();
					}
				};
				settings.AVAILABLE_APP_MODES.addListener(listener);
			}
			String available = settings.AVAILABLE_APP_MODES.get();
			cachedFilteredValues = new ArrayList<>();
			for (ApplicationMode v : values) {
				if (available.indexOf(v.getStringKey() + ",") != -1 || v == DEFAULT) {
					cachedFilteredValues.add(v);
				}
			}
		}
		return cachedFilteredValues;
	}

	public static List<ApplicationMode> allPossibleValues() {
		return new ArrayList<ApplicationMode>(values);
	}


	// returns modifiable ! Set<ApplicationMode> to exclude non-wanted derived
	public static Set<ApplicationMode> regWidgetVisibility(String widgetId, ApplicationMode... am) {
		HashSet<ApplicationMode> set = new HashSet<>();
		if (am == null) {
			set.addAll(values);
		} else {
			Collections.addAll(set, am);
		}
		for (ApplicationMode m : values) {
			// add derived modes
			if (set.contains(m.getParent())) {
				set.add(m);
			}
		}
		widgetsVisibilityMap.put(widgetId, set);
		return set;
	}

	public boolean isWidgetCollapsible(String key) {
		return false;
	}

	public boolean isWidgetVisible(OsmandApplication app, String key) {
		if (app.getAppCustomization().areWidgetsCustomized()) {
			return app.getAppCustomization().isWidgetVisible(key, this);
		}
		Set<ApplicationMode> set = widgetsVisibilityMap.get(key);
		if (set == null) {
			return false;
		}
		return set.contains(this);
	}

	public static Set<ApplicationMode> regWidgetAvailability(String widgetId, ApplicationMode... am) {
		HashSet<ApplicationMode> set = new HashSet<>();
		if (am == null) {
			set.addAll(values);
		} else {
			Collections.addAll(set, am);
		}
		for (ApplicationMode m : values) {
			// add derived modes
			if (set.contains(m.getParent())) {
				set.add(m);
			}
		}
		widgetsAvailabilityMap.put(widgetId, set);
		return set;
	}

	public boolean isWidgetAvailable(OsmandApplication app, String key) {
		if (app.getAppCustomization().areWidgetsCustomized()) {
			return app.getAppCustomization().isWidgetAvailable(key, this);
		}
		Set<ApplicationMode> set = widgetsAvailabilityMap.get(key);
		if (set == null) {
			return true;
		}
		return set.contains(this);
	}

	public static List<ApplicationMode> getModesDerivedFrom(ApplicationMode am) {
		List<ApplicationMode> list = new ArrayList<ApplicationMode>();
		for (ApplicationMode a : values) {
			if (a == am || a.getParent() == am) {
				list.add(a);
			}
		}
		return list;
	}

	public ApplicationMode getParent() {
		return parent;
	}

	public int getSmallIconDark() {
		return smallIconDark;
	}

	public boolean hasFastSpeed() {
		return getDefaultSpeed() > 10;
	}

	public int getResourceBearingDay() {
		return bearingIconDay;
	}

	public int getResourceBearingNight() {
		//return bearingIconDay;
		return bearingIconNight;
	}

	public int getResourceHeadingDay() {
		return headingIconDay;
	}

	public int getResourceHeadingNight() {
		return headingIconNight;
	}

	public int getResourceLocationDay() {
		return locationIconDay;
	}

	public int getResourceLocationNight() {
		//return locationIconDay;
		return locationIconNight;
	}

	public int getResourceLocationDayLost() {
		return locationIconDayLost;
	}

	public int getResourceLocationNightLost() {
		return locationIconNightLost;
	}

	public String getStringKey() {
		return stringKey;
	}

	public int getMapIconId() {
		return mapIconId;
	}

	public int getStringResource() {
		return key;
	}

	public String toHumanString(Context ctx) {
		return ctx.getString(key);
	}

	public String toHumanStringCtx(Context ctx) {
		return ctx.getString(key);
	}

	public static ApplicationMode valueOfStringKey(String key, ApplicationMode def) {
		for (ApplicationMode p : values) {
			if (p.getStringKey().equals(key)) {
				return p;
			}
		}
		return def;
	}

	public float getDefaultSpeed() {
		return defaultSpeed;
	}

	public int getMinDistanceForTurn() {
		return minDistanceForTurn;
	}

	public int getArrivalDistance() {
		return arrivalDistance;
	}

	public int getOffRouteDistance() {
		return offRouteDistance;
	}

	public boolean isDerivedRoutingFrom(ApplicationMode mode) {
		return this == mode || getParent() == mode;
	}

	private final int key;
	private final String stringKey;

	private ApplicationMode parent;
	private int mapIconId = R.drawable.map_world_globe_dark;
	private int smallIconDark = R.drawable.ic_world_globe_dark;
	private float defaultSpeed = 10f;
	private int minDistanceForTurn = 50;
	private int arrivalDistance = 90;
	private int offRouteDistance = 350;
	private int bearingIconDay = R.drawable.map_pedestrian_bearing;
	private int bearingIconNight = R.drawable.map_pedestrian_bearing_night;
	private int headingIconDay = R.drawable.map_pedestrian_location_view_angle;
	private int headingIconNight = R.drawable.map_pedestrian_location_view_angle_night;
	private int locationIconDay = R.drawable.map_pedestrian_location;
	private int locationIconNight = R.drawable.map_pedestrian_location_night;
	private int locationIconDayLost = R.drawable.map_pedestrian_location_lost;
	private int locationIconNightLost = R.drawable.map_pedestrian_location_lost_night;
	private static StateChangedListener<String> listener;
	private static OsmAndAppCustomization.OsmAndAppCustomizationListener customizationListener;
}
!@#$%
20190530_075321,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_a09896
package net.osmand.plus;

import android.content.Context;

import net.osmand.StateChangedListener;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;


public class ApplicationMode {
	private static Map<String, Set<ApplicationMode>> widgetsVisibilityMap = new LinkedHashMap<>();
	private static Map<String, Set<ApplicationMode>> widgetsAvailabilityMap = new LinkedHashMap<>();
	private static List<ApplicationMode> values = new ArrayList<>();
	private static List<ApplicationMode> cachedFilteredValues = new ArrayList<>();
	/*
	 * DEFAULT("Browse map"), CAR("Car"), BICYCLE("Bicycle"), PEDESTRIAN("Pedestrian");
	 */
	public static final ApplicationMode DEFAULT = create(R.string.app_mode_default, "default").speed(1.5f, 5).arrivalDistance(90).defLocation().
			icon(R.drawable.map_world_globe_dark, R.drawable.ic_world_globe_dark).reg();

	public static final ApplicationMode CAR = create(R.string.app_mode_car, "car").speed(15.3f, 35).carLocation().
			icon(R.drawable.map_action_car_dark, R.drawable.ic_action_car_dark).reg();

	public static final ApplicationMode BICYCLE = create(R.string.app_mode_bicycle, "bicycle").speed(5.5f, 15).arrivalDistance(60).offRouteDistance(50).bicycleLocation().
			icon(R.drawable.map_action_bicycle_dark, R.drawable.ic_action_bicycle_dark).reg();

	public static final ApplicationMode PEDESTRIAN = create(R.string.app_mode_pedestrian, "pedestrian").speed(1.5f, 5).arrivalDistance(45).offRouteDistance(20).
			icon(R.drawable.map_action_pedestrian_dark, R.drawable.ic_action_pedestrian_dark).reg();

	public static final ApplicationMode AIRCRAFT = create(R.string.app_mode_aircraft, "aircraft").speed(40f, 100).carLocation().
			icon(R.drawable.map_action_aircraft, R.drawable.ic_action_aircraft).reg();

	public static final ApplicationMode BOAT = create(R.string.app_mode_boat, "boat").speed(5.5f, 20).carLocation().
			icon(R.drawable.map_action_sail_boat_dark, R.drawable.ic_action_sail_boat_dark).reg();

	public static final ApplicationMode HIKING = create(R.string.app_mode_hiking, "hiking").speed(1.5f, 5).parent(PEDESTRIAN).
			icon(R.drawable.map_action_trekking_dark, R.drawable.ic_action_trekking_dark).reg();

	public static final ApplicationMode MOTORCYCLE = create(R.string.app_mode_motorcycle, "motorcycle").speed(15.3f, 40).
			carLocation().parent(CAR).
			icon(R.drawable.map_action_motorcycle_dark, R.drawable.ic_action_motorcycle_dark).reg();

	public static final ApplicationMode TRUCK = create(R.string.app_mode_truck, "truck").speed(15.3f, 40).
			carLocation().parent(CAR).
			icon(R.drawable.map_action_truck_dark, R.drawable.ic_action_truck_dark).reg();

	public static final ApplicationMode BUS = create(R.string.app_mode_bus, "bus").speed(15.3f, 40).
			carLocation().parent(CAR).
			icon(R.drawable.map_action_bus_dark, R.drawable.ic_action_bus_dark).reg();

	public static final ApplicationMode TRAIN = create(R.string.app_mode_train, "train").speed(25f, 40).
			carLocation().icon(R.drawable.map_action_train, R.drawable.ic_action_train).reg();

	static {
		ApplicationMode[] exceptDefault = new ApplicationMode[]{CAR, PEDESTRIAN, BICYCLE, BOAT, AIRCRAFT, BUS, TRAIN};
		ApplicationMode[] exceptPedestrianAndDefault = new ApplicationMode[]{CAR, BICYCLE, BOAT, AIRCRAFT, BUS, TRAIN};
		ApplicationMode[] exceptAirBoatDefault = new ApplicationMode[]{CAR, BICYCLE, PEDESTRIAN};
		ApplicationMode[] pedestrian = new ApplicationMode[]{PEDESTRIAN};
		ApplicationMode[] pedestrianBicycle = new ApplicationMode[]{PEDESTRIAN, BICYCLE};

		ApplicationMode[] all = null;
		ApplicationMode[] none = new ApplicationMode[]{};

		// left
		regWidgetVisibility("next_turn", exceptPedestrianAndDefault);
		regWidgetVisibility("next_turn_small", pedestrian);
		regWidgetVisibility("next_next_turn", exceptPedestrianAndDefault);
		regWidgetAvailability("next_turn", exceptDefault);
		regWidgetAvailability("next_turn_small", exceptDefault);
		regWidgetAvailability("next_next_turn", exceptDefault);

		// right
		regWidgetVisibility("intermediate_distance", all);
		regWidgetVisibility("distance", all);
		regWidgetVisibility("time", all);
		regWidgetVisibility("intermediate_time", all);
		regWidgetVisibility("speed", exceptPedestrianAndDefault);
		regWidgetVisibility("max_speed", CAR);
		regWidgetVisibility("altitude", pedestrianBicycle);
		regWidgetVisibility("gps_info", none);
		regWidgetAvailability("intermediate_distance", all);
		regWidgetAvailability("distance", all);
		regWidgetAvailability("time", all);
		regWidgetAvailability("intermediate_time", all);
		regWidgetAvailability("map_marker_1st", none);
		regWidgetAvailability("map_marker_2nd", none);

		// top
		regWidgetVisibility("config", none);
		regWidgetVisibility("layers", none);
		regWidgetVisibility("compass", none);
		regWidgetVisibility("street_name", exceptAirBoatDefault);
		regWidgetVisibility("back_to_location", all);
		regWidgetVisibility("monitoring_services", none);
		regWidgetVisibility("bgService", none);
	}


	private static class ApplicationModeBuilder {


		private ApplicationMode applicationMode;

		public ApplicationMode reg() {
			values.add(applicationMode);
			return applicationMode;
		}

		public ApplicationModeBuilder icon(int mapIcon, int smallIconDark) {
			applicationMode.mapIconId = mapIcon;
			applicationMode.smallIconDark = smallIconDark;
			return this;
		}

		public ApplicationModeBuilder carLocation() {
			applicationMode.bearingIconDay = R.drawable.map_car_bearing;
			applicationMode.bearingIconNight = R.drawable.map_car_bearing_night;
			applicationMode.headingIconDay = R.drawable.map_car_location_view_angle;
			applicationMode.headingIconNight = R.drawable.map_car_location_view_angle_night;
			applicationMode.locationIconDay = R.drawable.map_car_location;
			applicationMode.locationIconNight = R.drawable.map_car_location_night;
			applicationMode.locationIconDayLost = R.drawable.map_car_location_lost;
			applicationMode.locationIconNightLost = R.drawable.map_car_location_lost_night;
			return this;
		}

		public ApplicationModeBuilder parent(ApplicationMode parent) {
			applicationMode.parent = parent;
			return this;
		}

		public ApplicationModeBuilder bicycleLocation() {
			applicationMode.bearingIconDay = R.drawable.map_bicycle_bearing;
			applicationMode.bearingIconNight = R.drawable.map_bicycle_bearing_night;
			applicationMode.headingIconDay = R.drawable.map_bicycle_location_view_angle;
			applicationMode.headingIconNight = R.drawable.map_bicycle_location_view_angle_night;
			applicationMode.locationIconDay = R.drawable.map_bicycle_location;
			applicationMode.locationIconNight = R.drawable.map_bicycle_location_night;
			applicationMode.locationIconDayLost = R.drawable.map_bicycle_location_lost;
			applicationMode.locationIconNightLost = R.drawable.map_bicycle_location_lost_night;
			return this;
		}

		public ApplicationModeBuilder defLocation() {
			applicationMode.bearingIconDay = R.drawable.map_pedestrian_bearing;
			applicationMode.bearingIconNight = R.drawable.map_pedestrian_bearing_night;
			applicationMode.headingIconDay = R.drawable.map_default_location_view_angle;
			applicationMode.headingIconNight = R.drawable.map_default_location_view_angle_night;
			applicationMode.locationIconDay = R.drawable.map_pedestrian_location;
			applicationMode.locationIconNight = R.drawable.map_pedestrian_location_night;
			applicationMode.locationIconDayLost = R.drawable.map_pedestrian_location_lost;
			applicationMode.locationIconNightLost = R.drawable.map_pedestrian_location_lost_night;
			return this;
		}

		public ApplicationModeBuilder speed(float defSpeed, int distForTurn) {
			applicationMode.defaultSpeed = defSpeed;
			applicationMode.minDistanceForTurn = distForTurn;
			return this;
		}

		public ApplicationModeBuilder arrivalDistance(int arrivalDistance) {
			applicationMode.arrivalDistance = arrivalDistance;
			return this;
		}

		public ApplicationModeBuilder offRouteDistance(int offRouteDistance) {
			applicationMode.offRouteDistance = offRouteDistance;
			return this;
		}
	}

	private static ApplicationModeBuilder create(int key, String stringKey) {
		ApplicationModeBuilder builder = new ApplicationModeBuilder();
		builder.applicationMode = new ApplicationMode(key, stringKey);
		return builder;
	}

	private ApplicationMode(int key, String stringKey) {
		this.key = key;
		this.stringKey = stringKey;
	}

	public static List<ApplicationMode> values(OsmandApplication app) {
		if (customizationListener == null) {
			customizationListener = new OsmAndAppCustomization.OsmAndAppCustomizationListener() {
				@Override
				public void onOsmAndSettingsCustomized() {
					cachedFilteredValues = new ArrayList<>();
				}
			};
			app.getAppCustomization().addListener(customizationListener);
		}
		if (cachedFilteredValues.isEmpty()) {
			OsmandSettings settings = app.getSettings();
			if (listener == null) {
				listener = new StateChangedListener<String>() {
					@Override
					public void stateChanged(String change) {
						cachedFilteredValues = new ArrayList<>();
					}
				};
				settings.AVAILABLE_APP_MODES.addListener(listener);
			}
			String available = settings.AVAILABLE_APP_MODES.get();
			cachedFilteredValues = new ArrayList<>();
			for (ApplicationMode v : values) {
				if (available.indexOf(v.getStringKey() + ",") != -1 || v == DEFAULT) {
					cachedFilteredValues.add(v);
				}
			}
		}
		return cachedFilteredValues;
	}

	public static List<ApplicationMode> allPossibleValues() {
		return new ArrayList<ApplicationMode>(values);
	}


	// returns modifiable ! Set<ApplicationMode> to exclude non-wanted derived
	public static Set<ApplicationMode> regWidgetVisibility(String widgetId, ApplicationMode... am) {
		HashSet<ApplicationMode> set = new HashSet<>();
		if (am == null) {
			set.addAll(values);
		} else {
			Collections.addAll(set, am);
		}
		for (ApplicationMode m : values) {
			// add derived modes
			if (set.contains(m.getParent())) {
				set.add(m);
			}
		}
		widgetsVisibilityMap.put(widgetId, set);
		return set;
	}

	public boolean isWidgetCollapsible(String key) {
		return false;
	}

	public boolean isWidgetVisible(OsmandApplication app, String key) {
		if (app.getAppCustomization().areWidgetsCustomized()) {
			return app.getAppCustomization().isWidgetVisible(key, this);
		}
		Set<ApplicationMode> set = widgetsVisibilityMap.get(key);
		if (set == null) {
			return false;
		}
		return set.contains(this);
	}

	public static Set<ApplicationMode> regWidgetAvailability(String widgetId, ApplicationMode... am) {
		HashSet<ApplicationMode> set = new HashSet<>();
		if (am == null) {
			set.addAll(values);
		} else {
			Collections.addAll(set, am);
		}
		for (ApplicationMode m : values) {
			// add derived modes
			if (set.contains(m.getParent())) {
				set.add(m);
			}
		}
		widgetsAvailabilityMap.put(widgetId, set);
		return set;
	}

	public boolean isWidgetAvailable(OsmandApplication app, String key) {
		if (app.getAppCustomization().areWidgetsCustomized()) {
			return app.getAppCustomization().isWidgetAvailable(key, this);
		}
		Set<ApplicationMode> set = widgetsAvailabilityMap.get(key);
		if (set == null) {
			return true;
		}
		return set.contains(this);
	}

	public static List<ApplicationMode> getModesDerivedFrom(ApplicationMode am) {
		List<ApplicationMode> list = new ArrayList<ApplicationMode>();
		for (ApplicationMode a : values) {
			if (a == am || a.getParent() == am) {
				list.add(a);
			}
		}
		return list;
	}

	public ApplicationMode getParent() {
		return parent;
	}

	public int getSmallIconDark() {
		return smallIconDark;
	}

	public boolean hasFastSpeed() {
		return getDefaultSpeed() > 10;
	}

	public int getResourceBearingDay() {
		return bearingIconDay;
	}

	public int getResourceBearingNight() {
		//return bearingIconDay;
		return bearingIconNight;
	}

	public int getResourceHeadingDay() {
		return headingIconDay;
	}

	public int getResourceHeadingNight() {
		return headingIconNight;
	}

	public int getResourceLocationDay() {
		return locationIconDay;
	}

	public int getResourceLocationNight() {
		//return locationIconDay;
		return locationIconNight;
	}

	public int getResourceLocationDayLost() {
		return locationIconDayLost;
	}

	public int getResourceLocationNightLost() {
		return locationIconNightLost;
	}

	public String getStringKey() {
		return stringKey;
	}

	public int getMapIconId() {
		return mapIconId;
	}

	public int getStringResource() {
		return key;
	}

	public String toHumanString(Context ctx) {
		return ctx.getString(key);
	}

	public String toHumanStringCtx(Context ctx) {
		return ctx.getString(key);
	}

	public static ApplicationMode valueOfStringKey(String key, ApplicationMode def) {
		for (ApplicationMode p : values) {
			if (p.getStringKey().equals(key)) {
				return p;
			}
		}
		return def;
	}

	public float getDefaultSpeed() {
		return defaultSpeed;
	}

	public int getMinDistanceForTurn() {
		return minDistanceForTurn;
	}

	public int getArrivalDistance() {
		return arrivalDistance;
	}

	public int getOffRouteDistance() {
		return offRouteDistance;
	}

	public boolean isDerivedRoutingFrom(ApplicationMode mode) {
		return this == mode || getParent() == mode;
	}

	private final int key;
	private final String stringKey;

	private ApplicationMode parent;
	private int mapIconId = R.drawable.map_world_globe_dark;
	private int smallIconDark = R.drawable.ic_world_globe_dark;
	private float defaultSpeed = 10f;
	private int minDistanceForTurn = 50;
	private int arrivalDistance = 90;
	private int offRouteDistance = 350;
	private int bearingIconDay = R.drawable.map_pedestrian_bearing;
	private int bearingIconNight = R.drawable.map_pedestrian_bearing_night;
	private int headingIconDay = R.drawable.map_pedestrian_location_view_angle;
	private int headingIconNight = R.drawable.map_pedestrian_location_view_angle_night;
	private int locationIconDay = R.drawable.map_pedestrian_location;
	private int locationIconNight = R.drawable.map_pedestrian_location_night;
	private int locationIconDayLost = R.drawable.map_pedestrian_location_lost;
	private int locationIconNightLost = R.drawable.map_pedestrian_location_lost_night;
	private static StateChangedListener<String> listener;
	private static OsmAndAppCustomization.OsmAndAppCustomizationListener customizationListener;
}
!@#$%
20190530_075321,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_c09896
package net.osmand.plus;

import android.content.Context;

import net.osmand.StateChangedListener;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;


public class ApplicationMode {
	private static Map<String, Set<ApplicationMode>> widgetsVisibilityMap = new LinkedHashMap<>();
	private static Map<String, Set<ApplicationMode>> widgetsAvailabilityMap = new LinkedHashMap<>();
	private static List<ApplicationMode> values = new ArrayList<>();
	private static List<ApplicationMode> cachedFilteredValues = new ArrayList<>();
	/*
	 * DEFAULT("Browse map"), CAR("Car"), BICYCLE("Bicycle"), PEDESTRIAN("Pedestrian"); NAUTICAL("boat")
	 */
	public static final ApplicationMode DEFAULT = create(R.string.app_mode_default, "default").speed(1.5f, 5).arrivalDistance(90).defLocation().
			icon(R.drawable.map_world_globe_dark, R.drawable.ic_world_globe_dark).reg();

	public static final ApplicationMode CAR = create(R.string.app_mode_car, "car").speed(15.3f, 35).carLocation().
			icon(R.drawable.map_action_car_dark, R.drawable.ic_action_car_dark).reg();

	public static final ApplicationMode BICYCLE = create(R.string.app_mode_bicycle, "bicycle").speed(5.5f, 15).arrivalDistance(60).offRouteDistance(50).bicycleLocation().
			icon(R.drawable.map_action_bicycle_dark, R.drawable.ic_action_bicycle_dark).reg();

	public static final ApplicationMode PEDESTRIAN = create(R.string.app_mode_pedestrian, "pedestrian").speed(1.5f, 5).arrivalDistance(45).offRouteDistance(20).
			icon(R.drawable.map_action_pedestrian_dark, R.drawable.ic_action_pedestrian_dark).reg();

	public static final ApplicationMode AIRCRAFT = create(R.string.app_mode_aircraft, "aircraft").speed(40f, 100).carLocation().
			icon(R.drawable.map_action_aircraft, R.drawable.ic_action_aircraft).reg();

	public static final ApplicationMode BOAT = create(R.string.app_mode_boat, "boat").speed(5.5f, 20).carLocation().nauticalLocation().
			icon(R.drawable.map_action_sail_boat_dark, R.drawable.ic_action_sail_boat_dark).reg();

	public static final ApplicationMode HIKING = create(R.string.app_mode_hiking, "hiking").speed(1.5f, 5).parent(PEDESTRIAN).
			icon(R.drawable.map_action_trekking_dark, R.drawable.ic_action_trekking_dark).reg();

	public static final ApplicationMode MOTORCYCLE = create(R.string.app_mode_motorcycle, "motorcycle").speed(15.3f, 40).
			carLocation().parent(CAR).
			icon(R.drawable.map_action_motorcycle_dark, R.drawable.ic_action_motorcycle_dark).reg();

	public static final ApplicationMode TRUCK = create(R.string.app_mode_truck, "truck").speed(15.3f, 40).
			carLocation().parent(CAR).
			icon(R.drawable.map_action_truck_dark, R.drawable.ic_action_truck_dark).reg();

	public static final ApplicationMode BUS = create(R.string.app_mode_bus, "bus").speed(15.3f, 40).
			carLocation().parent(CAR).
			icon(R.drawable.map_action_bus_dark, R.drawable.ic_action_bus_dark).reg();

	public static final ApplicationMode TRAIN = create(R.string.app_mode_train, "train").speed(25f, 40).
			carLocation().icon(R.drawable.map_action_train, R.drawable.ic_action_train).reg();

	static {
		ApplicationMode[] exceptDefault = new ApplicationMode[]{CAR, PEDESTRIAN, BICYCLE, BOAT, AIRCRAFT, BUS, TRAIN};
		ApplicationMode[] exceptPedestrianAndDefault = new ApplicationMode[]{CAR, BICYCLE, BOAT, AIRCRAFT, BUS, TRAIN};
		ApplicationMode[] exceptAirBoatDefault = new ApplicationMode[]{CAR, BICYCLE, PEDESTRIAN};
		ApplicationMode[] pedestrian = new ApplicationMode[]{PEDESTRIAN};
		ApplicationMode[] pedestrianBicycle = new ApplicationMode[]{PEDESTRIAN, BICYCLE};

		ApplicationMode[] all = null;
		ApplicationMode[] none = new ApplicationMode[]{};

		// left
		regWidgetVisibility("next_turn", exceptPedestrianAndDefault);
		regWidgetVisibility("next_turn_small", pedestrian);
		regWidgetVisibility("next_next_turn", exceptPedestrianAndDefault);
		regWidgetAvailability("next_turn", exceptDefault);
		regWidgetAvailability("next_turn_small", exceptDefault);
		regWidgetAvailability("next_next_turn", exceptDefault);

		// right
		regWidgetVisibility("intermediate_distance", all);
		regWidgetVisibility("distance", all);
		regWidgetVisibility("time", all);
		regWidgetVisibility("intermediate_time", all);
		regWidgetVisibility("speed", exceptPedestrianAndDefault);
		regWidgetVisibility("max_speed", CAR);
		regWidgetVisibility("altitude", pedestrianBicycle);
		regWidgetVisibility("gps_info", none);
		regWidgetAvailability("intermediate_distance", all);
		regWidgetAvailability("distance", all);
		regWidgetAvailability("time", all);
		regWidgetAvailability("intermediate_time", all);
		regWidgetAvailability("map_marker_1st", none);
		regWidgetAvailability("map_marker_2nd", none);

		// top
		regWidgetVisibility("config", none);
		regWidgetVisibility("layers", none);
		regWidgetVisibility("compass", none);
		regWidgetVisibility("street_name", exceptAirBoatDefault);
		regWidgetVisibility("back_to_location", all);
		regWidgetVisibility("monitoring_services", none);
		regWidgetVisibility("bgService", none);
	}


	private static class ApplicationModeBuilder {


		private ApplicationMode applicationMode;

		public ApplicationMode reg() {
			values.add(applicationMode);
			return applicationMode;
		}

		public ApplicationModeBuilder icon(int mapIcon, int smallIconDark) {
			applicationMode.mapIconId = mapIcon;
			applicationMode.smallIconDark = smallIconDark;
			return this;
		}

		public ApplicationModeBuilder carLocation() {
			applicationMode.bearingIconDay = R.drawable.map_car_bearing;
			applicationMode.bearingIconNight = R.drawable.map_car_bearing_night;
			applicationMode.headingIconDay = R.drawable.map_car_location_view_angle;
			applicationMode.headingIconNight = R.drawable.map_car_location_view_angle_night;
			applicationMode.locationIconDay = R.drawable.map_car_location;
			applicationMode.locationIconNight = R.drawable.map_car_location_night;
			applicationMode.locationIconDayLost = R.drawable.map_car_location_lost;
			applicationMode.locationIconNightLost = R.drawable.map_car_location_lost_night;
			return this;
		}

		public ApplicationModeBuilder parent(ApplicationMode parent) {
			applicationMode.parent = parent;
			return this;
		}

		public ApplicationModeBuilder bicycleLocation() {
			applicationMode.bearingIconDay = R.drawable.map_bicycle_bearing;
			applicationMode.bearingIconNight = R.drawable.map_bicycle_bearing_night;
			applicationMode.headingIconDay = R.drawable.map_bicycle_location_view_angle;
			applicationMode.headingIconNight = R.drawable.map_bicycle_location_view_angle_night;
			applicationMode.locationIconDay = R.drawable.map_bicycle_location;
			applicationMode.locationIconNight = R.drawable.map_bicycle_location_night;
			applicationMode.locationIconDayLost = R.drawable.map_bicycle_location_lost;
			applicationMode.locationIconNightLost = R.drawable.map_bicycle_location_lost_night;
			return this;
		}

		public ApplicationModeBuilder defLocation() {
			applicationMode.bearingIconDay = R.drawable.map_pedestrian_bearing;
			applicationMode.bearingIconNight = R.drawable.map_pedestrian_bearing_night;
			applicationMode.headingIconDay = R.drawable.map_default_location_view_angle;
			applicationMode.headingIconNight = R.drawable.map_default_location_view_angle_night;
			applicationMode.locationIconDay = R.drawable.map_pedestrian_location;
			applicationMode.locationIconNight = R.drawable.map_pedestrian_location_night;
			applicationMode.locationIconDayLost = R.drawable.map_pedestrian_location_lost;
			applicationMode.locationIconNightLost = R.drawable.map_pedestrian_location_lost_night;
			return this;
		}

		public ApplicationModeBuilder nauticalLocation() {
			applicationMode.bearingIconDay = R.drawable.map_nautical_bearing;
			applicationMode.bearingIconNight = R.drawable.map_nautical_bearing_night;
			applicationMode.headingIconDay = R.drawable.map_nautical_location_view_angle;
			applicationMode.headingIconNight = R.drawable.map_nautical_location_view_angle_night;
			applicationMode.locationIconDay = R.drawable.map_nautical_location;
			applicationMode.locationIconNight = R.drawable.map_nautical_location_night;
			return this;
		}

		public ApplicationModeBuilder speed(float defSpeed, int distForTurn) {
			applicationMode.defaultSpeed = defSpeed;
			applicationMode.minDistanceForTurn = distForTurn;
			return this;
		}

		public ApplicationModeBuilder arrivalDistance(int arrivalDistance) {
			applicationMode.arrivalDistance = arrivalDistance;
			return this;
		}

		public ApplicationModeBuilder offRouteDistance(int offRouteDistance) {
			applicationMode.offRouteDistance = offRouteDistance;
			return this;
		}
	}

	private static ApplicationModeBuilder create(int key, String stringKey) {
		ApplicationModeBuilder builder = new ApplicationModeBuilder();
		builder.applicationMode = new ApplicationMode(key, stringKey);
		return builder;
	}

	private ApplicationMode(int key, String stringKey) {
		this.key = key;
		this.stringKey = stringKey;
	}

	public static List<ApplicationMode> values(OsmandApplication app) {
		if (customizationListener == null) {
			customizationListener = new OsmAndAppCustomization.OsmAndAppCustomizationListener() {
				@Override
				public void onOsmAndSettingsCustomized() {
					cachedFilteredValues = new ArrayList<>();
				}
			};
			app.getAppCustomization().addListener(customizationListener);
		}
		if (cachedFilteredValues.isEmpty()) {
			OsmandSettings settings = app.getSettings();
			if (listener == null) {
				listener = new StateChangedListener<String>() {
					@Override
					public void stateChanged(String change) {
						cachedFilteredValues = new ArrayList<>();
					}
				};
				settings.AVAILABLE_APP_MODES.addListener(listener);
			}
			String available = settings.AVAILABLE_APP_MODES.get();
			cachedFilteredValues = new ArrayList<>();
			for (ApplicationMode v : values) {
				if (available.indexOf(v.getStringKey() + ",") != -1 || v == DEFAULT) {
					cachedFilteredValues.add(v);
				}
			}
		}
		return cachedFilteredValues;
	}

	public static List<ApplicationMode> allPossibleValues() {
		return new ArrayList<ApplicationMode>(values);
	}


	// returns modifiable ! Set<ApplicationMode> to exclude non-wanted derived
	public static Set<ApplicationMode> regWidgetVisibility(String widgetId, ApplicationMode... am) {
		HashSet<ApplicationMode> set = new HashSet<>();
		if (am == null) {
			set.addAll(values);
		} else {
			Collections.addAll(set, am);
		}
		for (ApplicationMode m : values) {
			// add derived modes
			if (set.contains(m.getParent())) {
				set.add(m);
			}
		}
		widgetsVisibilityMap.put(widgetId, set);
		return set;
	}

	public boolean isWidgetCollapsible(String key) {
		return false;
	}

	public boolean isWidgetVisible(OsmandApplication app, String key) {
		if (app.getAppCustomization().areWidgetsCustomized()) {
			return app.getAppCustomization().isWidgetVisible(key, this);
		}
		Set<ApplicationMode> set = widgetsVisibilityMap.get(key);
		if (set == null) {
			return false;
		}
		return set.contains(this);
	}

	public static Set<ApplicationMode> regWidgetAvailability(String widgetId, ApplicationMode... am) {
		HashSet<ApplicationMode> set = new HashSet<>();
		if (am == null) {
			set.addAll(values);
		} else {
			Collections.addAll(set, am);
		}
		for (ApplicationMode m : values) {
			// add derived modes
			if (set.contains(m.getParent())) {
				set.add(m);
			}
		}
		widgetsAvailabilityMap.put(widgetId, set);
		return set;
	}

	public boolean isWidgetAvailable(OsmandApplication app, String key) {
		if (app.getAppCustomization().areWidgetsCustomized()) {
			return app.getAppCustomization().isWidgetAvailable(key, this);
		}
		Set<ApplicationMode> set = widgetsAvailabilityMap.get(key);
		if (set == null) {
			return true;
		}
		return set.contains(this);
	}

	public static List<ApplicationMode> getModesDerivedFrom(ApplicationMode am) {
		List<ApplicationMode> list = new ArrayList<ApplicationMode>();
		for (ApplicationMode a : values) {
			if (a == am || a.getParent() == am) {
				list.add(a);
			}
		}
		return list;
	}

	public ApplicationMode getParent() {
		return parent;
	}

	public int getSmallIconDark() {
		return smallIconDark;
	}

	public boolean hasFastSpeed() {
		return getDefaultSpeed() > 10;
	}

	public int getResourceBearingDay() {
		return bearingIconDay;
	}

	public int getResourceBearingNight() {
		//return bearingIconDay;
		return bearingIconNight;
	}

	public int getResourceHeadingDay() {
		return headingIconDay;
	}

	public int getResourceHeadingNight() {
		return headingIconNight;
	}

	public int getResourceLocationDay() {
		return locationIconDay;
	}

	public int getResourceLocationNight() {
		//return locationIconDay;
		return locationIconNight;
	}

	public int getResourceLocationDayLost() {
		return locationIconDayLost;
	}

	public int getResourceLocationNightLost() {
		return locationIconNightLost;
	}

	public String getStringKey() {
		return stringKey;
	}

	public int getMapIconId() {
		return mapIconId;
	}

	public int getStringResource() {
		return key;
	}

	public String toHumanString(Context ctx) {
		return ctx.getString(key);
	}

	public String toHumanStringCtx(Context ctx) {
		return ctx.getString(key);
	}

	public static ApplicationMode valueOfStringKey(String key, ApplicationMode def) {
		for (ApplicationMode p : values) {
			if (p.getStringKey().equals(key)) {
				return p;
			}
		}
		return def;
	}

	public float getDefaultSpeed() {
		return defaultSpeed;
	}

	public int getMinDistanceForTurn() {
		return minDistanceForTurn;
	}

	public int getArrivalDistance() {
		return arrivalDistance;
	}

	public int getOffRouteDistance() {
		return offRouteDistance;
	}

	public boolean isDerivedRoutingFrom(ApplicationMode mode) {
		return this == mode || getParent() == mode;
	}

	private final int key;
	private final String stringKey;

	private ApplicationMode parent;
	private int mapIconId = R.drawable.map_world_globe_dark;
	private int smallIconDark = R.drawable.ic_world_globe_dark;
	private float defaultSpeed = 10f;
	private int minDistanceForTurn = 50;
	private int arrivalDistance = 90;
	private int offRouteDistance = 350;
	private int bearingIconDay = R.drawable.map_pedestrian_bearing;
	private int bearingIconNight = R.drawable.map_pedestrian_bearing_night;
	private int headingIconDay = R.drawable.map_pedestrian_location_view_angle;
	private int headingIconNight = R.drawable.map_pedestrian_location_view_angle_night;
	private int locationIconDay = R.drawable.map_pedestrian_location;
	private int locationIconNight = R.drawable.map_pedestrian_location_night;
	private int locationIconDayLost = R.drawable.map_pedestrian_location_lost;
	private int locationIconNightLost = R.drawable.map_pedestrian_location_lost_night;
	private static StateChangedListener<String> listener;
	private static OsmAndAppCustomization.OsmAndAppCustomizationListener customizationListener;
}
!@#$%
20190530_075524,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_b08792
package net.osmand.router;

import gnu.trove.iterator.TIntIterator;
import gnu.trove.list.array.TIntArrayList;
import gnu.trove.set.hash.TIntHashSet;

import java.io.FileWriter;
import java.io.IOException;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import net.osmand.PlatformUtil;
import net.osmand.binary.BinaryMapIndexReader;
import net.osmand.binary.BinaryMapRouteReaderAdapter.RouteTypeRule;
import net.osmand.binary.RouteDataObject;
import net.osmand.data.LatLon;
import net.osmand.osm.MapRenderingTypes;
import net.osmand.router.BinaryRoutePlanner.FinalRouteSegment;
import net.osmand.router.BinaryRoutePlanner.RouteSegment;
import net.osmand.router.GeneralRouter.GeneralRouterProfile;
import net.osmand.router.RoutePlannerFrontEnd.RouteCalculationMode;
import net.osmand.util.Algorithms;
import net.osmand.util.MapAlgorithms;
import net.osmand.util.MapUtils;

import org.apache.commons.logging.Log;

public class RouteResultPreparation {

	public static boolean PRINT_TO_CONSOLE_ROUTE_INFORMATION_TO_TEST = false;
	public static String PRINT_TO_GPX_FILE = null;
	private static final float TURN_DEGREE_MIN = 45;
	public static final int SHIFT_ID = 6;
	private Log log = PlatformUtil.getLog(RouteResultPreparation.class);
	/**
	 * Helper method to prepare final result 
	 */
	List<RouteSegmentResult> prepareResult(RoutingContext ctx, FinalRouteSegment finalSegment) throws IOException {
		List<RouteSegmentResult> result  = convertFinalSegmentToResults(ctx, finalSegment);
		combineWayPointsForAreaRouting(ctx, result);
		prepareResult(ctx, result);
		return result;
	}
	
	private static class CombineAreaRoutePoint {
		int x31;
		int y31;
		int originalIndex;
	}

	private void combineWayPointsForAreaRouting(RoutingContext ctx, List<RouteSegmentResult> result) {
		for(int i = 0; i < result.size(); i++) {
			RouteSegmentResult rsr = result.get(i);
			RouteDataObject obj = rsr.getObject();
			boolean area = false;
			if(obj.getPoint31XTile(0) == obj.getPoint31XTile(obj.getPointsLength() - 1) &&
					obj.getPoint31YTile(0) == obj.getPoint31YTile(obj.getPointsLength() - 1)) {
				area = true;
			}
			if(!area || !ctx.getRouter().isArea(obj)) {
				continue;
			}
			List<CombineAreaRoutePoint> originalWay = new ArrayList<CombineAreaRoutePoint>();
			List<CombineAreaRoutePoint> routeWay = new ArrayList<CombineAreaRoutePoint>();
			for(int j = 0;  j < obj.getPointsLength(); j++) {
				CombineAreaRoutePoint pnt = new CombineAreaRoutePoint();
				pnt.x31 = obj.getPoint31XTile(j);
				pnt.y31 = obj.getPoint31YTile(j);
				pnt.originalIndex = j;
				
				originalWay.add(pnt);
				if(j >= rsr.getStartPointIndex() && j <= rsr.getEndPointIndex()) {
					routeWay.add(pnt);
				} else if(j <= rsr.getStartPointIndex() && j >= rsr.getEndPointIndex()) {
					routeWay.add(0, pnt);
				}
			}
			int originalSize = routeWay.size();
			simplifyAreaRouteWay(routeWay, originalWay);
			int newsize = routeWay.size();
			if (routeWay.size() != originalSize) {
				RouteDataObject nobj = new RouteDataObject(obj);
				nobj.pointsX = new int[newsize];
				nobj.pointsY = new int[newsize];
				for (int k = 0; k < newsize; k++) {
					nobj.pointsX[k] = routeWay.get(k).x31;
					nobj.pointsY[k] = routeWay.get(k).y31;
				}
				// in future point names might be used
				nobj.restrictions = null;
				nobj.restrictionsVia = null;
				nobj.pointTypes = null;
				nobj.pointNames = null;
				nobj.pointNameTypes = null;
				RouteSegmentResult nrsr = new RouteSegmentResult(nobj, 0, newsize - 1);
				result.set(i, nrsr);
			}
		}
	}

	private void simplifyAreaRouteWay(List<CombineAreaRoutePoint> routeWay, List<CombineAreaRoutePoint> originalWay) {
		boolean changed = true;
		while (changed) {
			changed = false;
			int connectStart = -1;
			int connectLen = 0;
			double dist = 0;
			int length = routeWay.size() - 1;
			while (length > 0 && connectLen == 0) {
				for (int i = 0; i < routeWay.size() - length; i++) {
					CombineAreaRoutePoint p = routeWay.get(i);
					CombineAreaRoutePoint n = routeWay.get(i + length);
					if (segmentLineBelongsToPolygon(p, n, originalWay)) {
						double ndist = BinaryRoutePlanner.squareRootDist(p.x31, p.y31, n.x31, n.y31);
						if (ndist > dist) {
							ndist = dist;
							connectStart = i;
							connectLen = length;
						}
					}
				}
				length--;
			}
			while (connectLen > 1) {
				routeWay.remove(connectStart + 1);
				connectLen--;
				changed = true;
			}
		}
		
	}

	private boolean segmentLineBelongsToPolygon(CombineAreaRoutePoint p, CombineAreaRoutePoint n,
			List<CombineAreaRoutePoint> originalWay) {
		int intersections = 0;
		int mx = p.x31 / 2 + n.x31 / 2;
		int my = p.y31 / 2 + n.y31 / 2;
		for(int i = 1; i < originalWay.size(); i++) {
			CombineAreaRoutePoint p2 = originalWay.get(i -1);
			CombineAreaRoutePoint n2 = originalWay.get(i);
			if(p.originalIndex != i && p.originalIndex != i - 1) {
				if(n.originalIndex != i && n.originalIndex != i - 1) {
					if(MapAlgorithms.linesIntersect(p.x31, p.y31, n.x31, n.y31, p2.x31, p2.y31, n2.x31, n2.y31)) {
						return false;
					}
				}
			}
			int fx = MapAlgorithms.ray_intersect_x(p2.x31, p2.y31, n2.x31, n2.y31, my);
			if (Integer.MIN_VALUE != fx && mx >= fx) {
				intersections++;
			}
		}
		return intersections % 2 == 1;
	}

	List<RouteSegmentResult> prepareResult(RoutingContext ctx, List<RouteSegmentResult> result) throws IOException {
		validateAllPointsConnected(result);
		splitRoadsAndAttachRoadSegments(ctx, result);
		calculateTimeSpeed(ctx, result);
		
		for (int i = 0; i < result.size(); i ++) {
			TurnType turnType = getTurnInfo(result, i, ctx.leftSideNavigation);
			result.get(i).setTurnType(turnType);
		}
		
		determineTurnsToMerge(ctx.leftSideNavigation, result);
		ignorePrecedingStraightsOnSameIntersection(ctx.leftSideNavigation, result);
		justifyUTurns(ctx.leftSideNavigation, result);
		addTurnInfoDescriptions(result);
		return result;
	}

	protected void ignorePrecedingStraightsOnSameIntersection(boolean leftside, List<RouteSegmentResult> result) {
		//Issue 2571: Ignore TurnType.C if immediately followed by another turn in non-motorway cases, as these likely belong to the very same intersection
		RouteSegmentResult nextSegment = null;
		double distanceToNextTurn = 999999;
		for (int i = result.size() - 1; i >= 0; i--) {
			// Mark next "real" turn
			if (nextSegment != null && nextSegment.getTurnType() != null &&
					nextSegment.getTurnType().getValue() != TurnType.C &&
					!isMotorway(nextSegment)) {
				if (distanceToNextTurn == 999999) {
					distanceToNextTurn = 0;
				}
			}
			RouteSegmentResult currentSegment = result.get(i);
			// Identify preceding goStraights within distance limit and suppress
			if (currentSegment != null) {
				distanceToNextTurn += currentSegment.getDistance();
				if (currentSegment.getTurnType() != null &&
						currentSegment.getTurnType().getValue() == TurnType.C &&
						distanceToNextTurn <= 100) {
					result.get(i).getTurnType().setSkipToSpeak(true);
				} else {
					nextSegment = currentSegment;
					distanceToNextTurn = 999999;
				}
			}
		}
	}

	private void justifyUTurns(boolean leftSide, List<RouteSegmentResult> result) {
		int next;
		for (int i = 0; i < result.size() - 1; i = next) {
			next = i + 1;
			TurnType t = result.get(i).getTurnType();
			// justify turn
			if (t != null) {
				TurnType jt = justifyUTurn(leftSide, result, i, t);
				if (jt != null) {
					result.get(i).setTurnType(jt);
					next = i + 2;
				}
			}
		}
	}

	private void calculateTimeSpeed(RoutingContext ctx, List<RouteSegmentResult> result) throws IOException {
		//for Naismith
		boolean usePedestrianHeight = ((((GeneralRouter) ctx.getRouter()).getProfile() == GeneralRouterProfile.PEDESTRIAN) && ((GeneralRouter) ctx.getRouter()).getHeightObstacles());

		for (int i = 0; i < result.size(); i++) {
			RouteSegmentResult rr = result.get(i);
			RouteDataObject road = rr.getObject();
			double distOnRoadToPass = 0;
			double speed = ctx.getRouter().defineVehicleSpeed(road);
			if (speed == 0) {
				speed = ctx.getRouter().getMinDefaultSpeed();
			} else {
				if(speed > 15) {
					// decrease speed proportionally from 15ms=50kmh - 
					// reference speed 30ms=108kmh - 7kmh
					speed = speed - ((speed - 15f) / (30f - 15f) * 2f);
				}
			}
			boolean plus = rr.getStartPointIndex() < rr.getEndPointIndex();
			int next;
			double distance = 0;

			//for Naismith
			float prevHeight = -99999.0f;
			float[] heightDistanceArray = null;
			if (usePedestrianHeight) {
				road.calculateHeightArray();
				heightDistanceArray = road.heightDistanceArray;
			}

			for (int j = rr.getStartPointIndex(); j != rr.getEndPointIndex(); j = next) {
				next = plus ? j + 1 : j - 1;
				double d = measuredDist(road.getPoint31XTile(j), road.getPoint31YTile(j), road.getPoint31XTile(next),
						road.getPoint31YTile(next));
				distance += d;
				double obstacle = ctx.getRouter().defineObstacle(road, j);
				if (obstacle < 0) {
					obstacle = 0;
				}
				distOnRoadToPass += d / speed + obstacle;  //this is time in seconds

				//for Naismith
				if (usePedestrianHeight) {
					int heightIndex = 2 * j + 1;
					if (heightDistanceArray != null && heightIndex < heightDistanceArray.length) {
						float height = heightDistanceArray[heightIndex];
						if (prevHeight != -99999.0f) {
							float heightDiff = height - prevHeight;
							if (heightDiff > 0) {  //ascent only
								distOnRoadToPass += heightDiff * 6.0f;  //Naismith's rule: add 1 hour per every 600m of ascent
							}
						}
					prevHeight = height;
					}
				}
			}

			// last point turn time can be added
			// if(i + 1 < result.size()) { distOnRoadToPass += ctx.getRouter().calculateTurnTime(); }
			rr.setSegmentTime((float) distOnRoadToPass);
			rr.setSegmentSpeed((float) speed);
			rr.setDistance((float) distance);
		}
	}

	private void splitRoadsAndAttachRoadSegments(RoutingContext ctx, List<RouteSegmentResult> result) throws IOException {
		for (int i = 0; i < result.size(); i++) {
			if (ctx.checkIfMemoryLimitCritical(ctx.config.memoryLimitation)) {
				ctx.unloadUnusedTiles(ctx.config.memoryLimitation);
			}
			RouteSegmentResult rr = result.get(i);
			RouteDataObject road = rr.getObject();
			checkAndInitRouteRegion(ctx, road);
			boolean plus = rr.getStartPointIndex() < rr.getEndPointIndex();
			int next;
			for (int j = rr.getStartPointIndex(); j != rr.getEndPointIndex(); j = next) {
				next = plus ? j + 1 : j - 1;
				if (j == rr.getStartPointIndex()) {
					attachRoadSegments(ctx, result, i, j, plus);
				}
				if (next != rr.getEndPointIndex()) {
					attachRoadSegments(ctx, result, i, next, plus);
				}
				List<RouteSegmentResult> attachedRoutes = rr.getAttachedRoutes(next);
				boolean tryToSplit = next != rr.getEndPointIndex() && !rr.getObject().roundabout() && attachedRoutes != null;
				if(rr.getDistance(next, plus ) == 0) {
					// same point will be processed next step
					tryToSplit = false;
				}
				if (tryToSplit) {
					// avoid small zigzags
					float before = rr.getBearing(next, !plus);
					float after = rr.getBearing(next, plus);
					if(rr.getDistance(next, plus ) < 5) {
						after = before + 180;
					} else if(rr.getDistance(next, !plus ) < 5) {
						before = after - 180;
					}
					boolean straight = Math.abs(MapUtils.degreesDiff(before + 180, after)) < TURN_DEGREE_MIN;
					boolean isSplit = false;
					// split if needed
					for (RouteSegmentResult rs : attachedRoutes) {
						double diff = MapUtils.degreesDiff(before + 180, rs.getBearingBegin());
						if (Math.abs(diff) <= TURN_DEGREE_MIN) {
							isSplit = true;
						} else if (!straight && Math.abs(diff) < 100) {
							isSplit = true;
						}
					}
					if (isSplit) {
						int endPointIndex = rr.getEndPointIndex();
						RouteSegmentResult split = new RouteSegmentResult(rr.getObject(), next, endPointIndex);
						split.copyPreattachedRoutes(rr, Math.abs(next - rr.getStartPointIndex()));
						rr.setEndPointIndex(next);
						result.add(i + 1, split);
						i++;
						// switch current segment to the splitted
						rr = split;
					}
				}
			}
		}
	}

	private void checkAndInitRouteRegion(RoutingContext ctx, RouteDataObject road) throws IOException {
		BinaryMapIndexReader reader = ctx.reverseMap.get(road.region);
		if(reader != null) {
			reader.initRouteRegion(road.region);
		}
	}

	private void validateAllPointsConnected(List<RouteSegmentResult> result) {
		for (int i = 1; i < result.size(); i++) {
			RouteSegmentResult rr = result.get(i);
			RouteSegmentResult pr = result.get(i - 1);
			double d = MapUtils.getDistance(pr.getPoint(pr.getEndPointIndex()), rr.getPoint(rr.getStartPointIndex()));
			if (d > 0) {
				System.err.println("Points are not connected : " + pr.getObject() + "(" + pr.getEndPointIndex() + ") -> " + rr.getObject()
						+ "(" + rr.getStartPointIndex() + ") " + d + " meters");
			}
		}
	}

	private List<RouteSegmentResult> convertFinalSegmentToResults(RoutingContext ctx, FinalRouteSegment finalSegment) {
		List<RouteSegmentResult> result = new ArrayList<RouteSegmentResult>();
		if (finalSegment != null) {
			ctx.routingTime = finalSegment.distanceFromStart;
			println("Routing calculated time distance " + finalSegment.distanceFromStart);
			// Get results from opposite direction roads
			RouteSegment segment = finalSegment.reverseWaySearch ? finalSegment : 
				finalSegment.opposite.getParentRoute();
			int parentSegmentStart = finalSegment.reverseWaySearch ? finalSegment.opposite.getSegmentStart() : 
				finalSegment.opposite.getParentSegmentEnd();
			float parentRoutingTime = -1;
			while (segment != null) {
				RouteSegmentResult res = new RouteSegmentResult(segment.road, parentSegmentStart, segment.getSegmentStart());
				parentRoutingTime = calcRoutingTime(parentRoutingTime, finalSegment, segment, res);
				parentSegmentStart = segment.getParentSegmentEnd();
				segment = segment.getParentRoute();
				addRouteSegmentToResult(ctx, result, res, false);
			}
			// reverse it just to attach good direction roads
			Collections.reverse(result);

			segment = finalSegment.reverseWaySearch ? finalSegment.opposite.getParentRoute() : finalSegment;
			int parentSegmentEnd = finalSegment.reverseWaySearch ? finalSegment.opposite.getParentSegmentEnd() : finalSegment.opposite.getSegmentStart();
			parentRoutingTime = -1;
			while (segment != null) {
				RouteSegmentResult res = new RouteSegmentResult(segment.road, segment.getSegmentStart(), parentSegmentEnd);
				parentRoutingTime = calcRoutingTime(parentRoutingTime, finalSegment, segment, res);
				parentSegmentEnd = segment.getParentSegmentEnd();
				segment = segment.getParentRoute();
				// happens in smart recalculation
				addRouteSegmentToResult(ctx, result, res, true);
			}
			Collections.reverse(result);
			// checkTotalRoutingTime(result);
		}
		return result;
	}

	protected void checkTotalRoutingTime(List<RouteSegmentResult> result) {
		float totalRoutingTime = 0;
		for(RouteSegmentResult r : result) {
			totalRoutingTime += r.getRoutingTime();
		}
		println("Total routing time ! " + totalRoutingTime);
	}

	private float calcRoutingTime(float parentRoutingTime, RouteSegment finalSegment, RouteSegment segment,
			RouteSegmentResult res) {
		if(segment != finalSegment) {
			if(parentRoutingTime != -1) {
				res.setRoutingTime(parentRoutingTime - segment.distanceFromStart);
			}
			parentRoutingTime = segment.distanceFromStart;
		}
		return parentRoutingTime;
	}
	
	private void addRouteSegmentToResult(RoutingContext ctx, List<RouteSegmentResult> result, RouteSegmentResult res, boolean reverse) {
		if (res.getStartPointIndex() != res.getEndPointIndex()) {
			if (result.size() > 0) {
				RouteSegmentResult last = result.get(result.size() - 1);
				if (last.getObject().id == res.getObject().id && ctx.calculationMode != RouteCalculationMode.BASE) {
					if (combineTwoSegmentResult(res, last, reverse)) {
						return;
					}
				}
			}
			result.add(res);
		}
	}
	
	private boolean combineTwoSegmentResult(RouteSegmentResult toAdd, RouteSegmentResult previous, 
			boolean reverse) {
		boolean ld = previous.getEndPointIndex() > previous.getStartPointIndex();
		boolean rd = toAdd.getEndPointIndex() > toAdd.getStartPointIndex();
		if (rd == ld) {
			if (toAdd.getStartPointIndex() == previous.getEndPointIndex() && !reverse) {
				previous.setEndPointIndex(toAdd.getEndPointIndex());
				previous.setRoutingTime(previous.getRoutingTime() + toAdd.getRoutingTime());
				return true;
			} else if (toAdd.getEndPointIndex() == previous.getStartPointIndex() && reverse) {
				previous.setStartPointIndex(toAdd.getStartPointIndex());
				previous.setRoutingTime(previous.getRoutingTime() + toAdd.getRoutingTime());
				return true;
			}
		}
		return false;
	}
	
	void printResults(RoutingContext ctx, LatLon start, LatLon end, List<RouteSegmentResult> result) {
		float completeTime = 0;
		float completeDistance = 0;
		for(RouteSegmentResult r : result) {
			completeTime += r.getSegmentTime();
			completeDistance += r.getDistance();
		}

		println("ROUTE : ");
		double startLat = start.getLatitude();
		double startLon = start.getLongitude();
		double endLat = end.getLatitude();
		double endLon = end.getLongitude();
		
		String msg = String.format("<test regions=\"\" description=\"\" best_percent=\"\" vehicle=\"%s\" \n"
				+ "  start_lat=\"%.5f\" start_lon=\"%.5f\" target_lat=\"%.5f\" target_lon=\"%.5f\" "
				+ " routing_time=\"%.2f\" loadedTiles=\"%d\" visitedSegments=\"%d\" complete_distance=\"%.2f\" complete_time=\"%.2f\" >",
				ctx.config.routerName, startLat, startLon, endLat, endLon, ctx.routingTime, ctx.loadedTiles, 
				ctx.visitedSegments, completeDistance, completeTime);
//		String msg = MessageFormat.format("<test regions=\"\" description=\"\" best_percent=\"\" vehicle=\"{4}\" \n"
//				+ "    start_lat=\"{0}\" start_lon=\"{1}\" target_lat=\"{2}\" target_lon=\"{3}\" {5} >", 
//				startLat + "", startLon + "", endLat + "", endLon + "", ctx.config.routerName, 
//				"loadedTiles = \"" + ctx.loadedTiles + "\" " + "visitedSegments = \"" + ctx.visitedSegments + "\" " +
//				"complete_distance = \"" + completeDistance + "\" " + "complete_time = \"" + completeTime + "\" " +
//				"routing_time = \"" + ctx.routingTime + "\" ");
		log.info(msg);
        println(msg);
		if (PRINT_TO_CONSOLE_ROUTE_INFORMATION_TO_TEST) {
			org.xmlpull.v1.XmlSerializer serializer = null;
			if(PRINT_TO_GPX_FILE != null) {
				serializer = PlatformUtil.newSerializer();
				try {
					serializer.setOutput(new FileWriter(PRINT_TO_GPX_FILE));
					serializer.setFeature("http://xmlpull.org/v1/doc/features.html#indent-output", true);
					// indentation as 3 spaces
//					serializer.setProperty("http://xmlpull.org/v1/doc/properties.html#serializer-indentation", "   ");
//					// also set the line separator
//					serializer.setProperty("http://xmlpull.org/v1/doc/properties.html#serializer-line-separator", "\n");
					serializer.startDocument("UTF-8", true);
					serializer.startTag("", "gpx");
					serializer.attribute("", "version", "1.1");
					serializer.attribute("", "xmlns", "http://www.topografix.com/GPX/1/1");
					serializer.attribute("", "xmlns:xsi", "http://www.w3.org/2001/XMLSchema-instance");
					serializer.attribute("", "xmlns:schemaLocation", "http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd");
					serializer.startTag("", "trk");
					serializer.startTag("", "trkseg");
				} catch (IOException e) {
					e.printStackTrace();
					serializer = null;
				}
			}
					
			double lastHeight = -180;		
			for (RouteSegmentResult res : result) {
				String name = res.getObject().getName();
				String ref = res.getObject().getRef("", false, res.isForwardDirection());
				if (name == null) {
					name = "";
				}
				if (ref != null) {
					name += " (" + ref + ") ";
				}
				StringBuilder additional = new StringBuilder();
				additional.append("time = \"").append(res.getSegmentTime()).append("\" ");
				additional.append("rtime = \"").append(res.getRoutingTime()).append("\" ");
				additional.append("name = \"").append(name).append("\" ");
//				float ms = res.getSegmentSpeed();
				float ms = res.getObject().getMaximumSpeed(res.isForwardDirection());
				if(ms > 0) {
					additional.append("maxspeed = \"").append(ms * 3.6f).append("\" ").append(res.getObject().getHighway()).append(" ");
				}
				additional.append("distance = \"").append(res.getDistance()).append("\" ");
				if (res.getTurnType() != null) {
					additional.append("turn = \"").append(res.getTurnType()).append("\" ");
					additional.append("turn_angle = \"").append(res.getTurnType().getTurnAngle()).append("\" ");
					if (res.getTurnType().getLanes() != null) {
						additional.append("lanes = \"").append(Arrays.toString(res.getTurnType().getLanes())).append("\" ");
					}
				}
				additional.append("start_bearing = \"").append(res.getBearingBegin()).append("\" ");
				additional.append("end_bearing = \"").append(res.getBearingEnd()).append("\" ");
				additional.append("height = \"").append(Arrays.toString(res.getHeightValues())).append("\" ");
				additional.append("description = \"").append(res.getDescription()).append("\" ");
				println(MessageFormat.format("\t<segment id=\"{0}\" oid=\"{1}\" start=\"{2}\" end=\"{3}\" {4}/>",
						(res.getObject().getId() >> (SHIFT_ID )) + "", res.getObject().getId() + "", 
						res.getStartPointIndex() + "", res.getEndPointIndex() + "", additional.toString()));
				int inc = res.getStartPointIndex() < res.getEndPointIndex() ? 1 : -1;
				int indexnext = res.getStartPointIndex();
				LatLon prev = null;
				for (int index = res.getStartPointIndex() ; index != res.getEndPointIndex(); ) {
					index = indexnext;
					indexnext += inc; 
					if (serializer != null) {
						try {
							LatLon l = res.getPoint(index);
							serializer.startTag("","trkpt");
							serializer.attribute("", "lat",  l.getLatitude() + "");
							serializer.attribute("", "lon",  l.getLongitude() + "");
							float[] vls = res.getObject().heightDistanceArray;
							double dist = prev == null ? 0 : MapUtils.getDistance(prev, l);
							if(index * 2 + 1 < vls.length) {
								double h = vls[2*index + 1];
								serializer.startTag("","ele");
								serializer.text(h +"");
								serializer.endTag("","ele");
								if(lastHeight != -180 && dist > 0) {
									serializer.startTag("","cmt");
									serializer.text((float) ((h -lastHeight)/ dist*100) + "% " +
									" degree " + (float) Math.atan(((h -lastHeight)/ dist)) / Math.PI * 180 +  
									" asc " + (float) (h -lastHeight) + " dist "
											+ (float) dist);
									serializer.endTag("","cmt");
									serializer.startTag("","slope");
									serializer.text((h -lastHeight)/ dist*100 + "");
									serializer.endTag("","slope");
								}
								serializer.startTag("","desc");
								serializer.text((res.getObject().getId() >> (SHIFT_ID )) + " " + index);
								serializer.endTag("","desc");
								lastHeight = h;
							} else if(lastHeight != -180){
//								serializer.startTag("","ele");
//								serializer.text(lastHeight +"");
//								serializer.endTag("","ele");
							}
							serializer.endTag("", "trkpt");
							prev = l;
						} catch (IOException e) {
							e.printStackTrace();
						}
					}
				}
				printAdditionalPointInfo(res);
			}
			if(serializer != null) {
				try {
					serializer.endTag("", "trkseg");
					serializer.endTag("", "trk");
					serializer.endTag("", "gpx");
					serializer.endDocument();
					serializer.flush();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
		}
		println("</test>");
		println(msg);
	}

	private void printAdditionalPointInfo(RouteSegmentResult res) {
		boolean plus = res.getStartPointIndex() < res.getEndPointIndex();
		for(int k = res.getStartPointIndex(); k != res.getEndPointIndex(); ) {
			int[] tp = res.getObject().getPointTypes(k);
			String[] pointNames = res.getObject().getPointNames(k);
			int[] pointNameTypes = res.getObject().getPointNameTypes(k);
			if (tp != null || pointNameTypes != null) {
				StringBuilder bld = new StringBuilder();
				bld.append("<point " + (k));
				if (tp != null) {
					for (int t = 0; t < tp.length; t++) {
						RouteTypeRule rr = res.getObject().region.quickGetEncodingRule(tp[t]);
						bld.append(" " + rr.getTag() + "=\"" + rr.getValue() + "\"");
					}
				}
				if (pointNameTypes != null) {
					for (int t = 0; t < pointNameTypes.length; t++) {
						RouteTypeRule rr = res.getObject().region.quickGetEncodingRule(pointNameTypes[t]);
						bld.append(" " + rr.getTag() + "=\"" + pointNames[t] + "\"");
					}
				}
				bld.append("/>");
				println("\t"+bld.toString());
			}
			if(plus) {
				k++;
			} else {
				k--;
			}
		}
	}


	protected void addTurnInfoDescriptions(List<RouteSegmentResult> result) {
		int prevSegment = -1;
		float dist = 0;
		for (int i = 0; i <= result.size(); i++) {
			if (i == result.size() || result.get(i).getTurnType() != null) {
				if (prevSegment >= 0) {
					String turn = result.get(prevSegment).getTurnType().toString();
					result.get(prevSegment).setDescription(
							turn + MessageFormat.format(" and go {0,number,#.##} meters", dist));
					if (result.get(prevSegment).getTurnType().isSkipToSpeak()) {
						result.get(prevSegment).setDescription("-*" + result.get(prevSegment).getDescription());
					}
				}
				prevSegment = i;
				dist = 0;
			}
			if (i < result.size()) {
				dist += result.get(i).getDistance();
			}
		}
	}

	protected TurnType justifyUTurn(boolean leftside, List<RouteSegmentResult> result, int i, TurnType t) {
		boolean tl = TurnType.isLeftTurnNoUTurn(t.getValue());
		boolean tr = TurnType.isRightTurnNoUTurn(t.getValue());
		if(tl || tr) {
			TurnType tnext = result.get(i + 1).getTurnType();
			if (tnext != null && result.get(i).getDistance() < 50) { //
				boolean ut = true;
				if (i > 0) {
					double uTurn = MapUtils.degreesDiff(result.get(i - 1).getBearingEnd(), result
							.get(i + 1).getBearingBegin());
					if (Math.abs(uTurn) < 120) {
						ut = false;
					}
				}
//				String highway = result.get(i).getObject().getHighway();
//				if(highway == null || highway.endsWith("track") || highway.endsWith("services") || highway.endsWith("service")
//						|| highway.endsWith("path")) {
//					ut = false;
//				}
				if (result.get(i - 1).getObject().getOneway() == 0 || result.get(i + 1).getObject().getOneway() == 0) {
					ut = false;
				}
				if (!Algorithms.objectEquals(getStreetName(result, i - 1, false), 
						getStreetName(result, i + 1, true))) {
					ut = false;
				}
				if (ut) {
					tnext.setSkipToSpeak(true);
					if (tl && TurnType.isLeftTurnNoUTurn(tnext.getValue())) {
						TurnType tt = TurnType.valueOf(TurnType.TU, false);
						tt.setLanes(t.getLanes());
						return tt;
					} else if (tr && TurnType.isRightTurnNoUTurn(tnext.getValue())) {
						TurnType tt = TurnType.valueOf(TurnType.TU, true);
						tt.setLanes(t.getLanes());
						return tt;
					}
				}
			}
		}
		return null;
	}

	private String getStreetName(List<RouteSegmentResult> result, int i, boolean dir) {
		String nm = result.get(i).getObject().getName();
		if (Algorithms.isEmpty(nm)) {
			if (!dir) {
				if (i > 0) {
					nm = result.get(i - 1).getObject().getName();
				}
			} else {
				if(i < result.size() - 1) {
					nm = result.get(i + 1).getObject().getName();
				}
			}
		}
		
		return nm;
	}

	private void determineTurnsToMerge(boolean leftside, List<RouteSegmentResult> result) {
		RouteSegmentResult nextSegment = null;
		double dist = 0;
		for (int i = result.size() - 1; i >= 0; i--) {
			RouteSegmentResult currentSegment = result.get(i);
			TurnType currentTurn = currentSegment.getTurnType();
			dist += currentSegment.getDistance();
			if (currentTurn == null || currentTurn.getLanes() == null) {
				// skip
			} else {
				boolean merged = false;
				if (nextSegment != null) {
					String hw = currentSegment.getObject().getHighway();
					double mergeDistance = 200;
					if (hw != null && (hw.startsWith("trunk") || hw.startsWith("motorway"))) {
						mergeDistance = 400;
					}
					if (dist < mergeDistance) {
						mergeTurnLanes(leftside, currentSegment, nextSegment);
						inferCommonActiveLane(currentSegment.getTurnType(), nextSegment.getTurnType());
						merged = true;
					}
				}
				if (!merged) {
					TurnType tt = currentSegment.getTurnType();
					inferActiveTurnLanesFromTurn(tt, TurnType.C);
				}
				nextSegment = currentSegment;
				dist = 0;
			}
		}
	}

	private void inferActiveTurnLanesFromTurn(TurnType tt, int type) {
		boolean found = false;
		if (tt.getValue() == type && tt.getLanes() != null) {
			for (int it = 0; it < tt.getLanes().length; it++) {
				int turn = tt.getLanes()[it];
				if (TurnType.getPrimaryTurn(turn) == type ||
						TurnType.getSecondaryTurn(turn) == type ||
						TurnType.getTertiaryTurn(turn) == type) {
					found = true;
					break;
				}
			}
		}
		if(found) {
			for (int it = 0; it < tt.getLanes().length; it++) {
				int turn = tt.getLanes()[it];
				if (TurnType.getPrimaryTurn(turn) != type) {
					if(TurnType.getSecondaryTurn(turn) == type) {
						int st = TurnType.getSecondaryTurn(turn);
						TurnType.setSecondaryTurn(tt.getLanes(), it, TurnType.getPrimaryTurn(turn));
						TurnType.setPrimaryTurn(tt.getLanes(), it, st);
					} else if(TurnType.getTertiaryTurn(turn) == type) {
						int st = TurnType.getTertiaryTurn(turn);
						TurnType.setTertiaryTurn(tt.getLanes(), it, TurnType.getPrimaryTurn(turn));
						TurnType.setPrimaryTurn(tt.getLanes(), it, st);
					} else {
						tt.getLanes()[it] = turn & (~1);
					}
				}
			}
		}
	}
	
	private class MergeTurnLaneTurn {
		TurnType turn;
		int[] originalLanes;
		int[] disabledLanes;
		int activeStartIndex = -1;
		int activeEndIndex = -1;
		int activeLen = 0;
		
		public MergeTurnLaneTurn(RouteSegmentResult segment) {
			this.turn = segment.getTurnType();
			if(turn != null) {
				originalLanes = turn.getLanes();
			}
			if(originalLanes != null) {
				disabledLanes = new int[originalLanes.length];
				for (int i = 0; i < originalLanes.length; i++) {
					int ln = originalLanes[i];
					disabledLanes[i] = ln & ~1;
					if ((ln & 1) > 0) {
						if (activeStartIndex == -1) {
							activeStartIndex = i;
						}
						activeEndIndex = i;
						activeLen++;
					}
				}
			}
		}
		
		public boolean isActiveTurnMostLeft() {
			return activeStartIndex == 0;
		}
		public boolean isActiveTurnMostRight() {
			return activeEndIndex == originalLanes.length - 1;
		}
	}
	
	private boolean mergeTurnLanes(boolean leftSide, RouteSegmentResult currentSegment, RouteSegmentResult nextSegment) {
		MergeTurnLaneTurn active = new MergeTurnLaneTurn(currentSegment);
		MergeTurnLaneTurn target = new MergeTurnLaneTurn(nextSegment);
		if (active.activeLen < 2) {
			return false;
		}
		if (target.activeStartIndex == -1) {
			return false;
		}
		boolean changed = false;
		if (target.isActiveTurnMostLeft()) {
			// let only the most left lanes be enabled
			if (target.activeLen < active.activeLen) {
				active.activeEndIndex -= (active.activeLen - target.activeLen);
				changed = true;
			}
		} else if (target.isActiveTurnMostRight()) {
			// next turn is right
			// let only the most right lanes be enabled
			if (target.activeLen < active.activeLen ) {
				active.activeStartIndex += (active.activeLen - target.activeLen);
				changed = true;
			}
		} else {
			// next turn is get through (take out the left and the right turn)
			if (target.activeLen < active.activeLen) {
				if(target.originalLanes.length == active.activeLen) {
					active.activeEndIndex = active.activeStartIndex + target.activeEndIndex;
					active.activeStartIndex = active.activeStartIndex + target.activeStartIndex;
					changed = true;
				} else {
					int straightActiveLen = 0;
					int straightActiveBegin = -1;
					for(int i = active.activeStartIndex; i <= active.activeEndIndex; i++) {
						if(TurnType.hasAnyTurnLane(active.originalLanes[i], TurnType.C)) {
							straightActiveLen++;
							if(straightActiveBegin == -1) {
								straightActiveBegin = i;
							}
						}
					}
					if(straightActiveBegin != -1 && straightActiveLen <= target.activeLen) {
						active.activeStartIndex = straightActiveBegin;
						active.activeEndIndex = straightActiveBegin + straightActiveLen - 1;
						changed = true;
					} else {
						// cause the next-turn goes forward exclude left most and right most lane
						if (active.activeStartIndex == 0) {
							active.activeStartIndex++;
							active.activeLen--;
						}
						if (active.activeEndIndex == active.originalLanes.length - 1) {
							active.activeEndIndex--;
							active.activeLen--;
						}
						float ratio = (active.activeLen - target.activeLen) / 2f;
						if (ratio > 0) {
							active.activeEndIndex = (int) Math.ceil(active.activeEndIndex - ratio);
							active.activeStartIndex = (int) Math.floor(active.activeStartIndex + ratio);
						}
						changed = true;
					}
				}
			}
		}
		if (!changed) {
			return false;
		}

		// set the allowed lane bit
		for (int i = 0; i < active.disabledLanes.length; i++) {
			if (i >= active.activeStartIndex && i <= active.activeEndIndex && 
					active.originalLanes[i] % 2 == 1) {
				active.disabledLanes[i] |= 1;
			}
		}
		TurnType currentTurn = currentSegment.getTurnType();
		currentTurn.setLanes(active.disabledLanes);
		return true;
	}
	
	private void inferCommonActiveLane(TurnType currentTurn, TurnType nextTurn) {
		int[] lanes = currentTurn.getLanes();
		TIntHashSet turnSet = new TIntHashSet();
		for(int i = 0; i < lanes.length; i++) {
			if(lanes[i] % 2 == 1 ) {
				int singleTurn = TurnType.getPrimaryTurn(lanes[i]);
				turnSet.add(singleTurn);
				if(TurnType.getSecondaryTurn(lanes[i]) != 0) {
					turnSet.add(TurnType.getSecondaryTurn(lanes[i]));
				}
				if(TurnType.getTertiaryTurn(lanes[i]) != 0) {
					turnSet.add(TurnType.getTertiaryTurn(lanes[i]));
				}
			}
		}
		int singleTurn = 0;
		if(turnSet.size() == 1) {
			singleTurn = turnSet.iterator().next();
		} else if(currentTurn.goAhead() && turnSet.contains(nextTurn.getValue())) {
			if(currentTurn.isPossibleLeftTurn() && 
					TurnType.isLeftTurn(nextTurn.getValue())) {
				singleTurn = nextTurn.getValue();	
			} else if(currentTurn.isPossibleLeftTurn() && 
					TurnType.isLeftTurn(nextTurn.getActiveCommonLaneTurn())) {
				singleTurn = nextTurn.getActiveCommonLaneTurn();
			} else if(currentTurn.isPossibleRightTurn() && 
					TurnType.isRightTurn(nextTurn.getValue())) {
				singleTurn = nextTurn.getValue();
			} else if(currentTurn.isPossibleRightTurn() && 
					TurnType.isRightTurn(nextTurn.getActiveCommonLaneTurn())) {
				singleTurn = nextTurn.getActiveCommonLaneTurn();
			}
		}
		if (singleTurn == 0) {
			singleTurn = currentTurn.getValue();
			if(singleTurn == TurnType.KL || singleTurn == TurnType.KR) {
				return;
			}
		}
		for(int i = 0; i < lanes.length; i++) {
			if(lanes[i] % 2 == 1 && TurnType.getPrimaryTurn(lanes[i]) != singleTurn) {
				if(TurnType.getSecondaryTurn(lanes[i]) == singleTurn) {
					TurnType.setSecondaryTurn(lanes, i, TurnType.getPrimaryTurn(lanes[i]));
					TurnType.setPrimaryTurn(lanes, i, singleTurn);
				} else if(TurnType.getTertiaryTurn(lanes[i]) == singleTurn) {
					TurnType.setTertiaryTurn(lanes, i, TurnType.getPrimaryTurn(lanes[i]));
					TurnType.setPrimaryTurn(lanes, i, singleTurn);
				} else {
					// disable lane
					lanes[i] = lanes[i] - 1;
				}
			}
		}
		
	}

	private static final int MAX_SPEAK_PRIORITY = 5;
	private int highwaySpeakPriority(String highway) {
		if(highway == null || highway.endsWith("track") || highway.endsWith("services") || highway.endsWith("service")
				|| highway.endsWith("path")) {
			return MAX_SPEAK_PRIORITY;
		}
		if (highway.endsWith("_link")  || highway.endsWith("unclassified") || highway.endsWith("road") 
				|| highway.endsWith("living_street") || highway.endsWith("residential") )  {
			return 1;
		}
		return 0;
	}


	private TurnType getTurnInfo(List<RouteSegmentResult> result, int i, boolean leftSide) {
		if (i == 0) {
			return TurnType.valueOf(TurnType.C, false);
		}
		RouteSegmentResult prev = result.get(i - 1) ;
		if(prev.getObject().roundabout()) {
			// already analyzed!
			return null;
		}
		RouteSegmentResult rr = result.get(i);
		if (rr.getObject().roundabout()) {
			return processRoundaboutTurn(result, i, leftSide, prev, rr);
		}
		TurnType t = null;
		if (prev != null) {
			boolean noAttachedRoads = rr.getAttachedRoutes(rr.getStartPointIndex()).size() == 0;
			// add description about turn
			double mpi = MapUtils.degreesDiff(prev.getBearingEnd(), rr.getBearingBegin());
			if(noAttachedRoads){
				// TODO VICTOR : look at the comment inside direction route
				// ? avoid small zigzags is covered at (search for "zigzags") 
//				double begin = rr.getObject().directionRoute(rr.getStartPointIndex(), rr.getStartPointIndex() < 
//						rr.getEndPointIndex(), 25);
//				mpi = MapUtils.degreesDiff(prev.getBearingEnd(), begin);
			}
			if (mpi >= TURN_DEGREE_MIN) {
				if (mpi < 45) {
					// Slight turn detection here causes many false positives where drivers would expect a "normal" TL. Best use limit-angle=TURN_DEGREE_MIN, this reduces TSL to the turn-lanes cases.
					t = TurnType.valueOf(TurnType.TSLL, leftSide);
				} else if (mpi < 120) {
					t = TurnType.valueOf(TurnType.TL, leftSide);
				} else if (mpi < 150 || leftSide) {
					t = TurnType.valueOf(TurnType.TSHL, leftSide);
				} else {
					t = TurnType.valueOf(TurnType.TU, leftSide);
				}
				int[] lanes = getTurnLanesInfo(prev, t.getValue());
				t.setLanes(lanes);
			} else if (mpi < -TURN_DEGREE_MIN) {
				if (mpi > -45) {
					t = TurnType.valueOf(TurnType.TSLR, leftSide);
				} else if (mpi > -120) {
					t = TurnType.valueOf(TurnType.TR, leftSide);
				} else if (mpi > -150 || !leftSide) {
					t = TurnType.valueOf(TurnType.TSHR, leftSide);
				} else {
					t = TurnType.valueOf(TurnType.TRU, leftSide);
				}
				int[] lanes = getTurnLanesInfo(prev, t.getValue());
				t.setLanes(lanes);
			} else {
				t = attachKeepLeftInfoAndLanes(leftSide, prev, rr);
			}
			if (t != null) {
				t.setTurnAngle((float) -mpi);
			}
		}
		return t;
	}

	private int[] getTurnLanesInfo(RouteSegmentResult prevSegm, int mainTurnType) {		String turnLanes = getTurnLanesString(prevSegm);
		int[] lanesArray ;
		if (turnLanes == null) {
			if(prevSegm.getTurnType() != null && prevSegm.getTurnType().getLanes() != null
					&& prevSegm.getDistance() < 100) {
				int[] lns = prevSegm.getTurnType().getLanes();
				TIntArrayList lst = new TIntArrayList();
				for(int i = 0; i < lns.length; i++) {
					if(lns[i] % 2 == 1) {
						lst.add((lns[i] >> 1) << 1);
					}
				}
				if(lst.isEmpty()) {
					return null;
				}
				lanesArray = lst.toArray();
			} else {
				return null;
			}
		} else {
			lanesArray = calculateRawTurnLanes(turnLanes, mainTurnType);
		}
		// Manually set the allowed lanes.
		boolean isSet = setAllowedLanes(mainTurnType, lanesArray);
		if(!isSet && lanesArray.length > 0) {
			// In some cases (at least in the US), the rightmost lane might not have a right turn indicated as per turn:lanes,
			// but is allowed and being used here. This section adds in that indicator.  The same applies for where leftSide is true.
			boolean leftTurn = TurnType.isLeftTurn(mainTurnType);
			int ind = leftTurn? 0 : lanesArray.length - 1;
			int primaryTurn = TurnType.getPrimaryTurn(lanesArray[ind]);
			final int st = TurnType.getSecondaryTurn(lanesArray[ind]);
			if (leftTurn) {
				if (!TurnType.isLeftTurn(primaryTurn)) {
					// This was just to make sure that there's no bad data.
					TurnType.setPrimaryTurnAndReset(lanesArray, ind, TurnType.TL);
					TurnType.setSecondaryTurn(lanesArray, ind, primaryTurn);
					TurnType.setTertiaryTurn(lanesArray, ind, st);
					primaryTurn = TurnType.TL;
					lanesArray[ind] |= 1;
				}
			} else {
				if (!TurnType.isRightTurn(primaryTurn)) {
					// This was just to make sure that there's no bad data.
					TurnType.setPrimaryTurnAndReset(lanesArray, ind, TurnType.TR);
					TurnType.setSecondaryTurn(lanesArray, ind, primaryTurn);
					TurnType.setTertiaryTurn(lanesArray, ind, st);
					primaryTurn = TurnType.TR;
					lanesArray[ind] |= 1;
				}
			}
			setAllowedLanes(primaryTurn, lanesArray);
		}
		return lanesArray;
	}

	protected boolean setAllowedLanes(int mainTurnType, int[] lanesArray) {
		boolean turnSet = false;
		for (int i = 0; i < lanesArray.length; i++) {
			if (TurnType.getPrimaryTurn(lanesArray[i]) == mainTurnType) {
				lanesArray[i] |= 1;
				turnSet = true;
			}
		}
		return turnSet;
	}

	private TurnType processRoundaboutTurn(List<RouteSegmentResult> result, int i, boolean leftSide, RouteSegmentResult prev,
			RouteSegmentResult rr) {
		int exit = 1;
		RouteSegmentResult last = rr;
		RouteSegmentResult firstRoundabout = rr;
		RouteSegmentResult lastRoundabout = rr;
		for (int j = i; j < result.size(); j++) {
			RouteSegmentResult rnext = result.get(j);
			last = rnext;
			if (rnext.getObject().roundabout()) {
				lastRoundabout = rnext;
				boolean plus = rnext.getStartPointIndex() < rnext.getEndPointIndex();
				int k = rnext.getStartPointIndex();
				if (j == i) {
					// first exit could be immediately after roundabout enter
//					k = plus ? k + 1 : k - 1;
				}
				while (k != rnext.getEndPointIndex()) {
					int attachedRoads = rnext.getAttachedRoutes(k).size();
					if(attachedRoads > 0) {
						exit++;
					}
					k = plus ? k + 1 : k - 1;
				}
			} else {
				break;
			}
		}
		// combine all roundabouts
		TurnType t = TurnType.getExitTurn(exit, 0, leftSide);
		// usually covers more than expected
		float turnAngleBasedOnOutRoads = (float) MapUtils.degreesDiff(last.getBearingBegin(), prev.getBearingEnd());
		// usually covers less than expected
		float turnAngleBasedOnCircle = (float) -MapUtils.degreesDiff(firstRoundabout.getBearingBegin(), lastRoundabout.getBearingEnd() + 180);
		if(Math.abs(turnAngleBasedOnOutRoads - turnAngleBasedOnCircle) > 180) {
			t.setTurnAngle(turnAngleBasedOnCircle ) ;
		} else {
			t.setTurnAngle((turnAngleBasedOnCircle + turnAngleBasedOnOutRoads) / 2) ;
		}
		return t;
	}
	
	private class RoadSplitStructure {
		boolean keepLeft = false;
		boolean keepRight = false;
		boolean speak = false;
		List<int[]> leftLanesInfo = new ArrayList<int[]>();
		int leftLanes = 0;
		List<int[]> rightLanesInfo = new ArrayList<int[]>();
		int rightLanes = 0;
		int roadsOnLeft = 0;
		int addRoadsOnLeft = 0;
		int roadsOnRight = 0;
		int addRoadsOnRight = 0;
	}


	private TurnType attachKeepLeftInfoAndLanes(boolean leftSide, RouteSegmentResult prevSegm, RouteSegmentResult currentSegm) {
		List<RouteSegmentResult> attachedRoutes = currentSegm.getAttachedRoutes(currentSegm.getStartPointIndex());
		if(attachedRoutes == null || attachedRoutes.size() == 0) {
			return null;
		}
		// keep left/right
		RoadSplitStructure rs = calculateRoadSplitStructure(prevSegm, currentSegm, attachedRoutes);
		if(rs.roadsOnLeft  + rs.roadsOnRight == 0) {
			return null;
		}
		
		// turn lanes exist
		String turnLanes = getTurnLanesString(prevSegm);
		if (turnLanes != null) {
			return createKeepLeftRightTurnBasedOnTurnTypes(rs, prevSegm, currentSegm, turnLanes, leftSide);
		}

		// turn lanes don't exist
		if (rs.keepLeft || rs.keepRight) {
			return createSimpleKeepLeftRightTurn(leftSide, prevSegm, currentSegm, rs);
			
		}
		return null;
	}

	protected TurnType createKeepLeftRightTurnBasedOnTurnTypes(RoadSplitStructure rs, RouteSegmentResult prevSegm,
			RouteSegmentResult currentSegm, String turnLanes, boolean leftSide) {
		// Maybe going straight at a 90-degree intersection
		TurnType t = TurnType.valueOf(TurnType.C, leftSide);
		int[] rawLanes = calculateRawTurnLanes(turnLanes, TurnType.C);
		boolean possiblyLeftTurn = rs.roadsOnLeft == 0;
		boolean possiblyRightTurn = rs.roadsOnRight == 0;
		for (int k = 0; k < rawLanes.length; k++) {
			int turn = TurnType.getPrimaryTurn(rawLanes[k]);
			int sturn = TurnType.getSecondaryTurn(rawLanes[k]);
			int tturn = TurnType.getTertiaryTurn(rawLanes[k]);
			if (turn == TurnType.TU || sturn == TurnType.TU || tturn == TurnType.TU) {
				possiblyLeftTurn = true;
			}
			if (turn == TurnType.TRU || sturn == TurnType.TRU || sturn == TurnType.TRU) {
				possiblyRightTurn = true;
			}
		}
		
		t.setPossibleLeftTurn(possiblyLeftTurn);
		t.setPossibleRightTurn(possiblyRightTurn);
		if (rs.keepLeft || rs.keepRight) {
			String[] splitLaneOptions = turnLanes.split("\\|", -1);
			int activeBeginIndex = findActiveIndex(rawLanes, splitLaneOptions, rs.leftLanes, true, 
					rs.leftLanesInfo, rs.roadsOnLeft, rs.addRoadsOnLeft);
			
			if(!rs.keepLeft && activeBeginIndex != -1 && 
					splitLaneOptions.length > 0 && !splitLaneOptions[splitLaneOptions.length - 1].contains(";")) {
				activeBeginIndex = Math.max(activeBeginIndex, 1);
			}
			int activeEndIndex = findActiveIndex(rawLanes, splitLaneOptions, rs.rightLanes, false, 
					rs.rightLanesInfo, rs.roadsOnRight, rs.addRoadsOnRight);
			if(!rs.keepRight && activeEndIndex != -1  && 
					splitLaneOptions.length > 0 && !splitLaneOptions[0].contains(";") ) {
				activeEndIndex = Math.min(activeEndIndex, rawLanes.length - 1);
			}
			if (activeBeginIndex == -1 || activeEndIndex == -1 || activeBeginIndex > activeEndIndex) {
				// something went wrong
				return createSimpleKeepLeftRightTurn(leftSide, prevSegm, currentSegm, rs);
			}
			for (int k = 0; k < rawLanes.length; k++) {
				if (k >= activeBeginIndex && k <= activeEndIndex) {
					rawLanes[k] |= 1;
				}
			}
			int tp = inferSlightTurnFromLanes(rawLanes, rs);
			if (tp != t.getValue() && tp != 0) {
				t = TurnType.valueOf(tp, leftSide);
			}
		} else {
			for (int k = 0; k < rawLanes.length; k++) {
				int turn = TurnType.getPrimaryTurn(rawLanes[k]);
				int sturn = TurnType.getSecondaryTurn(rawLanes[k]);
				int tturn = TurnType.getTertiaryTurn(rawLanes[k]);
				
				boolean active = false;
				// some turns go through many segments (to turn right or left)
				// so on one first segment the lane could be available and may be only 1 possible
				// all undesired lanes will be disabled through the 2nd pass
				if((TurnType.isRightTurn(sturn) && possiblyRightTurn) ||
						(TurnType.isLeftTurn(sturn) && possiblyLeftTurn)) {
					// we can't predict here whether it will be a left turn or straight on, 
					// it could be done during 2nd pass
					TurnType.setPrimaryTurn(rawLanes, k, sturn);
					TurnType.setSecondaryTurn(rawLanes, k, turn);
					active = true;
				} else if((TurnType.isRightTurn(tturn) && possiblyRightTurn) ||
						(TurnType.isLeftTurn(tturn) && possiblyLeftTurn)) {
					TurnType.setPrimaryTurn(rawLanes, k, tturn);
					TurnType.setTertiaryTurn(rawLanes, k, turn);
					active = true;
				} else if((TurnType.isRightTurn(turn) && possiblyRightTurn) ||
						(TurnType.isLeftTurn(turn) && possiblyLeftTurn)) {
					active = true;
				} else if (turn == TurnType.C) {
					active = true;
				}
				if (active) {
					rawLanes[k] |= 1;
				}
			}
		}
		t.setSkipToSpeak(!rs.speak);
		t.setLanes(rawLanes);
		return t;
	}

	protected int findActiveIndex(int[] rawLanes, String[] splitLaneOptions, int lanes, boolean left, 
			List<int[]> lanesInfo, int roads, int addRoads) {
		int activeStartIndex = -1;
		boolean lookupSlightTurn = addRoads > 0;
		TIntHashSet addedTurns = new TIntHashSet();
		// if we have information increase number of roads per each turn direction
		int diffTurnRoads = roads;
		int increaseTurnRoads = 0;
		for(int[] li : lanesInfo) {
			TIntHashSet set = new TIntHashSet();
			if(li != null) {
				for(int k = 0; k < li.length; k++) {
					TurnType.collectTurnTypes(li[k], set);
				}
			}
			increaseTurnRoads = Math.max(set.size() - 1, 0);
		}
		
		for (int i = 0; i < rawLanes.length; i++) {
			int ind = left ? i : (rawLanes.length - i - 1);
			if (!lookupSlightTurn ||
					TurnType.hasAnySlightTurnLane(rawLanes[ind])) {
				String[] laneTurns = splitLaneOptions[ind].split(";");
				int cnt = 0;
				for(String lTurn : laneTurns) {
					boolean added = addedTurns.add(TurnType.convertType(lTurn));
					if(added) {
						cnt++;
						diffTurnRoads --;
					}
				}
				lanes -= cnt;
				//lanes--;
				// we already found slight turn others are turn in different direction
				lookupSlightTurn = false;
			}
			if (lanes < 0 || diffTurnRoads + increaseTurnRoads < 0) {
				activeStartIndex = ind;
				break;
			} else if(diffTurnRoads < 0 && activeStartIndex < 0) {
				activeStartIndex = ind;
			}
		}
		return activeStartIndex;
	}

	protected RoadSplitStructure calculateRoadSplitStructure(RouteSegmentResult prevSegm, RouteSegmentResult currentSegm,
			List<RouteSegmentResult> attachedRoutes) {
		RoadSplitStructure rs = new RoadSplitStructure();
		int speakPriority = Math.max(highwaySpeakPriority(prevSegm.getObject().getHighway()), highwaySpeakPriority(currentSegm.getObject().getHighway()));
		for (RouteSegmentResult attached : attachedRoutes) {
			boolean restricted = false;
			for(int k = 0; k < prevSegm.getObject().getRestrictionLength(); k++) {
				if(prevSegm.getObject().getRestrictionId(k) == attached.getObject().getId() && 
						prevSegm.getObject().getRestrictionType(k) <= MapRenderingTypes.RESTRICTION_NO_STRAIGHT_ON) {
					restricted = true;
					break;
				}
			}
			if(restricted) {
				continue;
			}
			double ex = MapUtils.degreesDiff(attached.getBearingBegin(), currentSegm.getBearingBegin());
			double mpi = Math.abs(MapUtils.degreesDiff(prevSegm.getBearingEnd(), attached.getBearingBegin()));
			int rsSpeakPriority = highwaySpeakPriority(attached.getObject().getHighway());
			int lanes = countLanesMinOne(attached);
			int[] turnLanes = parseTurnLanes(attached.getObject(), attached.getBearingBegin() * Math.PI / 180);
			boolean smallStraightVariation = mpi < TURN_DEGREE_MIN;
			boolean smallTargetVariation = Math.abs(ex) < TURN_DEGREE_MIN;
			boolean attachedOnTheRight = ex >= 0;
			if (attachedOnTheRight) {
				rs.roadsOnRight++;
			} else {
				rs.roadsOnLeft++;
			}
			if (rsSpeakPriority != MAX_SPEAK_PRIORITY || speakPriority == MAX_SPEAK_PRIORITY) {
				if (smallTargetVariation || smallStraightVariation) {
					if (attachedOnTheRight) {
						rs.keepLeft = true;
						rs.rightLanes += lanes;
						if(turnLanes != null) {
							rs.rightLanesInfo.add(turnLanes);
						}
					} else {
						rs.keepRight = true;
						rs.leftLanes += lanes;
						if(turnLanes != null) {
							rs.leftLanesInfo.add(turnLanes);
						}
					}
					rs.speak = rs.speak || rsSpeakPriority <= speakPriority;
				} else {
					if (attachedOnTheRight) {
						rs.addRoadsOnRight++;
					} else {
						rs.addRoadsOnLeft++;
					}
				}
			}
		}
		return rs;
	}

	protected TurnType createSimpleKeepLeftRightTurn(boolean leftSide, RouteSegmentResult prevSegm,
			RouteSegmentResult currentSegm, RoadSplitStructure rs) {
		int current = countLanesMinOne(currentSegm);
		int ls = current + rs.leftLanes + rs.rightLanes;
		int[] lanes = new int[ls];
		for (int it = 0; it < ls; it++) {
			if (it < rs.leftLanes || it >= rs.leftLanes + current) {
				lanes[it] = 0;
			} else {
				lanes[it] = 1;
			}
		}
		// sometimes links are
		if ((current <= rs.leftLanes + rs.rightLanes) && (rs.leftLanes > 1 || rs.rightLanes > 1)) {
			rs.speak = true;
		}
		double devation = Math.abs(MapUtils.degreesDiff(prevSegm.getBearingEnd(), currentSegm.getBearingBegin()));
		boolean makeSlightTurn = devation > 5 && (!isMotorway(prevSegm) || !isMotorway(currentSegm));
		TurnType t = null;
		if (rs.keepLeft && rs.keepRight) {
			t = TurnType.valueOf(TurnType.C, leftSide);
		} else if (rs.keepLeft) {
			t = TurnType.valueOf(makeSlightTurn ? TurnType.TSLL : TurnType.KL, leftSide);
		} else if (rs.keepRight) {
			t = TurnType.valueOf(makeSlightTurn ? TurnType.TSLR : TurnType.KR, leftSide);
		} else {
			return t;
		}
		t.setSkipToSpeak(!rs.speak);
		t.setLanes(lanes);
		return t;
	}

	
	protected int countLanesMinOne(RouteSegmentResult attached) {
		final boolean oneway = attached.getObject().getOneway() != 0;
		int lns = attached.getObject().getLanes();
		if(lns == 0) {
			String tls = getTurnLanesString(attached);
			if(tls != null) {
				return Math.max(1, countOccurrences(tls, '|'));
			}
		}
		if (oneway) {
			return Math.max(1, lns);
		}
		try {
			if (attached.isForwardDirection() && attached.getObject().getValue("lanes:forward") != null) {
				return Integer.parseInt(attached.getObject().getValue("lanes:forward"));
			} else if (!attached.isForwardDirection() && attached.getObject().getValue("lanes:backward") != null) {
				return Integer.parseInt(attached.getObject().getValue("lanes:backward"));
			}
		} catch(NumberFormatException e) {
			e.printStackTrace();
		}
		return Math.max(1, (lns + 1) / 2);
	}

	protected static String getTurnLanesString(RouteSegmentResult segment) {
		if (segment.getObject().getOneway() == 0) {
			if (segment.isForwardDirection()) {
				return segment.getObject().getValue("turn:lanes:forward");
			} else {
				return segment.getObject().getValue("turn:lanes:backward");
			}
		} else {
			return segment.getObject().getValue("turn:lanes");
		}
	}

	

	private int countOccurrences(String haystack, char needle) {
	    int count = 0;
		for (int i = 0; i < haystack.length(); i++) {
			if (haystack.charAt(i) == needle) {
				count++;
			}
		}
		return count;
	}

	public static int[] parseTurnLanes(RouteDataObject ro, double dirToNorthEastPi) {
		String turnLanes = null;
		if (ro.getOneway() == 0) {
			// we should get direction to detect forward or backward
			double cmp = ro.directionRoute(0, true);
			if(Math.abs(MapUtils.alignAngleDifference(dirToNorthEastPi -cmp)) < Math.PI / 2) {
				turnLanes = ro.getValue("turn:lanes:forward");
			} else {
				turnLanes = ro.getValue("turn:lanes:backward");
			}
		} else {
			turnLanes = ro.getValue("turn:lanes");
		}
		if(turnLanes == null) {
			return null;
		}
		return calculateRawTurnLanes(turnLanes, 0);
	}
	
	public static int[] parseLanes(RouteDataObject ro, double dirToNorthEastPi) {
		int lns = 0;
		try {
			if (ro.getOneway() == 0) {
				// we should get direction to detect forward or backward
				double cmp = ro.directionRoute(0, true);
				
				if(Math.abs(MapUtils.alignAngleDifference(dirToNorthEastPi -cmp)) < Math.PI / 2) {
					if(ro.getValue("lanes:forward") != null) {
						lns = Integer.parseInt(ro.getValue("lanes:forward"));
					}
				} else {
					if(ro.getValue("lanes:backward") != null) {
					lns = Integer.parseInt(ro.getValue("lanes:backward"));
					}
				}
				if (lns == 0 && ro.getValue("lanes") != null) {
					lns = Integer.parseInt(ro.getValue("lanes")) / 2;
				}
			} else {
				lns = Integer.parseInt(ro.getValue("lanes"));
			}
			if(lns > 0 ) {
				return new int[lns];
			}
		} catch (NumberFormatException e) {
		}
		return null;
	}
	
	private static int[] calculateRawTurnLanes(String turnLanes, int calcTurnType) {
		String[] splitLaneOptions = turnLanes.split("\\|", -1);
		int[] lanes = new int[splitLaneOptions.length];
		for (int i = 0; i < splitLaneOptions.length; i++) {
			String[] laneOptions = splitLaneOptions[i].split(";");
			boolean isTertiaryTurn = false;
			for (int j = 0; j < laneOptions.length; j++) {
				int turn = TurnType.convertType(laneOptions[j]);

				final int primary = TurnType.getPrimaryTurn(lanes[i]);
				if (primary == 0) {
					TurnType.setPrimaryTurnAndReset(lanes, i, turn);
				} else {
                    if (turn == calcTurnType || 
                    	(TurnType.isRightTurn(calcTurnType) && TurnType.isRightTurn(turn)) || 
                    	(TurnType.isLeftTurn(calcTurnType) && TurnType.isLeftTurn(turn)) 
                    	) {
                    	TurnType.setPrimaryTurnShiftOthers(lanes, i, turn);
                    } else if (!isTertiaryTurn) {
                    	TurnType.setSecondaryTurnShiftOthers(lanes, i, turn);
						isTertiaryTurn = true;
                    } else {
						TurnType.setTertiaryTurn(lanes, i, turn);
						break;
                    }
				}
			}
		}
		return lanes;
	}

	private int inferSlightTurnFromLanes(int[] oLanes, RoadSplitStructure rs) {
		TIntHashSet possibleTurns = new TIntHashSet();
		for (int i = 0; i < oLanes.length; i++) {
			if ((oLanes[i] & 1) == 0) {
				continue;
			}
			if (possibleTurns.isEmpty()) {
				// Nothing is in the list to compare to, so add the first elements
				possibleTurns.add(TurnType.getPrimaryTurn(oLanes[i]));
				if (TurnType.getSecondaryTurn(oLanes[i]) != 0) {
					possibleTurns.add(TurnType.getSecondaryTurn(oLanes[i]));
				}
				if (TurnType.getTertiaryTurn(oLanes[i]) != 0) {
					possibleTurns.add(TurnType.getTertiaryTurn(oLanes[i]));
				}
			} else {
				TIntArrayList laneTurns = new TIntArrayList();
				laneTurns.add(TurnType.getPrimaryTurn(oLanes[i]));
				if (TurnType.getSecondaryTurn(oLanes[i]) != 0) {
					laneTurns.add(TurnType.getSecondaryTurn(oLanes[i]));
				}
				if (TurnType.getTertiaryTurn(oLanes[i]) != 0) {
					laneTurns.add(TurnType.getTertiaryTurn(oLanes[i]));
				}
				possibleTurns.retainAll(laneTurns);
				if (possibleTurns.isEmpty()) {
					// No common turns, so can't determine anything.
					return 0;
				}
			}
		}

		// Remove all turns from lanes not selected...because those aren't it
		for (int i = 0; i < oLanes.length; i++) {
			if ((oLanes[i] & 1) == 0 && !possibleTurns.isEmpty()) {
				possibleTurns.remove((Integer) TurnType.getPrimaryTurn(oLanes[i]));
				if (TurnType.getSecondaryTurn(oLanes[i]) != 0) {
					possibleTurns.remove((Integer) TurnType.getSecondaryTurn(oLanes[i]));
				}
				if (TurnType.getTertiaryTurn(oLanes[i]) != 0) {
					possibleTurns.remove((Integer) TurnType.getTertiaryTurn(oLanes[i]));
				}
			}
		}
		// remove all non-slight turns // TEST don't pass 
//		if(possibleTurns.size() > 1) {
//			TIntIterator it = possibleTurns.iterator();
//			while(it.hasNext()) {
//				int nxt = it.next();
//				if(!TurnType.isSlightTurn(nxt)) {
//					it.remove();
//				}
//			}
//		}
		int infer = 0;
		if (possibleTurns.size() == 1) {
			infer = possibleTurns.iterator().next();
		} else if (possibleTurns.size() > 1) {
			if (rs.keepLeft && rs.keepRight && possibleTurns.contains(TurnType.C)) {
				infer = TurnType.C;
			} else if (rs.keepLeft || rs.keepRight) {
				TIntIterator it = possibleTurns.iterator();
				infer = it.next();
				while(it.hasNext()) {
					int next = it.next();
					int orderInfer = TurnType.orderFromLeftToRight(infer);
					int orderNext = TurnType.orderFromLeftToRight(next) ;
					if(rs.keepLeft && orderNext < orderInfer) {
						infer = next;
					} else if(rs.keepRight && orderNext > orderInfer) {
						infer = next;
					}
				}
			}
		}

		// Checking to see that there is only one unique turn
		if (infer != 0) {
			for(int i = 0; i < oLanes.length; i++) {
				if(TurnType.getSecondaryTurn(oLanes[i]) == infer) {
					int pt = TurnType.getPrimaryTurn(oLanes[i]);
					int en = oLanes[i] & 1;
					TurnType.setPrimaryTurnAndReset(oLanes, i, infer);
					oLanes[i] |= en;
					TurnType.setSecondaryTurn(oLanes, i, pt);
				}
				
			}
		}
		return infer;
	}

	private boolean isMotorway(RouteSegmentResult s){
		String h = s.getObject().getHighway();
		return "motorway".equals(h) || "motorway_link".equals(h)  ||
				"trunk".equals(h) || "trunk_link".equals(h);
		
	}

	
	private void attachRoadSegments(RoutingContext ctx, List<RouteSegmentResult> result, int routeInd, int pointInd, boolean plus) throws IOException {
		RouteSegmentResult rr = result.get(routeInd);
		RouteDataObject road = rr.getObject();
		long nextL = pointInd < road.getPointsLength() - 1 ? getPoint(road, pointInd + 1) : 0;
		long prevL = pointInd > 0 ? getPoint(road, pointInd - 1) : 0;
		
		// attach additional roads to represent more information about the route
		RouteSegmentResult previousResult = null;
		
		// by default make same as this road id
		long previousRoadId = road.getId();
		if (pointInd == rr.getStartPointIndex() && routeInd > 0) {
			previousResult = result.get(routeInd - 1);
			previousRoadId = previousResult.getObject().getId();
			if (previousRoadId != road.getId()) {
				if (previousResult.getStartPointIndex() < previousResult.getEndPointIndex()
						&& previousResult.getEndPointIndex() < previousResult.getObject().getPointsLength() - 1) {
					rr.attachRoute(pointInd, new RouteSegmentResult(previousResult.getObject(), previousResult.getEndPointIndex(),
							previousResult.getObject().getPointsLength() - 1));
				} else if (previousResult.getStartPointIndex() > previousResult.getEndPointIndex() 
						&& previousResult.getEndPointIndex() > 0) {
					rr.attachRoute(pointInd, new RouteSegmentResult(previousResult.getObject(), previousResult.getEndPointIndex(), 0));
				}
			}
		}
		Iterator<RouteSegment> it;
		if(rr.getPreAttachedRoutes(pointInd) != null) {
			final RouteSegmentResult[] list = rr.getPreAttachedRoutes(pointInd);
			it = new Iterator<BinaryRoutePlanner.RouteSegment>() {
				int i = 0;
				@Override
				public boolean hasNext() {
					return i < list.length;
				}

				@Override
				public RouteSegment next() {
					RouteSegmentResult r = list[i++];
					return new RouteSegment(r.getObject(), r.getStartPointIndex());
				}

				@Override
				public void remove() {
				}
			};	
		} else {
			RouteSegment rt = ctx.loadRouteSegment(road.getPoint31XTile(pointInd), road.getPoint31YTile(pointInd), ctx.config.memoryLimitation);
			it = rt == null ? null : rt.getIterator();
		}
		// try to attach all segments except with current id
		while (it != null && it.hasNext()) {
			RouteSegment routeSegment = it.next();
			if (routeSegment.road.getId() != road.getId() && routeSegment.road.getId() != previousRoadId) {
				RouteDataObject addRoad = routeSegment.road;
				checkAndInitRouteRegion(ctx, addRoad);
				// TODO restrictions can be considered as well
				int oneWay = ctx.getRouter().isOneWay(addRoad);
				if (oneWay >= 0 && routeSegment.getSegmentStart() < addRoad.getPointsLength() - 1) {
					long pointL = getPoint(addRoad, routeSegment.getSegmentStart() + 1);
					if(pointL != nextL && pointL != prevL) {
						// if way contains same segment (nodes) as different way (do not attach it)
						rr.attachRoute(pointInd, new RouteSegmentResult(addRoad, routeSegment.getSegmentStart(), addRoad.getPointsLength() - 1));
					}
				}
				if (oneWay <= 0 && routeSegment.getSegmentStart() > 0) {
					long pointL = getPoint(addRoad, routeSegment.getSegmentStart() - 1);
					// if way contains same segment (nodes) as different way (do not attach it)
					if(pointL != nextL && pointL != prevL) {
						rr.attachRoute(pointInd, new RouteSegmentResult(addRoad, routeSegment.getSegmentStart(), 0));
					}
				}
			}
		}
	}
	
	private static void println(String logMsg) {
//		log.info(logMsg);
		System.out.println(logMsg);
	}
	
	private long getPoint(RouteDataObject road, int pointInd) {
		return (((long) road.getPoint31XTile(pointInd)) << 31) + (long) road.getPoint31YTile(pointInd);
	}
	
	private static double measuredDist(int x1, int y1, int x2, int y2) {
		return MapUtils.getDistance(MapUtils.get31LatitudeY(y1), MapUtils.get31LongitudeX(x1), 
				MapUtils.get31LatitudeY(y2), MapUtils.get31LongitudeX(x2));
	}


}
!@#$%
20190530_075524,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_a08792
package net.osmand.router;

import gnu.trove.iterator.TIntIterator;
import gnu.trove.list.array.TIntArrayList;
import gnu.trove.set.hash.TIntHashSet;

import java.io.FileWriter;
import java.io.IOException;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import net.osmand.PlatformUtil;
import net.osmand.binary.BinaryMapIndexReader;
import net.osmand.binary.BinaryMapRouteReaderAdapter.RouteTypeRule;
import net.osmand.binary.RouteDataObject;
import net.osmand.data.LatLon;
import net.osmand.osm.MapRenderingTypes;
import net.osmand.router.BinaryRoutePlanner.FinalRouteSegment;
import net.osmand.router.BinaryRoutePlanner.RouteSegment;
import net.osmand.router.GeneralRouter.GeneralRouterProfile;
import net.osmand.router.RoutePlannerFrontEnd.RouteCalculationMode;
import net.osmand.util.Algorithms;
import net.osmand.util.MapAlgorithms;
import net.osmand.util.MapUtils;

import org.apache.commons.logging.Log;

public class RouteResultPreparation {

	public static boolean PRINT_TO_CONSOLE_ROUTE_INFORMATION_TO_TEST = false;
	public static String PRINT_TO_GPX_FILE = null;
	private static final float TURN_DEGREE_MIN = 45;
	public static final int SHIFT_ID = 6;
	private Log log = PlatformUtil.getLog(RouteResultPreparation.class);
	/**
	 * Helper method to prepare final result 
	 */
	List<RouteSegmentResult> prepareResult(RoutingContext ctx, FinalRouteSegment finalSegment) throws IOException {
		List<RouteSegmentResult> result  = convertFinalSegmentToResults(ctx, finalSegment);
		combineWayPointsForAreaRouting(ctx, result);
		prepareResult(ctx, result);
		return result;
	}
	
	private static class CombineAreaRoutePoint {
		int x31;
		int y31;
		int originalIndex;
	}

	private void combineWayPointsForAreaRouting(RoutingContext ctx, List<RouteSegmentResult> result) {
		for(int i = 0; i < result.size(); i++) {
			RouteSegmentResult rsr = result.get(i);
			RouteDataObject obj = rsr.getObject();
			boolean area = false;
			if(obj.getPoint31XTile(0) == obj.getPoint31XTile(obj.getPointsLength() - 1) &&
					obj.getPoint31YTile(0) == obj.getPoint31YTile(obj.getPointsLength() - 1)) {
				area = true;
			}
			if(!area || !ctx.getRouter().isArea(obj)) {
				continue;
			}
			List<CombineAreaRoutePoint> originalWay = new ArrayList<CombineAreaRoutePoint>();
			List<CombineAreaRoutePoint> routeWay = new ArrayList<CombineAreaRoutePoint>();
			for(int j = 0;  j < obj.getPointsLength(); j++) {
				CombineAreaRoutePoint pnt = new CombineAreaRoutePoint();
				pnt.x31 = obj.getPoint31XTile(j);
				pnt.y31 = obj.getPoint31YTile(j);
				pnt.originalIndex = j;
				
				originalWay.add(pnt);
				if(j >= rsr.getStartPointIndex() && j <= rsr.getEndPointIndex()) {
					routeWay.add(pnt);
				} else if(j <= rsr.getStartPointIndex() && j >= rsr.getEndPointIndex()) {
					routeWay.add(0, pnt);
				}
			}
			int originalSize = routeWay.size();
			simplifyAreaRouteWay(routeWay, originalWay);
			int newsize = routeWay.size();
			if (routeWay.size() != originalSize) {
				RouteDataObject nobj = new RouteDataObject(obj);
				nobj.pointsX = new int[newsize];
				nobj.pointsY = new int[newsize];
				for (int k = 0; k < newsize; k++) {
					nobj.pointsX[k] = routeWay.get(k).x31;
					nobj.pointsY[k] = routeWay.get(k).y31;
				}
				// in future point names might be used
				nobj.restrictions = null;
				nobj.restrictionsVia = null;
				nobj.pointTypes = null;
				nobj.pointNames = null;
				nobj.pointNameTypes = null;
				RouteSegmentResult nrsr = new RouteSegmentResult(nobj, 0, newsize - 1);
				result.set(i, nrsr);
			}
		}
	}

	private void simplifyAreaRouteWay(List<CombineAreaRoutePoint> routeWay, List<CombineAreaRoutePoint> originalWay) {
		boolean changed = true;
		while (changed) {
			changed = false;
			int connectStart = -1;
			int connectLen = 0;
			double dist = 0;
			int length = routeWay.size() - 1;
			while (length > 0 && connectLen == 0) {
				for (int i = 0; i < routeWay.size() - length; i++) {
					CombineAreaRoutePoint p = routeWay.get(i);
					CombineAreaRoutePoint n = routeWay.get(i + length);
					if (segmentLineBelongsToPolygon(p, n, originalWay)) {
						double ndist = BinaryRoutePlanner.squareRootDist(p.x31, p.y31, n.x31, n.y31);
						if (ndist > dist) {
							ndist = dist;
							connectStart = i;
							connectLen = length;
						}
					}
				}
				length--;
			}
			while (connectLen > 1) {
				routeWay.remove(connectStart + 1);
				connectLen--;
				changed = true;
			}
		}
		
	}

	private boolean segmentLineBelongsToPolygon(CombineAreaRoutePoint p, CombineAreaRoutePoint n,
			List<CombineAreaRoutePoint> originalWay) {
		int intersections = 0;
		int mx = p.x31 / 2 + n.x31 / 2;
		int my = p.y31 / 2 + n.y31 / 2;
		for(int i = 1; i < originalWay.size(); i++) {
			CombineAreaRoutePoint p2 = originalWay.get(i -1);
			CombineAreaRoutePoint n2 = originalWay.get(i);
			if(p.originalIndex != i && p.originalIndex != i - 1) {
				if(n.originalIndex != i && n.originalIndex != i - 1) {
					if(MapAlgorithms.linesIntersect(p.x31, p.y31, n.x31, n.y31, p2.x31, p2.y31, n2.x31, n2.y31)) {
						return false;
					}
				}
			}
			int fx = MapAlgorithms.ray_intersect_x(p2.x31, p2.y31, n2.x31, n2.y31, my);
			if (Integer.MIN_VALUE != fx && mx >= fx) {
				intersections++;
			}
		}
		return intersections % 2 == 1;
	}

	List<RouteSegmentResult> prepareResult(RoutingContext ctx, List<RouteSegmentResult> result) throws IOException {
		validateAllPointsConnected(result);
		splitRoadsAndAttachRoadSegments(ctx, result);
		calculateTimeSpeed(ctx, result);
		
		for (int i = 0; i < result.size(); i ++) {
			TurnType turnType = getTurnInfo(result, i, ctx.leftSideNavigation);
			result.get(i).setTurnType(turnType);
		}
		
		determineTurnsToMerge(ctx.leftSideNavigation, result);
		ignorePrecedingStraightsOnSameIntersection(ctx.leftSideNavigation, result);
		justifyUTurns(ctx.leftSideNavigation, result);
		addTurnInfoDescriptions(result);
		return result;
	}

	protected void ignorePrecedingStraightsOnSameIntersection(boolean leftside, List<RouteSegmentResult> result) {
		//Issue 2571: Ignore TurnType.C if immediately followed by another turn in non-motorway cases, as these likely belong to the very same intersection
		RouteSegmentResult nextSegment = null;
		double distanceToNextTurn = 999999;
		for (int i = result.size() - 1; i >= 0; i--) {
			// Mark next "real" turn
			if (nextSegment != null && nextSegment.getTurnType() != null &&
					nextSegment.getTurnType().getValue() != TurnType.C &&
					!isMotorway(nextSegment)) {
				if (distanceToNextTurn == 999999) {
					distanceToNextTurn = 0;
				}
			}
			RouteSegmentResult currentSegment = result.get(i);
			// Identify preceding goStraights within distance limit and suppress
			if (currentSegment != null) {
				distanceToNextTurn += currentSegment.getDistance();
				if (currentSegment.getTurnType() != null &&
						currentSegment.getTurnType().getValue() == TurnType.C &&
						distanceToNextTurn <= 100) {
					result.get(i).getTurnType().setSkipToSpeak(true);
				} else {
					nextSegment = currentSegment;
					distanceToNextTurn = 999999;
				}
			}
		}
	}

	private void justifyUTurns(boolean leftSide, List<RouteSegmentResult> result) {
		int next;
		for (int i = 0; i < result.size() - 1; i = next) {
			next = i + 1;
			TurnType t = result.get(i).getTurnType();
			// justify turn
			if (t != null) {
				TurnType jt = justifyUTurn(leftSide, result, i, t);
				if (jt != null) {
					result.get(i).setTurnType(jt);
					next = i + 2;
				}
			}
		}
	}

	private void calculateTimeSpeed(RoutingContext ctx, List<RouteSegmentResult> result) throws IOException {
		//for Naismith
		boolean usePedestrianHeight = ((((GeneralRouter) ctx.getRouter()).getProfile() == GeneralRouterProfile.PEDESTRIAN) && ((GeneralRouter) ctx.getRouter()).getHeightObstacles());

		for (int i = 0; i < result.size(); i++) {
			RouteSegmentResult rr = result.get(i);
			RouteDataObject road = rr.getObject();
			double distOnRoadToPass = 0;
			double speed = ctx.getRouter().defineVehicleSpeed(road);
			if (speed == 0) {
				speed = ctx.getRouter().getMinDefaultSpeed();
			} else {
				if(speed > 15) {
					// decrease speed proportionally from 15ms=50kmh - 
					// reference speed 30ms=108kmh - 7kmh
					speed = speed - ((speed - 15f) / (30f - 15f) * 2f);
				}
			}
			boolean plus = rr.getStartPointIndex() < rr.getEndPointIndex();
			int next;
			double distance = 0;

			//for Naismith
			float prevHeight = -99999.0f;
			float[] heightDistanceArray = null;
			if (usePedestrianHeight) {
				road.calculateHeightArray();
				heightDistanceArray = road.heightDistanceArray;
			}

			for (int j = rr.getStartPointIndex(); j != rr.getEndPointIndex(); j = next) {
				next = plus ? j + 1 : j - 1;
				double d = measuredDist(road.getPoint31XTile(j), road.getPoint31YTile(j), road.getPoint31XTile(next),
						road.getPoint31YTile(next));
				distance += d;
				double obstacle = ctx.getRouter().defineObstacle(road, j);
				if (obstacle < 0) {
					obstacle = 0;
				}
				distOnRoadToPass += d / speed + obstacle;  //this is time in seconds

				//for Naismith
				if (usePedestrianHeight) {
					int heightIndex = 2 * j + 1;
					if (heightDistanceArray != null && heightIndex < heightDistanceArray.length) {
						float height = heightDistanceArray[heightIndex];
						if (prevHeight != -99999.0f) {
							float heightDiff = height - prevHeight;
							if (heightDiff > 0) {  //ascent only
								distOnRoadToPass += heightDiff * 6.0f;  //Naismith's rule: add 1 hour per every 600m of ascent
							}
						}
					prevHeight = height;
					}
				}
			}

			// last point turn time can be added
			// if(i + 1 < result.size()) { distOnRoadToPass += ctx.getRouter().calculateTurnTime(); }
			rr.setSegmentTime((float) distOnRoadToPass);
			rr.setSegmentSpeed((float) speed);
			rr.setDistance((float) distance);
		}
	}

	private void splitRoadsAndAttachRoadSegments(RoutingContext ctx, List<RouteSegmentResult> result) throws IOException {
		for (int i = 0; i < result.size(); i++) {
			if (ctx.checkIfMemoryLimitCritical(ctx.config.memoryLimitation)) {
				ctx.unloadUnusedTiles(ctx.config.memoryLimitation);
			}
			RouteSegmentResult rr = result.get(i);
			RouteDataObject road = rr.getObject();
			checkAndInitRouteRegion(ctx, road);
			boolean plus = rr.getStartPointIndex() < rr.getEndPointIndex();
			int next;
			for (int j = rr.getStartPointIndex(); j != rr.getEndPointIndex(); j = next) {
				next = plus ? j + 1 : j - 1;
				if (j == rr.getStartPointIndex()) {
					attachRoadSegments(ctx, result, i, j, plus);
				}
				if (next != rr.getEndPointIndex()) {
					attachRoadSegments(ctx, result, i, next, plus);
				}
				List<RouteSegmentResult> attachedRoutes = rr.getAttachedRoutes(next);
				boolean tryToSplit = next != rr.getEndPointIndex() && !rr.getObject().roundabout() && attachedRoutes != null;
				if(rr.getDistance(next, plus ) == 0) {
					// same point will be processed next step
					tryToSplit = false;
				}
				if (tryToSplit) {
					// avoid small zigzags
					float before = rr.getBearing(next, !plus);
					float after = rr.getBearing(next, plus);
					if(rr.getDistance(next, plus ) < 5) {
						after = before + 180;
					} else if(rr.getDistance(next, !plus ) < 5) {
						before = after - 180;
					}
					boolean straight = Math.abs(MapUtils.degreesDiff(before + 180, after)) < TURN_DEGREE_MIN;
					boolean isSplit = false;
					// split if needed
					for (RouteSegmentResult rs : attachedRoutes) {
						double diff = MapUtils.degreesDiff(before + 180, rs.getBearingBegin());
						if (Math.abs(diff) <= TURN_DEGREE_MIN) {
							isSplit = true;
						} else if (!straight && Math.abs(diff) < 100) {
							isSplit = true;
						}
					}
					if (isSplit) {
						int endPointIndex = rr.getEndPointIndex();
						RouteSegmentResult split = new RouteSegmentResult(rr.getObject(), next, endPointIndex);
						split.copyPreattachedRoutes(rr, Math.abs(next - rr.getStartPointIndex()));
						rr.setEndPointIndex(next);
						result.add(i + 1, split);
						i++;
						// switch current segment to the splitted
						rr = split;
					}
				}
			}
		}
	}

	private void checkAndInitRouteRegion(RoutingContext ctx, RouteDataObject road) throws IOException {
		BinaryMapIndexReader reader = ctx.reverseMap.get(road.region);
		if(reader != null) {
			reader.initRouteRegion(road.region);
		}
	}

	private void validateAllPointsConnected(List<RouteSegmentResult> result) {
		for (int i = 1; i < result.size(); i++) {
			RouteSegmentResult rr = result.get(i);
			RouteSegmentResult pr = result.get(i - 1);
			double d = MapUtils.getDistance(pr.getPoint(pr.getEndPointIndex()), rr.getPoint(rr.getStartPointIndex()));
			if (d > 0) {
				System.err.println("Points are not connected : " + pr.getObject() + "(" + pr.getEndPointIndex() + ") -> " + rr.getObject()
						+ "(" + rr.getStartPointIndex() + ") " + d + " meters");
			}
		}
	}

	private List<RouteSegmentResult> convertFinalSegmentToResults(RoutingContext ctx, FinalRouteSegment finalSegment) {
		List<RouteSegmentResult> result = new ArrayList<RouteSegmentResult>();
		if (finalSegment != null) {
			ctx.routingTime = finalSegment.distanceFromStart;
			println("Routing calculated time distance " + finalSegment.distanceFromStart);
			// Get results from opposite direction roads
			RouteSegment segment = finalSegment.reverseWaySearch ? finalSegment : 
				finalSegment.opposite.getParentRoute();
			int parentSegmentStart = finalSegment.reverseWaySearch ? finalSegment.opposite.getSegmentStart() : 
				finalSegment.opposite.getParentSegmentEnd();
			float parentRoutingTime = -1;
			while (segment != null) {
				RouteSegmentResult res = new RouteSegmentResult(segment.road, parentSegmentStart, segment.getSegmentStart());
				parentRoutingTime = calcRoutingTime(parentRoutingTime, finalSegment, segment, res);
				parentSegmentStart = segment.getParentSegmentEnd();
				segment = segment.getParentRoute();
				addRouteSegmentToResult(ctx, result, res, false);
			}
			// reverse it just to attach good direction roads
			Collections.reverse(result);

			segment = finalSegment.reverseWaySearch ? finalSegment.opposite.getParentRoute() : finalSegment;
			int parentSegmentEnd = finalSegment.reverseWaySearch ? finalSegment.opposite.getParentSegmentEnd() : finalSegment.opposite.getSegmentStart();
			parentRoutingTime = -1;
			while (segment != null) {
				RouteSegmentResult res = new RouteSegmentResult(segment.road, segment.getSegmentStart(), parentSegmentEnd);
				parentRoutingTime = calcRoutingTime(parentRoutingTime, finalSegment, segment, res);
				parentSegmentEnd = segment.getParentSegmentEnd();
				segment = segment.getParentRoute();
				// happens in smart recalculation
				addRouteSegmentToResult(ctx, result, res, true);
			}
			Collections.reverse(result);
			// checkTotalRoutingTime(result);
		}
		return result;
	}

	protected void checkTotalRoutingTime(List<RouteSegmentResult> result) {
		float totalRoutingTime = 0;
		for(RouteSegmentResult r : result) {
			totalRoutingTime += r.getRoutingTime();
		}
		println("Total routing time ! " + totalRoutingTime);
	}

	private float calcRoutingTime(float parentRoutingTime, RouteSegment finalSegment, RouteSegment segment,
			RouteSegmentResult res) {
		if(segment != finalSegment) {
			if(parentRoutingTime != -1) {
				res.setRoutingTime(parentRoutingTime - segment.distanceFromStart);
			}
			parentRoutingTime = segment.distanceFromStart;
		}
		return parentRoutingTime;
	}
	
	private void addRouteSegmentToResult(RoutingContext ctx, List<RouteSegmentResult> result, RouteSegmentResult res, boolean reverse) {
		if (res.getStartPointIndex() != res.getEndPointIndex()) {
			if (result.size() > 0) {
				RouteSegmentResult last = result.get(result.size() - 1);
				if (last.getObject().id == res.getObject().id && ctx.calculationMode != RouteCalculationMode.BASE) {
					if (combineTwoSegmentResult(res, last, reverse)) {
						return;
					}
				}
			}
			result.add(res);
		}
	}
	
	private boolean combineTwoSegmentResult(RouteSegmentResult toAdd, RouteSegmentResult previous, 
			boolean reverse) {
		boolean ld = previous.getEndPointIndex() > previous.getStartPointIndex();
		boolean rd = toAdd.getEndPointIndex() > toAdd.getStartPointIndex();
		if (rd == ld) {
			if (toAdd.getStartPointIndex() == previous.getEndPointIndex() && !reverse) {
				previous.setEndPointIndex(toAdd.getEndPointIndex());
				previous.setRoutingTime(previous.getRoutingTime() + toAdd.getRoutingTime());
				return true;
			} else if (toAdd.getEndPointIndex() == previous.getStartPointIndex() && reverse) {
				previous.setStartPointIndex(toAdd.getStartPointIndex());
				previous.setRoutingTime(previous.getRoutingTime() + toAdd.getRoutingTime());
				return true;
			}
		}
		return false;
	}
	
	void printResults(RoutingContext ctx, LatLon start, LatLon end, List<RouteSegmentResult> result) {
		float completeTime = 0;
		float completeDistance = 0;
		for(RouteSegmentResult r : result) {
			completeTime += r.getSegmentTime();
			completeDistance += r.getDistance();
		}

		println("ROUTE : ");
		double startLat = start.getLatitude();
		double startLon = start.getLongitude();
		double endLat = end.getLatitude();
		double endLon = end.getLongitude();
		
		String msg = String.format("<test regions=\"\" description=\"\" best_percent=\"\" vehicle=\"%s\" \n"
				+ "  start_lat=\"%.5f\" start_lon=\"%.5f\" target_lat=\"%.5f\" target_lon=\"%.5f\" "
				+ " routing_time=\"%.2f\" loadedTiles=\"%d\" visitedSegments=\"%d\" complete_distance=\"%.2f\" complete_time=\"%.2f\" >",
				ctx.config.routerName, startLat, startLon, endLat, endLon, ctx.routingTime, ctx.loadedTiles, 
				ctx.visitedSegments, completeDistance, completeTime);
//		String msg = MessageFormat.format("<test regions=\"\" description=\"\" best_percent=\"\" vehicle=\"{4}\" \n"
//				+ "    start_lat=\"{0}\" start_lon=\"{1}\" target_lat=\"{2}\" target_lon=\"{3}\" {5} >", 
//				startLat + "", startLon + "", endLat + "", endLon + "", ctx.config.routerName, 
//				"loadedTiles = \"" + ctx.loadedTiles + "\" " + "visitedSegments = \"" + ctx.visitedSegments + "\" " +
//				"complete_distance = \"" + completeDistance + "\" " + "complete_time = \"" + completeTime + "\" " +
//				"routing_time = \"" + ctx.routingTime + "\" ");
		log.info(msg);
        println(msg);
		if (PRINT_TO_CONSOLE_ROUTE_INFORMATION_TO_TEST) {
			org.xmlpull.v1.XmlSerializer serializer = null;
			if(PRINT_TO_GPX_FILE != null) {
				serializer = PlatformUtil.newSerializer();
				try {
					serializer.setOutput(new FileWriter(PRINT_TO_GPX_FILE));
					serializer.setFeature("http://xmlpull.org/v1/doc/features.html#indent-output", true);
					// indentation as 3 spaces
//					serializer.setProperty("http://xmlpull.org/v1/doc/properties.html#serializer-indentation", "   ");
//					// also set the line separator
//					serializer.setProperty("http://xmlpull.org/v1/doc/properties.html#serializer-line-separator", "\n");
					serializer.startDocument("UTF-8", true);
					serializer.startTag("", "gpx");
					serializer.attribute("", "version", "1.1");
					serializer.attribute("", "xmlns", "http://www.topografix.com/GPX/1/1");
					serializer.attribute("", "xmlns:xsi", "http://www.w3.org/2001/XMLSchema-instance");
					serializer.attribute("", "xmlns:schemaLocation", "http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd");
					serializer.startTag("", "trk");
					serializer.startTag("", "trkseg");
				} catch (IOException e) {
					e.printStackTrace();
					serializer = null;
				}
			}
					
			double lastHeight = -180;		
			for (RouteSegmentResult res : result) {
				String name = res.getObject().getName();
				String ref = res.getObject().getRef("", false, res.isForwardDirection());
				if (name == null) {
					name = "";
				}
				if (ref != null) {
					name += " (" + ref + ") ";
				}
				StringBuilder additional = new StringBuilder();
				additional.append("time = \"").append(res.getSegmentTime()).append("\" ");
				additional.append("rtime = \"").append(res.getRoutingTime()).append("\" ");
				additional.append("name = \"").append(name).append("\" ");
//				float ms = res.getSegmentSpeed();
				float ms = res.getObject().getMaximumSpeed(res.isForwardDirection());
				if(ms > 0) {
					additional.append("maxspeed = \"").append(ms * 3.6f).append("\" ").append(res.getObject().getHighway()).append(" ");
				}
				additional.append("distance = \"").append(res.getDistance()).append("\" ");
				if (res.getTurnType() != null) {
					additional.append("turn = \"").append(res.getTurnType()).append("\" ");
					additional.append("turn_angle = \"").append(res.getTurnType().getTurnAngle()).append("\" ");
					if (res.getTurnType().getLanes() != null) {
						additional.append("lanes = \"").append(Arrays.toString(res.getTurnType().getLanes())).append("\" ");
					}
				}
				additional.append("start_bearing = \"").append(res.getBearingBegin()).append("\" ");
				additional.append("end_bearing = \"").append(res.getBearingEnd()).append("\" ");
				additional.append("height = \"").append(Arrays.toString(res.getHeightValues())).append("\" ");
				additional.append("description = \"").append(res.getDescription()).append("\" ");
				println(MessageFormat.format("\t<segment id=\"{0}\" oid=\"{1}\" start=\"{2}\" end=\"{3}\" {4}/>",
						(res.getObject().getId() >> (SHIFT_ID )) + "", res.getObject().getId() + "", 
						res.getStartPointIndex() + "", res.getEndPointIndex() + "", additional.toString()));
				int inc = res.getStartPointIndex() < res.getEndPointIndex() ? 1 : -1;
				int indexnext = res.getStartPointIndex();
				LatLon prev = null;
				for (int index = res.getStartPointIndex() ; index != res.getEndPointIndex(); ) {
					index = indexnext;
					indexnext += inc; 
					if (serializer != null) {
						try {
							LatLon l = res.getPoint(index);
							serializer.startTag("","trkpt");
							serializer.attribute("", "lat",  l.getLatitude() + "");
							serializer.attribute("", "lon",  l.getLongitude() + "");
							float[] vls = res.getObject().heightDistanceArray;
							double dist = prev == null ? 0 : MapUtils.getDistance(prev, l);
							if(index * 2 + 1 < vls.length) {
								double h = vls[2*index + 1];
								serializer.startTag("","ele");
								serializer.text(h +"");
								serializer.endTag("","ele");
								if(lastHeight != -180 && dist > 0) {
									serializer.startTag("","cmt");
									serializer.text((float) ((h -lastHeight)/ dist*100) + "% " +
									" degree " + (float) Math.atan(((h -lastHeight)/ dist)) / Math.PI * 180 +  
									" asc " + (float) (h -lastHeight) + " dist "
											+ (float) dist);
									serializer.endTag("","cmt");
									serializer.startTag("","slope");
									serializer.text((h -lastHeight)/ dist*100 + "");
									serializer.endTag("","slope");
								}
								serializer.startTag("","desc");
								serializer.text((res.getObject().getId() >> (SHIFT_ID )) + " " + index);
								serializer.endTag("","desc");
								lastHeight = h;
							} else if(lastHeight != -180){
//								serializer.startTag("","ele");
//								serializer.text(lastHeight +"");
//								serializer.endTag("","ele");
							}
							serializer.endTag("", "trkpt");
							prev = l;
						} catch (IOException e) {
							e.printStackTrace();
						}
					}
				}
				printAdditionalPointInfo(res);
			}
			if(serializer != null) {
				try {
					serializer.endTag("", "trkseg");
					serializer.endTag("", "trk");
					serializer.endTag("", "gpx");
					serializer.endDocument();
					serializer.flush();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
		}
		println("</test>");
		println(msg);
	}

	private void printAdditionalPointInfo(RouteSegmentResult res) {
		boolean plus = res.getStartPointIndex() < res.getEndPointIndex();
		for(int k = res.getStartPointIndex(); k != res.getEndPointIndex(); ) {
			int[] tp = res.getObject().getPointTypes(k);
			String[] pointNames = res.getObject().getPointNames(k);
			int[] pointNameTypes = res.getObject().getPointNameTypes(k);
			if (tp != null || pointNameTypes != null) {
				StringBuilder bld = new StringBuilder();
				bld.append("<point " + (k));
				if (tp != null) {
					for (int t = 0; t < tp.length; t++) {
						RouteTypeRule rr = res.getObject().region.quickGetEncodingRule(tp[t]);
						bld.append(" " + rr.getTag() + "=\"" + rr.getValue() + "\"");
					}
				}
				if (pointNameTypes != null) {
					for (int t = 0; t < pointNameTypes.length; t++) {
						RouteTypeRule rr = res.getObject().region.quickGetEncodingRule(pointNameTypes[t]);
						bld.append(" " + rr.getTag() + "=\"" + pointNames[t] + "\"");
					}
				}
				bld.append("/>");
				println("\t"+bld.toString());
			}
			if(plus) {
				k++;
			} else {
				k--;
			}
		}
	}


	protected void addTurnInfoDescriptions(List<RouteSegmentResult> result) {
		int prevSegment = -1;
		float dist = 0;
		for (int i = 0; i <= result.size(); i++) {
			if (i == result.size() || result.get(i).getTurnType() != null) {
				if (prevSegment >= 0) {
					String turn = result.get(prevSegment).getTurnType().toString();
					result.get(prevSegment).setDescription(
							turn + MessageFormat.format(" and go {0,number,#.##} meters", dist));
					if (result.get(prevSegment).getTurnType().isSkipToSpeak()) {
						result.get(prevSegment).setDescription("-*" + result.get(prevSegment).getDescription());
					}
				}
				prevSegment = i;
				dist = 0;
			}
			if (i < result.size()) {
				dist += result.get(i).getDistance();
			}
		}
	}

	protected TurnType justifyUTurn(boolean leftside, List<RouteSegmentResult> result, int i, TurnType t) {
		boolean tl = TurnType.isLeftTurnNoUTurn(t.getValue());
		boolean tr = TurnType.isRightTurnNoUTurn(t.getValue());
		if(tl || tr) {
			TurnType tnext = result.get(i + 1).getTurnType();
			if (tnext != null && result.get(i).getDistance() < 50) { //
				boolean ut = true;
				if (i > 0) {
					double uTurn = MapUtils.degreesDiff(result.get(i - 1).getBearingEnd(), result
							.get(i + 1).getBearingBegin());
					if (Math.abs(uTurn) < 120) {
						ut = false;
					}
				}
//				String highway = result.get(i).getObject().getHighway();
//				if(highway == null || highway.endsWith("track") || highway.endsWith("services") || highway.endsWith("service")
//						|| highway.endsWith("path")) {
//					ut = false;
//				}
				if (result.get(i - 1).getObject().getOneway() == 0 || result.get(i + 1).getObject().getOneway() == 0) {
					ut = false;
				}
				if (!Algorithms.objectEquals(getStreetName(result, i - 1, false), 
						getStreetName(result, i + 1, true))) {
					ut = false;
				}
				if (ut) {
					tnext.setSkipToSpeak(true);
					if (tl && TurnType.isLeftTurnNoUTurn(tnext.getValue())) {
						TurnType tt = TurnType.valueOf(TurnType.TU, false);
						tt.setLanes(t.getLanes());
						return tt;
					} else if (tr && TurnType.isRightTurnNoUTurn(tnext.getValue())) {
						TurnType tt = TurnType.valueOf(TurnType.TU, true);
						tt.setLanes(t.getLanes());
						return tt;
					}
				}
			}
		}
		return null;
	}

	private String getStreetName(List<RouteSegmentResult> result, int i, boolean dir) {
		String nm = result.get(i).getObject().getName();
		if (Algorithms.isEmpty(nm)) {
			if (!dir) {
				if (i > 0) {
					nm = result.get(i - 1).getObject().getName();
				}
			} else {
				if(i < result.size() - 1) {
					nm = result.get(i + 1).getObject().getName();
				}
			}
		}
		
		return nm;
	}

	private void determineTurnsToMerge(boolean leftside, List<RouteSegmentResult> result) {
		RouteSegmentResult nextSegment = null;
		double dist = 0;
		for (int i = result.size() - 1; i >= 0; i--) {
			RouteSegmentResult currentSegment = result.get(i);
			TurnType currentTurn = currentSegment.getTurnType();
			dist += currentSegment.getDistance();
			if (currentTurn == null || currentTurn.getLanes() == null) {
				// skip
			} else {
				boolean merged = false;
				if (nextSegment != null) {
					String hw = currentSegment.getObject().getHighway();
					double mergeDistance = 200;
					if (hw != null && (hw.startsWith("trunk") || hw.startsWith("motorway"))) {
						mergeDistance = 400;
					}
					if (dist < mergeDistance) {
						mergeTurnLanes(leftside, currentSegment, nextSegment);
						inferCommonActiveLane(currentSegment.getTurnType(), nextSegment.getTurnType());
						merged = true;
					}
				}
				if (!merged) {
					TurnType tt = currentSegment.getTurnType();
					inferActiveTurnLanesFromTurn(tt, TurnType.C);
				}
				nextSegment = currentSegment;
				dist = 0;
			}
		}
	}

	private void inferActiveTurnLanesFromTurn(TurnType tt, int type) {
		boolean found = false;
		if (tt.getValue() == type && tt.getLanes() != null) {
			for (int it = 0; it < tt.getLanes().length; it++) {
				int turn = tt.getLanes()[it];
				if (TurnType.getPrimaryTurn(turn) == type ||
						TurnType.getSecondaryTurn(turn) == type ||
						TurnType.getTertiaryTurn(turn) == type) {
					found = true;
					break;
				}
			}
		}
		if(found) {
			for (int it = 0; it < tt.getLanes().length; it++) {
				int turn = tt.getLanes()[it];
				if (TurnType.getPrimaryTurn(turn) != type) {
					if(TurnType.getSecondaryTurn(turn) == type) {
						int st = TurnType.getSecondaryTurn(turn);
						TurnType.setSecondaryTurn(tt.getLanes(), it, TurnType.getPrimaryTurn(turn));
						TurnType.setPrimaryTurn(tt.getLanes(), it, st);
					} else if(TurnType.getTertiaryTurn(turn) == type) {
						int st = TurnType.getTertiaryTurn(turn);
						TurnType.setTertiaryTurn(tt.getLanes(), it, TurnType.getPrimaryTurn(turn));
						TurnType.setPrimaryTurn(tt.getLanes(), it, st);
					} else {
						tt.getLanes()[it] = turn & (~1);
					}
				}
			}
		}
	}
	
	private class MergeTurnLaneTurn {
		TurnType turn;
		int[] originalLanes;
		int[] disabledLanes;
		int activeStartIndex = -1;
		int activeEndIndex = -1;
		int activeLen = 0;
		
		public MergeTurnLaneTurn(RouteSegmentResult segment) {
			this.turn = segment.getTurnType();
			if(turn != null) {
				originalLanes = turn.getLanes();
			}
			if(originalLanes != null) {
				disabledLanes = new int[originalLanes.length];
				for (int i = 0; i < originalLanes.length; i++) {
					int ln = originalLanes[i];
					disabledLanes[i] = ln & ~1;
					if ((ln & 1) > 0) {
						if (activeStartIndex == -1) {
							activeStartIndex = i;
						}
						activeEndIndex = i;
						activeLen++;
					}
				}
			}
		}
		
		public boolean isActiveTurnMostLeft() {
			return activeStartIndex == 0;
		}
		public boolean isActiveTurnMostRight() {
			return activeEndIndex == originalLanes.length - 1;
		}
	}
	
	private boolean mergeTurnLanes(boolean leftSide, RouteSegmentResult currentSegment, RouteSegmentResult nextSegment) {
		MergeTurnLaneTurn active = new MergeTurnLaneTurn(currentSegment);
		MergeTurnLaneTurn target = new MergeTurnLaneTurn(nextSegment);
		if (active.activeLen < 2) {
			return false;
		}
		if (target.activeStartIndex == -1) {
			return false;
		}
		boolean changed = false;
		if (target.isActiveTurnMostLeft()) {
			// let only the most left lanes be enabled
			if (target.activeLen < active.activeLen) {
				active.activeEndIndex -= (active.activeLen - target.activeLen);
				changed = true;
			}
		} else if (target.isActiveTurnMostRight()) {
			// next turn is right
			// let only the most right lanes be enabled
			if (target.activeLen < active.activeLen ) {
				active.activeStartIndex += (active.activeLen - target.activeLen);
				changed = true;
			}
		} else {
			// next turn is get through (take out the left and the right turn)
			if (target.activeLen < active.activeLen) {
				if(target.originalLanes.length == active.activeLen) {
					active.activeEndIndex = active.activeStartIndex + target.activeEndIndex;
					active.activeStartIndex = active.activeStartIndex + target.activeStartIndex;
					changed = true;
				} else {
					int straightActiveLen = 0;
					int straightActiveBegin = -1;
					for(int i = active.activeStartIndex; i <= active.activeEndIndex; i++) {
						if(TurnType.hasAnyTurnLane(active.originalLanes[i], TurnType.C)) {
							straightActiveLen++;
							if(straightActiveBegin == -1) {
								straightActiveBegin = i;
							}
						}
					}
					if(straightActiveBegin != -1 && straightActiveLen <= target.activeLen) {
						active.activeStartIndex = straightActiveBegin;
						active.activeEndIndex = straightActiveBegin + straightActiveLen - 1;
						changed = true;
					} else {
						// cause the next-turn goes forward exclude left most and right most lane
						if (active.activeStartIndex == 0) {
							active.activeStartIndex++;
							active.activeLen--;
						}
						if (active.activeEndIndex == active.originalLanes.length - 1) {
							active.activeEndIndex--;
							active.activeLen--;
						}
						float ratio = (active.activeLen - target.activeLen) / 2f;
						if (ratio > 0) {
							active.activeEndIndex = (int) Math.ceil(active.activeEndIndex - ratio);
							active.activeStartIndex = (int) Math.floor(active.activeStartIndex + ratio);
						}
						changed = true;
					}
				}
			}
		}
		if (!changed) {
			return false;
		}

		// set the allowed lane bit
		for (int i = 0; i < active.disabledLanes.length; i++) {
			if (i >= active.activeStartIndex && i <= active.activeEndIndex && 
					active.originalLanes[i] % 2 == 1) {
				active.disabledLanes[i] |= 1;
			}
		}
		TurnType currentTurn = currentSegment.getTurnType();
		currentTurn.setLanes(active.disabledLanes);
		return true;
	}
	
	private void inferCommonActiveLane(TurnType currentTurn, TurnType nextTurn) {
		int[] lanes = currentTurn.getLanes();
		TIntHashSet turnSet = new TIntHashSet();
		for(int i = 0; i < lanes.length; i++) {
			if(lanes[i] % 2 == 1 ) {
				int singleTurn = TurnType.getPrimaryTurn(lanes[i]);
				turnSet.add(singleTurn);
				if(TurnType.getSecondaryTurn(lanes[i]) != 0) {
					turnSet.add(TurnType.getSecondaryTurn(lanes[i]));
				}
				if(TurnType.getTertiaryTurn(lanes[i]) != 0) {
					turnSet.add(TurnType.getTertiaryTurn(lanes[i]));
				}
			}
		}
		int singleTurn = 0;
		if(turnSet.size() == 1) {
			singleTurn = turnSet.iterator().next();
		} else if(currentTurn.goAhead() && turnSet.contains(nextTurn.getValue())) {
			if(currentTurn.isPossibleLeftTurn() && 
					TurnType.isLeftTurn(nextTurn.getValue())) {
				singleTurn = nextTurn.getValue();	
			} else if(currentTurn.isPossibleLeftTurn() && 
					TurnType.isLeftTurn(nextTurn.getActiveCommonLaneTurn())) {
				singleTurn = nextTurn.getActiveCommonLaneTurn();
			} else if(currentTurn.isPossibleRightTurn() && 
					TurnType.isRightTurn(nextTurn.getValue())) {
				singleTurn = nextTurn.getValue();
			} else if(currentTurn.isPossibleRightTurn() && 
					TurnType.isRightTurn(nextTurn.getActiveCommonLaneTurn())) {
				singleTurn = nextTurn.getActiveCommonLaneTurn();
			}
		}
		if (singleTurn == 0) {
			singleTurn = currentTurn.getValue();
			if(singleTurn == TurnType.KL || singleTurn == TurnType.KR) {
				return;
			}
		}
		for(int i = 0; i < lanes.length; i++) {
			if(lanes[i] % 2 == 1 && TurnType.getPrimaryTurn(lanes[i]) != singleTurn) {
				if(TurnType.getSecondaryTurn(lanes[i]) == singleTurn) {
					TurnType.setSecondaryTurn(lanes, i, TurnType.getPrimaryTurn(lanes[i]));
					TurnType.setPrimaryTurn(lanes, i, singleTurn);
				} else if(TurnType.getTertiaryTurn(lanes[i]) == singleTurn) {
					TurnType.setTertiaryTurn(lanes, i, TurnType.getPrimaryTurn(lanes[i]));
					TurnType.setPrimaryTurn(lanes, i, singleTurn);
				} else {
					// disable lane
					lanes[i] = lanes[i] - 1;
				}
			}
		}
		
	}

	private static final int MAX_SPEAK_PRIORITY = 5;
	private int highwaySpeakPriority(String highway) {
		if(highway == null || highway.endsWith("track") || highway.endsWith("services") || highway.endsWith("service")
				|| highway.endsWith("path")) {
			return MAX_SPEAK_PRIORITY;
		}
		if (highway.endsWith("_link")  || highway.endsWith("unclassified") || highway.endsWith("road") 
				|| highway.endsWith("living_street") || highway.endsWith("residential") )  {
			return 1;
		}
		return 0;
	}


	private TurnType getTurnInfo(List<RouteSegmentResult> result, int i, boolean leftSide) {
		if (i == 0) {
			return TurnType.valueOf(TurnType.C, false);
		}
		RouteSegmentResult prev = result.get(i - 1) ;
		if(prev.getObject().roundabout()) {
			// already analyzed!
			return null;
		}
		RouteSegmentResult rr = result.get(i);
		if (rr.getObject().roundabout()) {
			return processRoundaboutTurn(result, i, leftSide, prev, rr);
		}
		TurnType t = null;
		if (prev != null) {
			boolean noAttachedRoads = rr.getAttachedRoutes(rr.getStartPointIndex()).size() == 0;
			// add description about turn
			double mpi = MapUtils.degreesDiff(prev.getBearingEnd(), rr.getBearingBegin());
			if(noAttachedRoads){
				// TODO VICTOR : look at the comment inside direction route
				// ? avoid small zigzags is covered at (search for "zigzags") 
//				double begin = rr.getObject().directionRoute(rr.getStartPointIndex(), rr.getStartPointIndex() < 
//						rr.getEndPointIndex(), 25);
//				mpi = MapUtils.degreesDiff(prev.getBearingEnd(), begin);
			}
			if (mpi >= TURN_DEGREE_MIN) {
				if (mpi < 45) {
					// Slight turn detection here causes many false positives where drivers would expect a "normal" TL. Best use limit-angle=TURN_DEGREE_MIN, this reduces TSL to the turn-lanes cases.
					t = TurnType.valueOf(TurnType.TSLL, leftSide);
				} else if (mpi < 120) {
					t = TurnType.valueOf(TurnType.TL, leftSide);
				} else if (mpi < 150 || leftSide) {
					t = TurnType.valueOf(TurnType.TSHL, leftSide);
				} else {
					t = TurnType.valueOf(TurnType.TU, leftSide);
				}
				int[] lanes = getTurnLanesInfo(prev, t.getValue());
				t.setLanes(lanes);
			} else if (mpi < -TURN_DEGREE_MIN) {
				if (mpi > -45) {
					t = TurnType.valueOf(TurnType.TSLR, leftSide);
				} else if (mpi > -120) {
					t = TurnType.valueOf(TurnType.TR, leftSide);
				} else if (mpi > -150 || !leftSide) {
					t = TurnType.valueOf(TurnType.TSHR, leftSide);
				} else {
					t = TurnType.valueOf(TurnType.TRU, leftSide);
				}
				int[] lanes = getTurnLanesInfo(prev, t.getValue());
				t.setLanes(lanes);
			} else {
				t = attachKeepLeftInfoAndLanes(leftSide, prev, rr);
			}
			if (t != null) {
				t.setTurnAngle((float) -mpi);
			}
		}
		return t;
	}

	private int[] getTurnLanesInfo(RouteSegmentResult prevSegm, int mainTurnType) {		String turnLanes = getTurnLanesString(prevSegm);
		int[] lanesArray ;
		if (turnLanes == null) {
			if(prevSegm.getTurnType() != null && prevSegm.getTurnType().getLanes() != null
					&& prevSegm.getDistance() < 100) {
				int[] lns = prevSegm.getTurnType().getLanes();
				TIntArrayList lst = new TIntArrayList();
				for(int i = 0; i < lns.length; i++) {
					if(lns[i] % 2 == 1) {
						lst.add((lns[i] >> 1) << 1);
					}
				}
				if(lst.isEmpty()) {
					return null;
				}
				lanesArray = lst.toArray();
			} else {
				return null;
			}
		} else {
			lanesArray = calculateRawTurnLanes(turnLanes, mainTurnType);
		}
		// Manually set the allowed lanes.
		boolean isSet = setAllowedLanes(mainTurnType, lanesArray);
		if(!isSet && lanesArray.length > 0) {
			// In some cases (at least in the US), the rightmost lane might not have a right turn indicated as per turn:lanes,
			// but is allowed and being used here. This section adds in that indicator.  The same applies for where leftSide is true.
			boolean leftTurn = TurnType.isLeftTurn(mainTurnType);
			int ind = leftTurn? 0 : lanesArray.length - 1;
			int primaryTurn = TurnType.getPrimaryTurn(lanesArray[ind]);
			final int st = TurnType.getSecondaryTurn(lanesArray[ind]);
			if (leftTurn) {
				if (!TurnType.isLeftTurn(primaryTurn)) {
					// This was just to make sure that there's no bad data.
					TurnType.setPrimaryTurnAndReset(lanesArray, ind, TurnType.TL);
					TurnType.setSecondaryTurn(lanesArray, ind, primaryTurn);
					TurnType.setTertiaryTurn(lanesArray, ind, st);
					primaryTurn = TurnType.TL;
					lanesArray[ind] |= 1;
				}
			} else {
				if (!TurnType.isRightTurn(primaryTurn)) {
					// This was just to make sure that there's no bad data.
					TurnType.setPrimaryTurnAndReset(lanesArray, ind, TurnType.TR);
					TurnType.setSecondaryTurn(lanesArray, ind, primaryTurn);
					TurnType.setTertiaryTurn(lanesArray, ind, st);
					primaryTurn = TurnType.TR;
					lanesArray[ind] |= 1;
				}
			}
			setAllowedLanes(primaryTurn, lanesArray);
		}
		return lanesArray;
	}

	protected boolean setAllowedLanes(int mainTurnType, int[] lanesArray) {
		boolean turnSet = false;
		for (int i = 0; i < lanesArray.length; i++) {
			if (TurnType.getPrimaryTurn(lanesArray[i]) == mainTurnType) {
				lanesArray[i] |= 1;
				turnSet = true;
			}
		}
		return turnSet;
	}

	private TurnType processRoundaboutTurn(List<RouteSegmentResult> result, int i, boolean leftSide, RouteSegmentResult prev,
			RouteSegmentResult rr) {
		int exit = 1;
		RouteSegmentResult last = rr;
		RouteSegmentResult firstRoundabout = rr;
		RouteSegmentResult lastRoundabout = rr;
		for (int j = i; j < result.size(); j++) {
			RouteSegmentResult rnext = result.get(j);
			last = rnext;
			if (rnext.getObject().roundabout()) {
				lastRoundabout = rnext;
				boolean plus = rnext.getStartPointIndex() < rnext.getEndPointIndex();
				int k = rnext.getStartPointIndex();
				if (j == i) {
					// first exit could be immediately after roundabout enter
//					k = plus ? k + 1 : k - 1;
				}
				while (k != rnext.getEndPointIndex()) {
					int attachedRoads = rnext.getAttachedRoutes(k).size();
					if(attachedRoads > 0) {
						exit++;
					}
					k = plus ? k + 1 : k - 1;
				}
			} else {
				break;
			}
		}
		// combine all roundabouts
		TurnType t = TurnType.getExitTurn(exit, 0, leftSide);
		// usually covers more than expected
		float turnAngleBasedOnOutRoads = (float) MapUtils.degreesDiff(last.getBearingBegin(), prev.getBearingEnd());
		// usually covers less than expected
		float turnAngleBasedOnCircle = (float) -MapUtils.degreesDiff(firstRoundabout.getBearingBegin(), lastRoundabout.getBearingEnd() + 180);
		if(Math.abs(turnAngleBasedOnOutRoads - turnAngleBasedOnCircle) > 180) {
			t.setTurnAngle(turnAngleBasedOnCircle ) ;
		} else {
			t.setTurnAngle((turnAngleBasedOnCircle + turnAngleBasedOnOutRoads) / 2) ;
		}
		return t;
	}
	
	private class RoadSplitStructure {
		boolean keepLeft = false;
		boolean keepRight = false;
		boolean speak = false;
		List<int[]> leftLanesInfo = new ArrayList<int[]>();
		int leftLanes = 0;
		List<int[]> rightLanesInfo = new ArrayList<int[]>();
		int rightLanes = 0;
		int roadsOnLeft = 0;
		int addRoadsOnLeft = 0;
		int roadsOnRight = 0;
		int addRoadsOnRight = 0;
	}


	private TurnType attachKeepLeftInfoAndLanes(boolean leftSide, RouteSegmentResult prevSegm, RouteSegmentResult currentSegm) {
		List<RouteSegmentResult> attachedRoutes = currentSegm.getAttachedRoutes(currentSegm.getStartPointIndex());
		if(attachedRoutes == null || attachedRoutes.size() == 0) {
			return null;
		}
		// keep left/right
		RoadSplitStructure rs = calculateRoadSplitStructure(prevSegm, currentSegm, attachedRoutes);
		if(rs.roadsOnLeft  + rs.roadsOnRight == 0) {
			return null;
		}
		
		// turn lanes exist
		String turnLanes = getTurnLanesString(prevSegm);
		if (turnLanes != null) {
			return createKeepLeftRightTurnBasedOnTurnTypes(rs, prevSegm, currentSegm, turnLanes, leftSide);
		}

		// turn lanes don't exist
		if (rs.keepLeft || rs.keepRight) {
			return createSimpleKeepLeftRightTurn(leftSide, prevSegm, currentSegm, rs);
			
		}
		return null;
	}

	protected TurnType createKeepLeftRightTurnBasedOnTurnTypes(RoadSplitStructure rs, RouteSegmentResult prevSegm,
			RouteSegmentResult currentSegm, String turnLanes, boolean leftSide) {
		// Maybe going straight at a 90-degree intersection
		TurnType t = TurnType.valueOf(TurnType.C, leftSide);
		int[] rawLanes = calculateRawTurnLanes(turnLanes, TurnType.C);
		boolean possiblyLeftTurn = rs.roadsOnLeft == 0;
		boolean possiblyRightTurn = rs.roadsOnRight == 0;
		for (int k = 0; k < rawLanes.length; k++) {
			int turn = TurnType.getPrimaryTurn(rawLanes[k]);
			int sturn = TurnType.getSecondaryTurn(rawLanes[k]);
			int tturn = TurnType.getTertiaryTurn(rawLanes[k]);
			if (turn == TurnType.TU || sturn == TurnType.TU || tturn == TurnType.TU) {
				possiblyLeftTurn = true;
			}
			if (turn == TurnType.TRU || sturn == TurnType.TRU || sturn == TurnType.TRU) {
				possiblyRightTurn = true;
			}
		}
		
		t.setPossibleLeftTurn(possiblyLeftTurn);
		t.setPossibleRightTurn(possiblyRightTurn);
		if (rs.keepLeft || rs.keepRight) {
			String[] splitLaneOptions = turnLanes.split("\\|", -1);
			int activeBeginIndex = findActiveIndex(rawLanes, splitLaneOptions, rs.leftLanes, true, 
					rs.leftLanesInfo, rs.roadsOnLeft, rs.addRoadsOnLeft);
			
			if(!rs.keepLeft && activeBeginIndex != -1 && 
					splitLaneOptions.length > 0 && !splitLaneOptions[splitLaneOptions.length - 1].contains(";")) {
				activeBeginIndex = Math.max(activeBeginIndex, 1);
			}
			int activeEndIndex = findActiveIndex(rawLanes, splitLaneOptions, rs.rightLanes, false, 
					rs.rightLanesInfo, rs.roadsOnRight, rs.addRoadsOnRight);
			if(!rs.keepRight && activeEndIndex != -1  && 
					splitLaneOptions.length > 0 && !splitLaneOptions[0].contains(";") ) {
				activeEndIndex = Math.min(activeEndIndex, rawLanes.length - 1);
			}
			if (activeBeginIndex == -1 || activeEndIndex == -1 || activeBeginIndex > activeEndIndex) {
				// something went wrong
				return createSimpleKeepLeftRightTurn(leftSide, prevSegm, currentSegm, rs);
			}
			for (int k = 0; k < rawLanes.length; k++) {
				if (k >= activeBeginIndex && k <= activeEndIndex) {
					rawLanes[k] |= 1;
				}
			}
			int tp = inferSlightTurnFromLanes(rawLanes, rs);
			if (tp != t.getValue() && tp != 0) {
				t = TurnType.valueOf(tp, leftSide);
			}
		} else {
			for (int k = 0; k < rawLanes.length; k++) {
				int turn = TurnType.getPrimaryTurn(rawLanes[k]);
				int sturn = TurnType.getSecondaryTurn(rawLanes[k]);
				int tturn = TurnType.getTertiaryTurn(rawLanes[k]);
				
				boolean active = false;
				// some turns go through many segments (to turn right or left)
				// so on one first segment the lane could be available and may be only 1 possible
				// all undesired lanes will be disabled through the 2nd pass
				if((TurnType.isRightTurn(sturn) && possiblyRightTurn) ||
						(TurnType.isLeftTurn(sturn) && possiblyLeftTurn)) {
					// we can't predict here whether it will be a left turn or straight on, 
					// it could be done during 2nd pass
					TurnType.setPrimaryTurn(rawLanes, k, sturn);
					TurnType.setSecondaryTurn(rawLanes, k, turn);
					active = true;
				} else if((TurnType.isRightTurn(tturn) && possiblyRightTurn) ||
						(TurnType.isLeftTurn(tturn) && possiblyLeftTurn)) {
					TurnType.setPrimaryTurn(rawLanes, k, tturn);
					TurnType.setTertiaryTurn(rawLanes, k, turn);
					active = true;
				} else if((TurnType.isRightTurn(turn) && possiblyRightTurn) ||
						(TurnType.isLeftTurn(turn) && possiblyLeftTurn)) {
					active = true;
				} else if (turn == TurnType.C) {
					active = true;
				}
				if (active) {
					rawLanes[k] |= 1;
				}
			}
		}
		t.setSkipToSpeak(!rs.speak);
		t.setLanes(rawLanes);
		return t;
	}

	protected int findActiveIndex(int[] rawLanes, String[] splitLaneOptions, int lanes, boolean left, 
			List<int[]> lanesInfo, int roads, int addRoads) {
		int activeStartIndex = -1;
		boolean lookupSlightTurn = addRoads > 0;
		TIntHashSet addedTurns = new TIntHashSet();
		// if we have information increase number of roads per each turn direction
		int diffTurnRoads = roads;
		int increaseTurnRoads = 0;
		for(int[] li : lanesInfo) {
			TIntHashSet set = new TIntHashSet();
			if(li != null) {
				for(int k = 0; k < li.length; k++) {
					TurnType.collectTurnTypes(li[k], set);
				}
			}
			increaseTurnRoads = Math.max(set.size() - 1, 0);
		}
		
		for (int i = 0; i < rawLanes.length; i++) {
			int ind = left ? i : (rawLanes.length - i - 1);
			if (!lookupSlightTurn ||
					TurnType.hasAnySlightTurnLane(rawLanes[ind])) {
				String[] laneTurns = splitLaneOptions[ind].split(";");
				int cnt = 0;
				for(String lTurn : laneTurns) {
					boolean added = addedTurns.add(TurnType.convertType(lTurn));
					if(added) {
						cnt++;
						diffTurnRoads --;
					}
				}
				lanes -= cnt;
				//lanes--;
				// we already found slight turn others are turn in different direction
				lookupSlightTurn = false;
			}
			if (lanes < 0 || diffTurnRoads + increaseTurnRoads < 0) {
				activeStartIndex = ind;
				break;
			} else if(diffTurnRoads < 0 && activeStartIndex < 0) {
				activeStartIndex = ind;
			}
		}
		return activeStartIndex;
	}

	protected RoadSplitStructure calculateRoadSplitStructure(RouteSegmentResult prevSegm, RouteSegmentResult currentSegm,
			List<RouteSegmentResult> attachedRoutes) {
		RoadSplitStructure rs = new RoadSplitStructure();
		int speakPriority = Math.max(highwaySpeakPriority(prevSegm.getObject().getHighway()), highwaySpeakPriority(currentSegm.getObject().getHighway()));
		for (RouteSegmentResult attached : attachedRoutes) {
			boolean restricted = false;
			for(int k = 0; k < prevSegm.getObject().getRestrictionLength(); k++) {
				if(prevSegm.getObject().getRestrictionId(k) == attached.getObject().getId() && 
						prevSegm.getObject().getRestrictionType(k) <= MapRenderingTypes.RESTRICTION_NO_STRAIGHT_ON) {
					restricted = true;
					break;
				}
			}
			if(restricted) {
				continue;
			}
			double ex = MapUtils.degreesDiff(attached.getBearingBegin(), currentSegm.getBearingBegin());
			double mpi = Math.abs(MapUtils.degreesDiff(prevSegm.getBearingEnd(), attached.getBearingBegin()));
			int rsSpeakPriority = highwaySpeakPriority(attached.getObject().getHighway());
			int lanes = countLanesMinOne(attached);
			int[] turnLanes = parseTurnLanes(attached.getObject(), attached.getBearingBegin() * Math.PI / 180);
			boolean smallStraightVariation = mpi < TURN_DEGREE_MIN;
			boolean smallTargetVariation = Math.abs(ex) < TURN_DEGREE_MIN;
			boolean attachedOnTheRight = ex >= 0;
			if (attachedOnTheRight) {
				rs.roadsOnRight++;
			} else {
				rs.roadsOnLeft++;
			}
			if (rsSpeakPriority != MAX_SPEAK_PRIORITY || speakPriority == MAX_SPEAK_PRIORITY) {
				if (smallTargetVariation || smallStraightVariation) {
					if (attachedOnTheRight) {
						rs.keepLeft = true;
						rs.rightLanes += lanes;
						if(turnLanes != null) {
							rs.rightLanesInfo.add(turnLanes);
						}
					} else {
						rs.keepRight = true;
						rs.leftLanes += lanes;
						if(turnLanes != null) {
							rs.leftLanesInfo.add(turnLanes);
						}
					}
					rs.speak = rs.speak || rsSpeakPriority <= speakPriority;
				} else {
					if (attachedOnTheRight) {
						rs.addRoadsOnRight++;
					} else {
						rs.addRoadsOnLeft++;
					}
				}
			}
		}
		return rs;
	}

	protected TurnType createSimpleKeepLeftRightTurn(boolean leftSide, RouteSegmentResult prevSegm,
			RouteSegmentResult currentSegm, RoadSplitStructure rs) {
		int current = countLanesMinOne(currentSegm);
		int ls = current + rs.leftLanes + rs.rightLanes;
		int[] lanes = new int[ls];
		for (int it = 0; it < ls; it++) {
			if (it < rs.leftLanes || it >= rs.leftLanes + current) {
				lanes[it] = 0;
			} else {
				lanes[it] = 1;
			}
		}
		// sometimes links are
		if ((current <= rs.leftLanes + rs.rightLanes) && (rs.leftLanes > 1 || rs.rightLanes > 1)) {
			rs.speak = true;
		}
		double devation = Math.abs(MapUtils.degreesDiff(prevSegm.getBearingEnd(), currentSegm.getBearingBegin()));
		boolean makeSlightTurn = devation > 5 && (!isMotorway(prevSegm) || !isMotorway(currentSegm));
		TurnType t = null;
		if (rs.keepLeft && rs.keepRight) {
			t = TurnType.valueOf(TurnType.C, leftSide);
		} else if (rs.keepLeft) {
			t = TurnType.valueOf(makeSlightTurn ? TurnType.TSLL : TurnType.KL, leftSide);
		} else if (rs.keepRight) {
			t = TurnType.valueOf(makeSlightTurn ? TurnType.TSLR : TurnType.KR, leftSide);
		} else {
			return t;
		}
		t.setSkipToSpeak(!rs.speak);
		t.setLanes(lanes);
		return t;
	}

	
	protected int countLanesMinOne(RouteSegmentResult attached) {
		final boolean oneway = attached.getObject().getOneway() != 0;
		int lns = attached.getObject().getLanes();
		if(lns == 0) {
			String tls = getTurnLanesString(attached);
			if(tls != null) {
				return Math.max(1, countOccurrences(tls, '|'));
			}
		}
		if (oneway) {
			return Math.max(1, lns);
		}
		try {
			if (attached.isForwardDirection() && attached.getObject().getValue("lanes:forward") != null) {
				return Integer.parseInt(attached.getObject().getValue("lanes:forward"));
			} else if (!attached.isForwardDirection() && attached.getObject().getValue("lanes:backward") != null) {
				return Integer.parseInt(attached.getObject().getValue("lanes:backward"));
			}
		} catch(NumberFormatException e) {
			e.printStackTrace();
		}
		return Math.max(1, (lns + 1) / 2);
	}

	protected static String getTurnLanesString(RouteSegmentResult segment) {
		if (segment.getObject().getOneway() == 0) {
			if (segment.isForwardDirection()) {
				return segment.getObject().getValue("turn:lanes:forward");
			} else {
				return segment.getObject().getValue("turn:lanes:backward");
			}
		} else {
			return segment.getObject().getValue("turn:lanes");
		}
	}

	

	private int countOccurrences(String haystack, char needle) {
	    int count = 0;
		for (int i = 0; i < haystack.length(); i++) {
			if (haystack.charAt(i) == needle) {
				count++;
			}
		}
		return count;
	}

	public static int[] parseTurnLanes(RouteDataObject ro, double dirToNorthEastPi) {
		String turnLanes = null;
		if (ro.getOneway() == 0) {
			// we should get direction to detect forward or backward
			double cmp = ro.directionRoute(0, true);
			if(Math.abs(MapUtils.alignAngleDifference(dirToNorthEastPi -cmp)) < Math.PI / 2) {
				turnLanes = ro.getValue("turn:lanes:forward");
			} else {
				turnLanes = ro.getValue("turn:lanes:backward");
			}
		} else {
			turnLanes = ro.getValue("turn:lanes");
		}
		if(turnLanes == null) {
			return null;
		}
		return calculateRawTurnLanes(turnLanes, 0);
	}
	
	public static int[] parseLanes(RouteDataObject ro, double dirToNorthEastPi) {
		int lns = 0;
		try {
			if (ro.getOneway() == 0) {
				// we should get direction to detect forward or backward
				double cmp = ro.directionRoute(0, true);
				
				if(Math.abs(MapUtils.alignAngleDifference(dirToNorthEastPi -cmp)) < Math.PI / 2) {
					if(ro.getValue("lanes:forward") != null) {
						lns = Integer.parseInt(ro.getValue("lanes:forward"));
					}
				} else {
					if(ro.getValue("lanes:backward") != null) {
					lns = Integer.parseInt(ro.getValue("lanes:backward"));
					}
				}
				if (lns == 0 && ro.getValue("lanes") != null) {
					lns = Integer.parseInt(ro.getValue("lanes")) / 2;
				}
			} else {
				lns = Integer.parseInt(ro.getValue("lanes"));
			}
			if(lns > 0 ) {
				return new int[lns];
			}
		} catch (NumberFormatException e) {
		}
		return null;
	}
	
	private static int[] calculateRawTurnLanes(String turnLanes, int calcTurnType) {
		String[] splitLaneOptions = turnLanes.split("\\|", -1);
		int[] lanes = new int[splitLaneOptions.length];
		for (int i = 0; i < splitLaneOptions.length; i++) {
			String[] laneOptions = splitLaneOptions[i].split(";");
			boolean isTertiaryTurn = false;
			for (int j = 0; j < laneOptions.length; j++) {
				int turn = TurnType.convertType(laneOptions[j]);

				final int primary = TurnType.getPrimaryTurn(lanes[i]);
				if (primary == 0) {
					TurnType.setPrimaryTurnAndReset(lanes, i, turn);
				} else {
                    if (turn == calcTurnType || 
                    	(TurnType.isRightTurn(calcTurnType) && TurnType.isRightTurn(turn)) || 
                    	(TurnType.isLeftTurn(calcTurnType) && TurnType.isLeftTurn(turn)) 
                    	) {
                    	TurnType.setPrimaryTurnShiftOthers(lanes, i, turn);
                    } else if (!isTertiaryTurn) {
                    	TurnType.setSecondaryTurnShiftOthers(lanes, i, turn);
						isTertiaryTurn = true;
                    } else {
						TurnType.setTertiaryTurn(lanes, i, turn);
						break;
                    }
				}
			}
		}
		return lanes;
	}

	private int inferSlightTurnFromLanes(int[] oLanes, RoadSplitStructure rs) {
		TIntHashSet possibleTurns = new TIntHashSet();
		for (int i = 0; i < oLanes.length; i++) {
			if ((oLanes[i] & 1) == 0) {
				continue;
			}
			if (possibleTurns.isEmpty()) {
				// Nothing is in the list to compare to, so add the first elements
				possibleTurns.add(TurnType.getPrimaryTurn(oLanes[i]));
				if (TurnType.getSecondaryTurn(oLanes[i]) != 0) {
					possibleTurns.add(TurnType.getSecondaryTurn(oLanes[i]));
				}
				if (TurnType.getTertiaryTurn(oLanes[i]) != 0) {
					possibleTurns.add(TurnType.getTertiaryTurn(oLanes[i]));
				}
			} else {
				TIntArrayList laneTurns = new TIntArrayList();
				laneTurns.add(TurnType.getPrimaryTurn(oLanes[i]));
				if (TurnType.getSecondaryTurn(oLanes[i]) != 0) {
					laneTurns.add(TurnType.getSecondaryTurn(oLanes[i]));
				}
				if (TurnType.getTertiaryTurn(oLanes[i]) != 0) {
					laneTurns.add(TurnType.getTertiaryTurn(oLanes[i]));
				}
				possibleTurns.retainAll(laneTurns);
				if (possibleTurns.isEmpty()) {
					// No common turns, so can't determine anything.
					return 0;
				}
			}
		}

		// Remove all turns from lanes not selected...because those aren't it
		for (int i = 0; i < oLanes.length; i++) {
			if ((oLanes[i] & 1) == 0 && !possibleTurns.isEmpty()) {
				possibleTurns.remove((Integer) TurnType.getPrimaryTurn(oLanes[i]));
				if (TurnType.getSecondaryTurn(oLanes[i]) != 0) {
					possibleTurns.remove((Integer) TurnType.getSecondaryTurn(oLanes[i]));
				}
				if (TurnType.getTertiaryTurn(oLanes[i]) != 0) {
					possibleTurns.remove((Integer) TurnType.getTertiaryTurn(oLanes[i]));
				}
			}
		}
		// remove all non-slight turns // TEST don't pass 
//		if(possibleTurns.size() > 1) {
//			TIntIterator it = possibleTurns.iterator();
//			while(it.hasNext()) {
//				int nxt = it.next();
//				if(!TurnType.isSlightTurn(nxt)) {
//					it.remove();
//				}
//			}
//		}
		int infer = 0;
		if (possibleTurns.size() == 1) {
			infer = possibleTurns.iterator().next();
		} else if (possibleTurns.size() > 1) {
			if (rs.keepLeft && rs.keepRight && possibleTurns.contains(TurnType.C)) {
				infer = TurnType.C;
			} else if (rs.keepLeft || rs.keepRight) {
				TIntIterator it = possibleTurns.iterator();
				infer = it.next();
				while(it.hasNext()) {
					int next = it.next();
					int orderInfer = TurnType.orderFromLeftToRight(infer);
					int orderNext = TurnType.orderFromLeftToRight(next) ;
					if(rs.keepLeft && orderNext < orderInfer) {
						infer = next;
					} else if(rs.keepRight && orderNext > orderInfer) {
						infer = next;
					}
				}
			}
		}

		// Checking to see that there is only one unique turn
		if (infer != 0) {
			for(int i = 0; i < oLanes.length; i++) {
				if(TurnType.getSecondaryTurn(oLanes[i]) == infer) {
					int pt = TurnType.getPrimaryTurn(oLanes[i]);
					int en = oLanes[i] & 1;
					TurnType.setPrimaryTurnAndReset(oLanes, i, infer);
					oLanes[i] |= en;
					TurnType.setSecondaryTurn(oLanes, i, pt);
				}
				
			}
		}
		return infer;
	}

	private boolean isMotorway(RouteSegmentResult s){
		String h = s.getObject().getHighway();
		return "motorway".equals(h) || "motorway_link".equals(h)  ||
				"trunk".equals(h) || "trunk_link".equals(h);
		
	}

	
	private void attachRoadSegments(RoutingContext ctx, List<RouteSegmentResult> result, int routeInd, int pointInd, boolean plus) throws IOException {
		RouteSegmentResult rr = result.get(routeInd);
		RouteDataObject road = rr.getObject();
		long nextL = pointInd < road.getPointsLength() - 1 ? getPoint(road, pointInd + 1) : 0;
		long prevL = pointInd > 0 ? getPoint(road, pointInd - 1) : 0;
		
		// attach additional roads to represent more information about the route
		RouteSegmentResult previousResult = null;
		
		// by default make same as this road id
		long previousRoadId = road.getId();
		if (pointInd == rr.getStartPointIndex() && routeInd > 0) {
			previousResult = result.get(routeInd - 1);
			previousRoadId = previousResult.getObject().getId();
			if (previousRoadId != road.getId()) {
				if (previousResult.getStartPointIndex() < previousResult.getEndPointIndex()
						&& previousResult.getEndPointIndex() < previousResult.getObject().getPointsLength() - 1) {
					rr.attachRoute(pointInd, new RouteSegmentResult(previousResult.getObject(), previousResult.getEndPointIndex(),
							previousResult.getObject().getPointsLength() - 1));
				} else if (previousResult.getStartPointIndex() > previousResult.getEndPointIndex() 
						&& previousResult.getEndPointIndex() > 0) {
					rr.attachRoute(pointInd, new RouteSegmentResult(previousResult.getObject(), previousResult.getEndPointIndex(), 0));
				}
			}
		}
		Iterator<RouteSegment> it;
		if(rr.getPreAttachedRoutes(pointInd) != null) {
			final RouteSegmentResult[] list = rr.getPreAttachedRoutes(pointInd);
			it = new Iterator<BinaryRoutePlanner.RouteSegment>() {
				int i = 0;
				@Override
				public boolean hasNext() {
					return i < list.length;
				}

				@Override
				public RouteSegment next() {
					RouteSegmentResult r = list[i++];
					return new RouteSegment(r.getObject(), r.getStartPointIndex());
				}

				@Override
				public void remove() {
				}
			};	
		} else {
			RouteSegment rt = ctx.loadRouteSegment(road.getPoint31XTile(pointInd), road.getPoint31YTile(pointInd), ctx.config.memoryLimitation);
			it = rt == null ? null : rt.getIterator();
		}
		// try to attach all segments except with current id
		while (it != null && it.hasNext()) {
			RouteSegment routeSegment = it.next();
			if (routeSegment.road.getId() != road.getId() && routeSegment.road.getId() != previousRoadId) {
				RouteDataObject addRoad = routeSegment.road;
				checkAndInitRouteRegion(ctx, addRoad);
				// TODO restrictions can be considered as well
				int oneWay = ctx.getRouter().isOneWay(addRoad);
				if (oneWay >= 0 && routeSegment.getSegmentStart() < addRoad.getPointsLength() - 1) {
					long pointL = getPoint(addRoad, routeSegment.getSegmentStart() + 1);
					if(pointL != nextL && pointL != prevL) {
						// if way contains same segment (nodes) as different way (do not attach it)
						rr.attachRoute(pointInd, new RouteSegmentResult(addRoad, routeSegment.getSegmentStart(), addRoad.getPointsLength() - 1));
					}
				}
				if (oneWay <= 0 && routeSegment.getSegmentStart() > 0) {
					long pointL = getPoint(addRoad, routeSegment.getSegmentStart() - 1);
					// if way contains same segment (nodes) as different way (do not attach it)
					if(pointL != nextL && pointL != prevL) {
						rr.attachRoute(pointInd, new RouteSegmentResult(addRoad, routeSegment.getSegmentStart(), 0));
					}
				}
			}
		}
	}
	
	private static void println(String logMsg) {
//		log.info(logMsg);
		System.out.println(logMsg);
	}
	
	private long getPoint(RouteDataObject road, int pointInd) {
		return (((long) road.getPoint31XTile(pointInd)) << 31) + (long) road.getPoint31YTile(pointInd);
	}
	
	private static double measuredDist(int x1, int y1, int x2, int y2) {
		return MapUtils.getDistance(MapUtils.get31LatitudeY(y1), MapUtils.get31LongitudeX(x1), 
				MapUtils.get31LatitudeY(y2), MapUtils.get31LongitudeX(x2));
	}
}
!@#$%
20190530_075524,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_c08792
package net.osmand.router;

import gnu.trove.iterator.TIntIterator;
import gnu.trove.list.array.TIntArrayList;
import gnu.trove.set.hash.TIntHashSet;

import java.io.FileWriter;
import java.io.IOException;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import net.osmand.PlatformUtil;
import net.osmand.binary.BinaryMapIndexReader;
import net.osmand.binary.BinaryMapRouteReaderAdapter.RouteTypeRule;
import net.osmand.binary.RouteDataObject;
import net.osmand.data.LatLon;
import net.osmand.osm.MapRenderingTypes;
import net.osmand.router.BinaryRoutePlanner.FinalRouteSegment;
import net.osmand.router.BinaryRoutePlanner.RouteSegment;
import net.osmand.router.GeneralRouter.GeneralRouterProfile;
import net.osmand.router.RoutePlannerFrontEnd.RouteCalculationMode;
import net.osmand.util.Algorithms;
import net.osmand.util.MapAlgorithms;
import net.osmand.util.MapUtils;

import org.apache.commons.logging.Log;

public class RouteResultPreparation {

	public static boolean PRINT_TO_CONSOLE_ROUTE_INFORMATION_TO_TEST = false;
	public static String PRINT_TO_GPX_FILE = null;
	private static final float TURN_DEGREE_MIN = 45;
	public static final int SHIFT_ID = 6;
	private Log log = PlatformUtil.getLog(RouteResultPreparation.class);
	/**
	 * Helper method to prepare final result 
	 */
	List<RouteSegmentResult> prepareResult(RoutingContext ctx, FinalRouteSegment finalSegment) throws IOException {
		List<RouteSegmentResult> result  = convertFinalSegmentToResults(ctx, finalSegment);
		prepareResult(ctx, result);
		return result;
	}
	
	private static class CombineAreaRoutePoint {
		int x31;
		int y31;
		int originalIndex;
	}

	private void combineWayPointsForAreaRouting(RoutingContext ctx, List<RouteSegmentResult> result) {
		for(int i = 0; i < result.size(); i++) {
			RouteSegmentResult rsr = result.get(i);
			RouteDataObject obj = rsr.getObject();
			boolean area = false;
			if(obj.getPoint31XTile(0) == obj.getPoint31XTile(obj.getPointsLength() - 1) &&
					obj.getPoint31YTile(0) == obj.getPoint31YTile(obj.getPointsLength() - 1)) {
				area = true;
			}
			if(!area || !ctx.getRouter().isArea(obj)) {
				continue;
			}
			List<CombineAreaRoutePoint> originalWay = new ArrayList<CombineAreaRoutePoint>();
			List<CombineAreaRoutePoint> routeWay = new ArrayList<CombineAreaRoutePoint>();
			for(int j = 0;  j < obj.getPointsLength(); j++) {
				CombineAreaRoutePoint pnt = new CombineAreaRoutePoint();
				pnt.x31 = obj.getPoint31XTile(j);
				pnt.y31 = obj.getPoint31YTile(j);
				pnt.originalIndex = j;
				
				originalWay.add(pnt);
				if(j >= rsr.getStartPointIndex() && j <= rsr.getEndPointIndex()) {
					routeWay.add(pnt);
				} else if(j <= rsr.getStartPointIndex() && j >= rsr.getEndPointIndex()) {
					routeWay.add(0, pnt);
				}
			}
			int originalSize = routeWay.size();
			simplifyAreaRouteWay(routeWay, originalWay);
			int newsize = routeWay.size();
			if (routeWay.size() != originalSize) {
				RouteDataObject nobj = new RouteDataObject(obj);
				nobj.pointsX = new int[newsize];
				nobj.pointsY = new int[newsize];
				for (int k = 0; k < newsize; k++) {
					nobj.pointsX[k] = routeWay.get(k).x31;
					nobj.pointsY[k] = routeWay.get(k).y31;
				}
				// in future point names might be used
				nobj.restrictions = null;
				nobj.restrictionsVia = null;
				nobj.pointTypes = null;
				nobj.pointNames = null;
				nobj.pointNameTypes = null;
				RouteSegmentResult nrsr = new RouteSegmentResult(nobj, 0, newsize - 1);
				result.set(i, nrsr);
			}
		}
	}

	private void simplifyAreaRouteWay(List<CombineAreaRoutePoint> routeWay, List<CombineAreaRoutePoint> originalWay) {
		boolean changed = true;
		while (changed) {
			changed = false;
			int connectStart = -1;
			int connectLen = 0;
			double dist = 0;
			int length = routeWay.size() - 1;
			while (length > 0 && connectLen == 0) {
				for (int i = 0; i < routeWay.size() - length; i++) {
					CombineAreaRoutePoint p = routeWay.get(i);
					CombineAreaRoutePoint n = routeWay.get(i + length);
					if (segmentLineBelongsToPolygon(p, n, originalWay)) {
						double ndist = BinaryRoutePlanner.squareRootDist(p.x31, p.y31, n.x31, n.y31);
						if (ndist > dist) {
							ndist = dist;
							connectStart = i;
							connectLen = length;
						}
					}
				}
				length--;
			}
			while (connectLen > 1) {
				routeWay.remove(connectStart + 1);
				connectLen--;
				changed = true;
			}
		}
		
	}

	private boolean segmentLineBelongsToPolygon(CombineAreaRoutePoint p, CombineAreaRoutePoint n,
			List<CombineAreaRoutePoint> originalWay) {
		int intersections = 0;
		int mx = p.x31 / 2 + n.x31 / 2;
		int my = p.y31 / 2 + n.y31 / 2;
		for(int i = 1; i < originalWay.size(); i++) {
			CombineAreaRoutePoint p2 = originalWay.get(i -1);
			CombineAreaRoutePoint n2 = originalWay.get(i);
			if(p.originalIndex != i && p.originalIndex != i - 1) {
				if(n.originalIndex != i && n.originalIndex != i - 1) {
					if(MapAlgorithms.linesIntersect(p.x31, p.y31, n.x31, n.y31, p2.x31, p2.y31, n2.x31, n2.y31)) {
						return false;
					}
				}
			}
			int fx = MapAlgorithms.ray_intersect_x(p2.x31, p2.y31, n2.x31, n2.y31, my);
			if (Integer.MIN_VALUE != fx && mx >= fx) {
				intersections++;
			}
		}
		return intersections % 2 == 1;
	}

	List<RouteSegmentResult> prepareResult(RoutingContext ctx, List<RouteSegmentResult> result) throws IOException {
		combineWayPointsForAreaRouting(ctx, result);
		validateAllPointsConnected(result);
		splitRoadsAndAttachRoadSegments(ctx, result);
		calculateTimeSpeed(ctx, result);
		
		for (int i = 0; i < result.size(); i ++) {
			TurnType turnType = getTurnInfo(result, i, ctx.leftSideNavigation);
			result.get(i).setTurnType(turnType);
		}
		
		determineTurnsToMerge(ctx.leftSideNavigation, result);
		ignorePrecedingStraightsOnSameIntersection(ctx.leftSideNavigation, result);
		justifyUTurns(ctx.leftSideNavigation, result);
		addTurnInfoDescriptions(result);
		return result;
	}

	protected void ignorePrecedingStraightsOnSameIntersection(boolean leftside, List<RouteSegmentResult> result) {
		//Issue 2571: Ignore TurnType.C if immediately followed by another turn in non-motorway cases, as these likely belong to the very same intersection
		RouteSegmentResult nextSegment = null;
		double distanceToNextTurn = 999999;
		for (int i = result.size() - 1; i >= 0; i--) {
			// Mark next "real" turn
			if (nextSegment != null && nextSegment.getTurnType() != null &&
					nextSegment.getTurnType().getValue() != TurnType.C &&
					!isMotorway(nextSegment)) {
				if (distanceToNextTurn == 999999) {
					distanceToNextTurn = 0;
				}
			}
			RouteSegmentResult currentSegment = result.get(i);
			// Identify preceding goStraights within distance limit and suppress
			if (currentSegment != null) {
				distanceToNextTurn += currentSegment.getDistance();
				if (currentSegment.getTurnType() != null &&
						currentSegment.getTurnType().getValue() == TurnType.C &&
						distanceToNextTurn <= 100) {
					result.get(i).getTurnType().setSkipToSpeak(true);
				} else {
					nextSegment = currentSegment;
					distanceToNextTurn = 999999;
				}
			}
		}
	}

	private void justifyUTurns(boolean leftSide, List<RouteSegmentResult> result) {
		int next;
		for (int i = 0; i < result.size() - 1; i = next) {
			next = i + 1;
			TurnType t = result.get(i).getTurnType();
			// justify turn
			if (t != null) {
				TurnType jt = justifyUTurn(leftSide, result, i, t);
				if (jt != null) {
					result.get(i).setTurnType(jt);
					next = i + 2;
				}
			}
		}
	}

	private void calculateTimeSpeed(RoutingContext ctx, List<RouteSegmentResult> result) throws IOException {
		//for Naismith
		boolean usePedestrianHeight = ((((GeneralRouter) ctx.getRouter()).getProfile() == GeneralRouterProfile.PEDESTRIAN) && ((GeneralRouter) ctx.getRouter()).getHeightObstacles());

		for (int i = 0; i < result.size(); i++) {
			RouteSegmentResult rr = result.get(i);
			RouteDataObject road = rr.getObject();
			double distOnRoadToPass = 0;
			double speed = ctx.getRouter().defineVehicleSpeed(road);
			if (speed == 0) {
				speed = ctx.getRouter().getMinDefaultSpeed();
			} else {
				if(speed > 15) {
					// decrease speed proportionally from 15ms=50kmh - 
					// reference speed 30ms=108kmh - 7kmh
					speed = speed - ((speed - 15f) / (30f - 15f) * 2f);
				}
			}
			boolean plus = rr.getStartPointIndex() < rr.getEndPointIndex();
			int next;
			double distance = 0;

			//for Naismith
			float prevHeight = -99999.0f;
			float[] heightDistanceArray = null;
			if (usePedestrianHeight) {
				road.calculateHeightArray();
				heightDistanceArray = road.heightDistanceArray;
			}

			for (int j = rr.getStartPointIndex(); j != rr.getEndPointIndex(); j = next) {
				next = plus ? j + 1 : j - 1;
				double d = measuredDist(road.getPoint31XTile(j), road.getPoint31YTile(j), road.getPoint31XTile(next),
						road.getPoint31YTile(next));
				distance += d;
				double obstacle = ctx.getRouter().defineObstacle(road, j);
				if (obstacle < 0) {
					obstacle = 0;
				}
				distOnRoadToPass += d / speed + obstacle;  //this is time in seconds

				//for Naismith
				if (usePedestrianHeight) {
					int heightIndex = 2 * j + 1;
					if (heightDistanceArray != null && heightIndex < heightDistanceArray.length) {
						float height = heightDistanceArray[heightIndex];
						if (prevHeight != -99999.0f) {
							float heightDiff = height - prevHeight;
							if (heightDiff > 0) {  //ascent only
								distOnRoadToPass += heightDiff * 6.0f;  //Naismith's rule: add 1 hour per every 600m of ascent
							}
						}
					prevHeight = height;
					}
				}
			}

			// last point turn time can be added
			// if(i + 1 < result.size()) { distOnRoadToPass += ctx.getRouter().calculateTurnTime(); }
			rr.setSegmentTime((float) distOnRoadToPass);
			rr.setSegmentSpeed((float) speed);
			rr.setDistance((float) distance);
		}
	}

	private void splitRoadsAndAttachRoadSegments(RoutingContext ctx, List<RouteSegmentResult> result) throws IOException {
		for (int i = 0; i < result.size(); i++) {
			if (ctx.checkIfMemoryLimitCritical(ctx.config.memoryLimitation)) {
				ctx.unloadUnusedTiles(ctx.config.memoryLimitation);
			}
			RouteSegmentResult rr = result.get(i);
			RouteDataObject road = rr.getObject();
			checkAndInitRouteRegion(ctx, road);
			boolean plus = rr.getStartPointIndex() < rr.getEndPointIndex();
			int next;
			for (int j = rr.getStartPointIndex(); j != rr.getEndPointIndex(); j = next) {
				next = plus ? j + 1 : j - 1;
				if (j == rr.getStartPointIndex()) {
					attachRoadSegments(ctx, result, i, j, plus);
				}
				if (next != rr.getEndPointIndex()) {
					attachRoadSegments(ctx, result, i, next, plus);
				}
				List<RouteSegmentResult> attachedRoutes = rr.getAttachedRoutes(next);
				boolean tryToSplit = next != rr.getEndPointIndex() && !rr.getObject().roundabout() && attachedRoutes != null;
				if(rr.getDistance(next, plus ) == 0) {
					// same point will be processed next step
					tryToSplit = false;
				}
				if (tryToSplit) {
					// avoid small zigzags
					float before = rr.getBearing(next, !plus);
					float after = rr.getBearing(next, plus);
					if(rr.getDistance(next, plus ) < 5) {
						after = before + 180;
					} else if(rr.getDistance(next, !plus ) < 5) {
						before = after - 180;
					}
					boolean straight = Math.abs(MapUtils.degreesDiff(before + 180, after)) < TURN_DEGREE_MIN;
					boolean isSplit = false;
					// split if needed
					for (RouteSegmentResult rs : attachedRoutes) {
						double diff = MapUtils.degreesDiff(before + 180, rs.getBearingBegin());
						if (Math.abs(diff) <= TURN_DEGREE_MIN) {
							isSplit = true;
						} else if (!straight && Math.abs(diff) < 100) {
							isSplit = true;
						}
					}
					if (isSplit) {
						int endPointIndex = rr.getEndPointIndex();
						RouteSegmentResult split = new RouteSegmentResult(rr.getObject(), next, endPointIndex);
						split.copyPreattachedRoutes(rr, Math.abs(next - rr.getStartPointIndex()));
						rr.setEndPointIndex(next);
						result.add(i + 1, split);
						i++;
						// switch current segment to the splitted
						rr = split;
					}
				}
			}
		}
	}

	private void checkAndInitRouteRegion(RoutingContext ctx, RouteDataObject road) throws IOException {
		BinaryMapIndexReader reader = ctx.reverseMap.get(road.region);
		if(reader != null) {
			reader.initRouteRegion(road.region);
		}
	}

	private void validateAllPointsConnected(List<RouteSegmentResult> result) {
		for (int i = 1; i < result.size(); i++) {
			RouteSegmentResult rr = result.get(i);
			RouteSegmentResult pr = result.get(i - 1);
			double d = MapUtils.getDistance(pr.getPoint(pr.getEndPointIndex()), rr.getPoint(rr.getStartPointIndex()));
			if (d > 0) {
				System.err.println("Points are not connected : " + pr.getObject() + "(" + pr.getEndPointIndex() + ") -> " + rr.getObject()
						+ "(" + rr.getStartPointIndex() + ") " + d + " meters");
			}
		}
	}

	private List<RouteSegmentResult> convertFinalSegmentToResults(RoutingContext ctx, FinalRouteSegment finalSegment) {
		List<RouteSegmentResult> result = new ArrayList<RouteSegmentResult>();
		if (finalSegment != null) {
			ctx.routingTime = finalSegment.distanceFromStart;
			println("Routing calculated time distance " + finalSegment.distanceFromStart);
			// Get results from opposite direction roads
			RouteSegment segment = finalSegment.reverseWaySearch ? finalSegment : 
				finalSegment.opposite.getParentRoute();
			int parentSegmentStart = finalSegment.reverseWaySearch ? finalSegment.opposite.getSegmentStart() : 
				finalSegment.opposite.getParentSegmentEnd();
			float parentRoutingTime = -1;
			while (segment != null) {
				RouteSegmentResult res = new RouteSegmentResult(segment.road, parentSegmentStart, segment.getSegmentStart());
				parentRoutingTime = calcRoutingTime(parentRoutingTime, finalSegment, segment, res);
				parentSegmentStart = segment.getParentSegmentEnd();
				segment = segment.getParentRoute();
				addRouteSegmentToResult(ctx, result, res, false);
			}
			// reverse it just to attach good direction roads
			Collections.reverse(result);

			segment = finalSegment.reverseWaySearch ? finalSegment.opposite.getParentRoute() : finalSegment;
			int parentSegmentEnd = finalSegment.reverseWaySearch ? finalSegment.opposite.getParentSegmentEnd() : finalSegment.opposite.getSegmentStart();
			parentRoutingTime = -1;
			while (segment != null) {
				RouteSegmentResult res = new RouteSegmentResult(segment.road, segment.getSegmentStart(), parentSegmentEnd);
				parentRoutingTime = calcRoutingTime(parentRoutingTime, finalSegment, segment, res);
				parentSegmentEnd = segment.getParentSegmentEnd();
				segment = segment.getParentRoute();
				// happens in smart recalculation
				addRouteSegmentToResult(ctx, result, res, true);
			}
			Collections.reverse(result);
			// checkTotalRoutingTime(result);
		}
		return result;
	}

	protected void checkTotalRoutingTime(List<RouteSegmentResult> result) {
		float totalRoutingTime = 0;
		for(RouteSegmentResult r : result) {
			totalRoutingTime += r.getRoutingTime();
		}
		println("Total routing time ! " + totalRoutingTime);
	}

	private float calcRoutingTime(float parentRoutingTime, RouteSegment finalSegment, RouteSegment segment,
			RouteSegmentResult res) {
		if(segment != finalSegment) {
			if(parentRoutingTime != -1) {
				res.setRoutingTime(parentRoutingTime - segment.distanceFromStart);
			}
			parentRoutingTime = segment.distanceFromStart;
		}
		return parentRoutingTime;
	}
	
	private void addRouteSegmentToResult(RoutingContext ctx, List<RouteSegmentResult> result, RouteSegmentResult res, boolean reverse) {
		if (res.getStartPointIndex() != res.getEndPointIndex()) {
			if (result.size() > 0) {
				RouteSegmentResult last = result.get(result.size() - 1);
				if (last.getObject().id == res.getObject().id && ctx.calculationMode != RouteCalculationMode.BASE) {
					if (combineTwoSegmentResult(res, last, reverse)) {
						return;
					}
				}
			}
			result.add(res);
		}
	}
	
	private boolean combineTwoSegmentResult(RouteSegmentResult toAdd, RouteSegmentResult previous, 
			boolean reverse) {
		boolean ld = previous.getEndPointIndex() > previous.getStartPointIndex();
		boolean rd = toAdd.getEndPointIndex() > toAdd.getStartPointIndex();
		if (rd == ld) {
			if (toAdd.getStartPointIndex() == previous.getEndPointIndex() && !reverse) {
				previous.setEndPointIndex(toAdd.getEndPointIndex());
				previous.setRoutingTime(previous.getRoutingTime() + toAdd.getRoutingTime());
				return true;
			} else if (toAdd.getEndPointIndex() == previous.getStartPointIndex() && reverse) {
				previous.setStartPointIndex(toAdd.getStartPointIndex());
				previous.setRoutingTime(previous.getRoutingTime() + toAdd.getRoutingTime());
				return true;
			}
		}
		return false;
	}
	
	void printResults(RoutingContext ctx, LatLon start, LatLon end, List<RouteSegmentResult> result) {
		float completeTime = 0;
		float completeDistance = 0;
		for(RouteSegmentResult r : result) {
			completeTime += r.getSegmentTime();
			completeDistance += r.getDistance();
		}

		println("ROUTE : ");
		double startLat = start.getLatitude();
		double startLon = start.getLongitude();
		double endLat = end.getLatitude();
		double endLon = end.getLongitude();
		
		String msg = String.format("<test regions=\"\" description=\"\" best_percent=\"\" vehicle=\"%s\" \n"
				+ "  start_lat=\"%.5f\" start_lon=\"%.5f\" target_lat=\"%.5f\" target_lon=\"%.5f\" "
				+ " routing_time=\"%.2f\" loadedTiles=\"%d\" visitedSegments=\"%d\" complete_distance=\"%.2f\" complete_time=\"%.2f\" >",
				ctx.config.routerName, startLat, startLon, endLat, endLon, ctx.routingTime, ctx.loadedTiles, 
				ctx.visitedSegments, completeDistance, completeTime);
//		String msg = MessageFormat.format("<test regions=\"\" description=\"\" best_percent=\"\" vehicle=\"{4}\" \n"
//				+ "    start_lat=\"{0}\" start_lon=\"{1}\" target_lat=\"{2}\" target_lon=\"{3}\" {5} >", 
//				startLat + "", startLon + "", endLat + "", endLon + "", ctx.config.routerName, 
//				"loadedTiles = \"" + ctx.loadedTiles + "\" " + "visitedSegments = \"" + ctx.visitedSegments + "\" " +
//				"complete_distance = \"" + completeDistance + "\" " + "complete_time = \"" + completeTime + "\" " +
//				"routing_time = \"" + ctx.routingTime + "\" ");
		log.info(msg);
        println(msg);
		if (PRINT_TO_CONSOLE_ROUTE_INFORMATION_TO_TEST) {
			org.xmlpull.v1.XmlSerializer serializer = null;
			if(PRINT_TO_GPX_FILE != null) {
				serializer = PlatformUtil.newSerializer();
				try {
					serializer.setOutput(new FileWriter(PRINT_TO_GPX_FILE));
					serializer.setFeature("http://xmlpull.org/v1/doc/features.html#indent-output", true);
					// indentation as 3 spaces
//					serializer.setProperty("http://xmlpull.org/v1/doc/properties.html#serializer-indentation", "   ");
//					// also set the line separator
//					serializer.setProperty("http://xmlpull.org/v1/doc/properties.html#serializer-line-separator", "\n");
					serializer.startDocument("UTF-8", true);
					serializer.startTag("", "gpx");
					serializer.attribute("", "version", "1.1");
					serializer.attribute("", "xmlns", "http://www.topografix.com/GPX/1/1");
					serializer.attribute("", "xmlns:xsi", "http://www.w3.org/2001/XMLSchema-instance");
					serializer.attribute("", "xmlns:schemaLocation", "http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd");
					serializer.startTag("", "trk");
					serializer.startTag("", "trkseg");
				} catch (IOException e) {
					e.printStackTrace();
					serializer = null;
				}
			}
					
			double lastHeight = -180;		
			for (RouteSegmentResult res : result) {
				String name = res.getObject().getName();
				String ref = res.getObject().getRef("", false, res.isForwardDirection());
				if (name == null) {
					name = "";
				}
				if (ref != null) {
					name += " (" + ref + ") ";
				}
				StringBuilder additional = new StringBuilder();
				additional.append("time = \"").append(res.getSegmentTime()).append("\" ");
				additional.append("rtime = \"").append(res.getRoutingTime()).append("\" ");
				additional.append("name = \"").append(name).append("\" ");
//				float ms = res.getSegmentSpeed();
				float ms = res.getObject().getMaximumSpeed(res.isForwardDirection());
				if(ms > 0) {
					additional.append("maxspeed = \"").append(ms * 3.6f).append("\" ").append(res.getObject().getHighway()).append(" ");
				}
				additional.append("distance = \"").append(res.getDistance()).append("\" ");
				if (res.getTurnType() != null) {
					additional.append("turn = \"").append(res.getTurnType()).append("\" ");
					additional.append("turn_angle = \"").append(res.getTurnType().getTurnAngle()).append("\" ");
					if (res.getTurnType().getLanes() != null) {
						additional.append("lanes = \"").append(Arrays.toString(res.getTurnType().getLanes())).append("\" ");
					}
				}
				additional.append("start_bearing = \"").append(res.getBearingBegin()).append("\" ");
				additional.append("end_bearing = \"").append(res.getBearingEnd()).append("\" ");
				additional.append("height = \"").append(Arrays.toString(res.getHeightValues())).append("\" ");
				additional.append("description = \"").append(res.getDescription()).append("\" ");
				println(MessageFormat.format("\t<segment id=\"{0}\" oid=\"{1}\" start=\"{2}\" end=\"{3}\" {4}/>",
						(res.getObject().getId() >> (SHIFT_ID )) + "", res.getObject().getId() + "", 
						res.getStartPointIndex() + "", res.getEndPointIndex() + "", additional.toString()));
				int inc = res.getStartPointIndex() < res.getEndPointIndex() ? 1 : -1;
				int indexnext = res.getStartPointIndex();
				LatLon prev = null;
				for (int index = res.getStartPointIndex() ; index != res.getEndPointIndex(); ) {
					index = indexnext;
					indexnext += inc; 
					if (serializer != null) {
						try {
							LatLon l = res.getPoint(index);
							serializer.startTag("","trkpt");
							serializer.attribute("", "lat",  l.getLatitude() + "");
							serializer.attribute("", "lon",  l.getLongitude() + "");
							float[] vls = res.getObject().heightDistanceArray;
							double dist = prev == null ? 0 : MapUtils.getDistance(prev, l);
							if(index * 2 + 1 < vls.length) {
								double h = vls[2*index + 1];
								serializer.startTag("","ele");
								serializer.text(h +"");
								serializer.endTag("","ele");
								if(lastHeight != -180 && dist > 0) {
									serializer.startTag("","cmt");
									serializer.text((float) ((h -lastHeight)/ dist*100) + "% " +
									" degree " + (float) Math.atan(((h -lastHeight)/ dist)) / Math.PI * 180 +  
									" asc " + (float) (h -lastHeight) + " dist "
											+ (float) dist);
									serializer.endTag("","cmt");
									serializer.startTag("","slope");
									serializer.text((h -lastHeight)/ dist*100 + "");
									serializer.endTag("","slope");
								}
								serializer.startTag("","desc");
								serializer.text((res.getObject().getId() >> (SHIFT_ID )) + " " + index);
								serializer.endTag("","desc");
								lastHeight = h;
							} else if(lastHeight != -180){
//								serializer.startTag("","ele");
//								serializer.text(lastHeight +"");
//								serializer.endTag("","ele");
							}
							serializer.endTag("", "trkpt");
							prev = l;
						} catch (IOException e) {
							e.printStackTrace();
						}
					}
				}
				printAdditionalPointInfo(res);
			}
			if(serializer != null) {
				try {
					serializer.endTag("", "trkseg");
					serializer.endTag("", "trk");
					serializer.endTag("", "gpx");
					serializer.endDocument();
					serializer.flush();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
		}
		println("</test>");
		println(msg);
	}

	private void printAdditionalPointInfo(RouteSegmentResult res) {
		boolean plus = res.getStartPointIndex() < res.getEndPointIndex();
		for(int k = res.getStartPointIndex(); k != res.getEndPointIndex(); ) {
			int[] tp = res.getObject().getPointTypes(k);
			String[] pointNames = res.getObject().getPointNames(k);
			int[] pointNameTypes = res.getObject().getPointNameTypes(k);
			if (tp != null || pointNameTypes != null) {
				StringBuilder bld = new StringBuilder();
				bld.append("<point " + (k));
				if (tp != null) {
					for (int t = 0; t < tp.length; t++) {
						RouteTypeRule rr = res.getObject().region.quickGetEncodingRule(tp[t]);
						bld.append(" " + rr.getTag() + "=\"" + rr.getValue() + "\"");
					}
				}
				if (pointNameTypes != null) {
					for (int t = 0; t < pointNameTypes.length; t++) {
						RouteTypeRule rr = res.getObject().region.quickGetEncodingRule(pointNameTypes[t]);
						bld.append(" " + rr.getTag() + "=\"" + pointNames[t] + "\"");
					}
				}
				bld.append("/>");
				println("\t"+bld.toString());
			}
			if(plus) {
				k++;
			} else {
				k--;
			}
		}
	}


	protected void addTurnInfoDescriptions(List<RouteSegmentResult> result) {
		int prevSegment = -1;
		float dist = 0;
		for (int i = 0; i <= result.size(); i++) {
			if (i == result.size() || result.get(i).getTurnType() != null) {
				if (prevSegment >= 0) {
					String turn = result.get(prevSegment).getTurnType().toString();
					result.get(prevSegment).setDescription(
							turn + MessageFormat.format(" and go {0,number,#.##} meters", dist));
					if (result.get(prevSegment).getTurnType().isSkipToSpeak()) {
						result.get(prevSegment).setDescription("-*" + result.get(prevSegment).getDescription());
					}
				}
				prevSegment = i;
				dist = 0;
			}
			if (i < result.size()) {
				dist += result.get(i).getDistance();
			}
		}
	}

	protected TurnType justifyUTurn(boolean leftside, List<RouteSegmentResult> result, int i, TurnType t) {
		boolean tl = TurnType.isLeftTurnNoUTurn(t.getValue());
		boolean tr = TurnType.isRightTurnNoUTurn(t.getValue());
		if(tl || tr) {
			TurnType tnext = result.get(i + 1).getTurnType();
			if (tnext != null && result.get(i).getDistance() < 50) { //
				boolean ut = true;
				if (i > 0) {
					double uTurn = MapUtils.degreesDiff(result.get(i - 1).getBearingEnd(), result
							.get(i + 1).getBearingBegin());
					if (Math.abs(uTurn) < 120) {
						ut = false;
					}
				}
//				String highway = result.get(i).getObject().getHighway();
//				if(highway == null || highway.endsWith("track") || highway.endsWith("services") || highway.endsWith("service")
//						|| highway.endsWith("path")) {
//					ut = false;
//				}
				if (result.get(i - 1).getObject().getOneway() == 0 || result.get(i + 1).getObject().getOneway() == 0) {
					ut = false;
				}
				if (!Algorithms.objectEquals(getStreetName(result, i - 1, false), 
						getStreetName(result, i + 1, true))) {
					ut = false;
				}
				if (ut) {
					tnext.setSkipToSpeak(true);
					if (tl && TurnType.isLeftTurnNoUTurn(tnext.getValue())) {
						TurnType tt = TurnType.valueOf(TurnType.TU, false);
						tt.setLanes(t.getLanes());
						return tt;
					} else if (tr && TurnType.isRightTurnNoUTurn(tnext.getValue())) {
						TurnType tt = TurnType.valueOf(TurnType.TU, true);
						tt.setLanes(t.getLanes());
						return tt;
					}
				}
			}
		}
		return null;
	}

	private String getStreetName(List<RouteSegmentResult> result, int i, boolean dir) {
		String nm = result.get(i).getObject().getName();
		if (Algorithms.isEmpty(nm)) {
			if (!dir) {
				if (i > 0) {
					nm = result.get(i - 1).getObject().getName();
				}
			} else {
				if(i < result.size() - 1) {
					nm = result.get(i + 1).getObject().getName();
				}
			}
		}
		
		return nm;
	}

	private void determineTurnsToMerge(boolean leftside, List<RouteSegmentResult> result) {
		RouteSegmentResult nextSegment = null;
		double dist = 0;
		for (int i = result.size() - 1; i >= 0; i--) {
			RouteSegmentResult currentSegment = result.get(i);
			TurnType currentTurn = currentSegment.getTurnType();
			dist += currentSegment.getDistance();
			if (currentTurn == null || currentTurn.getLanes() == null) {
				// skip
			} else {
				boolean merged = false;
				if (nextSegment != null) {
					String hw = currentSegment.getObject().getHighway();
					double mergeDistance = 200;
					if (hw != null && (hw.startsWith("trunk") || hw.startsWith("motorway"))) {
						mergeDistance = 400;
					}
					if (dist < mergeDistance) {
						mergeTurnLanes(leftside, currentSegment, nextSegment);
						inferCommonActiveLane(currentSegment.getTurnType(), nextSegment.getTurnType());
						merged = true;
					}
				}
				if (!merged) {
					TurnType tt = currentSegment.getTurnType();
					inferActiveTurnLanesFromTurn(tt, TurnType.C);
				}
				nextSegment = currentSegment;
				dist = 0;
			}
		}
	}

	private void inferActiveTurnLanesFromTurn(TurnType tt, int type) {
		boolean found = false;
		if (tt.getValue() == type && tt.getLanes() != null) {
			for (int it = 0; it < tt.getLanes().length; it++) {
				int turn = tt.getLanes()[it];
				if (TurnType.getPrimaryTurn(turn) == type ||
						TurnType.getSecondaryTurn(turn) == type ||
						TurnType.getTertiaryTurn(turn) == type) {
					found = true;
					break;
				}
			}
		}
		if(found) {
			for (int it = 0; it < tt.getLanes().length; it++) {
				int turn = tt.getLanes()[it];
				if (TurnType.getPrimaryTurn(turn) != type) {
					if(TurnType.getSecondaryTurn(turn) == type) {
						int st = TurnType.getSecondaryTurn(turn);
						TurnType.setSecondaryTurn(tt.getLanes(), it, TurnType.getPrimaryTurn(turn));
						TurnType.setPrimaryTurn(tt.getLanes(), it, st);
					} else if(TurnType.getTertiaryTurn(turn) == type) {
						int st = TurnType.getTertiaryTurn(turn);
						TurnType.setTertiaryTurn(tt.getLanes(), it, TurnType.getPrimaryTurn(turn));
						TurnType.setPrimaryTurn(tt.getLanes(), it, st);
					} else {
						tt.getLanes()[it] = turn & (~1);
					}
				}
			}
		}
	}
	
	private class MergeTurnLaneTurn {
		TurnType turn;
		int[] originalLanes;
		int[] disabledLanes;
		int activeStartIndex = -1;
		int activeEndIndex = -1;
		int activeLen = 0;
		
		public MergeTurnLaneTurn(RouteSegmentResult segment) {
			this.turn = segment.getTurnType();
			if(turn != null) {
				originalLanes = turn.getLanes();
			}
			if(originalLanes != null) {
				disabledLanes = new int[originalLanes.length];
				for (int i = 0; i < originalLanes.length; i++) {
					int ln = originalLanes[i];
					disabledLanes[i] = ln & ~1;
					if ((ln & 1) > 0) {
						if (activeStartIndex == -1) {
							activeStartIndex = i;
						}
						activeEndIndex = i;
						activeLen++;
					}
				}
			}
		}
		
		public boolean isActiveTurnMostLeft() {
			return activeStartIndex == 0;
		}
		public boolean isActiveTurnMostRight() {
			return activeEndIndex == originalLanes.length - 1;
		}
	}
	
	private boolean mergeTurnLanes(boolean leftSide, RouteSegmentResult currentSegment, RouteSegmentResult nextSegment) {
		MergeTurnLaneTurn active = new MergeTurnLaneTurn(currentSegment);
		MergeTurnLaneTurn target = new MergeTurnLaneTurn(nextSegment);
		if (active.activeLen < 2) {
			return false;
		}
		if (target.activeStartIndex == -1) {
			return false;
		}
		boolean changed = false;
		if (target.isActiveTurnMostLeft()) {
			// let only the most left lanes be enabled
			if (target.activeLen < active.activeLen) {
				active.activeEndIndex -= (active.activeLen - target.activeLen);
				changed = true;
			}
		} else if (target.isActiveTurnMostRight()) {
			// next turn is right
			// let only the most right lanes be enabled
			if (target.activeLen < active.activeLen ) {
				active.activeStartIndex += (active.activeLen - target.activeLen);
				changed = true;
			}
		} else {
			// next turn is get through (take out the left and the right turn)
			if (target.activeLen < active.activeLen) {
				if(target.originalLanes.length == active.activeLen) {
					active.activeEndIndex = active.activeStartIndex + target.activeEndIndex;
					active.activeStartIndex = active.activeStartIndex + target.activeStartIndex;
					changed = true;
				} else {
					int straightActiveLen = 0;
					int straightActiveBegin = -1;
					for(int i = active.activeStartIndex; i <= active.activeEndIndex; i++) {
						if(TurnType.hasAnyTurnLane(active.originalLanes[i], TurnType.C)) {
							straightActiveLen++;
							if(straightActiveBegin == -1) {
								straightActiveBegin = i;
							}
						}
					}
					if(straightActiveBegin != -1 && straightActiveLen <= target.activeLen) {
						active.activeStartIndex = straightActiveBegin;
						active.activeEndIndex = straightActiveBegin + straightActiveLen - 1;
						changed = true;
					} else {
						// cause the next-turn goes forward exclude left most and right most lane
						if (active.activeStartIndex == 0) {
							active.activeStartIndex++;
							active.activeLen--;
						}
						if (active.activeEndIndex == active.originalLanes.length - 1) {
							active.activeEndIndex--;
							active.activeLen--;
						}
						float ratio = (active.activeLen - target.activeLen) / 2f;
						if (ratio > 0) {
							active.activeEndIndex = (int) Math.ceil(active.activeEndIndex - ratio);
							active.activeStartIndex = (int) Math.floor(active.activeStartIndex + ratio);
						}
						changed = true;
					}
				}
			}
		}
		if (!changed) {
			return false;
		}

		// set the allowed lane bit
		for (int i = 0; i < active.disabledLanes.length; i++) {
			if (i >= active.activeStartIndex && i <= active.activeEndIndex && 
					active.originalLanes[i] % 2 == 1) {
				active.disabledLanes[i] |= 1;
			}
		}
		TurnType currentTurn = currentSegment.getTurnType();
		currentTurn.setLanes(active.disabledLanes);
		return true;
	}
	
	private void inferCommonActiveLane(TurnType currentTurn, TurnType nextTurn) {
		int[] lanes = currentTurn.getLanes();
		TIntHashSet turnSet = new TIntHashSet();
		for(int i = 0; i < lanes.length; i++) {
			if(lanes[i] % 2 == 1 ) {
				int singleTurn = TurnType.getPrimaryTurn(lanes[i]);
				turnSet.add(singleTurn);
				if(TurnType.getSecondaryTurn(lanes[i]) != 0) {
					turnSet.add(TurnType.getSecondaryTurn(lanes[i]));
				}
				if(TurnType.getTertiaryTurn(lanes[i]) != 0) {
					turnSet.add(TurnType.getTertiaryTurn(lanes[i]));
				}
			}
		}
		int singleTurn = 0;
		if(turnSet.size() == 1) {
			singleTurn = turnSet.iterator().next();
		} else if(currentTurn.goAhead() && turnSet.contains(nextTurn.getValue())) {
			if(currentTurn.isPossibleLeftTurn() && 
					TurnType.isLeftTurn(nextTurn.getValue())) {
				singleTurn = nextTurn.getValue();	
			} else if(currentTurn.isPossibleLeftTurn() && 
					TurnType.isLeftTurn(nextTurn.getActiveCommonLaneTurn())) {
				singleTurn = nextTurn.getActiveCommonLaneTurn();
			} else if(currentTurn.isPossibleRightTurn() && 
					TurnType.isRightTurn(nextTurn.getValue())) {
				singleTurn = nextTurn.getValue();
			} else if(currentTurn.isPossibleRightTurn() && 
					TurnType.isRightTurn(nextTurn.getActiveCommonLaneTurn())) {
				singleTurn = nextTurn.getActiveCommonLaneTurn();
			}
		}
		if (singleTurn == 0) {
			singleTurn = currentTurn.getValue();
			if(singleTurn == TurnType.KL || singleTurn == TurnType.KR) {
				return;
			}
		}
		for(int i = 0; i < lanes.length; i++) {
			if(lanes[i] % 2 == 1 && TurnType.getPrimaryTurn(lanes[i]) != singleTurn) {
				if(TurnType.getSecondaryTurn(lanes[i]) == singleTurn) {
					TurnType.setSecondaryTurn(lanes, i, TurnType.getPrimaryTurn(lanes[i]));
					TurnType.setPrimaryTurn(lanes, i, singleTurn);
				} else if(TurnType.getTertiaryTurn(lanes[i]) == singleTurn) {
					TurnType.setTertiaryTurn(lanes, i, TurnType.getPrimaryTurn(lanes[i]));
					TurnType.setPrimaryTurn(lanes, i, singleTurn);
				} else {
					// disable lane
					lanes[i] = lanes[i] - 1;
				}
			}
		}
		
	}

	private static final int MAX_SPEAK_PRIORITY = 5;
	private int highwaySpeakPriority(String highway) {
		if(highway == null || highway.endsWith("track") || highway.endsWith("services") || highway.endsWith("service")
				|| highway.endsWith("path")) {
			return MAX_SPEAK_PRIORITY;
		}
		if (highway.endsWith("_link")  || highway.endsWith("unclassified") || highway.endsWith("road") 
				|| highway.endsWith("living_street") || highway.endsWith("residential") )  {
			return 1;
		}
		return 0;
	}


	private TurnType getTurnInfo(List<RouteSegmentResult> result, int i, boolean leftSide) {
		if (i == 0) {
			return TurnType.valueOf(TurnType.C, false);
		}
		RouteSegmentResult prev = result.get(i - 1) ;
		if(prev.getObject().roundabout()) {
			// already analyzed!
			return null;
		}
		RouteSegmentResult rr = result.get(i);
		if (rr.getObject().roundabout()) {
			return processRoundaboutTurn(result, i, leftSide, prev, rr);
		}
		TurnType t = null;
		if (prev != null) {
			boolean noAttachedRoads = rr.getAttachedRoutes(rr.getStartPointIndex()).size() == 0;
			// add description about turn
			double mpi = MapUtils.degreesDiff(prev.getBearingEnd(), rr.getBearingBegin());
			if(noAttachedRoads){
				// TODO VICTOR : look at the comment inside direction route
				// ? avoid small zigzags is covered at (search for "zigzags") 
//				double begin = rr.getObject().directionRoute(rr.getStartPointIndex(), rr.getStartPointIndex() < 
//						rr.getEndPointIndex(), 25);
//				mpi = MapUtils.degreesDiff(prev.getBearingEnd(), begin);
			}
			if (mpi >= TURN_DEGREE_MIN) {
				if (mpi < 45) {
					// Slight turn detection here causes many false positives where drivers would expect a "normal" TL. Best use limit-angle=TURN_DEGREE_MIN, this reduces TSL to the turn-lanes cases.
					t = TurnType.valueOf(TurnType.TSLL, leftSide);
				} else if (mpi < 120) {
					t = TurnType.valueOf(TurnType.TL, leftSide);
				} else if (mpi < 150 || leftSide) {
					t = TurnType.valueOf(TurnType.TSHL, leftSide);
				} else {
					t = TurnType.valueOf(TurnType.TU, leftSide);
				}
				int[] lanes = getTurnLanesInfo(prev, t.getValue());
				t.setLanes(lanes);
			} else if (mpi < -TURN_DEGREE_MIN) {
				if (mpi > -45) {
					t = TurnType.valueOf(TurnType.TSLR, leftSide);
				} else if (mpi > -120) {
					t = TurnType.valueOf(TurnType.TR, leftSide);
				} else if (mpi > -150 || !leftSide) {
					t = TurnType.valueOf(TurnType.TSHR, leftSide);
				} else {
					t = TurnType.valueOf(TurnType.TRU, leftSide);
				}
				int[] lanes = getTurnLanesInfo(prev, t.getValue());
				t.setLanes(lanes);
			} else {
				t = attachKeepLeftInfoAndLanes(leftSide, prev, rr);
			}
			if (t != null) {
				t.setTurnAngle((float) -mpi);
			}
		}
		return t;
	}

	private int[] getTurnLanesInfo(RouteSegmentResult prevSegm, int mainTurnType) {		String turnLanes = getTurnLanesString(prevSegm);
		int[] lanesArray ;
		if (turnLanes == null) {
			if(prevSegm.getTurnType() != null && prevSegm.getTurnType().getLanes() != null
					&& prevSegm.getDistance() < 100) {
				int[] lns = prevSegm.getTurnType().getLanes();
				TIntArrayList lst = new TIntArrayList();
				for(int i = 0; i < lns.length; i++) {
					if(lns[i] % 2 == 1) {
						lst.add((lns[i] >> 1) << 1);
					}
				}
				if(lst.isEmpty()) {
					return null;
				}
				lanesArray = lst.toArray();
			} else {
				return null;
			}
		} else {
			lanesArray = calculateRawTurnLanes(turnLanes, mainTurnType);
		}
		// Manually set the allowed lanes.
		boolean isSet = setAllowedLanes(mainTurnType, lanesArray);
		if(!isSet && lanesArray.length > 0) {
			// In some cases (at least in the US), the rightmost lane might not have a right turn indicated as per turn:lanes,
			// but is allowed and being used here. This section adds in that indicator.  The same applies for where leftSide is true.
			boolean leftTurn = TurnType.isLeftTurn(mainTurnType);
			int ind = leftTurn? 0 : lanesArray.length - 1;
			int primaryTurn = TurnType.getPrimaryTurn(lanesArray[ind]);
			final int st = TurnType.getSecondaryTurn(lanesArray[ind]);
			if (leftTurn) {
				if (!TurnType.isLeftTurn(primaryTurn)) {
					// This was just to make sure that there's no bad data.
					TurnType.setPrimaryTurnAndReset(lanesArray, ind, TurnType.TL);
					TurnType.setSecondaryTurn(lanesArray, ind, primaryTurn);
					TurnType.setTertiaryTurn(lanesArray, ind, st);
					primaryTurn = TurnType.TL;
					lanesArray[ind] |= 1;
				}
			} else {
				if (!TurnType.isRightTurn(primaryTurn)) {
					// This was just to make sure that there's no bad data.
					TurnType.setPrimaryTurnAndReset(lanesArray, ind, TurnType.TR);
					TurnType.setSecondaryTurn(lanesArray, ind, primaryTurn);
					TurnType.setTertiaryTurn(lanesArray, ind, st);
					primaryTurn = TurnType.TR;
					lanesArray[ind] |= 1;
				}
			}
			setAllowedLanes(primaryTurn, lanesArray);
		}
		return lanesArray;
	}

	protected boolean setAllowedLanes(int mainTurnType, int[] lanesArray) {
		boolean turnSet = false;
		for (int i = 0; i < lanesArray.length; i++) {
			if (TurnType.getPrimaryTurn(lanesArray[i]) == mainTurnType) {
				lanesArray[i] |= 1;
				turnSet = true;
			}
		}
		return turnSet;
	}

	private TurnType processRoundaboutTurn(List<RouteSegmentResult> result, int i, boolean leftSide, RouteSegmentResult prev,
			RouteSegmentResult rr) {
		int exit = 1;
		RouteSegmentResult last = rr;
		RouteSegmentResult firstRoundabout = rr;
		RouteSegmentResult lastRoundabout = rr;
		for (int j = i; j < result.size(); j++) {
			RouteSegmentResult rnext = result.get(j);
			last = rnext;
			if (rnext.getObject().roundabout()) {
				lastRoundabout = rnext;
				boolean plus = rnext.getStartPointIndex() < rnext.getEndPointIndex();
				int k = rnext.getStartPointIndex();
				if (j == i) {
					// first exit could be immediately after roundabout enter
//					k = plus ? k + 1 : k - 1;
				}
				while (k != rnext.getEndPointIndex()) {
					int attachedRoads = rnext.getAttachedRoutes(k).size();
					if(attachedRoads > 0) {
						exit++;
					}
					k = plus ? k + 1 : k - 1;
				}
			} else {
				break;
			}
		}
		// combine all roundabouts
		TurnType t = TurnType.getExitTurn(exit, 0, leftSide);
		// usually covers more than expected
		float turnAngleBasedOnOutRoads = (float) MapUtils.degreesDiff(last.getBearingBegin(), prev.getBearingEnd());
		// usually covers less than expected
		float turnAngleBasedOnCircle = (float) -MapUtils.degreesDiff(firstRoundabout.getBearingBegin(), lastRoundabout.getBearingEnd() + 180);
		if(Math.abs(turnAngleBasedOnOutRoads - turnAngleBasedOnCircle) > 180) {
			t.setTurnAngle(turnAngleBasedOnCircle ) ;
		} else {
			t.setTurnAngle((turnAngleBasedOnCircle + turnAngleBasedOnOutRoads) / 2) ;
		}
		return t;
	}
	
	private class RoadSplitStructure {
		boolean keepLeft = false;
		boolean keepRight = false;
		boolean speak = false;
		List<int[]> leftLanesInfo = new ArrayList<int[]>();
		int leftLanes = 0;
		List<int[]> rightLanesInfo = new ArrayList<int[]>();
		int rightLanes = 0;
		int roadsOnLeft = 0;
		int addRoadsOnLeft = 0;
		int roadsOnRight = 0;
		int addRoadsOnRight = 0;
	}


	private TurnType attachKeepLeftInfoAndLanes(boolean leftSide, RouteSegmentResult prevSegm, RouteSegmentResult currentSegm) {
		List<RouteSegmentResult> attachedRoutes = currentSegm.getAttachedRoutes(currentSegm.getStartPointIndex());
		if(attachedRoutes == null || attachedRoutes.size() == 0) {
			return null;
		}
		// keep left/right
		RoadSplitStructure rs = calculateRoadSplitStructure(prevSegm, currentSegm, attachedRoutes);
		if(rs.roadsOnLeft  + rs.roadsOnRight == 0) {
			return null;
		}
		
		// turn lanes exist
		String turnLanes = getTurnLanesString(prevSegm);
		if (turnLanes != null) {
			return createKeepLeftRightTurnBasedOnTurnTypes(rs, prevSegm, currentSegm, turnLanes, leftSide);
		}

		// turn lanes don't exist
		if (rs.keepLeft || rs.keepRight) {
			return createSimpleKeepLeftRightTurn(leftSide, prevSegm, currentSegm, rs);
			
		}
		return null;
	}

	protected TurnType createKeepLeftRightTurnBasedOnTurnTypes(RoadSplitStructure rs, RouteSegmentResult prevSegm,
			RouteSegmentResult currentSegm, String turnLanes, boolean leftSide) {
		// Maybe going straight at a 90-degree intersection
		TurnType t = TurnType.valueOf(TurnType.C, leftSide);
		int[] rawLanes = calculateRawTurnLanes(turnLanes, TurnType.C);
		boolean possiblyLeftTurn = rs.roadsOnLeft == 0;
		boolean possiblyRightTurn = rs.roadsOnRight == 0;
		for (int k = 0; k < rawLanes.length; k++) {
			int turn = TurnType.getPrimaryTurn(rawLanes[k]);
			int sturn = TurnType.getSecondaryTurn(rawLanes[k]);
			int tturn = TurnType.getTertiaryTurn(rawLanes[k]);
			if (turn == TurnType.TU || sturn == TurnType.TU || tturn == TurnType.TU) {
				possiblyLeftTurn = true;
			}
			if (turn == TurnType.TRU || sturn == TurnType.TRU || sturn == TurnType.TRU) {
				possiblyRightTurn = true;
			}
		}
		
		t.setPossibleLeftTurn(possiblyLeftTurn);
		t.setPossibleRightTurn(possiblyRightTurn);
		if (rs.keepLeft || rs.keepRight) {
			String[] splitLaneOptions = turnLanes.split("\\|", -1);
			int activeBeginIndex = findActiveIndex(rawLanes, splitLaneOptions, rs.leftLanes, true, 
					rs.leftLanesInfo, rs.roadsOnLeft, rs.addRoadsOnLeft);
			
			if(!rs.keepLeft && activeBeginIndex != -1 && 
					splitLaneOptions.length > 0 && !splitLaneOptions[splitLaneOptions.length - 1].contains(";")) {
				activeBeginIndex = Math.max(activeBeginIndex, 1);
			}
			int activeEndIndex = findActiveIndex(rawLanes, splitLaneOptions, rs.rightLanes, false, 
					rs.rightLanesInfo, rs.roadsOnRight, rs.addRoadsOnRight);
			if(!rs.keepRight && activeEndIndex != -1  && 
					splitLaneOptions.length > 0 && !splitLaneOptions[0].contains(";") ) {
				activeEndIndex = Math.min(activeEndIndex, rawLanes.length - 1);
			}
			if (activeBeginIndex == -1 || activeEndIndex == -1 || activeBeginIndex > activeEndIndex) {
				// something went wrong
				return createSimpleKeepLeftRightTurn(leftSide, prevSegm, currentSegm, rs);
			}
			for (int k = 0; k < rawLanes.length; k++) {
				if (k >= activeBeginIndex && k <= activeEndIndex) {
					rawLanes[k] |= 1;
				}
			}
			int tp = inferSlightTurnFromLanes(rawLanes, rs);
			if (tp != t.getValue() && tp != 0) {
				t = TurnType.valueOf(tp, leftSide);
			}
		} else {
			for (int k = 0; k < rawLanes.length; k++) {
				int turn = TurnType.getPrimaryTurn(rawLanes[k]);
				int sturn = TurnType.getSecondaryTurn(rawLanes[k]);
				int tturn = TurnType.getTertiaryTurn(rawLanes[k]);
				
				boolean active = false;
				// some turns go through many segments (to turn right or left)
				// so on one first segment the lane could be available and may be only 1 possible
				// all undesired lanes will be disabled through the 2nd pass
				if((TurnType.isRightTurn(sturn) && possiblyRightTurn) ||
						(TurnType.isLeftTurn(sturn) && possiblyLeftTurn)) {
					// we can't predict here whether it will be a left turn or straight on, 
					// it could be done during 2nd pass
					TurnType.setPrimaryTurn(rawLanes, k, sturn);
					TurnType.setSecondaryTurn(rawLanes, k, turn);
					active = true;
				} else if((TurnType.isRightTurn(tturn) && possiblyRightTurn) ||
						(TurnType.isLeftTurn(tturn) && possiblyLeftTurn)) {
					TurnType.setPrimaryTurn(rawLanes, k, tturn);
					TurnType.setTertiaryTurn(rawLanes, k, turn);
					active = true;
				} else if((TurnType.isRightTurn(turn) && possiblyRightTurn) ||
						(TurnType.isLeftTurn(turn) && possiblyLeftTurn)) {
					active = true;
				} else if (turn == TurnType.C) {
					active = true;
				}
				if (active) {
					rawLanes[k] |= 1;
				}
			}
		}
		t.setSkipToSpeak(!rs.speak);
		t.setLanes(rawLanes);
		return t;
	}

	protected int findActiveIndex(int[] rawLanes, String[] splitLaneOptions, int lanes, boolean left, 
			List<int[]> lanesInfo, int roads, int addRoads) {
		int activeStartIndex = -1;
		boolean lookupSlightTurn = addRoads > 0;
		TIntHashSet addedTurns = new TIntHashSet();
		// if we have information increase number of roads per each turn direction
		int diffTurnRoads = roads;
		int increaseTurnRoads = 0;
		for(int[] li : lanesInfo) {
			TIntHashSet set = new TIntHashSet();
			if(li != null) {
				for(int k = 0; k < li.length; k++) {
					TurnType.collectTurnTypes(li[k], set);
				}
			}
			increaseTurnRoads = Math.max(set.size() - 1, 0);
		}
		
		for (int i = 0; i < rawLanes.length; i++) {
			int ind = left ? i : (rawLanes.length - i - 1);
			if (!lookupSlightTurn ||
					TurnType.hasAnySlightTurnLane(rawLanes[ind])) {
				String[] laneTurns = splitLaneOptions[ind].split(";");
				int cnt = 0;
				for(String lTurn : laneTurns) {
					boolean added = addedTurns.add(TurnType.convertType(lTurn));
					if(added) {
						cnt++;
						diffTurnRoads --;
					}
				}
				lanes -= cnt;
				//lanes--;
				// we already found slight turn others are turn in different direction
				lookupSlightTurn = false;
			}
			if (lanes < 0 || diffTurnRoads + increaseTurnRoads < 0) {
				activeStartIndex = ind;
				break;
			} else if(diffTurnRoads < 0 && activeStartIndex < 0) {
				activeStartIndex = ind;
			}
		}
		return activeStartIndex;
	}

	protected RoadSplitStructure calculateRoadSplitStructure(RouteSegmentResult prevSegm, RouteSegmentResult currentSegm,
			List<RouteSegmentResult> attachedRoutes) {
		RoadSplitStructure rs = new RoadSplitStructure();
		int speakPriority = Math.max(highwaySpeakPriority(prevSegm.getObject().getHighway()), highwaySpeakPriority(currentSegm.getObject().getHighway()));
		for (RouteSegmentResult attached : attachedRoutes) {
			boolean restricted = false;
			for(int k = 0; k < prevSegm.getObject().getRestrictionLength(); k++) {
				if(prevSegm.getObject().getRestrictionId(k) == attached.getObject().getId() && 
						prevSegm.getObject().getRestrictionType(k) <= MapRenderingTypes.RESTRICTION_NO_STRAIGHT_ON) {
					restricted = true;
					break;
				}
			}
			if(restricted) {
				continue;
			}
			double ex = MapUtils.degreesDiff(attached.getBearingBegin(), currentSegm.getBearingBegin());
			double mpi = Math.abs(MapUtils.degreesDiff(prevSegm.getBearingEnd(), attached.getBearingBegin()));
			int rsSpeakPriority = highwaySpeakPriority(attached.getObject().getHighway());
			int lanes = countLanesMinOne(attached);
			int[] turnLanes = parseTurnLanes(attached.getObject(), attached.getBearingBegin() * Math.PI / 180);
			boolean smallStraightVariation = mpi < TURN_DEGREE_MIN;
			boolean smallTargetVariation = Math.abs(ex) < TURN_DEGREE_MIN;
			boolean attachedOnTheRight = ex >= 0;
			if (attachedOnTheRight) {
				rs.roadsOnRight++;
			} else {
				rs.roadsOnLeft++;
			}
			if (rsSpeakPriority != MAX_SPEAK_PRIORITY || speakPriority == MAX_SPEAK_PRIORITY) {
				if (smallTargetVariation || smallStraightVariation) {
					if (attachedOnTheRight) {
						rs.keepLeft = true;
						rs.rightLanes += lanes;
						if(turnLanes != null) {
							rs.rightLanesInfo.add(turnLanes);
						}
					} else {
						rs.keepRight = true;
						rs.leftLanes += lanes;
						if(turnLanes != null) {
							rs.leftLanesInfo.add(turnLanes);
						}
					}
					rs.speak = rs.speak || rsSpeakPriority <= speakPriority;
				} else {
					if (attachedOnTheRight) {
						rs.addRoadsOnRight++;
					} else {
						rs.addRoadsOnLeft++;
					}
				}
			}
		}
		return rs;
	}

	protected TurnType createSimpleKeepLeftRightTurn(boolean leftSide, RouteSegmentResult prevSegm,
			RouteSegmentResult currentSegm, RoadSplitStructure rs) {
		int current = countLanesMinOne(currentSegm);
		int ls = current + rs.leftLanes + rs.rightLanes;
		int[] lanes = new int[ls];
		for (int it = 0; it < ls; it++) {
			if (it < rs.leftLanes || it >= rs.leftLanes + current) {
				lanes[it] = 0;
			} else {
				lanes[it] = 1;
			}
		}
		// sometimes links are
		if ((current <= rs.leftLanes + rs.rightLanes) && (rs.leftLanes > 1 || rs.rightLanes > 1)) {
			rs.speak = true;
		}
		double devation = Math.abs(MapUtils.degreesDiff(prevSegm.getBearingEnd(), currentSegm.getBearingBegin()));
		boolean makeSlightTurn = devation > 5 && (!isMotorway(prevSegm) || !isMotorway(currentSegm));
		TurnType t = null;
		if (rs.keepLeft && rs.keepRight) {
			t = TurnType.valueOf(TurnType.C, leftSide);
		} else if (rs.keepLeft) {
			t = TurnType.valueOf(makeSlightTurn ? TurnType.TSLL : TurnType.KL, leftSide);
		} else if (rs.keepRight) {
			t = TurnType.valueOf(makeSlightTurn ? TurnType.TSLR : TurnType.KR, leftSide);
		} else {
			return t;
		}
		t.setSkipToSpeak(!rs.speak);
		t.setLanes(lanes);
		return t;
	}

	
	protected int countLanesMinOne(RouteSegmentResult attached) {
		final boolean oneway = attached.getObject().getOneway() != 0;
		int lns = attached.getObject().getLanes();
		if(lns == 0) {
			String tls = getTurnLanesString(attached);
			if(tls != null) {
				return Math.max(1, countOccurrences(tls, '|'));
			}
		}
		if (oneway) {
			return Math.max(1, lns);
		}
		try {
			if (attached.isForwardDirection() && attached.getObject().getValue("lanes:forward") != null) {
				return Integer.parseInt(attached.getObject().getValue("lanes:forward"));
			} else if (!attached.isForwardDirection() && attached.getObject().getValue("lanes:backward") != null) {
				return Integer.parseInt(attached.getObject().getValue("lanes:backward"));
			}
		} catch(NumberFormatException e) {
			e.printStackTrace();
		}
		return Math.max(1, (lns + 1) / 2);
	}

	protected static String getTurnLanesString(RouteSegmentResult segment) {
		if (segment.getObject().getOneway() == 0) {
			if (segment.isForwardDirection()) {
				return segment.getObject().getValue("turn:lanes:forward");
			} else {
				return segment.getObject().getValue("turn:lanes:backward");
			}
		} else {
			return segment.getObject().getValue("turn:lanes");
		}
	}

	

	private int countOccurrences(String haystack, char needle) {
	    int count = 0;
		for (int i = 0; i < haystack.length(); i++) {
			if (haystack.charAt(i) == needle) {
				count++;
			}
		}
		return count;
	}

	public static int[] parseTurnLanes(RouteDataObject ro, double dirToNorthEastPi) {
		String turnLanes = null;
		if (ro.getOneway() == 0) {
			// we should get direction to detect forward or backward
			double cmp = ro.directionRoute(0, true);
			if(Math.abs(MapUtils.alignAngleDifference(dirToNorthEastPi -cmp)) < Math.PI / 2) {
				turnLanes = ro.getValue("turn:lanes:forward");
			} else {
				turnLanes = ro.getValue("turn:lanes:backward");
			}
		} else {
			turnLanes = ro.getValue("turn:lanes");
		}
		if(turnLanes == null) {
			return null;
		}
		return calculateRawTurnLanes(turnLanes, 0);
	}
	
	public static int[] parseLanes(RouteDataObject ro, double dirToNorthEastPi) {
		int lns = 0;
		try {
			if (ro.getOneway() == 0) {
				// we should get direction to detect forward or backward
				double cmp = ro.directionRoute(0, true);
				
				if(Math.abs(MapUtils.alignAngleDifference(dirToNorthEastPi -cmp)) < Math.PI / 2) {
					if(ro.getValue("lanes:forward") != null) {
						lns = Integer.parseInt(ro.getValue("lanes:forward"));
					}
				} else {
					if(ro.getValue("lanes:backward") != null) {
					lns = Integer.parseInt(ro.getValue("lanes:backward"));
					}
				}
				if (lns == 0 && ro.getValue("lanes") != null) {
					lns = Integer.parseInt(ro.getValue("lanes")) / 2;
				}
			} else {
				lns = Integer.parseInt(ro.getValue("lanes"));
			}
			if(lns > 0 ) {
				return new int[lns];
			}
		} catch (NumberFormatException e) {
		}
		return null;
	}
	
	private static int[] calculateRawTurnLanes(String turnLanes, int calcTurnType) {
		String[] splitLaneOptions = turnLanes.split("\\|", -1);
		int[] lanes = new int[splitLaneOptions.length];
		for (int i = 0; i < splitLaneOptions.length; i++) {
			String[] laneOptions = splitLaneOptions[i].split(";");
			boolean isTertiaryTurn = false;
			for (int j = 0; j < laneOptions.length; j++) {
				int turn = TurnType.convertType(laneOptions[j]);

				final int primary = TurnType.getPrimaryTurn(lanes[i]);
				if (primary == 0) {
					TurnType.setPrimaryTurnAndReset(lanes, i, turn);
				} else {
                    if (turn == calcTurnType || 
                    	(TurnType.isRightTurn(calcTurnType) && TurnType.isRightTurn(turn)) || 
                    	(TurnType.isLeftTurn(calcTurnType) && TurnType.isLeftTurn(turn)) 
                    	) {
                    	TurnType.setPrimaryTurnShiftOthers(lanes, i, turn);
                    } else if (!isTertiaryTurn) {
                    	TurnType.setSecondaryTurnShiftOthers(lanes, i, turn);
						isTertiaryTurn = true;
                    } else {
						TurnType.setTertiaryTurn(lanes, i, turn);
						break;
                    }
				}
			}
		}
		return lanes;
	}

	private int inferSlightTurnFromLanes(int[] oLanes, RoadSplitStructure rs) {
		TIntHashSet possibleTurns = new TIntHashSet();
		for (int i = 0; i < oLanes.length; i++) {
			if ((oLanes[i] & 1) == 0) {
				continue;
			}
			if (possibleTurns.isEmpty()) {
				// Nothing is in the list to compare to, so add the first elements
				possibleTurns.add(TurnType.getPrimaryTurn(oLanes[i]));
				if (TurnType.getSecondaryTurn(oLanes[i]) != 0) {
					possibleTurns.add(TurnType.getSecondaryTurn(oLanes[i]));
				}
				if (TurnType.getTertiaryTurn(oLanes[i]) != 0) {
					possibleTurns.add(TurnType.getTertiaryTurn(oLanes[i]));
				}
			} else {
				TIntArrayList laneTurns = new TIntArrayList();
				laneTurns.add(TurnType.getPrimaryTurn(oLanes[i]));
				if (TurnType.getSecondaryTurn(oLanes[i]) != 0) {
					laneTurns.add(TurnType.getSecondaryTurn(oLanes[i]));
				}
				if (TurnType.getTertiaryTurn(oLanes[i]) != 0) {
					laneTurns.add(TurnType.getTertiaryTurn(oLanes[i]));
				}
				possibleTurns.retainAll(laneTurns);
				if (possibleTurns.isEmpty()) {
					// No common turns, so can't determine anything.
					return 0;
				}
			}
		}

		// Remove all turns from lanes not selected...because those aren't it
		for (int i = 0; i < oLanes.length; i++) {
			if ((oLanes[i] & 1) == 0 && !possibleTurns.isEmpty()) {
				possibleTurns.remove((Integer) TurnType.getPrimaryTurn(oLanes[i]));
				if (TurnType.getSecondaryTurn(oLanes[i]) != 0) {
					possibleTurns.remove((Integer) TurnType.getSecondaryTurn(oLanes[i]));
				}
				if (TurnType.getTertiaryTurn(oLanes[i]) != 0) {
					possibleTurns.remove((Integer) TurnType.getTertiaryTurn(oLanes[i]));
				}
			}
		}
		// remove all non-slight turns // TEST don't pass 
//		if(possibleTurns.size() > 1) {
//			TIntIterator it = possibleTurns.iterator();
//			while(it.hasNext()) {
//				int nxt = it.next();
//				if(!TurnType.isSlightTurn(nxt)) {
//					it.remove();
//				}
//			}
//		}
		int infer = 0;
		if (possibleTurns.size() == 1) {
			infer = possibleTurns.iterator().next();
		} else if (possibleTurns.size() > 1) {
			if (rs.keepLeft && rs.keepRight && possibleTurns.contains(TurnType.C)) {
				infer = TurnType.C;
			} else if (rs.keepLeft || rs.keepRight) {
				TIntIterator it = possibleTurns.iterator();
				infer = it.next();
				while(it.hasNext()) {
					int next = it.next();
					int orderInfer = TurnType.orderFromLeftToRight(infer);
					int orderNext = TurnType.orderFromLeftToRight(next) ;
					if(rs.keepLeft && orderNext < orderInfer) {
						infer = next;
					} else if(rs.keepRight && orderNext > orderInfer) {
						infer = next;
					}
				}
			}
		}

		// Checking to see that there is only one unique turn
		if (infer != 0) {
			for(int i = 0; i < oLanes.length; i++) {
				if(TurnType.getSecondaryTurn(oLanes[i]) == infer) {
					int pt = TurnType.getPrimaryTurn(oLanes[i]);
					int en = oLanes[i] & 1;
					TurnType.setPrimaryTurnAndReset(oLanes, i, infer);
					oLanes[i] |= en;
					TurnType.setSecondaryTurn(oLanes, i, pt);
				}
				
			}
		}
		return infer;
	}

	private boolean isMotorway(RouteSegmentResult s){
		String h = s.getObject().getHighway();
		return "motorway".equals(h) || "motorway_link".equals(h)  ||
				"trunk".equals(h) || "trunk_link".equals(h);
		
	}

	
	private void attachRoadSegments(RoutingContext ctx, List<RouteSegmentResult> result, int routeInd, int pointInd, boolean plus) throws IOException {
		RouteSegmentResult rr = result.get(routeInd);
		RouteDataObject road = rr.getObject();
		long nextL = pointInd < road.getPointsLength() - 1 ? getPoint(road, pointInd + 1) : 0;
		long prevL = pointInd > 0 ? getPoint(road, pointInd - 1) : 0;
		
		// attach additional roads to represent more information about the route
		RouteSegmentResult previousResult = null;
		
		// by default make same as this road id
		long previousRoadId = road.getId();
		if (pointInd == rr.getStartPointIndex() && routeInd > 0) {
			previousResult = result.get(routeInd - 1);
			previousRoadId = previousResult.getObject().getId();
			if (previousRoadId != road.getId()) {
				if (previousResult.getStartPointIndex() < previousResult.getEndPointIndex()
						&& previousResult.getEndPointIndex() < previousResult.getObject().getPointsLength() - 1) {
					rr.attachRoute(pointInd, new RouteSegmentResult(previousResult.getObject(), previousResult.getEndPointIndex(),
							previousResult.getObject().getPointsLength() - 1));
				} else if (previousResult.getStartPointIndex() > previousResult.getEndPointIndex() 
						&& previousResult.getEndPointIndex() > 0) {
					rr.attachRoute(pointInd, new RouteSegmentResult(previousResult.getObject(), previousResult.getEndPointIndex(), 0));
				}
			}
		}
		Iterator<RouteSegment> it;
		if(rr.getPreAttachedRoutes(pointInd) != null) {
			final RouteSegmentResult[] list = rr.getPreAttachedRoutes(pointInd);
			it = new Iterator<BinaryRoutePlanner.RouteSegment>() {
				int i = 0;
				@Override
				public boolean hasNext() {
					return i < list.length;
				}

				@Override
				public RouteSegment next() {
					RouteSegmentResult r = list[i++];
					return new RouteSegment(r.getObject(), r.getStartPointIndex());
				}

				@Override
				public void remove() {
				}
			};	
		} else {
			RouteSegment rt = ctx.loadRouteSegment(road.getPoint31XTile(pointInd), road.getPoint31YTile(pointInd), ctx.config.memoryLimitation);
			it = rt == null ? null : rt.getIterator();
		}
		// try to attach all segments except with current id
		while (it != null && it.hasNext()) {
			RouteSegment routeSegment = it.next();
			if (routeSegment.road.getId() != road.getId() && routeSegment.road.getId() != previousRoadId) {
				RouteDataObject addRoad = routeSegment.road;
				checkAndInitRouteRegion(ctx, addRoad);
				// TODO restrictions can be considered as well
				int oneWay = ctx.getRouter().isOneWay(addRoad);
				if (oneWay >= 0 && routeSegment.getSegmentStart() < addRoad.getPointsLength() - 1) {
					long pointL = getPoint(addRoad, routeSegment.getSegmentStart() + 1);
					if(pointL != nextL && pointL != prevL) {
						// if way contains same segment (nodes) as different way (do not attach it)
						rr.attachRoute(pointInd, new RouteSegmentResult(addRoad, routeSegment.getSegmentStart(), addRoad.getPointsLength() - 1));
					}
				}
				if (oneWay <= 0 && routeSegment.getSegmentStart() > 0) {
					long pointL = getPoint(addRoad, routeSegment.getSegmentStart() - 1);
					// if way contains same segment (nodes) as different way (do not attach it)
					if(pointL != nextL && pointL != prevL) {
						rr.attachRoute(pointInd, new RouteSegmentResult(addRoad, routeSegment.getSegmentStart(), 0));
					}
				}
			}
		}
	}
	
	private static void println(String logMsg) {
//		log.info(logMsg);
		System.out.println(logMsg);
	}
	
	private long getPoint(RouteDataObject road, int pointInd) {
		return (((long) road.getPoint31XTile(pointInd)) << 31) + (long) road.getPoint31YTile(pointInd);
	}
	
	private static double measuredDist(int x1, int y1, int x2, int y2) {
		return MapUtils.getDistance(MapUtils.get31LatitudeY(y1), MapUtils.get31LongitudeX(x1), 
				MapUtils.get31LatitudeY(y2), MapUtils.get31LongitudeX(x2));
	}
}
!@#$%
20190530_075859,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_b03780
package net.osmand.plus.helpers;

import android.annotation.SuppressLint;
import android.annotation.TargetApi;
import android.app.Activity;
import android.app.Application;
import android.app.ProgressDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.content.Intent;
import android.graphics.Color;
import android.graphics.Typeface;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.os.Build;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.support.v4.app.ActivityCompat;
import android.support.v4.content.ContextCompat;
import android.support.v7.app.AlertDialog;
import android.support.v7.widget.ListPopupWindow;
import android.support.v7.widget.SwitchCompat;
import android.text.SpannableString;
import android.text.style.StyleSpan;
import android.util.TypedValue;
import android.view.Gravity;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.ArrayAdapter;
import android.widget.Button;
import android.widget.CheckBox;
import android.widget.CompoundButton;
import android.widget.CompoundButton.OnCheckedChangeListener;
import android.widget.ImageView;
import android.widget.TextView;
import android.widget.Toast;

import com.github.mikephil.charting.charts.HorizontalBarChart;
import com.github.mikephil.charting.charts.LineChart;
import com.github.mikephil.charting.components.AxisBase;
import com.github.mikephil.charting.components.Legend;
import com.github.mikephil.charting.components.MarkerView;
import com.github.mikephil.charting.components.XAxis;
import com.github.mikephil.charting.components.YAxis;
import com.github.mikephil.charting.data.BarData;
import com.github.mikephil.charting.data.BarDataSet;
import com.github.mikephil.charting.data.BarEntry;
import com.github.mikephil.charting.data.ChartData;
import com.github.mikephil.charting.data.DataSet;
import com.github.mikephil.charting.data.Entry;
import com.github.mikephil.charting.data.LineDataSet;
import com.github.mikephil.charting.formatter.IAxisValueFormatter;
import com.github.mikephil.charting.formatter.IFillFormatter;
import com.github.mikephil.charting.highlight.Highlight;
import com.github.mikephil.charting.interfaces.dataprovider.LineDataProvider;
import com.github.mikephil.charting.interfaces.datasets.ILineDataSet;
import com.github.mikephil.charting.utils.MPPointF;

import net.osmand.AndroidUtils;
import net.osmand.CallbackWithObject;
import net.osmand.IndexConstants;
import net.osmand.Location;
import net.osmand.plus.ContextMenuAdapter;
import net.osmand.plus.ContextMenuItem;
import net.osmand.plus.GPXDatabase.GpxDataItem;
import net.osmand.GPXUtilities;
import net.osmand.GPXUtilities.Elevation;
import net.osmand.GPXUtilities.GPXFile;
import net.osmand.GPXUtilities.GPXTrackAnalysis;
import net.osmand.GPXUtilities.Speed;
import net.osmand.GPXUtilities.TrkSegment;
import net.osmand.plus.GpxSelectionHelper.SelectedGpxFile;
import net.osmand.plus.OsmAndFormatter;
import net.osmand.plus.OsmandApplication;
import net.osmand.plus.OsmandPlugin;
import net.osmand.plus.OsmandSettings;
import net.osmand.plus.R;
import net.osmand.plus.UiUtilities;
import net.osmand.plus.Version;
import net.osmand.plus.activities.ActivityResultListener;
import net.osmand.plus.activities.ActivityResultListener.OnActivityResultListener;
import net.osmand.plus.activities.MapActivity;
import net.osmand.plus.activities.PluginActivity;
import net.osmand.plus.activities.SettingsActivity;
import net.osmand.plus.dialogs.ConfigureMapMenu;
import net.osmand.plus.dialogs.ConfigureMapMenu.AppearanceListItem;
import net.osmand.plus.dialogs.ConfigureMapMenu.GpxAppearanceAdapter;
import net.osmand.plus.monitoring.OsmandMonitoringPlugin;
import net.osmand.plus.routing.RouteCalculationResult;
import net.osmand.render.RenderingRuleProperty;
import net.osmand.render.RenderingRuleSearchRequest;
import net.osmand.render.RenderingRulesStorage;
import net.osmand.router.RouteStatistics;
import net.osmand.util.Algorithms;
import net.osmand.util.MapUtils;

import java.io.File;
import java.text.DateFormat;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static com.github.mikephil.charting.components.XAxis.XAxisPosition.BOTTOM;
import static net.osmand.binary.RouteDataObject.HEIGHT_UNDEFINED;
import static net.osmand.plus.OsmAndFormatter.FEET_IN_ONE_METER;
import static net.osmand.plus.OsmAndFormatter.METERS_IN_KILOMETER;
import static net.osmand.plus.OsmAndFormatter.METERS_IN_ONE_MILE;
import static net.osmand.plus.OsmAndFormatter.METERS_IN_ONE_NAUTICALMILE;
import static net.osmand.plus.OsmAndFormatter.YARDS_IN_ONE_METER;
import static net.osmand.plus.dialogs.ConfigureMapMenu.CURRENT_TRACK_COLOR_ATTR;
import static net.osmand.plus.dialogs.ConfigureMapMenu.CURRENT_TRACK_WIDTH_ATTR;
import static net.osmand.plus.download.DownloadActivity.formatKb;
import static net.osmand.plus.download.DownloadActivity.formatMb;

public class GpxUiHelper {

	private static final int OPEN_GPX_DOCUMENT_REQUEST = 1005;

	public static String getDescription(OsmandApplication app, GPXFile result, File f, boolean html) {
		GPXTrackAnalysis analysis = result.getAnalysis(f == null ? 0 : f.lastModified());
		return getDescription(app, analysis, html);
	}

	public static String getDescription(OsmandApplication app, TrkSegment t, boolean html) {
		return getDescription(app, GPXTrackAnalysis.segment(0, t), html);
	}


	public static String getColorValue(String clr, String value, boolean html) {
		if (!html) {
			return value;
		}
		return "<font color=\"" + clr + "\">" + value + "</font>";
	}

	public static String getColorValue(String clr, String value) {
		return getColorValue(clr, value, true);
	}

	public static String getDescription(OsmandApplication app, GPXTrackAnalysis analysis, boolean html) {
		StringBuilder description = new StringBuilder();
		String nl = html ? "<br/>" : "\n";
		String timeSpanClr = Algorithms.colorToString(ContextCompat.getColor(app, R.color.gpx_time_span_color));
		String distanceClr = Algorithms.colorToString(ContextCompat.getColor(app, R.color.gpx_distance_color));
		String speedClr = Algorithms.colorToString(ContextCompat.getColor(app, R.color.gpx_speed));
		String ascClr = Algorithms.colorToString(ContextCompat.getColor(app, R.color.gpx_altitude_asc));
		String descClr = Algorithms.colorToString(ContextCompat.getColor(app, R.color.gpx_altitude_desc));
		// OUTPUT:
		// 1. Total distance, Start time, End time
		description.append(app.getString(R.string.gpx_info_distance, getColorValue(distanceClr,
						OsmAndFormatter.getFormattedDistance(analysis.totalDistance, app), html),
				getColorValue(distanceClr, analysis.points + "", html)));
		if (analysis.totalTracks > 1) {
			description.append(nl).append(app.getString(R.string.gpx_info_subtracks, getColorValue(speedClr, analysis.totalTracks + "", html)));
		}
		if (analysis.wptPoints > 0) {
			description.append(nl).append(app.getString(R.string.gpx_info_waypoints, getColorValue(speedClr, analysis.wptPoints + "", html)));
		}
		if (analysis.isTimeSpecified()) {
			description.append(nl).append(app.getString(R.string.gpx_info_start_time, analysis.startTime));
			description.append(nl).append(app.getString(R.string.gpx_info_end_time, analysis.endTime));
		}

		// 2. Time span
		if (analysis.timeSpan > 0 && analysis.timeSpan / 1000 != analysis.timeMoving / 1000) {
			final String formatDuration = Algorithms.formatDuration((int) (analysis.timeSpan / 1000), app.accessibilityEnabled());
			description.append(nl).append(app.getString(R.string.gpx_timespan,
					getColorValue(timeSpanClr, formatDuration, html)));
		}

		// 3. Time moving, if any
		if (analysis.isTimeMoving()) {
				//Next few lines for Issue 3222 heuristic testing only
				//final String formatDuration0 = Algorithms.formatDuration((int) (analysis.timeMoving0 / 1000), app.accessibilityEnabled());
				//description.append(nl).append(app.getString(R.string.gpx_timemoving,
				//		getColorValue(timeSpanClr, formatDuration0, html)));
				//description.append(" (" + getColorValue(distanceClr, OsmAndFormatter.getFormattedDistance(analysis.totalDistanceMoving0, app), html) + ")");
			final String formatDuration = Algorithms.formatDuration((int) (analysis.timeMoving / 1000), app.accessibilityEnabled());
			description.append(nl).append(app.getString(R.string.gpx_timemoving,
					getColorValue(timeSpanClr, formatDuration, html)));
			description.append(" (" + getColorValue(distanceClr, OsmAndFormatter.getFormattedDistance(analysis.totalDistanceMoving, app), html) + ")");
		}

		// 4. Elevation, eleUp, eleDown, if recorded
		if (analysis.isElevationSpecified()) {
			description.append(nl);
			description.append(app.getString(R.string.gpx_info_avg_altitude,
					getColorValue(speedClr, OsmAndFormatter.getFormattedAlt(analysis.avgElevation, app), html)));
			description.append(nl);
			String min = getColorValue(descClr, OsmAndFormatter.getFormattedAlt(analysis.minElevation, app), html);
			String max = getColorValue(ascClr, OsmAndFormatter.getFormattedAlt(analysis.maxElevation, app), html);
			String asc = getColorValue(ascClr, OsmAndFormatter.getFormattedAlt(analysis.diffElevationUp, app), html);
			String desc = getColorValue(descClr, OsmAndFormatter.getFormattedAlt(analysis.diffElevationDown, app), html);
			description.append(app.getString(R.string.gpx_info_diff_altitude, min + " - " + max));
			description.append(nl);
			description.append(app.getString(R.string.gpx_info_asc_altitude, "\u2193 " + desc + "   \u2191 " + asc + ""));
		}


		if (analysis.isSpeedSpecified()) {
			String avg = getColorValue(speedClr, OsmAndFormatter.getFormattedSpeed(analysis.avgSpeed, app), html);
			String max = getColorValue(ascClr, OsmAndFormatter.getFormattedSpeed(analysis.maxSpeed, app), html);
			description.append(nl).append(app.getString(R.string.gpx_info_average_speed, avg));
			description.append(nl).append(app.getString(R.string.gpx_info_maximum_speed, max));
		}
		return description.toString();
	}

	public static AlertDialog selectGPXFiles(List<String> selectedGpxList, final Activity activity,
											 final CallbackWithObject<GPXFile[]> callbackWithObject) {
		OsmandApplication app = (OsmandApplication) activity.getApplication();
		final File dir = app.getAppPath(IndexConstants.GPX_INDEX_DIR);
		final List<GPXInfo> allGpxList = getSortedGPXFilesInfo(dir, selectedGpxList, false);
		if (allGpxList.isEmpty()) {
			Toast.makeText(activity, R.string.gpx_files_not_found, Toast.LENGTH_LONG).show();
		}
		allGpxList.add(0, new GPXInfo(activity.getString(R.string.show_current_gpx_title), 0, 0));

		final ContextMenuAdapter adapter = createGpxContextMenuAdapter(allGpxList, selectedGpxList, true);
		return createDialog(activity, true, true, true, callbackWithObject, allGpxList, adapter);
	}

	public static AlertDialog selectGPXFile(final Activity activity,
											final boolean showCurrentGpx, final boolean multipleChoice, final CallbackWithObject<GPXFile[]> callbackWithObject) {
		OsmandApplication app = (OsmandApplication) activity.getApplication();
		final File dir = app.getAppPath(IndexConstants.GPX_INDEX_DIR);
		final List<GPXInfo> list = getSortedGPXFilesInfo(dir, null, false);
		if (list.isEmpty()) {
			Toast.makeText(activity, R.string.gpx_files_not_found, Toast.LENGTH_LONG).show();
		}
		if (!list.isEmpty() || showCurrentGpx) {
			if (showCurrentGpx) {
				list.add(0, new GPXInfo(activity.getString(R.string.show_current_gpx_title), 0, 0));
			}

			final ContextMenuAdapter adapter = createGpxContextMenuAdapter(list, null, showCurrentGpx);
			return createDialog(activity, showCurrentGpx, multipleChoice, false, callbackWithObject, list, adapter);
		}
		return null;
	}

	public static AlertDialog selectSingleGPXFile(final Activity activity, boolean showCurrentGpx,
												  final CallbackWithObject<GPXFile[]> callbackWithObject) {
		OsmandApplication app = (OsmandApplication) activity.getApplication();
		int gpxDirLength = app.getAppPath(IndexConstants.GPX_INDEX_DIR).getAbsolutePath().length();
		List<SelectedGpxFile> selectedGpxFiles = app.getSelectedGpxHelper().getSelectedGPXFiles();
		final List<GPXInfo> list = new ArrayList<>(selectedGpxFiles.size() + 1);
		if (OsmandPlugin.getEnabledPlugin(OsmandMonitoringPlugin.class) == null) {
			showCurrentGpx = false;
		}
		if (!selectedGpxFiles.isEmpty() || showCurrentGpx) {
			if (showCurrentGpx) {
				list.add(new GPXInfo(activity.getString(R.string.shared_string_currently_recording_track), 0, 0));
			}

			for (SelectedGpxFile selectedGpx : selectedGpxFiles) {
				if (!selectedGpx.getGpxFile().showCurrentTrack) {
					list.add(new GPXInfo(selectedGpx.getGpxFile().path.substring(gpxDirLength + 1), selectedGpx.getGpxFile().modifiedTime, 0));
				}
			}

			final ContextMenuAdapter adapter = createGpxContextMenuAdapter(list, null, showCurrentGpx);
			return createSingleChoiceDialog(activity, showCurrentGpx, callbackWithObject, list, adapter);
		}
		return null;
	}

	private static ContextMenuAdapter createGpxContextMenuAdapter(List<GPXInfo> allGpxList,
																  List<String> selectedGpxList,
																  boolean showCurrentTrack) {
		final ContextMenuAdapter adapter = new ContextMenuAdapter();
		//element position in adapter
		int i = 0;
		for (GPXInfo gpxInfo : allGpxList) {
			String fileName = gpxInfo.getFileName();
			String s = getGpxTitle(fileName);

			adapter.addItem(ContextMenuItem.createBuilder(s).setSelected(false)
					.setIcon(R.drawable.ic_action_polygom_dark).createItem());

			//if there's some selected files - need to mark them as selected
			if (selectedGpxList != null) {
				updateSelection(selectedGpxList, showCurrentTrack, adapter, i, fileName);
			}
			i++;
		}
		return adapter;
	}

	public static String getGpxTitle(String fileName) {
		String s = fileName;
		if (s.toLowerCase().endsWith(".gpx")) {
			s = s.substring(0, s.length() - ".gpx".length());
		}
		s = s.replace('_', ' ');
		return s;
	}

	protected static void updateSelection(List<String> selectedGpxList, boolean showCurrentTrack,
										  final ContextMenuAdapter adapter, int position, String fileName) {
		ContextMenuItem item = adapter.getItem(position);
		if (position == 0 && showCurrentTrack) {
			if (selectedGpxList.contains("")) {
				item.setSelected(true);
			}
		} else {
			for (String file : selectedGpxList) {
				if (file.endsWith(fileName)) {
					item.setSelected(true);
					break;
				}
			}
		}
	}

	private static void setDescripionInDialog(final ArrayAdapter<?> adapter, final ContextMenuAdapter cmAdapter, Activity activity,
											  final File dir, String filename, final int position) {
		final Application app = activity.getApplication();
		final File f = new File(dir, filename);
		loadGPXFileInDifferentThread(activity, new CallbackWithObject<GPXUtilities.GPXFile[]>() {

			@Override
			public boolean processResult(GPXFile[] result) {
				ContextMenuItem item = cmAdapter.getItem(position);
				item.setTitle(item.getTitle() + "\n" + getDescription((OsmandApplication) app, result[0], f, false));
				adapter.notifyDataSetInvalidated();
				return true;
			}
		}, dir, null, filename);
	}

	private static AlertDialog createSingleChoiceDialog(final Activity activity,
											final boolean showCurrentGpx,
											final CallbackWithObject<GPXFile[]> callbackWithObject,
											final List<GPXInfo> list,
											final ContextMenuAdapter adapter) {
		final OsmandApplication app = (OsmandApplication) activity.getApplication();
		final UiUtilities iconsCache = app.getUIUtilities();
		final File dir = app.getAppPath(IndexConstants.GPX_INDEX_DIR);
		AlertDialog.Builder builder = new AlertDialog.Builder(activity);
		final int layout = R.layout.list_menu_item_native_singlechoice;

		final ArrayAdapter<String> listAdapter = new ArrayAdapter<String>(activity, layout, R.id.text1,
				adapter.getItemNames()) {
			@Override
			public View getView(final int position, View convertView, ViewGroup parent) {
				// User super class to create the View
				View v = convertView;
				if (v == null) {
					v = activity.getLayoutInflater().inflate(layout, null);
				}
				final ContextMenuItem item = adapter.getItem(position);
				TextView tv = (TextView) v.findViewById(R.id.text1);
				Drawable icon;
				if (showCurrentGpx && position == 0) {
					icon = null;
				} else {
					icon = iconsCache.getThemedIcon(item.getIcon());
				}
				tv.setCompoundDrawablePadding(AndroidUtils.dpToPx(activity, 10f));
				tv.setCompoundDrawablesWithIntrinsicBounds(icon, null, null, null);
				tv.setText(item.getTitle());
				tv.setTextSize(TypedValue.COMPLEX_UNIT_SP, 16);

				return v;
			}
		};

		int selectedIndex = 0;
		String prevSelectedGpx = app.getSettings().LAST_SELECTED_GPX_TRACK_FOR_NEW_POINT.get();
		if (prevSelectedGpx != null) {
			selectedIndex = list.indexOf(prevSelectedGpx);
		}
		if (selectedIndex == -1) {
			selectedIndex = 0;
		}

		final int[] selectedPosition = {selectedIndex};
		builder.setSingleChoiceItems(listAdapter, selectedIndex, new OnClickListener() {
			@Override
			public void onClick(DialogInterface dialog, int position) {
				selectedPosition[0] = position;
			}
		});
		builder.setTitle(R.string.select_gpx)
				.setPositiveButton(R.string.shared_string_ok, new OnClickListener() {

					@Override
					public void onClick(DialogInterface dialog, int which) {

						int position = selectedPosition[0];
						if (position != -1 && position < list.size()) {
							if (showCurrentGpx && position == 0) {
								callbackWithObject.processResult(null);
								app.getSettings().LAST_SELECTED_GPX_TRACK_FOR_NEW_POINT.set(null);
							} else {
								String fileName = list.get(position).getFileName();
								app.getSettings().LAST_SELECTED_GPX_TRACK_FOR_NEW_POINT.set(fileName);
								SelectedGpxFile selectedGpxFile =
										app.getSelectedGpxHelper().getSelectedFileByName(fileName);
								if (selectedGpxFile != null) {
									callbackWithObject.processResult(new GPXFile[]{selectedGpxFile.getGpxFile()});
								} else {
									loadGPXFileInDifferentThread(activity, callbackWithObject, dir, null, fileName);
								}
							}
						}
					}
				})
				.setNegativeButton(R.string.shared_string_cancel, null);

		final AlertDialog dlg = builder.create();
		dlg.setCanceledOnTouchOutside(false);
		dlg.show();
		try {
			dlg.getListView().setFastScrollEnabled(true);
		} catch (Exception e) {
			// java.lang.ClassCastException: com.android.internal.widget.RoundCornerListAdapter
			// Unknown reason but on some devices fail
		}
		return dlg;
	}

	private static AlertDialog createDialog(final Activity activity,
											final boolean showCurrentGpx,
											final boolean multipleChoice,
											final boolean showAppearanceSetting,
											final CallbackWithObject<GPXFile[]> callbackWithObject,
											final List<GPXInfo> list,
											final ContextMenuAdapter adapter) {
		final OsmandApplication app = (OsmandApplication) activity.getApplication();
		final DateFormat dateFormat = android.text.format.DateFormat.getMediumDateFormat(activity);
		final File dir = app.getAppPath(IndexConstants.GPX_INDEX_DIR);
		AlertDialog.Builder builder = new AlertDialog.Builder(activity);
		final int layout = R.layout.gpx_track_item;
		final Map<String, String> gpxAppearanceParams = new HashMap<>();

		final ArrayAdapter<String> listAdapter = new ArrayAdapter<String>(activity, layout, R.id.title,
				adapter.getItemNames()) {

			List<GpxDataItem> dataItems = null;

			@Override
			public int getItemViewType(int position) {
				return showCurrentGpx && position == 0 ? 1 : 0;
			}

			@Override
			public int getViewTypeCount() {
				return 2;
			}

			private GpxDataItem getDataItem(GPXInfo info) {
				if (dataItems != null) {
					for (GpxDataItem item : dataItems) {
						if (item.getFile().getAbsolutePath().endsWith(info.fileName)) {
							return item;
						}
					}
				}
				return null;
			}

			@Override
			public View getView(final int position, View convertView, ViewGroup parent) {
				// User super class to create the View
				View v = convertView;
				boolean checkLayout = getItemViewType(position) == 0;
				if (v == null) {
					v = activity.getLayoutInflater().inflate(layout, null);
				}

				if (dataItems == null) {
					dataItems = app.getGpxDatabase().getItems();
				}

				final ContextMenuItem item = adapter.getItem(position);
				GPXInfo info = list.get(position);
				updateGpxInfoView(v, item.getTitle(), info, getDataItem(info), showCurrentGpx && position == 0, app);

				if (item.getSelected() == null) {
					v.findViewById(R.id.check_item).setVisibility(View.GONE);
					v.findViewById(R.id.check_local_index).setVisibility(View.GONE);
				} else {
					if (checkLayout) {
						final CheckBox ch = ((CheckBox) v.findViewById(R.id.check_local_index));
						ch.setVisibility(View.VISIBLE);
						v.findViewById(R.id.toggle_item).setVisibility(View.GONE);
						ch.setOnCheckedChangeListener(null);
						ch.setChecked(item.getSelected());
						ch.setOnCheckedChangeListener(new OnCheckedChangeListener() {
							@Override
							public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
								item.setSelected(isChecked);
							}
						});
					} else {
						final SwitchCompat ch = ((SwitchCompat) v.findViewById(R.id.toggle_item));
						ch.setVisibility(View.VISIBLE);
						v.findViewById(R.id.toggle_checkbox_item).setVisibility(View.GONE);
						ch.setOnCheckedChangeListener(null);
						ch.setChecked(item.getSelected());
						ch.setOnCheckedChangeListener(new OnCheckedChangeListener() {
							@Override
							public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
								item.setSelected(isChecked);
							}
						});
					}
					v.findViewById(R.id.check_item).setVisibility(View.VISIBLE);
				}
				return v;
			}
		};

		OnClickListener onClickListener = new OnClickListener() {
			@Override
			public void onClick(DialogInterface dialog, int position) {
			}
		};
		builder.setAdapter(listAdapter, onClickListener);
		if (multipleChoice) {
			if (showAppearanceSetting) {
				final RenderingRuleProperty trackWidthProp;
				final RenderingRuleProperty trackColorProp;
				final RenderingRulesStorage renderer = app.getRendererRegistry().getCurrentSelectedRenderer();
				if (renderer != null) {
					trackWidthProp = renderer.PROPS.getCustomRule(CURRENT_TRACK_WIDTH_ATTR);
					trackColorProp = renderer.PROPS.getCustomRule(CURRENT_TRACK_COLOR_ATTR);
				} else {
					trackWidthProp = null;
					trackColorProp = null;
				}
				if (trackWidthProp == null || trackColorProp == null) {
					builder.setTitle(R.string.show_gpx);
				} else {
					final View apprTitleView = activity.getLayoutInflater().inflate(R.layout.select_gpx_appearance_title, null);

					final OsmandSettings.CommonPreference<String> prefWidth
							= app.getSettings().getCustomRenderProperty(CURRENT_TRACK_WIDTH_ATTR);
					final OsmandSettings.CommonPreference<String> prefColor
							= app.getSettings().getCustomRenderProperty(CURRENT_TRACK_COLOR_ATTR);

					updateAppearanceTitle(activity, app, trackWidthProp, renderer, apprTitleView, prefWidth.get(), prefColor.get());

					apprTitleView.findViewById(R.id.button).setOnClickListener(new View.OnClickListener() {
						@Override
						public void onClick(View v) {
							final ListPopupWindow popup = new ListPopupWindow(activity);
							popup.setAnchorView(apprTitleView);
							popup.setContentWidth(AndroidUtils.dpToPx(activity, 200f));
							popup.setModal(true);
							popup.setDropDownGravity(Gravity.RIGHT | Gravity.TOP);
							popup.setVerticalOffset(AndroidUtils.dpToPx(activity, -48f));
							popup.setHorizontalOffset(AndroidUtils.dpToPx(activity, -6f));
							final GpxAppearanceAdapter gpxApprAdapter = new GpxAppearanceAdapter(activity,
									gpxAppearanceParams.containsKey(CURRENT_TRACK_COLOR_ATTR) ? gpxAppearanceParams.get(CURRENT_TRACK_COLOR_ATTR) : prefColor.get(),
									GpxAppearanceAdapter.GpxAppearanceAdapterType.TRACK_WIDTH_COLOR);
							popup.setAdapter(gpxApprAdapter);
							popup.setOnItemClickListener(new AdapterView.OnItemClickListener() {

								@Override
								public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
									AppearanceListItem item = gpxApprAdapter.getItem(position);
									if (item != null) {
										if (item.getAttrName() == CURRENT_TRACK_WIDTH_ATTR) {
											gpxAppearanceParams.put(CURRENT_TRACK_WIDTH_ATTR, item.getValue());
										} else if (item.getAttrName() == CURRENT_TRACK_COLOR_ATTR) {
											gpxAppearanceParams.put(CURRENT_TRACK_COLOR_ATTR, item.getValue());
										}
									}
									popup.dismiss();
									updateAppearanceTitle(activity, app, trackWidthProp, renderer,
											apprTitleView,
											gpxAppearanceParams.containsKey(CURRENT_TRACK_WIDTH_ATTR) ? gpxAppearanceParams.get(CURRENT_TRACK_WIDTH_ATTR) : prefWidth.get(),
											gpxAppearanceParams.containsKey(CURRENT_TRACK_COLOR_ATTR) ? gpxAppearanceParams.get(CURRENT_TRACK_COLOR_ATTR) : prefColor.get());
								}
							});
							popup.show();
						}
					});
					builder.setCustomTitle(apprTitleView);
				}
			} else {
				builder.setTitle(R.string.show_gpx);
			}
			builder.setPositiveButton(R.string.shared_string_ok, new OnClickListener() {

				@Override
				public void onClick(DialogInterface dialog, int which) {
					if (gpxAppearanceParams.size() > 0) {
						for (Map.Entry<String, String> entry : gpxAppearanceParams.entrySet()) {
							final OsmandSettings.CommonPreference<String> pref
									= app.getSettings().getCustomRenderProperty(entry.getKey());
							pref.set(entry.getValue());
						}
						if (activity instanceof MapActivity) {
							ConfigureMapMenu.refreshMapComplete((MapActivity) activity);
						}
					}
					GPXFile currentGPX = null;
					//clear all previously selected files before adding new one
					OsmandApplication app = (OsmandApplication) activity.getApplication();
					if (app != null && app.getSelectedGpxHelper() != null) {
						app.getSelectedGpxHelper().clearAllGpxFileToShow();
					}
					if (app != null && showCurrentGpx && adapter.getItem(0).getSelected()) {
						currentGPX = app.getSavingTrackHelper().getCurrentGpx();
					}
					List<String> s = new ArrayList<>();
					for (int i = (showCurrentGpx ? 1 : 0); i < adapter.length(); i++) {
						if (adapter.getItem(i).getSelected()) {
							s.add(list.get(i).getFileName());
						}
					}
					dialog.dismiss();
					loadGPXFileInDifferentThread(activity, callbackWithObject, dir, currentGPX,
							s.toArray(new String[s.size()]));
				}
			});
			builder.setNegativeButton(R.string.shared_string_cancel, null);
			if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT
					&& list.size() > 1 || !showCurrentGpx && list.size() > 0) {
				builder.setNeutralButton(R.string.gpx_add_track, null);
			}
		}

		final AlertDialog dlg = builder.create();
		dlg.setCanceledOnTouchOutside(true);
		if (list.size() == 0 || showCurrentGpx && list.size() == 1) {
			final View footerView = activity.getLayoutInflater().inflate(R.layout.no_gpx_files_list_footer, null);
			TextView descTextView = (TextView)footerView.findViewById(R.id.descFolder);
			String descPrefix = app.getString(R.string.gpx_no_tracks_title_folder);
			SpannableString spannableDesc = new SpannableString(descPrefix + ": " + dir.getAbsolutePath());
			spannableDesc.setSpan(new StyleSpan(android.graphics.Typeface.BOLD),
					descPrefix.length() + 1, spannableDesc.length(), 0);
			descTextView.setText(spannableDesc);
			if (Build.VERSION.SDK_INT < Build.VERSION_CODES.KITKAT) {
				footerView.findViewById(R.id.button).setVisibility(View.GONE);
			} else {
				footerView.findViewById(R.id.button).setOnClickListener(new View.OnClickListener() {
					@Override
					public void onClick(View v) {
						addTrack(activity, dlg);
					}
				});
			}
			dlg.getListView().addFooterView(footerView, null, false);
		}
		dlg.getListView().setOnItemClickListener(new OnItemClickListener() {
			@Override
			public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
				if (multipleChoice) {
					ContextMenuItem item = adapter.getItem(position);
					item.setSelected(!item.getSelected());
					listAdapter.notifyDataSetInvalidated();
					if (position == 0 && showCurrentGpx && item.getSelected()) {
						OsmandMonitoringPlugin monitoringPlugin = OsmandPlugin.getEnabledPlugin(OsmandMonitoringPlugin.class);
						if (monitoringPlugin == null) {
							AlertDialog.Builder confirm = new AlertDialog.Builder(activity);
							confirm.setPositiveButton(R.string.shared_string_ok, new DialogInterface.OnClickListener() {
								@Override
								public void onClick(DialogInterface dialog, int which) {
									Intent intent = new Intent(activity, PluginActivity.class);
									intent.putExtra(PluginActivity.EXTRA_PLUGIN_ID, OsmandMonitoringPlugin.ID);
									activity.startActivity(intent);
								}
							});
							confirm.setNegativeButton(R.string.shared_string_cancel, null);
							confirm.setMessage(activity.getString(R.string.enable_plugin_monitoring_services));
							confirm.show();
						} else if (!app.getSettings().SAVE_GLOBAL_TRACK_TO_GPX.get()) {
							monitoringPlugin.controlDialog(activity, false);
						}
					}
				} else {
					dlg.dismiss();
					if (showCurrentGpx && position == 0) {
						callbackWithObject.processResult(null);
					} else {
						String fileName = list.get(position).getFileName();
						SelectedGpxFile selectedGpxFile =
								app.getSelectedGpxHelper().getSelectedFileByName(fileName);
						if (selectedGpxFile != null) {
							callbackWithObject.processResult(new GPXFile[]{selectedGpxFile.getGpxFile()});
						} else {
							loadGPXFileInDifferentThread(activity, callbackWithObject, dir, null, fileName);
						}
					}
				}
			}
		});
		dlg.setOnShowListener(new DialogInterface.OnShowListener() {
			@Override
			public void onShow(DialogInterface dialog) {
				Button addTrackButton = ((AlertDialog) dialog).getButton(AlertDialog.BUTTON_NEUTRAL);
				if (addTrackButton != null) {
					addTrackButton.setOnClickListener(new View.OnClickListener() {
						@Override
						public void onClick(View v) {
							addTrack(activity, dlg);
						}
					});
				}
			}
		});
		dlg.show();
		try {
			dlg.getListView().setFastScrollEnabled(true);
		} catch (Exception e) {
			// java.lang.ClassCastException: com.android.internal.widget.RoundCornerListAdapter
			// Unknown reason but on some devices fail
		}
		return dlg;
	}

	public static void updateGpxInfoView(View v, String itemTitle, GPXInfo info, GpxDataItem dataItem, boolean currentlyRecordingTrack, OsmandApplication app) {
		TextView viewName = ((TextView) v.findViewById(R.id.name));
		viewName.setText(itemTitle.replace("/", "  ").trim());
		ImageView icon = (ImageView) v.findViewById(R.id.icon);
		icon.setVisibility(View.GONE);
		//icon.setImageDrawable(app.getIconsCache().getThemedIcon(R.drawable.ic_action_polygom_dark));
		viewName.setTypeface(Typeface.DEFAULT, Typeface.NORMAL);

		GPXTrackAnalysis analysis = null;
		if (currentlyRecordingTrack) {
			analysis = app.getSavingTrackHelper().getCurrentTrack().getTrackAnalysis();
		} else if (dataItem != null) {
			analysis = dataItem.getAnalysis();
		}

		boolean sectionRead = analysis == null;
		if (sectionRead) {
			v.findViewById(R.id.read_section).setVisibility(View.GONE);
			v.findViewById(R.id.unknown_section).setVisibility(View.VISIBLE);
			String date = "";
			String size = "";
			if (info.getFileSize() >= 0) {
				if (info.getFileSize() > (100 * (1 << 10))) {
					size = formatMb.format(new Object[]{(float) info.getFileSize() / (1 << 20)});
				} else {
					size = formatKb.format(new Object[]{(float) info.getFileSize() / (1 << 10)});
				}
			}
			DateFormat df = app.getResourceManager().getDateFormat();
			long fd = info.getLastModified();
			if (fd > 0) {
				date = (df.format(new Date(fd)));
			}
			TextView sizeText = (TextView) v.findViewById(R.id.date_and_size_details);
			sizeText.setText(date + " \u2022 " + size);

		} else {
			v.findViewById(R.id.read_section).setVisibility(View.VISIBLE);
			v.findViewById(R.id.unknown_section).setVisibility(View.GONE);
			ImageView distanceI = (ImageView) v.findViewById(R.id.distance_icon);
			distanceI.setVisibility(View.VISIBLE);
			distanceI.setImageDrawable(app.getUIUtilities().getThemedIcon(R.drawable.ic_small_distance));
			ImageView pointsI = (ImageView) v.findViewById(R.id.points_icon);
			pointsI.setVisibility(View.VISIBLE);
			pointsI.setImageDrawable(app.getUIUtilities().getThemedIcon(R.drawable.ic_small_point));
			ImageView timeI = (ImageView) v.findViewById(R.id.time_icon);
			timeI.setVisibility(View.VISIBLE);
			timeI.setImageDrawable(app.getUIUtilities().getThemedIcon(R.drawable.ic_small_time));
			TextView time = (TextView) v.findViewById(R.id.time);
			TextView distance = (TextView) v.findViewById(R.id.distance);
			TextView pointsCount = (TextView) v.findViewById(R.id.points_count);
			pointsCount.setText(analysis.wptPoints + "");
			distance.setText(OsmAndFormatter.getFormattedDistance(analysis.totalDistance, app));

			if (analysis.isTimeSpecified()) {
				time.setText(Algorithms.formatDuration((int) (analysis.timeSpan / 1000), app.accessibilityEnabled()) + "");
			} else {
				time.setText("");
			}
		}

		TextView descr = ((TextView) v.findViewById(R.id.description));
		descr.setVisibility(View.GONE);

		v.findViewById(R.id.check_item).setVisibility(View.GONE);
	}

	@TargetApi(Build.VERSION_CODES.KITKAT)
	private static void addTrack(final Activity activity, final AlertDialog dialog) {
		if (activity instanceof MapActivity) {
			final MapActivity mapActivity = (MapActivity) activity;
			ActivityResultListener listener = new ActivityResultListener(OPEN_GPX_DOCUMENT_REQUEST, new OnActivityResultListener() {
				@Override
				public void onResult(int resultCode, Intent resultData) {
					if (resultCode == Activity.RESULT_OK) {
						if (resultData != null) {
							Uri uri = resultData.getData();
							if (mapActivity.getImportHelper().handleGpxImport(uri, false)) {
								dialog.dismiss();
							}
						}
					}
				}
			});

			Intent intent = new Intent(Intent.ACTION_OPEN_DOCUMENT);
			//intent.addCategory(Intent.CATEGORY_OPENABLE);
			//intent.setType("application/gpx+xml");
			//intent.setType("text/plain");
			//intent.setType("text/xml");
			intent.setType("*/*");
			mapActivity.registerActivityResultListener(listener);
			activity.startActivityForResult(intent, OPEN_GPX_DOCUMENT_REQUEST);
		}
	}

	private static void updateAppearanceTitle(Activity activity, OsmandApplication app,
											  RenderingRuleProperty trackWidthProp,
											  RenderingRulesStorage renderer,
											  View apprTitleView,
											  String prefWidthValue,
											  String prefColorValue) {
		TextView widthTextView = (TextView) apprTitleView.findViewById(R.id.widthTitle);
		ImageView colorImageView = (ImageView) apprTitleView.findViewById(R.id.colorImage);
		if (Algorithms.isEmpty(prefWidthValue)) {
			widthTextView.setText(SettingsActivity.getStringPropertyValue(activity, trackWidthProp.getDefaultValueDescription()));
		} else {
			widthTextView.setText(SettingsActivity.getStringPropertyValue(activity, prefWidthValue));
		}
		int color = GpxAppearanceAdapter.parseTrackColor(renderer, prefColorValue);
		if (color == -1) {
			colorImageView.setImageDrawable(app.getUIUtilities().getThemedIcon(R.drawable.ic_action_circle));
		} else {
			colorImageView.setImageDrawable(app.getUIUtilities().getPaintedIcon(R.drawable.ic_action_circle, color));
		}
	}

	public static List<GPXInfo> getSortedGPXFilesInfoByDate(File dir, boolean absolutePath) {
		final List<GPXInfo> list = new ArrayList<>();
		readGpxDirectory(dir, list, "", absolutePath);
		Collections.sort(list, new Comparator<GPXInfo>() {
			@Override
			public int compare(GPXInfo object1, GPXInfo object2) {
				long lhs = object1.getLastModified();
				long rhs = object2.getLastModified();
				return lhs < rhs ? 1 : (lhs == rhs ? 0 : -1);
			}
		});
		return list;
	}


	public static List<GPXInfo> getSortedGPXFilesInfo(File dir, final List<String> selectedGpxList, boolean absolutePath) {
		final List<GPXInfo> list = new ArrayList<>();
		readGpxDirectory(dir, list, "", absolutePath);
		if (selectedGpxList != null) {
			for (GPXInfo info : list) {
				for (String fileName : selectedGpxList) {
					if (fileName.endsWith(info.getFileName())) {
						info.setSelected(true);
						break;
					}
				}
			}
		}
		Collections.sort(list, new Comparator<GPXInfo>() {
			@Override
			public int compare(GPXInfo i1, GPXInfo i2) {
				int res = i1.isSelected() == i2.isSelected() ? 0 : i1.isSelected() ? -1 : 1;
				if (res != 0) {
					return res;
				}

				String name1 = i1.getFileName();
				String name2 = i2.getFileName();
				int d1 = depth(name1);
				int d2 = depth(name2);
				if (d1 != d2) {
					return d1 - d2;
				}
				int lastSame = 0;
				for (int i = 0; i < name1.length() && i < name2.length(); i++) {
					if (name1.charAt(i) != name2.charAt(i)) {
						break;
					}
					if (name1.charAt(i) == '/') {
						lastSame = i + 1;
					}
				}

				boolean isDigitStarts1 = isLastSameStartsWithDigit(name1, lastSame);
				boolean isDigitStarts2 = isLastSameStartsWithDigit(name2, lastSame);
				res = isDigitStarts1 == isDigitStarts2 ? 0 : isDigitStarts1 ? -1 : 1;
				if (res != 0) {
					return res;
				}
				if (isDigitStarts1) {
					return -name1.compareToIgnoreCase(name2);
				}
				return name1.compareToIgnoreCase(name2);
			}

			private int depth(String name1) {
				int d = 0;
				for (int i = 0; i < name1.length(); i++) {
					if (name1.charAt(i) == '/') {
						d++;
					}
				}
				return d;
			}

			private boolean isLastSameStartsWithDigit(String name1, int lastSame) {
				if (name1.length() > lastSame) {
					return Character.isDigit(name1.charAt(lastSame));
				}

				return false;
			}
		});
		return list;
	}

	private static void readGpxDirectory(File dir, final List<GPXInfo> list, String parent,
										 boolean absolutePath) {
		if (dir != null && dir.canRead()) {
			File[] files = dir.listFiles();
			if (files != null) {
				for (File f : files) {
					if (f.getName().toLowerCase().endsWith(".gpx")) { //$NON-NLS-1$
						list.add(new GPXInfo(absolutePath ? f.getAbsolutePath() :
								parent + f.getName(), f.lastModified(), f.length()));
					} else if (f.isDirectory()) {
						readGpxDirectory(f, list, parent + f.getName() + "/", absolutePath);
					}
				}
			}
		}
	}

	private static void loadGPXFileInDifferentThread(final Activity activity, final CallbackWithObject<GPXFile[]> callbackWithObject,
													 final File dir, final GPXFile currentFile, final String... filename) {
		final ProgressDialog dlg = ProgressDialog.show(activity, activity.getString(R.string.loading_smth, ""),
				activity.getString(R.string.loading_data));
		new Thread(new Runnable() {
			@Override
			public void run() {
				final GPXFile[] result = new GPXFile[filename.length + (currentFile == null ? 0 : 1)];
				int k = 0;
				String w = "";
				if (currentFile != null) {
					result[k++] = currentFile;
				}
				for (String fname : filename) {
					final File f = new File(dir, fname);
					GPXFile res = GPXUtilities.loadGPXFile(f);
					if (res.error != null && res.error.getMessage().length() > 0) {
						w += res.error.getMessage() + "\n";
					}
					result[k++] = res;
				}
				dlg.dismiss();
				final String warn = w;
				activity.runOnUiThread(new Runnable() {
					@Override
					public void run() {
						if (warn.length() > 0) {
							Toast.makeText(activity, warn, Toast.LENGTH_LONG).show();
						} else {
							callbackWithObject.processResult(result);
						}
					}
				});
			}

		}, "Loading gpx").start(); //$NON-NLS-1$
	}

	public static void setupGPXChart(OsmandApplication ctx, LineChart mChart, int yLabelsCount) {
		OsmandSettings settings = ctx.getSettings();
		setupGPXChart(mChart, yLabelsCount, 24f, 16f, settings.isLightContent(), true);
	}

	public static void setupGPXChart(LineChart mChart, int yLabelsCount, float topOffset, float bottomOffset, boolean light, boolean useGesturesAndScale) {
		if (android.os.Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
			mChart.setHardwareAccelerationEnabled(false);
		} else {
			mChart.setHardwareAccelerationEnabled(true);
		}
		mChart.setTouchEnabled(useGesturesAndScale);
		mChart.setDragEnabled(useGesturesAndScale);
		mChart.setScaleEnabled(useGesturesAndScale);
		mChart.setPinchZoom(useGesturesAndScale);
		mChart.setScaleYEnabled(false);
		mChart.setAutoScaleMinMaxEnabled(true);
		mChart.setDrawBorders(false);
		mChart.getDescription().setEnabled(false);
		mChart.setMaxVisibleValueCount(10);
		mChart.setMinOffset(0f);
		mChart.setDragDecelerationEnabled(false);

		mChart.setExtraTopOffset(topOffset);
		mChart.setExtraBottomOffset(bottomOffset);

		// create a custom MarkerView (extend MarkerView) and specify the layout
		// to use for it
		GPXMarkerView mv = new GPXMarkerView(mChart.getContext());
		mv.setChartView(mChart); // For bounds control
		mChart.setMarker(mv); // Set the marker to the chart
		mChart.setDrawMarkers(true);

		XAxis xAxis = mChart.getXAxis();
		xAxis.setDrawAxisLine(false);
		xAxis.setDrawGridLines(true);
		xAxis.setGridLineWidth(1.5f);
		xAxis.setGridColor(ActivityCompat.getColor(mChart.getContext(), R.color.gpx_chart_black_grid));
		xAxis.enableGridDashedLine(25f, Float.MAX_VALUE, 0f);
		xAxis.setPosition(BOTTOM);
		xAxis.setTextColor(light ? mChart.getResources().getColor(R.color.secondary_text_light) : mChart.getResources().getColor(R.color.secondary_text_dark));

		YAxis yAxis = mChart.getAxisLeft();
		yAxis.enableGridDashedLine(10f, 5f, 0f);
		yAxis.setGridColor(ActivityCompat.getColor(mChart.getContext(), R.color.divider_color));
		yAxis.setDrawAxisLine(false);
		yAxis.setPosition(YAxis.YAxisLabelPosition.INSIDE_CHART);
		yAxis.setXOffset(16f);
		yAxis.setYOffset(-6f);
		yAxis.setLabelCount(yLabelsCount);
		yAxis.setTextColor(light ? mChart.getResources().getColor(R.color.secondary_text_light) : mChart.getResources().getColor(R.color.secondary_text_dark));

		yAxis = mChart.getAxisRight();
		yAxis.enableGridDashedLine(10f, 5f, 0f);
		yAxis.setGridColor(ActivityCompat.getColor(mChart.getContext(), R.color.divider_color));
		yAxis.setDrawAxisLine(false);
		yAxis.setPosition(YAxis.YAxisLabelPosition.INSIDE_CHART);
		yAxis.setXOffset(16f);
		yAxis.setYOffset(-6f);
		yAxis.setLabelCount(yLabelsCount);
		yAxis.setTextColor(light ? mChart.getResources().getColor(R.color.secondary_text_light) : mChart.getResources().getColor(R.color.secondary_text_dark));
		yAxis.setEnabled(false);

		Legend legend = mChart.getLegend();
		legend.setEnabled(false);
	}

	private static float setupAxisDistance(OsmandApplication ctx, AxisBase axisBase, float meters) {
		OsmandSettings settings = ctx.getSettings();
		OsmandSettings.MetricsConstants mc = settings.METRIC_SYSTEM.get();
		float divX;

		String format1 = "{0,number,0.#} ";
		String format2 = "{0,number,0.##} ";
		String fmt = null;
		float granularity = 1f;
		int mainUnitStr;
		float mainUnitInMeters;
		if (mc == OsmandSettings.MetricsConstants.KILOMETERS_AND_METERS) {
			mainUnitStr = R.string.km;
			mainUnitInMeters = METERS_IN_KILOMETER;
		} else if (mc == OsmandSettings.MetricsConstants.NAUTICAL_MILES) {
			mainUnitStr = R.string.nm;
			mainUnitInMeters = METERS_IN_ONE_NAUTICALMILE;
		} else {
			mainUnitStr = R.string.mile;
			mainUnitInMeters = METERS_IN_ONE_MILE;
		}
		if (meters > 9.99f * mainUnitInMeters) {
			fmt = format1;
			granularity = .1f;
		}
		if (meters >= 100 * mainUnitInMeters ||
				meters > 9.99f * mainUnitInMeters ||
				meters > 0.999f * mainUnitInMeters ||
				mc == OsmandSettings.MetricsConstants.MILES_AND_FEET && meters > 0.249f * mainUnitInMeters ||
				mc == OsmandSettings.MetricsConstants.MILES_AND_METERS && meters > 0.249f * mainUnitInMeters ||
				mc == OsmandSettings.MetricsConstants.MILES_AND_YARDS && meters > 0.249f * mainUnitInMeters ||
				mc == OsmandSettings.MetricsConstants.NAUTICAL_MILES && meters > 0.99f * mainUnitInMeters) {

			divX = mainUnitInMeters;
			if (fmt == null) {
				fmt = format2;
				granularity = .01f;
			}
		} else {
			fmt = null;
			granularity = 1f;
			if (mc == OsmandSettings.MetricsConstants.KILOMETERS_AND_METERS || mc == OsmandSettings.MetricsConstants.MILES_AND_METERS) {
				divX = 1f;
				mainUnitStr = R.string.m;
			} else if (mc == OsmandSettings.MetricsConstants.MILES_AND_FEET) {
				divX = 1f / FEET_IN_ONE_METER;
				mainUnitStr = R.string.foot;
			} else if (mc == OsmandSettings.MetricsConstants.MILES_AND_YARDS) {
				divX = 1f / YARDS_IN_ONE_METER;
				mainUnitStr = R.string.yard;
			} else {
				divX = 1f;
				mainUnitStr = R.string.m;
			}
		}

		final String formatX = fmt;
		final String mainUnitX = ctx.getString(mainUnitStr);

		axisBase.setGranularity(granularity);
		axisBase.setValueFormatter(new IAxisValueFormatter() {

			@Override
			public String getFormattedValue(float value, AxisBase axis) {
				if (!Algorithms.isEmpty(formatX)) {
					return MessageFormat.format(formatX + mainUnitX, value);
				} else {
					return (int)value + " " + mainUnitX;
				}
			}
		});

		return divX;
	}

	private static float setupXAxisTime(XAxis xAxis, long timeSpan) {

		final boolean useHours = timeSpan / 3600000 > 0;
		xAxis.setGranularity(1f);
		xAxis.setValueFormatter(new IAxisValueFormatter() {

			@Override
			public String getFormattedValue(float value, AxisBase axis) {
				int seconds = (int)value;
				if (useHours) {
					int hours = seconds / (60 * 60);
					int minutes = (seconds / 60) % 60;
					int sec = seconds % 60;
					return hours + ":" + (minutes < 10 ? "0" + minutes : minutes) + ":" + (sec < 10 ? "0" + sec : sec);
				} else {
					int minutes = (seconds / 60) % 60;
					int sec = seconds % 60;
					return (minutes < 10 ? "0" + minutes : minutes) + ":" + (sec < 10 ? "0" + sec : sec);
				}
			}
		});

		return 1f;
	}

	private static List<Entry> calculateElevationArray(GPXTrackAnalysis analysis, GPXDataSetAxisType axisType,
													   float divX, float convEle) {
		List<Entry> values = new ArrayList<>();
		List<Elevation> elevationData = analysis.elevationData;
		float nextX = 0;
		float nextY;
		float elev;
		float prevElevOrig = -80000;
		float prevElev = 0;
		int i = -1;
		int lastIndex = elevationData.size() - 1;
		Entry lastEntry = null;
		float lastXSameY = -1;
		boolean hasSameY = false;
		float x;
		for (Elevation e : elevationData) {
			i++;
			x = axisType == GPXDataSetAxisType.TIME ? e.time : e.distance;
			if (x > 0) {
				nextX += x / divX;
				if (!Float.isNaN(e.elevation)) {
					elev = e.elevation;
					if (prevElevOrig != -80000) {
						if (elev > prevElevOrig) {
							elev -= 1f;
						} else if (prevElevOrig == elev && i < lastIndex) {
							hasSameY = true;
							lastXSameY = nextX;
							continue;
						}
						if (prevElev == elev && i < lastIndex) {
							hasSameY = true;
							lastXSameY = nextX;
							continue;
						}
						if (hasSameY) {
							values.add(new Entry(lastXSameY, lastEntry.getY()));
						}
						hasSameY = false;
					}
					prevElevOrig = e.elevation;
					prevElev = elev;
					nextY = elev * convEle;
					lastEntry = new Entry(nextX, nextY);
					values.add(lastEntry);
				}
			}
		}
		return values;
	}

	public static void setupHorizontalGPXChart(HorizontalBarChart chart, int yLabelsCount, float topOffset, float bottomOffset, boolean useGesturesAndScale) {
		if (android.os.Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
			chart.setHardwareAccelerationEnabled(false);
		} else {
			chart.setHardwareAccelerationEnabled(true);
		}
		chart.setTouchEnabled(useGesturesAndScale);
		chart.setDragEnabled(useGesturesAndScale);
		chart.setScaleYEnabled(false);
		chart.setAutoScaleMinMaxEnabled(true);
		chart.setDrawBorders(false);
		chart.getDescription().setEnabled(false);
		chart.setDragDecelerationEnabled(false);

		chart.setExtraTopOffset(topOffset);
		chart.setExtraBottomOffset(bottomOffset);

		XAxis xl = chart.getXAxis();
		xl.setDrawLabels(false);
		xl.setEnabled(false);
		xl.setDrawAxisLine(false);
		xl.setDrawGridLines(false);

		YAxis yl = chart.getAxisLeft();
		yl.setLabelCount(yLabelsCount);
		yl.setDrawLabels(false);
		yl.setEnabled(false);
		yl.setDrawAxisLine(false);
		yl.setDrawGridLines(false);
		yl.setAxisMinimum(0f);

		YAxis yr = chart.getAxisRight();
		yr.setLabelCount(yLabelsCount);
		yr.setDrawAxisLine(false);
		yr.setDrawGridLines(false);
		yr.setAxisMinimum(0f);

		chart.setFitBars(true);

		Legend l = chart.getLegend();
		l.setEnabled(false);
	}

	public static <E> BarData buildStatisticChart(@NonNull OsmandApplication app,
	                                              @NonNull HorizontalBarChart mChart,
	                                              @NonNull RouteStatistics.Statistics<E> routeStatistics,
	                                              @NonNull GPXTrackAnalysis analysis,
	                                              boolean useRightAxis,
	                                              boolean nightMode) {

		XAxis xAxis = mChart.getXAxis();
		xAxis.setEnabled(false);

		YAxis yAxis;
		if (useRightAxis) {
			yAxis = mChart.getAxisRight();
			yAxis.setEnabled(true);
		} else {
			yAxis = mChart.getAxisLeft();
		}
		float divX = setupAxisDistance(app, yAxis, analysis.totalDistance);

		List<RouteStatistics.RouteSegmentAttribute<E>> segments = routeStatistics.getElements();
		List<BarEntry> entries = new ArrayList<>();
		float[] stacks = new float[segments.size()];
		int[] colors = new int[segments.size()];
		for (int i = 0; i < stacks.length; i++) {
			RouteStatistics.RouteSegmentAttribute segment = segments.get(i);
			stacks[i] = segment.getDistance() / divX;
			colors[i] = getColorFromRouteSegmentAttribute(app, segment, nightMode);
		}
		entries.add(new BarEntry(0, stacks));
		BarDataSet barDataSet = new BarDataSet(entries, "");
		barDataSet.setColors(colors);
		BarData dataSet = new BarData(barDataSet);
		dataSet.setDrawValues(false);

		mChart.getAxisRight().setAxisMaximum(dataSet.getYMax());
		mChart.getAxisLeft().setAxisMaximum(dataSet.getYMax());

		return dataSet;
	}

	public static int getColorFromRouteSegmentAttribute(OsmandApplication app, RouteStatistics.RouteSegmentAttribute segment, boolean nightMode) {
		String colorAttrName = segment.getColorAttrName();
		String colorName = segment.getColorName();
		int color = 0;
		if (colorName != null) {
			try {
				color = Color.parseColor(colorName);
			} catch (Exception e) {
			}
		} else if (colorAttrName != null) {
			color = GpxUiHelper.getColorFromStyle(app, colorAttrName, nightMode);
		}
		return color;
	}

	public static int getColorFromStyle(OsmandApplication app, String colorAttrName, boolean nightMode) {
		RenderingRulesStorage rrs = app.getRendererRegistry().getCurrentSelectedRenderer();
		RenderingRuleSearchRequest req = new RenderingRuleSearchRequest(rrs);
		req.setBooleanFilter(rrs.PROPS.R_NIGHT_MODE, nightMode);
		if (req.searchRenderingAttribute(colorAttrName)) {
			return req.getIntPropertyValue(rrs.PROPS.R_ATTR_COLOR_VALUE);
		}
		return 0;
	}

	public static OrderedLineDataSet createGPXElevationDataSet(@NonNull OsmandApplication ctx,
															   @NonNull LineChart mChart,
															   @NonNull GPXTrackAnalysis analysis,
															   @NonNull GPXDataSetAxisType axisType,
															   boolean useRightAxis,
															   boolean drawFilled) {
		OsmandSettings settings = ctx.getSettings();
		OsmandSettings.MetricsConstants mc = settings.METRIC_SYSTEM.get();
		boolean useFeet = (mc == OsmandSettings.MetricsConstants.MILES_AND_FEET) || (mc == OsmandSettings.MetricsConstants.MILES_AND_YARDS);
		boolean light = settings.isLightContent();
		final float convEle = useFeet ? 3.28084f : 1.0f;

		float divX;
		XAxis xAxis = mChart.getXAxis();
		if (axisType == GPXDataSetAxisType.TIME && analysis.isTimeSpecified()) {
			divX = setupXAxisTime(xAxis, analysis.timeSpan);
		} else {
			divX = setupAxisDistance(ctx, xAxis, analysis.totalDistance);
		}

		final String mainUnitY = useFeet ? ctx.getString(R.string.foot) : ctx.getString(R.string.m);

		YAxis yAxis;
		if (useRightAxis) {
			yAxis = mChart.getAxisRight();
			yAxis.setEnabled(true);
		} else {
			yAxis = mChart.getAxisLeft();
		}
		yAxis.setTextColor(ActivityCompat.getColor(mChart.getContext(), R.color.gpx_chart_blue_label));
		yAxis.setGridColor(ActivityCompat.getColor(mChart.getContext(), R.color.gpx_chart_blue_grid));
		yAxis.setGranularity(1f);
		yAxis.resetAxisMinimum();
		yAxis.setValueFormatter(new IAxisValueFormatter() {

			@Override
			public String getFormattedValue(float value, AxisBase axis) {
				return (int)value + " " + mainUnitY;
			}
		});

		List<Entry> values = calculateElevationArray(analysis, axisType, divX, convEle);

		OrderedLineDataSet dataSet = new OrderedLineDataSet(values, "", GPXDataSetType.ALTITUDE, axisType);
		dataSet.priority = (float) (analysis.avgElevation - analysis.minElevation) * convEle;
		dataSet.divX = divX;
		dataSet.mulY = convEle;
		dataSet.divY = Float.NaN;
		dataSet.units = mainUnitY;

		dataSet.setColor(ContextCompat.getColor(mChart.getContext(), R.color.gpx_chart_blue));
		dataSet.setLineWidth(1f);
		if (drawFilled) {
			dataSet.setFillAlpha(128);
			dataSet.setFillColor(ContextCompat.getColor(mChart.getContext(), R.color.gpx_chart_blue));
			dataSet.setDrawFilled(true);
		} else {
			dataSet.setDrawFilled(false);
		}

		dataSet.setDrawValues(false);
		dataSet.setValueTextSize(9f);
		dataSet.setFormLineWidth(1f);
		dataSet.setFormSize(15.f);

		dataSet.setDrawCircles(false);
		dataSet.setDrawCircleHole(false);

		dataSet.setHighlightEnabled(true);
		dataSet.setDrawVerticalHighlightIndicator(true);
		dataSet.setDrawHorizontalHighlightIndicator(false);
		dataSet.setHighLightColor(light ? mChart.getResources().getColor(R.color.secondary_text_light) : mChart.getResources().getColor(R.color.secondary_text_dark));

		//dataSet.setMode(LineDataSet.Mode.HORIZONTAL_BEZIER);

		dataSet.setFillFormatter(new IFillFormatter() {
			@Override
			public float getFillLinePosition(ILineDataSet dataSet, LineDataProvider dataProvider) {
				return dataProvider.getYChartMin();
			}
		});
		if (useRightAxis) {
			dataSet.setAxisDependency(YAxis.AxisDependency.RIGHT);
		}
		return dataSet;
	}

	public static OrderedLineDataSet createGPXSpeedDataSet(@NonNull OsmandApplication ctx,
														   @NonNull LineChart mChart,
														   @NonNull GPXTrackAnalysis analysis,
														   @NonNull GPXDataSetAxisType axisType,
														   boolean useRightAxis,
														   boolean drawFilled) {
		OsmandSettings settings = ctx.getSettings();
		boolean light = settings.isLightContent();

		float divX;
		XAxis xAxis = mChart.getXAxis();
		if (axisType == GPXDataSetAxisType.TIME && analysis.isTimeSpecified()) {
			divX = setupXAxisTime(xAxis, analysis.timeSpan);
		} else {
			divX = setupAxisDistance(ctx, xAxis, analysis.totalDistance);
		}

		OsmandSettings.SpeedConstants sps = settings.SPEED_SYSTEM.get();
		float mulSpeed = Float.NaN;
		float divSpeed = Float.NaN;
		final String mainUnitY = sps.toShortString(ctx);
		if (sps == OsmandSettings.SpeedConstants.KILOMETERS_PER_HOUR) {
			mulSpeed = 3.6f;
		} else if (sps == OsmandSettings.SpeedConstants.MILES_PER_HOUR) {
			mulSpeed = 3.6f * METERS_IN_KILOMETER / METERS_IN_ONE_MILE;
		} else if (sps == OsmandSettings.SpeedConstants.NAUTICALMILES_PER_HOUR) {
			mulSpeed = 3.6f * METERS_IN_KILOMETER / METERS_IN_ONE_NAUTICALMILE;
		} else if (sps == OsmandSettings.SpeedConstants.MINUTES_PER_KILOMETER) {
			divSpeed = METERS_IN_KILOMETER / 60;
		} else if (sps == OsmandSettings.SpeedConstants.MINUTES_PER_MILE) {
			divSpeed = METERS_IN_ONE_MILE / 60;
		} else {
			mulSpeed = 1f;
		}

		YAxis yAxis;
		if (useRightAxis) {
			yAxis = mChart.getAxisRight();
			yAxis.setEnabled(true);
		} else {
			yAxis = mChart.getAxisLeft();
		}
		if (analysis.hasSpeedInTrack()) {
			yAxis.setTextColor(ActivityCompat.getColor(mChart.getContext(), R.color.gpx_chart_orange_label));
			yAxis.setGridColor(ActivityCompat.getColor(mChart.getContext(), R.color.gpx_chart_orange_grid));
		} else {
			yAxis.setTextColor(ActivityCompat.getColor(mChart.getContext(), R.color.gpx_chart_red_label));
			yAxis.setGridColor(ActivityCompat.getColor(mChart.getContext(), R.color.gpx_chart_red_grid));
		}

		yAxis.setAxisMinimum(0f);

		ArrayList<Entry> values = new ArrayList<>();
		List<Speed> speedData = analysis.speedData;
		float nextX = 0;
		float nextY;
		float x;
		for (Speed s : speedData) {
			x = axisType == GPXDataSetAxisType.TIME ? s.time : s.distance;
			if (x > 0) {
				if (axisType == GPXDataSetAxisType.TIME && x > 60) {
					values.add(new Entry(nextX + 1, 0));
					values.add(new Entry(nextX + x - 1, 0));
				}
				nextX += x / divX;
				if (Float.isNaN(divSpeed)) {
					nextY = s.speed * mulSpeed;
				} else {
					nextY = divSpeed / s.speed;
				}
				if (nextY < 0 || Float.isInfinite(nextY)) {
					nextY = 0;
				}
				values.add(new Entry(nextX, nextY));
			}
		}

		OrderedLineDataSet dataSet = new OrderedLineDataSet(values, "", GPXDataSetType.SPEED, axisType);

		String format = null;
		if (dataSet.getYMax() < 3) {
			format = "{0,number,0.#} ";
		}
		final String formatY = format;
		yAxis.setValueFormatter(new IAxisValueFormatter() {

			@Override
			public String getFormattedValue(float value, AxisBase axis) {
				if (!Algorithms.isEmpty(formatY)) {
					return MessageFormat.format(formatY + mainUnitY, value);
				} else {
					return (int)value + " " + mainUnitY;
				}
			}
		});

		if (Float.isNaN(divSpeed)) {
			dataSet.priority = analysis.avgSpeed * mulSpeed;
		} else {
			dataSet.priority = divSpeed / analysis.avgSpeed;
		}
		dataSet.divX = divX;
		if (Float.isNaN(divSpeed)) {
			dataSet.mulY = mulSpeed;
			dataSet.divY = Float.NaN;
		} else {
			dataSet.divY = divSpeed;
			dataSet.mulY = Float.NaN;
		}
		dataSet.units = mainUnitY;

		if (analysis.hasSpeedInTrack()) {
			dataSet.setColor(ContextCompat.getColor(mChart.getContext(), R.color.gpx_chart_orange));
		} else {
			dataSet.setColor(ContextCompat.getColor(mChart.getContext(), R.color.gpx_chart_red));
		}
		dataSet.setLineWidth(1f);
		if (drawFilled) {
			dataSet.setFillAlpha(128);
			if (analysis.hasSpeedInTrack()) {
				dataSet.setFillColor(ContextCompat.getColor(mChart.getContext(), R.color.gpx_chart_orange));
			} else {
				dataSet.setFillColor(ContextCompat.getColor(mChart.getContext(), R.color.gpx_chart_red));
			}
			dataSet.setDrawFilled(true);
		} else {
			dataSet.setDrawFilled(false);
		}
		dataSet.setDrawValues(false);
		dataSet.setValueTextSize(9f);
		dataSet.setFormLineWidth(1f);
		dataSet.setFormSize(15.f);

		dataSet.setDrawCircles(false);
		dataSet.setDrawCircleHole(false);

		dataSet.setHighlightEnabled(true);
		dataSet.setDrawVerticalHighlightIndicator(true);
		dataSet.setDrawHorizontalHighlightIndicator(false);
		dataSet.setHighLightColor(light ? mChart.getResources().getColor(R.color.secondary_text_light) : mChart.getResources().getColor(R.color.secondary_text_dark));

		//dataSet.setMode(LineDataSet.Mode.HORIZONTAL_BEZIER);

		if (useRightAxis) {
			dataSet.setAxisDependency(YAxis.AxisDependency.RIGHT);
		}
		return dataSet;
	}

	public static OrderedLineDataSet createGPXSlopeDataSet(@NonNull OsmandApplication ctx,
														   @NonNull LineChart mChart,
														   @NonNull GPXTrackAnalysis analysis,
														   @NonNull GPXDataSetAxisType axisType,
														   @Nullable List<Entry> eleValues,
														   boolean useRightAxis,
														   boolean drawFilled) {
		if (axisType == GPXDataSetAxisType.TIME) {
			return null;
		}
		OsmandSettings settings = ctx.getSettings();
		boolean light = settings.isLightContent();
		OsmandSettings.MetricsConstants mc = settings.METRIC_SYSTEM.get();
		boolean useFeet = (mc == OsmandSettings.MetricsConstants.MILES_AND_FEET) || (mc == OsmandSettings.MetricsConstants.MILES_AND_YARDS);
		final float convEle = useFeet ? 3.28084f : 1.0f;
		final float totalDistance = analysis.totalDistance;

		XAxis xAxis = mChart.getXAxis();
		float divX = setupAxisDistance(ctx, xAxis, analysis.totalDistance);

		final String mainUnitY = "%";

		YAxis yAxis;
		if (useRightAxis) {
			yAxis = mChart.getAxisRight();
			yAxis.setEnabled(true);
		} else {
			yAxis = mChart.getAxisLeft();
		}
		yAxis.setTextColor(ActivityCompat.getColor(mChart.getContext(), R.color.gpx_chart_green_label));
		yAxis.setGridColor(ActivityCompat.getColor(mChart.getContext(), R.color.gpx_chart_green_grid));
		yAxis.setGranularity(1f);
		yAxis.resetAxisMinimum();
		yAxis.setValueFormatter(new IAxisValueFormatter() {

			@Override
			public String getFormattedValue(float value, AxisBase axis) {
				return (int)value + " " + mainUnitY;
			}
		});

		List<Entry> values;
		if (eleValues == null) {
			values = calculateElevationArray(analysis, GPXDataSetAxisType.DISTANCE, 1f, 1f);
		} else {
			values = new ArrayList<>(eleValues.size());
			for (Entry e : eleValues) {
				values.add(new Entry(e.getX() * divX, e.getY() / convEle));
			}
		}

		if (values == null || values.size() == 0) {
			if (useRightAxis) {
				yAxis.setEnabled(false);
			}
			return null;
		}

		int lastIndex = values.size() - 1;

		double STEP = 5;

		double[] calculatedDist = new double[(int) (totalDistance / STEP) + 1];
		double[] calculatedH = new double[(int) (totalDistance / STEP) + 1];
		int nextW = 0;
		for (int k = 0; k < calculatedDist.length; k++) {
			if (k > 0) {
				calculatedDist[k] = calculatedDist[k - 1] + STEP;
			}
			while(nextW < lastIndex && calculatedDist[k] > values.get(nextW).getX()) {
				nextW ++;
			}
			double pd = nextW == 0 ? 0 : values.get(nextW - 1).getX();
			double ph = nextW == 0 ? values.get(0).getY() : values.get(nextW - 1).getY();
			calculatedH[k] = ph + (values.get(nextW).getY() - ph) / (values.get(nextW).getX() - pd) * (calculatedDist[k] - pd);
		}

		double SLOPE_PROXIMITY = 100;

		if (totalDistance - SLOPE_PROXIMITY < 0) {
			if (useRightAxis) {
				yAxis.setEnabled(false);
			}
			return null;
		}

		double[] calculatedSlopeDist = new double[(int) ((totalDistance - SLOPE_PROXIMITY) / STEP) + 1];
		double[] calculatedSlope = new double[(int) ((totalDistance - SLOPE_PROXIMITY) / STEP) + 1];

		int index = (int) ((SLOPE_PROXIMITY / STEP) / 2);
		for (int k = 0; k < calculatedSlopeDist.length; k++) {
			calculatedSlopeDist[k] = calculatedDist[index + k];
			calculatedSlope[k] = (calculatedH[ 2 * index + k] - calculatedH[k]) * 100 / SLOPE_PROXIMITY;
			if (Double.isNaN(calculatedSlope[k])) {
				calculatedSlope[k] = 0;
			}
		}

		List<Entry> slopeValues = new ArrayList<>(calculatedSlopeDist.length);
		float prevSlope = -80000;
		float slope;
		float x;
		float lastXSameY = 0;
		boolean hasSameY = false;
		Entry lastEntry = null;
		lastIndex = calculatedSlopeDist.length - 1;
		for (int i = 0; i < calculatedSlopeDist.length; i++) {
			x = (float) calculatedSlopeDist[i] / divX;
			slope = (float) calculatedSlope[i];
			if (prevSlope != -80000) {
				if (prevSlope == slope && i < lastIndex) {
					hasSameY = true;
					lastXSameY = x;
					continue;
				}
				if (hasSameY) {
					slopeValues.add(new Entry(lastXSameY, lastEntry.getY()));
				}
				hasSameY = false;
			}
			prevSlope = slope;
			lastEntry = new Entry(x, slope);
			slopeValues.add(lastEntry);
		}

		OrderedLineDataSet dataSet = new OrderedLineDataSet(slopeValues, "", GPXDataSetType.SLOPE, axisType);
		dataSet.divX = divX;
		dataSet.units = mainUnitY;

		dataSet.setColor(ContextCompat.getColor(mChart.getContext(), R.color.gpx_chart_green));
		dataSet.setLineWidth(1f);
		if (drawFilled) {
			dataSet.setFillAlpha(128);
			dataSet.setFillColor(ContextCompat.getColor(mChart.getContext(), R.color.gpx_chart_green));
			dataSet.setDrawFilled(true);
		} else {
			dataSet.setDrawFilled(false);
		}

		dataSet.setDrawValues(false);
		dataSet.setValueTextSize(9f);
		dataSet.setFormLineWidth(1f);
		dataSet.setFormSize(15.f);

		dataSet.setDrawCircles(false);
		dataSet.setDrawCircleHole(false);

		dataSet.setHighlightEnabled(true);
		dataSet.setDrawVerticalHighlightIndicator(true);
		dataSet.setDrawHorizontalHighlightIndicator(false);
		dataSet.setHighLightColor(light ? mChart.getResources().getColor(R.color.secondary_text_light) : mChart.getResources().getColor(R.color.secondary_text_dark));

		//dataSet.setMode(LineDataSet.Mode.HORIZONTAL_BEZIER);

		/*
		dataSet.setFillFormatter(new IFillFormatter() {
			@Override
			public float getFillLinePosition(ILineDataSet dataSet, LineDataProvider dataProvider) {
				return dataProvider.getYChartMin();
			}
		});
		*/
		if (useRightAxis) {
			dataSet.setAxisDependency(YAxis.AxisDependency.RIGHT);
		}
		return dataSet;
	}

	public enum GPXDataSetType {
		ALTITUDE(R.string.altitude, R.drawable.ic_action_altitude_average),
		SPEED(R.string.map_widget_speed, R.drawable.ic_action_speed),
		SLOPE(R.string.shared_string_slope, R.drawable.ic_action_altitude_ascent);

		private int stringId;
		private int imageId;

		private GPXDataSetType(int stringId, int imageId) {
			this.stringId = stringId;
			this.imageId = imageId;
		}

		public String getName(@NonNull Context ctx) {
			return ctx.getString(stringId);
		}

		public int getStringId() {
			return stringId;
		}

		public int getImageId() {
			return imageId;
		}

		public Drawable getImageDrawable(@NonNull OsmandApplication app) {
			return app.getUIUtilities().getThemedIcon(imageId);
		}

		public static String getName(@NonNull Context ctx, @NonNull GPXDataSetType[] types) {
			List<String> list = new ArrayList<>();
			for (GPXDataSetType type : types) {
				list.add(type.getName(ctx));
			}
			Collections.sort(list);
			StringBuilder sb = new StringBuilder();
			for (String s : list) {
				if (sb.length() > 0) {
					sb.append("/");
				}
				sb.append(s);
			}
			return sb.toString();
		}

		public static Drawable getImageDrawable(@NonNull OsmandApplication app, @NonNull GPXDataSetType[] types) {
			if (types.length > 0) {
				return types[0].getImageDrawable(app);
			} else {
				return null;
			}
		}
	}

	public enum GPXDataSetAxisType {
		DISTANCE(R.string.distance, R.drawable.ic_action_marker_dark),
		TIME(R.string.shared_string_time, R.drawable.ic_action_time);

		private int stringId;
		private int imageId;

		private GPXDataSetAxisType(int stringId, int imageId) {
			this.stringId = stringId;
			this.imageId = imageId;
		}

		public String getName(Context ctx) {
			return ctx.getString(stringId);
		}

		public int getStringId() {
			return stringId;
		}

		public int getImageId() {
			return imageId;
		}

		public Drawable getImageDrawable(OsmandApplication app) {
			return app.getUIUtilities().getThemedIcon(imageId);
		}
	}

	public static class OrderedLineDataSet extends LineDataSet {

		private GPXDataSetType dataSetType;
		private GPXDataSetAxisType dataSetAxisType;

		float priority;
		String units;
		float divX = 1f;
		float divY = 1f;
		float mulY = 1f;

		OrderedLineDataSet(List<Entry> yVals, String label, GPXDataSetType dataSetType, GPXDataSetAxisType dataSetAxisType) {
			super(yVals, label);
			this.dataSetType = dataSetType;
			this.dataSetAxisType = dataSetAxisType;
		}

		public GPXDataSetType getDataSetType() {
			return dataSetType;
		}

		public GPXDataSetAxisType getDataSetAxisType() {
			return dataSetAxisType;
		}

		public float getPriority() {
			return priority;
		}

		public float getDivX() {
			return divX;
		}

		public float getDivY() {
			return divY;
		}

		public float getMulY() {
			return mulY;
		}

		public String getUnits() {
			return units;
		}
	}

	@SuppressLint("ViewConstructor")
	private static class GPXMarkerView extends MarkerView {

		private View textAltView;
		private View textSpdView;
		private View textSlpView;

		public GPXMarkerView(Context context) {
			super(context, R.layout.chart_marker_view);
			textAltView = findViewById(R.id.text_alt_container);
			textSpdView = findViewById(R.id.text_spd_container);
			textSlpView = findViewById(R.id.text_slp_container);
		}

		// callbacks everytime the MarkerView is redrawn, can be used to update the
		// content (user-interface)
		@Override
		public void refreshContent(Entry e, Highlight highlight) {
			ChartData chartData = getChartView().getData();
			if (chartData.getDataSetCount() == 1) {
				OrderedLineDataSet dataSet = (OrderedLineDataSet) chartData.getDataSetByIndex(0);
				String value = Integer.toString((int) e.getY()) + " ";
				String units = dataSet.units;
				switch (dataSet.getDataSetType()) {
					case ALTITUDE:
						((TextView) textAltView.findViewById(R.id.text_alt_value)).setText(value);
						((TextView) textAltView.findViewById(R.id.text_alt_units)).setText(units);
						textAltView.setVisibility(VISIBLE);
						textSpdView.setVisibility(GONE);
						textSlpView.setVisibility(GONE);
						break;
					case SPEED:
						((TextView) textSpdView.findViewById(R.id.text_spd_value)).setTextColor(dataSet.getColor());
						((TextView) textSpdView.findViewById(R.id.text_spd_value)).setText(value);
						((TextView) textSpdView.findViewById(R.id.text_spd_units)).setText(units);
						textAltView.setVisibility(GONE);
						textSpdView.setVisibility(VISIBLE);
						textSlpView.setVisibility(GONE);
						break;
					case SLOPE:
						((TextView) textSlpView.findViewById(R.id.text_slp_value)).setText(value);
						textAltView.setVisibility(GONE);
						textSpdView.setVisibility(GONE);
						textSlpView.setVisibility(VISIBLE);
						break;
				}
				findViewById(R.id.divider).setVisibility(GONE);
			} else if (chartData.getDataSetCount() == 2) {
				OrderedLineDataSet dataSet1 = (OrderedLineDataSet) chartData.getDataSetByIndex(0);
				OrderedLineDataSet dataSet2 = (OrderedLineDataSet) chartData.getDataSetByIndex(1);
				int altSetIndex = -1;
				int spdSetIndex = -1;
				int slpSetIndex = -1;
				switch (dataSet1.getDataSetType()) {
					case ALTITUDE:
						altSetIndex = 0;
						break;
					case SPEED:
						spdSetIndex = 0;
						break;
					case SLOPE:
						slpSetIndex = 0;
						break;
				}
				switch (dataSet2.getDataSetType()) {
					case ALTITUDE:
						altSetIndex = 1;
						break;
					case SPEED:
						spdSetIndex = 1;
						break;
					case SLOPE:
						slpSetIndex = 1;
						break;
				}
				if (altSetIndex != -1) {
					float y = getInterpolatedY(altSetIndex == 0 ? dataSet1 : dataSet2, e);
					((TextView) textAltView.findViewById(R.id.text_alt_value)).setText(Integer.toString((int) y) + " ");
					((TextView) textAltView.findViewById(R.id.text_alt_units)).setText((altSetIndex == 0 ? dataSet1.units : dataSet2.units));
					textAltView.setVisibility(VISIBLE);
				} else {
					textAltView.setVisibility(GONE);
				}
				if (spdSetIndex != -1) {
					float y = getInterpolatedY(spdSetIndex == 0 ? dataSet1 : dataSet2, e);
					((TextView) textSpdView.findViewById(R.id.text_spd_value)).setTextColor((spdSetIndex == 0 ? dataSet1 : dataSet2).getColor());
					((TextView) textSpdView.findViewById(R.id.text_spd_value)).setText(Integer.toString((int) y) + " ");
					((TextView) textSpdView.findViewById(R.id.text_spd_units)).setText(spdSetIndex == 0 ? dataSet1.units : dataSet2.units);
					textSpdView.setVisibility(VISIBLE);
				} else {
					textSpdView.setVisibility(GONE);
				}
				if (slpSetIndex != -1) {
					float y = getInterpolatedY(slpSetIndex == 0 ? dataSet1 : dataSet2, e);
					((TextView) textSlpView.findViewById(R.id.text_slp_value)).setText(Integer.toString((int) y) + " ");
					textSlpView.setVisibility(VISIBLE);
				} else {
					textSlpView.setVisibility(GONE);
				}
				findViewById(R.id.divider).setVisibility(VISIBLE);
			} else {
				textAltView.setVisibility(GONE);
				textSpdView.setVisibility(GONE);
				textSlpView.setVisibility(GONE);
				findViewById(R.id.divider).setVisibility(GONE);
			}
			super.refreshContent(e, highlight);
		}

		private float getInterpolatedY(OrderedLineDataSet ds, Entry e) {
			if (ds.getEntryIndex(e) == -1) {
				Entry upEntry = ds.getEntryForXValue(e.getX(), Float.NaN, DataSet.Rounding.UP);
				Entry downEntry = upEntry;
				int upIndex = ds.getEntryIndex(upEntry);
				if (upIndex > 0) {
					downEntry = ds.getEntryForIndex(upIndex - 1);
				}
				return MapUtils.getInterpolatedY(downEntry.getX(), downEntry.getY(), upEntry.getX(), upEntry.getY(), e.getX());
			} else {
				return e.getY();
			}
		}

		@Override
		public MPPointF getOffset() {
			if (getChartView().getData().getDataSetCount() == 2) {
				int x = findViewById(R.id.divider).getLeft();
				return new MPPointF(-x - AndroidUtils.dpToPx(getContext(), .5f), 0);
			} else {
				return new MPPointF(-getWidth() / 2f, 0);
			}
		}

		@Override
		public MPPointF getOffsetForDrawingAtPoint(float posX, float posY) {
			int margin = AndroidUtils.dpToPx(getContext(), 3f);
			MPPointF offset = getOffset();
			offset.y = -posY;
			if (posX + offset.x - margin < 0) {
				offset.x -= (offset.x + posX - margin);
			}
			if (posX + offset.x + getWidth() + margin > getChartView().getWidth()) {
				offset.x -= (getWidth() - (getChartView().getWidth() - posX) + offset.x) + margin;
			}
			return offset;
		}
	}


	public static GPXFile makeGpxFromRoute(RouteCalculationResult route, OsmandApplication app) {
		double lastHeight = HEIGHT_UNDEFINED;
		GPXFile gpx = new GPXUtilities.GPXFile(Version.getFullVersion(app));
		List<Location> locations = route.getRouteLocations();
		if (locations != null) {
			GPXUtilities.Track track = new GPXUtilities.Track();
			GPXUtilities.TrkSegment seg = new GPXUtilities.TrkSegment();
			for (Location l : locations) {
				GPXUtilities.WptPt point = new GPXUtilities.WptPt();
				point.lat = l.getLatitude();
				point.lon = l.getLongitude();
				if (l.hasAltitude()) {
					gpx.hasAltitude = true;
					float h = (float) l.getAltitude();
					point.ele = h;
					if (lastHeight == HEIGHT_UNDEFINED && seg.points.size() > 0) {
						for (GPXUtilities.WptPt pt : seg.points) {
							if (Double.isNaN(pt.ele)) {
								pt.ele = h;
							}
						}
					}
					lastHeight = h;
				}
				seg.points.add(point);
			}
			track.segments.add(seg);
			gpx.tracks.add(track);
		}
		return gpx;
	}



	public static class GPXInfo {
		private String fileName;
		private long lastModified;
		private long fileSize;
		private boolean selected;

		public GPXInfo(String fileName, long lastModified, long fileSize) {
			this.fileName = fileName;
			this.lastModified = lastModified;
			this.fileSize = fileSize;
		}

		public String getFileName() {
			return fileName;
		}

		public long getLastModified() {
			return lastModified;
		}

		public long getFileSize() {
			return fileSize;
		}

		public boolean isSelected() {
			return selected;
		}

		public void setSelected(boolean selected) {
			this.selected = selected;
		}
	}
}
!@#$%
20190530_075859,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_a03780
package net.osmand.plus.helpers;

import android.annotation.SuppressLint;
import android.annotation.TargetApi;
import android.app.Activity;
import android.app.Application;
import android.app.ProgressDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.content.Intent;
import android.graphics.Typeface;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.os.Build;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.support.v4.app.ActivityCompat;
import android.support.v4.content.ContextCompat;
import android.support.v7.app.AlertDialog;
import android.support.v7.widget.ListPopupWindow;
import android.support.v7.widget.SwitchCompat;
import android.text.SpannableString;
import android.text.style.StyleSpan;
import android.util.TypedValue;
import android.view.Gravity;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.ArrayAdapter;
import android.widget.Button;
import android.widget.CheckBox;
import android.widget.CompoundButton;
import android.widget.CompoundButton.OnCheckedChangeListener;
import android.widget.ImageView;
import android.widget.TextView;
import android.widget.Toast;

import com.github.mikephil.charting.charts.LineChart;
import com.github.mikephil.charting.components.AxisBase;
import com.github.mikephil.charting.components.Legend;
import com.github.mikephil.charting.components.MarkerView;
import com.github.mikephil.charting.components.XAxis;
import com.github.mikephil.charting.components.YAxis;
import com.github.mikephil.charting.data.ChartData;
import com.github.mikephil.charting.data.DataSet;
import com.github.mikephil.charting.data.Entry;
import com.github.mikephil.charting.data.LineDataSet;
import com.github.mikephil.charting.formatter.IAxisValueFormatter;
import com.github.mikephil.charting.formatter.IFillFormatter;
import com.github.mikephil.charting.highlight.Highlight;
import com.github.mikephil.charting.interfaces.dataprovider.LineDataProvider;
import com.github.mikephil.charting.interfaces.datasets.ILineDataSet;
import com.github.mikephil.charting.utils.MPPointF;

import net.osmand.AndroidUtils;
import net.osmand.CallbackWithObject;
import net.osmand.IndexConstants;
import net.osmand.Location;
import net.osmand.plus.ContextMenuAdapter;
import net.osmand.plus.ContextMenuItem;
import net.osmand.plus.GPXDatabase.GpxDataItem;
import net.osmand.GPXUtilities;
import net.osmand.GPXUtilities.Elevation;
import net.osmand.GPXUtilities.GPXFile;
import net.osmand.GPXUtilities.GPXTrackAnalysis;
import net.osmand.GPXUtilities.Speed;
import net.osmand.GPXUtilities.TrkSegment;
import net.osmand.plus.GpxSelectionHelper.SelectedGpxFile;
import net.osmand.plus.OsmAndFormatter;
import net.osmand.plus.OsmandApplication;
import net.osmand.plus.OsmandPlugin;
import net.osmand.plus.OsmandSettings;
import net.osmand.plus.R;
import net.osmand.plus.UiUtilities;
import net.osmand.plus.Version;
import net.osmand.plus.activities.ActivityResultListener;
import net.osmand.plus.activities.ActivityResultListener.OnActivityResultListener;
import net.osmand.plus.activities.MapActivity;
import net.osmand.plus.activities.PluginActivity;
import net.osmand.plus.activities.SettingsActivity;
import net.osmand.plus.dialogs.ConfigureMapMenu;
import net.osmand.plus.dialogs.ConfigureMapMenu.AppearanceListItem;
import net.osmand.plus.dialogs.ConfigureMapMenu.GpxAppearanceAdapter;
import net.osmand.plus.monitoring.OsmandMonitoringPlugin;
import net.osmand.plus.routing.RouteCalculationResult;
import net.osmand.render.RenderingRuleProperty;
import net.osmand.render.RenderingRulesStorage;
import net.osmand.util.Algorithms;
import net.osmand.util.MapUtils;

import java.io.File;
import java.text.DateFormat;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static com.github.mikephil.charting.components.XAxis.XAxisPosition.BOTTOM;
import static net.osmand.binary.RouteDataObject.HEIGHT_UNDEFINED;
import static net.osmand.plus.OsmAndFormatter.FEET_IN_ONE_METER;
import static net.osmand.plus.OsmAndFormatter.METERS_IN_KILOMETER;
import static net.osmand.plus.OsmAndFormatter.METERS_IN_ONE_MILE;
import static net.osmand.plus.OsmAndFormatter.METERS_IN_ONE_NAUTICALMILE;
import static net.osmand.plus.OsmAndFormatter.YARDS_IN_ONE_METER;
import static net.osmand.plus.dialogs.ConfigureMapMenu.CURRENT_TRACK_COLOR_ATTR;
import static net.osmand.plus.dialogs.ConfigureMapMenu.CURRENT_TRACK_WIDTH_ATTR;
import static net.osmand.plus.download.DownloadActivity.formatKb;
import static net.osmand.plus.download.DownloadActivity.formatMb;

public class GpxUiHelper {

	private static final int OPEN_GPX_DOCUMENT_REQUEST = 1005;

	public static String getDescription(OsmandApplication app, GPXFile result, File f, boolean html) {
		GPXTrackAnalysis analysis = result.getAnalysis(f == null ? 0 : f.lastModified());
		return getDescription(app, analysis, html);
	}

	public static String getDescription(OsmandApplication app, TrkSegment t, boolean html) {
		return getDescription(app, GPXTrackAnalysis.segment(0, t), html);
	}


	public static String getColorValue(String clr, String value, boolean html) {
		if (!html) {
			return value;
		}
		return "<font color=\"" + clr + "\">" + value + "</font>";
	}

	public static String getColorValue(String clr, String value) {
		return getColorValue(clr, value, true);
	}

	public static String getDescription(OsmandApplication app, GPXTrackAnalysis analysis, boolean html) {
		StringBuilder description = new StringBuilder();
		String nl = html ? "<br/>" : "\n";
		String timeSpanClr = Algorithms.colorToString(ContextCompat.getColor(app, R.color.gpx_time_span_color));
		String distanceClr = Algorithms.colorToString(ContextCompat.getColor(app, R.color.gpx_distance_color));
		String speedClr = Algorithms.colorToString(ContextCompat.getColor(app, R.color.gpx_speed));
		String ascClr = Algorithms.colorToString(ContextCompat.getColor(app, R.color.gpx_altitude_asc));
		String descClr = Algorithms.colorToString(ContextCompat.getColor(app, R.color.gpx_altitude_desc));
		// OUTPUT:
		// 1. Total distance, Start time, End time
		description.append(app.getString(R.string.gpx_info_distance, getColorValue(distanceClr,
						OsmAndFormatter.getFormattedDistance(analysis.totalDistance, app), html),
				getColorValue(distanceClr, analysis.points + "", html)));
		if (analysis.totalTracks > 1) {
			description.append(nl).append(app.getString(R.string.gpx_info_subtracks, getColorValue(speedClr, analysis.totalTracks + "", html)));
		}
		if (analysis.wptPoints > 0) {
			description.append(nl).append(app.getString(R.string.gpx_info_waypoints, getColorValue(speedClr, analysis.wptPoints + "", html)));
		}
		if (analysis.isTimeSpecified()) {
			description.append(nl).append(app.getString(R.string.gpx_info_start_time, analysis.startTime));
			description.append(nl).append(app.getString(R.string.gpx_info_end_time, analysis.endTime));
		}

		// 2. Time span
		if (analysis.timeSpan > 0 && analysis.timeSpan / 1000 != analysis.timeMoving / 1000) {
			final String formatDuration = Algorithms.formatDuration((int) (analysis.timeSpan / 1000), app.accessibilityEnabled());
			description.append(nl).append(app.getString(R.string.gpx_timespan,
					getColorValue(timeSpanClr, formatDuration, html)));
		}

		// 3. Time moving, if any
		if (analysis.isTimeMoving()) {
				//Next few lines for Issue 3222 heuristic testing only
				//final String formatDuration0 = Algorithms.formatDuration((int) (analysis.timeMoving0 / 1000), app.accessibilityEnabled());
				//description.append(nl).append(app.getString(R.string.gpx_timemoving,
				//		getColorValue(timeSpanClr, formatDuration0, html)));
				//description.append(" (" + getColorValue(distanceClr, OsmAndFormatter.getFormattedDistance(analysis.totalDistanceMoving0, app), html) + ")");
			final String formatDuration = Algorithms.formatDuration((int) (analysis.timeMoving / 1000), app.accessibilityEnabled());
			description.append(nl).append(app.getString(R.string.gpx_timemoving,
					getColorValue(timeSpanClr, formatDuration, html)));
			description.append(" (" + getColorValue(distanceClr, OsmAndFormatter.getFormattedDistance(analysis.totalDistanceMoving, app), html) + ")");
		}

		// 4. Elevation, eleUp, eleDown, if recorded
		if (analysis.isElevationSpecified()) {
			description.append(nl);
			description.append(app.getString(R.string.gpx_info_avg_altitude,
					getColorValue(speedClr, OsmAndFormatter.getFormattedAlt(analysis.avgElevation, app), html)));
			description.append(nl);
			String min = getColorValue(descClr, OsmAndFormatter.getFormattedAlt(analysis.minElevation, app), html);
			String max = getColorValue(ascClr, OsmAndFormatter.getFormattedAlt(analysis.maxElevation, app), html);
			String asc = getColorValue(ascClr, OsmAndFormatter.getFormattedAlt(analysis.diffElevationUp, app), html);
			String desc = getColorValue(descClr, OsmAndFormatter.getFormattedAlt(analysis.diffElevationDown, app), html);
			description.append(app.getString(R.string.gpx_info_diff_altitude, min + " - " + max));
			description.append(nl);
			description.append(app.getString(R.string.gpx_info_asc_altitude, "\u2193 " + desc + "   \u2191 " + asc + ""));
		}


		if (analysis.isSpeedSpecified()) {
			String avg = getColorValue(speedClr, OsmAndFormatter.getFormattedSpeed(analysis.avgSpeed, app), html);
			String max = getColorValue(ascClr, OsmAndFormatter.getFormattedSpeed(analysis.maxSpeed, app), html);
			description.append(nl).append(app.getString(R.string.gpx_info_average_speed, avg));
			description.append(nl).append(app.getString(R.string.gpx_info_maximum_speed, max));
		}
		return description.toString();
	}

	public static AlertDialog selectGPXFiles(List<String> selectedGpxList, final Activity activity,
											 final CallbackWithObject<GPXFile[]> callbackWithObject) {
		OsmandApplication app = (OsmandApplication) activity.getApplication();
		final File dir = app.getAppPath(IndexConstants.GPX_INDEX_DIR);
		final List<GPXInfo> allGpxList = getSortedGPXFilesInfo(dir, selectedGpxList, false);
		if (allGpxList.isEmpty()) {
			Toast.makeText(activity, R.string.gpx_files_not_found, Toast.LENGTH_LONG).show();
		}
		allGpxList.add(0, new GPXInfo(activity.getString(R.string.show_current_gpx_title), 0, 0));

		final ContextMenuAdapter adapter = createGpxContextMenuAdapter(allGpxList, selectedGpxList, true);
		return createDialog(activity, true, true, true, callbackWithObject, allGpxList, adapter);
	}

	public static AlertDialog selectGPXFile(final Activity activity,
											final boolean showCurrentGpx, final boolean multipleChoice, final CallbackWithObject<GPXFile[]> callbackWithObject) {
		OsmandApplication app = (OsmandApplication) activity.getApplication();
		final File dir = app.getAppPath(IndexConstants.GPX_INDEX_DIR);
		final List<GPXInfo> list = getSortedGPXFilesInfo(dir, null, false);
		if (list.isEmpty()) {
			Toast.makeText(activity, R.string.gpx_files_not_found, Toast.LENGTH_LONG).show();
		}
		if (!list.isEmpty() || showCurrentGpx) {
			if (showCurrentGpx) {
				list.add(0, new GPXInfo(activity.getString(R.string.show_current_gpx_title), 0, 0));
			}

			final ContextMenuAdapter adapter = createGpxContextMenuAdapter(list, null, showCurrentGpx);
			return createDialog(activity, showCurrentGpx, multipleChoice, false, callbackWithObject, list, adapter);
		}
		return null;
	}

	public static AlertDialog selectSingleGPXFile(final Activity activity, boolean showCurrentGpx,
												  final CallbackWithObject<GPXFile[]> callbackWithObject) {
		OsmandApplication app = (OsmandApplication) activity.getApplication();
		int gpxDirLength = app.getAppPath(IndexConstants.GPX_INDEX_DIR).getAbsolutePath().length();
		List<SelectedGpxFile> selectedGpxFiles = app.getSelectedGpxHelper().getSelectedGPXFiles();
		final List<GPXInfo> list = new ArrayList<>(selectedGpxFiles.size() + 1);
		if (OsmandPlugin.getEnabledPlugin(OsmandMonitoringPlugin.class) == null) {
			showCurrentGpx = false;
		}
		if (!selectedGpxFiles.isEmpty() || showCurrentGpx) {
			if (showCurrentGpx) {
				list.add(new GPXInfo(activity.getString(R.string.shared_string_currently_recording_track), 0, 0));
			}

			for (SelectedGpxFile selectedGpx : selectedGpxFiles) {
				if (!selectedGpx.getGpxFile().showCurrentTrack) {
					list.add(new GPXInfo(selectedGpx.getGpxFile().path.substring(gpxDirLength + 1), selectedGpx.getGpxFile().modifiedTime, 0));
				}
			}

			final ContextMenuAdapter adapter = createGpxContextMenuAdapter(list, null, showCurrentGpx);
			return createSingleChoiceDialog(activity, showCurrentGpx, callbackWithObject, list, adapter);
		}
		return null;
	}

	private static ContextMenuAdapter createGpxContextMenuAdapter(List<GPXInfo> allGpxList,
																  List<String> selectedGpxList,
																  boolean showCurrentTrack) {
		final ContextMenuAdapter adapter = new ContextMenuAdapter();
		//element position in adapter
		int i = 0;
		for (GPXInfo gpxInfo : allGpxList) {
			String fileName = gpxInfo.getFileName();
			String s = getGpxTitle(fileName);

			adapter.addItem(ContextMenuItem.createBuilder(s).setSelected(false)
					.setIcon(R.drawable.ic_action_polygom_dark).createItem());

			//if there's some selected files - need to mark them as selected
			if (selectedGpxList != null) {
				updateSelection(selectedGpxList, showCurrentTrack, adapter, i, fileName);
			}
			i++;
		}
		return adapter;
	}

	public static String getGpxTitle(String fileName) {
		String s = fileName;
		if (s.toLowerCase().endsWith(".gpx")) {
			s = s.substring(0, s.length() - ".gpx".length());
		}
		s = s.replace('_', ' ');
		return s;
	}

	protected static void updateSelection(List<String> selectedGpxList, boolean showCurrentTrack,
										  final ContextMenuAdapter adapter, int position, String fileName) {
		ContextMenuItem item = adapter.getItem(position);
		if (position == 0 && showCurrentTrack) {
			if (selectedGpxList.contains("")) {
				item.setSelected(true);
			}
		} else {
			for (String file : selectedGpxList) {
				if (file.endsWith(fileName)) {
					item.setSelected(true);
					break;
				}
			}
		}
	}

	private static void setDescripionInDialog(final ArrayAdapter<?> adapter, final ContextMenuAdapter cmAdapter, Activity activity,
											  final File dir, String filename, final int position) {
		final Application app = activity.getApplication();
		final File f = new File(dir, filename);
		loadGPXFileInDifferentThread(activity, new CallbackWithObject<GPXUtilities.GPXFile[]>() {

			@Override
			public boolean processResult(GPXFile[] result) {
				ContextMenuItem item = cmAdapter.getItem(position);
				item.setTitle(item.getTitle() + "\n" + getDescription((OsmandApplication) app, result[0], f, false));
				adapter.notifyDataSetInvalidated();
				return true;
			}
		}, dir, null, filename);
	}

	private static AlertDialog createSingleChoiceDialog(final Activity activity,
											final boolean showCurrentGpx,
											final CallbackWithObject<GPXFile[]> callbackWithObject,
											final List<GPXInfo> list,
											final ContextMenuAdapter adapter) {
		final OsmandApplication app = (OsmandApplication) activity.getApplication();
		final UiUtilities iconsCache = app.getUIUtilities();
		final File dir = app.getAppPath(IndexConstants.GPX_INDEX_DIR);
		AlertDialog.Builder builder = new AlertDialog.Builder(activity);
		final int layout = R.layout.list_menu_item_native_singlechoice;

		final ArrayAdapter<String> listAdapter = new ArrayAdapter<String>(activity, layout, R.id.text1,
				adapter.getItemNames()) {
			@Override
			public View getView(final int position, View convertView, ViewGroup parent) {
				// User super class to create the View
				View v = convertView;
				if (v == null) {
					v = activity.getLayoutInflater().inflate(layout, null);
				}
				final ContextMenuItem item = adapter.getItem(position);
				TextView tv = (TextView) v.findViewById(R.id.text1);
				Drawable icon;
				if (showCurrentGpx && position == 0) {
					icon = null;
				} else {
					icon = iconsCache.getThemedIcon(item.getIcon());
				}
				tv.setCompoundDrawablePadding(AndroidUtils.dpToPx(activity, 10f));
				tv.setCompoundDrawablesWithIntrinsicBounds(icon, null, null, null);
				tv.setText(item.getTitle());
				tv.setTextSize(TypedValue.COMPLEX_UNIT_SP, 16);

				return v;
			}
		};

		int selectedIndex = 0;
		String prevSelectedGpx = app.getSettings().LAST_SELECTED_GPX_TRACK_FOR_NEW_POINT.get();
		if (prevSelectedGpx != null) {
			selectedIndex = list.indexOf(prevSelectedGpx);
		}
		if (selectedIndex == -1) {
			selectedIndex = 0;
		}

		final int[] selectedPosition = {selectedIndex};
		builder.setSingleChoiceItems(listAdapter, selectedIndex, new OnClickListener() {
			@Override
			public void onClick(DialogInterface dialog, int position) {
				selectedPosition[0] = position;
			}
		});
		builder.setTitle(R.string.select_gpx)
				.setPositiveButton(R.string.shared_string_ok, new OnClickListener() {

					@Override
					public void onClick(DialogInterface dialog, int which) {

						int position = selectedPosition[0];
						if (position != -1 && position < list.size()) {
							if (showCurrentGpx && position == 0) {
								callbackWithObject.processResult(null);
								app.getSettings().LAST_SELECTED_GPX_TRACK_FOR_NEW_POINT.set(null);
							} else {
								String fileName = list.get(position).getFileName();
								app.getSettings().LAST_SELECTED_GPX_TRACK_FOR_NEW_POINT.set(fileName);
								SelectedGpxFile selectedGpxFile =
										app.getSelectedGpxHelper().getSelectedFileByName(fileName);
								if (selectedGpxFile != null) {
									callbackWithObject.processResult(new GPXFile[]{selectedGpxFile.getGpxFile()});
								} else {
									loadGPXFileInDifferentThread(activity, callbackWithObject, dir, null, fileName);
								}
							}
						}
					}
				})
				.setNegativeButton(R.string.shared_string_cancel, null);

		final AlertDialog dlg = builder.create();
		dlg.setCanceledOnTouchOutside(false);
		dlg.show();
		try {
			dlg.getListView().setFastScrollEnabled(true);
		} catch (Exception e) {
			// java.lang.ClassCastException: com.android.internal.widget.RoundCornerListAdapter
			// Unknown reason but on some devices fail
		}
		return dlg;
	}

	private static AlertDialog createDialog(final Activity activity,
											final boolean showCurrentGpx,
											final boolean multipleChoice,
											final boolean showAppearanceSetting,
											final CallbackWithObject<GPXFile[]> callbackWithObject,
											final List<GPXInfo> list,
											final ContextMenuAdapter adapter) {
		final OsmandApplication app = (OsmandApplication) activity.getApplication();
		final DateFormat dateFormat = android.text.format.DateFormat.getMediumDateFormat(activity);
		final File dir = app.getAppPath(IndexConstants.GPX_INDEX_DIR);
		AlertDialog.Builder builder = new AlertDialog.Builder(activity);
		final int layout = R.layout.gpx_track_item;
		final Map<String, String> gpxAppearanceParams = new HashMap<>();

		final ArrayAdapter<String> listAdapter = new ArrayAdapter<String>(activity, layout, R.id.title,
				adapter.getItemNames()) {

			List<GpxDataItem> dataItems = null;

			@Override
			public int getItemViewType(int position) {
				return showCurrentGpx && position == 0 ? 1 : 0;
			}

			@Override
			public int getViewTypeCount() {
				return 2;
			}

			private GpxDataItem getDataItem(GPXInfo info) {
				if (dataItems != null) {
					for (GpxDataItem item : dataItems) {
						if (item.getFile().getAbsolutePath().endsWith(info.fileName)) {
							return item;
						}
					}
				}
				return null;
			}

			@Override
			public View getView(final int position, View convertView, ViewGroup parent) {
				// User super class to create the View
				View v = convertView;
				boolean checkLayout = getItemViewType(position) == 0;
				if (v == null) {
					v = activity.getLayoutInflater().inflate(layout, null);
				}

				if (dataItems == null) {
					dataItems = app.getGpxDatabase().getItems();
				}

				final ContextMenuItem item = adapter.getItem(position);
				GPXInfo info = list.get(position);
				updateGpxInfoView(v, item.getTitle(), info, getDataItem(info), showCurrentGpx && position == 0, app);

				if (item.getSelected() == null) {
					v.findViewById(R.id.check_item).setVisibility(View.GONE);
					v.findViewById(R.id.check_local_index).setVisibility(View.GONE);
				} else {
					if (checkLayout) {
						final CheckBox ch = ((CheckBox) v.findViewById(R.id.check_local_index));
						ch.setVisibility(View.VISIBLE);
						v.findViewById(R.id.toggle_item).setVisibility(View.GONE);
						ch.setOnCheckedChangeListener(null);
						ch.setChecked(item.getSelected());
						ch.setOnCheckedChangeListener(new OnCheckedChangeListener() {
							@Override
							public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
								item.setSelected(isChecked);
							}
						});
					} else {
						final SwitchCompat ch = ((SwitchCompat) v.findViewById(R.id.toggle_item));
						ch.setVisibility(View.VISIBLE);
						v.findViewById(R.id.toggle_checkbox_item).setVisibility(View.GONE);
						ch.setOnCheckedChangeListener(null);
						ch.setChecked(item.getSelected());
						ch.setOnCheckedChangeListener(new OnCheckedChangeListener() {
							@Override
							public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
								item.setSelected(isChecked);
							}
						});
					}
					v.findViewById(R.id.check_item).setVisibility(View.VISIBLE);
				}
				return v;
			}
		};

		OnClickListener onClickListener = new OnClickListener() {
			@Override
			public void onClick(DialogInterface dialog, int position) {
			}
		};
		builder.setAdapter(listAdapter, onClickListener);
		if (multipleChoice) {
			if (showAppearanceSetting) {
				final RenderingRuleProperty trackWidthProp;
				final RenderingRuleProperty trackColorProp;
				final RenderingRulesStorage renderer = app.getRendererRegistry().getCurrentSelectedRenderer();
				if (renderer != null) {
					trackWidthProp = renderer.PROPS.getCustomRule(CURRENT_TRACK_WIDTH_ATTR);
					trackColorProp = renderer.PROPS.getCustomRule(CURRENT_TRACK_COLOR_ATTR);
				} else {
					trackWidthProp = null;
					trackColorProp = null;
				}
				if (trackWidthProp == null || trackColorProp == null) {
					builder.setTitle(R.string.show_gpx);
				} else {
					final View apprTitleView = activity.getLayoutInflater().inflate(R.layout.select_gpx_appearance_title, null);

					final OsmandSettings.CommonPreference<String> prefWidth
							= app.getSettings().getCustomRenderProperty(CURRENT_TRACK_WIDTH_ATTR);
					final OsmandSettings.CommonPreference<String> prefColor
							= app.getSettings().getCustomRenderProperty(CURRENT_TRACK_COLOR_ATTR);

					updateAppearanceTitle(activity, app, trackWidthProp, renderer, apprTitleView, prefWidth.get(), prefColor.get());

					apprTitleView.findViewById(R.id.button).setOnClickListener(new View.OnClickListener() {
						@Override
						public void onClick(View v) {
							final ListPopupWindow popup = new ListPopupWindow(activity);
							popup.setAnchorView(apprTitleView);
							popup.setContentWidth(AndroidUtils.dpToPx(activity, 200f));
							popup.setModal(true);
							popup.setDropDownGravity(Gravity.RIGHT | Gravity.TOP);
							popup.setVerticalOffset(AndroidUtils.dpToPx(activity, -48f));
							popup.setHorizontalOffset(AndroidUtils.dpToPx(activity, -6f));
							final GpxAppearanceAdapter gpxApprAdapter = new GpxAppearanceAdapter(activity,
									gpxAppearanceParams.containsKey(CURRENT_TRACK_COLOR_ATTR) ? gpxAppearanceParams.get(CURRENT_TRACK_COLOR_ATTR) : prefColor.get(),
									GpxAppearanceAdapter.GpxAppearanceAdapterType.TRACK_WIDTH_COLOR);
							popup.setAdapter(gpxApprAdapter);
							popup.setOnItemClickListener(new AdapterView.OnItemClickListener() {

								@Override
								public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
									AppearanceListItem item = gpxApprAdapter.getItem(position);
									if (item != null) {
										if (item.getAttrName() == CURRENT_TRACK_WIDTH_ATTR) {
											gpxAppearanceParams.put(CURRENT_TRACK_WIDTH_ATTR, item.getValue());
										} else if (item.getAttrName() == CURRENT_TRACK_COLOR_ATTR) {
											gpxAppearanceParams.put(CURRENT_TRACK_COLOR_ATTR, item.getValue());
										}
									}
									popup.dismiss();
									updateAppearanceTitle(activity, app, trackWidthProp, renderer,
											apprTitleView,
											gpxAppearanceParams.containsKey(CURRENT_TRACK_WIDTH_ATTR) ? gpxAppearanceParams.get(CURRENT_TRACK_WIDTH_ATTR) : prefWidth.get(),
											gpxAppearanceParams.containsKey(CURRENT_TRACK_COLOR_ATTR) ? gpxAppearanceParams.get(CURRENT_TRACK_COLOR_ATTR) : prefColor.get());
								}
							});
							popup.show();
						}
					});
					builder.setCustomTitle(apprTitleView);
				}
			} else {
				builder.setTitle(R.string.show_gpx);
			}
			builder.setPositiveButton(R.string.shared_string_ok, new OnClickListener() {

				@Override
				public void onClick(DialogInterface dialog, int which) {
					if (gpxAppearanceParams.size() > 0) {
						for (Map.Entry<String, String> entry : gpxAppearanceParams.entrySet()) {
							final OsmandSettings.CommonPreference<String> pref
									= app.getSettings().getCustomRenderProperty(entry.getKey());
							pref.set(entry.getValue());
						}
						if (activity instanceof MapActivity) {
							ConfigureMapMenu.refreshMapComplete((MapActivity) activity);
						}
					}
					GPXFile currentGPX = null;
					//clear all previously selected files before adding new one
					OsmandApplication app = (OsmandApplication) activity.getApplication();
					if (app != null && app.getSelectedGpxHelper() != null) {
						app.getSelectedGpxHelper().clearAllGpxFileToShow();
					}
					if (app != null && showCurrentGpx && adapter.getItem(0).getSelected()) {
						currentGPX = app.getSavingTrackHelper().getCurrentGpx();
					}
					List<String> s = new ArrayList<>();
					for (int i = (showCurrentGpx ? 1 : 0); i < adapter.length(); i++) {
						if (adapter.getItem(i).getSelected()) {
							s.add(list.get(i).getFileName());
						}
					}
					dialog.dismiss();
					loadGPXFileInDifferentThread(activity, callbackWithObject, dir, currentGPX,
							s.toArray(new String[s.size()]));
				}
			});
			builder.setNegativeButton(R.string.shared_string_cancel, null);
			if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT
					&& list.size() > 1 || !showCurrentGpx && list.size() > 0) {
				builder.setNeutralButton(R.string.gpx_add_track, null);
			}
		}

		final AlertDialog dlg = builder.create();
		dlg.setCanceledOnTouchOutside(true);
		if (list.size() == 0 || showCurrentGpx && list.size() == 1) {
			final View footerView = activity.getLayoutInflater().inflate(R.layout.no_gpx_files_list_footer, null);
			TextView descTextView = (TextView)footerView.findViewById(R.id.descFolder);
			String descPrefix = app.getString(R.string.gpx_no_tracks_title_folder);
			SpannableString spannableDesc = new SpannableString(descPrefix + ": " + dir.getAbsolutePath());
			spannableDesc.setSpan(new StyleSpan(android.graphics.Typeface.BOLD),
					descPrefix.length() + 1, spannableDesc.length(), 0);
			descTextView.setText(spannableDesc);
			if (Build.VERSION.SDK_INT < Build.VERSION_CODES.KITKAT) {
				footerView.findViewById(R.id.button).setVisibility(View.GONE);
			} else {
				footerView.findViewById(R.id.button).setOnClickListener(new View.OnClickListener() {
					@Override
					public void onClick(View v) {
						addTrack(activity, dlg);
					}
				});
			}
			dlg.getListView().addFooterView(footerView, null, false);
		}
		dlg.getListView().setOnItemClickListener(new OnItemClickListener() {
			@Override
			public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
				if (multipleChoice) {
					ContextMenuItem item = adapter.getItem(position);
					item.setSelected(!item.getSelected());
					listAdapter.notifyDataSetInvalidated();
					if (position == 0 && showCurrentGpx && item.getSelected()) {
						OsmandMonitoringPlugin monitoringPlugin = OsmandPlugin.getEnabledPlugin(OsmandMonitoringPlugin.class);
						if (monitoringPlugin == null) {
							AlertDialog.Builder confirm = new AlertDialog.Builder(activity);
							confirm.setPositiveButton(R.string.shared_string_ok, new DialogInterface.OnClickListener() {
								@Override
								public void onClick(DialogInterface dialog, int which) {
									Intent intent = new Intent(activity, PluginActivity.class);
									intent.putExtra(PluginActivity.EXTRA_PLUGIN_ID, OsmandMonitoringPlugin.ID);
									activity.startActivity(intent);
								}
							});
							confirm.setNegativeButton(R.string.shared_string_cancel, null);
							confirm.setMessage(activity.getString(R.string.enable_plugin_monitoring_services));
							confirm.show();
						} else if (!app.getSettings().SAVE_GLOBAL_TRACK_TO_GPX.get()) {
							monitoringPlugin.controlDialog(activity, false);
						}
					}
				} else {
					dlg.dismiss();
					if (showCurrentGpx && position == 0) {
						callbackWithObject.processResult(null);
					} else {
						String fileName = list.get(position).getFileName();
						SelectedGpxFile selectedGpxFile =
								app.getSelectedGpxHelper().getSelectedFileByName(fileName);
						if (selectedGpxFile != null) {
							callbackWithObject.processResult(new GPXFile[]{selectedGpxFile.getGpxFile()});
						} else {
							loadGPXFileInDifferentThread(activity, callbackWithObject, dir, null, fileName);
						}
					}
				}
			}
		});
		dlg.setOnShowListener(new DialogInterface.OnShowListener() {
			@Override
			public void onShow(DialogInterface dialog) {
				Button addTrackButton = ((AlertDialog) dialog).getButton(AlertDialog.BUTTON_NEUTRAL);
				if (addTrackButton != null) {
					addTrackButton.setOnClickListener(new View.OnClickListener() {
						@Override
						public void onClick(View v) {
							addTrack(activity, dlg);
						}
					});
				}
			}
		});
		dlg.show();
		try {
			dlg.getListView().setFastScrollEnabled(true);
		} catch (Exception e) {
			// java.lang.ClassCastException: com.android.internal.widget.RoundCornerListAdapter
			// Unknown reason but on some devices fail
		}
		return dlg;
	}

	public static void updateGpxInfoView(View v, String itemTitle, GPXInfo info, GpxDataItem dataItem, boolean currentlyRecordingTrack, OsmandApplication app) {
		TextView viewName = ((TextView) v.findViewById(R.id.name));
		viewName.setText(itemTitle.replace("/", "  ").trim());
		ImageView icon = (ImageView) v.findViewById(R.id.icon);
		icon.setVisibility(View.GONE);
		//icon.setImageDrawable(app.getIconsCache().getThemedIcon(R.drawable.ic_action_polygom_dark));
		viewName.setTypeface(Typeface.DEFAULT, Typeface.NORMAL);

		GPXTrackAnalysis analysis = null;
		if (currentlyRecordingTrack) {
			analysis = app.getSavingTrackHelper().getCurrentTrack().getTrackAnalysis();
		} else if (dataItem != null) {
			analysis = dataItem.getAnalysis();
		}

		boolean sectionRead = analysis == null;
		if (sectionRead) {
			v.findViewById(R.id.read_section).setVisibility(View.GONE);
			v.findViewById(R.id.unknown_section).setVisibility(View.VISIBLE);
			String date = "";
			String size = "";
			if (info.getFileSize() >= 0) {
				if (info.getFileSize() > (100 * (1 << 10))) {
					size = formatMb.format(new Object[]{(float) info.getFileSize() / (1 << 20)});
				} else {
					size = formatKb.format(new Object[]{(float) info.getFileSize() / (1 << 10)});
				}
			}
			DateFormat df = app.getResourceManager().getDateFormat();
			long fd = info.getLastModified();
			if (fd > 0) {
				date = (df.format(new Date(fd)));
			}
			TextView sizeText = (TextView) v.findViewById(R.id.date_and_size_details);
			sizeText.setText(date + " \u2022 " + size);

		} else {
			v.findViewById(R.id.read_section).setVisibility(View.VISIBLE);
			v.findViewById(R.id.unknown_section).setVisibility(View.GONE);
			ImageView distanceI = (ImageView) v.findViewById(R.id.distance_icon);
			distanceI.setVisibility(View.VISIBLE);
			distanceI.setImageDrawable(app.getUIUtilities().getThemedIcon(R.drawable.ic_small_distance));
			ImageView pointsI = (ImageView) v.findViewById(R.id.points_icon);
			pointsI.setVisibility(View.VISIBLE);
			pointsI.setImageDrawable(app.getUIUtilities().getThemedIcon(R.drawable.ic_small_point));
			ImageView timeI = (ImageView) v.findViewById(R.id.time_icon);
			timeI.setVisibility(View.VISIBLE);
			timeI.setImageDrawable(app.getUIUtilities().getThemedIcon(R.drawable.ic_small_time));
			TextView time = (TextView) v.findViewById(R.id.time);
			TextView distance = (TextView) v.findViewById(R.id.distance);
			TextView pointsCount = (TextView) v.findViewById(R.id.points_count);
			pointsCount.setText(analysis.wptPoints + "");
			distance.setText(OsmAndFormatter.getFormattedDistance(analysis.totalDistance, app));

			if (analysis.isTimeSpecified()) {
				time.setText(Algorithms.formatDuration((int) (analysis.timeSpan / 1000), app.accessibilityEnabled()) + "");
			} else {
				time.setText("");
			}
		}

		TextView descr = ((TextView) v.findViewById(R.id.description));
		descr.setVisibility(View.GONE);

		v.findViewById(R.id.check_item).setVisibility(View.GONE);
	}

	@TargetApi(Build.VERSION_CODES.KITKAT)
	private static void addTrack(final Activity activity, final AlertDialog dialog) {
		if (activity instanceof MapActivity) {
			final MapActivity mapActivity = (MapActivity) activity;
			ActivityResultListener listener = new ActivityResultListener(OPEN_GPX_DOCUMENT_REQUEST, new OnActivityResultListener() {
				@Override
				public void onResult(int resultCode, Intent resultData) {
					if (resultCode == Activity.RESULT_OK) {
						if (resultData != null) {
							Uri uri = resultData.getData();
							if (mapActivity.getImportHelper().handleGpxImport(uri, false)) {
								dialog.dismiss();
							}
						}
					}
				}
			});

			Intent intent = new Intent(Intent.ACTION_OPEN_DOCUMENT);
			//intent.addCategory(Intent.CATEGORY_OPENABLE);
			//intent.setType("application/gpx+xml");
			//intent.setType("text/plain");
			//intent.setType("text/xml");
			intent.setType("*/*");
			mapActivity.registerActivityResultListener(listener);
			activity.startActivityForResult(intent, OPEN_GPX_DOCUMENT_REQUEST);
		}
	}

	private static void updateAppearanceTitle(Activity activity, OsmandApplication app,
											  RenderingRuleProperty trackWidthProp,
											  RenderingRulesStorage renderer,
											  View apprTitleView,
											  String prefWidthValue,
											  String prefColorValue) {
		TextView widthTextView = (TextView) apprTitleView.findViewById(R.id.widthTitle);
		ImageView colorImageView = (ImageView) apprTitleView.findViewById(R.id.colorImage);
		if (Algorithms.isEmpty(prefWidthValue)) {
			widthTextView.setText(SettingsActivity.getStringPropertyValue(activity, trackWidthProp.getDefaultValueDescription()));
		} else {
			widthTextView.setText(SettingsActivity.getStringPropertyValue(activity, prefWidthValue));
		}
		int color = GpxAppearanceAdapter.parseTrackColor(renderer, prefColorValue);
		if (color == -1) {
			colorImageView.setImageDrawable(app.getUIUtilities().getThemedIcon(R.drawable.ic_action_circle));
		} else {
			colorImageView.setImageDrawable(app.getUIUtilities().getPaintedIcon(R.drawable.ic_action_circle, color));
		}
	}

	public static List<GPXInfo> getSortedGPXFilesInfoByDate(File dir, boolean absolutePath) {
		final List<GPXInfo> list = new ArrayList<>();
		readGpxDirectory(dir, list, "", absolutePath);
		Collections.sort(list, new Comparator<GPXInfo>() {
			@Override
			public int compare(GPXInfo object1, GPXInfo object2) {
				long lhs = object1.getLastModified();
				long rhs = object2.getLastModified();
				return lhs < rhs ? 1 : (lhs == rhs ? 0 : -1);
			}
		});
		return list;
	}


	public static List<GPXInfo> getSortedGPXFilesInfo(File dir, final List<String> selectedGpxList, boolean absolutePath) {
		final List<GPXInfo> list = new ArrayList<>();
		readGpxDirectory(dir, list, "", absolutePath);
		if (selectedGpxList != null) {
			for (GPXInfo info : list) {
				for (String fileName : selectedGpxList) {
					if (fileName.endsWith(info.getFileName())) {
						info.setSelected(true);
						break;
					}
				}
			}
		}
		Collections.sort(list, new Comparator<GPXInfo>() {
			@Override
			public int compare(GPXInfo i1, GPXInfo i2) {
				int res = i1.isSelected() == i2.isSelected() ? 0 : i1.isSelected() ? -1 : 1;
				if (res != 0) {
					return res;
				}

				String name1 = i1.getFileName();
				String name2 = i2.getFileName();
				int d1 = depth(name1);
				int d2 = depth(name2);
				if (d1 != d2) {
					return d1 - d2;
				}
				int lastSame = 0;
				for (int i = 0; i < name1.length() && i < name2.length(); i++) {
					if (name1.charAt(i) != name2.charAt(i)) {
						break;
					}
					if (name1.charAt(i) == '/') {
						lastSame = i + 1;
					}
				}

				boolean isDigitStarts1 = isLastSameStartsWithDigit(name1, lastSame);
				boolean isDigitStarts2 = isLastSameStartsWithDigit(name2, lastSame);
				res = isDigitStarts1 == isDigitStarts2 ? 0 : isDigitStarts1 ? -1 : 1;
				if (res != 0) {
					return res;
				}
				if (isDigitStarts1) {
					return -name1.compareToIgnoreCase(name2);
				}
				return name1.compareToIgnoreCase(name2);
			}

			private int depth(String name1) {
				int d = 0;
				for (int i = 0; i < name1.length(); i++) {
					if (name1.charAt(i) == '/') {
						d++;
					}
				}
				return d;
			}

			private boolean isLastSameStartsWithDigit(String name1, int lastSame) {
				if (name1.length() > lastSame) {
					return Character.isDigit(name1.charAt(lastSame));
				}

				return false;
			}
		});
		return list;
	}

	private static void readGpxDirectory(File dir, final List<GPXInfo> list, String parent,
										 boolean absolutePath) {
		if (dir != null && dir.canRead()) {
			File[] files = dir.listFiles();
			if (files != null) {
				for (File f : files) {
					if (f.getName().toLowerCase().endsWith(".gpx")) { //$NON-NLS-1$
						list.add(new GPXInfo(absolutePath ? f.getAbsolutePath() :
								parent + f.getName(), f.lastModified(), f.length()));
					} else if (f.isDirectory()) {
						readGpxDirectory(f, list, parent + f.getName() + "/", absolutePath);
					}
				}
			}
		}
	}

	private static void loadGPXFileInDifferentThread(final Activity activity, final CallbackWithObject<GPXFile[]> callbackWithObject,
													 final File dir, final GPXFile currentFile, final String... filename) {
		final ProgressDialog dlg = ProgressDialog.show(activity, activity.getString(R.string.loading_smth, ""),
				activity.getString(R.string.loading_data));
		new Thread(new Runnable() {
			@Override
			public void run() {
				final GPXFile[] result = new GPXFile[filename.length + (currentFile == null ? 0 : 1)];
				int k = 0;
				String w = "";
				if (currentFile != null) {
					result[k++] = currentFile;
				}
				for (String fname : filename) {
					final File f = new File(dir, fname);
					GPXFile res = GPXUtilities.loadGPXFile(f);
					if (res.error != null && res.error.getMessage().length() > 0) {
						w += res.error.getMessage() + "\n";
					}
					result[k++] = res;
				}
				dlg.dismiss();
				final String warn = w;
				activity.runOnUiThread(new Runnable() {
					@Override
					public void run() {
						if (warn.length() > 0) {
							Toast.makeText(activity, warn, Toast.LENGTH_LONG).show();
						} else {
							callbackWithObject.processResult(result);
						}
					}
				});
			}

		}, "Loading gpx").start(); //$NON-NLS-1$
	}

	public static void setupGPXChart(OsmandApplication ctx, LineChart mChart, int yLabelsCount) {
		OsmandSettings settings = ctx.getSettings();
		setupGPXChart(mChart, yLabelsCount, 24f, 16f, settings.isLightContent(), true);
	}

	public static void setupGPXChart(LineChart mChart, int yLabelsCount, float topOffset, float bottomOffset, boolean light, boolean useGesturesAndScale) {
		if (android.os.Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
			mChart.setHardwareAccelerationEnabled(false);
		} else {
			mChart.setHardwareAccelerationEnabled(true);
		}
		mChart.setTouchEnabled(useGesturesAndScale);
		mChart.setDragEnabled(useGesturesAndScale);
		mChart.setScaleEnabled(useGesturesAndScale);
		mChart.setPinchZoom(useGesturesAndScale);
		mChart.setScaleYEnabled(false);
		mChart.setAutoScaleMinMaxEnabled(true);
		mChart.setDrawBorders(false);
		mChart.getDescription().setEnabled(false);
		mChart.setMaxVisibleValueCount(10);
		mChart.setMinOffset(0f);
		mChart.setDragDecelerationEnabled(false);

		mChart.setExtraTopOffset(topOffset);
		mChart.setExtraBottomOffset(bottomOffset);

		// create a custom MarkerView (extend MarkerView) and specify the layout
		// to use for it
		GPXMarkerView mv = new GPXMarkerView(mChart.getContext());
		mv.setChartView(mChart); // For bounds control
		mChart.setMarker(mv); // Set the marker to the chart
		mChart.setDrawMarkers(true);

		XAxis xAxis = mChart.getXAxis();
		xAxis.setDrawAxisLine(false);
		xAxis.setDrawGridLines(true);
		xAxis.setGridLineWidth(1.5f);
		xAxis.setGridColor(ActivityCompat.getColor(mChart.getContext(), R.color.gpx_chart_black_grid));
		xAxis.enableGridDashedLine(25f, Float.MAX_VALUE, 0f);
		xAxis.setPosition(BOTTOM);
		xAxis.setTextColor(light ? mChart.getResources().getColor(R.color.secondary_text_light) : mChart.getResources().getColor(R.color.secondary_text_dark));

		YAxis yAxis = mChart.getAxisLeft();
		yAxis.enableGridDashedLine(10f, 5f, 0f);
		yAxis.setGridColor(ActivityCompat.getColor(mChart.getContext(), R.color.divider_color));
		yAxis.setDrawAxisLine(false);
		yAxis.setPosition(YAxis.YAxisLabelPosition.INSIDE_CHART);
		yAxis.setXOffset(16f);
		yAxis.setYOffset(-6f);
		yAxis.setLabelCount(yLabelsCount);
		yAxis.setTextColor(light ? mChart.getResources().getColor(R.color.secondary_text_light) : mChart.getResources().getColor(R.color.secondary_text_dark));

		yAxis = mChart.getAxisRight();
		yAxis.enableGridDashedLine(10f, 5f, 0f);
		yAxis.setGridColor(ActivityCompat.getColor(mChart.getContext(), R.color.divider_color));
		yAxis.setDrawAxisLine(false);
		yAxis.setPosition(YAxis.YAxisLabelPosition.INSIDE_CHART);
		yAxis.setXOffset(16f);
		yAxis.setYOffset(-6f);
		yAxis.setLabelCount(yLabelsCount);
		yAxis.setTextColor(light ? mChart.getResources().getColor(R.color.secondary_text_light) : mChart.getResources().getColor(R.color.secondary_text_dark));
		yAxis.setEnabled(false);

		Legend legend = mChart.getLegend();
		legend.setEnabled(false);
	}

	private static float setupXAxisDistance(OsmandApplication ctx, XAxis xAxis, float meters) {
		OsmandSettings settings = ctx.getSettings();
		OsmandSettings.MetricsConstants mc = settings.METRIC_SYSTEM.get();
		float divX;

		String format1 = "{0,number,0.#} ";
		String format2 = "{0,number,0.##} ";
		String fmt = null;
		float granularity = 1f;
		int mainUnitStr;
		float mainUnitInMeters;
		if (mc == OsmandSettings.MetricsConstants.KILOMETERS_AND_METERS) {
			mainUnitStr = R.string.km;
			mainUnitInMeters = METERS_IN_KILOMETER;
		} else if (mc == OsmandSettings.MetricsConstants.NAUTICAL_MILES) {
			mainUnitStr = R.string.nm;
			mainUnitInMeters = METERS_IN_ONE_NAUTICALMILE;
		} else {
			mainUnitStr = R.string.mile;
			mainUnitInMeters = METERS_IN_ONE_MILE;
		}
		if (meters > 9.99f * mainUnitInMeters) {
			fmt = format1;
			granularity = .1f;
		}
		if (meters >= 100 * mainUnitInMeters ||
				meters > 9.99f * mainUnitInMeters ||
				meters > 0.999f * mainUnitInMeters ||
				mc == OsmandSettings.MetricsConstants.MILES_AND_FEET && meters > 0.249f * mainUnitInMeters ||
				mc == OsmandSettings.MetricsConstants.MILES_AND_METERS && meters > 0.249f * mainUnitInMeters ||
				mc == OsmandSettings.MetricsConstants.MILES_AND_YARDS && meters > 0.249f * mainUnitInMeters ||
				mc == OsmandSettings.MetricsConstants.NAUTICAL_MILES && meters > 0.99f * mainUnitInMeters) {

			divX = mainUnitInMeters;
			if (fmt == null) {
				fmt = format2;
				granularity = .01f;
			}
		} else {
			fmt = null;
			granularity = 1f;
			if (mc == OsmandSettings.MetricsConstants.KILOMETERS_AND_METERS || mc == OsmandSettings.MetricsConstants.MILES_AND_METERS) {
				divX = 1f;
				mainUnitStr = R.string.m;
			} else if (mc == OsmandSettings.MetricsConstants.MILES_AND_FEET) {
				divX = 1f / FEET_IN_ONE_METER;
				mainUnitStr = R.string.foot;
			} else if (mc == OsmandSettings.MetricsConstants.MILES_AND_YARDS) {
				divX = 1f / YARDS_IN_ONE_METER;
				mainUnitStr = R.string.yard;
			} else {
				divX = 1f;
				mainUnitStr = R.string.m;
			}
		}

		final String formatX = fmt;
		final String mainUnitX = ctx.getString(mainUnitStr);

		xAxis.setGranularity(granularity);
		xAxis.setValueFormatter(new IAxisValueFormatter() {

			@Override
			public String getFormattedValue(float value, AxisBase axis) {
				if (!Algorithms.isEmpty(formatX)) {
					return MessageFormat.format(formatX + mainUnitX, value);
				} else {
					return (int)value + " " + mainUnitX;
				}
			}
		});

		return divX;
	}

	private static float setupXAxisTime(XAxis xAxis, long timeSpan) {

		final boolean useHours = timeSpan / 3600000 > 0;
		xAxis.setGranularity(1f);
		xAxis.setValueFormatter(new IAxisValueFormatter() {

			@Override
			public String getFormattedValue(float value, AxisBase axis) {
				int seconds = (int)value;
				if (useHours) {
					int hours = seconds / (60 * 60);
					int minutes = (seconds / 60) % 60;
					int sec = seconds % 60;
					return hours + ":" + (minutes < 10 ? "0" + minutes : minutes) + ":" + (sec < 10 ? "0" + sec : sec);
				} else {
					int minutes = (seconds / 60) % 60;
					int sec = seconds % 60;
					return (minutes < 10 ? "0" + minutes : minutes) + ":" + (sec < 10 ? "0" + sec : sec);
				}
			}
		});

		return 1f;
	}

	private static List<Entry> calculateElevationArray(GPXTrackAnalysis analysis, GPXDataSetAxisType axisType,
													   float divX, float convEle) {
		List<Entry> values = new ArrayList<>();
		List<Elevation> elevationData = analysis.elevationData;
		float nextX = 0;
		float nextY;
		float elev;
		float prevElevOrig = -80000;
		float prevElev = 0;
		int i = -1;
		int lastIndex = elevationData.size() - 1;
		Entry lastEntry = null;
		float lastXSameY = -1;
		boolean hasSameY = false;
		float x;
		for (Elevation e : elevationData) {
			i++;
			x = axisType == GPXDataSetAxisType.TIME ? e.time : e.distance;
			if (x > 0) {
				nextX += x / divX;
				if (!Float.isNaN(e.elevation)) {
					elev = e.elevation;
					if (prevElevOrig != -80000) {
						if (elev > prevElevOrig) {
							elev -= 1f;
						} else if (prevElevOrig == elev && i < lastIndex) {
							hasSameY = true;
							lastXSameY = nextX;
							continue;
						}
						if (prevElev == elev && i < lastIndex) {
							hasSameY = true;
							lastXSameY = nextX;
							continue;
						}
						if (hasSameY) {
							values.add(new Entry(lastXSameY, lastEntry.getY()));
						}
						hasSameY = false;
					}
					prevElevOrig = e.elevation;
					prevElev = elev;
					nextY = elev * convEle;
					lastEntry = new Entry(nextX, nextY);
					values.add(lastEntry);
				}
			}
		}
		return values;
	}

	public static OrderedLineDataSet createGPXElevationDataSet(@NonNull OsmandApplication ctx,
															   @NonNull LineChart mChart,
															   @NonNull GPXTrackAnalysis analysis,
															   @NonNull GPXDataSetAxisType axisType,
															   boolean useRightAxis,
															   boolean drawFilled) {
		OsmandSettings settings = ctx.getSettings();
		OsmandSettings.MetricsConstants mc = settings.METRIC_SYSTEM.get();
		boolean useFeet = (mc == OsmandSettings.MetricsConstants.MILES_AND_FEET) || (mc == OsmandSettings.MetricsConstants.MILES_AND_YARDS);
		boolean light = settings.isLightContent();
		final float convEle = useFeet ? 3.28084f : 1.0f;

		float divX;
		XAxis xAxis = mChart.getXAxis();
		if (axisType == GPXDataSetAxisType.TIME && analysis.isTimeSpecified()) {
			divX = setupXAxisTime(xAxis, analysis.timeSpan);
		} else {
			divX = setupXAxisDistance(ctx, xAxis, analysis.totalDistance);
		}

		final String mainUnitY = useFeet ? ctx.getString(R.string.foot) : ctx.getString(R.string.m);

		YAxis yAxis;
		if (useRightAxis) {
			yAxis = mChart.getAxisRight();
			yAxis.setEnabled(true);
		} else {
			yAxis = mChart.getAxisLeft();
		}
		yAxis.setTextColor(ActivityCompat.getColor(mChart.getContext(), R.color.gpx_chart_blue_label));
		yAxis.setGridColor(ActivityCompat.getColor(mChart.getContext(), R.color.gpx_chart_blue_grid));
		yAxis.setGranularity(1f);
		yAxis.resetAxisMinimum();
		yAxis.setValueFormatter(new IAxisValueFormatter() {

			@Override
			public String getFormattedValue(float value, AxisBase axis) {
				return (int)value + " " + mainUnitY;
			}
		});

		List<Entry> values = calculateElevationArray(analysis, axisType, divX, convEle);

		OrderedLineDataSet dataSet = new OrderedLineDataSet(values, "", GPXDataSetType.ALTITUDE, axisType);
		dataSet.priority = (float) (analysis.avgElevation - analysis.minElevation) * convEle;
		dataSet.divX = divX;
		dataSet.mulY = convEle;
		dataSet.divY = Float.NaN;
		dataSet.units = mainUnitY;

		dataSet.setColor(ContextCompat.getColor(mChart.getContext(), R.color.gpx_chart_blue));
		dataSet.setLineWidth(1f);
		if (drawFilled) {
			dataSet.setFillAlpha(128);
			dataSet.setFillColor(ContextCompat.getColor(mChart.getContext(), R.color.gpx_chart_blue));
			dataSet.setDrawFilled(true);
		} else {
			dataSet.setDrawFilled(false);
		}

		dataSet.setDrawValues(false);
		dataSet.setValueTextSize(9f);
		dataSet.setFormLineWidth(1f);
		dataSet.setFormSize(15.f);

		dataSet.setDrawCircles(false);
		dataSet.setDrawCircleHole(false);

		dataSet.setHighlightEnabled(true);
		dataSet.setDrawVerticalHighlightIndicator(true);
		dataSet.setDrawHorizontalHighlightIndicator(false);
		dataSet.setHighLightColor(light ? mChart.getResources().getColor(R.color.secondary_text_light) : mChart.getResources().getColor(R.color.secondary_text_dark));

		//dataSet.setMode(LineDataSet.Mode.HORIZONTAL_BEZIER);

		dataSet.setFillFormatter(new IFillFormatter() {
			@Override
			public float getFillLinePosition(ILineDataSet dataSet, LineDataProvider dataProvider) {
				return dataProvider.getYChartMin();
			}
		});
		if (useRightAxis) {
			dataSet.setAxisDependency(YAxis.AxisDependency.RIGHT);
		}
		return dataSet;
	}

	public static OrderedLineDataSet createGPXSpeedDataSet(@NonNull OsmandApplication ctx,
														   @NonNull LineChart mChart,
														   @NonNull GPXTrackAnalysis analysis,
														   @NonNull GPXDataSetAxisType axisType,
														   boolean useRightAxis,
														   boolean drawFilled) {
		OsmandSettings settings = ctx.getSettings();
		boolean light = settings.isLightContent();

		float divX;
		XAxis xAxis = mChart.getXAxis();
		if (axisType == GPXDataSetAxisType.TIME && analysis.isTimeSpecified()) {
			divX = setupXAxisTime(xAxis, analysis.timeSpan);
		} else {
			divX = setupXAxisDistance(ctx, xAxis, analysis.totalDistance);
		}

		OsmandSettings.SpeedConstants sps = settings.SPEED_SYSTEM.get();
		float mulSpeed = Float.NaN;
		float divSpeed = Float.NaN;
		final String mainUnitY = sps.toShortString(ctx);
		if (sps == OsmandSettings.SpeedConstants.KILOMETERS_PER_HOUR) {
			mulSpeed = 3.6f;
		} else if (sps == OsmandSettings.SpeedConstants.MILES_PER_HOUR) {
			mulSpeed = 3.6f * METERS_IN_KILOMETER / METERS_IN_ONE_MILE;
		} else if (sps == OsmandSettings.SpeedConstants.NAUTICALMILES_PER_HOUR) {
			mulSpeed = 3.6f * METERS_IN_KILOMETER / METERS_IN_ONE_NAUTICALMILE;
		} else if (sps == OsmandSettings.SpeedConstants.MINUTES_PER_KILOMETER) {
			divSpeed = METERS_IN_KILOMETER / 60;
		} else if (sps == OsmandSettings.SpeedConstants.MINUTES_PER_MILE) {
			divSpeed = METERS_IN_ONE_MILE / 60;
		} else {
			mulSpeed = 1f;
		}

		YAxis yAxis;
		if (useRightAxis) {
			yAxis = mChart.getAxisRight();
			yAxis.setEnabled(true);
		} else {
			yAxis = mChart.getAxisLeft();
		}
		if (analysis.hasSpeedInTrack()) {
			yAxis.setTextColor(ActivityCompat.getColor(mChart.getContext(), R.color.gpx_chart_orange_label));
			yAxis.setGridColor(ActivityCompat.getColor(mChart.getContext(), R.color.gpx_chart_orange_grid));
		} else {
			yAxis.setTextColor(ActivityCompat.getColor(mChart.getContext(), R.color.gpx_chart_red_label));
			yAxis.setGridColor(ActivityCompat.getColor(mChart.getContext(), R.color.gpx_chart_red_grid));
		}

		yAxis.setAxisMinimum(0f);

		ArrayList<Entry> values = new ArrayList<>();
		List<Speed> speedData = analysis.speedData;
		float nextX = 0;
		float nextY;
		float x;
		for (Speed s : speedData) {
			x = axisType == GPXDataSetAxisType.TIME ? s.time : s.distance;
			if (x > 0) {
				if (axisType == GPXDataSetAxisType.TIME && x > 60) {
					values.add(new Entry(nextX + 1, 0));
					values.add(new Entry(nextX + x - 1, 0));
				}
				nextX += x / divX;
				if (Float.isNaN(divSpeed)) {
					nextY = s.speed * mulSpeed;
				} else {
					nextY = divSpeed / s.speed;
				}
				if (nextY < 0 || Float.isInfinite(nextY)) {
					nextY = 0;
				}
				values.add(new Entry(nextX, nextY));
			}
		}

		OrderedLineDataSet dataSet = new OrderedLineDataSet(values, "", GPXDataSetType.SPEED, axisType);

		String format = null;
		if (dataSet.getYMax() < 3) {
			format = "{0,number,0.#} ";
		}
		final String formatY = format;
		yAxis.setValueFormatter(new IAxisValueFormatter() {

			@Override
			public String getFormattedValue(float value, AxisBase axis) {
				if (!Algorithms.isEmpty(formatY)) {
					return MessageFormat.format(formatY + mainUnitY, value);
				} else {
					return (int)value + " " + mainUnitY;
				}
			}
		});

		if (Float.isNaN(divSpeed)) {
			dataSet.priority = analysis.avgSpeed * mulSpeed;
		} else {
			dataSet.priority = divSpeed / analysis.avgSpeed;
		}
		dataSet.divX = divX;
		if (Float.isNaN(divSpeed)) {
			dataSet.mulY = mulSpeed;
			dataSet.divY = Float.NaN;
		} else {
			dataSet.divY = divSpeed;
			dataSet.mulY = Float.NaN;
		}
		dataSet.units = mainUnitY;

		if (analysis.hasSpeedInTrack()) {
			dataSet.setColor(ContextCompat.getColor(mChart.getContext(), R.color.gpx_chart_orange));
		} else {
			dataSet.setColor(ContextCompat.getColor(mChart.getContext(), R.color.gpx_chart_red));
		}
		dataSet.setLineWidth(1f);
		if (drawFilled) {
			dataSet.setFillAlpha(128);
			if (analysis.hasSpeedInTrack()) {
				dataSet.setFillColor(ContextCompat.getColor(mChart.getContext(), R.color.gpx_chart_orange));
			} else {
				dataSet.setFillColor(ContextCompat.getColor(mChart.getContext(), R.color.gpx_chart_red));
			}
			dataSet.setDrawFilled(true);
		} else {
			dataSet.setDrawFilled(false);
		}
		dataSet.setDrawValues(false);
		dataSet.setValueTextSize(9f);
		dataSet.setFormLineWidth(1f);
		dataSet.setFormSize(15.f);

		dataSet.setDrawCircles(false);
		dataSet.setDrawCircleHole(false);

		dataSet.setHighlightEnabled(true);
		dataSet.setDrawVerticalHighlightIndicator(true);
		dataSet.setDrawHorizontalHighlightIndicator(false);
		dataSet.setHighLightColor(light ? mChart.getResources().getColor(R.color.secondary_text_light) : mChart.getResources().getColor(R.color.secondary_text_dark));

		//dataSet.setMode(LineDataSet.Mode.HORIZONTAL_BEZIER);

		if (useRightAxis) {
			dataSet.setAxisDependency(YAxis.AxisDependency.RIGHT);
		}
		return dataSet;
	}

	public static OrderedLineDataSet createGPXSlopeDataSet(@NonNull OsmandApplication ctx,
														   @NonNull LineChart mChart,
														   @NonNull GPXTrackAnalysis analysis,
														   @NonNull GPXDataSetAxisType axisType,
														   @Nullable List<Entry> eleValues,
														   boolean useRightAxis,
														   boolean drawFilled) {
		if (axisType == GPXDataSetAxisType.TIME) {
			return null;
		}
		OsmandSettings settings = ctx.getSettings();
		boolean light = settings.isLightContent();
		OsmandSettings.MetricsConstants mc = settings.METRIC_SYSTEM.get();
		boolean useFeet = (mc == OsmandSettings.MetricsConstants.MILES_AND_FEET) || (mc == OsmandSettings.MetricsConstants.MILES_AND_YARDS);
		final float convEle = useFeet ? 3.28084f : 1.0f;
		final float totalDistance = analysis.totalDistance;

		XAxis xAxis = mChart.getXAxis();
		float divX = setupXAxisDistance(ctx, xAxis, analysis.totalDistance);

		final String mainUnitY = "%";

		YAxis yAxis;
		if (useRightAxis) {
			yAxis = mChart.getAxisRight();
			yAxis.setEnabled(true);
		} else {
			yAxis = mChart.getAxisLeft();
		}
		yAxis.setTextColor(ActivityCompat.getColor(mChart.getContext(), R.color.gpx_chart_green_label));
		yAxis.setGridColor(ActivityCompat.getColor(mChart.getContext(), R.color.gpx_chart_green_grid));
		yAxis.setGranularity(1f);
		yAxis.resetAxisMinimum();
		yAxis.setValueFormatter(new IAxisValueFormatter() {

			@Override
			public String getFormattedValue(float value, AxisBase axis) {
				return (int)value + " " + mainUnitY;
			}
		});

		List<Entry> values;
		if (eleValues == null) {
			values = calculateElevationArray(analysis, GPXDataSetAxisType.DISTANCE, 1f, 1f);
		} else {
			values = new ArrayList<>(eleValues.size());
			for (Entry e : eleValues) {
				values.add(new Entry(e.getX() * divX, e.getY() / convEle));
			}
		}

		if (values == null || values.size() == 0) {
			if (useRightAxis) {
				yAxis.setEnabled(false);
			}
			return null;
		}

		int lastIndex = values.size() - 1;

		double STEP = 5;

		double[] calculatedDist = new double[(int) (totalDistance / STEP) + 1];
		double[] calculatedH = new double[(int) (totalDistance / STEP) + 1];
		int nextW = 0;
		for (int k = 0; k < calculatedDist.length; k++) {
			if (k > 0) {
				calculatedDist[k] = calculatedDist[k - 1] + STEP;
			}
			while(nextW < lastIndex && calculatedDist[k] > values.get(nextW).getX()) {
				nextW ++;
			}
			double pd = nextW == 0 ? 0 : values.get(nextW - 1).getX();
			double ph = nextW == 0 ? values.get(0).getY() : values.get(nextW - 1).getY();
			calculatedH[k] = ph + (values.get(nextW).getY() - ph) / (values.get(nextW).getX() - pd) * (calculatedDist[k] - pd);
		}

		double SLOPE_PROXIMITY = 100;

		if (totalDistance - SLOPE_PROXIMITY < 0) {
			if (useRightAxis) {
				yAxis.setEnabled(false);
			}
			return null;
		}

		double[] calculatedSlopeDist = new double[(int) ((totalDistance - SLOPE_PROXIMITY) / STEP) + 1];
		double[] calculatedSlope = new double[(int) ((totalDistance - SLOPE_PROXIMITY) / STEP) + 1];

		int index = (int) ((SLOPE_PROXIMITY / STEP) / 2);
		for (int k = 0; k < calculatedSlopeDist.length; k++) {
			calculatedSlopeDist[k] = calculatedDist[index + k];
			calculatedSlope[k] = (calculatedH[ 2 * index + k] - calculatedH[k]) * 100 / SLOPE_PROXIMITY;
			if (Double.isNaN(calculatedSlope[k])) {
				calculatedSlope[k] = 0;
			}
		}

		List<Entry> slopeValues = new ArrayList<>(calculatedSlopeDist.length);
		float prevSlope = -80000;
		float slope;
		float x;
		float lastXSameY = 0;
		boolean hasSameY = false;
		Entry lastEntry = null;
		lastIndex = calculatedSlopeDist.length - 1;
		for (int i = 0; i < calculatedSlopeDist.length; i++) {
			x = (float) calculatedSlopeDist[i] / divX;
			slope = (float) calculatedSlope[i];
			if (prevSlope != -80000) {
				if (prevSlope == slope && i < lastIndex) {
					hasSameY = true;
					lastXSameY = x;
					continue;
				}
				if (hasSameY) {
					slopeValues.add(new Entry(lastXSameY, lastEntry.getY()));
				}
				hasSameY = false;
			}
			prevSlope = slope;
			lastEntry = new Entry(x, slope);
			slopeValues.add(lastEntry);
		}

		OrderedLineDataSet dataSet = new OrderedLineDataSet(slopeValues, "", GPXDataSetType.SLOPE, axisType);
		dataSet.divX = divX;
		dataSet.units = mainUnitY;

		dataSet.setColor(ContextCompat.getColor(mChart.getContext(), R.color.gpx_chart_green));
		dataSet.setLineWidth(1f);
		if (drawFilled) {
			dataSet.setFillAlpha(128);
			dataSet.setFillColor(ContextCompat.getColor(mChart.getContext(), R.color.gpx_chart_green));
			dataSet.setDrawFilled(true);
		} else {
			dataSet.setDrawFilled(false);
		}

		dataSet.setDrawValues(false);
		dataSet.setValueTextSize(9f);
		dataSet.setFormLineWidth(1f);
		dataSet.setFormSize(15.f);

		dataSet.setDrawCircles(false);
		dataSet.setDrawCircleHole(false);

		dataSet.setHighlightEnabled(true);
		dataSet.setDrawVerticalHighlightIndicator(true);
		dataSet.setDrawHorizontalHighlightIndicator(false);
		dataSet.setHighLightColor(light ? mChart.getResources().getColor(R.color.secondary_text_light) : mChart.getResources().getColor(R.color.secondary_text_dark));

		//dataSet.setMode(LineDataSet.Mode.HORIZONTAL_BEZIER);

		/*
		dataSet.setFillFormatter(new IFillFormatter() {
			@Override
			public float getFillLinePosition(ILineDataSet dataSet, LineDataProvider dataProvider) {
				return dataProvider.getYChartMin();
			}
		});
		*/
		if (useRightAxis) {
			dataSet.setAxisDependency(YAxis.AxisDependency.RIGHT);
		}
		return dataSet;
	}

	public enum GPXDataSetType {
		ALTITUDE(R.string.altitude, R.drawable.ic_action_altitude_average),
		SPEED(R.string.map_widget_speed, R.drawable.ic_action_speed),
		SLOPE(R.string.shared_string_slope, R.drawable.ic_action_altitude_ascent);

		private int stringId;
		private int imageId;

		private GPXDataSetType(int stringId, int imageId) {
			this.stringId = stringId;
			this.imageId = imageId;
		}

		public String getName(@NonNull Context ctx) {
			return ctx.getString(stringId);
		}

		public int getStringId() {
			return stringId;
		}

		public int getImageId() {
			return imageId;
		}

		public Drawable getImageDrawable(@NonNull OsmandApplication app) {
			return app.getUIUtilities().getThemedIcon(imageId);
		}

		public static String getName(@NonNull Context ctx, @NonNull GPXDataSetType[] types) {
			List<String> list = new ArrayList<>();
			for (GPXDataSetType type : types) {
				list.add(type.getName(ctx));
			}
			Collections.sort(list);
			StringBuilder sb = new StringBuilder();
			for (String s : list) {
				if (sb.length() > 0) {
					sb.append("/");
				}
				sb.append(s);
			}
			return sb.toString();
		}

		public static Drawable getImageDrawable(@NonNull OsmandApplication app, @NonNull GPXDataSetType[] types) {
			if (types.length > 0) {
				return types[0].getImageDrawable(app);
			} else {
				return null;
			}
		}
	}

	public enum GPXDataSetAxisType {
		DISTANCE(R.string.distance, R.drawable.ic_action_marker_dark),
		TIME(R.string.shared_string_time, R.drawable.ic_action_time);

		private int stringId;
		private int imageId;

		private GPXDataSetAxisType(int stringId, int imageId) {
			this.stringId = stringId;
			this.imageId = imageId;
		}

		public String getName(Context ctx) {
			return ctx.getString(stringId);
		}

		public int getStringId() {
			return stringId;
		}

		public int getImageId() {
			return imageId;
		}

		public Drawable getImageDrawable(OsmandApplication app) {
			return app.getUIUtilities().getThemedIcon(imageId);
		}
	}

	public static class OrderedLineDataSet extends LineDataSet {

		private GPXDataSetType dataSetType;
		private GPXDataSetAxisType dataSetAxisType;

		float priority;
		String units;
		float divX = 1f;
		float divY = 1f;
		float mulY = 1f;

		OrderedLineDataSet(List<Entry> yVals, String label, GPXDataSetType dataSetType, GPXDataSetAxisType dataSetAxisType) {
			super(yVals, label);
			this.dataSetType = dataSetType;
			this.dataSetAxisType = dataSetAxisType;
		}

		public GPXDataSetType getDataSetType() {
			return dataSetType;
		}

		public GPXDataSetAxisType getDataSetAxisType() {
			return dataSetAxisType;
		}

		public float getPriority() {
			return priority;
		}

		public float getDivX() {
			return divX;
		}

		public float getDivY() {
			return divY;
		}

		public float getMulY() {
			return mulY;
		}

		public String getUnits() {
			return units;
		}
	}

	@SuppressLint("ViewConstructor")
	private static class GPXMarkerView extends MarkerView {

		private View textAltView;
		private View textSpdView;
		private View textSlpView;

		public GPXMarkerView(Context context) {
			super(context, R.layout.chart_marker_view);
			textAltView = findViewById(R.id.text_alt_container);
			textSpdView = findViewById(R.id.text_spd_container);
			textSlpView = findViewById(R.id.text_slp_container);
		}

		// callbacks everytime the MarkerView is redrawn, can be used to update the
		// content (user-interface)
		@Override
		public void refreshContent(Entry e, Highlight highlight) {
			ChartData chartData = getChartView().getData();
			if (chartData.getDataSetCount() == 1) {
				OrderedLineDataSet dataSet = (OrderedLineDataSet) chartData.getDataSetByIndex(0);
				String value = Integer.toString((int) e.getY()) + " ";
				String units = dataSet.units;
				switch (dataSet.getDataSetType()) {
					case ALTITUDE:
						((TextView) textAltView.findViewById(R.id.text_alt_value)).setText(value);
						((TextView) textAltView.findViewById(R.id.text_alt_units)).setText(units);
						textAltView.setVisibility(VISIBLE);
						textSpdView.setVisibility(GONE);
						textSlpView.setVisibility(GONE);
						break;
					case SPEED:
						((TextView) textSpdView.findViewById(R.id.text_spd_value)).setTextColor(dataSet.getColor());
						((TextView) textSpdView.findViewById(R.id.text_spd_value)).setText(value);
						((TextView) textSpdView.findViewById(R.id.text_spd_units)).setText(units);
						textAltView.setVisibility(GONE);
						textSpdView.setVisibility(VISIBLE);
						textSlpView.setVisibility(GONE);
						break;
					case SLOPE:
						((TextView) textSlpView.findViewById(R.id.text_slp_value)).setText(value);
						textAltView.setVisibility(GONE);
						textSpdView.setVisibility(GONE);
						textSlpView.setVisibility(VISIBLE);
						break;
				}
				findViewById(R.id.divider).setVisibility(GONE);
			} else if (chartData.getDataSetCount() == 2) {
				OrderedLineDataSet dataSet1 = (OrderedLineDataSet) chartData.getDataSetByIndex(0);
				OrderedLineDataSet dataSet2 = (OrderedLineDataSet) chartData.getDataSetByIndex(1);
				int altSetIndex = -1;
				int spdSetIndex = -1;
				int slpSetIndex = -1;
				switch (dataSet1.getDataSetType()) {
					case ALTITUDE:
						altSetIndex = 0;
						break;
					case SPEED:
						spdSetIndex = 0;
						break;
					case SLOPE:
						slpSetIndex = 0;
						break;
				}
				switch (dataSet2.getDataSetType()) {
					case ALTITUDE:
						altSetIndex = 1;
						break;
					case SPEED:
						spdSetIndex = 1;
						break;
					case SLOPE:
						slpSetIndex = 1;
						break;
				}
				if (altSetIndex != -1) {
					float y = getInterpolatedY(altSetIndex == 0 ? dataSet1 : dataSet2, e);
					((TextView) textAltView.findViewById(R.id.text_alt_value)).setText(Integer.toString((int) y) + " ");
					((TextView) textAltView.findViewById(R.id.text_alt_units)).setText((altSetIndex == 0 ? dataSet1.units : dataSet2.units));
					textAltView.setVisibility(VISIBLE);
				} else {
					textAltView.setVisibility(GONE);
				}
				if (spdSetIndex != -1) {
					float y = getInterpolatedY(spdSetIndex == 0 ? dataSet1 : dataSet2, e);
					((TextView) textSpdView.findViewById(R.id.text_spd_value)).setTextColor((spdSetIndex == 0 ? dataSet1 : dataSet2).getColor());
					((TextView) textSpdView.findViewById(R.id.text_spd_value)).setText(Integer.toString((int) y) + " ");
					((TextView) textSpdView.findViewById(R.id.text_spd_units)).setText(spdSetIndex == 0 ? dataSet1.units : dataSet2.units);
					textSpdView.setVisibility(VISIBLE);
				} else {
					textSpdView.setVisibility(GONE);
				}
				if (slpSetIndex != -1) {
					float y = getInterpolatedY(slpSetIndex == 0 ? dataSet1 : dataSet2, e);
					((TextView) textSlpView.findViewById(R.id.text_slp_value)).setText(Integer.toString((int) y) + " ");
					textSlpView.setVisibility(VISIBLE);
				} else {
					textSlpView.setVisibility(GONE);
				}
				findViewById(R.id.divider).setVisibility(VISIBLE);
			} else {
				textAltView.setVisibility(GONE);
				textSpdView.setVisibility(GONE);
				textSlpView.setVisibility(GONE);
				findViewById(R.id.divider).setVisibility(GONE);
			}
			super.refreshContent(e, highlight);
		}

		private float getInterpolatedY(OrderedLineDataSet ds, Entry e) {
			if (ds.getEntryIndex(e) == -1) {
				Entry upEntry = ds.getEntryForXValue(e.getX(), Float.NaN, DataSet.Rounding.UP);
				Entry downEntry = upEntry;
				int upIndex = ds.getEntryIndex(upEntry);
				if (upIndex > 0) {
					downEntry = ds.getEntryForIndex(upIndex - 1);
				}
				return MapUtils.getInterpolatedY(downEntry.getX(), downEntry.getY(), upEntry.getX(), upEntry.getY(), e.getX());
			} else {
				return e.getY();
			}
		}

		@Override
		public MPPointF getOffset() {
			if (getChartView().getData().getDataSetCount() == 2) {
				int x = findViewById(R.id.divider).getLeft();
				return new MPPointF(-x - AndroidUtils.dpToPx(getContext(), .5f), 0);
			} else {
				return new MPPointF(-getWidth() / 2f, 0);
			}
		}

		@Override
		public MPPointF getOffsetForDrawingAtPoint(float posX, float posY) {
			int margin = AndroidUtils.dpToPx(getContext(), 3f);
			MPPointF offset = getOffset();
			offset.y = -posY;
			if (posX + offset.x - margin < 0) {
				offset.x -= (offset.x + posX - margin);
			}
			if (posX + offset.x + getWidth() + margin > getChartView().getWidth()) {
				offset.x -= (getWidth() - (getChartView().getWidth() - posX) + offset.x) + margin;
			}
			return offset;
		}
	}


	public static GPXFile makeGpxFromRoute(RouteCalculationResult route, OsmandApplication app) {
		double lastHeight = HEIGHT_UNDEFINED;
		GPXFile gpx = new GPXUtilities.GPXFile(Version.getFullVersion(app));
		List<Location> locations = route.getRouteLocations();
		if (locations != null) {
			GPXUtilities.Track track = new GPXUtilities.Track();
			GPXUtilities.TrkSegment seg = new GPXUtilities.TrkSegment();
			for (Location l : locations) {
				GPXUtilities.WptPt point = new GPXUtilities.WptPt();
				point.lat = l.getLatitude();
				point.lon = l.getLongitude();
				if (l.hasAltitude()) {
					gpx.hasAltitude = true;
					float h = (float) l.getAltitude();
					point.ele = h;
					if (lastHeight == HEIGHT_UNDEFINED && seg.points.size() > 0) {
						for (GPXUtilities.WptPt pt : seg.points) {
							if (Double.isNaN(pt.ele)) {
								pt.ele = h;
							}
						}
					}
					lastHeight = h;
				}
				seg.points.add(point);
			}
			track.segments.add(seg);
			gpx.tracks.add(track);
		}
		return gpx;
	}



	public static class GPXInfo {
		private String fileName;
		private long lastModified;
		private long fileSize;
		private boolean selected;

		public GPXInfo(String fileName, long lastModified, long fileSize) {
			this.fileName = fileName;
			this.lastModified = lastModified;
			this.fileSize = fileSize;
		}

		public String getFileName() {
			return fileName;
		}

		public long getLastModified() {
			return lastModified;
		}

		public long getFileSize() {
			return fileSize;
		}

		public boolean isSelected() {
			return selected;
		}

		public void setSelected(boolean selected) {
			this.selected = selected;
		}
	}
}
!@#$%
20190530_075859,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_c03780
package net.osmand.plus.helpers;

import android.annotation.SuppressLint;
import android.annotation.TargetApi;
import android.app.Activity;
import android.app.Application;
import android.app.ProgressDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.content.Intent;
import android.graphics.Typeface;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.os.Build;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.support.v4.app.ActivityCompat;
import android.support.v4.content.ContextCompat;
import android.support.v7.app.AlertDialog;
import android.support.v7.widget.ListPopupWindow;
import android.support.v7.widget.SwitchCompat;
import android.text.SpannableString;
import android.text.style.StyleSpan;
import android.util.TypedValue;
import android.view.Gravity;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.ArrayAdapter;
import android.widget.Button;
import android.widget.CheckBox;
import android.widget.CompoundButton;
import android.widget.CompoundButton.OnCheckedChangeListener;
import android.widget.ImageView;
import android.widget.TextView;
import android.widget.Toast;

import com.github.mikephil.charting.charts.LineChart;
import com.github.mikephil.charting.components.AxisBase;
import com.github.mikephil.charting.components.Legend;
import com.github.mikephil.charting.components.MarkerView;
import com.github.mikephil.charting.components.XAxis;
import com.github.mikephil.charting.components.YAxis;
import com.github.mikephil.charting.data.ChartData;
import com.github.mikephil.charting.data.DataSet;
import com.github.mikephil.charting.data.Entry;
import com.github.mikephil.charting.data.LineDataSet;
import com.github.mikephil.charting.formatter.IAxisValueFormatter;
import com.github.mikephil.charting.formatter.IFillFormatter;
import com.github.mikephil.charting.highlight.Highlight;
import com.github.mikephil.charting.interfaces.dataprovider.LineDataProvider;
import com.github.mikephil.charting.interfaces.datasets.ILineDataSet;
import com.github.mikephil.charting.utils.MPPointF;

import net.osmand.AndroidUtils;
import net.osmand.CallbackWithObject;
import net.osmand.IndexConstants;
import net.osmand.Location;
import net.osmand.plus.ContextMenuAdapter;
import net.osmand.plus.ContextMenuItem;
import net.osmand.plus.GPXDatabase.GpxDataItem;
import net.osmand.GPXUtilities;
import net.osmand.GPXUtilities.Elevation;
import net.osmand.GPXUtilities.GPXFile;
import net.osmand.GPXUtilities.GPXTrackAnalysis;
import net.osmand.GPXUtilities.Speed;
import net.osmand.GPXUtilities.TrkSegment;
import net.osmand.plus.GpxSelectionHelper.SelectedGpxFile;
import net.osmand.plus.OsmAndFormatter;
import net.osmand.plus.OsmandApplication;
import net.osmand.plus.OsmandPlugin;
import net.osmand.plus.OsmandSettings;
import net.osmand.plus.R;
import net.osmand.plus.UiUtilities;
import net.osmand.plus.Version;
import net.osmand.plus.activities.ActivityResultListener;
import net.osmand.plus.activities.ActivityResultListener.OnActivityResultListener;
import net.osmand.plus.activities.MapActivity;
import net.osmand.plus.activities.PluginActivity;
import net.osmand.plus.activities.SettingsActivity;
import net.osmand.plus.dialogs.ConfigureMapMenu;
import net.osmand.plus.dialogs.ConfigureMapMenu.AppearanceListItem;
import net.osmand.plus.dialogs.ConfigureMapMenu.GpxAppearanceAdapter;
import net.osmand.plus.monitoring.OsmandMonitoringPlugin;
import net.osmand.plus.routing.RouteCalculationResult;
import net.osmand.render.RenderingRuleProperty;
import net.osmand.render.RenderingRulesStorage;
import net.osmand.util.Algorithms;
import net.osmand.util.MapUtils;

import java.io.File;
import java.text.DateFormat;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static com.github.mikephil.charting.components.XAxis.XAxisPosition.BOTTOM;
import static net.osmand.binary.RouteDataObject.HEIGHT_UNDEFINED;
import static net.osmand.plus.OsmAndFormatter.FEET_IN_ONE_METER;
import static net.osmand.plus.OsmAndFormatter.METERS_IN_KILOMETER;
import static net.osmand.plus.OsmAndFormatter.METERS_IN_ONE_MILE;
import static net.osmand.plus.OsmAndFormatter.METERS_IN_ONE_NAUTICALMILE;
import static net.osmand.plus.OsmAndFormatter.YARDS_IN_ONE_METER;
import static net.osmand.plus.dialogs.ConfigureMapMenu.CURRENT_TRACK_COLOR_ATTR;
import static net.osmand.plus.dialogs.ConfigureMapMenu.CURRENT_TRACK_WIDTH_ATTR;
import static net.osmand.plus.download.DownloadActivity.formatKb;
import static net.osmand.plus.download.DownloadActivity.formatMb;

public class GpxUiHelper {

	private static final int OPEN_GPX_DOCUMENT_REQUEST = 1005;

	public static String getDescription(OsmandApplication app, GPXFile result, File f, boolean html) {
		GPXTrackAnalysis analysis = result.getAnalysis(f == null ? 0 : f.lastModified());
		return getDescription(app, analysis, html);
	}

	public static String getDescription(OsmandApplication app, TrkSegment t, boolean html) {
		return getDescription(app, GPXTrackAnalysis.segment(0, t), html);
	}


	public static String getColorValue(String clr, String value, boolean html) {
		if (!html) {
			return value;
		}
		return "<font color=\"" + clr + "\">" + value + "</font>";
	}

	public static String getColorValue(String clr, String value) {
		return getColorValue(clr, value, true);
	}

	public static String getDescription(OsmandApplication app, GPXTrackAnalysis analysis, boolean html) {
		StringBuilder description = new StringBuilder();
		String nl = html ? "<br/>" : "\n";
		String timeSpanClr = Algorithms.colorToString(ContextCompat.getColor(app, R.color.gpx_time_span_color));
		String distanceClr = Algorithms.colorToString(ContextCompat.getColor(app, R.color.gpx_distance_color));
		String speedClr = Algorithms.colorToString(ContextCompat.getColor(app, R.color.gpx_speed));
		String ascClr = Algorithms.colorToString(ContextCompat.getColor(app, R.color.gpx_altitude_asc));
		String descClr = Algorithms.colorToString(ContextCompat.getColor(app, R.color.gpx_altitude_desc));
		// OUTPUT:
		// 1. Total distance, Start time, End time
		description.append(app.getString(R.string.gpx_info_distance, getColorValue(distanceClr,
						OsmAndFormatter.getFormattedDistance(analysis.totalDistance, app), html),
				getColorValue(distanceClr, analysis.points + "", html)));
		if (analysis.totalTracks > 1) {
			description.append(nl).append(app.getString(R.string.gpx_info_subtracks, getColorValue(speedClr, analysis.totalTracks + "", html)));
		}
		if (analysis.wptPoints > 0) {
			description.append(nl).append(app.getString(R.string.gpx_info_waypoints, getColorValue(speedClr, analysis.wptPoints + "", html)));
		}
		if (analysis.isTimeSpecified()) {
			description.append(nl).append(app.getString(R.string.gpx_info_start_time, analysis.startTime));
			description.append(nl).append(app.getString(R.string.gpx_info_end_time, analysis.endTime));
		}

		// 2. Time span
		if (analysis.timeSpan > 0 && analysis.timeSpan / 1000 != analysis.timeMoving / 1000) {
			final String formatDuration = Algorithms.formatDuration((int) (analysis.timeSpan / 1000), app.accessibilityEnabled());
			description.append(nl).append(app.getString(R.string.gpx_timespan,
					getColorValue(timeSpanClr, formatDuration, html)));
		}

		// 3. Time moving, if any
		if (analysis.isTimeMoving()) {
				//Next few lines for Issue 3222 heuristic testing only
				//final String formatDuration0 = Algorithms.formatDuration((int) (analysis.timeMoving0 / 1000), app.accessibilityEnabled());
				//description.append(nl).append(app.getString(R.string.gpx_timemoving,
				//		getColorValue(timeSpanClr, formatDuration0, html)));
				//description.append(" (" + getColorValue(distanceClr, OsmAndFormatter.getFormattedDistance(analysis.totalDistanceMoving0, app), html) + ")");
			final String formatDuration = Algorithms.formatDuration((int) (analysis.timeMoving / 1000), app.accessibilityEnabled());
			description.append(nl).append(app.getString(R.string.gpx_timemoving,
					getColorValue(timeSpanClr, formatDuration, html)));
			description.append(" (" + getColorValue(distanceClr, OsmAndFormatter.getFormattedDistance(analysis.totalDistanceMoving, app), html) + ")");
		}

		// 4. Elevation, eleUp, eleDown, if recorded
		if (analysis.isElevationSpecified()) {
			description.append(nl);
			description.append(app.getString(R.string.gpx_info_avg_altitude,
					getColorValue(speedClr, OsmAndFormatter.getFormattedAlt(analysis.avgElevation, app), html)));
			description.append(nl);
			String min = getColorValue(descClr, OsmAndFormatter.getFormattedAlt(analysis.minElevation, app), html);
			String max = getColorValue(ascClr, OsmAndFormatter.getFormattedAlt(analysis.maxElevation, app), html);
			String asc = getColorValue(ascClr, OsmAndFormatter.getFormattedAlt(analysis.diffElevationUp, app), html);
			String desc = getColorValue(descClr, OsmAndFormatter.getFormattedAlt(analysis.diffElevationDown, app), html);
			description.append(app.getString(R.string.gpx_info_diff_altitude, min + " - " + max));
			description.append(nl);
			description.append(app.getString(R.string.gpx_info_asc_altitude, "\u2193 " + desc + "   \u2191 " + asc + ""));
		}


		if (analysis.isSpeedSpecified()) {
			String avg = getColorValue(speedClr, OsmAndFormatter.getFormattedSpeed(analysis.avgSpeed, app), html);
			String max = getColorValue(ascClr, OsmAndFormatter.getFormattedSpeed(analysis.maxSpeed, app), html);
			description.append(nl).append(app.getString(R.string.gpx_info_average_speed, avg));
			description.append(nl).append(app.getString(R.string.gpx_info_maximum_speed, max));
		}
		return description.toString();
	}

	public static AlertDialog selectGPXFiles(List<String> selectedGpxList, final Activity activity,
											 final CallbackWithObject<GPXFile[]> callbackWithObject) {
		OsmandApplication app = (OsmandApplication) activity.getApplication();
		final File dir = app.getAppPath(IndexConstants.GPX_INDEX_DIR);
		final List<GPXInfo> allGpxList = getSortedGPXFilesInfo(dir, selectedGpxList, false);
		if (allGpxList.isEmpty()) {
			Toast.makeText(activity, R.string.gpx_files_not_found, Toast.LENGTH_LONG).show();
		}
		allGpxList.add(0, new GPXInfo(activity.getString(R.string.show_current_gpx_title), 0, 0));

		final ContextMenuAdapter adapter = createGpxContextMenuAdapter(allGpxList, selectedGpxList, true);
		return createDialog(activity, true, true, true, callbackWithObject, allGpxList, adapter);
	}

	public static AlertDialog selectGPXFile(final Activity activity,
											final boolean showCurrentGpx, final boolean multipleChoice, final CallbackWithObject<GPXFile[]> callbackWithObject) {
		OsmandApplication app = (OsmandApplication) activity.getApplication();
		final File dir = app.getAppPath(IndexConstants.GPX_INDEX_DIR);
		final List<GPXInfo> list = getSortedGPXFilesInfo(dir, null, false);
		if (list.isEmpty()) {
			Toast.makeText(activity, R.string.gpx_files_not_found, Toast.LENGTH_LONG).show();
		}
		if (!list.isEmpty() || showCurrentGpx) {
			if (showCurrentGpx) {
				list.add(0, new GPXInfo(activity.getString(R.string.show_current_gpx_title), 0, 0));
			}

			final ContextMenuAdapter adapter = createGpxContextMenuAdapter(list, null, showCurrentGpx);
			return createDialog(activity, showCurrentGpx, multipleChoice, false, callbackWithObject, list, adapter);
		}
		return null;
	}

	public static AlertDialog selectSingleGPXFile(final Activity activity, boolean showCurrentGpx,
												  final CallbackWithObject<GPXFile[]> callbackWithObject) {
		OsmandApplication app = (OsmandApplication) activity.getApplication();
		int gpxDirLength = app.getAppPath(IndexConstants.GPX_INDEX_DIR).getAbsolutePath().length();
		List<SelectedGpxFile> selectedGpxFiles = app.getSelectedGpxHelper().getSelectedGPXFiles();
		final List<GPXInfo> list = new ArrayList<>(selectedGpxFiles.size() + 1);
		if (OsmandPlugin.getEnabledPlugin(OsmandMonitoringPlugin.class) == null) {
			showCurrentGpx = false;
		}
		if (!selectedGpxFiles.isEmpty() || showCurrentGpx) {
			if (showCurrentGpx) {
				list.add(new GPXInfo(activity.getString(R.string.shared_string_currently_recording_track), 0, 0));
			}

			for (SelectedGpxFile selectedGpx : selectedGpxFiles) {
				if (!selectedGpx.getGpxFile().showCurrentTrack) {
					list.add(new GPXInfo(selectedGpx.getGpxFile().path.substring(gpxDirLength + 1), selectedGpx.getGpxFile().modifiedTime, 0));
				}
			}

			final ContextMenuAdapter adapter = createGpxContextMenuAdapter(list, null, showCurrentGpx);
			return createSingleChoiceDialog(activity, showCurrentGpx, callbackWithObject, list, adapter);
		}
		return null;
	}

	private static ContextMenuAdapter createGpxContextMenuAdapter(List<GPXInfo> allGpxList,
																  List<String> selectedGpxList,
																  boolean showCurrentTrack) {
		final ContextMenuAdapter adapter = new ContextMenuAdapter();
		//element position in adapter
		int i = 0;
		for (GPXInfo gpxInfo : allGpxList) {
			String fileName = gpxInfo.getFileName();
			String s = getGpxTitle(fileName);

			adapter.addItem(ContextMenuItem.createBuilder(s).setSelected(false)
					.setIcon(R.drawable.ic_action_polygom_dark).createItem());

			//if there's some selected files - need to mark them as selected
			if (selectedGpxList != null) {
				updateSelection(selectedGpxList, showCurrentTrack, adapter, i, fileName);
			}
			i++;
		}
		return adapter;
	}

	public static String getGpxTitle(String fileName) {
		String s = fileName;
		if (s.toLowerCase().endsWith(".gpx")) {
			s = s.substring(0, s.length() - ".gpx".length());
		}
		s = s.replace('_', ' ');
		return s;
	}

	protected static void updateSelection(List<String> selectedGpxList, boolean showCurrentTrack,
										  final ContextMenuAdapter adapter, int position, String fileName) {
		ContextMenuItem item = adapter.getItem(position);
		if (position == 0 && showCurrentTrack) {
			if (selectedGpxList.contains("")) {
				item.setSelected(true);
			}
		} else {
			for (String file : selectedGpxList) {
				if (file.endsWith(fileName)) {
					item.setSelected(true);
					break;
				}
			}
		}
	}

	private static void setDescripionInDialog(final ArrayAdapter<?> adapter, final ContextMenuAdapter cmAdapter, Activity activity,
											  final File dir, String filename, final int position) {
		final Application app = activity.getApplication();
		final File f = new File(dir, filename);
		loadGPXFileInDifferentThread(activity, new CallbackWithObject<GPXUtilities.GPXFile[]>() {

			@Override
			public boolean processResult(GPXFile[] result) {
				ContextMenuItem item = cmAdapter.getItem(position);
				item.setTitle(item.getTitle() + "\n" + getDescription((OsmandApplication) app, result[0], f, false));
				adapter.notifyDataSetInvalidated();
				return true;
			}
		}, dir, null, filename);
	}

	private static AlertDialog createSingleChoiceDialog(final Activity activity,
											final boolean showCurrentGpx,
											final CallbackWithObject<GPXFile[]> callbackWithObject,
											final List<GPXInfo> list,
											final ContextMenuAdapter adapter) {
		final OsmandApplication app = (OsmandApplication) activity.getApplication();
		final UiUtilities iconsCache = app.getUIUtilities();
		final File dir = app.getAppPath(IndexConstants.GPX_INDEX_DIR);
		AlertDialog.Builder builder = new AlertDialog.Builder(activity);
		final int layout = R.layout.list_menu_item_native_singlechoice;

		final ArrayAdapter<String> listAdapter = new ArrayAdapter<String>(activity, layout, R.id.text1,
				adapter.getItemNames()) {
			@Override
			public View getView(final int position, View convertView, ViewGroup parent) {
				// User super class to create the View
				View v = convertView;
				if (v == null) {
					v = activity.getLayoutInflater().inflate(layout, null);
				}
				final ContextMenuItem item = adapter.getItem(position);
				TextView tv = (TextView) v.findViewById(R.id.text1);
				Drawable icon;
				if (showCurrentGpx && position == 0) {
					icon = null;
				} else {
					icon = iconsCache.getThemedIcon(item.getIcon());
				}
				tv.setCompoundDrawablePadding(AndroidUtils.dpToPx(activity, 10f));
				tv.setCompoundDrawablesWithIntrinsicBounds(icon, null, null, null);
				tv.setText(item.getTitle());
				tv.setTextSize(TypedValue.COMPLEX_UNIT_SP, 16);

				return v;
			}
		};

		int selectedIndex = 0;
		String prevSelectedGpx = app.getSettings().LAST_SELECTED_GPX_TRACK_FOR_NEW_POINT.get();
		if (prevSelectedGpx != null) {
			selectedIndex = list.indexOf(prevSelectedGpx);
		}
		if (selectedIndex == -1) {
			selectedIndex = 0;
		}

		final int[] selectedPosition = {selectedIndex};
		builder.setSingleChoiceItems(listAdapter, selectedIndex, new OnClickListener() {
			@Override
			public void onClick(DialogInterface dialog, int position) {
				selectedPosition[0] = position;
			}
		});
		builder.setTitle(R.string.select_gpx)
				.setPositiveButton(R.string.shared_string_ok, new OnClickListener() {

					@Override
					public void onClick(DialogInterface dialog, int which) {

						int position = selectedPosition[0];
						if (position != -1 && position < list.size()) {
							if (showCurrentGpx && position == 0) {
								callbackWithObject.processResult(null);
								app.getSettings().LAST_SELECTED_GPX_TRACK_FOR_NEW_POINT.set(null);
							} else {
								String fileName = list.get(position).getFileName();
								app.getSettings().LAST_SELECTED_GPX_TRACK_FOR_NEW_POINT.set(fileName);
								SelectedGpxFile selectedGpxFile =
										app.getSelectedGpxHelper().getSelectedFileByName(fileName);
								if (selectedGpxFile != null) {
									callbackWithObject.processResult(new GPXFile[]{selectedGpxFile.getGpxFile()});
								} else {
									loadGPXFileInDifferentThread(activity, callbackWithObject, dir, null, fileName);
								}
							}
						}
					}
				})
				.setNegativeButton(R.string.shared_string_cancel, null);

		final AlertDialog dlg = builder.create();
		dlg.setCanceledOnTouchOutside(false);
		dlg.show();
		try {
			dlg.getListView().setFastScrollEnabled(true);
		} catch (Exception e) {
			// java.lang.ClassCastException: com.android.internal.widget.RoundCornerListAdapter
			// Unknown reason but on some devices fail
		}
		return dlg;
	}

	private static AlertDialog createDialog(final Activity activity,
											final boolean showCurrentGpx,
											final boolean multipleChoice,
											final boolean showAppearanceSetting,
											final CallbackWithObject<GPXFile[]> callbackWithObject,
											final List<GPXInfo> list,
											final ContextMenuAdapter adapter) {
		final OsmandApplication app = (OsmandApplication) activity.getApplication();
		final DateFormat dateFormat = android.text.format.DateFormat.getMediumDateFormat(activity);
		final File dir = app.getAppPath(IndexConstants.GPX_INDEX_DIR);
		AlertDialog.Builder builder = new AlertDialog.Builder(activity);
		final int layout = R.layout.gpx_track_item;
		final Map<String, String> gpxAppearanceParams = new HashMap<>();

		final ArrayAdapter<String> listAdapter = new ArrayAdapter<String>(activity, layout, R.id.title,
				adapter.getItemNames()) {

			List<GpxDataItem> dataItems = null;

			@Override
			public int getItemViewType(int position) {
				return showCurrentGpx && position == 0 ? 1 : 0;
			}

			@Override
			public int getViewTypeCount() {
				return 2;
			}

			private GpxDataItem getDataItem(GPXInfo info) {
				if (dataItems != null) {
					for (GpxDataItem item : dataItems) {
						if (item.getFile().getAbsolutePath().endsWith(info.fileName)) {
							return item;
						}
					}
				}
				return null;
			}

			@Override
			public View getView(final int position, View convertView, ViewGroup parent) {
				// User super class to create the View
				View v = convertView;
				boolean checkLayout = getItemViewType(position) == 0;
				if (v == null) {
					v = activity.getLayoutInflater().inflate(layout, null);
				}

				if (dataItems == null) {
					dataItems = app.getGpxDatabase().getItems();
				}

				final ContextMenuItem item = adapter.getItem(position);
				GPXInfo info = list.get(position);
				updateGpxInfoView(v, item.getTitle(), info, getDataItem(info), showCurrentGpx && position == 0, app);

				if (item.getSelected() == null) {
					v.findViewById(R.id.check_item).setVisibility(View.GONE);
					v.findViewById(R.id.check_local_index).setVisibility(View.GONE);
				} else {
					if (checkLayout) {
						final CheckBox ch = ((CheckBox) v.findViewById(R.id.check_local_index));
						ch.setVisibility(View.VISIBLE);
						v.findViewById(R.id.toggle_item).setVisibility(View.GONE);
						ch.setOnCheckedChangeListener(null);
						ch.setChecked(item.getSelected());
						ch.setOnCheckedChangeListener(new OnCheckedChangeListener() {
							@Override
							public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
								item.setSelected(isChecked);
							}
						});
					} else {
						final SwitchCompat ch = ((SwitchCompat) v.findViewById(R.id.toggle_item));
						ch.setVisibility(View.VISIBLE);
						v.findViewById(R.id.toggle_checkbox_item).setVisibility(View.GONE);
						ch.setOnCheckedChangeListener(null);
						ch.setChecked(item.getSelected());
						ch.setOnCheckedChangeListener(new OnCheckedChangeListener() {
							@Override
							public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
								item.setSelected(isChecked);
							}
						});
					}
					v.findViewById(R.id.check_item).setVisibility(View.VISIBLE);
				}
				return v;
			}
		};

		OnClickListener onClickListener = new OnClickListener() {
			@Override
			public void onClick(DialogInterface dialog, int position) {
			}
		};
		builder.setAdapter(listAdapter, onClickListener);
		if (multipleChoice) {
			if (showAppearanceSetting) {
				final RenderingRuleProperty trackWidthProp;
				final RenderingRuleProperty trackColorProp;
				final RenderingRulesStorage renderer = app.getRendererRegistry().getCurrentSelectedRenderer();
				if (renderer != null) {
					trackWidthProp = renderer.PROPS.getCustomRule(CURRENT_TRACK_WIDTH_ATTR);
					trackColorProp = renderer.PROPS.getCustomRule(CURRENT_TRACK_COLOR_ATTR);
				} else {
					trackWidthProp = null;
					trackColorProp = null;
				}
				if (trackWidthProp == null || trackColorProp == null) {
					builder.setTitle(R.string.show_gpx);
				} else {
					final View apprTitleView = activity.getLayoutInflater().inflate(R.layout.select_gpx_appearance_title, null);

					final OsmandSettings.CommonPreference<String> prefWidth
							= app.getSettings().getCustomRenderProperty(CURRENT_TRACK_WIDTH_ATTR);
					final OsmandSettings.CommonPreference<String> prefColor
							= app.getSettings().getCustomRenderProperty(CURRENT_TRACK_COLOR_ATTR);

					updateAppearanceTitle(activity, app, trackWidthProp, renderer, apprTitleView, prefWidth.get(), prefColor.get());

					apprTitleView.findViewById(R.id.button).setOnClickListener(new View.OnClickListener() {
						@Override
						public void onClick(View v) {
							final ListPopupWindow popup = new ListPopupWindow(activity);
							popup.setAnchorView(apprTitleView);
							popup.setContentWidth(AndroidUtils.dpToPx(activity, 200f));
							popup.setModal(true);
							popup.setDropDownGravity(Gravity.RIGHT | Gravity.TOP);
							popup.setVerticalOffset(AndroidUtils.dpToPx(activity, -48f));
							popup.setHorizontalOffset(AndroidUtils.dpToPx(activity, -6f));
							final GpxAppearanceAdapter gpxApprAdapter = new GpxAppearanceAdapter(activity,
									gpxAppearanceParams.containsKey(CURRENT_TRACK_COLOR_ATTR) ? gpxAppearanceParams.get(CURRENT_TRACK_COLOR_ATTR) : prefColor.get(),
									GpxAppearanceAdapter.GpxAppearanceAdapterType.TRACK_WIDTH_COLOR);
							popup.setAdapter(gpxApprAdapter);
							popup.setOnItemClickListener(new AdapterView.OnItemClickListener() {

								@Override
								public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
									AppearanceListItem item = gpxApprAdapter.getItem(position);
									if (item != null) {
										if (item.getAttrName() == CURRENT_TRACK_WIDTH_ATTR) {
											gpxAppearanceParams.put(CURRENT_TRACK_WIDTH_ATTR, item.getValue());
										} else if (item.getAttrName() == CURRENT_TRACK_COLOR_ATTR) {
											gpxAppearanceParams.put(CURRENT_TRACK_COLOR_ATTR, item.getValue());
										}
									}
									popup.dismiss();
									updateAppearanceTitle(activity, app, trackWidthProp, renderer,
											apprTitleView,
											gpxAppearanceParams.containsKey(CURRENT_TRACK_WIDTH_ATTR) ? gpxAppearanceParams.get(CURRENT_TRACK_WIDTH_ATTR) : prefWidth.get(),
											gpxAppearanceParams.containsKey(CURRENT_TRACK_COLOR_ATTR) ? gpxAppearanceParams.get(CURRENT_TRACK_COLOR_ATTR) : prefColor.get());
								}
							});
							popup.show();
						}
					});
					builder.setCustomTitle(apprTitleView);
				}
			} else {
				builder.setTitle(R.string.show_gpx);
			}
			builder.setPositiveButton(R.string.shared_string_ok, new OnClickListener() {

				@Override
				public void onClick(DialogInterface dialog, int which) {
					if (gpxAppearanceParams.size() > 0) {
						for (Map.Entry<String, String> entry : gpxAppearanceParams.entrySet()) {
							final OsmandSettings.CommonPreference<String> pref
									= app.getSettings().getCustomRenderProperty(entry.getKey());
							pref.set(entry.getValue());
						}
						if (activity instanceof MapActivity) {
							ConfigureMapMenu.refreshMapComplete((MapActivity) activity);
						}
					}
					GPXFile currentGPX = null;
					//clear all previously selected files before adding new one
					OsmandApplication app = (OsmandApplication) activity.getApplication();
					if (app != null && app.getSelectedGpxHelper() != null) {
						app.getSelectedGpxHelper().clearAllGpxFileToShow();
					}
					if (app != null && showCurrentGpx && adapter.getItem(0).getSelected()) {
						currentGPX = app.getSavingTrackHelper().getCurrentGpx();
					}
					List<String> s = new ArrayList<>();
					for (int i = (showCurrentGpx ? 1 : 0); i < adapter.length(); i++) {
						if (adapter.getItem(i).getSelected()) {
							s.add(list.get(i).getFileName());
						}
					}
					dialog.dismiss();
					loadGPXFileInDifferentThread(activity, callbackWithObject, dir, currentGPX,
							s.toArray(new String[s.size()]));
				}
			});
			builder.setNegativeButton(R.string.shared_string_cancel, null);
			if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT
					&& list.size() > 1 || !showCurrentGpx && list.size() > 0) {
				builder.setNeutralButton(R.string.gpx_add_track, null);
			}
		}

		final AlertDialog dlg = builder.create();
		dlg.setCanceledOnTouchOutside(true);
		if (list.size() == 0 || showCurrentGpx && list.size() == 1) {
			final View footerView = activity.getLayoutInflater().inflate(R.layout.no_gpx_files_list_footer, null);
			TextView descTextView = (TextView)footerView.findViewById(R.id.descFolder);
			String descPrefix = app.getString(R.string.gpx_no_tracks_title_folder);
			SpannableString spannableDesc = new SpannableString(descPrefix + ": " + dir.getAbsolutePath());
			spannableDesc.setSpan(new StyleSpan(android.graphics.Typeface.BOLD),
					descPrefix.length() + 1, spannableDesc.length(), 0);
			descTextView.setText(spannableDesc);
			if (Build.VERSION.SDK_INT < Build.VERSION_CODES.KITKAT) {
				footerView.findViewById(R.id.button).setVisibility(View.GONE);
			} else {
				footerView.findViewById(R.id.button).setOnClickListener(new View.OnClickListener() {
					@Override
					public void onClick(View v) {
						addTrack(activity, dlg);
					}
				});
			}
			dlg.getListView().addFooterView(footerView, null, false);
		}
		dlg.getListView().setOnItemClickListener(new OnItemClickListener() {
			@Override
			public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
				if (multipleChoice) {
					ContextMenuItem item = adapter.getItem(position);
					item.setSelected(!item.getSelected());
					listAdapter.notifyDataSetInvalidated();
					if (position == 0 && showCurrentGpx && item.getSelected()) {
						OsmandMonitoringPlugin monitoringPlugin = OsmandPlugin.getEnabledPlugin(OsmandMonitoringPlugin.class);
						if (monitoringPlugin == null) {
							AlertDialog.Builder confirm = new AlertDialog.Builder(activity);
							confirm.setPositiveButton(R.string.shared_string_ok, new DialogInterface.OnClickListener() {
								@Override
								public void onClick(DialogInterface dialog, int which) {
									Intent intent = new Intent(activity, PluginActivity.class);
									intent.putExtra(PluginActivity.EXTRA_PLUGIN_ID, OsmandMonitoringPlugin.ID);
									activity.startActivity(intent);
								}
							});
							confirm.setNegativeButton(R.string.shared_string_cancel, null);
							confirm.setMessage(activity.getString(R.string.enable_plugin_monitoring_services));
							confirm.show();
						} else if (!app.getSettings().SAVE_GLOBAL_TRACK_TO_GPX.get()) {
							monitoringPlugin.controlDialog(activity, false);
						}
					}
				} else {
					dlg.dismiss();
					if (showCurrentGpx && position == 0) {
						callbackWithObject.processResult(null);
					} else {
						String fileName = list.get(position).getFileName();
						SelectedGpxFile selectedGpxFile =
								app.getSelectedGpxHelper().getSelectedFileByName(fileName);
						if (selectedGpxFile != null) {
							callbackWithObject.processResult(new GPXFile[]{selectedGpxFile.getGpxFile()});
						} else {
							loadGPXFileInDifferentThread(activity, callbackWithObject, dir, null, fileName);
						}
					}
				}
			}
		});
		dlg.setOnShowListener(new DialogInterface.OnShowListener() {
			@Override
			public void onShow(DialogInterface dialog) {
				Button addTrackButton = ((AlertDialog) dialog).getButton(AlertDialog.BUTTON_NEUTRAL);
				if (addTrackButton != null) {
					addTrackButton.setOnClickListener(new View.OnClickListener() {
						@Override
						public void onClick(View v) {
							addTrack(activity, dlg);
						}
					});
				}
			}
		});
		dlg.show();
		try {
			dlg.getListView().setFastScrollEnabled(true);
		} catch (Exception e) {
			// java.lang.ClassCastException: com.android.internal.widget.RoundCornerListAdapter
			// Unknown reason but on some devices fail
		}
		return dlg;
	}

	public static void updateGpxInfoView(View v, String itemTitle, GPXInfo info, GpxDataItem dataItem, boolean currentlyRecordingTrack, OsmandApplication app) {
		TextView viewName = ((TextView) v.findViewById(R.id.name));
		viewName.setText(itemTitle.replace("/", "  ").trim());
		ImageView icon = (ImageView) v.findViewById(R.id.icon);
		icon.setVisibility(View.GONE);
		//icon.setImageDrawable(app.getIconsCache().getThemedIcon(R.drawable.ic_action_polygom_dark));
		viewName.setTypeface(Typeface.DEFAULT, Typeface.NORMAL);

		GPXTrackAnalysis analysis = null;
		if (currentlyRecordingTrack) {
			analysis = app.getSavingTrackHelper().getCurrentTrack().getTrackAnalysis();
		} else if (dataItem != null) {
			analysis = dataItem.getAnalysis();
		}

		boolean sectionRead = analysis == null;
		if (sectionRead) {
			v.findViewById(R.id.read_section).setVisibility(View.GONE);
			v.findViewById(R.id.unknown_section).setVisibility(View.VISIBLE);
			String date = "";
			String size = "";
			if (info.getFileSize() >= 0) {
				if (info.getFileSize() > (100 * (1 << 10))) {
					size = formatMb.format(new Object[]{(float) info.getFileSize() / (1 << 20)});
				} else {
					size = formatKb.format(new Object[]{(float) info.getFileSize() / (1 << 10)});
				}
			}
			DateFormat df = app.getResourceManager().getDateFormat();
			long fd = info.getLastModified();
			if (fd > 0) {
				date = (df.format(new Date(fd)));
			}
			TextView sizeText = (TextView) v.findViewById(R.id.date_and_size_details);
			sizeText.setText(date + " \u2022 " + size);

		} else {
			v.findViewById(R.id.read_section).setVisibility(View.VISIBLE);
			v.findViewById(R.id.unknown_section).setVisibility(View.GONE);
			ImageView distanceI = (ImageView) v.findViewById(R.id.distance_icon);
			distanceI.setVisibility(View.VISIBLE);
			distanceI.setImageDrawable(app.getUIUtilities().getThemedIcon(R.drawable.ic_small_distance));
			ImageView pointsI = (ImageView) v.findViewById(R.id.points_icon);
			pointsI.setVisibility(View.VISIBLE);
			pointsI.setImageDrawable(app.getUIUtilities().getThemedIcon(R.drawable.ic_small_point));
			ImageView timeI = (ImageView) v.findViewById(R.id.time_icon);
			timeI.setVisibility(View.VISIBLE);
			timeI.setImageDrawable(app.getUIUtilities().getThemedIcon(R.drawable.ic_small_time));
			TextView time = (TextView) v.findViewById(R.id.time);
			TextView distance = (TextView) v.findViewById(R.id.distance);
			TextView pointsCount = (TextView) v.findViewById(R.id.points_count);
			pointsCount.setText(analysis.wptPoints + "");
			distance.setText(OsmAndFormatter.getFormattedDistance(analysis.totalDistance, app));

			if (analysis.isTimeSpecified()) {
				time.setText(Algorithms.formatDuration((int) (analysis.timeSpan / 1000), app.accessibilityEnabled()) + "");
			} else {
				time.setText("");
			}
		}

		TextView descr = ((TextView) v.findViewById(R.id.description));
		descr.setVisibility(View.GONE);

		v.findViewById(R.id.check_item).setVisibility(View.GONE);
	}

	@TargetApi(Build.VERSION_CODES.KITKAT)
	private static void addTrack(final Activity activity, final AlertDialog dialog) {
		if (activity instanceof MapActivity) {
			final MapActivity mapActivity = (MapActivity) activity;
			ActivityResultListener listener = new ActivityResultListener(OPEN_GPX_DOCUMENT_REQUEST, new OnActivityResultListener() {
				@Override
				public void onResult(int resultCode, Intent resultData) {
					if (resultCode == Activity.RESULT_OK) {
						if (resultData != null) {
							Uri uri = resultData.getData();
							if (mapActivity.getImportHelper().handleGpxImport(uri, false)) {
								dialog.dismiss();
							}
						}
					}
				}
			});

			Intent intent = new Intent(Intent.ACTION_OPEN_DOCUMENT);
			//intent.addCategory(Intent.CATEGORY_OPENABLE);
			//intent.setType("application/gpx+xml");
			//intent.setType("text/plain");
			//intent.setType("text/xml");
			intent.setType("*/*");
			mapActivity.registerActivityResultListener(listener);
			activity.startActivityForResult(intent, OPEN_GPX_DOCUMENT_REQUEST);
		}
	}

	private static void updateAppearanceTitle(Activity activity, OsmandApplication app,
											  RenderingRuleProperty trackWidthProp,
											  RenderingRulesStorage renderer,
											  View apprTitleView,
											  String prefWidthValue,
											  String prefColorValue) {
		TextView widthTextView = (TextView) apprTitleView.findViewById(R.id.widthTitle);
		ImageView colorImageView = (ImageView) apprTitleView.findViewById(R.id.colorImage);
		if (Algorithms.isEmpty(prefWidthValue)) {
			widthTextView.setText(SettingsActivity.getStringPropertyValue(activity, trackWidthProp.getDefaultValueDescription()));
		} else {
			widthTextView.setText(SettingsActivity.getStringPropertyValue(activity, prefWidthValue));
		}
		int color = GpxAppearanceAdapter.parseTrackColor(renderer, prefColorValue);
		if (color == -1) {
			colorImageView.setImageDrawable(app.getUIUtilities().getThemedIcon(R.drawable.ic_action_circle));
		} else {
			colorImageView.setImageDrawable(app.getUIUtilities().getPaintedIcon(R.drawable.ic_action_circle, color));
		}
	}

	public static List<GPXInfo> getSortedGPXFilesInfoByDate(File dir, boolean absolutePath) {
		final List<GPXInfo> list = new ArrayList<>();
		readGpxDirectory(dir, list, "", absolutePath);
		Collections.sort(list, new Comparator<GPXInfo>() {
			@Override
			public int compare(GPXInfo object1, GPXInfo object2) {
				long lhs = object1.getLastModified();
				long rhs = object2.getLastModified();
				return lhs < rhs ? 1 : (lhs == rhs ? 0 : -1);
			}
		});
		return list;
	}


	public static List<GPXInfo> getSortedGPXFilesInfo(File dir, final List<String> selectedGpxList, boolean absolutePath) {
		final List<GPXInfo> list = new ArrayList<>();
		readGpxDirectory(dir, list, "", absolutePath);
		if (selectedGpxList != null) {
			for (GPXInfo info : list) {
				for (String fileName : selectedGpxList) {
					if (fileName.endsWith(info.getFileName())) {
						info.setSelected(true);
						break;
					}
				}
			}
		}
		Collections.sort(list, new Comparator<GPXInfo>() {
			@Override
			public int compare(GPXInfo i1, GPXInfo i2) {
				int res = i1.isSelected() == i2.isSelected() ? 0 : i1.isSelected() ? -1 : 1;
				if (res != 0) {
					return res;
				}

				String name1 = i1.getFileName();
				String name2 = i2.getFileName();
				int d1 = depth(name1);
				int d2 = depth(name2);
				if (d1 != d2) {
					return d1 - d2;
				}
				int lastSame = 0;
				for (int i = 0; i < name1.length() && i < name2.length(); i++) {
					if (name1.charAt(i) != name2.charAt(i)) {
						break;
					}
					if (name1.charAt(i) == '/') {
						lastSame = i + 1;
					}
				}

				boolean isDigitStarts1 = isLastSameStartsWithDigit(name1, lastSame);
				boolean isDigitStarts2 = isLastSameStartsWithDigit(name2, lastSame);
				res = isDigitStarts1 == isDigitStarts2 ? 0 : isDigitStarts1 ? -1 : 1;
				if (res != 0) {
					return res;
				}
				if (isDigitStarts1) {
					return -name1.compareToIgnoreCase(name2);
				}
				return name1.compareToIgnoreCase(name2);
			}

			private int depth(String name1) {
				int d = 0;
				for (int i = 0; i < name1.length(); i++) {
					if (name1.charAt(i) == '/') {
						d++;
					}
				}
				return d;
			}

			private boolean isLastSameStartsWithDigit(String name1, int lastSame) {
				if (name1.length() > lastSame) {
					return Character.isDigit(name1.charAt(lastSame));
				}

				return false;
			}
		});
		return list;
	}

	private static void readGpxDirectory(File dir, final List<GPXInfo> list, String parent,
										 boolean absolutePath) {
		if (dir != null && dir.canRead()) {
			File[] files = dir.listFiles();
			if (files != null) {
				for (File f : files) {
					if (f.getName().toLowerCase().endsWith(".gpx")) { //$NON-NLS-1$
						list.add(new GPXInfo(absolutePath ? f.getAbsolutePath() :
								parent + f.getName(), f.lastModified(), f.length()));
					} else if (f.isDirectory()) {
						readGpxDirectory(f, list, parent + f.getName() + "/", absolutePath);
					}
				}
			}
		}
	}


	private static void loadGPXFileInDifferentThread(final Activity activity, final CallbackWithObject<GPXFile[]> callbackWithObject,
													 final File dir, final GPXFile currentFile, final String... filename) {
		final ProgressDialog dlg = ProgressDialog.show(activity, activity.getString(R.string.loading_smth, ""),
				activity.getString(R.string.loading_data));
		new Thread(new Runnable() {
			@Override
			public void run() {
				final GPXFile[] result = new GPXFile[filename.length + (currentFile == null ? 0 : 1)];
				int k = 0;
				String w = "";
				if (currentFile != null) {
					result[k++] = currentFile;
				}
				for (String fname : filename) {
					final File f = new File(dir, fname);
					GPXFile res = GPXUtilities.loadGPXFile(f);
					if (res.error != null && res.error.getMessage().length() > 0) {
						w += res.error.getMessage() + "\n";
					}
					result[k++] = res;
				}
				dlg.dismiss();
				final String warn = w;
				activity.runOnUiThread(new Runnable() {
					@Override
					public void run() {
						if (warn.length() > 0) {
							Toast.makeText(activity, warn, Toast.LENGTH_LONG).show();
						} else {
							callbackWithObject.processResult(result);
						}
					}
				});
			}

		}, "Loading gpx").start(); //$NON-NLS-1$
	}

	public static void setupGPXChart(OsmandApplication ctx, LineChart mChart, int yLabelsCount) {
		OsmandSettings settings = ctx.getSettings();
		setupGPXChart(mChart, yLabelsCount, 24f, 16f, settings.isLightContent(), true);
	}

	public static void setupGPXChart(LineChart mChart, int yLabelsCount, float topOffset, float bottomOffset, boolean light, boolean useGesturesAndScale) {
		if (android.os.Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
			mChart.setHardwareAccelerationEnabled(false);
		} else {
			mChart.setHardwareAccelerationEnabled(true);
		}
		mChart.setTouchEnabled(useGesturesAndScale);
		mChart.setDragEnabled(useGesturesAndScale);
		mChart.setScaleEnabled(useGesturesAndScale);
		mChart.setPinchZoom(useGesturesAndScale);
		mChart.setScaleYEnabled(false);
		mChart.setAutoScaleMinMaxEnabled(true);
		mChart.setDrawBorders(false);
		mChart.getDescription().setEnabled(false);
		mChart.setMaxVisibleValueCount(10);
		mChart.setMinOffset(0f);
		mChart.setDragDecelerationEnabled(false);

		mChart.setExtraTopOffset(topOffset);
		mChart.setExtraBottomOffset(bottomOffset);

		// create a custom MarkerView (extend MarkerView) and specify the layout
		// to use for it
		GPXMarkerView mv = new GPXMarkerView(mChart.getContext());
		mv.setChartView(mChart); // For bounds control
		mChart.setMarker(mv); // Set the marker to the chart
		mChart.setDrawMarkers(true);

		XAxis xAxis = mChart.getXAxis();
		xAxis.setDrawAxisLine(false);
		xAxis.setDrawGridLines(true);
		xAxis.setGridLineWidth(1.5f);
		xAxis.setGridColor(ActivityCompat.getColor(mChart.getContext(), R.color.gpx_chart_black_grid));
		xAxis.enableGridDashedLine(25f, Float.MAX_VALUE, 0f);
		xAxis.setPosition(BOTTOM);
		xAxis.setTextColor(light ? mChart.getResources().getColor(R.color.secondary_text_light) : mChart.getResources().getColor(R.color.secondary_text_dark));

		YAxis yAxis = mChart.getAxisLeft();
		yAxis.enableGridDashedLine(10f, 5f, 0f);
		yAxis.setGridColor(ActivityCompat.getColor(mChart.getContext(), R.color.divider_color));
		yAxis.setDrawAxisLine(false);
		yAxis.setPosition(YAxis.YAxisLabelPosition.INSIDE_CHART);
		yAxis.setXOffset(16f);
		yAxis.setYOffset(-6f);
		yAxis.setLabelCount(yLabelsCount);
		yAxis.setTextColor(light ? mChart.getResources().getColor(R.color.secondary_text_light) : mChart.getResources().getColor(R.color.secondary_text_dark));

		yAxis = mChart.getAxisRight();
		yAxis.enableGridDashedLine(10f, 5f, 0f);
		yAxis.setGridColor(ActivityCompat.getColor(mChart.getContext(), R.color.divider_color));
		yAxis.setDrawAxisLine(false);
		yAxis.setPosition(YAxis.YAxisLabelPosition.INSIDE_CHART);
		yAxis.setXOffset(16f);
		yAxis.setYOffset(-6f);
		yAxis.setLabelCount(yLabelsCount);
		yAxis.setTextColor(light ? mChart.getResources().getColor(R.color.secondary_text_light) : mChart.getResources().getColor(R.color.secondary_text_dark));
		yAxis.setEnabled(false);

		Legend legend = mChart.getLegend();
		legend.setEnabled(false);
	}

	private static float setupXAxisDistance(OsmandApplication ctx, XAxis xAxis, float meters) {
		OsmandSettings settings = ctx.getSettings();
		OsmandSettings.MetricsConstants mc = settings.METRIC_SYSTEM.get();
		float divX;

		String format1 = "{0,number,0.#} ";
		String format2 = "{0,number,0.##} ";
		String fmt = null;
		float granularity = 1f;
		int mainUnitStr;
		float mainUnitInMeters;
		if (mc == OsmandSettings.MetricsConstants.KILOMETERS_AND_METERS) {
			mainUnitStr = R.string.km;
			mainUnitInMeters = METERS_IN_KILOMETER;
		} else if (mc == OsmandSettings.MetricsConstants.NAUTICAL_MILES) {
			mainUnitStr = R.string.nm;
			mainUnitInMeters = METERS_IN_ONE_NAUTICALMILE;
		} else {
			mainUnitStr = R.string.mile;
			mainUnitInMeters = METERS_IN_ONE_MILE;
		}
		if (meters > 9.99f * mainUnitInMeters) {
			fmt = format1;
			granularity = .1f;
		}
		if (meters >= 100 * mainUnitInMeters ||
				meters > 9.99f * mainUnitInMeters ||
				meters > 0.999f * mainUnitInMeters ||
				mc == OsmandSettings.MetricsConstants.MILES_AND_FEET && meters > 0.249f * mainUnitInMeters ||
				mc == OsmandSettings.MetricsConstants.MILES_AND_METERS && meters > 0.249f * mainUnitInMeters ||
				mc == OsmandSettings.MetricsConstants.MILES_AND_YARDS && meters > 0.249f * mainUnitInMeters ||
				mc == OsmandSettings.MetricsConstants.NAUTICAL_MILES && meters > 0.99f * mainUnitInMeters) {

			divX = mainUnitInMeters;
			if (fmt == null) {
				fmt = format2;
				granularity = .01f;
			}
		} else {
			fmt = null;
			granularity = 1f;
			if (mc == OsmandSettings.MetricsConstants.KILOMETERS_AND_METERS || mc == OsmandSettings.MetricsConstants.MILES_AND_METERS) {
				divX = 1f;
				mainUnitStr = R.string.m;
			} else if (mc == OsmandSettings.MetricsConstants.MILES_AND_FEET) {
				divX = 1f / FEET_IN_ONE_METER;
				mainUnitStr = R.string.foot;
			} else if (mc == OsmandSettings.MetricsConstants.MILES_AND_YARDS) {
				divX = 1f / YARDS_IN_ONE_METER;
				mainUnitStr = R.string.yard;
			} else {
				divX = 1f;
				mainUnitStr = R.string.m;
			}
		}

		final String formatX = fmt;
		final String mainUnitX = ctx.getString(mainUnitStr);

		xAxis.setGranularity(granularity);
		xAxis.setValueFormatter(new IAxisValueFormatter() {

			@Override
			public String getFormattedValue(float value, AxisBase axis) {
				if (!Algorithms.isEmpty(formatX)) {
					return MessageFormat.format(formatX + mainUnitX, value);
				} else {
					return (int)value + " " + mainUnitX;
				}
			}
		});

		return divX;
	}

	private static float setupXAxisTime(XAxis xAxis, long timeSpan) {

		final boolean useHours = timeSpan / 3600000 > 0;
		xAxis.setGranularity(1f);
		xAxis.setValueFormatter(new IAxisValueFormatter() {

			@Override
			public String getFormattedValue(float value, AxisBase axis) {
				int seconds = (int)value;
				if (useHours) {
					int hours = seconds / (60 * 60);
					int minutes = (seconds / 60) % 60;
					int sec = seconds % 60;
					return hours + ":" + (minutes < 10 ? "0" + minutes : minutes) + ":" + (sec < 10 ? "0" + sec : sec);
				} else {
					int minutes = (seconds / 60) % 60;
					int sec = seconds % 60;
					return (minutes < 10 ? "0" + minutes : minutes) + ":" + (sec < 10 ? "0" + sec : sec);
				}
			}
		});

		return 1f;
	}

	private static List<Entry> calculateElevationArray(GPXTrackAnalysis analysis, GPXDataSetAxisType axisType,
													   float divX, float convEle) {
		List<Entry> values = new ArrayList<>();
		List<Elevation> elevationData = analysis.elevationData;
		float nextX = 0;
		float nextY;
		float elev;
		float prevElevOrig = -80000;
		float prevElev = 0;
		int i = -1;
		int lastIndex = elevationData.size() - 1;
		Entry lastEntry = null;
		float lastXSameY = -1;
		boolean hasSameY = false;
		float x;
		for (Elevation e : elevationData) {
			i++;
			x = axisType == GPXDataSetAxisType.TIME ? e.time : e.distance;
			if (x > 0) {
				nextX += x / divX;
				if (!Float.isNaN(e.elevation)) {
					elev = e.elevation;
					if (prevElevOrig != -80000) {
						if (elev > prevElevOrig) {
							elev -= 1f;
						} else if (prevElevOrig == elev && i < lastIndex) {
							hasSameY = true;
							lastXSameY = nextX;
							continue;
						}
						if (prevElev == elev && i < lastIndex) {
							hasSameY = true;
							lastXSameY = nextX;
							continue;
						}
						if (hasSameY) {
							values.add(new Entry(lastXSameY, lastEntry.getY()));
						}
						hasSameY = false;
					}
					prevElevOrig = e.elevation;
					prevElev = elev;
					nextY = elev * convEle;
					lastEntry = new Entry(nextX, nextY);
					values.add(lastEntry);
				}
			}
		}
		return values;
	}

	public static OrderedLineDataSet createGPXElevationDataSet(@NonNull OsmandApplication ctx,
															   @NonNull LineChart mChart,
															   @NonNull GPXTrackAnalysis analysis,
															   @NonNull GPXDataSetAxisType axisType,
															   boolean useRightAxis,
															   boolean drawFilled) {
		OsmandSettings settings = ctx.getSettings();
		OsmandSettings.MetricsConstants mc = settings.METRIC_SYSTEM.get();
		boolean useFeet = (mc == OsmandSettings.MetricsConstants.MILES_AND_FEET) || (mc == OsmandSettings.MetricsConstants.MILES_AND_YARDS);
		boolean light = settings.isLightContent();
		final float convEle = useFeet ? 3.28084f : 1.0f;

		float divX;
		XAxis xAxis = mChart.getXAxis();
		if (axisType == GPXDataSetAxisType.TIME && analysis.isTimeSpecified()) {
			divX = setupXAxisTime(xAxis, analysis.timeSpan);
		} else {
			divX = setupXAxisDistance(ctx, xAxis, analysis.totalDistance);
		}

		final String mainUnitY = useFeet ? ctx.getString(R.string.foot) : ctx.getString(R.string.m);

		YAxis yAxis;
		if (useRightAxis) {
			yAxis = mChart.getAxisRight();
			yAxis.setEnabled(true);
		} else {
			yAxis = mChart.getAxisLeft();
		}
		yAxis.setTextColor(ActivityCompat.getColor(mChart.getContext(), R.color.gpx_chart_blue_label));
		yAxis.setGridColor(ActivityCompat.getColor(mChart.getContext(), R.color.gpx_chart_blue_grid));
		yAxis.setGranularity(1f);
		yAxis.resetAxisMinimum();
		yAxis.setValueFormatter(new IAxisValueFormatter() {

			@Override
			public String getFormattedValue(float value, AxisBase axis) {
				return (int)value + " " + mainUnitY;
			}
		});

		List<Entry> values = calculateElevationArray(analysis, axisType, divX, convEle);

		OrderedLineDataSet dataSet = new OrderedLineDataSet(values, "", GPXDataSetType.ALTITUDE, axisType);
		dataSet.priority = (float) (analysis.avgElevation - analysis.minElevation) * convEle;
		dataSet.divX = divX;
		dataSet.mulY = convEle;
		dataSet.divY = Float.NaN;
		dataSet.units = mainUnitY;

		dataSet.setColor(ContextCompat.getColor(mChart.getContext(), R.color.gpx_chart_blue));
		dataSet.setLineWidth(1f);
		if (drawFilled) {
			dataSet.setFillAlpha(128);
			dataSet.setFillColor(ContextCompat.getColor(mChart.getContext(), R.color.gpx_chart_blue));
			dataSet.setDrawFilled(true);
		} else {
			dataSet.setDrawFilled(false);
		}

		dataSet.setDrawValues(false);
		dataSet.setValueTextSize(9f);
		dataSet.setFormLineWidth(1f);
		dataSet.setFormSize(15.f);

		dataSet.setDrawCircles(false);
		dataSet.setDrawCircleHole(false);

		dataSet.setHighlightEnabled(true);
		dataSet.setDrawVerticalHighlightIndicator(true);
		dataSet.setDrawHorizontalHighlightIndicator(false);
		dataSet.setHighLightColor(light ? mChart.getResources().getColor(R.color.secondary_text_light) : mChart.getResources().getColor(R.color.secondary_text_dark));

		//dataSet.setMode(LineDataSet.Mode.HORIZONTAL_BEZIER);

		dataSet.setFillFormatter(new IFillFormatter() {
			@Override
			public float getFillLinePosition(ILineDataSet dataSet, LineDataProvider dataProvider) {
				return dataProvider.getYChartMin();
			}
		});
		if (useRightAxis) {
			dataSet.setAxisDependency(YAxis.AxisDependency.RIGHT);
		}
		return dataSet;
	}

	public static OrderedLineDataSet createGPXSpeedDataSet(@NonNull OsmandApplication ctx,
														   @NonNull LineChart mChart,
														   @NonNull GPXTrackAnalysis analysis,
														   @NonNull GPXDataSetAxisType axisType,
														   boolean useRightAxis,
														   boolean drawFilled) {
		OsmandSettings settings = ctx.getSettings();
		boolean light = settings.isLightContent();

		float divX;
		XAxis xAxis = mChart.getXAxis();
		if (axisType == GPXDataSetAxisType.TIME && analysis.isTimeSpecified()) {
			divX = setupXAxisTime(xAxis, analysis.timeSpan);
		} else {
			divX = setupXAxisDistance(ctx, xAxis, analysis.totalDistance);
		}

		OsmandSettings.SpeedConstants sps = settings.SPEED_SYSTEM.get();
		float mulSpeed = Float.NaN;
		float divSpeed = Float.NaN;
		final String mainUnitY = sps.toShortString(ctx);
		if (sps == OsmandSettings.SpeedConstants.KILOMETERS_PER_HOUR) {
			mulSpeed = 3.6f;
		} else if (sps == OsmandSettings.SpeedConstants.MILES_PER_HOUR) {
			mulSpeed = 3.6f * METERS_IN_KILOMETER / METERS_IN_ONE_MILE;
		} else if (sps == OsmandSettings.SpeedConstants.NAUTICALMILES_PER_HOUR) {
			mulSpeed = 3.6f * METERS_IN_KILOMETER / METERS_IN_ONE_NAUTICALMILE;
		} else if (sps == OsmandSettings.SpeedConstants.MINUTES_PER_KILOMETER) {
			divSpeed = METERS_IN_KILOMETER / 60;
		} else if (sps == OsmandSettings.SpeedConstants.MINUTES_PER_MILE) {
			divSpeed = METERS_IN_ONE_MILE / 60;
		} else {
			mulSpeed = 1f;
		}

		YAxis yAxis;
		if (useRightAxis) {
			yAxis = mChart.getAxisRight();
			yAxis.setEnabled(true);
		} else {
			yAxis = mChart.getAxisLeft();
		}
		if (analysis.hasSpeedInTrack()) {
			yAxis.setTextColor(ActivityCompat.getColor(mChart.getContext(), R.color.gpx_chart_orange_label));
			yAxis.setGridColor(ActivityCompat.getColor(mChart.getContext(), R.color.gpx_chart_orange_grid));
		} else {
			yAxis.setTextColor(ActivityCompat.getColor(mChart.getContext(), R.color.gpx_chart_red_label));
			yAxis.setGridColor(ActivityCompat.getColor(mChart.getContext(), R.color.gpx_chart_red_grid));
		}

		yAxis.setAxisMinimum(0f);

		ArrayList<Entry> values = new ArrayList<>();
		List<Speed> speedData = analysis.speedData;
		float nextX = 0;
		float nextY;
		float x;
		for (Speed s : speedData) {
			x = axisType == GPXDataSetAxisType.TIME ? s.time : s.distance;
			if (x > 0) {
				if (axisType == GPXDataSetAxisType.TIME && x > 60) {
					values.add(new Entry(nextX + 1, 0));
					values.add(new Entry(nextX + x - 1, 0));
				}
				nextX += x / divX;
				if (Float.isNaN(divSpeed)) {
					nextY = s.speed * mulSpeed;
				} else {
					nextY = divSpeed / s.speed;
				}
				if (nextY < 0 || Float.isInfinite(nextY)) {
					nextY = 0;
				}
				values.add(new Entry(nextX, nextY));
			}
		}

		OrderedLineDataSet dataSet = new OrderedLineDataSet(values, "", GPXDataSetType.SPEED, axisType);

		String format = null;
		if (dataSet.getYMax() < 3) {
			format = "{0,number,0.#} ";
		}
		final String formatY = format;
		yAxis.setValueFormatter(new IAxisValueFormatter() {

			@Override
			public String getFormattedValue(float value, AxisBase axis) {
				if (!Algorithms.isEmpty(formatY)) {
					return MessageFormat.format(formatY + mainUnitY, value);
				} else {
					return (int)value + " " + mainUnitY;
				}
			}
		});

		if (Float.isNaN(divSpeed)) {
			dataSet.priority = analysis.avgSpeed * mulSpeed;
		} else {
			dataSet.priority = divSpeed / analysis.avgSpeed;
		}
		dataSet.divX = divX;
		if (Float.isNaN(divSpeed)) {
			dataSet.mulY = mulSpeed;
			dataSet.divY = Float.NaN;
		} else {
			dataSet.divY = divSpeed;
			dataSet.mulY = Float.NaN;
		}
		dataSet.units = mainUnitY;

		if (analysis.hasSpeedInTrack()) {
			dataSet.setColor(ContextCompat.getColor(mChart.getContext(), R.color.gpx_chart_orange));
		} else {
			dataSet.setColor(ContextCompat.getColor(mChart.getContext(), R.color.gpx_chart_red));
		}
		dataSet.setLineWidth(1f);
		if (drawFilled) {
			dataSet.setFillAlpha(128);
			if (analysis.hasSpeedInTrack()) {
				dataSet.setFillColor(ContextCompat.getColor(mChart.getContext(), R.color.gpx_chart_orange));
			} else {
				dataSet.setFillColor(ContextCompat.getColor(mChart.getContext(), R.color.gpx_chart_red));
			}
			dataSet.setDrawFilled(true);
		} else {
			dataSet.setDrawFilled(false);
		}
		dataSet.setDrawValues(false);
		dataSet.setValueTextSize(9f);
		dataSet.setFormLineWidth(1f);
		dataSet.setFormSize(15.f);

		dataSet.setDrawCircles(false);
		dataSet.setDrawCircleHole(false);

		dataSet.setHighlightEnabled(true);
		dataSet.setDrawVerticalHighlightIndicator(true);
		dataSet.setDrawHorizontalHighlightIndicator(false);
		dataSet.setHighLightColor(light ? mChart.getResources().getColor(R.color.secondary_text_light) : mChart.getResources().getColor(R.color.secondary_text_dark));

		//dataSet.setMode(LineDataSet.Mode.HORIZONTAL_BEZIER);

		if (useRightAxis) {
			dataSet.setAxisDependency(YAxis.AxisDependency.RIGHT);
		}
		return dataSet;
	}

	public static OrderedLineDataSet createGPXSlopeDataSet(@NonNull OsmandApplication ctx,
														   @NonNull LineChart mChart,
														   @NonNull GPXTrackAnalysis analysis,
														   @NonNull GPXDataSetAxisType axisType,
														   @Nullable List<Entry> eleValues,
														   boolean useRightAxis,
														   boolean drawFilled) {
		if (axisType == GPXDataSetAxisType.TIME) {
			return null;
		}
		OsmandSettings settings = ctx.getSettings();
		boolean light = settings.isLightContent();
		OsmandSettings.MetricsConstants mc = settings.METRIC_SYSTEM.get();
		boolean useFeet = (mc == OsmandSettings.MetricsConstants.MILES_AND_FEET) || (mc == OsmandSettings.MetricsConstants.MILES_AND_YARDS);
		final float convEle = useFeet ? 3.28084f : 1.0f;
		final float totalDistance = analysis.totalDistance;

		XAxis xAxis = mChart.getXAxis();
		float divX = setupXAxisDistance(ctx, xAxis, analysis.totalDistance);

		final String mainUnitY = "%";

		YAxis yAxis;
		if (useRightAxis) {
			yAxis = mChart.getAxisRight();
			yAxis.setEnabled(true);
		} else {
			yAxis = mChart.getAxisLeft();
		}
		yAxis.setTextColor(ActivityCompat.getColor(mChart.getContext(), R.color.gpx_chart_green_label));
		yAxis.setGridColor(ActivityCompat.getColor(mChart.getContext(), R.color.gpx_chart_green_grid));
		yAxis.setGranularity(1f);
		yAxis.resetAxisMinimum();
		yAxis.setValueFormatter(new IAxisValueFormatter() {

			@Override
			public String getFormattedValue(float value, AxisBase axis) {
				return (int)value + " " + mainUnitY;
			}
		});

		List<Entry> values;
		if (eleValues == null) {
			values = calculateElevationArray(analysis, GPXDataSetAxisType.DISTANCE, 1f, 1f);
		} else {
			values = new ArrayList<>(eleValues.size());
			for (Entry e : eleValues) {
				values.add(new Entry(e.getX() * divX, e.getY() / convEle));
			}
		}

		if (values == null || values.size() == 0) {
			if (useRightAxis) {
				yAxis.setEnabled(false);
			}
			return null;
		}

		int lastIndex = values.size() - 1;

		double STEP = 5;

		double[] calculatedDist = new double[(int) (totalDistance / STEP) + 1];
		double[] calculatedH = new double[(int) (totalDistance / STEP) + 1];
		int nextW = 0;
		for (int k = 0; k < calculatedDist.length; k++) {
			if (k > 0) {
				calculatedDist[k] = calculatedDist[k - 1] + STEP;
			}
			while(nextW < lastIndex && calculatedDist[k] > values.get(nextW).getX()) {
				nextW ++;
			}
			double pd = nextW == 0 ? 0 : values.get(nextW - 1).getX();
			double ph = nextW == 0 ? values.get(0).getY() : values.get(nextW - 1).getY();
			calculatedH[k] = ph + (values.get(nextW).getY() - ph) / (values.get(nextW).getX() - pd) * (calculatedDist[k] - pd);
		}

		double SLOPE_PROXIMITY = 100;

		if (totalDistance - SLOPE_PROXIMITY < 0) {
			if (useRightAxis) {
				yAxis.setEnabled(false);
			}
			return null;
		}

		double[] calculatedSlopeDist = new double[(int) ((totalDistance - SLOPE_PROXIMITY) / STEP) + 1];
		double[] calculatedSlope = new double[(int) ((totalDistance - SLOPE_PROXIMITY) / STEP) + 1];

		int index = (int) ((SLOPE_PROXIMITY / STEP) / 2);
		for (int k = 0; k < calculatedSlopeDist.length; k++) {
			calculatedSlopeDist[k] = calculatedDist[index + k];
			calculatedSlope[k] = (calculatedH[ 2 * index + k] - calculatedH[k]) * 100 / SLOPE_PROXIMITY;
			if (Double.isNaN(calculatedSlope[k])) {
				calculatedSlope[k] = 0;
			}
		}

		List<Entry> slopeValues = new ArrayList<>(calculatedSlopeDist.length);
		float prevSlope = -80000;
		float slope;
		float x;
		float lastXSameY = 0;
		boolean hasSameY = false;
		Entry lastEntry = null;
		lastIndex = calculatedSlopeDist.length - 1;
		for (int i = 0; i < calculatedSlopeDist.length; i++) {
			x = (float) calculatedSlopeDist[i] / divX;
			slope = (float) calculatedSlope[i];
			if (prevSlope != -80000) {
				if (prevSlope == slope && i < lastIndex) {
					hasSameY = true;
					lastXSameY = x;
					continue;
				}
				if (hasSameY) {
					slopeValues.add(new Entry(lastXSameY, lastEntry.getY()));
				}
				hasSameY = false;
			}
			prevSlope = slope;
			lastEntry = new Entry(x, slope);
			slopeValues.add(lastEntry);
		}

		OrderedLineDataSet dataSet = new OrderedLineDataSet(slopeValues, "", GPXDataSetType.SLOPE, axisType);
		dataSet.divX = divX;
		dataSet.units = mainUnitY;

		dataSet.setColor(ContextCompat.getColor(mChart.getContext(), R.color.gpx_chart_green));
		dataSet.setLineWidth(1f);
		if (drawFilled) {
			dataSet.setFillAlpha(128);
			dataSet.setFillColor(ContextCompat.getColor(mChart.getContext(), R.color.gpx_chart_green));
			dataSet.setDrawFilled(true);
		} else {
			dataSet.setDrawFilled(false);
		}

		dataSet.setDrawValues(false);
		dataSet.setValueTextSize(9f);
		dataSet.setFormLineWidth(1f);
		dataSet.setFormSize(15.f);

		dataSet.setDrawCircles(false);
		dataSet.setDrawCircleHole(false);

		dataSet.setHighlightEnabled(true);
		dataSet.setDrawVerticalHighlightIndicator(true);
		dataSet.setDrawHorizontalHighlightIndicator(false);
		dataSet.setHighLightColor(light ? mChart.getResources().getColor(R.color.secondary_text_light) : mChart.getResources().getColor(R.color.secondary_text_dark));

		//dataSet.setMode(LineDataSet.Mode.HORIZONTAL_BEZIER);

		/*
		dataSet.setFillFormatter(new IFillFormatter() {
			@Override
			public float getFillLinePosition(ILineDataSet dataSet, LineDataProvider dataProvider) {
				return dataProvider.getYChartMin();
			}
		});
		*/
		if (useRightAxis) {
			dataSet.setAxisDependency(YAxis.AxisDependency.RIGHT);
		}
		return dataSet;
	}

	public enum GPXDataSetType {
		ALTITUDE(R.string.altitude, R.drawable.ic_action_altitude_average),
		SPEED(R.string.map_widget_speed, R.drawable.ic_action_speed),
		SLOPE(R.string.shared_string_slope, R.drawable.ic_action_altitude_ascent);

		private int stringId;
		private int imageId;

		private GPXDataSetType(int stringId, int imageId) {
			this.stringId = stringId;
			this.imageId = imageId;
		}

		public String getName(@NonNull Context ctx) {
			return ctx.getString(stringId);
		}

		public int getStringId() {
			return stringId;
		}

		public int getImageId() {
			return imageId;
		}

		public Drawable getImageDrawable(@NonNull OsmandApplication app) {
			return app.getUIUtilities().getThemedIcon(imageId);
		}

		public static String getName(@NonNull Context ctx, @NonNull GPXDataSetType[] types) {
			List<String> list = new ArrayList<>();
			for (GPXDataSetType type : types) {
				list.add(type.getName(ctx));
			}
			Collections.sort(list);
			StringBuilder sb = new StringBuilder();
			for (String s : list) {
				if (sb.length() > 0) {
					sb.append("/");
				}
				sb.append(s);
			}
			return sb.toString();
		}

		public static Drawable getImageDrawable(@NonNull OsmandApplication app, @NonNull GPXDataSetType[] types) {
			if (types.length > 0) {
				return types[0].getImageDrawable(app);
			} else {
				return null;
			}
		}
	}

	public enum GPXDataSetAxisType {
		DISTANCE(R.string.distance, R.drawable.ic_action_marker_dark),
		TIME(R.string.shared_string_time, R.drawable.ic_action_time);

		private int stringId;
		private int imageId;

		private GPXDataSetAxisType(int stringId, int imageId) {
			this.stringId = stringId;
			this.imageId = imageId;
		}

		public String getName(Context ctx) {
			return ctx.getString(stringId);
		}

		public int getStringId() {
			return stringId;
		}

		public int getImageId() {
			return imageId;
		}

		public Drawable getImageDrawable(OsmandApplication app) {
			return app.getUIUtilities().getThemedIcon(imageId);
		}
	}

	public static class OrderedLineDataSet extends LineDataSet {

		private GPXDataSetType dataSetType;
		private GPXDataSetAxisType dataSetAxisType;

		float priority;
		String units;
		float divX = 1f;
		float divY = 1f;
		float mulY = 1f;

		OrderedLineDataSet(List<Entry> yVals, String label, GPXDataSetType dataSetType, GPXDataSetAxisType dataSetAxisType) {
			super(yVals, label);
			this.dataSetType = dataSetType;
			this.dataSetAxisType = dataSetAxisType;
		}

		public GPXDataSetType getDataSetType() {
			return dataSetType;
		}

		public GPXDataSetAxisType getDataSetAxisType() {
			return dataSetAxisType;
		}

		public float getPriority() {
			return priority;
		}

		public float getDivX() {
			return divX;
		}

		public float getDivY() {
			return divY;
		}

		public float getMulY() {
			return mulY;
		}

		public String getUnits() {
			return units;
		}
	}

	@SuppressLint("ViewConstructor")
	private static class GPXMarkerView extends MarkerView {

		private View textAltView;
		private View textSpdView;
		private View textSlpView;

		public GPXMarkerView(Context context) {
			super(context, R.layout.chart_marker_view);
			textAltView = findViewById(R.id.text_alt_container);
			textSpdView = findViewById(R.id.text_spd_container);
			textSlpView = findViewById(R.id.text_slp_container);
		}

		// callbacks everytime the MarkerView is redrawn, can be used to update the
		// content (user-interface)
		@Override
		public void refreshContent(Entry e, Highlight highlight) {
			ChartData chartData = getChartView().getData();
			if (chartData.getDataSetCount() == 1) {
				OrderedLineDataSet dataSet = (OrderedLineDataSet) chartData.getDataSetByIndex(0);
				String value = Integer.toString((int) e.getY()) + " ";
				String units = dataSet.units;
				switch (dataSet.getDataSetType()) {
					case ALTITUDE:
						((TextView) textAltView.findViewById(R.id.text_alt_value)).setText(value);
						((TextView) textAltView.findViewById(R.id.text_alt_units)).setText(units);
						textAltView.setVisibility(VISIBLE);
						textSpdView.setVisibility(GONE);
						textSlpView.setVisibility(GONE);
						break;
					case SPEED:
						((TextView) textSpdView.findViewById(R.id.text_spd_value)).setTextColor(dataSet.getColor());
						((TextView) textSpdView.findViewById(R.id.text_spd_value)).setText(value);
						((TextView) textSpdView.findViewById(R.id.text_spd_units)).setText(units);
						textAltView.setVisibility(GONE);
						textSpdView.setVisibility(VISIBLE);
						textSlpView.setVisibility(GONE);
						break;
					case SLOPE:
						((TextView) textSlpView.findViewById(R.id.text_slp_value)).setText(value);
						textAltView.setVisibility(GONE);
						textSpdView.setVisibility(GONE);
						textSlpView.setVisibility(VISIBLE);
						break;
				}
				findViewById(R.id.divider).setVisibility(GONE);
			} else if (chartData.getDataSetCount() == 2) {
				OrderedLineDataSet dataSet1 = (OrderedLineDataSet) chartData.getDataSetByIndex(0);
				OrderedLineDataSet dataSet2 = (OrderedLineDataSet) chartData.getDataSetByIndex(1);
				int altSetIndex = -1;
				int spdSetIndex = -1;
				int slpSetIndex = -1;
				switch (dataSet1.getDataSetType()) {
					case ALTITUDE:
						altSetIndex = 0;
						break;
					case SPEED:
						spdSetIndex = 0;
						break;
					case SLOPE:
						slpSetIndex = 0;
						break;
				}
				switch (dataSet2.getDataSetType()) {
					case ALTITUDE:
						altSetIndex = 1;
						break;
					case SPEED:
						spdSetIndex = 1;
						break;
					case SLOPE:
						slpSetIndex = 1;
						break;
				}
				if (altSetIndex != -1) {
					float y = getInterpolatedY(altSetIndex == 0 ? dataSet1 : dataSet2, e);
					((TextView) textAltView.findViewById(R.id.text_alt_value)).setText(Integer.toString((int) y) + " ");
					((TextView) textAltView.findViewById(R.id.text_alt_units)).setText((altSetIndex == 0 ? dataSet1.units : dataSet2.units));
					textAltView.setVisibility(VISIBLE);
				} else {
					textAltView.setVisibility(GONE);
				}
				if (spdSetIndex != -1) {
					float y = getInterpolatedY(spdSetIndex == 0 ? dataSet1 : dataSet2, e);
					((TextView) textSpdView.findViewById(R.id.text_spd_value)).setTextColor((spdSetIndex == 0 ? dataSet1 : dataSet2).getColor());
					((TextView) textSpdView.findViewById(R.id.text_spd_value)).setText(Integer.toString((int) y) + " ");
					((TextView) textSpdView.findViewById(R.id.text_spd_units)).setText(spdSetIndex == 0 ? dataSet1.units : dataSet2.units);
					textSpdView.setVisibility(VISIBLE);
				} else {
					textSpdView.setVisibility(GONE);
				}
				if (slpSetIndex != -1) {
					float y = getInterpolatedY(slpSetIndex == 0 ? dataSet1 : dataSet2, e);
					((TextView) textSlpView.findViewById(R.id.text_slp_value)).setText(Integer.toString((int) y) + " ");
					textSlpView.setVisibility(VISIBLE);
				} else {
					textSlpView.setVisibility(GONE);
				}
				findViewById(R.id.divider).setVisibility(VISIBLE);
			} else {
				textAltView.setVisibility(GONE);
				textSpdView.setVisibility(GONE);
				textSlpView.setVisibility(GONE);
				findViewById(R.id.divider).setVisibility(GONE);
			}
			super.refreshContent(e, highlight);
		}

		private float getInterpolatedY(OrderedLineDataSet ds, Entry e) {
			if (ds.getEntryIndex(e) == -1) {
				Entry upEntry = ds.getEntryForXValue(e.getX(), Float.NaN, DataSet.Rounding.UP);
				Entry downEntry = upEntry;
				int upIndex = ds.getEntryIndex(upEntry);
				if (upIndex > 0) {
					downEntry = ds.getEntryForIndex(upIndex - 1);
				}
				return MapUtils.getInterpolatedY(downEntry.getX(), downEntry.getY(), upEntry.getX(), upEntry.getY(), e.getX());
			} else {
				return e.getY();
			}
		}

		@Override
		public MPPointF getOffset() {
			if (getChartView().getData().getDataSetCount() == 2) {
				int x = findViewById(R.id.divider).getLeft();
				return new MPPointF(-x - AndroidUtils.dpToPx(getContext(), .5f), 0);
			} else {
				return new MPPointF(-getWidth() / 2f, 0);
			}
		}

		@Override
		public MPPointF getOffsetForDrawingAtPoint(float posX, float posY) {
			int margin = AndroidUtils.dpToPx(getContext(), 3f);
			MPPointF offset = getOffset();
			offset.y = -posY;
			if (posX + offset.x - margin < 0) {
				offset.x -= (offset.x + posX - margin);
			}
			if (posX + offset.x + getWidth() + margin > getChartView().getWidth()) {
				offset.x -= (getWidth() - (getChartView().getWidth() - posX) + offset.x) + margin;
			}
			return offset;
		}
	}


	public static GPXFile makeGpxFromRoute(RouteCalculationResult route, OsmandApplication app) {
		double lastHeight = HEIGHT_UNDEFINED;
		GPXFile gpx = new GPXUtilities.GPXFile(Version.getFullVersion(app));
		List<Location> locations = route.getRouteLocations();
		if (locations != null) {
			GPXUtilities.Track track = new GPXUtilities.Track();
			GPXUtilities.TrkSegment seg = new GPXUtilities.TrkSegment();
			for (Location l : locations) {
				GPXUtilities.WptPt point = new GPXUtilities.WptPt();
				point.lat = l.getLatitude();
				point.lon = l.getLongitude();
				if (l.hasAltitude()) {
					gpx.hasAltitude = true;
					float h = (float) l.getAltitude();
					point.ele = h;
					if (lastHeight == HEIGHT_UNDEFINED && seg.points.size() > 0) {
						for (GPXUtilities.WptPt pt : seg.points) {
							if (Double.isNaN(pt.ele)) {
								pt.ele = h;
							}
						}
					}
					lastHeight = h;
				}
				seg.points.add(point);
			}
			track.segments.add(seg);
			gpx.tracks.add(track);
		}
		return gpx;
	}



	public static class GPXInfo {
		private String fileName;
		private long lastModified;
		private long fileSize;
		private boolean selected;

		public GPXInfo(String fileName, long lastModified, long fileSize) {
			this.fileName = fileName;
			this.lastModified = lastModified;
			this.fileSize = fileSize;
		}

		public String getFileName() {
			return fileName;
		}

		public long getLastModified() {
			return lastModified;
		}

		public long getFileSize() {
			return fileSize;
		}

		public boolean isSelected() {
			return selected;
		}

		public void setSelected(boolean selected) {
			this.selected = selected;
		}
	}
}
!@#$%
20190530_080324,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_b10456
package net.osmand.plus.views;

import android.animation.Animator;
import android.animation.AnimatorListenerAdapter;
import android.animation.AnimatorSet;
import android.animation.ObjectAnimator;
import android.content.Context;
import android.graphics.Canvas;
import android.graphics.PointF;
import android.os.Build;
import android.os.Vibrator;
import android.support.annotation.DimenRes;
import android.support.v4.app.Fragment;
import android.support.v4.content.ContextCompat;
import android.support.v4.util.Pair;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewAnimationUtils;
import android.widget.FrameLayout;
import android.widget.ImageButton;
import android.widget.ImageView;

import com.getkeepsafe.taptargetview.TapTarget;
import com.getkeepsafe.taptargetview.TapTargetView;

import net.osmand.AndroidUtils;
import net.osmand.data.LatLon;
import net.osmand.data.RotatedTileBox;
import net.osmand.plus.OsmAndLocationProvider;
import net.osmand.plus.OsmandApplication;
import net.osmand.plus.OsmandSettings;
import net.osmand.plus.R;
import net.osmand.plus.activities.MapActivity;
import net.osmand.plus.helpers.AndroidUiHelper;
import net.osmand.plus.mapcontextmenu.MapContextMenu;
import net.osmand.plus.mapcontextmenu.MapContextMenuFragment;
import net.osmand.plus.mapcontextmenu.other.MapMultiSelectionMenu;
import net.osmand.plus.measurementtool.MeasurementToolLayer;
import net.osmand.plus.quickaction.QuickAction;
import net.osmand.plus.quickaction.QuickActionFactory;
import net.osmand.plus.quickaction.QuickActionRegistry;
import net.osmand.plus.quickaction.QuickActionsWidget;

import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.List;
import net.osmand.plus.quickaction.actions.DayNightModeAction;

import static net.osmand.plus.views.ContextMenuLayer.VIBRATE_SHORT;

/**
 * Created by okorsun on 23.12.16.
 */

public class MapQuickActionLayer extends OsmandMapLayer implements QuickActionRegistry.QuickActionUpdatesListener, QuickAction.QuickActionSelectionListener {

    private final ContextMenuLayer contextMenuLayer;
    private final MeasurementToolLayer measurementToolLayer;
    private final MapMarkersLayer mapMarkersLayer;
    private ImageView contextMarker;
    private final MapActivity mapActivity;
    private final OsmandApplication app;
    private final OsmandSettings settings;
    private final QuickActionRegistry quickActionRegistry;

    private ImageButton quickActionButton;
    private QuickActionsWidget quickActionsWidget;

    private OsmandMapTileView view;
    private boolean wasCollapseButtonVisible;
    private int previousMapPosition;

    private boolean inMovingMarkerMode;
    private boolean isLayerOn;

    private boolean nightMode;
    private boolean prevWidgetState;

    public MapQuickActionLayer(MapActivity activity, ContextMenuLayer contextMenuLayer) {
        this.mapActivity = activity;
        this.contextMenuLayer = contextMenuLayer;
        app = activity.getMyApplication();
        settings = activity.getMyApplication().getSettings();
        quickActionRegistry = activity.getMapLayers().getQuickActionRegistry();
		measurementToolLayer = mapActivity.getMapLayers().getMeasurementToolLayer();
        mapMarkersLayer = mapActivity.getMapLayers().getMapMarkersLayer();
    }


    @Override
    public void initLayer(OsmandMapTileView view) {
        this.view = view;

        quickActionsWidget = (QuickActionsWidget) mapActivity.findViewById(R.id.quick_action_widget);
        quickActionButton = (ImageButton) mapActivity.findViewById(R.id.map_quick_actions_button);
        setQuickActionButtonMargin();
        isLayerOn = quickActionRegistry.isQuickActionOn();
		nightMode = app.getDaynightHelper().isNightModeForMapControls();
		updateQuickActionButton(false);
        quickActionButton.setContentDescription(mapActivity.getString(R.string.configure_screen_quick_action));
        quickActionButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
				mapActivity.dismissCardDialog();
                if (!showTutorialIfNeeded()) {
                    setLayerState(!isWidgetVisible());
                }
            }
        });

        Context context = view.getContext();
        contextMarker = new ImageView(context);
        contextMarker.setLayoutParams(new FrameLayout.LayoutParams(FrameLayout.LayoutParams.WRAP_CONTENT, FrameLayout.LayoutParams.WRAP_CONTENT));
        contextMarker.setImageDrawable(ContextCompat.getDrawable(context, R.drawable.map_pin_context_menu));
        contextMarker.setClickable(true);
        int minw = contextMarker.getDrawable().getMinimumWidth();
        int minh = contextMarker.getDrawable().getMinimumHeight();
        contextMarker.layout(0, 0, minw, minh);


        quickActionButton.setOnLongClickListener(new View.OnLongClickListener() {
            @Override
            public boolean onLongClick(View v) {
                Vibrator vibrator = (Vibrator) mapActivity.getSystemService(Context.VIBRATOR_SERVICE);
                vibrator.vibrate(VIBRATE_SHORT);
                quickActionButton.setScaleX(1.5f);
                quickActionButton.setScaleY(1.5f);
                quickActionButton.setAlpha(0.95f);
                quickActionButton.setOnTouchListener(onQuickActionTouchListener);
                return true;
            }
        });

    }

    public void refreshLayer() {
        setLayerState(false);
        isLayerOn = quickActionRegistry.isQuickActionOn();
        setupQuickActionBtnVisibility();
    }

    private boolean showTutorialIfNeeded() {
        if (isLayerOn && !app.accessibilityEnabled() && !settings.IS_QUICK_ACTION_TUTORIAL_SHOWN.get() && android.os.Build.VERSION.SDK_INT >= 14) {
            TapTargetView.showFor(mapActivity,                 // `this` is an Activity
                    TapTarget.forView(quickActionButton, mapActivity.getString(R.string.quick_action_btn_tutorial_title), mapActivity.getString(R.string.quick_action_btn_tutorial_descr))
                            // All options below are optional
                            .outerCircleColor(R.color.osmand_orange)      // Specify a color for the outer circle
                            .targetCircleColor(R.color.color_white)   // Specify a color for the target circle
                            .titleTextSize(20)                  // Specify the size (in sp) of the title text
                            .descriptionTextSize(16)            // Specify the size (in sp) of the description text
                            .descriptionTextColor(R.color.color_white)            // Specify a color for both the title and description text
                            .titleTextColor(R.color.color_white)            // Specify a color for both the title and description text
                            .drawShadow(true)                   // Whether to draw a drop shadow or not
                            .cancelable(false)                  // Whether tapping outside the outer circle dismisses the view
                            .tintTarget(false)                   // Whether to tint the target view's color
                            .transparentTarget(false)           // Specify whether the target is transparent (displays the content underneath)
                            .targetRadius(50),                  // Specify the target radius (in dp)
                    new TapTargetView.Listener() {          // The listener can listen for regular clicks, long clicks or cancels
                        @Override
                        public void onTargetClick(TapTargetView view) {
                            super.onTargetClick(view);      // This call is optional
                            settings.IS_QUICK_ACTION_TUTORIAL_SHOWN.set(true);
                        }
                    });
            return true;
        } else
            return false;
    }

    private void setQuickActionButtonMargin() {
        FrameLayout.LayoutParams param = (FrameLayout.LayoutParams) quickActionButton.getLayoutParams();
        if (AndroidUiHelper.isOrientationPortrait(mapActivity)) {
            Pair<Integer, Integer> fabMargin = settings.getPortraitFabMargin();
            if (fabMargin != null) {
                param.rightMargin = fabMargin.first;
                param.bottomMargin = fabMargin.second;
            } else {
                param.bottomMargin = calculateTotalSizePx(R.dimen.map_button_size, R.dimen.map_button_spacing) * 2;
            }
        } else {
            Pair<Integer, Integer> fabMargin = settings.getLandscapeFabMargin();
            if (fabMargin != null) {
                param.rightMargin = fabMargin.first;
                param.bottomMargin = fabMargin.second;
            } else {
                param.rightMargin = calculateTotalSizePx(R.dimen.map_button_size, R.dimen.map_button_spacing_land) * 2;
            }
        }
        quickActionButton.setLayoutParams(param);
    }

    private int calculateTotalSizePx(@DimenRes int... dimensId) {
        int result = 0;
        for (int id : dimensId) {
            result += mapActivity.getResources().getDimensionPixelSize(id);
        }
        return result;
    }

	public boolean isWidgetVisible() {
		return quickActionsWidget.getVisibility() == View.VISIBLE;
	}

	/**
	 * @param showWidget
	 * @return true, if state was changed
	 */
	public boolean setLayerState(boolean showWidget) {
		prevWidgetState = showWidget;
		if (isWidgetVisible() == showWidget)    // check if state change is needed
		    return false;

		updateQuickActionButton(showWidget);
		if (settings.DO_NOT_USE_ANIMATIONS.get()) {
		    quickActionsWidget.setVisibility(!showWidget ? View.GONE : View.VISIBLE);
		} else {
		    animateWidget(showWidget);
		}
		mapActivity.updateStatusBarColor();

		if (!showWidget) {
		    quitMovingMarker();
		    quickActionRegistry.setUpdatesListener(null);
		    quickActionsWidget.setSelectionListener(null);
		} else {
		    enterMovingMode(mapActivity.getMapView().getCurrentRotatedTileBox());
		    quickActionsWidget.setActions(quickActionRegistry.getFilteredQuickActions());
		    quickActionRegistry.setUpdatesListener(MapQuickActionLayer.this);
		    quickActionsWidget.setSelectionListener(MapQuickActionLayer.this);
		}

		return true;
	}

    private void animateWidget(final boolean show) {
        AnimatorSet set = new AnimatorSet();
        List<Animator> animators = new ArrayList<>();
        int[] animationCoordinates = AndroidUtils.getCenterViewCoordinates(quickActionButton);
        int centerX = quickActionsWidget.getWidth() / 2;
        int centerY = quickActionsWidget.getHeight() / 2;
        float initialValueX = show ? animationCoordinates[0] - centerX : 0;
        float finalValueX = show ? 0 : animationCoordinates[0] - centerX;
        float initialValueY = show ? animationCoordinates[1] - centerY : 0;
        float finalValueY = show ? 0 : animationCoordinates[1] - centerY;
        animators.add(ObjectAnimator.ofFloat(quickActionsWidget, View.TRANSLATION_X, initialValueX, finalValueX));
        animators.add(ObjectAnimator.ofFloat(quickActionsWidget, View.TRANSLATION_Y, initialValueY, finalValueY));
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
            float initialRadius = show ? 0 : (float) Math.sqrt(Math.pow(quickActionsWidget.getWidth() / 2, 2) + Math.pow(quickActionsWidget.getHeight() / 2, 2));
            float finalRadius = show ? (float) Math.sqrt(Math.pow(quickActionsWidget.getWidth() / 2, 2) + Math.pow(quickActionsWidget.getHeight() / 2, 2)) : 0;
            Animator circleAnimator = ViewAnimationUtils.createCircularReveal(quickActionsWidget, centerX, centerY, initialRadius, finalRadius);
            animators.add(circleAnimator);
        }
        float initialValueScale = show ? 0f : 1f;
        float finalValueScale = show ? 1f : 0f;
        animators.add(ObjectAnimator.ofFloat(quickActionsWidget, View.SCALE_X, initialValueScale, finalValueScale));
        animators.add(ObjectAnimator.ofFloat(quickActionsWidget, View.SCALE_Y, initialValueScale, finalValueScale));
        set.setDuration(300).playTogether(animators);
        set.addListener(new AnimatorListenerAdapter() {
            @Override
            public void onAnimationStart(Animator animation) {
                super.onAnimationStart(animation);
                if (show) {
                    quickActionsWidget.setVisibility(View.VISIBLE);
                }
            }

            @Override
            public void onAnimationEnd(Animator animation) {
                super.onAnimationEnd(animation);
                if (!show) {
                    quickActionsWidget.setVisibility(View.GONE);
                    quickActionsWidget.setTranslationX(0);
                    quickActionsWidget.setTranslationY(0);
                }
            }
        });
        set.start();
    }

	private void updateQuickActionButton(boolean widgetVisible) {
		quickActionButton.setImageDrawable(app.getUIUtilities().getIcon(
				!widgetVisible ? R.drawable.map_quick_action : R.drawable.map_action_cancel, !nightMode));
		quickActionButton.setBackgroundResource(
				nightMode ? R.drawable.btn_circle_night : R.drawable.btn_circle_trans);
		quickActionButton.setContentDescription(mapActivity.getString(!widgetVisible ? R.string.configure_screen_quick_action : R.string.shared_string_cancel));
	}

    private void enterMovingMode(RotatedTileBox tileBox) {
        previousMapPosition = view.getMapPosition();
        view.setMapPosition(OsmandSettings.MIDDLE_BOTTOM_CONSTANT);
        MapContextMenu menu = mapActivity.getContextMenu();

        LatLon ll = menu.isActive() && tileBox.containsLatLon(menu.getLatLon()) ? menu.getLatLon() : tileBox.getCenterLatLon();
        boolean isFollowPoint = isFolowPoint(tileBox, menu);

        menu.updateMapCenter(null);
        menu.close();

        RotatedTileBox rb = new RotatedTileBox(tileBox);
        if (!isFollowPoint && previousMapPosition != OsmandSettings.BOTTOM_CONSTANT)
            rb.setCenterLocation(0.5f, 0.3f);

        rb.setLatLonCenter(ll.getLatitude(), ll.getLongitude());
        double lat = rb.getLatFromPixel(tileBox.getCenterPixelX(), tileBox.getCenterPixelY());
        double lon = rb.getLonFromPixel(tileBox.getCenterPixelX(), tileBox.getCenterPixelY());
        view.setLatLon(lat, lon);

        inMovingMarkerMode = true;
        mark(View.INVISIBLE, R.id.map_ruler_layout,
                R.id.map_left_widgets_panel, R.id.map_right_widgets_panel, R.id.map_center_info);

        View collapseButton = mapActivity.findViewById(R.id.map_collapse_button);
        if (collapseButton != null && collapseButton.getVisibility() == View.VISIBLE) {
            wasCollapseButtonVisible = true;
            collapseButton.setVisibility(View.INVISIBLE);
        } else {
            wasCollapseButtonVisible = false;
        }

        view.refreshMap();
    }

    private boolean isFolowPoint(RotatedTileBox tileBox, MapContextMenu menu) {
        return OsmAndLocationProvider.isLocationPermissionAvailable(mapActivity) &&
                mapActivity.getMapViewTrackingUtilities().isMapLinkedToLocation() ||
                menu.isActive() && tileBox.containsLatLon(menu.getLatLon());  // remove if not to folow if there is selected point on map
    }

    private void quitMovingMarker() {

        RotatedTileBox tileBox = mapActivity.getMapView().getCurrentRotatedTileBox();
        if (!isFolowPoint(tileBox, mapActivity.getContextMenu()) && previousMapPosition != OsmandSettings.BOTTOM_CONSTANT){
            RotatedTileBox rb = tileBox.copy();
            rb.setCenterLocation(0.5f, 0.5f);
            LatLon ll = tileBox.getCenterLatLon();
            rb.setLatLonCenter(ll.getLatitude(), ll.getLongitude());
            double lat = tileBox.getLatFromPixel(rb.getCenterPixelX(), rb.getCenterPixelY());
            double lon = tileBox.getLonFromPixel(rb.getCenterPixelX(), rb.getCenterPixelY());
            view.setLatLon(lat, lon);
        }
        view.setMapPosition(previousMapPosition);

        inMovingMarkerMode = false;
        mark(View.VISIBLE, R.id.map_ruler_layout,
                R.id.map_left_widgets_panel, R.id.map_right_widgets_panel, R.id.map_center_info);

        View collapseButton = mapActivity.findViewById(R.id.map_collapse_button);
        if (collapseButton != null && wasCollapseButtonVisible) {
            collapseButton.setVisibility(View.VISIBLE);
        }
        view.refreshMap();
    }

    private void mark(int status, int... widgets) {
        for (int widget : widgets) {
            View v = mapActivity.findViewById(widget);
            if (v != null) {
                v.setVisibility(status);
            }
        }
    }

    @Override
    public boolean onSingleTap(PointF point, RotatedTileBox tileBox) {
        if (isInMovingMarkerMode() && !pressedQuickActionWidget(point.x, point.y)) {
            setLayerState(false);
            return true;
        } else
            return false;
    }

    private boolean pressedQuickActionWidget(float px, float py) {
        return py <= quickActionsWidget.getHeight();
    }

    @Override
    public void onDraw(Canvas canvas, RotatedTileBox box, DrawSettings settings) {
		boolean nightMode = app.getDaynightHelper().isNightModeForMapControls();
		if (isInMovingMarkerMode()) {
			canvas.translate(box.getCenterPixelX() - contextMarker.getWidth() / 2, box.getCenterPixelY() - contextMarker.getHeight());
			contextMarker.draw(canvas);
		}
		if (this.nightMode != nightMode) {
			this.nightMode = nightMode;
			updateQuickActionButton(prevWidgetState);
		}
		setupQuickActionBtnVisibility();
    }

    private void setupQuickActionBtnVisibility() {
        MapContextMenu contextMenu = mapActivity.getContextMenu();
        MapMultiSelectionMenu multiSelectionMenu = contextMenu.getMultiSelectionMenu();
        WeakReference<MapContextMenuFragment> contextMenuMenuFragmentRef = contextMenu.findMenuFragment();
        MapContextMenuFragment contextMenuMenuFragment = contextMenuMenuFragmentRef != null ? contextMenuMenuFragmentRef.get() : null;
        Fragment multiMenuFragment = multiSelectionMenu.getFragmentByTag();
        boolean hideQuickButton = !isLayerOn ||
                contextMenuLayer.isInChangeMarkerPositionMode() ||
				contextMenuLayer.isInGpxDetailsMode() ||
				measurementToolLayer.isInMeasurementMode() ||
                mapMarkersLayer.isInPlanRouteMode() ||
                contextMenu.isVisible() && contextMenuMenuFragment != null && !contextMenuMenuFragment.isRemoving() ||
                contextMenu.isVisible() && contextMenuMenuFragment != null && contextMenuMenuFragment.isAdded() ||
                multiSelectionMenu.isVisible() && multiMenuFragment != null && multiMenuFragment.isAdded() ||
                multiSelectionMenu.isVisible() && multiMenuFragment != null && !multiMenuFragment.isRemoving();
        quickActionButton.setVisibility(hideQuickButton ? View.GONE : View.VISIBLE);
    }

    @Override
    public void destroyLayer() {

    }

    @Override
    public boolean drawInScreenPixels() {
        return true;
    }


    @Override
    public void onActionsUpdated() {
        quickActionsWidget.setActions(quickActionRegistry.getFilteredQuickActions());
    }

    @Override
    public void onActionSelected(QuickAction action) {
        QuickActionFactory.produceAction(action).execute(mapActivity);
        setLayerState(false);
    }

    public PointF getMovableCenterPoint(RotatedTileBox tb) {
        return new PointF(tb.getPixWidth() / 2, tb.getPixHeight() / 2);
    }

    public boolean isInMovingMarkerMode() {
        return isLayerOn && inMovingMarkerMode;
    }

    public boolean isLayerOn() {
        return isLayerOn;
    }

    public boolean onBackPressed() {
        return setLayerState(false);
    }

    View.OnTouchListener onQuickActionTouchListener = new View.OnTouchListener() {
        private int initialMarginX;
        private int initialMarginY;
        private float initialTouchX;
        private float initialTouchY;

        @Override
        public boolean onTouch(View v, MotionEvent event) {
            switch (event.getAction()) {
                case MotionEvent.ACTION_DOWN:
                    setUpInitialValues(v, event);
                    return true;
                case MotionEvent.ACTION_UP:
                    quickActionButton.setOnTouchListener(null);
                    quickActionButton.setPressed(false);
                    quickActionButton.setScaleX(1);
                    quickActionButton.setScaleY(1);
                    quickActionButton.setAlpha(1f);
                    FrameLayout.LayoutParams params = (FrameLayout.LayoutParams) v.getLayoutParams();
                    if (AndroidUiHelper.isOrientationPortrait(mapActivity))
                        settings.setPortraitFabMargin(params.rightMargin, params.bottomMargin);
                    else
                        settings.setLandscapeFabMargin(params.rightMargin, params.bottomMargin);
                    return true;
                case MotionEvent.ACTION_MOVE:
                    if (initialMarginX == 0 && initialMarginY == 0 && initialTouchX == 0 && initialTouchY == 0)
                        setUpInitialValues(v, event);

                    int padding = calculateTotalSizePx(R.dimen.map_button_margin);
                    FrameLayout parent = (FrameLayout) v.getParent();
                    FrameLayout.LayoutParams param = (FrameLayout.LayoutParams) v.getLayoutParams();

                    int deltaX = (int) (initialTouchX - event.getRawX());
                    int deltaY = (int) (initialTouchY - event.getRawY());

                    int newMarginX = interpolate(initialMarginX + deltaX, v.getWidth(), parent.getWidth() - padding * 2);
                    int newMarginY = interpolate(initialMarginY + deltaY, v.getHeight(), parent.getHeight() - padding * 2);

                    if (v.getHeight() + newMarginY <= parent.getHeight() - padding * 2 && newMarginY > 0)
                        param.bottomMargin = newMarginY;

                    if (v.getWidth() + newMarginX <= parent.getWidth() - padding * 2 && newMarginX > 0) {
                        param.rightMargin = newMarginX;
                    }

                    v.setLayoutParams(param);

                    return true;
            }
            return false;
        }

        private int interpolate(int value, int divider, int boundsSize) {
            int viewSize = divider;
            if (value <= divider && value > 0)
                return value * value / divider;
            else {
                int leftMargin = boundsSize - value - viewSize;
                if (leftMargin <= divider && value < boundsSize - viewSize)
                    return leftMargin - (leftMargin * leftMargin / divider) + value;
                else
                    return value;
            }
        }

        private void setUpInitialValues(View v, MotionEvent event) {
            FrameLayout.LayoutParams params = (FrameLayout.LayoutParams) v.getLayoutParams();

            initialMarginX = params.rightMargin;
            initialMarginY = params.bottomMargin;

            initialTouchX = event.getRawX();
            initialTouchY = event.getRawY();
        }
    };
}
!@#$%
20190530_080324,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_a10456
package net.osmand.plus.views;

import android.animation.Animator;
import android.animation.AnimatorListenerAdapter;
import android.animation.AnimatorSet;
import android.animation.ObjectAnimator;
import android.content.Context;
import android.graphics.Canvas;
import android.graphics.PointF;
import android.os.Build;
import android.os.Vibrator;
import android.support.annotation.DimenRes;
import android.support.v4.app.Fragment;
import android.support.v4.content.ContextCompat;
import android.support.v4.util.Pair;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewAnimationUtils;
import android.widget.FrameLayout;
import android.widget.ImageButton;
import android.widget.ImageView;

import com.getkeepsafe.taptargetview.TapTarget;
import com.getkeepsafe.taptargetview.TapTargetView;

import net.osmand.AndroidUtils;
import net.osmand.data.LatLon;
import net.osmand.data.RotatedTileBox;
import net.osmand.plus.OsmAndLocationProvider;
import net.osmand.plus.OsmandApplication;
import net.osmand.plus.OsmandSettings;
import net.osmand.plus.R;
import net.osmand.plus.activities.MapActivity;
import net.osmand.plus.helpers.AndroidUiHelper;
import net.osmand.plus.mapcontextmenu.MapContextMenu;
import net.osmand.plus.mapcontextmenu.MapContextMenuFragment;
import net.osmand.plus.mapcontextmenu.other.MapMultiSelectionMenu;
import net.osmand.plus.measurementtool.MeasurementToolLayer;
import net.osmand.plus.quickaction.QuickAction;
import net.osmand.plus.quickaction.QuickActionFactory;
import net.osmand.plus.quickaction.QuickActionRegistry;
import net.osmand.plus.quickaction.QuickActionsWidget;

import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.List;
import net.osmand.plus.quickaction.actions.DayNightModeAction;

import static net.osmand.plus.views.ContextMenuLayer.VIBRATE_SHORT;

/**
 * Created by okorsun on 23.12.16.
 */

public class MapQuickActionLayer extends OsmandMapLayer implements QuickActionRegistry.QuickActionUpdatesListener, QuickAction.QuickActionSelectionListener {

    private final ContextMenuLayer contextMenuLayer;
    private final MeasurementToolLayer measurementToolLayer;
    private final MapMarkersLayer mapMarkersLayer;
    private ImageView contextMarker;
    private final MapActivity mapActivity;
    private final OsmandApplication app;
    private final OsmandSettings settings;
    private final QuickActionRegistry quickActionRegistry;

    private ImageButton quickActionButton;
    private QuickActionsWidget quickActionsWidget;

    private OsmandMapTileView view;
    private boolean wasCollapseButtonVisible;
    private int previousMapPosition;

    private boolean inMovingMarkerMode;
    private boolean isLayerOn;

    private boolean nightMode;
    private boolean prevWidgetState;

    public MapQuickActionLayer(MapActivity activity, ContextMenuLayer contextMenuLayer) {
        this.mapActivity = activity;
        this.contextMenuLayer = contextMenuLayer;
        app = activity.getMyApplication();
        settings = activity.getMyApplication().getSettings();
        quickActionRegistry = activity.getMapLayers().getQuickActionRegistry();
		measurementToolLayer = mapActivity.getMapLayers().getMeasurementToolLayer();
        mapMarkersLayer = mapActivity.getMapLayers().getMapMarkersLayer();
    }


    @Override
    public void initLayer(OsmandMapTileView view) {
        this.view = view;

        quickActionsWidget = (QuickActionsWidget) mapActivity.findViewById(R.id.quick_action_widget);
        quickActionButton = (ImageButton) mapActivity.findViewById(R.id.map_quick_actions_button);
        setQuickActionButtonMargin();
        isLayerOn = quickActionRegistry.isQuickActionOn();
		nightMode = app.getDaynightHelper().isNightModeForMapControls();
		updateQuickActionButton(false);
        quickActionButton.setContentDescription(mapActivity.getString(R.string.configure_screen_quick_action));
        quickActionButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
				mapActivity.dismissCardDialog();
                if (!showTutorialIfNeeded()) {
                    setLayerState(!isWidgetVisible());
                }
            }
        });

        Context context = view.getContext();
        contextMarker = new ImageView(context);
        contextMarker.setLayoutParams(new FrameLayout.LayoutParams(FrameLayout.LayoutParams.WRAP_CONTENT, FrameLayout.LayoutParams.WRAP_CONTENT));
        contextMarker.setImageDrawable(ContextCompat.getDrawable(context, R.drawable.map_pin_context_menu));
        contextMarker.setClickable(true);
        int minw = contextMarker.getDrawable().getMinimumWidth();
        int minh = contextMarker.getDrawable().getMinimumHeight();
        contextMarker.layout(0, 0, minw, minh);


        quickActionButton.setOnLongClickListener(new View.OnLongClickListener() {
            @Override
            public boolean onLongClick(View v) {
                Vibrator vibrator = (Vibrator) mapActivity.getSystemService(Context.VIBRATOR_SERVICE);
                vibrator.vibrate(VIBRATE_SHORT);
                quickActionButton.setScaleX(1.5f);
                quickActionButton.setScaleY(1.5f);
                quickActionButton.setAlpha(0.95f);
                quickActionButton.setOnTouchListener(onQuickActionTouchListener);
                return true;
            }
        });

    }

    public void refreshLayer() {
        setLayerState(false);
        isLayerOn = quickActionRegistry.isQuickActionOn();
        setupQuickActionBtnVisibility();
    }

    private boolean showTutorialIfNeeded() {
        if (isLayerOn && !app.accessibilityEnabled() && !settings.IS_QUICK_ACTION_TUTORIAL_SHOWN.get() && android.os.Build.VERSION.SDK_INT >= 14) {
            TapTargetView.showFor(mapActivity,                 // `this` is an Activity
                    TapTarget.forView(quickActionButton, mapActivity.getString(R.string.quick_action_btn_tutorial_title), mapActivity.getString(R.string.quick_action_btn_tutorial_descr))
                            // All options below are optional
                            .outerCircleColor(R.color.osmand_orange)      // Specify a color for the outer circle
                            .targetCircleColor(R.color.color_white)   // Specify a color for the target circle
                            .titleTextSize(20)                  // Specify the size (in sp) of the title text
                            .descriptionTextSize(16)            // Specify the size (in sp) of the description text
                            .descriptionTextColor(R.color.color_white)            // Specify a color for both the title and description text
                            .titleTextColor(R.color.color_white)            // Specify a color for both the title and description text
                            .drawShadow(true)                   // Whether to draw a drop shadow or not
                            .cancelable(false)                  // Whether tapping outside the outer circle dismisses the view
                            .tintTarget(false)                   // Whether to tint the target view's color
                            .transparentTarget(false)           // Specify whether the target is transparent (displays the content underneath)
                            .targetRadius(50),                  // Specify the target radius (in dp)
                    new TapTargetView.Listener() {          // The listener can listen for regular clicks, long clicks or cancels
                        @Override
                        public void onTargetClick(TapTargetView view) {
                            super.onTargetClick(view);      // This call is optional
                            settings.IS_QUICK_ACTION_TUTORIAL_SHOWN.set(true);
                        }
                    });
            return true;
        } else
            return false;
    }

    private void setQuickActionButtonMargin() {
        FrameLayout.LayoutParams param = (FrameLayout.LayoutParams) quickActionButton.getLayoutParams();
        if (AndroidUiHelper.isOrientationPortrait(mapActivity)) {
            Pair<Integer, Integer> fabMargin = settings.getPortraitFabMargin();
            if (fabMargin != null) {
                param.rightMargin = fabMargin.first;
                param.bottomMargin = fabMargin.second;
            } else {
                param.bottomMargin = calculateTotalSizePx(R.dimen.map_button_size, R.dimen.map_button_spacing) * 2;
            }
        } else {
            Pair<Integer, Integer> fabMargin = settings.getLandscapeFabMargin();
            if (fabMargin != null) {
                param.rightMargin = fabMargin.first;
                param.bottomMargin = fabMargin.second;
            } else {
                param.rightMargin = calculateTotalSizePx(R.dimen.map_button_size, R.dimen.map_button_spacing_land) * 2;
            }
        }
        quickActionButton.setLayoutParams(param);
    }

    private int calculateTotalSizePx(@DimenRes int... dimensId) {
        int result = 0;
        for (int id : dimensId) {
            result += mapActivity.getResources().getDimensionPixelSize(id);
        }
        return result;
    }

	public boolean isWidgetVisible() {
		return quickActionsWidget.getVisibility() == View.VISIBLE;
	}

    /**
     * @param showWidget
     * @return true, if state was changed
     */
    public boolean setLayerState(boolean showWidget) {
		prevWidgetState = showWidget;
        if (isWidgetVisible() == showWidget)    // check if state change is needed
            return false;

		updateQuickActionButton(showWidget);
		if (settings.DO_NOT_USE_ANIMATIONS.get()) {
            quickActionsWidget.setVisibility(!showWidget ? View.GONE : View.VISIBLE);
        } else {
		    animateWidget(showWidget);
        }
        mapActivity.updateStatusBarColor();

        if (!showWidget) {
            quitMovingMarker();
            quickActionRegistry.setUpdatesListener(null);
            quickActionsWidget.setSelectionListener(null);
        } else {
            enterMovingMode(mapActivity.getMapView().getCurrentRotatedTileBox());
            quickActionsWidget.setActions(quickActionRegistry.getFilteredQuickActions());
            quickActionRegistry.setUpdatesListener(MapQuickActionLayer.this);
            quickActionsWidget.setSelectionListener(MapQuickActionLayer.this);
        }

        return true;
    }

    private void animateWidget(final boolean show) {
        AnimatorSet set = new AnimatorSet();
        List<Animator> animators = new ArrayList<>();
        int[] animationCoordinates = AndroidUtils.getCenterViewCoordinates(quickActionButton);
        int centerX = quickActionsWidget.getWidth() / 2;
        int centerY = quickActionsWidget.getHeight() / 2;
        float initialValueX = show ? animationCoordinates[0] - centerX : 0;
        float finalValueX = show ? 0 : animationCoordinates[0] - centerX;
        float initialValueY = show ? animationCoordinates[1] - centerY : 0;
        float finalValueY = show ? 0 : animationCoordinates[1] - centerY;
        animators.add(ObjectAnimator.ofFloat(quickActionsWidget, View.TRANSLATION_X, initialValueX, finalValueX));
        animators.add(ObjectAnimator.ofFloat(quickActionsWidget, View.TRANSLATION_Y, initialValueY, finalValueY));
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
            float initialRadius = show ? 0 : (float) Math.sqrt(Math.pow(quickActionsWidget.getWidth() / 2, 2) + Math.pow(quickActionsWidget.getHeight() / 2, 2));
            float finalRadius = show ? (float) Math.sqrt(Math.pow(quickActionsWidget.getWidth() / 2, 2) + Math.pow(quickActionsWidget.getHeight() / 2, 2)) : 0;
            Animator circleAnimator = ViewAnimationUtils.createCircularReveal(quickActionsWidget, centerX, centerY, initialRadius, finalRadius);
            animators.add(circleAnimator);
        }
        float initialValueScale = show ? 0f : 1f;
        float finalValueScale = show ? 1f : 0f;
        animators.add(ObjectAnimator.ofFloat(quickActionsWidget, View.SCALE_X, initialValueScale, finalValueScale));
        animators.add(ObjectAnimator.ofFloat(quickActionsWidget, View.SCALE_Y, initialValueScale, finalValueScale));
        set.setDuration(300).playTogether(animators);
        set.addListener(new AnimatorListenerAdapter() {
            @Override
            public void onAnimationStart(Animator animation) {
                super.onAnimationStart(animation);
                if (show) {
                    quickActionsWidget.setVisibility(View.VISIBLE);
                }
            }

            @Override
            public void onAnimationEnd(Animator animation) {
                super.onAnimationEnd(animation);
                if (!show) {
                    quickActionsWidget.setVisibility(View.GONE);
                    quickActionsWidget.setTranslationX(0);
                    quickActionsWidget.setTranslationY(0);
                }
            }
        });
        set.start();
    }

	private void updateQuickActionButton(boolean widgetVisible) {
		quickActionButton.setImageDrawable(app.getUIUtilities().getIcon(
				!widgetVisible ? R.drawable.map_quick_action : R.drawable.map_action_cancel, !nightMode));
		quickActionButton.setBackgroundResource(
				nightMode ? R.drawable.btn_circle_night : R.drawable.btn_circle_trans);
		quickActionButton.setContentDescription(mapActivity.getString(!widgetVisible ? R.string.configure_screen_quick_action : R.string.shared_string_cancel));
	}

    private void enterMovingMode(RotatedTileBox tileBox) {
        previousMapPosition = view.getMapPosition();
        view.setMapPosition(OsmandSettings.MIDDLE_BOTTOM_CONSTANT);
        MapContextMenu menu = mapActivity.getContextMenu();

        LatLon ll = menu.isActive() && tileBox.containsLatLon(menu.getLatLon()) ? menu.getLatLon() : tileBox.getCenterLatLon();
        boolean isFollowPoint = isFolowPoint(tileBox, menu);

        menu.updateMapCenter(null);
        menu.close();

        RotatedTileBox rb = new RotatedTileBox(tileBox);
        if (!isFollowPoint && previousMapPosition != OsmandSettings.BOTTOM_CONSTANT)
            rb.setCenterLocation(0.5f, 0.3f);

        rb.setLatLonCenter(ll.getLatitude(), ll.getLongitude());
        double lat = rb.getLatFromPixel(tileBox.getCenterPixelX(), tileBox.getCenterPixelY());
        double lon = rb.getLonFromPixel(tileBox.getCenterPixelX(), tileBox.getCenterPixelY());
        view.setLatLon(lat, lon);

        inMovingMarkerMode = true;
        mark(View.INVISIBLE, R.id.map_ruler_layout,
                R.id.map_left_widgets_panel, R.id.map_right_widgets_panel, R.id.map_center_info);

        View collapseButton = mapActivity.findViewById(R.id.map_collapse_button);
        if (collapseButton != null && collapseButton.getVisibility() == View.VISIBLE) {
            wasCollapseButtonVisible = true;
            collapseButton.setVisibility(View.INVISIBLE);
        } else {
            wasCollapseButtonVisible = false;
        }

        view.refreshMap();
    }

    private boolean isFolowPoint(RotatedTileBox tileBox, MapContextMenu menu) {
        return OsmAndLocationProvider.isLocationPermissionAvailable(mapActivity) &&
                mapActivity.getMapViewTrackingUtilities().isMapLinkedToLocation() ||
                menu.isActive() && tileBox.containsLatLon(menu.getLatLon());  // remove if not to folow if there is selected point on map
    }

    private void quitMovingMarker() {

        RotatedTileBox tileBox = mapActivity.getMapView().getCurrentRotatedTileBox();
        if (!isFolowPoint(tileBox, mapActivity.getContextMenu()) && previousMapPosition != OsmandSettings.BOTTOM_CONSTANT){
            RotatedTileBox rb = tileBox.copy();
            rb.setCenterLocation(0.5f, 0.5f);
            LatLon ll = tileBox.getCenterLatLon();
            rb.setLatLonCenter(ll.getLatitude(), ll.getLongitude());
            double lat = tileBox.getLatFromPixel(rb.getCenterPixelX(), rb.getCenterPixelY());
            double lon = tileBox.getLonFromPixel(rb.getCenterPixelX(), rb.getCenterPixelY());
            view.setLatLon(lat, lon);
        }
        view.setMapPosition(previousMapPosition);

        inMovingMarkerMode = false;
        mark(View.VISIBLE, R.id.map_ruler_layout,
                R.id.map_left_widgets_panel, R.id.map_right_widgets_panel, R.id.map_center_info);

        View collapseButton = mapActivity.findViewById(R.id.map_collapse_button);
        if (collapseButton != null && wasCollapseButtonVisible) {
            collapseButton.setVisibility(View.VISIBLE);
        }
        view.refreshMap();
    }

    private void mark(int status, int... widgets) {
        for (int widget : widgets) {
            View v = mapActivity.findViewById(widget);
            if (v != null) {
                v.setVisibility(status);
            }
        }
    }

    @Override
    public boolean onSingleTap(PointF point, RotatedTileBox tileBox) {
        if (isInMovingMarkerMode() && !pressedQuickActionWidget(point.x, point.y)) {
            setLayerState(false);
            return true;
        } else
            return false;
    }

    private boolean pressedQuickActionWidget(float px, float py) {
        return py <= quickActionsWidget.getHeight();
    }

    @Override
    public void onDraw(Canvas canvas, RotatedTileBox box, DrawSettings settings) {
		boolean nightMode = app.getDaynightHelper().isNightModeForMapControls();
        if (isInMovingMarkerMode()) {
            canvas.translate(box.getCenterPixelX() - contextMarker.getWidth() / 2, box.getCenterPixelY() - contextMarker.getHeight());
            contextMarker.draw(canvas);
        }
		if (this.nightMode != nightMode) {
			this.nightMode = nightMode;
			updateQuickActionButton(prevWidgetState);
		}
        setupQuickActionBtnVisibility();
    }

    private void setupQuickActionBtnVisibility() {
        MapContextMenu contextMenu = mapActivity.getContextMenu();
        MapMultiSelectionMenu multiSelectionMenu = contextMenu.getMultiSelectionMenu();
        WeakReference<MapContextMenuFragment> contextMenuMenuFragmentRef = contextMenu.findMenuFragment();
        MapContextMenuFragment contextMenuMenuFragment = contextMenuMenuFragmentRef != null ? contextMenuMenuFragmentRef.get() : null;
        Fragment multiMenuFragment = multiSelectionMenu.getFragmentByTag();
        boolean hideQuickButton = !isLayerOn ||
                contextMenuLayer.isInChangeMarkerPositionMode() ||
				contextMenuLayer.isInGpxDetailsMode() ||
				measurementToolLayer.isInMeasurementMode() ||
                mapMarkersLayer.isInPlanRouteMode() ||
                contextMenu.isVisible() && contextMenuMenuFragment != null && !contextMenuMenuFragment.isRemoving() ||
                contextMenu.isVisible() && contextMenuMenuFragment != null && contextMenuMenuFragment.isAdded() ||
                multiSelectionMenu.isVisible() && multiMenuFragment != null && multiMenuFragment.isAdded() ||
                multiSelectionMenu.isVisible() && multiMenuFragment != null && !multiMenuFragment.isRemoving();
        quickActionButton.setVisibility(hideQuickButton ? View.GONE : View.VISIBLE);
    }

    @Override
    public void destroyLayer() {

    }

    @Override
    public boolean drawInScreenPixels() {
        return true;
    }


    @Override
    public void onActionsUpdated() {
        quickActionsWidget.setActions(quickActionRegistry.getFilteredQuickActions());
    }

    @Override
    public void onActionSelected(QuickAction action) {
        QuickActionFactory.produceAction(action).execute(mapActivity);
        setLayerState(false);
    }

    public PointF getMovableCenterPoint(RotatedTileBox tb) {
        return new PointF(tb.getPixWidth() / 2, tb.getPixHeight() / 2);
    }

    public boolean isInMovingMarkerMode() {
        return isLayerOn && inMovingMarkerMode;
    }

    public boolean isLayerOn() {
        return isLayerOn;
    }

    public boolean onBackPressed() {
        return setLayerState(false);
    }

    View.OnTouchListener onQuickActionTouchListener = new View.OnTouchListener() {
        private int initialMarginX;
        private int initialMarginY;
        private float initialTouchX;
        private float initialTouchY;

        @Override
        public boolean onTouch(View v, MotionEvent event) {
            switch (event.getAction()) {
                case MotionEvent.ACTION_DOWN:
                    setUpInitialValues(v, event);
                    return true;
                case MotionEvent.ACTION_UP:
                    quickActionButton.setOnTouchListener(null);
                    quickActionButton.setPressed(false);
                    quickActionButton.setScaleX(1);
                    quickActionButton.setScaleY(1);
                    quickActionButton.setAlpha(1f);
                    FrameLayout.LayoutParams params = (FrameLayout.LayoutParams) v.getLayoutParams();
                    if (AndroidUiHelper.isOrientationPortrait(mapActivity))
                        settings.setPortraitFabMargin(params.rightMargin, params.bottomMargin);
                    else
                        settings.setLandscapeFabMargin(params.rightMargin, params.bottomMargin);
                    return true;
                case MotionEvent.ACTION_MOVE:
                    if (initialMarginX == 0 && initialMarginY == 0 && initialTouchX == 0 && initialTouchY == 0)
                        setUpInitialValues(v, event);

                    int padding = calculateTotalSizePx(R.dimen.map_button_margin);
                    FrameLayout parent = (FrameLayout) v.getParent();
                    FrameLayout.LayoutParams param = (FrameLayout.LayoutParams) v.getLayoutParams();

                    int deltaX = (int) (initialTouchX - event.getRawX());
                    int deltaY = (int) (initialTouchY - event.getRawY());

                    int newMarginX = interpolate(initialMarginX + deltaX, v.getWidth(), parent.getWidth() - padding * 2);
                    int newMarginY = interpolate(initialMarginY + deltaY, v.getHeight(), parent.getHeight() - padding * 2);

                    if (v.getHeight() + newMarginY <= parent.getHeight() - padding * 2 && newMarginY > 0)
                        param.bottomMargin = newMarginY;

                    if (v.getWidth() + newMarginX <= parent.getWidth() - padding * 2 && newMarginX > 0) {
                        param.rightMargin = newMarginX;
                    }

                    v.setLayoutParams(param);

                    return true;
            }
            return false;
        }

        private int interpolate(int value, int divider, int boundsSize) {
            int viewSize = divider;
            if (value <= divider && value > 0)
                return value * value / divider;
            else {
                int leftMargin = boundsSize - value - viewSize;
                if (leftMargin <= divider && value < boundsSize - viewSize)
                    return leftMargin - (leftMargin * leftMargin / divider) + value;
                else
                    return value;
            }
        }

        private void setUpInitialValues(View v, MotionEvent event) {
            FrameLayout.LayoutParams params = (FrameLayout.LayoutParams) v.getLayoutParams();

            initialMarginX = params.rightMargin;
            initialMarginY = params.bottomMargin;

            initialTouchX = event.getRawX();
            initialTouchY = event.getRawY();
        }
    };
}
!@#$%
20190530_080324,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_c10456
package net.osmand.plus.views;

import android.animation.Animator;
import android.animation.AnimatorListenerAdapter;
import android.animation.AnimatorSet;
import android.animation.ObjectAnimator;
import android.content.Context;
import android.graphics.Canvas;
import android.graphics.PointF;
import android.os.Build;
import android.os.Vibrator;
import android.support.annotation.DimenRes;
import android.support.v4.app.Fragment;
import android.support.v4.content.ContextCompat;
import android.support.v4.util.Pair;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewAnimationUtils;
import android.widget.FrameLayout;
import android.widget.ImageButton;
import android.widget.ImageView;

import com.getkeepsafe.taptargetview.TapTarget;
import com.getkeepsafe.taptargetview.TapTargetView;

import net.osmand.AndroidUtils;
import net.osmand.data.LatLon;
import net.osmand.data.RotatedTileBox;
import net.osmand.plus.OsmAndLocationProvider;
import net.osmand.plus.OsmandApplication;
import net.osmand.plus.OsmandSettings;
import net.osmand.plus.R;
import net.osmand.plus.activities.MapActivity;
import net.osmand.plus.helpers.AndroidUiHelper;
import net.osmand.plus.mapcontextmenu.MapContextMenu;
import net.osmand.plus.mapcontextmenu.MapContextMenuFragment;
import net.osmand.plus.mapcontextmenu.other.MapMultiSelectionMenu;
import net.osmand.plus.measurementtool.MeasurementToolLayer;
import net.osmand.plus.quickaction.QuickAction;
import net.osmand.plus.quickaction.QuickActionFactory;
import net.osmand.plus.quickaction.QuickActionRegistry;
import net.osmand.plus.quickaction.QuickActionsWidget;

import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.List;
import net.osmand.plus.quickaction.actions.DayNightModeAction;

import static net.osmand.plus.views.ContextMenuLayer.VIBRATE_SHORT;

/**
 * Created by okorsun on 23.12.16.
 */

public class MapQuickActionLayer extends OsmandMapLayer implements
	QuickActionRegistry.QuickActionUpdatesListener, QuickAction.QuickActionSelectionListener {

	private final ContextMenuLayer contextMenuLayer;
	private final MeasurementToolLayer measurementToolLayer;
	private final MapMarkersLayer mapMarkersLayer;
	private ImageView contextMarker;
	private final MapActivity mapActivity;
	private final OsmandApplication app;
	private final OsmandSettings settings;
	private final QuickActionRegistry quickActionRegistry;

	private ImageButton quickActionButton;
	private QuickActionsWidget quickActionsWidget;

	private OsmandMapTileView view;
	private boolean wasCollapseButtonVisible;
	private int previousMapPosition;

	private boolean inMovingMarkerMode;
	private boolean isLayerOn;

	private boolean nightMode;
	private boolean prevWidgetState;

	public MapQuickActionLayer(MapActivity activity, ContextMenuLayer contextMenuLayer) {
		this.mapActivity = activity;
		this.contextMenuLayer = contextMenuLayer;
		app = activity.getMyApplication();
		settings = activity.getMyApplication().getSettings();
		quickActionRegistry = activity.getMapLayers().getQuickActionRegistry();
		measurementToolLayer = mapActivity.getMapLayers().getMeasurementToolLayer();
		mapMarkersLayer = mapActivity.getMapLayers().getMapMarkersLayer();
	}


	@Override
	public void initLayer(OsmandMapTileView view) {
		this.view = view;

		quickActionsWidget = (QuickActionsWidget) mapActivity.findViewById(R.id.quick_action_widget);
		quickActionButton = (ImageButton) mapActivity.findViewById(R.id.map_quick_actions_button);
		setQuickActionButtonMargin();
		isLayerOn = quickActionRegistry.isQuickActionOn();
		nightMode = app.getDaynightHelper().isNightModeForMapControls();
		updateQuickActionButton(false);
		quickActionButton.setContentDescription(mapActivity.getString(R.string.configure_screen_quick_action));
		quickActionButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				mapActivity.dismissCardDialog();
				if (!showTutorialIfNeeded()) {
					setLayerState(!isWidgetVisible());
				}
			}
		});

		Context context = view.getContext();
		contextMarker = new ImageView(context);
		contextMarker.setLayoutParams(
			new FrameLayout.LayoutParams(FrameLayout.LayoutParams.WRAP_CONTENT,
				FrameLayout.LayoutParams.WRAP_CONTENT));
		contextMarker.setImageDrawable(ContextCompat.getDrawable(context, R.drawable.map_pin_context_menu));
		contextMarker.setClickable(true);
		int minw = contextMarker.getDrawable().getMinimumWidth();
		int minh = contextMarker.getDrawable().getMinimumHeight();
		contextMarker.layout(0, 0, minw, minh);

		quickActionButton.setOnLongClickListener(new View.OnLongClickListener() {
			@Override
			public boolean onLongClick(View v) {
				Vibrator vibrator = (Vibrator) mapActivity.getSystemService(Context.VIBRATOR_SERVICE);
				vibrator.vibrate(VIBRATE_SHORT);
				quickActionButton.setScaleX(1.5f);
				quickActionButton.setScaleY(1.5f);
				quickActionButton.setAlpha(0.95f);
				quickActionButton.setOnTouchListener(onQuickActionTouchListener);
				return true;
			}
		});

	}

	public void refreshLayer() {
		setLayerState(false);
		isLayerOn = quickActionRegistry.isQuickActionOn();
		setupQuickActionBtnVisibility();
	}

	private boolean showTutorialIfNeeded() {
		if (isLayerOn && !app.accessibilityEnabled()
			&& !settings.IS_QUICK_ACTION_TUTORIAL_SHOWN.get() && android.os.Build.VERSION.SDK_INT >= 14) {
			TapTargetView.showFor(mapActivity,                 // `this` is an Activity
				TapTarget.forView(quickActionButton,
					mapActivity.getString(R.string.quick_action_btn_tutorial_title),
					mapActivity.getString(R.string.quick_action_btn_tutorial_descr))
					// All options below are optional
					.outerCircleColor(R.color.osmand_orange)      // Specify a color for the outer circle
					.targetCircleColor(R.color.color_white)   // Specify a color for the target circle
					.titleTextSize(20)                  // Specify the size (in sp) of the title text
					.descriptionTextSize(16)            // Specify the size (in sp) of the description text
					.descriptionTextColor(R.color.color_white)            // Specify a color for both the title and description text
					.titleTextColor(R.color.color_white)            // Specify a color for both the title and description text
					.drawShadow(true)                   // Whether to draw a drop shadow or not
					.cancelable(false)                  // Whether tapping outside the outer circle dismisses the view
					.tintTarget(false)                   // Whether to tint the target view's color
					.transparentTarget(false)           // Specify whether the target is transparent (displays the content underneath)
					.targetRadius(50),                  // Specify the target radius (in dp)
				new TapTargetView.Listener() {          // The listener can listen for regular clicks, long clicks or cancels
					@Override
					public void onTargetClick(TapTargetView view) {
						super.onTargetClick(view);      // This call is optional
						settings.IS_QUICK_ACTION_TUTORIAL_SHOWN.set(true);
					}
				});
			return true;
		} else {
			return false;
		}
	}

	private void setQuickActionButtonMargin() {
		FrameLayout.LayoutParams param = (FrameLayout.LayoutParams) quickActionButton.getLayoutParams();
		if (AndroidUiHelper.isOrientationPortrait(mapActivity)) {
			Pair<Integer, Integer> fabMargin = settings.getPortraitFabMargin();
			if (fabMargin != null) {
				param.rightMargin = fabMargin.first;
				param.bottomMargin = fabMargin.second;
			} else {
				param.bottomMargin = calculateTotalSizePx(R.dimen.map_button_size, R.dimen.map_button_spacing) * 2;
			}
		} else {
			Pair<Integer, Integer> fabMargin = settings.getLandscapeFabMargin();
			if (fabMargin != null) {
				param.rightMargin = fabMargin.first;
				param.bottomMargin = fabMargin.second;
			} else {
				param.rightMargin = calculateTotalSizePx(R.dimen.map_button_size, R.dimen.map_button_spacing_land) * 2;
			}
		}
		quickActionButton.setLayoutParams(param);
	}

	private int calculateTotalSizePx(@DimenRes int... dimensId) {
		int result = 0;
		for (int id : dimensId) {
			result += mapActivity.getResources().getDimensionPixelSize(id);
		}
		return result;
	}

	public boolean isWidgetVisible() {
		return quickActionsWidget.getVisibility() == View.VISIBLE;
	}

	/**
	 * @param showWidget
	 * @return true, if state was changed
	 */
	public boolean setLayerState(boolean showWidget) {
		prevWidgetState = showWidget;
		if (isWidgetVisible() == showWidget) {   // check if state change is needed
			return false;
		}

		updateQuickActionButton(showWidget);
		if (settings.DO_NOT_USE_ANIMATIONS.get()) {
			quickActionsWidget.setVisibility(!showWidget ? View.GONE : View.VISIBLE);
		} else {
			animateWidget(showWidget);
		}
		mapActivity.updateStatusBarColor();

		if (!showWidget) {
			quitMovingMarker();
			quickActionRegistry.setUpdatesListener(null);
			quickActionsWidget.setSelectionListener(null);
		} else {
			enterMovingMode(mapActivity.getMapView().getCurrentRotatedTileBox());
			quickActionsWidget.setActions(quickActionRegistry.getFilteredQuickActions());
			quickActionRegistry.setUpdatesListener(MapQuickActionLayer.this);
			quickActionsWidget.setSelectionListener(MapQuickActionLayer.this);
		}

		return true;
	}

	private void animateWidget(final boolean show) {
		AnimatorSet set = new AnimatorSet();
		List<Animator> animators = new ArrayList<>();
		int[] animationCoordinates = AndroidUtils.getCenterViewCoordinates(quickActionButton);
		int centerX = quickActionsWidget.getWidth() / 2;
		int centerY = quickActionsWidget.getHeight() / 2;
		float initialValueX = show ? animationCoordinates[0] - centerX : 0;
		float finalValueX = show ? 0 : animationCoordinates[0] - centerX;
		float initialValueY = show ? animationCoordinates[1] - centerY : 0;
		float finalValueY = show ? 0 : animationCoordinates[1] - centerY;
		animators.add(ObjectAnimator.ofFloat(quickActionsWidget, View.TRANSLATION_X, initialValueX, finalValueX));
		animators.add(ObjectAnimator.ofFloat(quickActionsWidget, View.TRANSLATION_Y, initialValueY, finalValueY));
		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
			float initialRadius = show ? 0 : (float) Math.sqrt(Math.pow(quickActionsWidget.getWidth() / 2, 2) + Math.pow(quickActionsWidget.getHeight() / 2, 2));
			float finalRadius = show ? (float) Math.sqrt(Math.pow(quickActionsWidget.getWidth() / 2, 2) + Math.pow(quickActionsWidget.getHeight() / 2, 2)) : 0;
			Animator circleAnimator = ViewAnimationUtils.createCircularReveal(quickActionsWidget, centerX, centerY, initialRadius,
					finalRadius);
			animators.add(circleAnimator);
		}
		float initialValueScale = show ? 0f : 1f;
		float finalValueScale = show ? 1f : 0f;
		animators.add(ObjectAnimator.ofFloat(quickActionsWidget, View.SCALE_X, initialValueScale, finalValueScale));
		animators.add(ObjectAnimator.ofFloat(quickActionsWidget, View.SCALE_Y, initialValueScale, finalValueScale));
		set.setDuration(300).playTogether(animators);
		set.addListener(new AnimatorListenerAdapter() {
			@Override
			public void onAnimationStart(Animator animation) {
				super.onAnimationStart(animation);
				if (show) {
					quickActionsWidget.setVisibility(View.VISIBLE);
				}
			}

			@Override
			public void onAnimationEnd(Animator animation) {
				super.onAnimationEnd(animation);
				if (!show) {
					quickActionsWidget.setVisibility(View.GONE);
					quickActionsWidget.setTranslationX(0);
					quickActionsWidget.setTranslationY(0);
				}
			}
		});
		set.start();
	}

	private void updateQuickActionButton(boolean widgetVisible) {
		quickActionButton.setImageDrawable(app.getUIUtilities().getIcon(
			!widgetVisible ? R.drawable.map_quick_action : R.drawable.map_action_cancel, !nightMode));
		quickActionButton.setBackgroundResource(
			nightMode ? R.drawable.btn_circle_night : R.drawable.btn_circle_trans);
		quickActionButton.setContentDescription(mapActivity.getString(!widgetVisible ? R.string.configure_screen_quick_action : R.string.shared_string_cancel));
	}

	private void enterMovingMode(RotatedTileBox tileBox) {
		previousMapPosition = view.getMapPosition();
		view.setMapPosition(OsmandSettings.MIDDLE_BOTTOM_CONSTANT);
		MapContextMenu menu = mapActivity.getContextMenu();

		LatLon ll = menu.isActive() && tileBox.containsLatLon(menu.getLatLon()) ? menu.getLatLon()
			: tileBox.getCenterLatLon();
		boolean isFollowPoint = isFolowPoint(tileBox, menu);

		menu.updateMapCenter(null);
		menu.close();

		RotatedTileBox rb = new RotatedTileBox(tileBox);
		if (!isFollowPoint && previousMapPosition != OsmandSettings.BOTTOM_CONSTANT) {
			rb.setCenterLocation(0.5f, 0.3f);
		}

		rb.setLatLonCenter(ll.getLatitude(), ll.getLongitude());
		double lat = rb.getLatFromPixel(tileBox.getCenterPixelX(), tileBox.getCenterPixelY());
		double lon = rb.getLonFromPixel(tileBox.getCenterPixelX(), tileBox.getCenterPixelY());
		view.setLatLon(lat, lon);

		inMovingMarkerMode = true;
		mark(View.INVISIBLE, R.id.map_ruler_layout,
			R.id.map_left_widgets_panel, R.id.map_right_widgets_panel, R.id.map_center_info);

		View collapseButton = mapActivity.findViewById(R.id.map_collapse_button);
		if (collapseButton != null && collapseButton.getVisibility() == View.VISIBLE) {
			wasCollapseButtonVisible = true;
			collapseButton.setVisibility(View.INVISIBLE);
		} else {
			wasCollapseButtonVisible = false;
		}

		view.refreshMap();
	}

	private boolean isFolowPoint(RotatedTileBox tileBox, MapContextMenu menu) {
		return OsmAndLocationProvider.isLocationPermissionAvailable(mapActivity) &&
			mapActivity.getMapViewTrackingUtilities().isMapLinkedToLocation() ||
			menu.isActive() && tileBox.containsLatLon(
				menu.getLatLon());  // remove if not to folow if there is selected point on map
	}

	private void quitMovingMarker() {

		RotatedTileBox tileBox = mapActivity.getMapView().getCurrentRotatedTileBox();
		if (!isFolowPoint(tileBox, mapActivity.getContextMenu())
			&& previousMapPosition != OsmandSettings.BOTTOM_CONSTANT) {
			RotatedTileBox rb = tileBox.copy();
			rb.setCenterLocation(0.5f, 0.5f);
			LatLon ll = tileBox.getCenterLatLon();
			rb.setLatLonCenter(ll.getLatitude(), ll.getLongitude());
			double lat = tileBox.getLatFromPixel(rb.getCenterPixelX(), rb.getCenterPixelY());
			double lon = tileBox.getLonFromPixel(rb.getCenterPixelX(), rb.getCenterPixelY());
			view.setLatLon(lat, lon);
		}
		view.setMapPosition(previousMapPosition);

		inMovingMarkerMode = false;
		mark(View.VISIBLE, R.id.map_ruler_layout,
			R.id.map_left_widgets_panel, R.id.map_right_widgets_panel, R.id.map_center_info);

		View collapseButton = mapActivity.findViewById(R.id.map_collapse_button);
		if (collapseButton != null && wasCollapseButtonVisible) {
			collapseButton.setVisibility(View.VISIBLE);
		}
		view.refreshMap();
	}

	private void mark(int status, int... widgets) {
		for (int widget : widgets) {
			View v = mapActivity.findViewById(widget);
			if (v != null) {
				v.setVisibility(status);
			}
		}
	}

	@Override
	public boolean onSingleTap(PointF point, RotatedTileBox tileBox) {
		if (isInMovingMarkerMode() && !pressedQuickActionWidget(point.x, point.y)) {
			setLayerState(false);
			return true;
		} else {
			return false;
		}
	}

	private boolean pressedQuickActionWidget(float px, float py) {
		return py <= quickActionsWidget.getHeight();
	}

	@Override
	public void onDraw(Canvas canvas, RotatedTileBox box, DrawSettings settings) {
		boolean nightMode = app.getDaynightHelper().isNightModeForMapControls();
		if (isInMovingMarkerMode()) {
			canvas.translate(box.getCenterPixelX() - contextMarker.getWidth() / 2,
				box.getCenterPixelY() - contextMarker.getHeight());
			contextMarker.draw(canvas);
		}
		if (this.nightMode != nightMode) {
			this.nightMode = nightMode;
			updateQuickActionButton(prevWidgetState);
		}
		setupQuickActionBtnVisibility();
	}

	private void setupQuickActionBtnVisibility() {
		MapContextMenu contextMenu = mapActivity.getContextMenu();
		MapMultiSelectionMenu multiSelectionMenu = contextMenu.getMultiSelectionMenu();
		WeakReference<MapContextMenuFragment> contextMenuMenuFragmentRef = contextMenu
			.findMenuFragment();
		MapContextMenuFragment contextMenuMenuFragment =
			contextMenuMenuFragmentRef != null ? contextMenuMenuFragmentRef.get() : null;
		Fragment multiMenuFragment = multiSelectionMenu.getFragmentByTag();
		boolean hideQuickButton = !isLayerOn ||
			contextMenuLayer.isInChangeMarkerPositionMode() ||
			contextMenuLayer.isInGpxDetailsMode() ||
			measurementToolLayer.isInMeasurementMode() ||
			mapMarkersLayer.isInPlanRouteMode() ||
			contextMenu.isVisible() && contextMenuMenuFragment != null && !contextMenuMenuFragment.isRemoving() ||
			contextMenu.isVisible() && contextMenuMenuFragment != null && contextMenuMenuFragment.isAdded() ||
			multiSelectionMenu.isVisible() && multiMenuFragment != null && multiMenuFragment.isAdded() ||
			multiSelectionMenu.isVisible() && multiMenuFragment != null && !multiMenuFragment.isRemoving();
		quickActionButton.setVisibility(hideQuickButton ? View.GONE : View.VISIBLE);
	}

	@Override
	public void destroyLayer() {

	}

	@Override
	public boolean drawInScreenPixels() {
		return true;
	}


	@Override
	public void onActionsUpdated() {
		quickActionsWidget.setActions(quickActionRegistry.getFilteredQuickActions());
	}

	@Override
	public void onActionSelected(QuickAction action) {
		QuickActionFactory.produceAction(action).execute(mapActivity);
		setLayerState(false);
	}

	public PointF getMovableCenterPoint(RotatedTileBox tb) {
		return new PointF(tb.getPixWidth() / 2, tb.getPixHeight() / 2);
	}

	public boolean isInMovingMarkerMode() {
		return isLayerOn && inMovingMarkerMode;
	}

	public boolean isLayerOn() {
		return isLayerOn;
	}

	public boolean onBackPressed() {
		return setLayerState(false);
	}

	View.OnTouchListener onQuickActionTouchListener = new View.OnTouchListener() {
		private int initialMarginX;
		private int initialMarginY;
		private float initialTouchX;
		private float initialTouchY;

		@Override
		public boolean onTouch(View v, MotionEvent event) {
			switch (event.getAction()) {
				case MotionEvent.ACTION_DOWN:
					setUpInitialValues(v, event);
					return true;
				case MotionEvent.ACTION_UP:
					quickActionButton.setOnTouchListener(null);
					quickActionButton.setPressed(false);
					quickActionButton.setScaleX(1);
					quickActionButton.setScaleY(1);
					quickActionButton.setAlpha(1f);
					FrameLayout.LayoutParams params = (FrameLayout.LayoutParams) v
						.getLayoutParams();
					if (AndroidUiHelper.isOrientationPortrait(mapActivity)) {
						settings.setPortraitFabMargin(params.rightMargin, params.bottomMargin);
					} else {
						settings.setLandscapeFabMargin(params.rightMargin, params.bottomMargin);
					}
					return true;
				case MotionEvent.ACTION_MOVE:
					if (initialMarginX == 0 && initialMarginY == 0 && initialTouchX == 0
						&& initialTouchY == 0) {
						setUpInitialValues(v, event);
					}

					int padding = calculateTotalSizePx(R.dimen.map_button_margin);
					FrameLayout parent = (FrameLayout) v.getParent();
					FrameLayout.LayoutParams param = (FrameLayout.LayoutParams) v.getLayoutParams();

					int deltaX = (int) (initialTouchX - event.getRawX());
					int deltaY = (int) (initialTouchY - event.getRawY());

					int newMarginX = interpolate(initialMarginX + deltaX, v.getWidth(),
						parent.getWidth() - padding * 2);
					int newMarginY = interpolate(initialMarginY + deltaY, v.getHeight(),
						parent.getHeight() - padding * 2);

					if (v.getHeight() + newMarginY <= parent.getHeight() - padding * 2 && newMarginY > 0) {
						param.bottomMargin = newMarginY;
					}

					if (v.getWidth() + newMarginX <= parent.getWidth() - padding * 2 && newMarginX > 0) {
						param.rightMargin = newMarginX;
					}

					v.setLayoutParams(param);

					return true;
			}
			return false;
		}

		private int interpolate(int value, int divider, int boundsSize) {
			int viewSize = divider;
			if (value <= divider && value > 0) {
				return value * value / divider;
			} else {
				int leftMargin = boundsSize - value - viewSize;
				if (leftMargin <= divider && value < boundsSize - viewSize) {
					return leftMargin - (leftMargin * leftMargin / divider) + value;
				} else {
					return value;
				}
			}
		}

		private void setUpInitialValues(View v, MotionEvent event) {
			FrameLayout.LayoutParams params = (FrameLayout.LayoutParams) v.getLayoutParams();

			initialMarginX = params.rightMargin;
			initialMarginY = params.bottomMargin;

			initialTouchX = event.getRawX();
			initialTouchY = event.getRawY();
		}
	};
}
!@#$%
20190530_081431,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_b04544
package net.osmand.plus;

import android.content.Context;

import net.osmand.StateChangedListener;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;


public class ApplicationMode {
	private static Map<String, Set<ApplicationMode>> widgetsVisibilityMap = new LinkedHashMap<>();
	private static Map<String, Set<ApplicationMode>> widgetsAvailabilityMap = new LinkedHashMap<>();
	private static List<ApplicationMode> defaultValues = new ArrayList<>();
	private static List<ApplicationMode> values = new ArrayList<>();
	private static List<ApplicationMode> cachedFilteredValues = new ArrayList<>();
	/*
	 * DEFAULT("Browse map"), CAR("Car"), BICYCLE("Bicycle"), PEDESTRIAN("Pedestrian"); NAUTICAL("boat"); PUBLIC_TRANSPORT("Public transport")
	 */
	public static final ApplicationMode DEFAULT = create(R.string.app_mode_default, "default").speed(1.5f, 5).arrivalDistance(90).defLocation().
			icon(R.drawable.map_world_globe_dark, R.drawable.ic_world_globe_dark).reg();

	public static final ApplicationMode CAR = create(R.string.app_mode_car, "car").speed(15.3f, 35).carLocation().
			icon(R.drawable.map_action_car_dark, R.drawable.ic_action_car_dark).reg();

	public static final ApplicationMode BICYCLE = create(R.string.app_mode_bicycle, "bicycle").speed(5.5f, 15).arrivalDistance(60).offRouteDistance(50).bicycleLocation().
			icon(R.drawable.map_action_bicycle_dark, R.drawable.ic_action_bicycle_dark).reg();

	public static final ApplicationMode PEDESTRIAN = create(R.string.app_mode_pedestrian, "pedestrian").speed(1.5f, 5).arrivalDistance(45).offRouteDistance(20).
			icon(R.drawable.map_action_pedestrian_dark, R.drawable.ic_action_pedestrian_dark).reg();

	public static final ApplicationMode PUBLIC_TRANSPORT = create(R.string.app_mode_public_transport, "public_transport").
			icon(R.drawable.map_action_bus_dark, R.drawable.ic_action_bus_dark).reg();

	public static final ApplicationMode BOAT = create(R.string.app_mode_boat, "boat").speed(5.5f, 20).nauticalLocation().
			icon(R.drawable.map_action_sail_boat_dark, R.drawable.ic_action_sail_boat_dark).reg();

	public static final ApplicationMode AIRCRAFT = create(R.string.app_mode_aircraft, "aircraft").speed(40f, 100).carLocation().
			icon(R.drawable.map_action_aircraft, R.drawable.ic_action_aircraft).reg();
//---------------------------------------------------------------------------------------------------------------
//	public static final ApplicationMode HIKING = create(R.string.app_mode_hiking, "hiking").speed(1.5f, 5).parent(PEDESTRIAN).
//			icon(R.drawable.map_action_trekking_dark, R.drawable.ic_action_trekking_dark).reg();
//
//	public static final ApplicationMode MOTORCYCLE = create(R.string.app_mode_motorcycle, "motorcycle").speed(15.3f, 40).
//			carLocation().parent(CAR).
//			icon(R.drawable.map_action_motorcycle_dark, R.drawable.ic_action_motorcycle_dark).reg();
//
//	public static final ApplicationMode TRUCK = create(R.string.app_mode_truck, "truck").speed(15.3f, 40).
//			carLocation().parent(CAR).
//			icon(R.drawable.map_action_truck_dark, R.drawable.ic_action_truck_dark).reg();
//
//	public static final ApplicationMode TRAIN = create(R.string.app_mode_train, "train").speed(25f, 40).
//			carLocation().icon(R.drawable.map_action_train, R.drawable.ic_action_train).reg();
	String profile = "profile: ";
	static {
		ApplicationMode[] exceptDefault = new ApplicationMode[]{CAR, PEDESTRIAN, BICYCLE, BOAT, PUBLIC_TRANSPORT};
		ApplicationMode[] exceptPedestrianAndDefault = new ApplicationMode[]{CAR, BICYCLE, BOAT, PUBLIC_TRANSPORT};
		ApplicationMode[] exceptAirBoatDefault = new ApplicationMode[]{CAR, BICYCLE, PEDESTRIAN};
		ApplicationMode[] pedestrian = new ApplicationMode[]{PEDESTRIAN};
		ApplicationMode[] pedestrianBicycle = new ApplicationMode[]{PEDESTRIAN, BICYCLE};

		ApplicationMode[] all = null;
		ApplicationMode[] none = new ApplicationMode[]{};

		// left
		regWidgetVisibility("next_turn", exceptPedestrianAndDefault);
		regWidgetVisibility("next_turn_small", pedestrian);
		regWidgetVisibility("next_next_turn", exceptPedestrianAndDefault);
		regWidgetAvailability("next_turn", exceptDefault);
		regWidgetAvailability("next_turn_small", exceptDefault);
		regWidgetAvailability("next_next_turn", exceptDefault);

		// right
		regWidgetVisibility("intermediate_distance", all);
		regWidgetVisibility("distance", all);
		regWidgetVisibility("time", all);
		regWidgetVisibility("intermediate_time", all);
		regWidgetVisibility("speed", exceptPedestrianAndDefault);
		regWidgetVisibility("max_speed", CAR);
		regWidgetVisibility("altitude", pedestrianBicycle);
		regWidgetVisibility("gps_info", none);
		regWidgetAvailability("intermediate_distance", all);
		regWidgetAvailability("distance", all);
		regWidgetAvailability("time", all);
		regWidgetAvailability("intermediate_time", all);
		regWidgetAvailability("map_marker_1st", none);
		regWidgetAvailability("map_marker_2nd", none);

		// top
		regWidgetVisibility("config", none);
		regWidgetVisibility("layers", none);
		regWidgetVisibility("compass", none);
		regWidgetVisibility("street_name", exceptAirBoatDefault);
		regWidgetVisibility("back_to_location", all);
		regWidgetVisibility("monitoring_services", none);
		regWidgetVisibility("bgService", none);
	}



	public static class ApplicationModeBuilder {
		private ApplicationMode applicationMode;

		public ApplicationMode reg() {
			values.add(applicationMode);
			defaultValues.add(applicationMode);
			return applicationMode;
		}

		public ApplicationMode customReg() {
			values.add(applicationMode);
			return applicationMode;
		}

		public ApplicationModeBuilder icon(int mapIcon, int smallIconDark) {
			applicationMode.mapIconId = mapIcon;
			applicationMode.smallIconDark = smallIconDark;
			return this;
		}


		public ApplicationModeBuilder parent(ApplicationMode parent) {
			applicationMode.parent = parent;
			return this;
		}

		/**
		 * @param type - id of set of icons for different navigation styles:
		 *               1 - car, 2 - bicicle, 3 - nautical, any other - default
		 */
		public ApplicationModeBuilder setLocationAndBearingIcons(int type) {
			switch (type) {
				case 1:
					return this.carLocation();
				case 2:
					return this.bicycleLocation();
				case 3:
					return this.nauticalLocation();
				default:
					return this.defLocation();
			}
		}

		public ApplicationModeBuilder carLocation() {
			applicationMode.bearingIconDay = R.drawable.map_car_bearing;
			applicationMode.bearingIconNight = R.drawable.map_car_bearing_night;
			applicationMode.headingIconDay = R.drawable.map_car_location_view_angle;
			applicationMode.headingIconNight = R.drawable.map_car_location_view_angle_night;
			applicationMode.locationIconDay = R.drawable.map_car_location;
			applicationMode.locationIconNight = R.drawable.map_car_location_night;
			applicationMode.locationIconDayLost = R.drawable.map_car_location_lost;
			applicationMode.locationIconNightLost = R.drawable.map_car_location_lost_night;
			return this;
		}

		public ApplicationModeBuilder bicycleLocation() {
			applicationMode.bearingIconDay = R.drawable.map_bicycle_bearing;
			applicationMode.bearingIconNight = R.drawable.map_bicycle_bearing_night;
			applicationMode.headingIconDay = R.drawable.map_bicycle_location_view_angle;
			applicationMode.headingIconNight = R.drawable.map_bicycle_location_view_angle_night;
			applicationMode.locationIconDay = R.drawable.map_bicycle_location;
			applicationMode.locationIconNight = R.drawable.map_bicycle_location_night;
			applicationMode.locationIconDayLost = R.drawable.map_bicycle_location_lost;
			applicationMode.locationIconNightLost = R.drawable.map_bicycle_location_lost_night;
			return this;
		}

		public ApplicationModeBuilder defLocation() {
			applicationMode.bearingIconDay = R.drawable.map_pedestrian_bearing;
			applicationMode.bearingIconNight = R.drawable.map_pedestrian_bearing_night;
			applicationMode.headingIconDay = R.drawable.map_default_location_view_angle;
			applicationMode.headingIconNight = R.drawable.map_default_location_view_angle_night;
			applicationMode.locationIconDay = R.drawable.map_pedestrian_location;
			applicationMode.locationIconNight = R.drawable.map_pedestrian_location_night;
			applicationMode.locationIconDayLost = R.drawable.map_pedestrian_location_lost;
			applicationMode.locationIconNightLost = R.drawable.map_pedestrian_location_lost_night;
			return this;
		}

		public ApplicationModeBuilder nauticalLocation() {
			applicationMode.bearingIconDay = R.drawable.map_nautical_bearing;
			applicationMode.bearingIconNight = R.drawable.map_nautical_bearing_night;
			applicationMode.headingIconDay = R.drawable.map_nautical_location_view_angle;
			applicationMode.headingIconNight = R.drawable.map_nautical_location_view_angle_night;
			applicationMode.locationIconDay = R.drawable.map_nautical_location;
			applicationMode.locationIconNight = R.drawable.map_nautical_location_night;
			return this;
		}

		public ApplicationModeBuilder speed(float defSpeed, int distForTurn) {
			applicationMode.defaultSpeed = defSpeed;
			applicationMode.minDistanceForTurn = distForTurn;
			return this;
		}

		public ApplicationModeBuilder arrivalDistance(int arrivalDistance) {
			applicationMode.arrivalDistance = arrivalDistance;
			return this;
		}

		public ApplicationModeBuilder offRouteDistance(int offRouteDistance) {
			applicationMode.offRouteDistance = offRouteDistance;
			return this;
		}

		public ApplicationModeBuilder userProfileTitle(String userProfileTitle) {
			applicationMode.userProfileTitle = userProfileTitle;
			return this;
		}
	}



	private static ApplicationModeBuilder create(int key, String stringKey) {
		ApplicationModeBuilder builder = new ApplicationModeBuilder();
		builder.applicationMode = new ApplicationMode(key, stringKey);
		return builder;
	}

	public static ApplicationModeBuilder createCustomMode(String userProfileTitle, String stringKey) {
		return create(-1, stringKey).userProfileTitle(userProfileTitle);
	}

	private ApplicationMode(int key, String stringKey) {
		this.key = key;
		this.stringKey = stringKey;
	}

	public static List<ApplicationMode> values(OsmandApplication app) {
		if (customizationListener == null) {
			customizationListener = new OsmAndAppCustomization.OsmAndAppCustomizationListener() {
				@Override
				public void onOsmAndSettingsCustomized() {
					cachedFilteredValues = new ArrayList<>();
				}
			};
			app.getAppCustomization().addListener(customizationListener);
		}
		if (cachedFilteredValues.isEmpty()) {
			OsmandSettings settings = app.getSettings();
			if (listener == null) {
				listener = new StateChangedListener<String>() {
					@Override
					public void stateChanged(String change) {
						cachedFilteredValues = new ArrayList<>();
					}
				};
				settings.AVAILABLE_APP_MODES.addListener(listener);
			}
			String available = settings.AVAILABLE_APP_MODES.get();
			cachedFilteredValues = new ArrayList<>();
			for (ApplicationMode v : values) {
				if (available.indexOf(v.getStringKey() + ",") != -1 || v == DEFAULT) {
					cachedFilteredValues.add(v);
				}
			}
		}
		return cachedFilteredValues;
	}

	public static List<ApplicationMode> allPossibleValues() {
		return new ArrayList<>(values);
	}

	public static List<ApplicationMode> getDefaultValues() {
		return new ArrayList<>(defaultValues);
	}

	// returns modifiable ! Set<ApplicationMode> to exclude non-wanted derived
	public static Set<ApplicationMode> regWidgetVisibility(String widgetId, ApplicationMode... am) {
		HashSet<ApplicationMode> set = new HashSet<>();
		if (am == null) {
			set.addAll(values);
		} else {
			Collections.addAll(set, am);
		}
		for (ApplicationMode m : values) {
			// add derived modes
			if (set.contains(m.getParent())) {
				set.add(m);
			}
		}
		widgetsVisibilityMap.put(widgetId, set);
		return set;
	}

	public boolean isWidgetCollapsible(String key) {
		return false;
	}

	public boolean isWidgetVisible(OsmandApplication app, String key) {
		if (app.getAppCustomization().areWidgetsCustomized()) {
			return app.getAppCustomization().isWidgetVisible(key, this);
		}
		Set<ApplicationMode> set = widgetsVisibilityMap.get(key);
		if (set == null) {
			return false;
		}
		return set.contains(this);
	}

	public static Set<ApplicationMode> regWidgetAvailability(String widgetId, ApplicationMode... am) {
		HashSet<ApplicationMode> set = new HashSet<>();
		if (am == null) {
			set.addAll(values);
		} else {
			Collections.addAll(set, am);
		}
		for (ApplicationMode m : values) {
			// add derived modes
			if (set.contains(m.getParent())) {
				set.add(m);
			}
		}
		widgetsAvailabilityMap.put(widgetId, set);
		return set;
	}

	public boolean isWidgetAvailable(OsmandApplication app, String key) {
		if (app.getAppCustomization().areWidgetsCustomized()) {
			return app.getAppCustomization().isWidgetAvailable(key, this);
		}
		Set<ApplicationMode> set = widgetsAvailabilityMap.get(key);
		if (set == null) {
			return true;
		}
		return set.contains(this);
	}

	public static List<ApplicationMode> getModesDerivedFrom(ApplicationMode am) {
		List<ApplicationMode> list = new ArrayList<ApplicationMode>();
		for (ApplicationMode a : values) {
			if (a == am || a.getParent() == am) {
				list.add(a);
			}
		}
		return list;
	}

	public ApplicationMode getParent() {
		return parent;
	}

	public int getSmallIconDark() {
		return smallIconDark;
	}

	public boolean hasFastSpeed() {
		return getDefaultSpeed() > 10;
	}

	public int getResourceBearingDay() {
		return bearingIconDay;
	}

	public int getResourceBearingNight() {
		//return bearingIconDay;
		return bearingIconNight;
	}

	public int getResourceHeadingDay() {
		return headingIconDay;
	}

	public int getResourceHeadingNight() {
		return headingIconNight;
	}

	public int getResourceLocationDay() {
		return locationIconDay;
	}

	public int getResourceLocationNight() {
		//return locationIconDay;
		return locationIconNight;
	}

	public int getResourceLocationDayLost() {
		return locationIconDayLost;
	}

	public int getResourceLocationNightLost() {
		return locationIconNightLost;
	}

	public String getStringKey() {
		return stringKey;
	}

	public int getMapIconId() {
		return mapIconId;
	}

	public int getStringResource() {
		return key;
	}

	public String toHumanString(Context ctx) {
		return ctx.getString(key);
	}

	public String toHumanStringCtx(Context ctx) {
		return ctx.getString(key);
	}

	public static ApplicationMode valueOfStringKey(String key, ApplicationMode def) {
		for (ApplicationMode p : values) {
			if (p.getStringKey().equals(key)) {
				return p;
			}
		}
		return def;
	}

	public float getDefaultSpeed() {
		return defaultSpeed;
	}

	public int getMinDistanceForTurn() {
		return minDistanceForTurn;
	}

	public int getArrivalDistance() {
		return arrivalDistance;
	}

	public int getOffRouteDistance() {
		return offRouteDistance;
	}

	public boolean isDerivedRoutingFrom(ApplicationMode mode) {
		return this == mode || getParent() == mode;
	}

	public String getUserProfileTitle() {
		return userProfileTitle;
	}

	private final int key;
	private final String stringKey;
	private String userProfileTitle = "";
	private ApplicationMode parent;
	private int mapIconId = R.drawable.map_world_globe_dark;
	private int smallIconDark = R.drawable.ic_world_globe_dark;
	private float defaultSpeed = 10f;
	private int minDistanceForTurn = 50;
	private int arrivalDistance = 90;
	private int offRouteDistance = 350;
	private int bearingIconDay = R.drawable.map_pedestrian_bearing;
	private int bearingIconNight = R.drawable.map_pedestrian_bearing_night;
	private int headingIconDay = R.drawable.map_pedestrian_location_view_angle;
	private int headingIconNight = R.drawable.map_pedestrian_location_view_angle_night;
	private int locationIconDay = R.drawable.map_pedestrian_location;
	private int locationIconNight = R.drawable.map_pedestrian_location_night;
	private int locationIconDayLost = R.drawable.map_pedestrian_location_lost;
	private int locationIconNightLost = R.drawable.map_pedestrian_location_lost_night;
	private static StateChangedListener<String> listener;
	private static OsmAndAppCustomization.OsmAndAppCustomizationListener customizationListener;
}
!@#$%
20190530_081431,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_a04544
package net.osmand.plus;

import android.content.Context;

import net.osmand.StateChangedListener;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;


public class ApplicationMode {
	private static Map<String, Set<ApplicationMode>> widgetsVisibilityMap = new LinkedHashMap<>();
	private static Map<String, Set<ApplicationMode>> widgetsAvailabilityMap = new LinkedHashMap<>();
	private static List<ApplicationMode> defaultValues = new ArrayList<>();
	private static List<ApplicationMode> values = new ArrayList<>();
	private static List<ApplicationMode> cachedFilteredValues = new ArrayList<>();
	/*
	 * DEFAULT("Browse map"), CAR("Car"), BICYCLE("Bicycle"), PEDESTRIAN("Pedestrian"); NAUTICAL("boat"); PUBLIC_TRANSPORT("Public transport")
	 */
	public static final ApplicationMode DEFAULT = create(R.string.app_mode_default, "default").speed(1.5f, 5).arrivalDistance(90).defLocation().
			icon(R.drawable.map_world_globe_dark, R.drawable.ic_world_globe_dark).reg();

	public static final ApplicationMode CAR = create(R.string.app_mode_car, "car").speed(15.3f, 35).carLocation().
			icon(R.drawable.map_action_car_dark, R.drawable.ic_action_car_dark).reg();

	public static final ApplicationMode BICYCLE = create(R.string.app_mode_bicycle, "bicycle").speed(5.5f, 15).arrivalDistance(60).offRouteDistance(50).bicycleLocation().
			icon(R.drawable.map_action_bicycle_dark, R.drawable.ic_action_bicycle_dark).reg();

	public static final ApplicationMode PEDESTRIAN = create(R.string.app_mode_pedestrian, "pedestrian").speed(1.5f, 5).arrivalDistance(45).offRouteDistance(20).
			icon(R.drawable.map_action_pedestrian_dark, R.drawable.ic_action_pedestrian_dark).reg();

	public static final ApplicationMode PUBLIC_TRANSPORT = create(R.string.app_mode_public_transport, "public_transport").
			icon(R.drawable.map_action_bus_dark, R.drawable.ic_action_bus_dark).reg();

	public static final ApplicationMode BOAT = create(R.string.app_mode_boat, "boat").speed(5.5f, 20).nauticalLocation().
			icon(R.drawable.map_action_sail_boat_dark, R.drawable.ic_action_sail_boat_dark).reg();

	public static final ApplicationMode AIRCRAFT = create(R.string.app_mode_aircraft, "aircraft").speed(40f, 100).carLocation().
			icon(R.drawable.map_action_aircraft, R.drawable.ic_action_aircraft).reg();
//---------------------------------------------------------------------------------------------------------------
//	public static final ApplicationMode HIKING = create(R.string.app_mode_hiking, "hiking").speed(1.5f, 5).parent(PEDESTRIAN).
//			icon(R.drawable.map_action_trekking_dark, R.drawable.ic_action_trekking_dark).reg();
//
//	public static final ApplicationMode MOTORCYCLE = create(R.string.app_mode_motorcycle, "motorcycle").speed(15.3f, 40).
//			carLocation().parent(CAR).
//			icon(R.drawable.map_action_motorcycle_dark, R.drawable.ic_action_motorcycle_dark).reg();
//
//	public static final ApplicationMode TRUCK = create(R.string.app_mode_truck, "truck").speed(15.3f, 40).
//			carLocation().parent(CAR).
//			icon(R.drawable.map_action_truck_dark, R.drawable.ic_action_truck_dark).reg();
//
//	public static final ApplicationMode TRAIN = create(R.string.app_mode_train, "train").speed(25f, 40).
//			carLocation().icon(R.drawable.map_action_train, R.drawable.ic_action_train).reg();

	static {
		ApplicationMode[] exceptDefault = new ApplicationMode[]{CAR, PEDESTRIAN, BICYCLE, BOAT, PUBLIC_TRANSPORT};
		ApplicationMode[] exceptPedestrianAndDefault = new ApplicationMode[]{CAR, BICYCLE, BOAT, PUBLIC_TRANSPORT};
		ApplicationMode[] exceptAirBoatDefault = new ApplicationMode[]{CAR, BICYCLE, PEDESTRIAN};
		ApplicationMode[] pedestrian = new ApplicationMode[]{PEDESTRIAN};
		ApplicationMode[] pedestrianBicycle = new ApplicationMode[]{PEDESTRIAN, BICYCLE};

		ApplicationMode[] all = null;
		ApplicationMode[] none = new ApplicationMode[]{};

		// left
		regWidgetVisibility("next_turn", exceptPedestrianAndDefault);
		regWidgetVisibility("next_turn_small", pedestrian);
		regWidgetVisibility("next_next_turn", exceptPedestrianAndDefault);
		regWidgetAvailability("next_turn", exceptDefault);
		regWidgetAvailability("next_turn_small", exceptDefault);
		regWidgetAvailability("next_next_turn", exceptDefault);

		// right
		regWidgetVisibility("intermediate_distance", all);
		regWidgetVisibility("distance", all);
		regWidgetVisibility("time", all);
		regWidgetVisibility("intermediate_time", all);
		regWidgetVisibility("speed", exceptPedestrianAndDefault);
		regWidgetVisibility("max_speed", CAR);
		regWidgetVisibility("altitude", pedestrianBicycle);
		regWidgetVisibility("gps_info", none);
		regWidgetAvailability("intermediate_distance", all);
		regWidgetAvailability("distance", all);
		regWidgetAvailability("time", all);
		regWidgetAvailability("intermediate_time", all);
		regWidgetAvailability("map_marker_1st", none);
		regWidgetAvailability("map_marker_2nd", none);

		// top
		regWidgetVisibility("config", none);
		regWidgetVisibility("layers", none);
		regWidgetVisibility("compass", none);
		regWidgetVisibility("street_name", exceptAirBoatDefault);
		regWidgetVisibility("back_to_location", all);
		regWidgetVisibility("monitoring_services", none);
		regWidgetVisibility("bgService", none);
	}



	public static class ApplicationModeBuilder {


		private ApplicationMode applicationMode;

		public ApplicationMode reg() {
			values.add(applicationMode);
			defaultValues.add(applicationMode);
			return applicationMode;
		}

		public ApplicationMode customReg() {
			values.add(applicationMode);
			return applicationMode;
		}

		public ApplicationModeBuilder icon(int mapIcon, int smallIconDark) {
			applicationMode.mapIconId = mapIcon;
			applicationMode.smallIconDark = smallIconDark;
			return this;
		}

		public ApplicationModeBuilder carLocation() {
			applicationMode.bearingIconDay = R.drawable.map_car_bearing;
			applicationMode.bearingIconNight = R.drawable.map_car_bearing_night;
			applicationMode.headingIconDay = R.drawable.map_car_location_view_angle;
			applicationMode.headingIconNight = R.drawable.map_car_location_view_angle_night;
			applicationMode.locationIconDay = R.drawable.map_car_location;
			applicationMode.locationIconNight = R.drawable.map_car_location_night;
			applicationMode.locationIconDayLost = R.drawable.map_car_location_lost;
			applicationMode.locationIconNightLost = R.drawable.map_car_location_lost_night;
			return this;
		}

		public ApplicationModeBuilder parent(ApplicationMode parent) {
			applicationMode.parent = parent;
			return this;
		}

		public ApplicationModeBuilder bicycleLocation() {
			applicationMode.bearingIconDay = R.drawable.map_bicycle_bearing;
			applicationMode.bearingIconNight = R.drawable.map_bicycle_bearing_night;
			applicationMode.headingIconDay = R.drawable.map_bicycle_location_view_angle;
			applicationMode.headingIconNight = R.drawable.map_bicycle_location_view_angle_night;
			applicationMode.locationIconDay = R.drawable.map_bicycle_location;
			applicationMode.locationIconNight = R.drawable.map_bicycle_location_night;
			applicationMode.locationIconDayLost = R.drawable.map_bicycle_location_lost;
			applicationMode.locationIconNightLost = R.drawable.map_bicycle_location_lost_night;
			return this;
		}

		public ApplicationModeBuilder defLocation() {
			applicationMode.bearingIconDay = R.drawable.map_pedestrian_bearing;
			applicationMode.bearingIconNight = R.drawable.map_pedestrian_bearing_night;
			applicationMode.headingIconDay = R.drawable.map_default_location_view_angle;
			applicationMode.headingIconNight = R.drawable.map_default_location_view_angle_night;
			applicationMode.locationIconDay = R.drawable.map_pedestrian_location;
			applicationMode.locationIconNight = R.drawable.map_pedestrian_location_night;
			applicationMode.locationIconDayLost = R.drawable.map_pedestrian_location_lost;
			applicationMode.locationIconNightLost = R.drawable.map_pedestrian_location_lost_night;
			return this;
		}

		public ApplicationModeBuilder nauticalLocation() {
			applicationMode.bearingIconDay = R.drawable.map_nautical_bearing;
			applicationMode.bearingIconNight = R.drawable.map_nautical_bearing_night;
			applicationMode.headingIconDay = R.drawable.map_nautical_location_view_angle;
			applicationMode.headingIconNight = R.drawable.map_nautical_location_view_angle_night;
			applicationMode.locationIconDay = R.drawable.map_nautical_location;
			applicationMode.locationIconNight = R.drawable.map_nautical_location_night;
			return this;
		}

		public ApplicationModeBuilder speed(float defSpeed, int distForTurn) {
			applicationMode.defaultSpeed = defSpeed;
			applicationMode.minDistanceForTurn = distForTurn;
			return this;
		}

		public ApplicationModeBuilder arrivalDistance(int arrivalDistance) {
			applicationMode.arrivalDistance = arrivalDistance;
			return this;
		}

		public ApplicationModeBuilder offRouteDistance(int offRouteDistance) {
			applicationMode.offRouteDistance = offRouteDistance;
			return this;
		}
	}

	private static ApplicationModeBuilder create(int key, String stringKey) {
		ApplicationModeBuilder builder = new ApplicationModeBuilder();
		builder.applicationMode = new ApplicationMode(key, stringKey);
		return builder;
	}

	public static ApplicationModeBuilder createCustomMode(String userProfileTitle, String stringKey) {
		return create(-1, stringKey);
	}

	private ApplicationMode(int key, String stringKey) {
		this.key = key;
		this.stringKey = stringKey;
	}

	public static List<ApplicationMode> values(OsmandApplication app) {
		if (customizationListener == null) {
			customizationListener = new OsmAndAppCustomization.OsmAndAppCustomizationListener() {
				@Override
				public void onOsmAndSettingsCustomized() {
					cachedFilteredValues = new ArrayList<>();
				}
			};
			app.getAppCustomization().addListener(customizationListener);
		}
		if (cachedFilteredValues.isEmpty()) {
			OsmandSettings settings = app.getSettings();
			if (listener == null) {
				listener = new StateChangedListener<String>() {
					@Override
					public void stateChanged(String change) {
						cachedFilteredValues = new ArrayList<>();
					}
				};
				settings.AVAILABLE_APP_MODES.addListener(listener);
			}
			String available = settings.AVAILABLE_APP_MODES.get();
			cachedFilteredValues = new ArrayList<>();
			for (ApplicationMode v : values) {
				if (available.indexOf(v.getStringKey() + ",") != -1 || v == DEFAULT) {
					cachedFilteredValues.add(v);
				}
			}
		}
		return cachedFilteredValues;
	}

	public static List<ApplicationMode> allPossibleValues() {
		return new ArrayList<>(values);
	}

	public static List<ApplicationMode> getDefaultValues() {
		return new ArrayList<>(defaultValues);
	}

	// returns modifiable ! Set<ApplicationMode> to exclude non-wanted derived
	public static Set<ApplicationMode> regWidgetVisibility(String widgetId, ApplicationMode... am) {
		HashSet<ApplicationMode> set = new HashSet<>();
		if (am == null) {
			set.addAll(values);
		} else {
			Collections.addAll(set, am);
		}
		for (ApplicationMode m : values) {
			// add derived modes
			if (set.contains(m.getParent())) {
				set.add(m);
			}
		}
		widgetsVisibilityMap.put(widgetId, set);
		return set;
	}

	public boolean isWidgetCollapsible(String key) {
		return false;
	}

	public boolean isWidgetVisible(OsmandApplication app, String key) {
		if (app.getAppCustomization().areWidgetsCustomized()) {
			return app.getAppCustomization().isWidgetVisible(key, this);
		}
		Set<ApplicationMode> set = widgetsVisibilityMap.get(key);
		if (set == null) {
			return false;
		}
		return set.contains(this);
	}

	public static Set<ApplicationMode> regWidgetAvailability(String widgetId, ApplicationMode... am) {
		HashSet<ApplicationMode> set = new HashSet<>();
		if (am == null) {
			set.addAll(values);
		} else {
			Collections.addAll(set, am);
		}
		for (ApplicationMode m : values) {
			// add derived modes
			if (set.contains(m.getParent())) {
				set.add(m);
			}
		}
		widgetsAvailabilityMap.put(widgetId, set);
		return set;
	}

	public boolean isWidgetAvailable(OsmandApplication app, String key) {
		if (app.getAppCustomization().areWidgetsCustomized()) {
			return app.getAppCustomization().isWidgetAvailable(key, this);
		}
		Set<ApplicationMode> set = widgetsAvailabilityMap.get(key);
		if (set == null) {
			return true;
		}
		return set.contains(this);
	}

	public static List<ApplicationMode> getModesDerivedFrom(ApplicationMode am) {
		List<ApplicationMode> list = new ArrayList<ApplicationMode>();
		for (ApplicationMode a : values) {
			if (a == am || a.getParent() == am) {
				list.add(a);
			}
		}
		return list;
	}

	public ApplicationMode getParent() {
		return parent;
	}

	public int getSmallIconDark() {
		return smallIconDark;
	}

	public boolean hasFastSpeed() {
		return getDefaultSpeed() > 10;
	}

	public int getResourceBearingDay() {
		return bearingIconDay;
	}

	public int getResourceBearingNight() {
		//return bearingIconDay;
		return bearingIconNight;
	}

	public int getResourceHeadingDay() {
		return headingIconDay;
	}

	public int getResourceHeadingNight() {
		return headingIconNight;
	}

	public int getResourceLocationDay() {
		return locationIconDay;
	}

	public int getResourceLocationNight() {
		//return locationIconDay;
		return locationIconNight;
	}

	public int getResourceLocationDayLost() {
		return locationIconDayLost;
	}

	public int getResourceLocationNightLost() {
		return locationIconNightLost;
	}

	public String getStringKey() {
		return stringKey;
	}

	public int getMapIconId() {
		return mapIconId;
	}

	public int getStringResource() {
		return key;
	}

	public String toHumanString(Context ctx) {
		return ctx.getString(key);
	}

	public String toHumanStringCtx(Context ctx) {
		return ctx.getString(key);
	}

	public static ApplicationMode valueOfStringKey(String key, ApplicationMode def) {
		for (ApplicationMode p : values) {
			if (p.getStringKey().equals(key)) {
				return p;
			}
		}
		return def;
	}

	public float getDefaultSpeed() {
		return defaultSpeed;
	}

	public int getMinDistanceForTurn() {
		return minDistanceForTurn;
	}

	public int getArrivalDistance() {
		return arrivalDistance;
	}

	public int getOffRouteDistance() {
		return offRouteDistance;
	}

	public void setUserProfileTitle(String userProfileTitle) {
		this.userProfileTitle = userProfileTitle;
	}

	public void setMapIconId(int mapIconId) {
		this.mapIconId = mapIconId;
	}

	public void setSmallIconDark(int smallIconDark) {
		this.smallIconDark = smallIconDark;
	}

	public boolean isDerivedRoutingFrom(ApplicationMode mode) {
		return this == mode || getParent() == mode;
	}

	public String getUserProfileTitle() {
		return userProfileTitle;
	}

	private final int key;
	private final String stringKey;
	private String userProfileTitle = "";
	private ApplicationMode parent;
	private int mapIconId = R.drawable.map_world_globe_dark;
	private int smallIconDark = R.drawable.ic_world_globe_dark;
	private float defaultSpeed = 10f;
	private int minDistanceForTurn = 50;
	private int arrivalDistance = 90;
	private int offRouteDistance = 350;
	private int bearingIconDay = R.drawable.map_pedestrian_bearing;
	private int bearingIconNight = R.drawable.map_pedestrian_bearing_night;
	private int headingIconDay = R.drawable.map_pedestrian_location_view_angle;
	private int headingIconNight = R.drawable.map_pedestrian_location_view_angle_night;
	private int locationIconDay = R.drawable.map_pedestrian_location;
	private int locationIconNight = R.drawable.map_pedestrian_location_night;
	private int locationIconDayLost = R.drawable.map_pedestrian_location_lost;
	private int locationIconNightLost = R.drawable.map_pedestrian_location_lost_night;
	private static StateChangedListener<String> listener;
	private static OsmAndAppCustomization.OsmAndAppCustomizationListener customizationListener;
}
!@#$%
20190530_081431,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_c04544
package net.osmand.plus;

import android.content.Context;

import net.osmand.StateChangedListener;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;


public class ApplicationMode {
	private static Map<String, Set<ApplicationMode>> widgetsVisibilityMap = new LinkedHashMap<>();
	private static Map<String, Set<ApplicationMode>> widgetsAvailabilityMap = new LinkedHashMap<>();
	private static List<ApplicationMode> defaultValues = new ArrayList<>();
	private static List<ApplicationMode> values = new ArrayList<>();
	private static List<ApplicationMode> cachedFilteredValues = new ArrayList<>();
	/*
	 * DEFAULT("Browse map"), CAR("Car"), BICYCLE("Bicycle"), PEDESTRIAN("Pedestrian"); NAUTICAL("boat"); PUBLIC_TRANSPORT("Public transport")
	 */
	public static final ApplicationMode DEFAULT = create(R.string.app_mode_default, "default").speed(1.5f, 5).arrivalDistance(90).defLocation().
			icon(R.drawable.map_world_globe_dark, R.drawable.ic_world_globe_dark).reg();

	public static final ApplicationMode CAR = create(R.string.app_mode_car, "car").speed(15.3f, 35).carLocation().
			icon(R.drawable.map_action_car_dark, R.drawable.ic_action_car_dark).reg();

	public static final ApplicationMode BICYCLE = create(R.string.app_mode_bicycle, "bicycle").speed(5.5f, 15).arrivalDistance(60).offRouteDistance(50).bicycleLocation().
			icon(R.drawable.map_action_bicycle_dark, R.drawable.ic_action_bicycle_dark).reg();

	public static final ApplicationMode PEDESTRIAN = create(R.string.app_mode_pedestrian, "pedestrian").speed(1.5f, 5).arrivalDistance(45).offRouteDistance(20).
			icon(R.drawable.map_action_pedestrian_dark, R.drawable.ic_action_pedestrian_dark).reg();

	public static final ApplicationMode PUBLIC_TRANSPORT = create(R.string.app_mode_public_transport, "public_transport").
			icon(R.drawable.map_action_bus_dark, R.drawable.ic_action_bus_dark).reg();

	public static final ApplicationMode BOAT = create(R.string.app_mode_boat, "boat").speed(5.5f, 20).nauticalLocation().
			icon(R.drawable.map_action_sail_boat_dark, R.drawable.ic_action_sail_boat_dark).reg();

	public static final ApplicationMode AIRCRAFT = create(R.string.app_mode_aircraft, "aircraft").speed(40f, 100).carLocation().
			icon(R.drawable.map_action_aircraft, R.drawable.ic_action_aircraft).reg();
//---------------------------------------------------------------------------------------------------------------
//	public static final ApplicationMode HIKING = create(R.string.app_mode_hiking, "hiking").speed(1.5f, 5).parent(PEDESTRIAN).
//			icon(R.drawable.map_action_trekking_dark, R.drawable.ic_action_trekking_dark).reg();
//
//	public static final ApplicationMode MOTORCYCLE = create(R.string.app_mode_motorcycle, "motorcycle").speed(15.3f, 40).
//			carLocation().parent(CAR).
//			icon(R.drawable.map_action_motorcycle_dark, R.drawable.ic_action_motorcycle_dark).reg();
//
//	public static final ApplicationMode TRUCK = create(R.string.app_mode_truck, "truck").speed(15.3f, 40).
//			carLocation().parent(CAR).
//			icon(R.drawable.map_action_truck_dark, R.drawable.ic_action_truck_dark).reg();
//
//	public static final ApplicationMode TRAIN = create(R.string.app_mode_train, "train").speed(25f, 40).
//			carLocation().icon(R.drawable.map_action_train, R.drawable.ic_action_train).reg();

	static {
		ApplicationMode[] exceptDefault = new ApplicationMode[]{CAR, PEDESTRIAN, BICYCLE, BOAT, PUBLIC_TRANSPORT};
		ApplicationMode[] exceptPedestrianAndDefault = new ApplicationMode[]{CAR, BICYCLE, BOAT, PUBLIC_TRANSPORT};
		ApplicationMode[] exceptAirBoatDefault = new ApplicationMode[]{CAR, BICYCLE, PEDESTRIAN};
		ApplicationMode[] pedestrian = new ApplicationMode[]{PEDESTRIAN};
		ApplicationMode[] pedestrianBicycle = new ApplicationMode[]{PEDESTRIAN, BICYCLE};

		ApplicationMode[] all = null;
		ApplicationMode[] none = new ApplicationMode[]{};

		// left
		regWidgetVisibility("next_turn", exceptPedestrianAndDefault);
		regWidgetVisibility("next_turn_small", pedestrian);
		regWidgetVisibility("next_next_turn", exceptPedestrianAndDefault);
		regWidgetAvailability("next_turn", exceptDefault);
		regWidgetAvailability("next_turn_small", exceptDefault);
		regWidgetAvailability("next_next_turn", exceptDefault);

		// right
		regWidgetVisibility("intermediate_distance", all);
		regWidgetVisibility("distance", all);
		regWidgetVisibility("time", all);
		regWidgetVisibility("intermediate_time", all);
		regWidgetVisibility("speed", exceptPedestrianAndDefault);
		regWidgetVisibility("max_speed", CAR);
		regWidgetVisibility("altitude", pedestrianBicycle);
		regWidgetVisibility("gps_info", none);
		regWidgetAvailability("intermediate_distance", all);
		regWidgetAvailability("distance", all);
		regWidgetAvailability("time", all);
		regWidgetAvailability("intermediate_time", all);
		regWidgetAvailability("map_marker_1st", none);
		regWidgetAvailability("map_marker_2nd", none);

		// top
		regWidgetVisibility("config", none);
		regWidgetVisibility("layers", none);
		regWidgetVisibility("compass", none);
		regWidgetVisibility("street_name", exceptAirBoatDefault);
		regWidgetVisibility("back_to_location", all);
		regWidgetVisibility("monitoring_services", none);
		regWidgetVisibility("bgService", none);
	}



	public static class ApplicationModeBuilder {


		private ApplicationMode applicationMode;

		public ApplicationMode reg() {
			values.add(applicationMode);
			defaultValues.add(applicationMode);
			return applicationMode;
		}

		public ApplicationMode customReg() {
			values.add(applicationMode);
			return applicationMode;
		}

		public ApplicationModeBuilder icon(int mapIcon, int smallIconDark) {
			applicationMode.mapIconId = mapIcon;
			applicationMode.smallIconDark = smallIconDark;
			return this;
		}

		public ApplicationModeBuilder carLocation() {
			applicationMode.bearingIconDay = R.drawable.map_car_bearing;
			applicationMode.bearingIconNight = R.drawable.map_car_bearing_night;
			applicationMode.headingIconDay = R.drawable.map_car_location_view_angle;
			applicationMode.headingIconNight = R.drawable.map_car_location_view_angle_night;
			applicationMode.locationIconDay = R.drawable.map_car_location;
			applicationMode.locationIconNight = R.drawable.map_car_location_night;
			applicationMode.locationIconDayLost = R.drawable.map_car_location_lost;
			applicationMode.locationIconNightLost = R.drawable.map_car_location_lost_night;
			return this;
		}

		public ApplicationModeBuilder parent(ApplicationMode parent) {
			applicationMode.parent = parent;
			return this;
		}

		public ApplicationModeBuilder bicycleLocation() {
			applicationMode.bearingIconDay = R.drawable.map_bicycle_bearing;
			applicationMode.bearingIconNight = R.drawable.map_bicycle_bearing_night;
			applicationMode.headingIconDay = R.drawable.map_bicycle_location_view_angle;
			applicationMode.headingIconNight = R.drawable.map_bicycle_location_view_angle_night;
			applicationMode.locationIconDay = R.drawable.map_bicycle_location;
			applicationMode.locationIconNight = R.drawable.map_bicycle_location_night;
			applicationMode.locationIconDayLost = R.drawable.map_bicycle_location_lost;
			applicationMode.locationIconNightLost = R.drawable.map_bicycle_location_lost_night;
			return this;
		}

		public ApplicationModeBuilder defLocation() {
			applicationMode.bearingIconDay = R.drawable.map_pedestrian_bearing;
			applicationMode.bearingIconNight = R.drawable.map_pedestrian_bearing_night;
			applicationMode.headingIconDay = R.drawable.map_default_location_view_angle;
			applicationMode.headingIconNight = R.drawable.map_default_location_view_angle_night;
			applicationMode.locationIconDay = R.drawable.map_pedestrian_location;
			applicationMode.locationIconNight = R.drawable.map_pedestrian_location_night;
			applicationMode.locationIconDayLost = R.drawable.map_pedestrian_location_lost;
			applicationMode.locationIconNightLost = R.drawable.map_pedestrian_location_lost_night;
			return this;
		}

		public ApplicationModeBuilder nauticalLocation() {
			applicationMode.bearingIconDay = R.drawable.map_nautical_bearing;
			applicationMode.bearingIconNight = R.drawable.map_nautical_bearing_night;
			applicationMode.headingIconDay = R.drawable.map_nautical_location_view_angle;
			applicationMode.headingIconNight = R.drawable.map_nautical_location_view_angle_night;
			applicationMode.locationIconDay = R.drawable.map_nautical_location;
			applicationMode.locationIconNight = R.drawable.map_nautical_location_night;
			return this;
		}

		public ApplicationModeBuilder speed(float defSpeed, int distForTurn) {
			applicationMode.defaultSpeed = defSpeed;
			applicationMode.minDistanceForTurn = distForTurn;
			return this;
		}

		public ApplicationModeBuilder arrivalDistance(int arrivalDistance) {
			applicationMode.arrivalDistance = arrivalDistance;
			return this;
		}

		public ApplicationModeBuilder offRouteDistance(int offRouteDistance) {
			applicationMode.offRouteDistance = offRouteDistance;
			return this;
		}

		public ApplicationModeBuilder userProfileTitle(String userProfileTitle) {
			applicationMode.userProfileTitle = userProfileTitle;
			return this;
		}
	}

	private static ApplicationModeBuilder create(int key, String stringKey) {
		ApplicationModeBuilder builder = new ApplicationModeBuilder();
		builder.applicationMode = new ApplicationMode(key, stringKey);
		return builder;
	}

	public static ApplicationModeBuilder createCustomMode(String userProfileTitle, String stringKey) {
		return create(-1, stringKey).userProfileTitle(userProfileTitle);
	}

	private ApplicationMode(int key, String stringKey) {
		this.key = key;
		this.stringKey = stringKey;
	}

	public static List<ApplicationMode> values(OsmandApplication app) {
		if (customizationListener == null) {
			customizationListener = new OsmAndAppCustomization.OsmAndAppCustomizationListener() {
				@Override
				public void onOsmAndSettingsCustomized() {
					cachedFilteredValues = new ArrayList<>();
				}
			};
			app.getAppCustomization().addListener(customizationListener);
		}
		if (cachedFilteredValues.isEmpty()) {
			OsmandSettings settings = app.getSettings();
			if (listener == null) {
				listener = new StateChangedListener<String>() {
					@Override
					public void stateChanged(String change) {
						cachedFilteredValues = new ArrayList<>();
					}
				};
				settings.AVAILABLE_APP_MODES.addListener(listener);
			}
			String available = settings.AVAILABLE_APP_MODES.get();
			cachedFilteredValues = new ArrayList<>();
			for (ApplicationMode v : values) {
				if (available.indexOf(v.getStringKey() + ",") != -1 || v == DEFAULT) {
					cachedFilteredValues.add(v);
				}
			}
		}
		return cachedFilteredValues;
	}

	public static List<ApplicationMode> allPossibleValues() {
		return new ArrayList<>(values);
	}

	public static List<ApplicationMode> getDefaultValues() {
		return new ArrayList<>(defaultValues);
	}

	// returns modifiable ! Set<ApplicationMode> to exclude non-wanted derived
	public static Set<ApplicationMode> regWidgetVisibility(String widgetId, ApplicationMode... am) {
		HashSet<ApplicationMode> set = new HashSet<>();
		if (am == null) {
			set.addAll(values);
		} else {
			Collections.addAll(set, am);
		}
		for (ApplicationMode m : values) {
			// add derived modes
			if (set.contains(m.getParent())) {
				set.add(m);
			}
		}
		widgetsVisibilityMap.put(widgetId, set);
		return set;
	}

	public boolean isWidgetCollapsible(String key) {
		return false;
	}

	public boolean isWidgetVisible(OsmandApplication app, String key) {
		if (app.getAppCustomization().areWidgetsCustomized()) {
			return app.getAppCustomization().isWidgetVisible(key, this);
		}
		Set<ApplicationMode> set = widgetsVisibilityMap.get(key);
		if (set == null) {
			return false;
		}
		return set.contains(this);
	}

	public static Set<ApplicationMode> regWidgetAvailability(String widgetId, ApplicationMode... am) {
		HashSet<ApplicationMode> set = new HashSet<>();
		if (am == null) {
			set.addAll(values);
		} else {
			Collections.addAll(set, am);
		}
		for (ApplicationMode m : values) {
			// add derived modes
			if (set.contains(m.getParent())) {
				set.add(m);
			}
		}
		widgetsAvailabilityMap.put(widgetId, set);
		return set;
	}

	public boolean isWidgetAvailable(OsmandApplication app, String key) {
		if (app.getAppCustomization().areWidgetsCustomized()) {
			return app.getAppCustomization().isWidgetAvailable(key, this);
		}
		Set<ApplicationMode> set = widgetsAvailabilityMap.get(key);
		if (set == null) {
			return true;
		}
		return set.contains(this);
	}

	public static List<ApplicationMode> getModesDerivedFrom(ApplicationMode am) {
		List<ApplicationMode> list = new ArrayList<ApplicationMode>();
		for (ApplicationMode a : values) {
			if (a == am || a.getParent() == am) {
				list.add(a);
			}
		}
		return list;
	}

	public ApplicationMode getParent() {
		return parent;
	}

	public int getSmallIconDark() {
		return smallIconDark;
	}

	public boolean hasFastSpeed() {
		return getDefaultSpeed() > 10;
	}

	public int getResourceBearingDay() {
		return bearingIconDay;
	}

	public int getResourceBearingNight() {
		//return bearingIconDay;
		return bearingIconNight;
	}

	public int getResourceHeadingDay() {
		return headingIconDay;
	}

	public int getResourceHeadingNight() {
		return headingIconNight;
	}

	public int getResourceLocationDay() {
		return locationIconDay;
	}

	public int getResourceLocationNight() {
		//return locationIconDay;
		return locationIconNight;
	}

	public int getResourceLocationDayLost() {
		return locationIconDayLost;
	}

	public int getResourceLocationNightLost() {
		return locationIconNightLost;
	}

	public String getStringKey() {
		return stringKey;
	}

	public int getMapIconId() {
		return mapIconId;
	}

	public int getStringResource() {
		return key;
	}

	public String toHumanString(Context ctx) {
		return ctx.getString(key);
	}

	public String toHumanStringCtx(Context ctx) {
		return ctx.getString(key);
	}

	public static ApplicationMode valueOfStringKey(String key, ApplicationMode def) {
		for (ApplicationMode p : values) {
			if (p.getStringKey().equals(key)) {
				return p;
			}
		}
		return def;
	}

	public float getDefaultSpeed() {
		return defaultSpeed;
	}

	public int getMinDistanceForTurn() {
		return minDistanceForTurn;
	}

	public int getArrivalDistance() {
		return arrivalDistance;
	}

	public int getOffRouteDistance() {
		return offRouteDistance;
	}

	public boolean isDerivedRoutingFrom(ApplicationMode mode) {
		return this == mode || getParent() == mode;
	}

	public String getUserProfileTitle() {
		return userProfileTitle;
	}

	private final int key;
	private final String stringKey;
	private String userProfileTitle = "";
	private ApplicationMode parent;
	private int mapIconId = R.drawable.map_world_globe_dark;
	private int smallIconDark = R.drawable.ic_world_globe_dark;
	private float defaultSpeed = 10f;
	private int minDistanceForTurn = 50;
	private int arrivalDistance = 90;
	private int offRouteDistance = 350;
	private int bearingIconDay = R.drawable.map_pedestrian_bearing;
	private int bearingIconNight = R.drawable.map_pedestrian_bearing_night;
	private int headingIconDay = R.drawable.map_pedestrian_location_view_angle;
	private int headingIconNight = R.drawable.map_pedestrian_location_view_angle_night;
	private int locationIconDay = R.drawable.map_pedestrian_location;
	private int locationIconNight = R.drawable.map_pedestrian_location_night;
	private int locationIconDayLost = R.drawable.map_pedestrian_location_lost;
	private int locationIconNightLost = R.drawable.map_pedestrian_location_lost_night;
	private static StateChangedListener<String> listener;
	private static OsmAndAppCustomization.OsmAndAppCustomizationListener customizationListener;
}
!@#$%
20190530_081623,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_b06248
package net.osmand.plus;

import android.content.Context;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.annotations.Expose;
import com.google.gson.reflect.TypeToken;
import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashSet;
import net.osmand.PlatformUtil;
import net.osmand.StateChangedListener;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import net.osmand.util.Algorithms;
import net.sf.junidecode.App;
import org.apache.commons.logging.Log;


public class ApplicationMode {

	private static final Log LOG = PlatformUtil.getLog(ApplicationMode.class);
	private static Map<String, Set<ApplicationMode>> widgetsVisibilityMap = new LinkedHashMap<>();
	private static Map<String, Set<ApplicationMode>> widgetsAvailabilityMap = new LinkedHashMap<>();
	private static List<ApplicationMode> defaultValues = new ArrayList<>();
	private static List<ApplicationMode> values = new ArrayList<>();
	private static List<ApplicationMode> cachedFilteredValues = new ArrayList<>();
	/*
	 * DEFAULT("Browse map"), CAR("Car"), BICYCLE("Bicycle"), PEDESTRIAN("Pedestrian"); NAUTICAL("boat"); PUBLIC_TRANSPORT("Public transport")
	 */
	public static final ApplicationMode DEFAULT = create(R.string.app_mode_default, "default").speed(1.5f, 5).arrivalDistance(90).defLocation().
			icon(R.drawable.map_world_globe_dark, R.drawable.ic_world_globe_dark).reg();

	public static final ApplicationMode CAR = create(R.string.app_mode_car, "car").speed(15.3f, 35).carLocation().
			icon(R.drawable.map_action_car_dark, R.drawable.ic_action_car_dark).reg();

	public static final ApplicationMode BICYCLE = create(R.string.app_mode_bicycle, "bicycle").speed(5.5f, 15).arrivalDistance(60).offRouteDistance(50).bicycleLocation().
			icon(R.drawable.map_action_bicycle_dark, R.drawable.ic_action_bicycle_dark).reg();

	public static final ApplicationMode PEDESTRIAN = create(R.string.app_mode_pedestrian, "pedestrian").speed(1.5f, 5).arrivalDistance(45).offRouteDistance(20).
			icon(R.drawable.map_action_pedestrian_dark, R.drawable.ic_action_pedestrian_dark).reg();

	public static final ApplicationMode PUBLIC_TRANSPORT = create(R.string.app_mode_public_transport, "public_transport").
			icon(R.drawable.map_action_bus_dark, R.drawable.ic_action_bus_dark).reg();

	public static final ApplicationMode BOAT = create(R.string.app_mode_boat, "boat").speed(5.5f, 20).nauticalLocation().
			icon(R.drawable.map_action_sail_boat_dark, R.drawable.ic_action_sail_boat_dark).reg();

	public static final ApplicationMode AIRCRAFT = create(R.string.app_mode_aircraft, "aircraft").speed(40f, 100).carLocation().
			icon(R.drawable.map_action_aircraft, R.drawable.ic_action_aircraft).reg();


//---------------------------------------------------------------------------------------------------------------
//	public static final ApplicationMode HIKING = create(R.string.app_mode_hiking, "hiking").speed(1.5f, 5).parent(PEDESTRIAN).
//			icon(R.drawable.map_action_trekking_dark, R.drawable.ic_action_trekking_dark).reg();
//
//	public static final ApplicationMode MOTORCYCLE = create(R.string.app_mode_motorcycle, "motorcycle").speed(15.3f, 40).
//			carLocation().parent(CAR).
//			icon(R.drawable.map_action_motorcycle_dark, R.drawable.ic_action_motorcycle_dark).reg();
//
//	public static final ApplicationMode TRUCK = create(R.string.app_mode_truck, "truck").speed(15.3f, 40).
//			carLocation().parent(CAR).
//			icon(R.drawable.map_action_truck_dark, R.drawable.ic_action_truck_dark).reg();
//
//	public static final ApplicationMode TRAIN = create(R.string.app_mode_train, "train").speed(25f, 40).
//			carLocation().icon(R.drawable.map_action_train, R.drawable.ic_action_train).reg();
	String profile = "profile: ";
	static {
		ApplicationMode[] exceptDefault = new ApplicationMode[]{CAR, PEDESTRIAN, BICYCLE, BOAT, PUBLIC_TRANSPORT};
		ApplicationMode[] exceptPedestrianAndDefault = new ApplicationMode[]{CAR, BICYCLE, BOAT, PUBLIC_TRANSPORT};
		ApplicationMode[] exceptAirBoatDefault = new ApplicationMode[]{CAR, BICYCLE, PEDESTRIAN};
		ApplicationMode[] pedestrian = new ApplicationMode[]{PEDESTRIAN};
		ApplicationMode[] pedestrianBicycle = new ApplicationMode[]{PEDESTRIAN, BICYCLE};

		ApplicationMode[] all = null;
		ApplicationMode[] none = new ApplicationMode[]{};

		// left
		regWidgetVisibility("next_turn", exceptPedestrianAndDefault);
		regWidgetVisibility("next_turn_small", pedestrian);
		regWidgetVisibility("next_next_turn", exceptPedestrianAndDefault);
		regWidgetAvailability("next_turn", exceptDefault);
		regWidgetAvailability("next_turn_small", exceptDefault);
		regWidgetAvailability("next_next_turn", exceptDefault);

		// right
		regWidgetVisibility("intermediate_distance", all);
		regWidgetVisibility("distance", all);
		regWidgetVisibility("time", all);
		regWidgetVisibility("intermediate_time", all);
		regWidgetVisibility("speed", exceptPedestrianAndDefault);
		regWidgetVisibility("max_speed", CAR);
		regWidgetVisibility("altitude", pedestrianBicycle);
		regWidgetVisibility("gps_info", none);
		regWidgetAvailability("intermediate_distance", all);
		regWidgetAvailability("distance", all);
		regWidgetAvailability("time", all);
		regWidgetAvailability("intermediate_time", all);
		regWidgetAvailability("map_marker_1st", none);
		regWidgetAvailability("map_marker_2nd", none);

		// top
		regWidgetVisibility("config", none);
		regWidgetVisibility("layers", none);
		regWidgetVisibility("compass", none);
		regWidgetVisibility("street_name", exceptAirBoatDefault);
		regWidgetVisibility("back_to_location", all);
		regWidgetVisibility("monitoring_services", none);
		regWidgetVisibility("bgService", none);
	}



	public static class ApplicationModeBuilder {
		private ApplicationMode applicationMode;

		public ApplicationMode reg() {
			values.add(applicationMode);
			defaultValues.add(applicationMode);
			return applicationMode;
		}

		public ApplicationMode customReg() {
			values.add(applicationMode);
			return applicationMode;
		}

		public ApplicationModeBuilder icon(int mapIcon, int smallIconDark) {
			applicationMode.mapIconId = mapIcon;
			applicationMode.smallIconDark = smallIconDark;
			return this;
		}


		public ApplicationModeBuilder parent(ApplicationMode parent) {
			applicationMode.parent = parent;
			return this;
		}

		/**
		 * @param type - id of set of icons for different navigation styles:
		 *               1 - car, 2 - bicicle, 3 - nautical, any other - default
		 */
		public ApplicationModeBuilder setLocationAndBearingIcons(int type) {
			applicationMode.mapIconsSetId = type;
			switch (type) {
				case 1:
					return this.carLocation();
				case 2:
					return this.bicycleLocation();
				case 3:
					return this.nauticalLocation();
				default:
					return this.defLocation();
			}
		}

		public ApplicationModeBuilder carLocation() {
			applicationMode.bearingIconDay = R.drawable.map_car_bearing;
			applicationMode.bearingIconNight = R.drawable.map_car_bearing_night;
			applicationMode.headingIconDay = R.drawable.map_car_location_view_angle;
			applicationMode.headingIconNight = R.drawable.map_car_location_view_angle_night;
			applicationMode.locationIconDay = R.drawable.map_car_location;
			applicationMode.locationIconNight = R.drawable.map_car_location_night;
			applicationMode.locationIconDayLost = R.drawable.map_car_location_lost;
			applicationMode.locationIconNightLost = R.drawable.map_car_location_lost_night;
			return this;
		}

		public ApplicationModeBuilder bicycleLocation() {
			applicationMode.bearingIconDay = R.drawable.map_bicycle_bearing;
			applicationMode.bearingIconNight = R.drawable.map_bicycle_bearing_night;
			applicationMode.headingIconDay = R.drawable.map_bicycle_location_view_angle;
			applicationMode.headingIconNight = R.drawable.map_bicycle_location_view_angle_night;
			applicationMode.locationIconDay = R.drawable.map_bicycle_location;
			applicationMode.locationIconNight = R.drawable.map_bicycle_location_night;
			applicationMode.locationIconDayLost = R.drawable.map_bicycle_location_lost;
			applicationMode.locationIconNightLost = R.drawable.map_bicycle_location_lost_night;
			return this;
		}

		public ApplicationModeBuilder defLocation() {
			applicationMode.bearingIconDay = R.drawable.map_pedestrian_bearing;
			applicationMode.bearingIconNight = R.drawable.map_pedestrian_bearing_night;
			applicationMode.headingIconDay = R.drawable.map_default_location_view_angle;
			applicationMode.headingIconNight = R.drawable.map_default_location_view_angle_night;
			applicationMode.locationIconDay = R.drawable.map_pedestrian_location;
			applicationMode.locationIconNight = R.drawable.map_pedestrian_location_night;
			applicationMode.locationIconDayLost = R.drawable.map_pedestrian_location_lost;
			applicationMode.locationIconNightLost = R.drawable.map_pedestrian_location_lost_night;
			return this;
		}

		public ApplicationModeBuilder nauticalLocation() {
			applicationMode.bearingIconDay = R.drawable.map_nautical_bearing;
			applicationMode.bearingIconNight = R.drawable.map_nautical_bearing_night;
			applicationMode.headingIconDay = R.drawable.map_nautical_location_view_angle;
			applicationMode.headingIconNight = R.drawable.map_nautical_location_view_angle_night;
			applicationMode.locationIconDay = R.drawable.map_nautical_location;
			applicationMode.locationIconNight = R.drawable.map_nautical_location_night;
			return this;
		}

		public ApplicationModeBuilder speed(float defSpeed, int distForTurn) {
			applicationMode.defaultSpeed = defSpeed;
			applicationMode.minDistanceForTurn = distForTurn;
			return this;
		}

		public ApplicationModeBuilder arrivalDistance(int arrivalDistance) {
			applicationMode.arrivalDistance = arrivalDistance;
			return this;
		}

		public ApplicationModeBuilder offRouteDistance(int offRouteDistance) {
			applicationMode.offRouteDistance = offRouteDistance;
			return this;
		}

		public ApplicationModeBuilder userProfileTitle(String userProfileTitle) {
			applicationMode.userProfileName = userProfileTitle;
			return this;
		}
	}



	private static ApplicationModeBuilder create(int key, String stringKey) {
		ApplicationModeBuilder builder = new ApplicationModeBuilder();
		builder.applicationMode = new ApplicationMode(key, stringKey);
		return builder;
	}

	public static ApplicationModeBuilder createCustomMode(String userProfileTitle, String stringKey) {
		return create(-1, stringKey).userProfileTitle(userProfileTitle);
	}

	private ApplicationMode(int key, String stringKey) {
		this.key = key;
		this.stringKey = stringKey;
	}

	public static List<ApplicationMode> values(OsmandApplication app) {
		if (customizationListener == null) {
			customizationListener = new OsmAndAppCustomization.OsmAndAppCustomizationListener() {
				@Override
				public void onOsmAndSettingsCustomized() {
					cachedFilteredValues = new ArrayList<>();
				}
			};
			app.getAppCustomization().addListener(customizationListener);
		}
		if (cachedFilteredValues.isEmpty()) {
			OsmandSettings settings = app.getSettings();
			if (listener == null) {
				listener = new StateChangedListener<String>() {
					@Override
					public void stateChanged(String change) {
						cachedFilteredValues = new ArrayList<>();
					}
				};
				settings.AVAILABLE_APP_MODES.addListener(listener);
			}
			String available = settings.AVAILABLE_APP_MODES.get();
			cachedFilteredValues = new ArrayList<>();
			for (ApplicationMode v : values) {
				if (available.indexOf(v.getStringKey() + ",") != -1 || v == DEFAULT) {
					cachedFilteredValues.add(v);
				}
			}
		}
		return cachedFilteredValues;
	}

	public static List<ApplicationMode> allPossibleValues() {
		return new ArrayList<>(values);
	}

	public static List<ApplicationMode> getDefaultValues() {
		return new ArrayList<>(defaultValues);
	}

	// returns modifiable ! Set<ApplicationMode> to exclude non-wanted derived
	public static Set<ApplicationMode> regWidgetVisibility(String widgetId, ApplicationMode... am) {
		HashSet<ApplicationMode> set = new HashSet<>();
		if (am == null) {
			set.addAll(values);
		} else {
			Collections.addAll(set, am);
		}
		for (ApplicationMode m : values) {
			// add derived modes
			if (set.contains(m.getParent())) {
				set.add(m);
			}
		}
		widgetsVisibilityMap.put(widgetId, set);
		return set;
	}

	public boolean isWidgetCollapsible(String key) {
		return false;
	}

	public boolean isWidgetVisible(OsmandApplication app, String key) {
		if (app.getAppCustomization().areWidgetsCustomized()) {
			return app.getAppCustomization().isWidgetVisible(key, this);
		}
		Set<ApplicationMode> set = widgetsVisibilityMap.get(key);
		if (set == null) {
			return false;
		}
		return set.contains(this);
	}

	public static Set<ApplicationMode> regWidgetAvailability(String widgetId, ApplicationMode... am) {
		HashSet<ApplicationMode> set = new HashSet<>();
		if (am == null) {
			set.addAll(values);
		} else {
			Collections.addAll(set, am);
		}
		for (ApplicationMode m : values) {
			// add derived modes
			if (set.contains(m.getParent())) {
				set.add(m);
			}
		}
		widgetsAvailabilityMap.put(widgetId, set);
		return set;
	}

	public boolean isWidgetAvailable(OsmandApplication app, String key) {
		if (app.getAppCustomization().areWidgetsCustomized()) {
			return app.getAppCustomization().isWidgetAvailable(key, this);
		}
		Set<ApplicationMode> set = widgetsAvailabilityMap.get(key);
		if (set == null) {
			return true;
		}
		return set.contains(this);
	}

	public static List<ApplicationMode> getModesDerivedFrom(ApplicationMode am) {
		List<ApplicationMode> list = new ArrayList<ApplicationMode>();
		for (ApplicationMode a : values) {
			if (a == am || a.getParent() == am) {
				list.add(a);
			}
		}
		return list;
	}

	public ApplicationMode getParent() {
		return parent;
	}

	public int getSmallIconDark() {
		return smallIconDark;
	}

	public boolean hasFastSpeed() {
		return getDefaultSpeed() > 10;
	}

	public int getResourceBearingDay() {
		return bearingIconDay;
	}

	public int getResourceBearingNight() {
		//return bearingIconDay;
		return bearingIconNight;
	}

	public int getResourceHeadingDay() {
		return headingIconDay;
	}

	public int getResourceHeadingNight() {
		return headingIconNight;
	}

	public int getResourceLocationDay() {
		return locationIconDay;
	}

	public int getResourceLocationNight() {
		//return locationIconDay;
		return locationIconNight;
	}

	public int getResourceLocationDayLost() {
		return locationIconDayLost;
	}

	public int getResourceLocationNightLost() {
		return locationIconNightLost;
	}

	public String getStringKey() {
		return stringKey;
	}

	public int getMapIconId() {
		return mapIconId;
	}

	public int getStringResource() {
		return key;
	}

	public String toHumanString(Context ctx) {
		if (Algorithms.isEmpty(userProfileName) && key != -1) {
			return ctx.getString(key);
		} else {
			return userProfileName;
		}

	}

	public String toHumanStringCtx(Context ctx) {
		if (Algorithms.isEmpty(userProfileName)) {
			return ctx.getString(key);
		} else {
			return userProfileName;
		}
	}

	public static ApplicationMode valueOfStringKey(String key, ApplicationMode def) {
		for (ApplicationMode p : values) {
			if (p.getStringKey().equals(key)) {
				return p;
			}
		}
		return def;
	}

	public float getDefaultSpeed() {
		return defaultSpeed;
	}

	public int getMinDistanceForTurn() {
		return minDistanceForTurn;
	}

	public int getArrivalDistance() {
		return arrivalDistance;
	}

	public int getOffRouteDistance() {
		return offRouteDistance;
	}

	public boolean isDerivedRoutingFrom(ApplicationMode mode) {
		return this == mode || getParent() == mode;
	}

	public int getMapIconsSetId() {
		return mapIconsSetId;
	}

	public String getUserProfileName() {
		return userProfileName;
	}

	@Expose private final int key;
	@Expose private final String stringKey;
	@Expose private String userProfileName;
	@Expose private int mapIconsSetId = 0;
	@Expose private ApplicationMode parent;
	@Expose private int mapIconId = R.drawable.map_world_globe_dark;
	@Expose private int smallIconDark = R.drawable.ic_world_globe_dark;
	@Expose private float defaultSpeed = 10f;
	@Expose private int minDistanceForTurn = 50;
	@Expose private int arrivalDistance = 90;
	@Expose private int offRouteDistance = 350;
	@Expose private int bearingIconDay = R.drawable.map_pedestrian_bearing;
	@Expose private int bearingIconNight = R.drawable.map_pedestrian_bearing_night;
	@Expose private int headingIconDay = R.drawable.map_pedestrian_location_view_angle;
	@Expose private int headingIconNight = R.drawable.map_pedestrian_location_view_angle_night;
	@Expose private int locationIconDay = R.drawable.map_pedestrian_location;
	@Expose private int locationIconNight = R.drawable.map_pedestrian_location_night;
	@Expose private int locationIconDayLost = R.drawable.map_pedestrian_location_lost;
	@Expose private int locationIconNightLost = R.drawable.map_pedestrian_location_lost_night;
	private static StateChangedListener<String> listener;
	private static OsmAndAppCustomization.OsmAndAppCustomizationListener customizationListener;

	public static void saveCustomModeToSettings(OsmandSettings settings){
		List<ApplicationMode> customModes = new ArrayList<>();
		for (ApplicationMode mode : values) {
			if (mode.parent != null) {
				customModes.add(mode);
			}
		}
		Gson gson = new GsonBuilder().excludeFieldsWithoutExposeAnnotation().create();
		String profiles = gson.toJson(customModes);
		settings.CUSTOM_APP_PROFILES.set(profiles);
	}

	public static void initCustomModes(OsmandSettings settings){
		Gson gson = new GsonBuilder().excludeFieldsWithoutExposeAnnotation().create();
		Type t = new TypeToken<ArrayList<ApplicationMode>>() {}.getType();
		List<ApplicationMode> customProfiles = gson.fromJson(settings.CUSTOM_APP_PROFILES.get(), t);

		if (!Algorithms.isEmpty(customProfiles)) {
			for (ApplicationMode m : customProfiles) {
				if (!values.contains(m)) {
					values.add(m);
				}
			}
		}
	}

	public static void deleteCustomMode(String userModeTitle, OsmandApplication app) {
		Iterator<ApplicationMode> it = values.iterator();
		while (it.hasNext()) {
			ApplicationMode m = it.next();
			if (m.userProfileName == userModeTitle) {
				it.remove();
			}
		}
		ApplicationMode.saveCustomModeToSettings(app.getSettings());
	}



}
!@#$%
20190530_081623,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_a06248
package net.osmand.plus;

import android.content.Context;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.annotations.Expose;
import com.google.gson.reflect.TypeToken;
import java.lang.reflect.Type;
import java.util.HashMap;
import net.osmand.PlatformUtil;
import net.osmand.StateChangedListener;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import net.osmand.util.Algorithms;
import net.sf.junidecode.App;
import org.apache.commons.logging.Log;


public class ApplicationMode {

	private static final Log LOG = PlatformUtil.getLog(ApplicationMode.class);
	private static Map<String, Set<ApplicationMode>> widgetsVisibilityMap = new LinkedHashMap<>();
	private static Map<String, Set<ApplicationMode>> widgetsAvailabilityMap = new LinkedHashMap<>();
	private static List<ApplicationMode> defaultValues = new ArrayList<>();
	private static List<ApplicationMode> values = new ArrayList<>();
	private static List<ApplicationMode> cachedFilteredValues = new ArrayList<>();
	/*
	 * DEFAULT("Browse map"), CAR("Car"), BICYCLE("Bicycle"), PEDESTRIAN("Pedestrian"); NAUTICAL("boat"); PUBLIC_TRANSPORT("Public transport")
	 */
	public static final ApplicationMode DEFAULT = create(R.string.app_mode_default, "default").speed(1.5f, 5).arrivalDistance(90).defLocation().
			icon(R.drawable.map_world_globe_dark, R.drawable.ic_world_globe_dark).reg();

	public static final ApplicationMode CAR = create(R.string.app_mode_car, "car").speed(15.3f, 35).carLocation().
			icon(R.drawable.map_action_car_dark, R.drawable.ic_action_car_dark).reg();

	public static final ApplicationMode BICYCLE = create(R.string.app_mode_bicycle, "bicycle").speed(5.5f, 15).arrivalDistance(60).offRouteDistance(50).bicycleLocation().
			icon(R.drawable.map_action_bicycle_dark, R.drawable.ic_action_bicycle_dark).reg();

	public static final ApplicationMode PEDESTRIAN = create(R.string.app_mode_pedestrian, "pedestrian").speed(1.5f, 5).arrivalDistance(45).offRouteDistance(20).
			icon(R.drawable.map_action_pedestrian_dark, R.drawable.ic_action_pedestrian_dark).reg();

	public static final ApplicationMode PUBLIC_TRANSPORT = create(R.string.app_mode_public_transport, "public_transport").
			icon(R.drawable.map_action_bus_dark, R.drawable.ic_action_bus_dark).reg();

	public static final ApplicationMode BOAT = create(R.string.app_mode_boat, "boat").speed(5.5f, 20).nauticalLocation().
			icon(R.drawable.map_action_sail_boat_dark, R.drawable.ic_action_sail_boat_dark).reg();

	public static final ApplicationMode AIRCRAFT = create(R.string.app_mode_aircraft, "aircraft").speed(40f, 100).carLocation().
			icon(R.drawable.map_action_aircraft, R.drawable.ic_action_aircraft).reg();


//---------------------------------------------------------------------------------------------------------------
//	public static final ApplicationMode HIKING = create(R.string.app_mode_hiking, "hiking").speed(1.5f, 5).parent(PEDESTRIAN).
//			icon(R.drawable.map_action_trekking_dark, R.drawable.ic_action_trekking_dark).reg();
//
//	public static final ApplicationMode MOTORCYCLE = create(R.string.app_mode_motorcycle, "motorcycle").speed(15.3f, 40).
//			carLocation().parent(CAR).
//			icon(R.drawable.map_action_motorcycle_dark, R.drawable.ic_action_motorcycle_dark).reg();
//
//	public static final ApplicationMode TRUCK = create(R.string.app_mode_truck, "truck").speed(15.3f, 40).
//			carLocation().parent(CAR).
//			icon(R.drawable.map_action_truck_dark, R.drawable.ic_action_truck_dark).reg();
//
//	public static final ApplicationMode TRAIN = create(R.string.app_mode_train, "train").speed(25f, 40).
//			carLocation().icon(R.drawable.map_action_train, R.drawable.ic_action_train).reg();
	String profile = "profile: ";
	static {
		ApplicationMode[] exceptDefault = new ApplicationMode[]{CAR, PEDESTRIAN, BICYCLE, BOAT, PUBLIC_TRANSPORT};
		ApplicationMode[] exceptPedestrianAndDefault = new ApplicationMode[]{CAR, BICYCLE, BOAT, PUBLIC_TRANSPORT};
		ApplicationMode[] exceptAirBoatDefault = new ApplicationMode[]{CAR, BICYCLE, PEDESTRIAN};
		ApplicationMode[] pedestrian = new ApplicationMode[]{PEDESTRIAN};
		ApplicationMode[] pedestrianBicycle = new ApplicationMode[]{PEDESTRIAN, BICYCLE};

		ApplicationMode[] all = null;
		ApplicationMode[] none = new ApplicationMode[]{};

		// left
		regWidgetVisibility("next_turn", exceptPedestrianAndDefault);
		regWidgetVisibility("next_turn_small", pedestrian);
		regWidgetVisibility("next_next_turn", exceptPedestrianAndDefault);
		regWidgetAvailability("next_turn", exceptDefault);
		regWidgetAvailability("next_turn_small", exceptDefault);
		regWidgetAvailability("next_next_turn", exceptDefault);

		// right
		regWidgetVisibility("intermediate_distance", all);
		regWidgetVisibility("distance", all);
		regWidgetVisibility("time", all);
		regWidgetVisibility("intermediate_time", all);
		regWidgetVisibility("speed", exceptPedestrianAndDefault);
		regWidgetVisibility("max_speed", CAR);
		regWidgetVisibility("altitude", pedestrianBicycle);
		regWidgetVisibility("gps_info", none);
		regWidgetAvailability("intermediate_distance", all);
		regWidgetAvailability("distance", all);
		regWidgetAvailability("time", all);
		regWidgetAvailability("intermediate_time", all);
		regWidgetAvailability("map_marker_1st", none);
		regWidgetAvailability("map_marker_2nd", none);

		// top
		regWidgetVisibility("config", none);
		regWidgetVisibility("layers", none);
		regWidgetVisibility("compass", none);
		regWidgetVisibility("street_name", exceptAirBoatDefault);
		regWidgetVisibility("back_to_location", all);
		regWidgetVisibility("monitoring_services", none);
		regWidgetVisibility("bgService", none);
	}



	public static class ApplicationModeBuilder {
		private ApplicationMode applicationMode;

		public ApplicationMode reg() {
			values.add(applicationMode);
			defaultValues.add(applicationMode);
			return applicationMode;
		}

		public ApplicationMode customReg() {
			values.add(applicationMode);
			return applicationMode;
		}

		public ApplicationModeBuilder icon(int mapIcon, int smallIconDark) {
			applicationMode.mapIconId = mapIcon;
			applicationMode.smallIconDark = smallIconDark;
			return this;
		}


		public ApplicationModeBuilder parent(ApplicationMode parent) {
			applicationMode.parent = parent;
			return this;
		}

		/**
		 * @param type - id of set of icons for different navigation styles:
		 *               1 - car, 2 - bicicle, 3 - nautical, any other - default
		 */
		public ApplicationModeBuilder setLocationAndBearingIcons(int type) {
			applicationMode.mapIconsSetId = type;
			switch (type) {
				case 1:
					return this.carLocation();
				case 2:
					return this.bicycleLocation();
				case 3:
					return this.nauticalLocation();
				default:
					return this.defLocation();
			}
		}

		public ApplicationModeBuilder carLocation() {
			applicationMode.bearingIconDay = R.drawable.map_car_bearing;
			applicationMode.bearingIconNight = R.drawable.map_car_bearing_night;
			applicationMode.headingIconDay = R.drawable.map_car_location_view_angle;
			applicationMode.headingIconNight = R.drawable.map_car_location_view_angle_night;
			applicationMode.locationIconDay = R.drawable.map_car_location;
			applicationMode.locationIconNight = R.drawable.map_car_location_night;
			applicationMode.locationIconDayLost = R.drawable.map_car_location_lost;
			applicationMode.locationIconNightLost = R.drawable.map_car_location_lost_night;
			return this;
		}

		public ApplicationModeBuilder bicycleLocation() {
			applicationMode.bearingIconDay = R.drawable.map_bicycle_bearing;
			applicationMode.bearingIconNight = R.drawable.map_bicycle_bearing_night;
			applicationMode.headingIconDay = R.drawable.map_bicycle_location_view_angle;
			applicationMode.headingIconNight = R.drawable.map_bicycle_location_view_angle_night;
			applicationMode.locationIconDay = R.drawable.map_bicycle_location;
			applicationMode.locationIconNight = R.drawable.map_bicycle_location_night;
			applicationMode.locationIconDayLost = R.drawable.map_bicycle_location_lost;
			applicationMode.locationIconNightLost = R.drawable.map_bicycle_location_lost_night;
			return this;
		}

		public ApplicationModeBuilder defLocation() {
			applicationMode.bearingIconDay = R.drawable.map_pedestrian_bearing;
			applicationMode.bearingIconNight = R.drawable.map_pedestrian_bearing_night;
			applicationMode.headingIconDay = R.drawable.map_default_location_view_angle;
			applicationMode.headingIconNight = R.drawable.map_default_location_view_angle_night;
			applicationMode.locationIconDay = R.drawable.map_pedestrian_location;
			applicationMode.locationIconNight = R.drawable.map_pedestrian_location_night;
			applicationMode.locationIconDayLost = R.drawable.map_pedestrian_location_lost;
			applicationMode.locationIconNightLost = R.drawable.map_pedestrian_location_lost_night;
			return this;
		}

		public ApplicationModeBuilder nauticalLocation() {
			applicationMode.bearingIconDay = R.drawable.map_nautical_bearing;
			applicationMode.bearingIconNight = R.drawable.map_nautical_bearing_night;
			applicationMode.headingIconDay = R.drawable.map_nautical_location_view_angle;
			applicationMode.headingIconNight = R.drawable.map_nautical_location_view_angle_night;
			applicationMode.locationIconDay = R.drawable.map_nautical_location;
			applicationMode.locationIconNight = R.drawable.map_nautical_location_night;
			return this;
		}

		public ApplicationModeBuilder speed(float defSpeed, int distForTurn) {
			applicationMode.defaultSpeed = defSpeed;
			applicationMode.minDistanceForTurn = distForTurn;
			return this;
		}

		public ApplicationModeBuilder arrivalDistance(int arrivalDistance) {
			applicationMode.arrivalDistance = arrivalDistance;
			return this;
		}

		public ApplicationModeBuilder offRouteDistance(int offRouteDistance) {
			applicationMode.offRouteDistance = offRouteDistance;
			return this;
		}

		public ApplicationModeBuilder userProfileTitle(String userProfileTitle) {
			applicationMode.userProfileName = userProfileTitle;
			return this;
		}
	}



	private static ApplicationModeBuilder create(int key, String stringKey) {
		ApplicationModeBuilder builder = new ApplicationModeBuilder();
		builder.applicationMode = new ApplicationMode(key, stringKey);
		return builder;
	}

	public static ApplicationModeBuilder createCustomMode(String userProfileTitle, String stringKey) {
		return create(-1, stringKey).userProfileTitle(userProfileTitle);
	}

	private ApplicationMode(int key, String stringKey) {
		this.key = key;
		this.stringKey = stringKey;
	}

	public static List<ApplicationMode> values(OsmandApplication app) {
		if (customizationListener == null) {
			customizationListener = new OsmAndAppCustomization.OsmAndAppCustomizationListener() {
				@Override
				public void onOsmAndSettingsCustomized() {
					cachedFilteredValues = new ArrayList<>();
				}
			};
			app.getAppCustomization().addListener(customizationListener);
		}
		if (cachedFilteredValues.isEmpty()) {
			OsmandSettings settings = app.getSettings();
			if (listener == null) {
				listener = new StateChangedListener<String>() {
					@Override
					public void stateChanged(String change) {
						cachedFilteredValues = new ArrayList<>();
					}
				};
				settings.AVAILABLE_APP_MODES.addListener(listener);
			}
			String available = settings.AVAILABLE_APP_MODES.get();
			cachedFilteredValues = new ArrayList<>();
			for (ApplicationMode v : values) {
				if (available.indexOf(v.getStringKey() + ",") != -1 || v == DEFAULT) {
					cachedFilteredValues.add(v);
				}
			}
		}
		return cachedFilteredValues;
	}

	public static List<ApplicationMode> allPossibleValues() {
		return new ArrayList<>(values);
	}

	public static List<ApplicationMode> getDefaultValues() {
		return new ArrayList<>(defaultValues);
	}

	// returns modifiable ! Set<ApplicationMode> to exclude non-wanted derived
	public static Set<ApplicationMode> regWidgetVisibility(String widgetId, ApplicationMode... am) {
		HashSet<ApplicationMode> set = new HashSet<>();
		if (am == null) {
			set.addAll(values);
		} else {
			Collections.addAll(set, am);
		}
		for (ApplicationMode m : values) {
			// add derived modes
			if (set.contains(m.getParent())) {
				set.add(m);
			}
		}
		widgetsVisibilityMap.put(widgetId, set);
		return set;
	}

	public boolean isWidgetCollapsible(String key) {
		return false;
	}

	public boolean isWidgetVisible(OsmandApplication app, String key) {
		if (app.getAppCustomization().areWidgetsCustomized()) {
			return app.getAppCustomization().isWidgetVisible(key, this);
		}
		Set<ApplicationMode> set = widgetsVisibilityMap.get(key);
		if (set == null) {
			return false;
		}
		return set.contains(this);
	}

	public static Set<ApplicationMode> regWidgetAvailability(String widgetId, ApplicationMode... am) {
		HashSet<ApplicationMode> set = new HashSet<>();
		if (am == null) {
			set.addAll(values);
		} else {
			Collections.addAll(set, am);
		}
		for (ApplicationMode m : values) {
			// add derived modes
			if (set.contains(m.getParent())) {
				set.add(m);
			}
		}
		widgetsAvailabilityMap.put(widgetId, set);
		return set;
	}

	public boolean isWidgetAvailable(OsmandApplication app, String key) {
		if (app.getAppCustomization().areWidgetsCustomized()) {
			return app.getAppCustomization().isWidgetAvailable(key, this);
		}
		Set<ApplicationMode> set = widgetsAvailabilityMap.get(key);
		if (set == null) {
			return true;
		}
		return set.contains(this);
	}

	public static List<ApplicationMode> getModesDerivedFrom(ApplicationMode am) {
		List<ApplicationMode> list = new ArrayList<ApplicationMode>();
		for (ApplicationMode a : values) {
			if (a == am || a.getParent() == am) {
				list.add(a);
			}
		}
		return list;
	}

	public ApplicationMode getParent() {
		return parent;
	}

	public int getSmallIconDark() {
		return smallIconDark;
	}

	public boolean hasFastSpeed() {
		return getDefaultSpeed() > 10;
	}

	public int getResourceBearingDay() {
		return bearingIconDay;
	}

	public int getResourceBearingNight() {
		//return bearingIconDay;
		return bearingIconNight;
	}

	public int getResourceHeadingDay() {
		return headingIconDay;
	}

	public int getResourceHeadingNight() {
		return headingIconNight;
	}

	public int getResourceLocationDay() {
		return locationIconDay;
	}

	public int getResourceLocationNight() {
		//return locationIconDay;
		return locationIconNight;
	}

	public int getResourceLocationDayLost() {
		return locationIconDayLost;
	}

	public int getResourceLocationNightLost() {
		return locationIconNightLost;
	}

	public String getStringKey() {
		return stringKey;
	}

	public int getMapIconId() {
		return mapIconId;
	}

	public int getStringResource() {
		return key;
	}

	public String toHumanString(Context ctx) {
		if (Algorithms.isEmpty(userProfileName)) {
			return ctx.getString(key);
		} else {
			return userProfileName;
		}

	}

	public String toHumanStringCtx(Context ctx) {
		if (Algorithms.isEmpty(userProfileName)) {
			return ctx.getString(key);
		} else {
			return userProfileName;
		}
	}

	public static ApplicationMode valueOfStringKey(String key, ApplicationMode def) {
		for (ApplicationMode p : values) {
			if (p.getStringKey().equals(key)) {
				return p;
			}
		}
		return def;
	}

	public float getDefaultSpeed() {
		return defaultSpeed;
	}

	public int getMinDistanceForTurn() {
		return minDistanceForTurn;
	}

	public int getArrivalDistance() {
		return arrivalDistance;
	}

	public int getOffRouteDistance() {
		return offRouteDistance;
	}

	public boolean isDerivedRoutingFrom(ApplicationMode mode) {
		return this == mode || getParent() == mode;
	}

	public int getMapIconsSetId() {
		return mapIconsSetId;
	}

	public String getUserProfileName() {
		return userProfileName;
	}

	@Expose private final int key;
	@Expose private final String stringKey;
	@Expose private String userProfileName = "";
	@Expose private int mapIconsSetId = 0;
	@Expose private ApplicationMode parent;
	@Expose private int mapIconId = R.drawable.map_world_globe_dark;
	@Expose private int smallIconDark = R.drawable.ic_world_globe_dark;
	@Expose private float defaultSpeed = 10f;
	@Expose private int minDistanceForTurn = 50;
	@Expose private int arrivalDistance = 90;
	@Expose private int offRouteDistance = 350;
	@Expose private int bearingIconDay = R.drawable.map_pedestrian_bearing;
	@Expose private int bearingIconNight = R.drawable.map_pedestrian_bearing_night;
	@Expose private int headingIconDay = R.drawable.map_pedestrian_location_view_angle;
	@Expose private int headingIconNight = R.drawable.map_pedestrian_location_view_angle_night;
	@Expose private int locationIconDay = R.drawable.map_pedestrian_location;
	@Expose private int locationIconNight = R.drawable.map_pedestrian_location_night;
	@Expose private int locationIconDayLost = R.drawable.map_pedestrian_location_lost;
	@Expose private int locationIconNightLost = R.drawable.map_pedestrian_location_lost_night;
	private static StateChangedListener<String> listener;
	private static OsmAndAppCustomization.OsmAndAppCustomizationListener customizationListener;


	public void saveCustomProfileToSettings(OsmandSettings settings){
		List<ApplicationMode> customModes = new ArrayList<>();
		for (ApplicationMode mode : values) {
			if (mode.parent != null) {
				customModes.add(mode);
			}
		}
		Gson gson = new GsonBuilder().excludeFieldsWithoutExposeAnnotation().create();
		String profiles = gson.toJson(customModes);
		settings.CUSTOM_APP_PROFILES.set(profiles);
	}



	public static boolean initCustomProfiles(OsmandSettings settings){
		Gson gson = new GsonBuilder().excludeFieldsWithoutExposeAnnotation().create();
		Type t = new TypeToken<ArrayList<ApplicationMode>>() {}.getType();
		List<ApplicationMode> customProfiles = gson.fromJson(settings.CUSTOM_APP_PROFILES.get(), t);

		if (!Algorithms.isEmpty(customProfiles)) {
			for (ApplicationMode m : customProfiles) {
				if (!values.contains(m)) {
					values.add(m);
					if (m.getParent() != null) {
						LOG.debug("parent: " + m.getParent().getStringKey());
					} else {
						LOG.debug("parent: propal!!!!!111 " );
					}

				}
			}
			return true;
		}
		return false;
	}



}
!@#$%
20190530_081623,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_c06248
package net.osmand.plus;

import android.content.Context;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.annotations.Expose;
import com.google.gson.reflect.TypeToken;
import java.lang.reflect.Type;
import java.util.HashMap;
import net.osmand.PlatformUtil;
import net.osmand.StateChangedListener;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import net.osmand.plus.profiles.RoutingProfile;
import net.osmand.router.GeneralRouter;
import net.osmand.util.Algorithms;
import net.sf.junidecode.App;
import org.apache.commons.logging.Log;


public class ApplicationMode {

	private static final Log LOG = PlatformUtil.getLog(ApplicationMode.class);
	private static Map<String, Set<ApplicationMode>> widgetsVisibilityMap = new LinkedHashMap<>();
	private static Map<String, Set<ApplicationMode>> widgetsAvailabilityMap = new LinkedHashMap<>();
	private static List<ApplicationMode> defaultValues = new ArrayList<>();
	private static List<ApplicationMode> values = new ArrayList<>();
	private static List<ApplicationMode> cachedFilteredValues = new ArrayList<>();
	/*
	 * DEFAULT("Browse map"), CAR("Car"), BICYCLE("Bicycle"), PEDESTRIAN("Pedestrian"); NAUTICAL("boat"); PUBLIC_TRANSPORT("Public transport")
	 */
	public static final ApplicationMode DEFAULT = create(R.string.app_mode_default, "default").speed(1.5f, 5).arrivalDistance(90).defLocation().
			icon(R.drawable.map_world_globe_dark, R.drawable.ic_world_globe_dark).reg();

	public static final ApplicationMode CAR = create(R.string.app_mode_car, "car").speed(15.3f, 35).carLocation().
			icon(R.drawable.map_action_car_dark, R.drawable.ic_action_car_dark).reg();

	public static final ApplicationMode BICYCLE = create(R.string.app_mode_bicycle, "bicycle").speed(5.5f, 15).arrivalDistance(60).offRouteDistance(50).bicycleLocation().
			icon(R.drawable.map_action_bicycle_dark, R.drawable.ic_action_bicycle_dark).reg();

	public static final ApplicationMode PEDESTRIAN = create(R.string.app_mode_pedestrian, "pedestrian").speed(1.5f, 5).arrivalDistance(45).offRouteDistance(20).
			icon(R.drawable.map_action_pedestrian_dark, R.drawable.ic_action_pedestrian_dark).reg();

	public static final ApplicationMode PUBLIC_TRANSPORT = create(R.string.app_mode_public_transport, "public_transport").
			icon(R.drawable.map_action_bus_dark, R.drawable.ic_action_bus_dark).reg();

	public static final ApplicationMode BOAT = create(R.string.app_mode_boat, "boat").speed(5.5f, 20).nauticalLocation().
			icon(R.drawable.map_action_sail_boat_dark, R.drawable.ic_action_sail_boat_dark).reg();

	public static final ApplicationMode AIRCRAFT = create(R.string.app_mode_aircraft, "aircraft").speed(40f, 100).carLocation().
			icon(R.drawable.map_action_aircraft, R.drawable.ic_action_aircraft).reg();


//---------------------------------------------------------------------------------------------------------------
//	public static final ApplicationMode HIKING = create(R.string.app_mode_hiking, "hiking").speed(1.5f, 5).parent(PEDESTRIAN).
//			icon(R.drawable.map_action_trekking_dark, R.drawable.ic_action_trekking_dark).reg();
//
//	public static final ApplicationMode MOTORCYCLE = create(R.string.app_mode_motorcycle, "motorcycle").speed(15.3f, 40).
//			carLocation().parent(CAR).
//			icon(R.drawable.map_action_motorcycle_dark, R.drawable.ic_action_motorcycle_dark).reg();
//
//	public static final ApplicationMode TRUCK = create(R.string.app_mode_truck, "truck").speed(15.3f, 40).
//			carLocation().parent(CAR).
//			icon(R.drawable.map_action_truck_dark, R.drawable.ic_action_truck_dark).reg();
//
//	public static final ApplicationMode TRAIN = create(R.string.app_mode_train, "train").speed(25f, 40).
//			carLocation().icon(R.drawable.map_action_train, R.drawable.ic_action_train).reg();
	String profile = "profile: ";
	static {
		ApplicationMode[] exceptDefault = new ApplicationMode[]{CAR, PEDESTRIAN, BICYCLE, BOAT, PUBLIC_TRANSPORT};
		ApplicationMode[] exceptPedestrianAndDefault = new ApplicationMode[]{CAR, BICYCLE, BOAT, PUBLIC_TRANSPORT};
		ApplicationMode[] exceptAirBoatDefault = new ApplicationMode[]{CAR, BICYCLE, PEDESTRIAN};
		ApplicationMode[] pedestrian = new ApplicationMode[]{PEDESTRIAN};
		ApplicationMode[] pedestrianBicycle = new ApplicationMode[]{PEDESTRIAN, BICYCLE};

		ApplicationMode[] all = null;
		ApplicationMode[] none = new ApplicationMode[]{};

		// left
		regWidgetVisibility("next_turn", exceptPedestrianAndDefault);
		regWidgetVisibility("next_turn_small", pedestrian);
		regWidgetVisibility("next_next_turn", exceptPedestrianAndDefault);
		regWidgetAvailability("next_turn", exceptDefault);
		regWidgetAvailability("next_turn_small", exceptDefault);
		regWidgetAvailability("next_next_turn", exceptDefault);

		// right
		regWidgetVisibility("intermediate_distance", all);
		regWidgetVisibility("distance", all);
		regWidgetVisibility("time", all);
		regWidgetVisibility("intermediate_time", all);
		regWidgetVisibility("speed", exceptPedestrianAndDefault);
		regWidgetVisibility("max_speed", CAR);
		regWidgetVisibility("altitude", pedestrianBicycle);
		regWidgetVisibility("gps_info", none);
		regWidgetAvailability("intermediate_distance", all);
		regWidgetAvailability("distance", all);
		regWidgetAvailability("time", all);
		regWidgetAvailability("intermediate_time", all);
		regWidgetAvailability("map_marker_1st", none);
		regWidgetAvailability("map_marker_2nd", none);

		// top
		regWidgetVisibility("config", none);
		regWidgetVisibility("layers", none);
		regWidgetVisibility("compass", none);
		regWidgetVisibility("street_name", exceptAirBoatDefault);
		regWidgetVisibility("back_to_location", all);
		regWidgetVisibility("monitoring_services", none);
		regWidgetVisibility("bgService", none);
	}



	public static class ApplicationModeBuilder {
		private ApplicationMode applicationMode;

		public ApplicationMode reg() {
			values.add(applicationMode);
			defaultValues.add(applicationMode);
			return applicationMode;
		}

		public ApplicationMode customReg() {
			values.add(applicationMode);
			return applicationMode;
		}

		public ApplicationModeBuilder icon(int mapIcon, int smallIconDark) {
			applicationMode.mapIconId = mapIcon;
			applicationMode.smallIconDark = smallIconDark;
			return this;
		}


		public ApplicationModeBuilder parent(ApplicationMode parent) {
			applicationMode.parent = parent;
			return this;
		}

		/**
		 * @param type - id of set of icons for different navigation styles:
		 *               1 - car, 2 - bicicle, 3 - nautical, any other - default
		 */
		public ApplicationModeBuilder setLocationAndBearingIcons(int type) {
			applicationMode.mapIconsSetId = type;
			switch (type) {
				case 1:
					return this.carLocation();
				case 2:
					return this.bicycleLocation();
				case 3:
					return this.nauticalLocation();
				default:
					return this.defLocation();
			}
		}

		public ApplicationModeBuilder carLocation() {
			applicationMode.bearingIconDay = R.drawable.map_car_bearing;
			applicationMode.bearingIconNight = R.drawable.map_car_bearing_night;
			applicationMode.headingIconDay = R.drawable.map_car_location_view_angle;
			applicationMode.headingIconNight = R.drawable.map_car_location_view_angle_night;
			applicationMode.locationIconDay = R.drawable.map_car_location;
			applicationMode.locationIconNight = R.drawable.map_car_location_night;
			applicationMode.locationIconDayLost = R.drawable.map_car_location_lost;
			applicationMode.locationIconNightLost = R.drawable.map_car_location_lost_night;
			return this;
		}

		public ApplicationModeBuilder bicycleLocation() {
			applicationMode.bearingIconDay = R.drawable.map_bicycle_bearing;
			applicationMode.bearingIconNight = R.drawable.map_bicycle_bearing_night;
			applicationMode.headingIconDay = R.drawable.map_bicycle_location_view_angle;
			applicationMode.headingIconNight = R.drawable.map_bicycle_location_view_angle_night;
			applicationMode.locationIconDay = R.drawable.map_bicycle_location;
			applicationMode.locationIconNight = R.drawable.map_bicycle_location_night;
			applicationMode.locationIconDayLost = R.drawable.map_bicycle_location_lost;
			applicationMode.locationIconNightLost = R.drawable.map_bicycle_location_lost_night;
			return this;
		}

		public ApplicationModeBuilder defLocation() {
			applicationMode.bearingIconDay = R.drawable.map_pedestrian_bearing;
			applicationMode.bearingIconNight = R.drawable.map_pedestrian_bearing_night;
			applicationMode.headingIconDay = R.drawable.map_default_location_view_angle;
			applicationMode.headingIconNight = R.drawable.map_default_location_view_angle_night;
			applicationMode.locationIconDay = R.drawable.map_pedestrian_location;
			applicationMode.locationIconNight = R.drawable.map_pedestrian_location_night;
			applicationMode.locationIconDayLost = R.drawable.map_pedestrian_location_lost;
			applicationMode.locationIconNightLost = R.drawable.map_pedestrian_location_lost_night;
			return this;
		}

		public ApplicationModeBuilder nauticalLocation() {
			applicationMode.bearingIconDay = R.drawable.map_nautical_bearing;
			applicationMode.bearingIconNight = R.drawable.map_nautical_bearing_night;
			applicationMode.headingIconDay = R.drawable.map_nautical_location_view_angle;
			applicationMode.headingIconNight = R.drawable.map_nautical_location_view_angle_night;
			applicationMode.locationIconDay = R.drawable.map_nautical_location;
			applicationMode.locationIconNight = R.drawable.map_nautical_location_night;
			return this;
		}

		public ApplicationModeBuilder speed(float defSpeed, int distForTurn) {
			applicationMode.defaultSpeed = defSpeed;
			applicationMode.minDistanceForTurn = distForTurn;
			return this;
		}

		public ApplicationModeBuilder arrivalDistance(int arrivalDistance) {
			applicationMode.arrivalDistance = arrivalDistance;
			return this;
		}

		public ApplicationModeBuilder offRouteDistance(int offRouteDistance) {
			applicationMode.offRouteDistance = offRouteDistance;
			return this;
		}

		public ApplicationModeBuilder userProfileTitle(String userProfileTitle) {
			applicationMode.userProfileName = userProfileTitle;
			return this;
		}

		public ApplicationModeBuilder assignRoutingProfile(GeneralRouter.GeneralRouterProfile profile) {
			applicationMode.assignedRoutingProfile = profile;
			return this;
		}
	}



	private static ApplicationModeBuilder create(int key, String stringKey) {
		ApplicationModeBuilder builder = new ApplicationModeBuilder();
		builder.applicationMode = new ApplicationMode(key, stringKey);
		return builder;
	}

	public static ApplicationModeBuilder createCustomMode(String userProfileTitle, String stringKey) {
		return create(-1, stringKey).userProfileTitle(userProfileTitle);
	}

	private ApplicationMode(int key, String stringKey) {
		this.key = key;
		this.stringKey = stringKey;
	}

	public static List<ApplicationMode> values(OsmandApplication app) {
		if (customizationListener == null) {
			customizationListener = new OsmAndAppCustomization.OsmAndAppCustomizationListener() {
				@Override
				public void onOsmAndSettingsCustomized() {
					cachedFilteredValues = new ArrayList<>();
				}
			};
			app.getAppCustomization().addListener(customizationListener);
		}
		if (cachedFilteredValues.isEmpty()) {
			OsmandSettings settings = app.getSettings();
			if (listener == null) {
				listener = new StateChangedListener<String>() {
					@Override
					public void stateChanged(String change) {
						cachedFilteredValues = new ArrayList<>();
					}
				};
				settings.AVAILABLE_APP_MODES.addListener(listener);
			}
			String available = settings.AVAILABLE_APP_MODES.get();
			cachedFilteredValues = new ArrayList<>();
			for (ApplicationMode v : values) {
				if (available.indexOf(v.getStringKey() + ",") != -1 || v == DEFAULT) {
					cachedFilteredValues.add(v);
				}
			}
		}
		return cachedFilteredValues;
	}

	public static List<ApplicationMode> allPossibleValues() {
		return new ArrayList<>(values);
	}

	public static List<ApplicationMode> getDefaultValues() {
		return new ArrayList<>(defaultValues);
	}

	// returns modifiable ! Set<ApplicationMode> to exclude non-wanted derived
	public static Set<ApplicationMode> regWidgetVisibility(String widgetId, ApplicationMode... am) {
		HashSet<ApplicationMode> set = new HashSet<>();
		if (am == null) {
			set.addAll(values);
		} else {
			Collections.addAll(set, am);
		}
		for (ApplicationMode m : values) {
			// add derived modes
			if (set.contains(m.getParent())) {
				set.add(m);
			}
		}
		widgetsVisibilityMap.put(widgetId, set);
		return set;
	}

	public boolean isWidgetCollapsible(String key) {
		return false;
	}

	public boolean isWidgetVisible(OsmandApplication app, String key) {
		if (app.getAppCustomization().areWidgetsCustomized()) {
			return app.getAppCustomization().isWidgetVisible(key, this);
		}
		Set<ApplicationMode> set = widgetsVisibilityMap.get(key);
		if (set == null) {
			return false;
		}
		return set.contains(this);
	}

	public static Set<ApplicationMode> regWidgetAvailability(String widgetId, ApplicationMode... am) {
		HashSet<ApplicationMode> set = new HashSet<>();
		if (am == null) {
			set.addAll(values);
		} else {
			Collections.addAll(set, am);
		}
		for (ApplicationMode m : values) {
			// add derived modes
			if (set.contains(m.getParent())) {
				set.add(m);
			}
		}
		widgetsAvailabilityMap.put(widgetId, set);
		return set;
	}

	public boolean isWidgetAvailable(OsmandApplication app, String key) {
		if (app.getAppCustomization().areWidgetsCustomized()) {
			return app.getAppCustomization().isWidgetAvailable(key, this);
		}
		Set<ApplicationMode> set = widgetsAvailabilityMap.get(key);
		if (set == null) {
			return true;
		}
		return set.contains(this);
	}

	public static List<ApplicationMode> getModesDerivedFrom(ApplicationMode am) {
		List<ApplicationMode> list = new ArrayList<ApplicationMode>();
		for (ApplicationMode a : values) {
			if (a == am || a.getParent() == am) {
				list.add(a);
			}
		}
		return list;
	}

	public ApplicationMode getParent() {
		return parent;
	}

	public int getSmallIconDark() {
		return smallIconDark;
	}

	public boolean hasFastSpeed() {
		return getDefaultSpeed() > 10;
	}

	public int getResourceBearingDay() {
		return bearingIconDay;
	}

	public int getResourceBearingNight() {
		//return bearingIconDay;
		return bearingIconNight;
	}

	public int getResourceHeadingDay() {
		return headingIconDay;
	}

	public int getResourceHeadingNight() {
		return headingIconNight;
	}

	public int getResourceLocationDay() {
		return locationIconDay;
	}

	public int getResourceLocationNight() {
		//return locationIconDay;
		return locationIconNight;
	}

	public int getResourceLocationDayLost() {
		return locationIconDayLost;
	}

	public int getResourceLocationNightLost() {
		return locationIconNightLost;
	}

	public String getStringKey() {
		return stringKey;
	}

	public int getMapIconId() {
		return mapIconId;
	}

	public int getStringResource() {
		return key;
	}

	public String toHumanString(Context ctx) {
		if (Algorithms.isEmpty(userProfileName)) {
			return ctx.getString(key);
		} else {
			return userProfileName;
		}

	}

	public String toHumanStringCtx(Context ctx) {
		if (Algorithms.isEmpty(userProfileName)) {
			return ctx.getString(key);
		} else {
			return userProfileName;
		}
	}

	public static ApplicationMode valueOfStringKey(String key, ApplicationMode def) {
		for (ApplicationMode p : values) {
			if (p.getStringKey().equals(key)) {
				return p;
			}
		}
		return def;
	}

	public float getDefaultSpeed() {
		return defaultSpeed;
	}

	public int getMinDistanceForTurn() {
		return minDistanceForTurn;
	}

	public int getArrivalDistance() {
		return arrivalDistance;
	}

	public int getOffRouteDistance() {
		return offRouteDistance;
	}

	public boolean isDerivedRoutingFrom(ApplicationMode mode) {
		return this == mode || getParent() == mode;
	}

	public GeneralRouter.GeneralRouterProfile getAssignedRouteingProfile() {
		return assignedRoutingProfile;
	}

	public int getMapIconsSetId() {
		return mapIconsSetId;
	}

	public String getUserProfileName() {
		return userProfileName;
	}

	@Expose private final int key;
	@Expose private final String stringKey;
	@Expose private String userProfileName = "";
	@Expose private int mapIconsSetId = 0;
	@Expose private ApplicationMode parent;
	@Expose private int mapIconId = R.drawable.map_world_globe_dark;
	@Expose private int smallIconDark = R.drawable.ic_world_globe_dark;
	@Expose private float defaultSpeed = 10f;
	@Expose private int minDistanceForTurn = 50;
	@Expose private int arrivalDistance = 90;
	@Expose private int offRouteDistance = 350;
	@Expose private int bearingIconDay = R.drawable.map_pedestrian_bearing;
	@Expose private int bearingIconNight = R.drawable.map_pedestrian_bearing_night;
	@Expose private int headingIconDay = R.drawable.map_pedestrian_location_view_angle;
	@Expose private int headingIconNight = R.drawable.map_pedestrian_location_view_angle_night;
	@Expose private int locationIconDay = R.drawable.map_pedestrian_location;
	@Expose private int locationIconNight = R.drawable.map_pedestrian_location_night;
	@Expose private int locationIconDayLost = R.drawable.map_pedestrian_location_lost;
	@Expose private int locationIconNightLost = R.drawable.map_pedestrian_location_lost_night;
	@Expose private GeneralRouter.GeneralRouterProfile assignedRoutingProfile = null;
	private static StateChangedListener<String> listener;
	private static OsmAndAppCustomization.OsmAndAppCustomizationListener customizationListener;


	public void saveCustomProfileToSettings(OsmandSettings settings){
		List<ApplicationMode> customModes = new ArrayList<>();
		for (ApplicationMode mode : values) {
			if (mode.parent != null) {
				customModes.add(mode);
			}
		}
		Gson gson = new GsonBuilder().excludeFieldsWithoutExposeAnnotation().create();
		String profiles = gson.toJson(customModes);
		settings.CUSTOM_APP_PROFILES.set(profiles);
	}



	public static boolean initCustomProfiles(OsmandSettings settings){
		Gson gson = new GsonBuilder().excludeFieldsWithoutExposeAnnotation().create();
		Type t = new TypeToken<ArrayList<ApplicationMode>>() {}.getType();
		List<ApplicationMode> customProfiles = gson.fromJson(settings.CUSTOM_APP_PROFILES.get(), t);

		if (!Algorithms.isEmpty(customProfiles)) {
			for (ApplicationMode m : customProfiles) {
				if (!values.contains(m)) {
					values.add(m);
					if (m.getParent() != null) {
						LOG.debug("parent: " + m.getParent().getStringKey());
					} else {
						LOG.debug("parent: propal!!!!!111 " );
					}

				}
			}
			return true;
		}
		return false;
	}



}
!@#$%
20190530_081828,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_b09852
package net.osmand.plus.profiles;

import static net.osmand.plus.activities.SettingsNavigationActivity.INTENT_SKIP_DIALOG;
import static net.osmand.plus.profiles.SelectProfileBottomSheetDialogFragment.DIALOG_TYPE;
import static net.osmand.plus.profiles.SelectProfileBottomSheetDialogFragment.SELECTED_KEY;
import static net.osmand.plus.profiles.SelectProfileBottomSheetDialogFragment.TYPE_APP_PROFILE;
import static net.osmand.plus.profiles.SelectProfileBottomSheetDialogFragment.TYPE_ICON;
import static net.osmand.plus.profiles.SelectProfileBottomSheetDialogFragment.TYPE_NAV_PROFILE;
import static net.osmand.plus.profiles.SettingsProfileFragment.IS_NEW_PROFILE;
import static net.osmand.plus.profiles.SettingsProfileFragment.IS_USER_PROFILE;
import static net.osmand.plus.profiles.SettingsProfileFragment.PROFILE_STRING_KEY;

import android.app.Activity;
import android.content.DialogInterface;
import android.content.DialogInterface.OnDismissListener;
import android.content.Intent;
import android.graphics.Rect;
import android.graphics.drawable.GradientDrawable;
import android.os.Bundle;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.support.v4.content.ContextCompat;
import android.support.v7.app.ActionBar;
import android.support.v7.app.AlertDialog;
import android.support.v7.app.AlertDialog.Builder;
import android.text.Editable;
import android.text.TextWatcher;
import android.view.LayoutInflater;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;

import android.view.ViewTreeObserver.OnGlobalLayoutListener;
import android.widget.Button;
import android.widget.FrameLayout;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.ScrollView;
import android.widget.TextView;
import android.widget.Toast;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import net.osmand.PlatformUtil;
import net.osmand.plus.ApplicationMode;
import net.osmand.plus.OsmandApplication;
import net.osmand.plus.R;
import net.osmand.plus.activities.MapActivity;
import net.osmand.plus.activities.OsmandActionBarActivity;
import net.osmand.plus.activities.SettingsNavigationActivity;
import net.osmand.plus.base.BaseOsmAndFragment;
import net.osmand.plus.profiles.SelectProfileBottomSheetDialogFragment.SelectProfileListener;
import net.osmand.plus.routing.RouteProvider.RouteService;
import net.osmand.plus.widgets.OsmandTextFieldBoxes;
import net.osmand.router.GeneralRouter;
import net.osmand.util.Algorithms;
import org.apache.commons.logging.Log;
import studio.carbonylgroup.textfieldboxes.ExtendedEditText;

public class EditProfileFragment extends BaseOsmAndFragment {

	private static final Log LOG = PlatformUtil.getLog(EditProfileFragment.class);

	public static final String OPEN_CONFIG_ON_MAP = "openConfigOnMap";
	public static final String MAP_CONFIG = "openMapConfigMenu";
	public static final String NAV_CONFIG = "openNavConfigMenu";
	public static final String SCREEN_CONFIG = "openScreenConfigMenu";
	public static final String SELECTED_ITEM = "editedProfile";
	public static final String SELECTED_ICON = "selectedIcon";

	OsmandApplication app;

	ApplicationMode mode = null;
	ApplicationProfileObject profile = null;
	List<RoutingProfileDataObject> routingProfileDataObjects;
	RoutingProfileDataObject selectedRoutingProfileDataObject = null;

	private boolean isNew = false;
	private boolean isUserProfile = false;
	private boolean isDataChanged = false;
	private boolean isCancelAllowed = true;
	private boolean isNightMode;

	private SelectProfileListener navTypeListener = null;
	private SelectProfileListener iconIdListener = null;
	private SelectProfileListener baseTypeListener = null;

	private ImageView profileIcon;
	private LinearLayout profileIconBtn;
	private ExtendedEditText profileNameEt;
	private OsmandTextFieldBoxes profileNameTextBox;
	private ExtendedEditText navTypeEt;
	private OsmandTextFieldBoxes navTypeTextBox;
	private FrameLayout selectNavTypeBtn;
	private Button cancelBtn;
	private Button saveButton;
	private View mapConfigBtn;
	private View screenConfigBtn;
	private View navConfigBtn;
	private LinearLayout buttonsLayout;
	private FrameLayout clickBlockLayout;
	private LinearLayout typeSelectionBtn;
	private ImageView baseModeIcon;
	private TextView baseModeTitle;
	private ScrollView scrollContainer;
	private LinearLayout buttonsLayoutSV;
	private Button cancelBtnSV;
	private Button saveButtonSV;

	@Override
	public void onCreate(@Nullable Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		app = getMyApplication();
		if (getArguments() != null) {
			String modeName = getArguments().getString(PROFILE_STRING_KEY, "car");
			isNew = getArguments().getBoolean(IS_NEW_PROFILE, false);
			isUserProfile = getArguments().getBoolean(IS_USER_PROFILE, false);
			mode = ApplicationMode.valueOfStringKey(modeName, ApplicationMode.DEFAULT);
			profile = new ApplicationProfileObject(mode, isNew, isUserProfile);
		}
		isNightMode = !app.getSettings().isLightContent();
		routingProfileDataObjects = getRoutingProfiles(app);
	}

	@Nullable
	@Override
	public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container,
		@Nullable Bundle savedInstanceState) {

		final View view = inflater.inflate(R.layout.fragment_selected_profile, container, false);

		profileIcon = view.findViewById(R.id.select_icon_btn_img);
		profileIconBtn = view.findViewById(R.id.profile_icon_layout);
		profileNameEt = view.findViewById(R.id.profile_name_et);
		profileNameTextBox = view.findViewById(R.id.profile_name_otfb);
		navTypeEt = view.findViewById(R.id.navigation_type_et);
		navTypeTextBox = view.findViewById(R.id.navigation_type_otfb);
		selectNavTypeBtn = view.findViewById(R.id.select_nav_type_btn);
		cancelBtn = view.findViewById(R.id.cancel_button);
		saveButton = view.findViewById(R.id.save_profile_btn);
		mapConfigBtn = view.findViewById(R.id.map_config_btn);
		screenConfigBtn = view.findViewById(R.id.screen_config_btn);
		navConfigBtn = view.findViewById(R.id.nav_settings_btn);
		buttonsLayout = view.findViewById(R.id.buttons_layout);
		clickBlockLayout = view.findViewById(R.id.click_block_layout);
		typeSelectionBtn = view.findViewById(R.id.type_selection_button);
		baseModeIcon = view.findViewById(R.id.mode_icon);
		baseModeTitle = view.findViewById(R.id.mode_title);
		scrollContainer = view.findViewById(R.id.scroll_view_container);
		buttonsLayoutSV = view.findViewById(R.id.buttons_layout_sv);
		cancelBtnSV = view.findViewById(R.id.cancel_button_sv);
		saveButtonSV = view.findViewById(R.id.save_profile_btn_sv);

		profileNameEt.setFocusable(true);
		profileNameEt.setSelectAllOnFocus(true);
		profileIconBtn.setBackgroundResource(R.drawable.rounded_background_3dp);
		GradientDrawable selectIconBtnBackground = (GradientDrawable) profileIconBtn
			.getBackground();

		if (isNightMode) {
			profileNameTextBox
				.setPrimaryColor(ContextCompat.getColor(app, R.color.color_dialog_buttons_dark));
			navTypeTextBox
				.setPrimaryColor(ContextCompat.getColor(app, R.color.color_dialog_buttons_dark));
			selectIconBtnBackground
				.setColor(app.getResources().getColor(R.color.text_field_box_dark));
		} else {
			selectIconBtnBackground
				.setColor(app.getResources().getColor(R.color.text_field_box_light));
		}

		String title = "New Profile";

		int startIconId = R.drawable.map_world_globe_dark;

		if (isNew) {
			isDataChanged = true;
			startIconId = profile.parent.getSmallIconDark();
			profile.iconId = startIconId;
		} else if (isUserProfile) {
			title = profile.userProfileTitle;
			profileNameEt.setText(title);
			startIconId = profile.iconId;
			isDataChanged = false;
		} else if (profile.key != -1) {
			title = getResources().getString(profile.key);
			profileNameEt.setText(profile.key);
			startIconId = profile.iconId;
			clickBlockLayout.setClickable(true);
		}
		profile.userProfileTitle = title;

		if (profile.parent != null) {
			setupBaseProfileView(profile.parent.getStringKey());
		} else if (profile.key != -1) {
			baseModeTitle.setText(profile.key);
			baseModeIcon.setImageDrawable(
				app.getUIUtilities().getIcon(profile.iconId, R.color.icon_color));
		}
		typeSelectionBtn.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
				if (isUserProfile || isNew) {
					final SelectProfileBottomSheetDialogFragment dialog = new SelectProfileBottomSheetDialogFragment();
					Bundle bundle = new Bundle();
					if (profile.parent != null) {
						bundle.putString(SELECTED_KEY, profile.parent.getStringKey());
					}
					bundle.putString(DIALOG_TYPE, TYPE_APP_PROFILE);
					dialog.setArguments(bundle);
					if (getActivity() != null) {
						getActivity().getSupportFragmentManager().beginTransaction()
							.add(dialog, "select_base_type").commitAllowingStateLoss();
					}
				}
			}
		});

		if (!Algorithms.isEmpty(mode.getRoutingProfile())) {
			for (RoutingProfileDataObject r : routingProfileDataObjects) {
				if (mode.getRoutingProfile().equals(r.getStringKey())) {
					profile.routingProfileDataObject = r;
					r.setSelected(true);
					navTypeEt.setText(r.getName());
					navTypeEt.clearFocus();
				}
			}
		} else {
			for (RoutingProfileDataObject rp : routingProfileDataObjects) {
				if (profile.stringKey.equals(rp.getStringKey())) {
					navTypeEt.setText(
						RoutingProfilesResources.valueOf(rp.getStringKey().toUpperCase())
							.getStringRes());
				}
			}
			navTypeEt.clearFocus();
		}
		profileNameEt.clearFocus();

		if (getActivity() != null
			&& ((EditProfileActivity) getActivity()).getSupportActionBar() != null) {
			((EditProfileActivity) getActivity()).getSupportActionBar().setTitle(title);
			((EditProfileActivity) getActivity()).getSupportActionBar().setElevation(5.0f);
		}

		int iconColor;
		if (!isUserProfile) {
			iconColor = R.color.icon_color;
		} else {
			iconColor = isNightMode
				? R.color.active_buttons_and_links_dark
				: R.color.active_buttons_and_links_light;
		}

		profileIcon.setImageDrawable(app.getUIUtilities().getIcon(startIconId, iconColor));

		profileNameEt.addTextChangedListener(new TextWatcher() {
			@Override
			public void beforeTextChanged(CharSequence s, int start, int count, int after) {
			}

			@Override
			public void onTextChanged(CharSequence s, int start, int before, int count) {
			}

			@Override
			public void afterTextChanged(Editable s) {
				if (getActivity() instanceof OsmandActionBarActivity) {
					ActionBar actionBar = ((OsmandActionBarActivity) getActivity())
						.getSupportActionBar();
					if (actionBar != null) {
						actionBar.setTitle(s.toString());
						profile.userProfileTitle = s.toString();
						isCancelAllowed = false;
					}
				}
			}
		});

		selectNavTypeBtn.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				if (isNew || isUserProfile) {
					final SelectProfileBottomSheetDialogFragment fragment = new SelectProfileBottomSheetDialogFragment();
					Bundle bundle = new Bundle();
					if (profile.routingProfileDataObject != null) {
						bundle.putString(SELECTED_KEY,
							profile.routingProfileDataObject.getStringKey());
					}
					bundle.putString(DIALOG_TYPE, TYPE_NAV_PROFILE);
					fragment.setArguments(bundle);
					if (getActivity() != null) {
						getActivity().getSupportFragmentManager().beginTransaction()
							.add(fragment, "select_nav_type").commitAllowingStateLoss();
					}
					navTypeEt.setCursorVisible(false);
					navTypeEt.setTextIsSelectable(false);
					navTypeEt.clearFocus();
					navTypeEt.requestFocus(ExtendedEditText.FOCUS_UP);
				}
			}
		});

		profileIconBtn.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
				final SelectProfileBottomSheetDialogFragment iconSelectDialog = new SelectProfileBottomSheetDialogFragment();
				Bundle bundle = new Bundle();
				bundle.putString(DIALOG_TYPE, TYPE_ICON);
				bundle.putInt(SELECTED_ICON, profile.iconId);
				iconSelectDialog.setArguments(bundle);
				if (getActivity() != null) {
					getActivity().getSupportFragmentManager().beginTransaction()
						.add(iconSelectDialog, "select_icon")
						.commitAllowingStateLoss();
				}
			}
		});

		mapConfigBtn.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
				if (isDataChanged) {
					needSaveDialog();
				} else if (getSettings() != null) {
					activateMode(mode);
					getSettings().APPLICATION_MODE.set(mode);
					Intent i = new Intent(getActivity(), MapActivity.class);
					i.putExtra(OPEN_CONFIG_ON_MAP, MAP_CONFIG);
					i.putExtra(SELECTED_ITEM, profile.stringKey);
					startActivity(i);
				}
			}
		});

		screenConfigBtn.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
				if (isDataChanged) {
					needSaveDialog();
				} else if (getSettings() != null) {
					activateMode(mode);
					getSettings().APPLICATION_MODE.set(mode);
					Intent i = new Intent(getActivity(), MapActivity.class);
					i.putExtra(OPEN_CONFIG_ON_MAP, SCREEN_CONFIG);
					i.putExtra(SELECTED_ITEM, profile.stringKey);
					startActivity(i);
				}
			}
		});

		navConfigBtn.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
				if (isDataChanged) {
					needSaveDialog();
				} else if (getSettings() != null) {
					activateMode(mode);
					getSettings().APPLICATION_MODE.set(mode);
					Intent i = new Intent(getActivity(), SettingsNavigationActivity.class);
					i.putExtra(INTENT_SKIP_DIALOG, true);
					i.putExtra(OPEN_CONFIG_ON_MAP, NAV_CONFIG);
					i.putExtra(SELECTED_ITEM, profile.stringKey);
					startActivity(i);
				}
			}
		});

		cancelBtn.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
				if (getActivity() != null) {
					getActivity().onBackPressed();
				}
			}
		});

		cancelBtnSV.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
				if (getActivity() != null) {
					getActivity().onBackPressed();
				}
			}
		});

		saveButton.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
				if (saveNewProfile()) {
					activateMode(mode);
					getActivity().onBackPressed();
				}
			}
		});

		saveButtonSV.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
				if (saveNewProfile()) {
					activateMode(mode);
					getActivity().onBackPressed();
				}
			}
		});

		view.getViewTreeObserver().addOnGlobalLayoutListener(new OnGlobalLayoutListener() {
			@Override
			public void onGlobalLayout() {
				int marginShow = 66;
				int marginHide = 0;

				float d = getResources().getDisplayMetrics().density;
				Rect r = new Rect();
				view.getWindowVisibleDisplayFrame(r);
				int screenHeight = view.getRootView().getHeight();
				int keypadHeight = screenHeight - r.bottom;
				if (keypadHeight > screenHeight * 0.15) {
					buttonsLayout.setVisibility(View.GONE);
					buttonsLayoutSV.setVisibility(View.VISIBLE);
					setMargins(scrollContainer, 0, 0, 0, (int) (marginHide * d));
				} else {
					buttonsLayoutSV.setVisibility(View.GONE);
					buttonsLayout.setVisibility(View.VISIBLE);
					setMargins(scrollContainer, 0, 0, 0, (int) (marginShow * d));
				}
			}
		});
		return view;
	}

	@Override
	public void onResume() {
		getBaseProfileListener();
		getNavProfileListener();
		getIconListener();
		super.onResume();
	}

	boolean onBackPressedAllowed() {
		return isCancelAllowed;
	}

	SelectProfileListener getIconListener() {
		if (iconIdListener == null) {
			iconIdListener = new SelectProfileListener() {
				@Override
				public void onSelectedType(int pos) {
					isDataChanged = true;
					profile.iconId = pos;
					profileIcon.setImageDrawable(app.getUIUtilities().getIcon(pos,
						isNightMode ? R.color.active_buttons_and_links_dark
							: R.color.active_buttons_and_links_light));
				}
			};
		}
		return iconIdListener;
	}

	SelectProfileListener getBaseProfileListener() {
		if (baseTypeListener == null) {
			baseTypeListener = new SelectProfileListener() {
				@Override
				public void onSelectedType(int pos) {
					String key = SettingsProfileFragment.getBaseProfiles(getMyApplication())
						.get(pos).getStringKey();
					setupBaseProfileView(key);
					profile.parent = ApplicationMode.valueOfStringKey(key, ApplicationMode.DEFAULT);
				}
			};
		}
		return baseTypeListener;
	}

	SelectProfileListener getNavProfileListener() {
		if (navTypeListener == null) {
			navTypeListener = new SelectProfileListener() {
				@Override
				public void onSelectedType(int pos) {
					updateRoutingProfile(pos);
				}
			};
		}
		return navTypeListener;
	}

	@Override
	public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
		super.onViewCreated(view, savedInstanceState);
		if (!isUserProfile && !isNew) {
			profileNameEt.setFocusable(false);
			navTypeEt.setFocusable(false);
		}

		if (isNew) {
			profileNameEt.requestFocus();
		} else {
			scrollContainer.requestFocus();
		}

	}

	void updateRoutingProfile(int pos) {
		isDataChanged = true;
		for (int i = 0; i < routingProfileDataObjects.size(); i++) {
			if (i == pos) {
				routingProfileDataObjects.get(i).setSelected(true);
			} else {
				routingProfileDataObjects.get(i).setSelected(false);
			}
		}
		selectedRoutingProfileDataObject = routingProfileDataObjects.get(pos);
		navTypeEt.setText(selectedRoutingProfileDataObject.getName());
		profile.routingProfileDataObject = selectedRoutingProfileDataObject;
	}

	void activateMode(ApplicationMode mode) {
		if (!ApplicationMode.values(app).contains(mode)) {
			ApplicationMode.changeProfileStatus(mode, true, getMyApplication());
		}
	}

	private void setupBaseProfileView(String stringKey) {
		for (ApplicationMode am : ApplicationMode.getDefaultValues()) {
			if (am.getStringKey().equals(stringKey)) {
				baseModeIcon.setImageDrawable(
					app.getUIUtilities().getIcon(am.getSmallIconDark(), R.color.icon_color));
				baseModeTitle.setText(Algorithms.capitalizeFirstLetter(am.toHumanString(app)));
				isDataChanged = false;
			}
		}
	}

	private void setMargins(View v, int l, int t, int r, int b) {
		if (v.getLayoutParams() instanceof ViewGroup.MarginLayoutParams) {
			ViewGroup.MarginLayoutParams p = (ViewGroup.MarginLayoutParams) v.getLayoutParams();
			p.setMargins(l, t, r, b);
			v.requestLayout();
		}
	}

	private boolean saveNewProfile() {
		if (profile.routingProfileDataObject == null) {
			showSaveWarningDialog(
				getString(R.string.profile_alert_need_routing_type_title),
				getString(R.string.profile_alert_need_routing_type_msg),
				getActivity());
			return false;
		}

		if (profile.userProfileTitle.isEmpty()
			|| profile.userProfileTitle.replace(" ", "").length() < 1) {
			showSaveWarningDialog(
				getString(R.string.profile_alert_need_profile_name_title),
				getString(R.string.profile_alert_need_profile_name_msg),
				getActivity()
			);
			return false;
		}

		for (ApplicationMode m : ApplicationMode.allPossibleValues()) {
			if (m.getUserProfileName() != null && getActivity() != null) {
				if (m.getUserProfileName().equals(profile.userProfileTitle)) {
					if (isNew || !Algorithms.isEmpty(mode.getUserProfileName())
						&& !mode.getUserProfileName().equals(profile.userProfileTitle)) {
						AlertDialog.Builder bld = new AlertDialog.Builder(getActivity());
						bld.setTitle(R.string.profile_alert_duplicate_name_title);
						bld.setMessage(R.string.profile_alert_duplicate_name_msg);
						bld.setNegativeButton(R.string.shared_string_dismiss, null);
						bld.show();
						bld.setOnDismissListener(new OnDismissListener() {
							@Override
							public void onDismiss(DialogInterface dialog) {
								profileNameEt.requestFocus();
							}
						});
						return false;
					}
				}
			}
		}

		if (isUserProfile && !isNew) {
			ApplicationMode.deleteCustomMode(mode.getUserProfileName(), getMyApplication());
		}

		String customStringKey = profile.stringKey;
		if (isNew && profile.parent != null) {
			customStringKey =
				profile.parent.getStringKey() + "_" + System.currentTimeMillis();
		}

		ApplicationMode.ApplicationModeBuilder builder = ApplicationMode
			.createCustomMode(profile.userProfileTitle.trim(), customStringKey)
			.parent(profile.parent)
			.icon(profile.iconId, profile.iconId);

		if (profile.routingProfileDataObject != null) {
			builder.setRoutingProfile(profile.routingProfileDataObject.getStringKey());
		}

		ApplicationMode mode = builder.customReg();
		ApplicationMode.saveCustomModeToSettings(getSettings());

		if (!ApplicationMode.values(app).contains(mode)) {
			boolean save = ApplicationMode.changeProfileStatus(mode, true, getMyApplication());

			if (save && getSettings() != null) {
				if (profile.routingProfileDataObject.getStringKey()
					.equals(RoutingProfilesResources.STRAIGHT_LINE_MODE.toString())) {
					getSettings().ROUTER_SERVICE.setModeValue(mode, RouteService.STRAIGHT);
				} else if (profile.routingProfileDataObject.getStringKey()
					.equals(RoutingProfilesResources.BROUTER_MODE.toString())) {
					getSettings().ROUTER_SERVICE.setModeValue(mode, RouteService.BROUTER);
				} else {
					getSettings().ROUTER_SERVICE.setModeValue(mode, RouteService.OSMAND);
				}
			}

		}
		isDataChanged = false;
		isCancelAllowed = true;
		return true;
	}

	private void needSaveDialog() {
		if (getActivity() != null) {
			AlertDialog.Builder bld = new AlertDialog.Builder(getActivity());
			bld.setTitle(R.string.profile_alert_need_save_title);
			bld.setMessage(R.string.profile_alert_need_save_msg);
			bld.setNegativeButton(R.string.shared_string_ok, null);
			bld.show();
		}
	}

	private void showSaveWarningDialog(String title, String message, Activity activity) {
		AlertDialog.Builder bld = new AlertDialog.Builder(activity);
		bld.setTitle(title);
		bld.setMessage(message);
		bld.setNegativeButton(R.string.shared_string_dismiss, null);
		bld.show();
	}

	void confirmCancelDialog(final Activity activity) {
		AlertDialog.Builder bld = new Builder(activity);
		bld.setTitle(R.string.shared_string_dismiss);
		bld.setMessage(R.string.exit_without_saving);
		bld.setPositiveButton(R.string.shared_string_ok, new DialogInterface.OnClickListener() {
			@Override
			public void onClick(DialogInterface dialog, int which) {
				isCancelAllowed = true;
				activity.onBackPressed();
			}
		});
		bld.setNegativeButton(R.string.shared_string_cancel, null);
		bld.show();

	}

	void onDeleteProfileClick() {
		if (getActivity() != null) {
			if (isUserProfile) {
				AlertDialog.Builder bld = new AlertDialog.Builder(getActivity());
				bld.setTitle(R.string.profile_alert_delete_title);
				bld.setMessage(String
					.format(getString(R.string.profile_alert_delete_msg),
						profile.userProfileTitle));
				bld.setPositiveButton(R.string.shared_string_delete,
					new DialogInterface.OnClickListener() {
						@Override
						public void onClick(DialogInterface dialog, int which) {
							ApplicationMode
								.deleteCustomMode(profile.userProfileTitle, getMyApplication());
							if (getActivity() != null) {
								getActivity().onBackPressed();
							}
							getSettings().APPLICATION_MODE.set(ApplicationMode.DEFAULT);
						}
					});
				bld.setNegativeButton(R.string.shared_string_dismiss, null);
				bld.show();
			} else {
				Toast.makeText(getActivity(), R.string.profile_alert_cant_delete_base,
					Toast.LENGTH_SHORT).show();
			}
		}
	}

	static List<RoutingProfileDataObject> getRoutingProfiles(OsmandApplication context) {
		List<RoutingProfileDataObject> profilesObjects = new ArrayList<>();
		profilesObjects.add(new RoutingProfileDataObject(
			RoutingProfilesResources.STRAIGHT_LINE_MODE.toString(),
			context.getString(RoutingProfilesResources.STRAIGHT_LINE_MODE.getStringRes()),
			context.getString(R.string.special_routing_type),
			RoutingProfilesResources.STRAIGHT_LINE_MODE.getIconRes(),
			false, null));
		if (context.getBRouterService() != null) {
			profilesObjects.add(new RoutingProfileDataObject(
				RoutingProfilesResources.BROUTER_MODE.toString(),
				context.getString(RoutingProfilesResources.BROUTER_MODE.getStringRes()),
				context.getString(R.string.third_party_routing_type),
				RoutingProfilesResources.BROUTER_MODE.getIconRes(),
				false, null));
		}

		Map<String, GeneralRouter> inputProfiles = context.getRoutingConfig().getAllRouters();
		for (Entry<String, GeneralRouter> e : inputProfiles.entrySet()) {
			int iconRes = R.drawable.ic_action_gdirections_dark;
			String name = e.getValue().getProfileName();
			String description = context.getString(R.string.osmand_default_routing);
			if (RoutingProfilesResources.isRpValue(name.toUpperCase())){
				iconRes = RoutingProfilesResources.valueOf(name.toUpperCase()).getIconRes();
				name = context
					.getString(RoutingProfilesResources.valueOf(name.toUpperCase()).getStringRes());
			} else if (!Algorithms.isEmpty(e.getValue().getFilename())) {
				description = e.getValue().getFilename();
			}
			profilesObjects.add(new RoutingProfileDataObject(e.getKey(), name, description,
				iconRes, false, e.getValue().getFilename()));
		}
		return profilesObjects;
	}

	public enum RoutingProfilesResources {
		STRAIGHT_LINE_MODE(R.string.routing_profile_straightline,R.drawable.ic_action_split_interval),
		BROUTER_MODE(R.string.routing_profile_broutrer, R.drawable.ic_action_split_interval),
		CAR(R.string.rendering_value_car_name, R.drawable.ic_action_car_dark),
		PEDESTRIAN(R.string.rendering_value_pedestrian_name, R.drawable.map_action_pedestrian_dark),
		BICYCLE(R.string.rendering_value_bicycle_name, R.drawable.map_action_bicycle_dark),
		SKI(R.string.routing_profile_ski, R.drawable.ic_plugin_skimaps),
		PUBLIC_TRANSPORT(R.string.app_mode_public_transport, R.drawable.map_action_bus_dark),
		BOAT(R.string.app_mode_boat, R.drawable.map_action_sail_boat_dark),
		GEOCODING(R.string.routing_profile_geocoding, R.drawable.ic_action_world_globe);

		int stringRes;
		int iconRes;

		RoutingProfilesResources(int stringRes, int iconRes) {
			this.stringRes = stringRes;
			this.iconRes = iconRes;
		}

		public int getStringRes() {
			return stringRes;
		}

		public int getIconRes() {
			return iconRes;
		}

		private static final List<String> rpValues = new ArrayList<>();

		static {
			for (RoutingProfilesResources rpr : RoutingProfilesResources.values()) {
				rpValues.add(rpr.name());
			}
		}

		public static boolean isRpValue(String value) {
			return rpValues.contains(value);
		}
	}

	private class ApplicationProfileObject {

		int key = -1;
		String stringKey;
		String userProfileTitle = "";
		ApplicationMode parent = null;
		int iconId = R.drawable.map_world_globe_dark;
		RoutingProfileDataObject routingProfileDataObject = null;

		ApplicationProfileObject(ApplicationMode mode, boolean isNew, boolean isUserProfile) {
			if (isNew) {
				stringKey = mode.getStringKey() + System.currentTimeMillis();
				parent = mode;
			} else if (isUserProfile) {
				stringKey = mode.getStringKey();
				parent = mode.getParent();
				iconId = mode.getSmallIconDark();
				userProfileTitle = mode.getUserProfileName();
			} else {
				key = mode.getStringResource();
				stringKey = mode.getStringKey();
				iconId = mode.getSmallIconDark();
			}
		}
	}
}
!@#$%
20190530_081828,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_a09852
package net.osmand.plus.profiles;

import static net.osmand.plus.activities.SettingsNavigationActivity.INTENT_SKIP_DIALOG;
import static net.osmand.plus.profiles.SelectProfileBottomSheetDialogFragment.DIALOG_TYPE;
import static net.osmand.plus.profiles.SelectProfileBottomSheetDialogFragment.SELECTED_KEY;
import static net.osmand.plus.profiles.SelectProfileBottomSheetDialogFragment.TYPE_APP_PROFILE;
import static net.osmand.plus.profiles.SelectProfileBottomSheetDialogFragment.TYPE_ICON;
import static net.osmand.plus.profiles.SelectProfileBottomSheetDialogFragment.TYPE_NAV_PROFILE;
import static net.osmand.plus.profiles.SettingsProfileFragment.IS_NEW_PROFILE;
import static net.osmand.plus.profiles.SettingsProfileFragment.IS_USER_PROFILE;
import static net.osmand.plus.profiles.SettingsProfileFragment.PROFILE_STRING_KEY;

import android.app.Activity;
import android.content.DialogInterface;
import android.content.DialogInterface.OnDismissListener;
import android.content.Intent;
import android.graphics.Rect;
import android.graphics.drawable.GradientDrawable;
import android.os.Bundle;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.support.v4.content.ContextCompat;
import android.support.v7.app.ActionBar;
import android.support.v7.app.AlertDialog;
import android.support.v7.app.AlertDialog.Builder;
import android.text.Editable;
import android.text.TextWatcher;
import android.view.LayoutInflater;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;

import android.view.ViewTreeObserver.OnGlobalLayoutListener;
import android.widget.Button;
import android.widget.FrameLayout;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.ScrollView;
import android.widget.TextView;
import android.widget.Toast;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import net.osmand.PlatformUtil;
import net.osmand.plus.ApplicationMode;
import net.osmand.plus.OsmandApplication;
import net.osmand.plus.R;
import net.osmand.plus.activities.MapActivity;
import net.osmand.plus.activities.OsmandActionBarActivity;
import net.osmand.plus.activities.SettingsNavigationActivity;
import net.osmand.plus.base.BaseOsmAndFragment;
import net.osmand.plus.profiles.SelectProfileBottomSheetDialogFragment.SelectProfileListener;
import net.osmand.plus.routing.RouteProvider.RouteService;
import net.osmand.plus.widgets.OsmandTextFieldBoxes;
import net.osmand.router.GeneralRouter;
import net.osmand.util.Algorithms;
import org.apache.commons.lang3.EnumUtils;
import org.apache.commons.logging.Log;
import studio.carbonylgroup.textfieldboxes.ExtendedEditText;

public class EditProfileFragment extends BaseOsmAndFragment {

	private static final Log LOG = PlatformUtil.getLog(EditProfileFragment.class);

	public static final String OPEN_CONFIG_ON_MAP = "openConfigOnMap";
	public static final String MAP_CONFIG = "openMapConfigMenu";
	public static final String NAV_CONFIG = "openNavConfigMenu";
	public static final String SCREEN_CONFIG = "openScreenConfigMenu";
	public static final String SELECTED_ITEM = "editedProfile";
	public static final String SELECTED_ICON = "selectedIcon";

	OsmandApplication app;

	ApplicationMode mode = null;
	ApplicationProfileObject profile = null;
	List<RoutingProfileDataObject> routingProfileDataObjects;
	RoutingProfileDataObject selectedRoutingProfileDataObject = null;

	private boolean isNew = false;
	private boolean isUserProfile = false;
	private boolean isDataChanged = false;
	private boolean isCancelAllowed = true;
	private boolean isNightMode;

	private SelectProfileListener navTypeListener = null;
	private SelectProfileListener iconIdListener = null;
	private SelectProfileListener baseTypeListener = null;

	private ImageView profileIcon;
	private LinearLayout profileIconBtn;
	private ExtendedEditText profileNameEt;
	private OsmandTextFieldBoxes profileNameTextBox;
	private ExtendedEditText navTypeEt;
	private OsmandTextFieldBoxes navTypeTextBox;
	private FrameLayout selectNavTypeBtn;
	private Button cancelBtn;
	private Button saveButton;
	private View mapConfigBtn;
	private View screenConfigBtn;
	private View navConfigBtn;
	private LinearLayout buttonsLayout;
	private FrameLayout clickBlockLayout;
	private LinearLayout typeSelectionBtn;
	private ImageView baseModeIcon;
	private TextView baseModeTitle;
	private ScrollView scrollContainer;
	private LinearLayout buttonsLayoutSV;
	private Button cancelBtnSV;
	private Button saveButtonSV;

	@Override
	public void onCreate(@Nullable Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		app = getMyApplication();
		if (getArguments() != null) {
			String modeName = getArguments().getString(PROFILE_STRING_KEY, "car");
			isNew = getArguments().getBoolean(IS_NEW_PROFILE, false);
			isUserProfile = getArguments().getBoolean(IS_USER_PROFILE, false);
			mode = ApplicationMode.valueOfStringKey(modeName, ApplicationMode.DEFAULT);
			profile = new ApplicationProfileObject(mode, isNew, isUserProfile);
		}
		isNightMode = !app.getSettings().isLightContent();
		routingProfileDataObjects = getRoutingProfiles(app);
	}

	@Nullable
	@Override
	public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container,
		@Nullable Bundle savedInstanceState) {

		final View view = inflater.inflate(R.layout.fragment_selected_profile, container, false);

		profileIcon = view.findViewById(R.id.select_icon_btn_img);
		profileIconBtn = view.findViewById(R.id.profile_icon_layout);
		profileNameEt = view.findViewById(R.id.profile_name_et);
		profileNameTextBox = view.findViewById(R.id.profile_name_otfb);
		navTypeEt = view.findViewById(R.id.navigation_type_et);
		navTypeTextBox = view.findViewById(R.id.navigation_type_otfb);
		selectNavTypeBtn = view.findViewById(R.id.select_nav_type_btn);
		cancelBtn = view.findViewById(R.id.cancel_button);
		saveButton = view.findViewById(R.id.save_profile_btn);
		mapConfigBtn = view.findViewById(R.id.map_config_btn);
		screenConfigBtn = view.findViewById(R.id.screen_config_btn);
		navConfigBtn = view.findViewById(R.id.nav_settings_btn);
		buttonsLayout = view.findViewById(R.id.buttons_layout);
		clickBlockLayout = view.findViewById(R.id.click_block_layout);
		typeSelectionBtn = view.findViewById(R.id.type_selection_button);
		baseModeIcon = view.findViewById(R.id.mode_icon);
		baseModeTitle = view.findViewById(R.id.mode_title);
		scrollContainer = view.findViewById(R.id.scroll_view_container);
		buttonsLayoutSV = view.findViewById(R.id.buttons_layout_sv);
		cancelBtnSV = view.findViewById(R.id.cancel_button_sv);
		saveButtonSV = view.findViewById(R.id.save_profile_btn_sv);

		profileNameEt.setFocusable(true);
		profileNameEt.setSelectAllOnFocus(true);
		profileIconBtn.setBackgroundResource(R.drawable.rounded_background_3dp);
		GradientDrawable selectIconBtnBackground = (GradientDrawable) profileIconBtn
			.getBackground();

		if (isNightMode) {
			profileNameTextBox
				.setPrimaryColor(ContextCompat.getColor(app, R.color.color_dialog_buttons_dark));
			navTypeTextBox
				.setPrimaryColor(ContextCompat.getColor(app, R.color.color_dialog_buttons_dark));
			selectIconBtnBackground
				.setColor(app.getResources().getColor(R.color.text_field_box_dark));
		} else {
			selectIconBtnBackground
				.setColor(app.getResources().getColor(R.color.text_field_box_light));
		}

		String title = "New Profile";

		int startIconId = R.drawable.map_world_globe_dark;

		if (isNew) {
			isDataChanged = true;
			startIconId = profile.parent.getSmallIconDark();
			profile.iconId = startIconId;
		} else if (isUserProfile) {
			title = profile.userProfileTitle;
			profileNameEt.setText(title);
			startIconId = profile.iconId;
			isDataChanged = false;
		} else if (profile.key != -1) {
			title = getResources().getString(profile.key);
			profileNameEt.setText(profile.key);
			startIconId = profile.iconId;
			clickBlockLayout.setClickable(true);
		}
		profile.userProfileTitle = title;

		if (profile.parent != null) {
			setupBaseProfileView(profile.parent.getStringKey());
		} else if (profile.key != -1) {
			baseModeTitle.setText(profile.key);
			baseModeIcon.setImageDrawable(
				app.getUIUtilities().getIcon(profile.iconId, R.color.icon_color));
		}
		typeSelectionBtn.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
				if (isUserProfile || isNew) {
					final SelectProfileBottomSheetDialogFragment dialog = new SelectProfileBottomSheetDialogFragment();
					Bundle bundle = new Bundle();
					if (profile.parent != null) {
						bundle.putString(SELECTED_KEY, profile.parent.getStringKey());
					}
					bundle.putString(DIALOG_TYPE, TYPE_APP_PROFILE);
					dialog.setArguments(bundle);
					if (getActivity() != null) {
						getActivity().getSupportFragmentManager().beginTransaction()
							.add(dialog, "select_base_type").commitAllowingStateLoss();
					}
				}
			}
		});

		if (!Algorithms.isEmpty(mode.getRoutingProfile())) {
			for (RoutingProfileDataObject r : routingProfileDataObjects) {
				if (mode.getRoutingProfile().equals(r.getStringKey())) {
					profile.routingProfileDataObject = r;
					r.setSelected(true);
					navTypeEt.setText(r.getName());
					navTypeEt.clearFocus();
				}
			}
		} else {
			for (RoutingProfileDataObject rp : routingProfileDataObjects) {
				if (profile.stringKey.equals(rp.getStringKey())) {
					navTypeEt.setText(
						RoutingProfilesResources.valueOf(rp.getStringKey().toUpperCase())
							.getStringRes());
				}
			}
			navTypeEt.clearFocus();
		}
		profileNameEt.clearFocus();

		if (getActivity() != null
			&& ((EditProfileActivity) getActivity()).getSupportActionBar() != null) {
			((EditProfileActivity) getActivity()).getSupportActionBar().setTitle(title);
			((EditProfileActivity) getActivity()).getSupportActionBar().setElevation(5.0f);
		}

		int iconColor;
		if (!isUserProfile) {
			iconColor = R.color.icon_color;
		} else {
			iconColor = isNightMode
				? R.color.active_buttons_and_links_dark
				: R.color.active_buttons_and_links_light;
		}

		profileIcon.setImageDrawable(app.getUIUtilities().getIcon(startIconId, iconColor));

		profileNameEt.addTextChangedListener(new TextWatcher() {
			@Override
			public void beforeTextChanged(CharSequence s, int start, int count, int after) {
			}

			@Override
			public void onTextChanged(CharSequence s, int start, int before, int count) {
			}

			@Override
			public void afterTextChanged(Editable s) {
				if (getActivity() instanceof OsmandActionBarActivity) {
					ActionBar actionBar = ((OsmandActionBarActivity) getActivity())
						.getSupportActionBar();
					if (actionBar != null) {
						actionBar.setTitle(s.toString());
						profile.userProfileTitle = s.toString();
						isCancelAllowed = false;
					}
				}
			}
		});

		selectNavTypeBtn.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				if (isNew || isUserProfile) {
					final SelectProfileBottomSheetDialogFragment fragment = new SelectProfileBottomSheetDialogFragment();
					Bundle bundle = new Bundle();
					if (profile.routingProfileDataObject != null) {
						bundle.putString(SELECTED_KEY,
							profile.routingProfileDataObject.getStringKey());
					}
					bundle.putString(DIALOG_TYPE, TYPE_NAV_PROFILE);
					fragment.setArguments(bundle);
					if (getActivity() != null) {
						getActivity().getSupportFragmentManager().beginTransaction()
							.add(fragment, "select_nav_type").commitAllowingStateLoss();
					}
					navTypeEt.setCursorVisible(false);
					navTypeEt.setTextIsSelectable(false);
					navTypeEt.clearFocus();
					navTypeEt.requestFocus(ExtendedEditText.FOCUS_UP);
				}
			}
		});

		profileIconBtn.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
				final SelectProfileBottomSheetDialogFragment iconSelectDialog = new SelectProfileBottomSheetDialogFragment();
				Bundle bundle = new Bundle();
				bundle.putString(DIALOG_TYPE, TYPE_ICON);
				bundle.putInt(SELECTED_ICON, profile.iconId);
				iconSelectDialog.setArguments(bundle);
				if (getActivity() != null) {
					getActivity().getSupportFragmentManager().beginTransaction()
						.add(iconSelectDialog, "select_icon")
						.commitAllowingStateLoss();
				}
			}
		});

		mapConfigBtn.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
				if (isDataChanged) {
					needSaveDialog();
				} else if (getSettings() != null) {
					activateMode(mode);
					getSettings().APPLICATION_MODE.set(mode);
					Intent i = new Intent(getActivity(), MapActivity.class);
					i.putExtra(OPEN_CONFIG_ON_MAP, MAP_CONFIG);
					i.putExtra(SELECTED_ITEM, profile.stringKey);
					startActivity(i);
				}
			}
		});

		screenConfigBtn.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
				if (isDataChanged) {
					needSaveDialog();
				} else if (getSettings() != null) {
					activateMode(mode);
					getSettings().APPLICATION_MODE.set(mode);
					Intent i = new Intent(getActivity(), MapActivity.class);
					i.putExtra(OPEN_CONFIG_ON_MAP, SCREEN_CONFIG);
					i.putExtra(SELECTED_ITEM, profile.stringKey);
					startActivity(i);
				}
			}
		});

		navConfigBtn.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
				if (isDataChanged) {
					needSaveDialog();
				} else if (getSettings() != null) {
					activateMode(mode);
					getSettings().APPLICATION_MODE.set(mode);
					Intent i = new Intent(getActivity(), SettingsNavigationActivity.class);
					i.putExtra(INTENT_SKIP_DIALOG, true);
					i.putExtra(OPEN_CONFIG_ON_MAP, NAV_CONFIG);
					i.putExtra(SELECTED_ITEM, profile.stringKey);
					startActivity(i);
				}
			}
		});

		cancelBtn.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
				if (getActivity() != null) {
					getActivity().onBackPressed();
				}
			}
		});

		cancelBtnSV.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
				if (getActivity() != null) {
					getActivity().onBackPressed();
				}
			}
		});

		saveButton.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
				if (saveNewProfile()) {
					activateMode(mode);
					getActivity().onBackPressed();
				}
			}
		});

		saveButtonSV.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
				if (saveNewProfile()) {
					activateMode(mode);
					getActivity().onBackPressed();
				}
			}
		});

		view.getViewTreeObserver().addOnGlobalLayoutListener(new OnGlobalLayoutListener() {
			@Override
			public void onGlobalLayout() {
				int marginShow = 66;
				int marginHide = 0;

				float d = getResources().getDisplayMetrics().density;
				Rect r = new Rect();
				view.getWindowVisibleDisplayFrame(r);
				int screenHeight = view.getRootView().getHeight();
				int keypadHeight = screenHeight - r.bottom;
				if (keypadHeight > screenHeight * 0.15) {
					buttonsLayout.setVisibility(View.GONE);
					buttonsLayoutSV.setVisibility(View.VISIBLE);
					setMargins(scrollContainer, 0, 0, 0, (int) (marginHide * d));
				} else {
					buttonsLayoutSV.setVisibility(View.GONE);
					buttonsLayout.setVisibility(View.VISIBLE);
					setMargins(scrollContainer, 0, 0, 0, (int) (marginShow * d));
				}
			}
		});
		return view;
	}

	@Override
	public void onResume() {
		getBaseProfileListener();
		getNavProfileListener();
		getIconListener();
		super.onResume();
	}

	boolean onBackPressedAllowed() {
		return isCancelAllowed;
	}

	SelectProfileListener getIconListener() {
		if (iconIdListener == null) {
			iconIdListener = new SelectProfileListener() {
				@Override
				public void onSelectedType(int pos) {
					isDataChanged = true;
					profile.iconId = pos;
					profileIcon.setImageDrawable(app.getUIUtilities().getIcon(pos,
						isNightMode ? R.color.active_buttons_and_links_dark
							: R.color.active_buttons_and_links_light));
				}
			};
		}
		return iconIdListener;
	}

	SelectProfileListener getBaseProfileListener() {
		if (baseTypeListener == null) {
			baseTypeListener = new SelectProfileListener() {
				@Override
				public void onSelectedType(int pos) {
					String key = SettingsProfileFragment.getBaseProfiles(getMyApplication())
						.get(pos).getStringKey();
					setupBaseProfileView(key);
					profile.parent = ApplicationMode.valueOfStringKey(key, ApplicationMode.DEFAULT);
				}
			};
		}
		return baseTypeListener;
	}

	SelectProfileListener getNavProfileListener() {
		if (navTypeListener == null) {
			navTypeListener = new SelectProfileListener() {
				@Override
				public void onSelectedType(int pos) {
					updateRoutingProfile(pos);
				}
			};
		}
		return navTypeListener;
	}

	@Override
	public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
		super.onViewCreated(view, savedInstanceState);
		if (!isUserProfile && !isNew) {
			profileNameEt.setFocusable(false);
			navTypeEt.setFocusable(false);
		}

		if (isNew) {
			profileNameEt.requestFocus();
		} else {
			scrollContainer.requestFocus();
		}

	}

	void updateRoutingProfile(int pos) {
		isDataChanged = true;
		for (int i = 0; i < routingProfileDataObjects.size(); i++) {
			if (i == pos) {
				routingProfileDataObjects.get(i).setSelected(true);
			} else {
				routingProfileDataObjects.get(i).setSelected(false);
			}
		}
		selectedRoutingProfileDataObject = routingProfileDataObjects.get(pos);
		navTypeEt.setText(selectedRoutingProfileDataObject.getName());
		profile.routingProfileDataObject = selectedRoutingProfileDataObject;
	}

	void activateMode(ApplicationMode mode) {
		if (!ApplicationMode.values(app).contains(mode)) {
			ApplicationMode.changeProfileStatus(mode, true, getMyApplication());
		}
	}

	private void setupBaseProfileView(String stringKey) {
		for (ApplicationMode am : ApplicationMode.getDefaultValues()) {
			if (am.getStringKey().equals(stringKey)) {
				baseModeIcon.setImageDrawable(
					app.getUIUtilities().getIcon(am.getSmallIconDark(), R.color.icon_color));
				baseModeTitle.setText(Algorithms.capitalizeFirstLetter(am.toHumanString(app)));
				isDataChanged = false;
			}
		}
	}

	private void setMargins(View v, int l, int t, int r, int b) {
		if (v.getLayoutParams() instanceof ViewGroup.MarginLayoutParams) {
			ViewGroup.MarginLayoutParams p = (ViewGroup.MarginLayoutParams) v.getLayoutParams();
			p.setMargins(l, t, r, b);
			v.requestLayout();
		}
	}

	private boolean saveNewProfile() {
		if (profile.routingProfileDataObject == null) {
			showSaveWarningDialog(
				getString(R.string.profile_alert_need_routing_type_title),
				getString(R.string.profile_alert_need_routing_type_msg),
				getActivity());
			return false;
		}

		if (profile.userProfileTitle.isEmpty()
			|| profile.userProfileTitle.replace(" ", "").length() < 1) {
			showSaveWarningDialog(
				getString(R.string.profile_alert_need_profile_name_title),
				getString(R.string.profile_alert_need_profile_name_msg),
				getActivity()
			);
			return false;
		}

		for (ApplicationMode m : ApplicationMode.allPossibleValues()) {
			if (m.getUserProfileName() != null && getActivity() != null) {
				if (m.getUserProfileName().equals(profile.userProfileTitle)) {
					if (isNew || !Algorithms.isEmpty(mode.getUserProfileName())
						&& !mode.getUserProfileName().equals(profile.userProfileTitle)) {
						AlertDialog.Builder bld = new AlertDialog.Builder(getActivity());
						bld.setTitle(R.string.profile_alert_duplicate_name_title);
						bld.setMessage(R.string.profile_alert_duplicate_name_msg);
						bld.setNegativeButton(R.string.shared_string_dismiss, null);
						bld.show();
						bld.setOnDismissListener(new OnDismissListener() {
							@Override
							public void onDismiss(DialogInterface dialog) {
								profileNameEt.requestFocus();
							}
						});
						return false;
					}
				}
			}
		}

		if (isUserProfile && !isNew) {
			ApplicationMode.deleteCustomMode(mode.getUserProfileName(), getMyApplication());
		}

		String customStringKey = profile.stringKey;
		if (isNew && profile.parent != null) {
			customStringKey =
				profile.parent.getStringKey() + "_" + System.currentTimeMillis();
		}

		ApplicationMode.ApplicationModeBuilder builder = ApplicationMode
			.createCustomMode(profile.userProfileTitle.trim(), customStringKey)
			.parent(profile.parent)
			.icon(profile.iconId, profile.iconId);

		if (profile.routingProfileDataObject != null) {
			builder.setRoutingProfile(profile.routingProfileDataObject.getStringKey());
		}

		ApplicationMode mode = builder.customReg();
		ApplicationMode.saveCustomModeToSettings(getSettings());

		if (!ApplicationMode.values(app).contains(mode)) {
			boolean save = ApplicationMode.changeProfileStatus(mode, true, getMyApplication());

			if (save && getSettings() != null) {
				if (profile.routingProfileDataObject.getStringKey()
					.equals(RoutingProfilesResources.STRAIGHT_LINE_MODE.toString())) {
					getSettings().ROUTER_SERVICE.setModeValue(mode, RouteService.STRAIGHT);
				} else if (profile.routingProfileDataObject.getStringKey()
					.equals(RoutingProfilesResources.BROUTER_MODE.toString())) {
					getSettings().ROUTER_SERVICE.setModeValue(mode, RouteService.BROUTER);
				} else {
					getSettings().ROUTER_SERVICE.setModeValue(mode, RouteService.OSMAND);
				}
			}

		}
		isDataChanged = false;
		isCancelAllowed = true;
		return true;
	}

	private void needSaveDialog() {
		if (getActivity() != null) {
			AlertDialog.Builder bld = new AlertDialog.Builder(getActivity());
			bld.setTitle(R.string.profile_alert_need_save_title);
			bld.setMessage(R.string.profile_alert_need_save_msg);
			bld.setNegativeButton(R.string.shared_string_ok, null);
			bld.show();
		}
	}

	private void showSaveWarningDialog(String title, String message, Activity activity) {
		AlertDialog.Builder bld = new AlertDialog.Builder(activity);
		bld.setTitle(title);
		bld.setMessage(message);
		bld.setNegativeButton(R.string.shared_string_dismiss, null);
		bld.show();
	}

	void confirmCancelDialog(final Activity activity) {
		AlertDialog.Builder bld = new Builder(activity);
		bld.setTitle(R.string.shared_string_dismiss);
		bld.setMessage(R.string.exit_without_saving);
		bld.setPositiveButton(R.string.shared_string_ok, new DialogInterface.OnClickListener() {
			@Override
			public void onClick(DialogInterface dialog, int which) {
				isCancelAllowed = true;
				activity.onBackPressed();
			}
		});
		bld.setNegativeButton(R.string.shared_string_cancel, null);
		bld.show();

	}

	void onDeleteProfileClick() {
		if (getActivity() != null) {
			if (isUserProfile) {
				AlertDialog.Builder bld = new AlertDialog.Builder(getActivity());
				bld.setTitle(R.string.profile_alert_delete_title);
				bld.setMessage(String
					.format(getString(R.string.profile_alert_delete_msg),
						profile.userProfileTitle));
				bld.setPositiveButton(R.string.shared_string_delete,
					new DialogInterface.OnClickListener() {
						@Override
						public void onClick(DialogInterface dialog, int which) {
							ApplicationMode
								.deleteCustomMode(profile.userProfileTitle, getMyApplication());
							if (getActivity() != null) {
								getActivity().onBackPressed();
							}
							getSettings().APPLICATION_MODE.set(ApplicationMode.DEFAULT);
						}
					});
				bld.setNegativeButton(R.string.shared_string_dismiss, null);
				bld.show();
			} else {
				Toast.makeText(getActivity(), R.string.profile_alert_cant_delete_base,
					Toast.LENGTH_SHORT).show();
			}
		}
	}

	static List<RoutingProfileDataObject> getRoutingProfiles(OsmandApplication context) {
		List<RoutingProfileDataObject> profilesObjects = new ArrayList<>();
		profilesObjects.add(new RoutingProfileDataObject(
			RoutingProfilesResources.STRAIGHT_LINE_MODE.toString(),
			context.getString(RoutingProfilesResources.STRAIGHT_LINE_MODE.getStringRes()),
			context.getString(R.string.special_routing_type),
			RoutingProfilesResources.STRAIGHT_LINE_MODE.getIconRes(),
			false, null));
		if (context.getBRouterService() != null) {
			profilesObjects.add(new RoutingProfileDataObject(
				RoutingProfilesResources.BROUTER_MODE.toString(),
				context.getString(RoutingProfilesResources.BROUTER_MODE.getStringRes()),
				context.getString(R.string.third_party_routing_type),
				RoutingProfilesResources.BROUTER_MODE.getIconRes(),
				false, null));
		}

		Map<String, GeneralRouter> inputProfiles = context.getRoutingConfig().getAllRouters();
		for (Entry<String, GeneralRouter> e : inputProfiles.entrySet()) {
			int iconRes = R.drawable.ic_action_gdirections_dark;
			String name = e.getValue().getProfileName();
			String description = context.getString(R.string.osmand_default_routing);
			if (EnumUtils.isValidEnum(RoutingProfilesResources.class, name.toUpperCase())){
				iconRes = RoutingProfilesResources.valueOf(name.toUpperCase()).getIconRes();
				name = context
					.getString(RoutingProfilesResources.valueOf(name.toUpperCase()).getStringRes());
			} else if (!Algorithms.isEmpty(e.getValue().getFilename())) {
				description = e.getValue().getFilename();
			}
			profilesObjects.add(new RoutingProfileDataObject(e.getKey(), name, description,
				iconRes, false, e.getValue().getFilename()));
		}
		return profilesObjects;
	}

	public enum RoutingProfilesResources {
		STRAIGHT_LINE_MODE(R.string.routing_profile_straightline,R.drawable.ic_action_split_interval),
		BROUTER_MODE(R.string.routing_profile_broutrer, R.drawable.ic_action_split_interval),
		CAR(R.string.rendering_value_car_name, R.drawable.ic_action_car_dark),
		PEDESTRIAN(R.string.rendering_value_pedestrian_name, R.drawable.map_action_pedestrian_dark),
		BICYCLE(R.string.rendering_value_bicycle_name, R.drawable.map_action_bicycle_dark),
		SKI(R.string.routing_profile_ski, R.drawable.ic_plugin_skimaps),
		PUBLIC_TRANSPORT(R.string.app_mode_public_transport, R.drawable.map_action_bus_dark),
		BOAT(R.string.app_mode_boat, R.drawable.map_action_sail_boat_dark),
		GEOCODING(R.string.routing_profile_geocoding, R.drawable.ic_action_world_globe);

		int stringRes;
		int iconRes;

		RoutingProfilesResources(int stringRes, int iconRes) {
			this.stringRes = stringRes;
			this.iconRes = iconRes;
		}

		public int getStringRes() {
			return stringRes;
		}

		public int getIconRes() {
			return iconRes;
		}
	}

	private class ApplicationProfileObject {

		int key = -1;
		String stringKey;
		String userProfileTitle = "";
		ApplicationMode parent = null;
		int iconId = R.drawable.map_world_globe_dark;
		RoutingProfileDataObject routingProfileDataObject = null;

		ApplicationProfileObject(ApplicationMode mode, boolean isNew, boolean isUserProfile) {
			if (isNew) {
				stringKey = mode.getStringKey() + System.currentTimeMillis();
				parent = mode;
			} else if (isUserProfile) {
				stringKey = mode.getStringKey();
				parent = mode.getParent();
				iconId = mode.getSmallIconDark();
				userProfileTitle = mode.getUserProfileName();
			} else {
				key = mode.getStringResource();
				stringKey = mode.getStringKey();
				iconId = mode.getSmallIconDark();
			}
		}
	}
}
!@#$%
20190530_081828,C:\Users\Alice Borner\Desktop\projects\Osmand\git\.merge_file_c09852
package net.osmand.plus.profiles;

import static net.osmand.plus.activities.SettingsNavigationActivity.INTENT_SKIP_DIALOG;
import static net.osmand.plus.profiles.SelectProfileBottomSheetDialogFragment.DIALOG_TYPE;
import static net.osmand.plus.profiles.SelectProfileBottomSheetDialogFragment.SELECTED_KEY;
import static net.osmand.plus.profiles.SelectProfileBottomSheetDialogFragment.TYPE_APP_PROFILE;
import static net.osmand.plus.profiles.SelectProfileBottomSheetDialogFragment.TYPE_ICON;
import static net.osmand.plus.profiles.SelectProfileBottomSheetDialogFragment.TYPE_NAV_PROFILE;
import static net.osmand.plus.profiles.SettingsProfileFragment.IS_NEW_PROFILE;
import static net.osmand.plus.profiles.SettingsProfileFragment.IS_USER_PROFILE;
import static net.osmand.plus.profiles.SettingsProfileFragment.PROFILE_STRING_KEY;

import android.app.Activity;
import android.content.DialogInterface;
import android.content.DialogInterface.OnDismissListener;
import android.content.Intent;
import android.graphics.Rect;
import android.graphics.drawable.GradientDrawable;
import android.os.Bundle;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.support.v4.content.ContextCompat;
import android.support.v7.app.ActionBar;
import android.support.v7.app.AlertDialog;
import android.support.v7.app.AlertDialog.Builder;
import android.text.Editable;
import android.text.TextWatcher;
import android.view.LayoutInflater;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;

import android.view.ViewTreeObserver.OnGlobalLayoutListener;
import android.widget.Button;
import android.widget.FrameLayout;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.ScrollView;
import android.widget.TextView;
import android.widget.Toast;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import net.osmand.PlatformUtil;
import net.osmand.plus.ApplicationMode;
import net.osmand.plus.OsmandApplication;
import net.osmand.plus.R;
import net.osmand.plus.activities.MapActivity;
import net.osmand.plus.activities.OsmandActionBarActivity;
import net.osmand.plus.activities.SettingsNavigationActivity;
import net.osmand.plus.base.BaseOsmAndFragment;
import net.osmand.plus.profiles.SelectProfileBottomSheetDialogFragment.SelectProfileListener;
import net.osmand.plus.routing.RouteProvider.RouteService;
import net.osmand.plus.widgets.OsmandTextFieldBoxes;
import net.osmand.router.GeneralRouter;
import net.osmand.util.Algorithms;
import org.apache.commons.lang3.EnumUtils;
import org.apache.commons.logging.Log;
import studio.carbonylgroup.textfieldboxes.ExtendedEditText;

public class EditProfileFragment extends BaseOsmAndFragment {

	private static final Log LOG = PlatformUtil.getLog(EditProfileFragment.class);

	public static final String OPEN_CONFIG_ON_MAP = "openConfigOnMap";
	public static final String MAP_CONFIG = "openMapConfigMenu";
	public static final String NAV_CONFIG = "openNavConfigMenu";
	public static final String SCREEN_CONFIG = "openScreenConfigMenu";
	public static final String SELECTED_ITEM = "editedProfile";
	public static final String SELECTED_ICON = "selectedIcon";

	OsmandApplication app;

	ApplicationMode mode = null;
	ApplicationProfileObject profile = null;
	List<RoutingProfileDataObject> routingProfileDataObjects;
	RoutingProfileDataObject selectedRoutingProfileDataObject = null;

	private boolean isNew = false;
	private boolean isUserProfile = false;
	private boolean isDataChanged = false;
	private boolean isCancelAllowed = true;
	private boolean isNightMode;

	private SelectProfileListener navTypeListener = null;
	private SelectProfileListener iconIdListener = null;
	private SelectProfileListener baseTypeListener = null;

	private ImageView profileIcon;
	private LinearLayout profileIconBtn;
	private ExtendedEditText profileNameEt;
	private OsmandTextFieldBoxes profileNameTextBox;
	private ExtendedEditText navTypeEt;
	private OsmandTextFieldBoxes navTypeTextBox;
	private FrameLayout selectNavTypeBtn;
	private Button cancelBtn;
	private Button saveButton;
	private View mapConfigBtn;
	private View screenConfigBtn;
	private View navConfigBtn;
	private LinearLayout buttonsLayout;
	private FrameLayout clickBlockLayout;
	private LinearLayout typeSelectionBtn;
	private ImageView baseModeIcon;
	private TextView baseModeTitle;
	private ScrollView scrollContainer;
	private LinearLayout buttonsLayoutSV;
	private Button cancelBtnSV;
	private Button saveButtonSV;

	@Override
	public void onCreate(@Nullable Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		app = getMyApplication();
		if (getArguments() != null) {
			String modeName = getArguments().getString(PROFILE_STRING_KEY, "car");
			isNew = getArguments().getBoolean(IS_NEW_PROFILE, false);
			isUserProfile = getArguments().getBoolean(IS_USER_PROFILE, false);
			mode = ApplicationMode.valueOfStringKey(modeName, ApplicationMode.DEFAULT);
			profile = new ApplicationProfileObject(mode, isNew, isUserProfile);
		}
		isNightMode = !app.getSettings().isLightContent();
		routingProfileDataObjects = getRoutingProfiles(app);
	}

	@Nullable
	@Override
	public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container,
		@Nullable Bundle savedInstanceState) {

		final View view = inflater.inflate(R.layout.fragment_selected_profile, container, false);

		profileIcon = view.findViewById(R.id.select_icon_btn_img);
		profileIconBtn = view.findViewById(R.id.profile_icon_layout);
		profileNameEt = view.findViewById(R.id.profile_name_et);
		profileNameTextBox = view.findViewById(R.id.profile_name_otfb);
		navTypeEt = view.findViewById(R.id.navigation_type_et);
		navTypeTextBox = view.findViewById(R.id.navigation_type_otfb);
		selectNavTypeBtn = view.findViewById(R.id.select_nav_type_btn);
		cancelBtn = view.findViewById(R.id.cancel_button);
		saveButton = view.findViewById(R.id.save_profile_btn);
		mapConfigBtn = view.findViewById(R.id.map_config_btn);
		screenConfigBtn = view.findViewById(R.id.screen_config_btn);
		navConfigBtn = view.findViewById(R.id.nav_settings_btn);
		buttonsLayout = view.findViewById(R.id.buttons_layout);
		clickBlockLayout = view.findViewById(R.id.click_block_layout);
		typeSelectionBtn = view.findViewById(R.id.type_selection_button);
		baseModeIcon = view.findViewById(R.id.mode_icon);
		baseModeTitle = view.findViewById(R.id.mode_title);
		scrollContainer = view.findViewById(R.id.scroll_view_container);
		buttonsLayoutSV = view.findViewById(R.id.buttons_layout_sv);
		cancelBtnSV = view.findViewById(R.id.cancel_button_sv);
		saveButtonSV = view.findViewById(R.id.save_profile_btn_sv);

		profileNameEt.setFocusable(true);
		profileNameEt.setSelectAllOnFocus(true);
		profileIconBtn.setBackgroundResource(R.drawable.rounded_background_3dp);
		GradientDrawable selectIconBtnBackground = (GradientDrawable) profileIconBtn
			.getBackground();

		if (isNightMode) {
			profileNameTextBox
				.setPrimaryColor(ContextCompat.getColor(app, R.color.color_dialog_buttons_dark));
			navTypeTextBox
				.setPrimaryColor(ContextCompat.getColor(app, R.color.color_dialog_buttons_dark));
			selectIconBtnBackground
				.setColor(app.getResources().getColor(R.color.text_field_box_dark));
		} else {
			selectIconBtnBackground
				.setColor(app.getResources().getColor(R.color.text_field_box_light));
		}

		String title = "New Profile";

		int startIconId = R.drawable.map_world_globe_dark;

		if (isNew) {
			isDataChanged = true;
			startIconId = profile.parent.getSmallIconDark();
			profile.iconId = startIconId;
		} else if (isUserProfile) {
			title = profile.userProfileTitle;
			profileNameEt.setText(title);
			startIconId = profile.iconId;
			isDataChanged = false;
		} else if (profile.key != -1) {
			title = getResources().getString(profile.key);
			profileNameEt.setText(profile.key);
			startIconId = profile.iconId;
			clickBlockLayout.setClickable(true);
		}
		profile.userProfileTitle = title;

		if (profile.parent != null) {
			setupBaseProfileView(profile.parent.getStringKey());
		} else if (profile.key != -1) {
			baseModeTitle.setText(profile.key);
			baseModeIcon.setImageDrawable(
				app.getUIUtilities().getIcon(profile.iconId, R.color.icon_color));
		}
		typeSelectionBtn.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
				if (isUserProfile || isNew) {
					final SelectProfileBottomSheetDialogFragment dialog = new SelectProfileBottomSheetDialogFragment();
					Bundle bundle = new Bundle();
					if (profile.parent != null) {
						bundle.putString(SELECTED_KEY, profile.parent.getStringKey());
					}
					bundle.putString(DIALOG_TYPE, TYPE_APP_PROFILE);
					dialog.setArguments(bundle);
					if (getActivity() != null) {
						getActivity().getSupportFragmentManager().beginTransaction()
							.add(dialog, "select_base_type").commitAllowingStateLoss();
					}
				}
			}
		});

		if (!Algorithms.isEmpty(mode.getRoutingProfile())) {
			for (RoutingProfileDataObject r : routingProfileDataObjects) {
				if (mode.getRoutingProfile().equals(r.getStringKey())) {
					profile.routingProfileDataObject = r;
					r.setSelected(true);
					navTypeEt.setText(r.getName());
					navTypeEt.clearFocus();
				}
			}
		} else {
			for (RoutingProfileDataObject rp : routingProfileDataObjects) {
				if (profile.stringKey.equals(rp.getStringKey())) {
					navTypeEt.setText(
						RoutingProfilesResources.valueOf(rp.getStringKey().toUpperCase())
							.getStringRes());
				}
			}
			navTypeEt.clearFocus();
		}
		profileNameEt.clearFocus();

		if (getActivity() != null
			&& ((EditProfileActivity) getActivity()).getSupportActionBar() != null) {
			((EditProfileActivity) getActivity()).getSupportActionBar().setTitle(title);
			((EditProfileActivity) getActivity()).getSupportActionBar().setElevation(5.0f);
		}

		int iconColor;
		if (!isUserProfile) {
			iconColor = R.color.icon_color;
		} else {
			iconColor = isNightMode
				? R.color.active_buttons_and_links_dark
				: R.color.active_buttons_and_links_light;
		}

		profileIcon.setImageDrawable(app.getUIUtilities().getIcon(startIconId, iconColor));

		profileNameEt.addTextChangedListener(new TextWatcher() {
			@Override
			public void beforeTextChanged(CharSequence s, int start, int count, int after) {
			}

			@Override
			public void onTextChanged(CharSequence s, int start, int before, int count) {
			}

			@Override
			public void afterTextChanged(Editable s) {
				if (getActivity() instanceof OsmandActionBarActivity) {
					ActionBar actionBar = ((OsmandActionBarActivity) getActivity())
						.getSupportActionBar();
					if (actionBar != null) {
						actionBar.setTitle(s.toString());
						profile.userProfileTitle = s.toString();
						isCancelAllowed = false;
					}
				}
			}
		});

		selectNavTypeBtn.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				if (isNew || isUserProfile) {
					final SelectProfileBottomSheetDialogFragment fragment = new SelectProfileBottomSheetDialogFragment();
					Bundle bundle = new Bundle();
					if (profile.routingProfileDataObject != null) {
						bundle.putString(SELECTED_KEY,
							profile.routingProfileDataObject.getStringKey());
					}
					bundle.putString(DIALOG_TYPE, TYPE_NAV_PROFILE);
					fragment.setArguments(bundle);
					if (getActivity() != null) {
						getActivity().getSupportFragmentManager().beginTransaction()
							.add(fragment, "select_nav_type").commitAllowingStateLoss();
					}
					navTypeEt.setCursorVisible(false);
					navTypeEt.setTextIsSelectable(false);
					navTypeEt.clearFocus();
					navTypeEt.requestFocus(ExtendedEditText.FOCUS_UP);
				}
			}
		});

		profileIconBtn.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
				final SelectProfileBottomSheetDialogFragment iconSelectDialog = new SelectProfileBottomSheetDialogFragment();
				Bundle bundle = new Bundle();
				bundle.putString(DIALOG_TYPE, TYPE_ICON);
				bundle.putInt(SELECTED_ICON, profile.iconId);
				iconSelectDialog.setArguments(bundle);
				if (getActivity() != null) {
					getActivity().getSupportFragmentManager().beginTransaction()
						.add(iconSelectDialog, "select_icon")
						.commitAllowingStateLoss();
				}
			}
		});

		mapConfigBtn.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
				if (isDataChanged) {
					needSaveDialog();
				} else if (getSettings() != null) {
					activateMode(mode);
					getSettings().APPLICATION_MODE.set(mode);
					Intent i = new Intent(getActivity(), MapActivity.class);
					i.putExtra(OPEN_CONFIG_ON_MAP, MAP_CONFIG);
					i.putExtra(SELECTED_ITEM, profile.stringKey);
					startActivity(i);
				}
			}
		});

		screenConfigBtn.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
				if (isDataChanged) {
					needSaveDialog();
				} else if (getSettings() != null) {
					activateMode(mode);
					getSettings().APPLICATION_MODE.set(mode);
					Intent i = new Intent(getActivity(), MapActivity.class);
					i.putExtra(OPEN_CONFIG_ON_MAP, SCREEN_CONFIG);
					i.putExtra(SELECTED_ITEM, profile.stringKey);
					startActivity(i);
				}
			}
		});

		navConfigBtn.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
				if (isDataChanged) {
					needSaveDialog();
				} else if (getSettings() != null) {
					activateMode(mode);
					getSettings().APPLICATION_MODE.set(mode);
					Intent i = new Intent(getActivity(), SettingsNavigationActivity.class);
					i.putExtra(INTENT_SKIP_DIALOG, true);
					i.putExtra(OPEN_CONFIG_ON_MAP, NAV_CONFIG);
					i.putExtra(SELECTED_ITEM, profile.stringKey);
					startActivity(i);
				}
			}
		});

		cancelBtn.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
				if (getActivity() != null) {
					getActivity().onBackPressed();
				}
			}
		});

		cancelBtnSV.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
				if (getActivity() != null) {
					getActivity().onBackPressed();
				}
			}
		});

		saveButton.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
				if (saveNewProfile()) {
					activateMode(mode);
					getActivity().onBackPressed();
				}
			}
		});

		saveButtonSV.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
				if (saveNewProfile()) {
					activateMode(mode);
					getActivity().onBackPressed();
				}
			}
		});

		view.getViewTreeObserver().addOnGlobalLayoutListener(new OnGlobalLayoutListener() {
			@Override
			public void onGlobalLayout() {
				int marginShow = 66;
				int marginHide = 0;

				float d = getResources().getDisplayMetrics().density;
				Rect r = new Rect();
				view.getWindowVisibleDisplayFrame(r);
				int screenHeight = view.getRootView().getHeight();
				int keypadHeight = screenHeight - r.bottom;
				if (keypadHeight > screenHeight * 0.15) {
					buttonsLayout.setVisibility(View.GONE);
					buttonsLayoutSV.setVisibility(View.VISIBLE);
					setMargins(scrollContainer, 0, 0, 0, (int) (marginHide * d));
				} else {
					buttonsLayoutSV.setVisibility(View.GONE);
					buttonsLayout.setVisibility(View.VISIBLE);
					setMargins(scrollContainer, 0, 0, 0, (int) (marginShow * d));
				}
			}
		});
		return view;
	}

	@Override
	public void onResume() {
		getBaseProfileListener();
		getNavProfileListener();
		getIconListener();
		super.onResume();
	}

	boolean onBackPressedAllowed() {
		return isCancelAllowed;
	}

	SelectProfileListener getIconListener() {
		if (iconIdListener == null) {
			iconIdListener = new SelectProfileListener() {
				@Override
				public void onSelectedType(int pos) {
					isDataChanged = true;
					profile.iconId = pos;
					profileIcon.setImageDrawable(app.getUIUtilities().getIcon(pos,
						isNightMode ? R.color.active_buttons_and_links_dark
							: R.color.active_buttons_and_links_light));
				}
			};
		}
		return iconIdListener;
	}

	SelectProfileListener getBaseProfileListener() {
		if (baseTypeListener == null) {
			baseTypeListener = new SelectProfileListener() {
				@Override
				public void onSelectedType(int pos) {
					String key = SettingsProfileFragment.getBaseProfiles(getMyApplication())
						.get(pos).getStringKey();
					setupBaseProfileView(key);
					profile.parent = ApplicationMode.valueOfStringKey(key, ApplicationMode.DEFAULT);
				}
			};
		}
		return baseTypeListener;
	}

	SelectProfileListener getNavProfileListener() {
		if (navTypeListener == null) {
			navTypeListener = new SelectProfileListener() {
				@Override
				public void onSelectedType(int pos) {
					updateRoutingProfile(pos);
				}
			};
		}
		return navTypeListener;
	}

	@Override
	public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
		super.onViewCreated(view, savedInstanceState);
		if (!isUserProfile && !isNew) {
			profileNameEt.setFocusable(false);
			navTypeEt.setFocusable(false);
		}

		if (isNew) {
			profileNameEt.requestFocus();
		} else {
			scrollContainer.requestFocus();
		}

	}

	void updateRoutingProfile(int pos) {
		isDataChanged = true;
		for (int i = 0; i < routingProfileDataObjects.size(); i++) {
			if (i == pos) {
				routingProfileDataObjects.get(i).setSelected(true);
			} else {
				routingProfileDataObjects.get(i).setSelected(false);
			}
		}
		selectedRoutingProfileDataObject = routingProfileDataObjects.get(pos);
		navTypeEt.setText(selectedRoutingProfileDataObject.getName());
		profile.routingProfileDataObject = selectedRoutingProfileDataObject;
	}

	void activateMode(ApplicationMode mode) {
		if (!ApplicationMode.values(app).contains(mode)) {
			ApplicationMode.changeProfileStatus(mode, true, getMyApplication());
		}
	}

	private void setupBaseProfileView(String stringKey) {
		for (ApplicationMode am : ApplicationMode.getDefaultValues()) {
			if (am.getStringKey().equals(stringKey)) {
				baseModeIcon.setImageDrawable(
					app.getUIUtilities().getIcon(am.getSmallIconDark(), R.color.icon_color));
				baseModeTitle.setText(Algorithms.capitalizeFirstLetter(am.toHumanString(app)));
				isDataChanged = false;
			}
		}
	}

	private void setMargins(View v, int l, int t, int r, int b) {
		if (v.getLayoutParams() instanceof ViewGroup.MarginLayoutParams) {
			ViewGroup.MarginLayoutParams p = (ViewGroup.MarginLayoutParams) v.getLayoutParams();
			p.setMargins(l, t, r, b);
			v.requestLayout();
		}
	}

	private boolean saveNewProfile() {
		if (profile.routingProfileDataObject == null) {
			showSaveWarningDialog(
				getString(R.string.profile_alert_need_routing_type_title),
				getString(R.string.profile_alert_need_routing_type_msg),
				getActivity());
			return false;
		}

		if (profile.userProfileTitle.isEmpty()
			|| profile.userProfileTitle.replace(" ", "").length() < 1) {
			showSaveWarningDialog(
				getString(R.string.profile_alert_need_profile_name_title),
				getString(R.string.profile_alert_need_profile_name_msg),
				getActivity()
			);
			return false;
		}

		for (ApplicationMode m : ApplicationMode.allPossibleValues()) {
			if (m.getUserProfileName() != null && getActivity() != null) {
				if (m.getUserProfileName().equals(profile.userProfileTitle)) {
					if (isNew || !Algorithms.isEmpty(mode.getUserProfileName())
						&& !mode.getUserProfileName().equals(profile.userProfileTitle)) {
						AlertDialog.Builder bld = new AlertDialog.Builder(getActivity());
						bld.setTitle(R.string.profile_alert_duplicate_name_title);
						bld.setMessage(R.string.profile_alert_duplicate_name_msg);
						bld.setNegativeButton(R.string.shared_string_dismiss, null);
						bld.show();
						bld.setOnDismissListener(new OnDismissListener() {
							@Override
							public void onDismiss(DialogInterface dialog) {
								profileNameEt.requestFocus();
							}
						});
						return false;
					}
				}
			}
		}

		if (isUserProfile && !isNew) {
			ApplicationMode.deleteCustomMode(mode.getUserProfileName(), getMyApplication());
		}

		String customStringKey = profile.stringKey;
		if (isNew && profile.parent != null) {
			customStringKey =
				profile.parent.getStringKey() + "_" + System.currentTimeMillis();
		}

		ApplicationMode.ApplicationModeBuilder builder = ApplicationMode
			.createCustomMode(profile.userProfileTitle.trim(), customStringKey)
			.parent(profile.parent)
			.icon(profile.iconId, profile.iconId);

		if (profile.routingProfileDataObject != null) {
			builder.setRoutingProfile(profile.routingProfileDataObject.getStringKey());
		}

		ApplicationMode mode = builder.customReg();
		ApplicationMode.saveCustomModeToSettings(getSettings());

		if (!ApplicationMode.values(app).contains(mode)) {
			boolean save = ApplicationMode.changeProfileStatus(mode, true, getMyApplication());

			if (save && getSettings() != null) {
				if (profile.routingProfileDataObject.getStringKey()
					.equals(RoutingProfilesResources.STRAIGHT_LINE_MODE.toString())) {
					getSettings().ROUTER_SERVICE.setModeValue(mode, RouteService.STRAIGHT);
				} else if (profile.routingProfileDataObject.getStringKey()
					.equals(RoutingProfilesResources.BROUTER_MODE.toString())) {
					getSettings().ROUTER_SERVICE.setModeValue(mode, RouteService.BROUTER);
				} else {
					getSettings().ROUTER_SERVICE.setModeValue(mode, RouteService.OSMAND);
				}
			}

		}
		isDataChanged = false;
		isCancelAllowed = true;
		return true;
	}

	private void needSaveDialog() {
		if (getActivity() != null) {
			AlertDialog.Builder bld = new AlertDialog.Builder(getActivity());
			bld.setTitle(R.string.profile_alert_need_save_title);
			bld.setMessage(R.string.profile_alert_need_save_msg);
			bld.setNegativeButton(R.string.shared_string_ok, null);
			bld.show();
		}
	}

	private void showSaveWarningDialog(String title, String message, Activity activity) {
		AlertDialog.Builder bld = new AlertDialog.Builder(activity);
		bld.setTitle(title);
		bld.setMessage(message);
		bld.setNegativeButton(R.string.shared_string_dismiss, null);
		bld.show();
	}

	void confirmCancelDialog(final Activity activity) {
		AlertDialog.Builder bld = new Builder(activity);
		bld.setTitle(R.string.shared_string_dismiss);
		bld.setMessage(R.string.exit_without_saving);
		bld.setPositiveButton(R.string.shared_string_ok, new DialogInterface.OnClickListener() {
			@Override
			public void onClick(DialogInterface dialog, int which) {
				isCancelAllowed = true;
				activity.onBackPressed();
			}
		});
		bld.setNegativeButton(R.string.shared_string_cancel, null);
		bld.show();

	}

	void onDeleteProfileClick() {
		if (getActivity() != null) {
			if (isUserProfile) {
				AlertDialog.Builder bld = new AlertDialog.Builder(getActivity());
				bld.setTitle(R.string.profile_alert_delete_title);
				bld.setMessage(String
					.format(getString(R.string.profile_alert_delete_msg),
						profile.userProfileTitle));
				bld.setPositiveButton(R.string.shared_string_delete,
					new DialogInterface.OnClickListener() {
						@Override
						public void onClick(DialogInterface dialog, int which) {
							ApplicationMode
								.deleteCustomMode(profile.userProfileTitle, getMyApplication());
							if (getActivity() != null) {
								getActivity().onBackPressed();
							}
							getSettings().APPLICATION_MODE.set(ApplicationMode.DEFAULT);
						}
					});
				bld.setNegativeButton(R.string.shared_string_dismiss, null);
				bld.show();
			} else {
				Toast.makeText(getActivity(), R.string.profile_alert_cant_delete_base,
					Toast.LENGTH_SHORT).show();
			}
		}
	}

	static List<RoutingProfileDataObject> getRoutingProfiles(OsmandApplication context) {
		List<RoutingProfileDataObject> profilesObjects = new ArrayList<>();
		profilesObjects.add(new RoutingProfileDataObject(
			RoutingProfilesResources.STRAIGHT_LINE_MODE.toString(),
			context.getString(RoutingProfilesResources.STRAIGHT_LINE_MODE.getStringRes()),
			context.getString(R.string.special_routing_type),
			RoutingProfilesResources.STRAIGHT_LINE_MODE.getIconRes(),
			false, null));
		if (context.getBRouterService() != null) {
			profilesObjects.add(new RoutingProfileDataObject(
				RoutingProfilesResources.BROUTER_MODE.toString(),
				context.getString(RoutingProfilesResources.BROUTER_MODE.getStringRes()),
				context.getString(R.string.third_party_routing_type),
				RoutingProfilesResources.BROUTER_MODE.getIconRes(),
				false, null));
		}

		Map<String, GeneralRouter> inputProfiles = context.getRoutingConfig().getAllRouters();
		for (Entry<String, GeneralRouter> e : inputProfiles.entrySet()) {
			int iconRes = R.drawable.ic_action_gdirections_dark;
			String name = e.getValue().getProfileName();
			String description = context.getString(R.string.osmand_default_routing);
			if (RoutingProfilesResources.isRpValue(name.toUpperCase())){
				iconRes = RoutingProfilesResources.valueOf(name.toUpperCase()).getIconRes();
				name = context
					.getString(RoutingProfilesResources.valueOf(name.toUpperCase()).getStringRes());
			} else if (!Algorithms.isEmpty(e.getValue().getFilename())) {
				description = e.getValue().getFilename();
			}
			profilesObjects.add(new RoutingProfileDataObject(e.getKey(), name, description,
				iconRes, false, e.getValue().getFilename()));
		}
		return profilesObjects;
	}

	public enum RoutingProfilesResources {
		STRAIGHT_LINE_MODE(R.string.routing_profile_straightline,R.drawable.ic_action_split_interval),
		BROUTER_MODE(R.string.routing_profile_broutrer, R.drawable.ic_action_split_interval),
		CAR(R.string.rendering_value_car_name, R.drawable.ic_action_car_dark),
		PEDESTRIAN(R.string.rendering_value_pedestrian_name, R.drawable.map_action_pedestrian_dark),
		BICYCLE(R.string.rendering_value_bicycle_name, R.drawable.map_action_bicycle_dark),
		SKI(R.string.routing_profile_ski, R.drawable.ic_plugin_skimaps),
		PUBLIC_TRANSPORT(R.string.app_mode_public_transport, R.drawable.map_action_bus_dark),
		BOAT(R.string.app_mode_boat, R.drawable.map_action_sail_boat_dark),
		GEOCODING(R.string.routing_profile_geocoding, R.drawable.ic_action_world_globe);

		int stringRes;
		int iconRes;

		RoutingProfilesResources(int stringRes, int iconRes) {
			this.stringRes = stringRes;
			this.iconRes = iconRes;
		}

		public int getStringRes() {
			return stringRes;
		}

		public int getIconRes() {
			return iconRes;
		}

		private static final List<String> rpValues = new ArrayList<>();

		static {
			for (RoutingProfilesResources rpr : RoutingProfilesResources.values()) {
				rpValues.add(rpr.name());
			}
		}

		public static boolean isRpValue(String value) {
			return rpValues.contains(value);
		}
	}

	private class ApplicationProfileObject {

		int key = -1;
		String stringKey;
		String userProfileTitle = "";
		ApplicationMode parent = null;
		int iconId = R.drawable.map_world_globe_dark;
		RoutingProfileDataObject routingProfileDataObject = null;

		ApplicationProfileObject(ApplicationMode mode, boolean isNew, boolean isUserProfile) {
			if (isNew) {
				stringKey = mode.getStringKey() + System.currentTimeMillis();
				parent = mode;
			} else if (isUserProfile) {
				stringKey = mode.getStringKey();
				parent = mode.getParent();
				iconId = mode.getSmallIconDark();
				userProfileTitle = mode.getUserProfileName();
			} else {
				key = mode.getStringResource();
				stringKey = mode.getStringKey();
				iconId = mode.getSmallIconDark();
			}
		}
	}
}
!@#$%
