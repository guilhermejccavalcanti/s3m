C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_b10740;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_a10740;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_c10740
<<<<<<< MINE
    implements OnClickListener, AdapterView.OnItemClickListener, AnimationListener {
=======
    implements OnClickListener, AdapterView.OnItemClickListener, AnimationListener, Progressable {
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_b10740;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_a10740;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_c10740
<<<<<<< MINE
            final MessageReference ref = data.getParcelableExtra(ChooseFolder.EXTRA_MESSAGE);
=======
            final MessageReference ref = (MessageReference)data.getSerializableExtra(ChooseFolder.EXTRA_MESSAGE);
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_b10740;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_a10740;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_c10740
<<<<<<< MINE
=======
        case R.id.export:
            onExport(mAccount);
            return true;

        case R.id.export_all:
            onExport(null);
            return true;

>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_b10740;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_a10740;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_c10740
<<<<<<< MINE
=======

            @Override
            public void systemStatusChanged() {
                mHandler.refreshTitle();
            }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_b10740;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_a10740;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_c10740
<<<<<<< MINE
=======
        private static final int NON_MESSAGE_ITEMS = 1;

>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_b10740;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_a10740;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_c10740
<<<<<<< MINE
=======

            if (position == mAdapter.messages.size()) {
                return getFooterView(position, convertView, parent);
            } else {
                return  getItemView(position, convertView, parent);
            }
        }

        public View getItemView(int position, View convertView, ViewGroup parent) {
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_b10740;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_a10740;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_c10740
<<<<<<< MINE
=======
        public View getFooterView(int position, View convertView, ViewGroup parent) {
            if (footerView == null) {
                footerView = mInflater.inflate(R.layout.message_list_item_footer, parent, false);
                if (mQueryString != null) {
                    footerView.setVisibility(View.GONE);
                }
                footerView.setId(R.layout.message_list_item_footer);
                FooterViewHolder holder = new FooterViewHolder();
                holder.progress = (ProgressBar)footerView.findViewById(R.id.message_list_progress);
                holder.progress.setIndeterminate(true);
                holder.main = (TextView)footerView.findViewById(R.id.main_text);
                footerView.setTag(holder);
            }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_b10740;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_a10740;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_c10740
<<<<<<< MINE
=======
            FooterViewHolder holder = (FooterViewHolder)footerView.getTag();

            if (mCurrentFolder != null && mAccount != null) {
                if (mCurrentFolder.loading) {
                    holder.main.setText(getString(R.string.status_loading_more));
                    holder.progress.setVisibility(ProgressBar.VISIBLE);
                } else {
                    if (!mCurrentFolder.lastCheckFailed) {
                        if (mAccount.getDisplayCount() == 0) {
                            holder.main.setText(getString(R.string.message_list_load_more_messages_action));
                        } else {
                            holder.main.setText(String.format(getString(R.string.load_more_messages_fmt), mAccount.getDisplayCount()));
                        }
                    } else {
                        holder.main.setText(getString(R.string.status_loading_more_failed));
                    }
                    holder.progress.setVisibility(ProgressBar.INVISIBLE);
                }
            } else {
                holder.progress.setVisibility(ProgressBar.INVISIBLE);
            }

            return footerView;
        }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_b10740;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_a10740;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_c10740
<<<<<<< MINE

    private View getFooterView(ViewGroup parent) {
        if (mFooterView == null) {
            mFooterView = mInflater.inflate(R.layout.message_list_item_footer, parent, false);
            if (mQueryString != null) {
                mFooterView.setVisibility(View.GONE);
            }
            mFooterView.setId(R.layout.message_list_item_footer);
            FooterViewHolder holder = new FooterViewHolder();
            holder.progress = (ProgressBar) mFooterView.findViewById(R.id.message_list_progress);
            holder.progress.setIndeterminate(true);
            holder.main = (TextView) mFooterView.findViewById(R.id.main_text);
            mFooterView.setTag(holder);
        }

        return mFooterView;
    }

    private void updateFooterView() {
        FooterViewHolder holder = (FooterViewHolder) mFooterView.getTag();

        if (mCurrentFolder != null && mAccount != null) {
            if (mCurrentFolder.loading) {
                holder.main.setText(getString(R.string.status_loading_more));
                holder.progress.setVisibility(ProgressBar.VISIBLE);
            } else {
                if (!mCurrentFolder.lastCheckFailed) {
                    if (mAccount.getDisplayCount() == 0) {
                        holder.main.setText(getString(R.string.message_list_load_more_messages_action));
                    } else {
                        holder.main.setText(String.format(getString(R.string.load_more_messages_fmt), mAccount.getDisplayCount()));
                    }
                } else {
                    holder.main.setText(getString(R.string.status_loading_more_failed));
                }
                holder.progress.setVisibility(ProgressBar.INVISIBLE);
            }
        } else {
            holder.progress.setVisibility(ProgressBar.INVISIBLE);
        }
    }

=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_b02500;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_a02500;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_c02500
<<<<<<< MINE
import java.util.*;
=======
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Locale;
import java.util.Stack;
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_b10932;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_a10932;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_c10932
<<<<<<< MINE
        //s.put("messageFormatAuto", new BooleanSetting(Account.DEFAULT_MESSAGE_FORMAT_AUTO)); // added to version 2
=======
        s.put("messageFormatAuto", new BooleanSetting(Account.DEFAULT_MESSAGE_FORMAT_AUTO)); // added to version 2
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_b05080;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_a05080;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_c05080
<<<<<<< MINE
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Stack;
=======
import java.util.*;
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_b04340;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_a04340;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_c04340
<<<<<<< MINE
import android.view.ContextMenu;
import android.view.ContextMenu.ContextMenuInfo;
import android.view.GestureDetector;
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_b04340;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_a04340;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_c04340
<<<<<<< MINE
    private void onToggleFlag(MessageInfoHolder messageInfo) {
        LocalMessage message = messageInfo.message;
        Folder folder = message.getFolder();
        Account account = folder.getAccount();
        String folderName = folder.getName();
=======
    private void onToggleRead(final List<MessageInfoHolder> holders) {
        Message message;
        Folder folder;
        Account account;
        String folderName;
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_b04340;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_a04340;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_c04340
<<<<<<< MINE
        computeBatchDirection();
=======
            messageInfo.read = !messageInfo.read;
            mAdapter.sortMessages();
        }
    }

    private void onToggleFlag(final List<MessageInfoHolder> holders) {
        Message message;
        Folder folder;
        Account account;
        String folderName;

        int i = 0;
        for (final Iterator<MessageInfoHolder> iterator = holders.iterator(); iterator.hasNext(); i++) {
            final MessageInfoHolder messageInfo = iterator.next();
            message = messageInfo.message;
            folder = message.getFolder();
            account = folder.getAccount();
            folderName = message.getFolder().getName();

            mController.setFlag(account, folderName, new Message[]{message}, Flag.FLAGGED, !messageInfo.flagged);

            messageInfo.flagged = !messageInfo.flagged;
            mAdapter.sortMessages();
        }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_b07652;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_a07652;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_c07652
<<<<<<< MINE
import com.fsck.k9.provider.EmailProvider;
import com.fsck.k9.provider.EmailProvider.MessageColumns;
=======
import com.fsck.k9.mail.store.LocalStore.LocalMessage;
import com.fsck.k9.search.ConditionsTreeNode;
import com.fsck.k9.search.LocalSearch;
import com.fsck.k9.search.SearchSpecification;
import com.fsck.k9.search.SearchSpecification.ATTRIBUTE;
import com.fsck.k9.search.SearchSpecification.SEARCHFIELD;
import com.fsck.k9.search.SearchSpecification.SearchCondition;
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_b07652;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_a07652;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_c07652
<<<<<<< MINE

=======
    
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_b07652;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_a07652;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_c07652
<<<<<<< MINE
    class MessageListAdapter extends CursorAdapter {
=======
        public List<Message> mExtraSearchResults;

        private final ActivityListener mListener = new ActivityListener() {

            @Override
            public void remoteSearchAddMessage(Account account, String folderName, Message message, final int numDone, final int numTotal) {

                if (numTotal > 0 && numDone < numTotal) {
                    mFragmentListener.setMessageListProgress(Window.PROGRESS_END / numTotal * numDone);
                } else {
                    mFragmentListener.setMessageListProgress(Window.PROGRESS_END);
                }

                mHandler.addOrUpdateMessages(account, folderName, Collections.singletonList(message), false);
            }

            @Override
            public void remoteSearchFailed(Account acct, String folder, final String err) {
                //TODO: Better error handling
                mHandler.post(new Runnable() {
                    @Override
                    public void run() {
                        Toast.makeText(getActivity(), err, Toast.LENGTH_LONG).show();
                    }
                });
            }

            @Override
            public void remoteSearchStarted(Account acct, String folder) {
                mHandler.progress(true);
                mHandler.updateFooter(mContext.getString(R.string.remote_search_sending_query), true);
            }


            @Override
            public void remoteSearchFinished(Account acct, String folder, int numResults, List<Message> extraResults) {
                mHandler.progress(false);
                if (extraResults != null && extraResults.size() > 0) {
                    mExtraSearchResults = extraResults;
                    mHandler.updateFooter(String.format(mContext.getString(R.string.load_more_messages_fmt), acct.getRemoteSearchNumResults()), false);
                } else {
                    mHandler.updateFooter("", false);
                }
                mFragmentListener.setMessageListProgress(Window.PROGRESS_END);

            }

            @Override
            public void remoteSearchServerQueryComplete(Account account, String folderName, int numResults) {
                mHandler.progress(true);
                if (account != null &&  account.getRemoteSearchNumResults() != 0 && numResults > account.getRemoteSearchNumResults()) {
                    mHandler.updateFooter(mContext.getString(R.string.remote_search_downloading_limited, account.getRemoteSearchNumResults(), numResults), true);
                } else {
                    mHandler.updateFooter(mContext.getString(R.string.remote_search_downloading, numResults), true);
                }
                mFragmentListener.setMessageListProgress(Window.PROGRESS_START);
            }

            @Override
            public void informUserOfStatus() {
                mHandler.refreshTitle();
            }

            @Override
            public void synchronizeMailboxStarted(Account account, String folder) {
                if (updateForMe(account, folder)) {
                    mHandler.progress(true);
                    mHandler.folderLoading(folder, true);
                }
                super.synchronizeMailboxStarted(account, folder);
            }

            @Override
            public void synchronizeMailboxFinished(Account account, String folder,
            int totalMessagesInMailbox, int numNewMessages) {

                if (updateForMe(account, folder)) {
                    mHandler.progress(false);
                    mHandler.folderLoading(folder, false);
                    mHandler.sortMessages();
                }
                super.synchronizeMailboxFinished(account, folder, totalMessagesInMailbox, numNewMessages);
            }

            @Override
            public void synchronizeMailboxFailed(Account account, String folder, String message) {

                if (updateForMe(account, folder)) {
                    mHandler.progress(false);
                    mHandler.folderLoading(folder, false);
                    mHandler.sortMessages();
                }
                super.synchronizeMailboxFailed(account, folder, message);
            }

            @Override
            public void synchronizeMailboxAddOrUpdateMessage(Account account, String folder, Message message) {
                mHandler.addOrUpdateMessages(account, folder, Collections.singletonList(message), true);
            }

            @Override
            public void synchronizeMailboxRemovedMessage(Account account, String folder, Message message) {
                mHandler.removeMessage(message.makeMessageReference());
            }

            @Override
            public void listLocalMessagesStarted(Account account, String folder) {
                if ((!mSingleAccountMode && folder == null) || (account != null && account.equals(mAccount))) {
                    mHandler.progress(true);
                    if (folder != null) {
                        mHandler.folderLoading(folder, true);
                    }
                }
            }

            @Override
            public void listLocalMessagesFailed(Account account, String folder, String message) {
                if ((!mSingleAccountMode && folder == null) || (account != null && account.equals(mAccount))) {
                    mHandler.sortMessages();
                    mHandler.progress(false);
                    if (folder != null) {
                        mHandler.folderLoading(folder, false);
                    }
                }
            }

            @Override
            public void listLocalMessagesFinished(Account account, String folder) {
                if ((!mSingleAccountMode && folder == null) || (account != null && account.equals(mAccount))) {
                    mHandler.sortMessages();
                    mHandler.progress(false);
                    if (folder != null) {
                        mHandler.folderLoading(folder, false);
                    }
                }
            }

            @Override
            public void listLocalMessagesRemoveMessage(Account account, String folder, Message message) {
                mHandler.removeMessage(message.makeMessageReference());
            }

            @Override
            public void listLocalMessagesAddMessages(Account account, String folder, List<Message> messages) {
                mHandler.addOrUpdateMessages(account, folder, messages, false);
            }

            @Override
            public void listLocalMessagesUpdateMessage(Account account, String folder, Message message) {
                mHandler.addOrUpdateMessages(account, folder, Collections.singletonList(message), false);
            }

            @Override
            public void searchStats(AccountStats stats) {
                mUnreadMessageCount = stats.unreadMessageCount;
                super.searchStats(stats);
            }

            @Override
            public void folderStatusChanged(Account account, String folder, int unreadMessageCount) {
                if (updateForMe(account, folder)) {
                    mUnreadMessageCount = unreadMessageCount;
                }
                super.folderStatusChanged(account, folder, unreadMessageCount);
            }

            @Override
            public void messageUidChanged(Account account, String folder, String oldUid, String newUid) {
                MessageReference ref = new MessageReference();
                ref.accountUuid = account.getUuid();
                ref.folderName = folder;
                ref.uid = oldUid;

                mHandler.changeMessageUid(ref, newUid);
            }
        };

        private boolean updateForMe(Account account, String folder) {     	
        	// TODO get a contentprovider :D
        	return true;
        	
        	/*
            if ((account.equals(mAccount) && mFolderName != null && folder.equals(mFolderName))) {
                return true;
            } else {
                return false;
            }
            */
        }

        public List<MessageInfoHolder> getMessages() {
            return mMessages;
        }

        public void restoreMessages(List<MessageInfoHolder> messages) {
            mMessages.addAll(messages);
        }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_b07652;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_a07652;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_c07652
<<<<<<< MINE
            //notifyDataSetChanged();
=======
            notifyDataSetChanged();
        }

        public void addMessages(final List<MessageInfoHolder> messages) {
            if (messages.isEmpty()) {
                return;
            }

            final boolean wasEmpty = mMessages.isEmpty();

            for (final MessageInfoHolder message : messages) {
                if (mFolderName == null || (message.folder != null && message.folder.name.equals(mFolderName))) {
                    int index = Collections.binarySearch(mMessages, message, getComparator());

                    if (index < 0) {
                        index = (index * -1) - 1;
                    }

                    mMessages.add(index, message);
                }
            }

            if (wasEmpty) {
                mListView.setSelection(0);
            }
            resetUnreadCount();

            notifyDataSetChanged();
            computeSelectAllVisibility();
        }

        public void changeMessageUid(MessageReference ref, String newUid) {
            MessageInfoHolder holder = getMessage(ref);
            if (holder != null) {
                holder.uid = newUid;
                holder.message.setUid(newUid);
            }
        }

        public void resetUnreadCount() {
            if (!mSingleFolderMode) {
                int unreadCount = 0;

                for (MessageInfoHolder holder : mMessages) {
                    unreadCount += holder.read ? 0 : 1;
                }

                mUnreadMessageCount = unreadCount;
                refreshTitle();
            }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_b07652;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_a07652;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_c07652
<<<<<<< MINE
        private String recipientSigil(boolean toMe, boolean ccMe) {
            if (toMe) {
=======
        public void addOrUpdateMessages(final Account account, final String folderName,
                final List<Message> messages, final boolean verifyAgainstSearch) {

            boolean needsSort = false;
            final List<MessageInfoHolder> messagesToAdd = new ArrayList<MessageInfoHolder>();
            List<MessageInfoHolder> messagesToRemove = new ArrayList<MessageInfoHolder>();
            List<Message> messagesToSearch = new ArrayList<Message>();

            // cache field into local variable for faster access for JVM without JIT
            final MessageHelper messageHelper = mMessageHelper;

            for (Message message : messages) {
                MessageInfoHolder m = getMessage(message);
                if (message.isSet(Flag.DELETED)) {
                    if (m != null) {
                        messagesToRemove.add(m);
                    }
                } else {
                    final Folder messageFolder = message.getFolder();
                    final Account messageAccount = messageFolder.getAccount();
                    if (m == null) {
                        if (updateForMe(account, folderName)) {
                            m = new MessageInfoHolder();
                            FolderInfoHolder folderInfoHolder = new FolderInfoHolder(
                                    mContext, messageFolder, messageAccount);
                            messageHelper.populate(m, message, folderInfoHolder, messageAccount);

                            if (verifyAgainstSearch) {
                                LocalMessage localMessage = (LocalMessage) message;

                                if (mThreadId != -1) {
                                    if (localMessage.getRootId() == mThreadId ||
                                            localMessage.getId() == mThreadId) {
                                        messagesToAdd.add(m);
                                    }
                                } else if (mThreadViewEnabled) {
                                    long threadId = localMessage.getRootId();
                                    if (threadId == -1) {
                                        threadId = localMessage.getId();
                                    }

                                    MessageInfoHolder threadPlaceHolder = getThread(threadId);
                                    if (threadPlaceHolder == null) {
                                        messagesToAdd.add(m);
                                    } else if (m.compareDate.after(threadPlaceHolder.compareDate)) {
                                        messagesToRemove.add(threadPlaceHolder);
                                        messagesToAdd.add(m);
                                    } else {
                                        threadPlaceHolder.threadCount = m.threadCount;
                                    }
                                } else {
                                    messagesToAdd.add(m);
                                }
                            } else {
                                messagesToAdd.add(m);
                            }
                        } /*else {
                            if (mQueryString != null) {
                                if (verifyAgainstSearch) {
                                    messagesToSearch.add(message);
                                } else {
                                    m = new MessageInfoHolder();
                                    FolderInfoHolder folderInfoHolder = new FolderInfoHolder(
                                            mContext, messageFolder, messageAccount);
                                    messageHelper.populate(m, message, folderInfoHolder,
                                            messageAccount);
                                    messagesToAdd.add(m);
                                }
                            }
                        }*/
                    } else {
                        m.dirty = false; // as we reload the message, unset its dirty flag
                        FolderInfoHolder folderInfoHolder = new FolderInfoHolder(mContext,
                                messageFolder, account);
                        messageHelper.populate(m, message, folderInfoHolder, account);
                        needsSort = true;
                    }
                }
            }

            if (!messagesToSearch.isEmpty()) {
            	// building a tree with all possible message id's we want to search in
            	ConditionsTreeNode msgIdTree = new ConditionsTreeNode(
            			new SearchCondition(SEARCHFIELD.UID, ATTRIBUTE.EQUALS, 
            					String.valueOf(messagesToSearch.get(0).getUid())));
            	
            	if (messagesToSearch.size() > 1) {
            		for(int i=1; i<messagesToSearch.size(); ++i) {
            			msgIdTree.or(new SearchCondition(SEARCHFIELD.UID, ATTRIBUTE.EQUALS, 
            					String.valueOf(messagesToSearch.get(i).getUid())));		
            		}
            	}
            	
            	// construct a new search with existing conditions and the message id narrowing
            	LocalSearch tmpSearch = null;
            	try {
            		tmpSearch = new LocalSearch(MessageListFragment.this.mSearch.getName());
					tmpSearch.and(msgIdTree);					
				} catch (Exception e) {
					// impossible, we created it here locally, parent = null
				}
            	
            	// search
                mController.searchLocalMessages(tmpSearch,
                new MessagingListener() {
                    @Override
                    public void listLocalMessagesAddMessages(Account account, String folder,
                            List<Message> messages) {
                        mHandler.addOrUpdateMessages(account, folder, messages, false);
                    }
                });
            }

            if (!messagesToRemove.isEmpty()) {
                removeMessages(messagesToRemove);
            }

            if (!messagesToAdd.isEmpty()) {
                addMessages(messagesToAdd);
            }

            if (needsSort) {
                sortMessages();
                resetUnreadCount();
            }
        }

        /**
         * Find a specific message in the message list.
         *
         * <p><strong>Note:</strong>
         * This method was optimized because it is called a lot. Don't change it unless you know
         * what you are doing.</p>
         *
         * @param message
         *         A {@link Message} instance describing the message to look for.
         *
         * @return The corresponding {@link MessageInfoHolder} instance if the message was found in
         *         the message list. {@code null} otherwise.
         */
        private MessageInfoHolder getMessage(Message message) {
            String uid;
            Folder folder;
            for (MessageInfoHolder holder : mMessages) {
                uid = message.getUid();
                if (uid != null && (holder.uid == uid || uid.equals(holder.uid))) {
                    folder = message.getFolder();
                     if (holder.folder.name.equals(folder.getName()) &&
                             holder.account.equals(folder.getAccount().getUuid())) {
                         return holder;
                     }
                }
            }

            return null;
        }

        /**
         * Find a specific message in the message list.
         *
         * <p><strong>Note:</strong>
         * This method was optimized because it is called a lot. Don't change it unless you know
         * what you are doing.</p>
         *
         * @param messageReference
         *         A {@link MessageReference} instance describing the message to look for.
         *
         * @return The corresponding {@link MessageInfoHolder} instance if the message was found in
         *         the message list. {@code null} otherwise.
         */
        private MessageInfoHolder getMessage(MessageReference messageReference) {
            String uid;
            for (MessageInfoHolder holder : mMessages) {
                uid = messageReference.uid;
                if ((holder.uid == uid || uid.equals(holder.uid)) &&
                        holder.folder.name.equals(messageReference.folderName) &&
                        holder.account.equals(messageReference.accountUuid)) {
                     return holder;
                }
            }

            return null;
        }

        private MessageInfoHolder getThread(long threadId) {
            for (MessageInfoHolder holder : mMessages) {
                LocalMessage localMessage = (LocalMessage) holder.message;
                if (localMessage.getId() == threadId || localMessage.getRootId() == threadId) {
                    return holder;
                }
            }

            return null;
        }

        @Override
        public int getCount() {
            return mMessages.size();
        }

        @Override
        public long getItemId(int position) {
            try {
                MessageInfoHolder messageHolder = (MessageInfoHolder) getItem(position);
                if (messageHolder != null) {
                    return messageHolder.message.getId();
                }
            } catch (Exception e) {
                Log.i(K9.LOG_TAG, "getItemId(" + position + ") ", e);
            }
            return -1;
        }

        @Override
        public Object getItem(int position) {
            try {
                if (position < mMessages.size()) {
                    return mMessages.get(position);
                }
            } catch (Exception e) {
                Log.e(K9.LOG_TAG, "getItem(" + position + "), but folder.messages.size() = " + mMessages.size(), e);
            }
            return null;
        }

        @Override
        public View getView(int position, View convertView, ViewGroup parent) {
            MessageInfoHolder message = (MessageInfoHolder) getItem(position);
            View view;

            if ((convertView != null) && (convertView.getId() == R.layout.message_list_item)) {
                view = convertView;
            } else {
                view = mInflater.inflate(R.layout.message_list_item, parent, false);
                view.setId(R.layout.message_list_item);
            }

            MessageViewHolder holder = (MessageViewHolder) view.getTag();

            if (holder == null) {
                holder = new MessageViewHolder();
                holder.date = (TextView) view.findViewById(R.id.date);
                holder.chip = view.findViewById(R.id.chip);
                holder.preview = (TextView) view.findViewById(R.id.preview);

                if (mSenderAboveSubject) {
                    holder.from = (TextView) view.findViewById(R.id.subject);
                    holder.from.setTextSize(TypedValue.COMPLEX_UNIT_SP, mFontSizes.getMessageListSender());
                } else {
                    holder.subject = (TextView) view.findViewById(R.id.subject);
                    holder.subject.setTextSize(TypedValue.COMPLEX_UNIT_SP, mFontSizes.getMessageListSubject());
                }

                holder.date.setTextSize(TypedValue.COMPLEX_UNIT_SP, mFontSizes.getMessageListDate());

                holder.preview.setLines(mPreviewLines);
                holder.preview.setTextSize(TypedValue.COMPLEX_UNIT_SP, mFontSizes.getMessageListPreview());
                holder.threadCount = (TextView) view.findViewById(R.id.thread_count);

                view.setTag(holder);
            }

            if (message != null) {
                bindView(position, view, holder, message);
            } else {
                // This branch code is triggered when the local store
                // hands us an invalid message

                holder.chip.getBackground().setAlpha(0);
                if (holder.subject != null) {
                    holder.subject.setText(getString(R.string.general_no_subject));
                    holder.subject.setTypeface(null, Typeface.NORMAL);
                }

                String noSender = getString(R.string.general_no_sender);

                if (holder.preview != null) {
                    holder.preview.setText(noSender, TextView.BufferType.SPANNABLE);
                    Spannable str = (Spannable) holder.preview.getText();

                    str.setSpan(new StyleSpan(Typeface.NORMAL),
                                0,
                                noSender.length(),
                                Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
                    str.setSpan(new AbsoluteSizeSpan(mFontSizes.getMessageListSender(), true),
                                0,
                                noSender.length(),
                                Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
                } else {
                    holder.from.setText(noSender);
                    holder.from.setTypeface(null, Typeface.NORMAL);
                    holder.from.setCompoundDrawablesWithIntrinsicBounds(null, null, null, null);
                }

                holder.date.setText(getString(R.string.general_no_date));

                //WARNING: Order of the next 2 lines matter
                holder.position = -1;
            }


            return view;
        }

        /**
         * Associate model data to view object.
         *
         * @param position
         *            The position of the item within the adapter's data set of
         *            the item whose view we want.
         * @param view
         *            Main view component to alter. Never <code>null</code>.
         * @param holder
         *            Convenience view holder - eases access to <tt>view</tt>
         *            child views. Never <code>null</code>.
         * @param message
         *            Never <code>null</code>.
         */



        private void bindView(final int position, final View view, final MessageViewHolder holder,
                              final MessageInfoHolder message) {

            int maybeBoldTypeface = message.read ? Typeface.NORMAL : Typeface.BOLD;

            // So that the mSelectedCount is only incremented/decremented
            // when a user checks the checkbox (vs code)
            holder.position = -1;

            if (message.selected) {

            holder.chip.setBackgroundDrawable(message.message.getFolder().getAccount().getCheckmarkChip().drawable());
            }

            else {
            holder.chip.setBackgroundDrawable(message.message.getFolder().getAccount().generateColorChip(message.read,message.message.toMe(), message.message.ccMe(), message.message.fromMe(), message.flagged).drawable());

            }

            if (K9.useBackgroundAsUnreadIndicator()) {
                int res = (message.read) ? R.attr.messageListReadItemBackgroundColor :
                        R.attr.messageListUnreadItemBackgroundColor;

                TypedValue outValue = new TypedValue();
                getActivity().getTheme().resolveAttribute(res, outValue, true);
                view.setBackgroundColor(outValue.data);
            }

            String subject = null;

            if ((message.message.getSubject() == null) || message.message.getSubject().equals("")) {
                subject = (String) getText(R.string.general_no_subject);

            } else {
                subject = message.message.getSubject();
            }

            int threadCount = message.threadCount;
            if (mThreadId == -1 && threadCount > 1) {
                holder.threadCount.setText(Integer.toString(threadCount));
                holder.threadCount.setVisibility(View.VISIBLE);
            } else {
                holder.threadCount.setVisibility(View.GONE);
            }


            // We'll get badge support soon --jrv
//            if (holder.badge != null) {
//                String email = message.counterpartyAddress;
//                holder.badge.assignContactFromEmail(email, true);
//                if (email != null) {
//                    mContactsPictureLoader.loadContactPicture(email, holder.badge);
//                }
//            }

            if (holder.preview != null) {
                /*
                 * In the touchable UI, we have previews. Otherwise, we
                 * have just a "from" line.
                 * Because text views can't wrap around each other(?) we
                 * compose a custom view containing the preview and the
                 * from.
                 */

                CharSequence beforePreviewText = null;
                if (mSenderAboveSubject) {
                    beforePreviewText = subject;
                } else {
                    beforePreviewText = message.sender;
                }

                holder.preview.setText(new SpannableStringBuilder(recipientSigil(message))
                                       .append(beforePreviewText).append(" ").append(message.message.getPreview()),
                                       TextView.BufferType.SPANNABLE);
                Spannable str = (Spannable)holder.preview.getText();

                // Create a span section for the sender, and assign the correct font size and weight.
                str.setSpan(new AbsoluteSizeSpan((mSenderAboveSubject ? mFontSizes.getMessageListSubject(): mFontSizes.getMessageListSender()), true),
                            0, beforePreviewText.length() + 1, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);

                int color = (K9.getK9Theme() == K9.THEME_LIGHT) ?
                        Color.rgb(105, 105, 105) :
                        Color.rgb(160, 160, 160);

                // set span for preview message.
                str.setSpan(new ForegroundColorSpan(color), // How do I can specify the android.R.attr.textColorTertiary
                            beforePreviewText.length() + 1,
                            str.length(),
                            Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
            }


            if (holder.from != null ) {
                holder.from.setTypeface(null, maybeBoldTypeface);
                if (mSenderAboveSubject) {
                    holder.from.setCompoundDrawablesWithIntrinsicBounds(
                            message.answered ? mAnsweredIcon : null, // left
                            null, // top
                            message.message.hasAttachments() ? mAttachmentIcon : null, // right
                            null); // bottom

                    holder.from.setText(message.sender);
                } else {
                    holder.from.setText(new SpannableStringBuilder(recipientSigil(message)).append(message.sender));
                }
            }

            if (holder.subject != null ) {
                if (!mSenderAboveSubject) {
                    holder.subject.setCompoundDrawablesWithIntrinsicBounds(
                            message.answered ? mAnsweredIcon : null, // left
                            null, // top
                            message.message.hasAttachments() ? mAttachmentIcon : null, // right
                            null); // bottom
                }

                holder.subject.setTypeface(null, maybeBoldTypeface);
                holder.subject.setText(subject);
            }

            holder.date.setText(message.getDate(mMessageHelper));
            holder.position = position;
        }


        private String recipientSigil(MessageInfoHolder message) {
            if (message.message.toMe()) {
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_b06096;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_a06096;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_c06096
<<<<<<< MINE
=======
import android.widget.BaseAdapter;
import android.widget.CheckBox;
import android.widget.CompoundButton;
import android.widget.CompoundButton.OnCheckedChangeListener;
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_b06096;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_a06096;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_c06096
<<<<<<< MINE
        private String recipientSigil(boolean toMe, boolean ccMe) {
            if (toMe) {
=======
        public void markAllMessagesAsDirty() {
            for (MessageInfoHolder holder : mMessages) {
                holder.dirty = true;
            }
        }

        public void pruneDirtyMessages() {
            List<MessageInfoHolder> messagesToRemove = new ArrayList<MessageInfoHolder>();

            for (MessageInfoHolder holder : mMessages) {
                if (holder.dirty) {
                    messagesToRemove.add(holder);
                }
            }
            removeMessages(messagesToRemove);
        }

        public void removeMessage(MessageReference messageReference) {
            MessageInfoHolder holder = getMessage(messageReference);
            if (holder == null) {
                Log.w(K9.LOG_TAG, "Got callback to remove non-existent message with UID " +
                        messageReference.uid);
            } else {
                removeMessages(Collections.singletonList(holder));
            }
        }

        public void removeMessages(final List<MessageInfoHolder> messages) {
            if (messages.isEmpty()) {
                return;
            }

            for (MessageInfoHolder message : messages) {
                if (message != null && (mFolderName == null || (
                        message.folder != null &&
                        message.folder.name.equals(mFolderName)))) {
                    if (message.selected && mSelectedCount > 0) {
                        mSelectedCount--;
                    }
                    mMessages.remove(message);
                }
            }
            resetUnreadCount();

            notifyDataSetChanged();
            computeSelectAllVisibility();
        }

        /**
         * Set the selection state for all messages at once.
         * @param selected Selection state to set.
         */
        public void setSelectionForAllMesages(final boolean selected) {
            for (MessageInfoHolder message : mMessages) {
                message.selected = selected;
            }

            notifyDataSetChanged();
        }

        public void addMessages(final List<MessageInfoHolder> messages) {
            if (messages.isEmpty()) {
                return;
            }

            final boolean wasEmpty = mMessages.isEmpty();

            for (final MessageInfoHolder message : messages) {
                if (mFolderName == null || (message.folder != null && message.folder.name.equals(mFolderName))) {
                    int index = Collections.binarySearch(mMessages, message, getComparator());

                    if (index < 0) {
                        index = (index * -1) - 1;
                    }

                    mMessages.add(index, message);
                }
            }

            if (wasEmpty) {
                mListView.setSelection(0);
            }
            resetUnreadCount();

            notifyDataSetChanged();
            computeSelectAllVisibility();
        }

        public void changeMessageUid(MessageReference ref, String newUid) {
            MessageInfoHolder holder = getMessage(ref);
            if (holder != null) {
                holder.uid = newUid;
                holder.message.setUid(newUid);
            }
        }

        public void resetUnreadCount() {
            if (mQueryString != null) {
                int unreadCount = 0;

                for (MessageInfoHolder holder : mMessages) {
                    unreadCount += holder.read ? 0 : 1;
                }

                mUnreadMessageCount = unreadCount;
                refreshTitle();
            }
        }

        public void sortMessages() {
            final Comparator<MessageInfoHolder> chainComparator = getComparator();

            Collections.sort(mMessages, chainComparator);

            notifyDataSetChanged();
        }

        public void addOrUpdateMessages(final Account account, final String folderName,
                final List<Message> messages, final boolean verifyAgainstSearch) {

            boolean needsSort = false;
            final List<MessageInfoHolder> messagesToAdd = new ArrayList<MessageInfoHolder>();
            List<MessageInfoHolder> messagesToRemove = new ArrayList<MessageInfoHolder>();
            List<Message> messagesToSearch = new ArrayList<Message>();

            // cache field into local variable for faster access for JVM without JIT
            final MessageHelper messageHelper = mMessageHelper;

            for (Message message : messages) {
                MessageInfoHolder m = getMessage(message);
                if (message.isSet(Flag.DELETED)) {
                    if (m != null) {
                        messagesToRemove.add(m);
                    }
                } else {
                    final Folder messageFolder = message.getFolder();
                    final Account messageAccount = messageFolder.getAccount();
                    if (m == null) {
                        if (updateForMe(account, folderName)) {
                            m = new MessageInfoHolder();
                            FolderInfoHolder folderInfoHolder = new FolderInfoHolder(
                                    getActivity(), messageFolder, messageAccount);
                            messageHelper.populate(m, message, folderInfoHolder, messageAccount);
                            messagesToAdd.add(m);
                        } else {
                            if (mQueryString != null) {
                                if (verifyAgainstSearch) {
                                    messagesToSearch.add(message);
                                } else {
                                    m = new MessageInfoHolder();
                                    FolderInfoHolder folderInfoHolder = new FolderInfoHolder(
                                            getActivity(), messageFolder, messageAccount);
                                    messageHelper.populate(m, message, folderInfoHolder,
                                            messageAccount);
                                    messagesToAdd.add(m);
                                }
                            }
                        }
                    } else {
                        m.dirty = false; // as we reload the message, unset its dirty flag
                        FolderInfoHolder folderInfoHolder = new FolderInfoHolder(getActivity(),
                                messageFolder, account);
                        messageHelper.populate(m, message, folderInfoHolder, account);
                        needsSort = true;
                    }
                }
            }

            if (!messagesToSearch.isEmpty()) {
                mController.searchLocalMessages(mAccountUuids, mFolderNames,
                        messagesToSearch.toArray(EMPTY_MESSAGE_ARRAY), mQueryString, mIntegrate,
                        mQueryFlags, mForbiddenFlags,
                new MessagingListener() {
                    @Override
                    public void listLocalMessagesAddMessages(Account account, String folder,
                            List<Message> messages) {
                        mHandler.addOrUpdateMessages(account, folder, messages, false);
                    }
                });
            }

            if (!messagesToRemove.isEmpty()) {
                removeMessages(messagesToRemove);
            }

            if (!messagesToAdd.isEmpty()) {
                addMessages(messagesToAdd);
            }

            if (needsSort) {
                sortMessages();
                resetUnreadCount();
            }
        }

        /**
         * Find a specific message in the message list.
         *
         * <p><strong>Note:</strong>
         * This method was optimized because it is called a lot. Don't change it unless you know
         * what you are doing.</p>
         *
         * @param message
         *         A {@link Message} instance describing the message to look for.
         *
         * @return The corresponding {@link MessageInfoHolder} instance if the message was found in
         *         the message list. {@code null} otherwise.
         */
        private MessageInfoHolder getMessage(Message message) {
            String uid;
            Folder folder;
            for (MessageInfoHolder holder : mMessages) {
                uid = message.getUid();
                if (uid != null && (holder.uid == uid || uid.equals(holder.uid))) {
                    folder = message.getFolder();
                     if (holder.folder.name.equals(folder.getName()) &&
                             holder.account.equals(folder.getAccount().getUuid())) {
                         return holder;
                     }
                }
            }

            return null;
        }

        /**
         * Find a specific message in the message list.
         *
         * <p><strong>Note:</strong>
         * This method was optimized because it is called a lot. Don't change it unless you know
         * what you are doing.</p>
         *
         * @param messageReference
         *         A {@link MessageReference} instance describing the message to look for.
         *
         * @return The corresponding {@link MessageInfoHolder} instance if the message was found in
         *         the message list. {@code null} otherwise.
         */
        private MessageInfoHolder getMessage(MessageReference messageReference) {
            String uid;
            for (MessageInfoHolder holder : mMessages) {
                uid = messageReference.uid;
                if ((holder.uid == uid || uid.equals(holder.uid)) &&
                        holder.folder.name.equals(messageReference.folderName) &&
                        holder.account.equals(messageReference.accountUuid)) {
                     return holder;
                }
            }

            return null;
        }

        public FolderInfoHolder getFolder(String folder, Account account) {
            LocalFolder local_folder = null;
            try {
                LocalStore localStore = account.getLocalStore();
                local_folder = localStore.getFolder(folder);
                return new FolderInfoHolder(getActivity(), local_folder, account);
            } catch (Exception e) {
                Log.e(K9.LOG_TAG, "getFolder(" + folder + ") goes boom: ", e);
                return null;
            } finally {
                if (local_folder != null) {
                    local_folder.close();
                }
            }
        }


        @Override
        public int getCount() {
            return mMessages.size();
        }

        @Override
        public long getItemId(int position) {
            try {
                MessageInfoHolder messageHolder = (MessageInfoHolder) getItem(position);
                if (messageHolder != null) {
                    return messageHolder.message.getId();
                }
            } catch (Exception e) {
                Log.i(K9.LOG_TAG, "getItemId(" + position + ") ", e);
            }
            return -1;
        }

        @Override
        public Object getItem(int position) {
            try {
                if (position < mMessages.size()) {
                    return mMessages.get(position);
                }
            } catch (Exception e) {
                Log.e(K9.LOG_TAG, "getItem(" + position + "), but folder.messages.size() = " + mMessages.size(), e);
            }
            return null;
        }

        @Override
        public View getView(int position, View convertView, ViewGroup parent) {
            MessageInfoHolder message = (MessageInfoHolder) getItem(position);
            View view;

            if ((convertView != null) && (convertView.getId() == R.layout.message_list_item)) {
                view = convertView;
            } else {
                view = mInflater.inflate(R.layout.message_list_item, parent, false);
                view.setId(R.layout.message_list_item);
            }

            MessageViewHolder holder = (MessageViewHolder) view.getTag();

            if (holder == null) {
                holder = new MessageViewHolder();
                holder.date = (TextView) view.findViewById(R.id.date);
                holder.chip = view.findViewById(R.id.chip);
                holder.selected = (CheckBox) view.findViewById(R.id.selected_checkbox);
                holder.preview = (TextView) view.findViewById(R.id.preview);
                if (mCheckboxes) {
                    holder.selected.setVisibility(View.VISIBLE);
                }

                if (holder.selected != null) {
                    holder.selected.setOnCheckedChangeListener(holder);
                }


                if (mSenderAboveSubject) {
                    holder.from = (TextView) view.findViewById(R.id.subject);
                    holder.from.setTextSize(TypedValue.COMPLEX_UNIT_SP, mFontSizes.getMessageListSender());
                } else {
                    holder.subject = (TextView) view.findViewById(R.id.subject);
                    holder.subject.setTextSize(TypedValue.COMPLEX_UNIT_SP, mFontSizes.getMessageListSubject());
                }

                holder.date.setTextSize(TypedValue.COMPLEX_UNIT_SP, mFontSizes.getMessageListDate());

                holder.preview.setLines(mPreviewLines);
                holder.preview.setTextSize(TypedValue.COMPLEX_UNIT_SP, mFontSizes.getMessageListPreview());

                view.setTag(holder);
            }

            if (message != null) {
                bindView(position, view, holder, message);
            } else {
                // This branch code is triggered when the local store
                // hands us an invalid message

                holder.chip.getBackground().setAlpha(0);
                if (holder.subject != null) {
                    holder.subject.setText(getString(R.string.general_no_subject));
                    holder.subject.setTypeface(null, Typeface.NORMAL);
                }

                String noSender = getString(R.string.general_no_sender);

                if (holder.preview != null) {
                    holder.preview.setText(noSender, TextView.BufferType.SPANNABLE);
                    Spannable str = (Spannable) holder.preview.getText();

                    str.setSpan(new StyleSpan(Typeface.NORMAL),
                                0,
                                noSender.length(),
                                Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
                    str.setSpan(new AbsoluteSizeSpan(mFontSizes.getMessageListSender(), true),
                                0,
                                noSender.length(),
                                Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
                } else {
                    holder.from.setText(noSender);
                    holder.from.setTypeface(null, Typeface.NORMAL);
                    holder.from.setCompoundDrawablesWithIntrinsicBounds(null, null, null, null);
                }

                holder.date.setText(getString(R.string.general_no_date));

                //WARNING: Order of the next 2 lines matter
                holder.position = -1;
                holder.selected.setChecked(false);

                if (!mCheckboxes) {
                    holder.selected.setVisibility(View.GONE);
                }
            }


            return view;
        }

        /**
         * Associate model data to view object.
         *
         * @param position
         *            The position of the item within the adapter's data set of
         *            the item whose view we want.
         * @param view
         *            Main view component to alter. Never <code>null</code>.
         * @param holder
         *            Convenience view holder - eases access to <tt>view</tt>
         *            child views. Never <code>null</code>.
         * @param message
         *            Never <code>null</code>.
         */



        private void bindView(final int position, final View view, final MessageViewHolder holder,
                              final MessageInfoHolder message) {

            int maybeBoldTypeface = message.read ? Typeface.NORMAL : Typeface.BOLD;

            // So that the mSelectedCount is only incremented/decremented
            // when a user checks the checkbox (vs code)
            holder.position = -1;

            holder.selected.setChecked(message.selected);

            if (!mCheckboxes && message.selected) {

                holder.chip.setBackgroundDrawable(message.message.getFolder().getAccount().getCheckmarkChip().drawable());
            }

            else {
                holder.chip.setBackgroundDrawable(message.message.getFolder().getAccount().generateColorChip(message.read,message.message.toMe(), message.message.ccMe(), message.message.fromMe(), message.flagged).drawable());

            }

            if (K9.useBackgroundAsUnreadIndicator()) {
                int res = (message.read) ? R.attr.messageListReadItemBackgroundColor :
                        R.attr.messageListUnreadItemBackgroundColor;

                TypedValue outValue = new TypedValue();
                getActivity().getTheme().resolveAttribute(res, outValue, true);
                view.setBackgroundColor(outValue.data);
            }

            String subject = null;

            if ((message.message.getSubject() == null) || message.message.getSubject().equals("")) {
                subject = (String) getText(R.string.general_no_subject);

            } else {
                subject = message.message.getSubject();
            }

            // We'll get badge support soon --jrv
//            if (holder.badge != null) {
//                String email = message.counterpartyAddress;
//                holder.badge.assignContactFromEmail(email, true);
//                if (email != null) {
//                    mContactsPictureLoader.loadContactPicture(email, holder.badge);
//                }
//            }

            if (holder.preview != null) {
                /*
                 * In the touchable UI, we have previews. Otherwise, we
                 * have just a "from" line.
                 * Because text views can't wrap around each other(?) we
                 * compose a custom view containing the preview and the
                 * from.
                 */

                CharSequence beforePreviewText = null;
                if (mSenderAboveSubject) {
                    beforePreviewText = subject;
                } else {
                    beforePreviewText = message.sender;
                }

                holder.preview.setText(new SpannableStringBuilder(recipientSigil(message))
                                       .append(beforePreviewText).append(" ").append(message.message.getPreview()),
                                       TextView.BufferType.SPANNABLE);
                Spannable str = (Spannable)holder.preview.getText();

                // Create a span section for the sender, and assign the correct font size and weight.
                str.setSpan(new AbsoluteSizeSpan((mSenderAboveSubject ? mFontSizes.getMessageListSubject(): mFontSizes.getMessageListSender()), true),
                            0, beforePreviewText.length() + 1, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);

                int color = (K9.getK9Theme() == K9.THEME_LIGHT) ?
                        Color.rgb(105, 105, 105) :
                        Color.rgb(160, 160, 160);

                // set span for preview message.
                str.setSpan(new ForegroundColorSpan(color), // How do I can specify the android.R.attr.textColorTertiary
                            beforePreviewText.length() + 1,
                            str.length(),
                            Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
            }


            if (holder.from != null ) {
                holder.from.setTypeface(null, maybeBoldTypeface);
                if (mSenderAboveSubject) {
                    holder.from.setCompoundDrawablesWithIntrinsicBounds(
                            message.answered ? mAnsweredIcon : null, // left
                            null, // top
                            message.message.hasAttachments() ? mAttachmentIcon : null, // right
                            null); // bottom

                    holder.from.setText(message.sender);
                } else {
                    holder.from.setText(new SpannableStringBuilder(recipientSigil(message)).append(message.sender));
                }
            }

            if (holder.subject != null ) {
                if (!mSenderAboveSubject) {
                    holder.subject.setCompoundDrawablesWithIntrinsicBounds(
                            message.answered ? mAnsweredIcon : null, // left
                            null, // top
                            message.message.hasAttachments() ? mAttachmentIcon : null, // right
                            null); // bottom
                }

                holder.subject.setTypeface(null, maybeBoldTypeface);
                holder.subject.setText(subject);
            }

            holder.date.setText(message.getDate(mMessageHelper));
            holder.position = position;
        }


        private String recipientSigil(MessageInfoHolder message) {
            if (message.message.toMe()) {
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_b06096;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_a06096;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_c06096
<<<<<<< MINE
        public TextView threadCount;
=======
        public CheckBox selected;
        public int position = -1;

        @Override
        public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
            if (position != -1) {
                MessageInfoHolder message = (MessageInfoHolder) mAdapter.getItem(position);
                    toggleMessageSelect(message);


            }
        }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_b12108;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_a12108;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_c12108
<<<<<<< MINE
=======

    public static void testSinglePart7BitNoRecurse() throws Exception {
        MimeMessage msg = parseWithoutRecurse(toStream(
                "From: <adam@example.org>\r\n" +
                "To: <eva@example.org>\r\n" +
                "Subject: Testmail\r\n" +
                "MIME-Version: 1.0\r\n" +
                "Content-type: text/plain\r\n" +
                "Content-Transfer-Encoding: 7bit\r\n" +
                "\r\n" +
                "this is some test text."));

        checkAddresses(msg.getFrom(), "adam@example.org");
        checkAddresses(msg.getRecipients(RecipientType.TO), "eva@example.org");
        assertEquals("Testmail", msg.getSubject());
        assertEquals("text/plain", msg.getContentType());
        assertEquals("this is some test text.", streamToString(MimeUtility.decodeBody(msg.getBody())));
    }

    public static void testSinglePart8BitRecurse() throws Exception {
        MimeMessage msg = parseWithRecurse(toStream(
                "From: <adam@example.org>\r\n" +
                "To: <eva@example.org>\r\n" +
                "Subject: Testmail\r\n" +
                "MIME-Version: 1.0\r\n" +
                "Content-type: text/plain; encoding=ISO-8859-1\r\n" +
                "Content-Transfer-Encoding: 8bit\r\n" +
                "\r\n" +
                "gefhrliche Umlaute"));

        checkAddresses(msg.getFrom(), "adam@example.org");
        checkAddresses(msg.getRecipients(RecipientType.TO), "eva@example.org");
        assertEquals("Testmail", msg.getSubject());
        assertEquals("text/plain; encoding=ISO-8859-1", msg.getContentType());
        assertEquals("gefhrliche Umlaute", streamToString(MimeUtility.decodeBody(msg.getBody())));
    }

    public static void testSinglePartBase64NoRecurse() throws Exception {
        MimeMessage msg = parseWithoutRecurse(toStream(
                "From: <adam@example.org>\r\n" +
                "To: <eva@example.org>\r\n" +
                "Subject: Testmail\r\n" +
                "MIME-Version: 1.0\r\n" +
                "Content-type: text/plain\r\n" +
                "Content-Transfer-Encoding: base64\r\n" +
                "\r\n" +
                "dGhpcyBpcyBzb21lIG1vcmUgdGVzdCB0ZXh0Lg==\r\n"));

        checkAddresses(msg.getFrom(), "adam@example.org");
        checkAddresses(msg.getRecipients(RecipientType.TO), "eva@example.org");
        assertEquals("Testmail", msg.getSubject());
        assertEquals("text/plain", msg.getContentType());
        assertEquals("this is some more test text.", streamToString(MimeUtility.decodeBody(msg.getBody())));
    }

    public static void testMultipartSingleLayerNoRecurse() throws Exception {
        MimeMessage msg = parseWithoutRecurse(toStream(
                "From: <x@example.org>\r\n" +
                "To: <y@example.org>\r\n" +
                "Subject: Testmail 2\r\n" +
                "MIME-Version: 1.0\n" +
                "Content-Type: multipart/mixed; boundary=frontier\n" +
                "\n" +
                "This is a message with multiple parts in MIME format.\n" +
                "--frontier\n" +
                "Content-Type: text/plain\n" +
                "\n" +
                "This is the body of the message.\n" +
                "--frontier\n" +
                "Content-Type: application/octet-stream\n" +
                "Content-Transfer-Encoding: base64\n" +
                "\n" +
                "PGh0bWw+CiAgPGhlYWQ+CiAgPC9oZWFkPgogIDxib2R5PgogICAgPHA+VGhpcyBpcyB0aGUg\n" +
                "Ym9keSBvZiB0aGUgbWVzc2FnZS48L3A+CiAgPC9ib2R5Pgo8L2h0bWw+Cg=\n" +
                "--frontier--"));

        checkAddresses(msg.getFrom(), "x@example.org");
        checkAddresses(msg.getRecipients(RecipientType.TO), "y@example.org");
        assertEquals("Testmail 2", msg.getSubject());
        assertEquals("multipart/mixed; boundary=frontier", msg.getContentType());
        checkLeafParts(msg,
                "This is the body of the message.",
                "<html>\n" +
                "  <head>\n" +
                "  </head>\n" +
                "  <body>\n" +
                "    <p>This is the body of the message.</p>\n" +
                "  </body>\n" +
                "</html>\n" +
                "");
    }

    public static void testMultipartSingleLayerRecurse() throws Exception {
        MimeMessage msg = parseWithRecurse(toStream(
                "From: <x@example.org>\r\n" +
                "To: <y@example.org>\r\n" +
                "Subject: Testmail 2\r\n" +
                "MIME-Version: 1.0\n" +
                "Content-Type: multipart/mixed; boundary=frontier\n" +
                "\n" +
                "This is a message with multiple parts in MIME format.\n" +
                "--frontier\n" +
                "Content-Type: text/plain\n" +
                "\n" +
                "This is the body of the message.\n" +
                "--frontier\n" +
                "Content-Type: application/octet-stream\n" +
                "Content-Transfer-Encoding: base64\n" +
                "\n" +
                "PGh0bWw+CiAgPGhlYWQ+CiAgPC9oZWFkPgogIDxib2R5PgogICAgPHA+VGhpcyBpcyB0aGUg\n" +
                "Ym9keSBvZiB0aGUgbWVzc2FnZS48L3A+CiAgPC9ib2R5Pgo8L2h0bWw+Cg=\n" +
                "--frontier--"));

        checkAddresses(msg.getFrom(), "x@example.org");
        checkAddresses(msg.getRecipients(RecipientType.TO), "y@example.org");
        assertEquals("Testmail 2", msg.getSubject());
        assertEquals("multipart/mixed; boundary=frontier", msg.getContentType());
        checkLeafParts(msg,
                "This is the body of the message.",
                "<html>\n" +
                "  <head>\n" +
                "  </head>\n" +
                "  <body>\n" +
                "    <p>This is the body of the message.</p>\n" +
                "  </body>\n" +
                "</html>\n" +
                "");
    }

    public static void testMultipartTwoLayersRecurse() throws Exception {
        MimeMessage msg = parseWithRecurse(toStream(
                "From: <x@example.org>\r\n" +
                "To: <y@example.org>\r\n" +
                "Subject: Testmail 2\r\n" +
                "MIME-Version: 1.0\n" +
                "Content-Type: multipart/mixed; boundary=1\n" +
                "\n" +
                "This is a message with multiple parts in MIME format.\n" +
                "--1\n" +
                "Content-Type: text/plain\n" +
                "\n" +
                "some text in the first part\n" +
                "--1\n" +
                "Content-Type: multipart/alternative; boundary=2\n" +
                "\n" +
                "--2\n" +
                "Content-Type: text/plain\n" +
                "\n" +
                "alternative 1\n" +
                "--2\n" +
                "Content-Type: text/plain\n" +
                "\n" +
                "alternative 2\n" +
                "--2--\n" +
                "--1--"));

        checkAddresses(msg.getFrom(), "x@example.org");
        checkAddresses(msg.getRecipients(RecipientType.TO), "y@example.org");
        assertEquals("Testmail 2", msg.getSubject());
        assertEquals("multipart/mixed; boundary=1", msg.getContentType());
        checkLeafParts(msg,
                "some text in the first part",
                "alternative 1",
                "alternative 2");
    }

>>>>>>> YOURS
