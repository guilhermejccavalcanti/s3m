\documentclass[../../Algorithms.tex]{subfiles}

%TODO: make notation compatible with Merge.tex's notation
\begin{document}
    \section{Renaming Handler}
    \subsection{Early Concepts}

    \subsubsection{Possibly renamed without body changes nodes}

    $R_{wobc}(T, B) = \{ b \in B \mid (\lnot \exists t \in T) (t.id = b.id)) \land (\exists t \in T) (t.body = b.body)\}$

    \subsubsection{Possibly deleted or renamed with body changes nodes}

    $DR_{wbc}(T, B) = \{ b \in B \mid (\lnot \exists t \in T) (t.id = b.id \lor t.body = b.body)\}$

    \subsubsection{Nodes IDs similarity}

    $a.id \approx b.id \leftrightarrow a.id.name = b.id.name \lor a.id.params = b.id.params$

    \subsection{Match Algorithm}
    
    \begin{algorithm}[H]
        \caption{Match Algorithm}
        \SetAlgoLined

        \KwIn{L, B, R, M}
        \KwOut{Set of quadruples $(l, b, r, m)$ consisting of the base node $b$ and its corresponding left node $l$, right node $r$ and merge node $m$}
        
        \BlankLine
        \SetKwFunction{cn}{correspondentNode}
        \SetKwFunction{mn}{mergeNode}
        
        $matches \leftarrow \emptyset$\;
        \ForEach{$b \in DR_{wbc}(L, B) \cup DR_{wbc}(R, B) \cup R_{wobc}(L, B) \cup R_{wobc}(R, B)$}{
            $l \leftarrow \cn{b, L}$\;
            $r \leftarrow \cn{b, R}$\;
            $m \leftarrow$ \colorbox{red}{$\mn{l, r, M}$}\;
            $matches \leftarrow matches \cup (l, b, r, m)$\;
        }

        \BlankLine
        \KwRet{matches}
    \end{algorithm}

    \begin{algorithm}[H]
        \caption{Correspondent Node}

        \KwIn{b, T}
        \KwOut{b's correspondent node on tree T}

        \BlankLine
        $t \leftarrow findFirst(t \in T \rightarrow t.id = b.id)$\;
            
        \BlankLine
        \If{t = null}{
            $t \leftarrow findFirst(t \in T \rightarrow t.body = b.body)$\;
        }
            
        \BlankLine
        \If{t = null}{
            $t \leftarrow findFirst(t \in T \rightarrow t.body \approx b.body \land t.id \approx b.id)$\;
        }
            
        \BlankLine
        \If{t = null}{
            $t \leftarrow findFirst(t \in T \rightarrow t.body = substring(b.body) \lor b.body = substring(t.body))$\;
        }

        \BlankLine
        \KwRet{t}\;
    \end{algorithm}

    \begin{algorithm}[H]
        \caption{Merge Node}

        \KwIn{\colorbox{red}{l, r, M}}
        \KwOut{l and r's merge node on tree M}

        \BlankLine
        \If{$l \neq null$}{
            \KwRet{$find(m \in M \rightarrow m.id = l.id)$}\;
        }

        \BlankLine
        \If{$r \neq null$}{
            \KwRet{$find(m \in M \rightarrow m.id = r.id)$}\;
        }

        \BlankLine
        \KwRet{null}\;
    \end{algorithm}

    \subsection{Handle Algorithms}

    \SetKwFunction{srd}{singleRenamingOrDeletion}
    \SetKwFunction{run}{removeUnmatchedNode}

    \begin{algorithm}[H]
        \caption{Check References and Merge Methods Variant}

        \SetKwFunction{nrt}{newReferenceTo}

        \KwIn{\colorbox{red}{(l, b, r, m), M}}

        \BlankLine
        \uIf{$l.id = b.id \lor r.id = b.id$}{
            $m.body = textualMerge(l, b, r)$\;
            \colorbox{red}{\run{l, r, m, M}}\;
        }
        \uElseIf{$l.id \neq r.id$}{
            $m.body = conflit(l, b, r)$\;
            \colorbox{red}{\run{l, r, m, M}}\;
        }
        \ElseIf{$l.body \neq r.body$}{
            \uIf{$\nrt{l} \lor \nrt{r}$}{
                $m.body = conflict(l, b, r)$\;
            }
            \Else{
                $m.body = textualMerge(l, b, r)$\;
            }

            \BlankLine
            \colorbox{red}{\run{l, r, m, M}}\;
        }
    \end{algorithm}
    
    \begin{algorithm}[H]
        \caption{Merge Methods Variant}

        \KwIn{\colorbox{red}{(l, b, r, m), M}}

        \BlankLine
        \colorbox{red}{$m.body = textualMerge(l, b, r)$}\;

        \colorbox{red}{\run{l, r, m, M}}\;
    \end{algorithm}
    
    \begin{algorithm}[H]
        \caption{Check Textual and Keep Both Methods Variant}
        
        \KwIn{\colorbox{red}{(l, b, r, m), M}}
        
        \BlankLine
        \SetKwFunction{tmhcis}{textualMergeHasConflictInvolvingSignature}
        
        \uIf{$l.id = b.id \lor r.id = b.id$}{
            \If{\tmhcis{b}}{
                $m.body = conflict(l, b, r)$\;
                \colorbox{red}{\run{l, r, m, M}}\;
            }
        }
        \ElseIf{\colorbox{red}{$l.id \neq r.id \land l.body = r.body$}}{
            $m.body = conflict(l, b, r)$\;
            \colorbox{red}{\run{l, r, m, M}}\;
        }
    \end{algorithm}
    
    \begin{algorithm}[H]
        \caption{Keep Both Methods Variant}
        
        \KwIn{\colorbox{red}{(l, b, r, m), M}}
        
        \BlankLine
        \SetKwFunction{hc}{hasConflict}
        
        \If{$(l.id = b.id \lor r.id = b.id) \land \hc{m}$}{
            $removeConflict(m)$\;
        }
    \end{algorithm}

    \begin{algorithm}[H]
        \caption{Remove Unmatched Node}

        \KwIn{l, r, m, M}

        \BlankLine
        \If{$l.id = m.id \land r.id \neq m.id$}{
            \rn{r, M}\;
        }
    \end{algorithm}
\end{document}